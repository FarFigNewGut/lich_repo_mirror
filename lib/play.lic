=begin

  Play - a script for playing Shattered

  Play gets bounties and tries to complete them.  When it doesn't have a
  bounty, it hunts with bigshot and rests in the Shattered Nexus.  It interacts
  with the bots there, getting spells, mana, healing, lockpicking and more.

  For a list of commands and settings, type ;play help
  For more information about getting started, type ;play setup

  author: Air

=end

# Hunting areas.  These are used to configure bigshot's targets, hunting room and boundaries.
# The format to add an area is [[creatures], room_in_nearest_town, hunting_room, [hunting_boundaries], options...]
# creatures are '<level><flags>: <name>'
# flags are u for undead, b for carries boxes, f for flee
# more dangerous targets should be listed first, in case priority targeting is used
# options can be
#  :no_boss_bounties for areas where boss critters can wander outside the hunting boundaries
#  :no_rescue_bounties for areas where child2 fails to step its way home one room at a time
#  :dont_get_spellups is used for the Rift to prevent nudging for spells between hunts
#  :interior_rooms means that the list of boundary rooms is replaced with a list of hunting rooms
hunting_areas = [
	[["1: ant"], 223, 7583, [7575, 7582], :no_boss_bounties],
	[["3b: dark vysan"], 223, 7734, [7694, 7755]],
	[["8b: greater burrow orc"], 223, 7950, [7949, 7965]],
	[["9ub: snow spectre"], 3234, 3014, [3013, 3026]],
	[["13ub: darkwoode", "10ub: werebear", "8b: greater orc"], 223, 8508, [8435]],
	[["15u: wolfshade"], 223, 8461, [8460, 8471]],
	[["16b: hill troll"], 223, 6836, [6835]],
	[["18ub: nedum vereri"], 223, 8471, [8470]],
	[["20b: steel golem"], 223, 7824, [7823]],
	[["23ub: zombie"], 223, 7874, [7873]],
	[["25b: krolvin warfarer"], 223, 6437, [6428]],
	[["28: dobrem"], 1425, 5496, [5495]],
	[["35u: spectral woodsman", "32u: rotting farmhand", "30uf: elder tree spirit"], 2486, 3126, [3125]],
	[["41u: skeletal lord", "37u: skeletal warhorse"], 223, 14037, [14036, 15991]],
	[["42u: phantasma", "41u: skeletal lord"], 223, 15991, [14070]],
	[["48: kiramon defender", "40: kiramon worker"], 223, 7120, [*7120..7146], :interior_rooms, :no_rescue_bounties, :no_boss_bounties],
	[["53b: stone sentinel", "50ub: banshee"], 223, 3686, [3698, 7070, 7071], :no_rescue_bounties],
	[["55u: eidolon", "49u: waern", "48ub: dybbuk"], 1437, 5413, [5411, 13023]],
	[["58b: stone giant", "55b: stone troll"], 223, 3576, [3574, 3578, 3834, 3839]],
	[["63b: troll king", "63b: Sheruvian harbinger", "55u: nightmare steed", "0: quickly growing troll king", "0: strange pulsing mass", "0: severed troll leg", "0: severed troll arm"], 223, 3699, [3698, 3817, 3818], :no_rescue_bounties],
	[["72: krag dweller", "70b: krag yeti"], 223, 6136, [6135, 6152], :no_boss_bounties],
	[["74b: lesser minotaur"], 223, 6152, [6141, 6191], :no_boss_bounties],
	[["78b: minotaur magus", "76b: minotaur warrior", "74b: lesser minotaur"], 223, 6191, [9651]],
	[["84b: greater krynch", "82: ^earth elemental"], 223, 8375, [8374], :no_boss_bounties],
	[["87ub: n'ecare", "86: aivren", "84b: Vvrael warlock"], 2635, 12093, [*2595..2597, 2611, *2616..2618, *12091..12094, *12174..12205, *12212..12214, 12216, 12218, *12221..12227], :interior_rooms, :no_boss_bounties, :no_rescue_bounties, :dont_get_spellups],
	[["89b: Illoke jarl", "88: greater earth elemental", "86: Illoke elder", "85: being", "84b: greater krynch", "82: earth elemental"], 223, 8429, [3839]],
	[["93u: vaespilon", "91u: lost soul", "87ub: n'ecare"], 2635, 12160, [12159, 12160, 12162, 12165, 12170, 12173, *12206..12211, 12215], :interior_rooms, :no_boss_bounties, :no_rescue_bounties, :dont_get_spellups],
	[["100b: triton radical", "98u: spectral triton defender", "98: triton combatant", "96b: siren", "96b: triton executioner"], nil, 12744, [*12694..12700, *12720..12725, *12730..12748], :interior_rooms, :no_boss_bounties],
	[["105: greater water elemental", "103u: ethereal triton sentry", "102b: triton magus", "100b: triton radical", "98u: spectral triton defender", "98: triton combatant"], nil, 12749, [*12749..12762], :interior_rooms, :no_boss_bounties],
	[["110ub: frostborne lich", "110ub: infernal lich", "108b: Vvrael destroyer", "106ub: murky soul siphon", "104b: darkly inked fetish master", "100b: glistening cerebralite"], 2635, 12229, [12217, 12219, 12220, *12228..12247, *12249..12251, *12253..12256], :interior_rooms, :no_boss_bounties, :no_rescue_bounties, :dont_get_spellups],
]

# Adjustable knobs.
skip_creature_bounties = ['triton executioner'] # don't do bounties that require killing these creatures
search_boundaries = [12701, 12749] # extra rooms to treat as boundaries for SEARCH bounties
bandit_exclude = [12532, 12533, 14729] # extra rooms to exclude for bandit bounties
quick_spellup_time = 45 # keep at least this many minutes on spells (in addition to a full waggle after hunting)
self_cast_list = [101, 102, 103, 107, 115, 120, 202, 211, 215, 219, 303, 307, 310, 313, 401, 406, 414, 425, 430, 503, 507, 508, 509, 513, 520, 540, 601, 602, 606, 613, 617, 618, 625, 640, 704, 712, 716, 905, 911, 913, 920, 1003, 1006, 1007, 1010, 1019, 1109, 1119, 1125, 1130, 1601, 1606, 1610, 1611, 1612, 1616] # spells to cast on ourselves
nudge_cast_list = [101, 103, 107, 202, 401, 406, 414, 503, 509, 602, 618, 1204, 1601] # spells to cast on others when nudged
mass_spell_list = [611, 911] # spells to cast when resting, joined to a group and we have spare mana that will be wasted on the next pulse
mass_spell_delay = 10 # minutes to wait between casts of a mass spell
teleportation_spell_list = [130] # spells that can be used to return from the Rift and Nelemar
trash_loot_types = %w(clothing food junk) # trash items of these types in our lootsack if they don't get sold
nexus_room = 20239 # resting room (must be a number)
nexus_trash = 'narrow fissure' # trash receptacle in resting room
table_room = 20726 # room with tables
group_pcs = %w(Tyrean Bruiser Wreck Nexushealbot) # players that can be joined while resting in the Nexus
min_deeds = 10 # get more deeds when the player has fewer than this many and the get-deeds setting is on
max_deeds = 30 # when getting more deeds, stop once the player has this many

# Determine the game instance.
if XMLData.game == 'unknown'
	if ARGV.include?('--reconnect')
		echo('Unknown game instance.  Reconnecting...')
		loop { put('quit'); sleep(1) }
	else
		echo('Unknown game instance.  Please reconnect.')
		exit
	end
end
gsf = (XMLData.game == 'GSF')

# Set a nonce so helper scripts can detect if we restarted.
$play_instance = Random.new.bytes(16)

# Check if helper scripts are installed.
required_scripts = %w(bigshot go2 loot-be-gone useherbs waggle)
required_scripts_missing = required_scripts.select { |s| !Script.exists?(s) }
if required_scripts_missing.count > 0
	echo("You must also download the following script#{required_scripts_missing.count > 1 ? 's' : ''} to use play:  " + required_scripts_missing.join(', '))
	exit
end

# Check that bigshot is new enough.
version_line = File.readlines("#{SCRIPT_DIR}/bigshot.lic").find { |l| l =~ /^BIGSHOT_VERSION = '(\d\.\d+)'/ }
if !version_line.nil? && $1.to_f < 3.80
	echo('You must update to a newer version of bigshot to use play.')
	exit
end

# Check that variables are set up.
if Vars.lootsack.nil? || GameObj[Vars.lootsack].nil?
	echo("Can't find your lootsack.  Set it with ;var set lootsack=whatever")
	exit
end
if GameObj[XMLData.stow_container_id].nil?
	echo("Can't find your stow container.  Set it with STOW SET whatever")
	exit
end
if Vars.op.nil?
	echo("Bigshot isn't configured.  Run ;bigshot setup")
	exit
end

# Load default settings.
char_settings = CharSettings.to_hash
defaults = {
	'adjust-difficulty' => true,
	'alfred-gems' => gsf,
	'attack' => ';bigshot quick',
	'boost-absorb' => gsf,
	'boost-experience' => gsf,
	'boost-longterm' => gsf,
	'boost-loot' => gsf,
	'collectibles' => true,
	'fried-bounties' => true,
	'get-spellups' => gsf,
	'give-spellups' => gsf,
	'kill-creatures' => true,
	'kill-dangerous-creature' => true,
	'locksmith-pool' => gsf,
	'percentmind' => 75,
	'percentspirit' => 75,
	'procure-gems' => true,
	'procure-skins' => true,
	'rescue-child' => true,
	'retrieve-heirloom-loot' => true,
	'retrieve-heirloom-search' => true,
	'share-mana' => gsf,
	'symbol-blessing' => true,
}
for k, v in defaults
	char_settings[k] = v if char_settings[k].nil?
end

# Parse options.
script_name = script.name.dup
stop_script = false
$play_command = proc { |opt|
	cmd = "#{$clean_lich_char}#{script_name}"

	respond("")
	if opt =~ /^1009=(.+)$/i
		if (char_settings['1009'] = ($1 == 'nil') ? nil : $1)
			respond("Now singing a shield of type #{char_settings['1009']}.")
		else
			respond("No longer singing a shield.")
		end
	elsif opt =~ /^1012=(.+)$/i
		if (char_settings['1012'] = ($1 == 'nil') ? nil : $1)
			respond("Now singing a weapon of type #{char_settings['1012']}.")
		else
			respond("No longer singing a weapon.")
		end
	elsif opt =~ /^1014=(\d+|nil)$/i
		if (char_settings['1014'] = ($1 == 'nil') ? nil : $1)
			respond("Now singing armor of AsG #{char_settings['1014']}.")
		else
			respond("No longer singing armor.")
		end
	elsif opt =~ /^adjust-difficulty=(yes|no)$/i
		if (char_settings['adjust-difficulty'] = ($1 =~ /y/i) ? true : false)
			respond("Now adjusting bounty difficulty when getting bounties for hunting areas loaded with ;play hunt.")
		else
			respond("No longer adjusting bounty difficulty.")
		end
	elsif opt =~ /^alfred-gems=(yes|no)$/i && gsf
		if (char_settings['alfred-gems'] = ($1 =~ /y/i) ? true : false)
			respond("Now giving gems to Alfred.")
		else
			respond("No longer giving gems to Alfred.")
		end
	elsif opt =~ /^attack=(.+)$/i
		if (char_settings['attack'] = ($1 == 'nil') ? nil : $1)
			respond("Attack commands set to: #{char_settings['attack']}")
			respond("NOTE: These commands are used for Kill Bandits and Escort Traveler tasks.  Bigshot is used for hunting tasks.")
		else
			respond("Attack commands reset.")
		end
	elsif opt =~ /^bless=(.+)$/i
		if (char_settings['bless'] = ($1 == 'nil') ? nil : $1)
			respond("Now blessing: /#{char_settings['bless']}/")
		else
			respond("No longer blessing anything.")
		end
	elsif opt =~ /^boost-absorb=(yes|no)$/i
		if (char_settings['boost-absorb'] = ($1 =~ /y/i) ? true : false)
			respond("Now using BOOST ABSORB.")
		else
			respond("No longer using BOOST ABSORB.")
		end
	elsif opt =~ /^boost-experience=(yes|no)$/i
		if (char_settings['boost-experience'] = ($1 =~ /y/i) ? true : false)
			respond("Now using BOOST EXPERIENCE.")
		else
			respond("No longer using BOOST EXPERIENCE.")
		end
	elsif opt =~ /^boost-longterm=(yes|no)$/i
		if (char_settings['boost-longterm'] = ($1 =~ /y/i) ? true : false)
			respond("Now using BOOST LONGTERM.")
		else
			respond("No longer using BOOST LONGTERM.")
		end
	elsif opt =~ /^boost-loot=(yes|no)$/i
		if (char_settings['boost-loot'] = ($1 =~ /y/i) ? true : false)
			respond("Now using BOOST LOOT.")
		else
			respond("No longer using BOOST LOOT.")
		end
	elsif opt =~ /^collectibles=(yes|no)$/i
		if (char_settings['collectibles'] = ($1 =~ /y/i) ? true : false)
			respond("Now depositing collectibles.")
		else
			respond("No longer depositing collectibles.")
		end
	elsif opt =~ /^escort-traveler-long=(yes|no)$/i
		if (char_settings['escort-traveler-long'] = ($1 =~ /y/i) ? true : false)
			respond("Now doing Escort Traveler (long) bounties.")
			respond("NOTE: You must download ego2.lic.") unless Script.exists?('ego2')
		else
			respond("No longer doing Escort Traveler (long) bounties.")
		end
	elsif opt =~ /^escort-traveler-short=(yes|no)$/i
		if (char_settings['escort-traveler-short'] = ($1 =~ /y/i) ? true : false)
			respond("Now doing Escort Traveler (short) bounties.")
			respond("NOTE: You must download ego2.lic.") unless Script.exists?('ego2')
		else
			respond("No longer doing Escort Traveler (short) bounties.")
		end
	elsif opt =~ /^fried-bounties=(yes|no)$/i
		if (char_settings['fried-bounties'] = ($1 =~ /y/i) ? true : false)
			respond("Now working on bounties while fried.")
		else
			respond("No longer working on bounties while fried.")
		end
	elsif opt =~ /^get-deeds=(yes|no)$/i
		if (char_settings['get-deeds'] = ($1 =~ /y/i) ? true : false)
			respond("Now getting deeds.")
			respond("NOTE: This only works if you hunt around Wehnimer's Landing, Icemule Trace or Solhven.  It will withdraw silvers from the Landing bank.")
			respond("NOTE: You must download ruby-deed.lic.") unless Script.exists?('ruby-deed')
		else
			respond("No longer getting deeds.")
		end
	elsif opt =~ /^get-spellups=(yes|no)$/i && gsf
		if (char_settings['get-spellups'] = ($1 =~ /y/i) ? true : false)
			respond("Now requesting spellups from other players.")
		else
			respond("No longer requesting spellups from other players.")
		end
	elsif opt =~ /^give-spellups=(yes|no)$/i && gsf
		if (char_settings['give-spellups'] = ($1 =~ /y/i) ? true : false)
			respond("Now giving spellups to other players.")
		else
			respond("No longer giving spellups to other players.")
		end
	elsif opt =~ /^idle=(.+)$/i
		if (char_settings['idle'] = ($1 == 'nil') ? nil : $1)
			respond("Idle commands set to: #{char_settings['idle']}")
			respond("NOTE: These commands will run once per second while resting.")
		else
			respond("Idle commands cleared.")
		end
	elsif opt =~ /^kill-bandits=(yes|no)$/i
		if (char_settings['kill-bandits'] = ($1 =~ /y/i) ? true : false)
			respond("Now doing Kill Bandits bounties.")
			respond("NOTE: This feature is experimental and has only been tested on Teras Isle.")
		else
			respond("No longer doing Kill Bandits bounties.")
		end
	elsif opt =~ /^kill-creatures=(yes|no)$/i
		if (char_settings['kill-creatures'] = ($1 =~ /y/i) ? true : false)
			respond("Now doing Kill Creatures bounties.")
		else
			respond("No longer doing Kill Creatures bounties.")
		end
	elsif opt =~ /^kill-dangerous-creature=(yes|no)$/i
		if (char_settings['kill-dangerous-creature'] = ($1 =~ /y/i) ? true : false)
			respond("Now doing Kill Dangerous Creature bounties.")
		else
			respond("No longer doing Kill Dangerous Creature bounties.")
		end
	elsif opt =~ /^locksmith-pool=(?:(yes)|(no)|(\d+))$/i
		if (char_settings['locksmith-pool'] = $1 ? true : $2 ? false : $3.to_i)
			if $1
				respond("Now using the locksmith pool.")
			else
				respond("Now using the locksmith pool and leaving a #{char_settings['locksmith-pool']} silver tip.")
			end
		else
			respond("No longer using the locksmith pool.")
		end
	elsif opt =~ /^log-flags=(.*)$/i
		if (char_settings['log-flags'] = $1.empty? ? nil : $1)
			respond("Log flags set to \"#{char_settings['log-flags']}\".")
		else
			respond("Log flags cleared.")
		end
	elsif opt =~ /^log-window=(.+)$/i
		new_log_window = $1.downcase
		valid_windows = %w(familiar thoughts voln death logons assess ooc atmospherics console nil)
		if valid_windows.include?(new_log_window)
			if new_log_window == 'nil'
				char_settings['log-window'] = nil
				respond("Log messages will no longer be shown.")
			else
				char_settings['log-window'] = new_log_window
				respond("Log messages will now go to the #{new_log_window} window.")
				respond("NOTE: Messages always go to the familiar window when using Wizard or Avalon.") if %w(wizard avalon).include?($frontend)
			end
		else
			respond("Valid options are: #{valid_windows.join(', ')}")
		end
	elsif opt =~ /^loresing=(yes|no)$/i && gsf
		if (char_settings['loresing'] = ($1 =~ /y/i) ? true : false)
			respond("Now providing loresinging for other players.")
			respond("NOTE: You must download testme.lic.") unless Script.exists?('testme')
		else
			respond("No longer providing loresinging for other players.")
		end
	elsif opt =~ /^percentmind=(\d+)%?$/i
		char_settings['percentmind'] = $1.to_i
		respond("Now hunting when mind is at #{char_settings['percentmind']}% or below.")
	elsif opt =~ /^percentspirit=(\d+)%?$/i
		char_settings['percentspirit'] = $1.to_i
		respond("Now hunting when spirit is at #{char_settings['percentspirit']}% or above.")
	elsif opt =~ /^procure-gems=(yes|no)$/i
		if (char_settings['procure-gems'] = ($1 =~ /y/i) ? true : false)
			respond("Now doing Procure Gems bounties.")
		else
			respond("No longer doing Procure Gems bounties.")
		end
	elsif opt =~ /^procure-skins=(yes|no)$/i
		if (char_settings['procure-skins'] = ($1 =~ /y/i) ? true : false)
			respond("Now doing Procure Skins bounties.")
		else
			respond("No longer doing Procure Skins bounties.")
		end
	elsif opt =~ /^rescue-child=(yes|no)$/i
		if (char_settings['rescue-child'] = ($1 =~ /y/i) ? true : false)
			respond("Now doing Rescue Child bounties.")
			respond("NOTE: You must download child2.lic and step2.lic.") unless Script.exists?('child2') && Script.exists?('step2')
		else
			respond("No longer doing Rescue Child bounties.")
		end
	elsif opt =~ /^rest=(.+)$/i
		if (char_settings['rest'] = ($1 == 'nil') ? nil : $1)
			respond("Resting commands set to: #{char_settings['rest']}")
		else
			respond("Resting commands cleared.")
		end
	elsif opt =~ /^retrieve-heirloom-loot=(yes|no)$/i
		if (char_settings['retrieve-heirloom-loot'] = ($1 =~ /y/i) ? true : false)
			respond("Now doing Retrieve Heirloom (LOOT) bounties.")
		else
			respond("No longer doing Retrieve Heirloom (LOOT) bounties.")
		end
	elsif opt =~ /^retrieve-heirloom-search=(yes|no)$/i
		if (char_settings['retrieve-heirloom-search'] = ($1 =~ /y/i) ? true : false)
			respond("Now doing Retrieve Heirloom (SEARCH) bounties.")
		else
			respond("No longer doing Retrieve Heirloom (SEARCH) bounties.")
		end
	elsif opt =~ /^share-mana=(yes|no)$/i && gsf
		if (char_settings['share-mana'] = ($1 =~ /y/i) ? true : false)
			respond("Now sharing spare mana that would be wasted on the next pulse.")
			LNet.tune_channel('play')
		else
			respond("No longer sharing spare mana that would be wasted on the next pulse.")
			LNet.untune_channel('play')
		end
	elsif opt =~ /^sing-gems=(?:(yes)|(no)|(\d+))$/i
		if (char_settings['sing-gems'] = $1 ? true : $2 ? false : $3.to_i)
			if $1
				respond("Now purifying all gems.")
			else
				respond("Now purifying gems worth at least #{char_settings['sing-gems']}.")
				respond("NOTE: 25 Trading skill required to appraise gems.") if $3 && Skills.trading < 25
			end
			respond("NOTE: This will override loot-be-gone's exclude-types and stockpile settings.")
		else
			respond("No longer purifying gems.")
		end
	elsif opt =~ /^skip-spells=(\d+(?:,\d+)*|nil)$/i
		if (char_settings['skip-spells'] = ($1 == 'nil') ? nil : $1.split(/,/).map { |s| s.to_i })
			respond("Now skipping spells #{char_settings['skip-spells'].join(',')}")
		else
			respond("No longer skipping spells.")
		end
	elsif opt =~ /^stop-hunting=(yes|no)$/i
		if (char_settings['stop-hunting'] = ($1 =~ /y/i) ? true : false)
			respond("Now ending hunt immediately when a bounty is available.")
		else
			respond("No longer ending hunt immediately when a bounty is available.")
		end
	elsif opt =~ /^symbol-blessing=(yes|no)$/i
		if (char_settings['symbol-blessing'] = ($1 =~ /y/i) ? true : false)
			respond("Now using Symbol of Blessing to bless equipment.")
		else
			respond("No longer using Symbol of Blessing to bless equipment.")
			respond("NOTE: Because you can't cast 304, Alfred will be asked for blessing.") unless Spell[304].known?
		end
		respond("NOTE: Because you can cast 304, this will have no effect.") if Spell[304].known?
	elsif opt =~ /^symbol-return=(yes|no)$/i
		if (char_settings['symbol-return'] = ($1 =~ /y/i) ? true : false)
			respond("Now using Symbol of Return to return from Nelemar and the Rift.")
		else
			respond("No longer using Symbol of Return to return from Nelemar and the Rift.")
		end
	elsif opt =~ /^use-gold-ring=(yes|no)$/i
		if (char_settings['use-gold-ring'] = ($1 =~ /y/i) ? true : false)
			respond("Now using gold rings to return from Nelemar and the Rift.")
		else
			respond("No longer using golds ring to return from Nelemar and the Rift.")
		end
	elsif opt =~ /^stop$/i
		stop_script = true
		respond("Stopping...")
	elsif opt =~ /^setup$/i
		#       0         1         2         3         4         5         6         7         8
		respond("First, you should go through play's settings by typing ;play help.")
		respond("")
		respond("Play uses bigshot to hunt.  You'll need to configure it with ;bigshot setup.")
		respond("Play will use its settings instead of bigshot's settings for when to hunt and")
		respond("rest, and what commands to send before and after a hunt.  You'll hunt with")
		respond("whatever equipment you've chosen to use with the READY verb.")
		respond("")
		respond("Play automatically takes care of selling loot, healing and spelling up.")
		respond("")
		respond("Loot-be-gone is used to sell your loot.  You should check its settings with")
		respond(";loot-be-gone list.  Make sure your lootsack is set correctly.  If you set")
		respond("stockpile on, set the locker room number and put jars in your locker, play will")
		respond("use loot-be-gone's stockpile to do Procure Gems bounties.")
		respond("")
		respond("Play does bounties for the creatures that you've configured bigshot to hunt.")
		respond("You'll need child2 and step2 if you want to do Rescue Child bounties and you'll")
		respond("need ego2 if you want to do Escort Traveler bounties.")
		respond("")
		respond("Play will exit when you die.  You can use zombie to restart it automatically:")
		respond(";zombie set start-scripts play")
		respond(";autostart add zombie")
		respond("")
		respond("When you're ready to start, type ;play")
	elsif opt =~ /^hunt$/i
		respond("Play can configure bigshot to hunt in the following areas for you:")
		respond("")
		for area in hunting_areas
			creatures = area[0].map { |c| c =~ /(\d+).*: (.*)/; "#$2 (#$1)" }
			respond("  - #{creatures.join(', ')}")
		end
		respond("")
		respond("To load an area, type #{cmd} hunt=<creature> (e.g. #{cmd} hunt=siren)")
	elsif opt =~ /^hunt=(.+?)([+-]\d+)?$/i
		target, overhunt = $1, ($2 || 999).to_i
		if (a = hunting_areas.find { |h| h[0].any? { |c| c =~ /#{target}/i } })
			creatures, rrid, hrid, bs, *options = a
			target_creatures = creatures.select { |c| c =~ /^(\d+)([^:]*f)?/; $2.nil? && $1.to_i <= Stats.level + overhunt }
			flee_creatures = creatures - target_creatures
			# Configure bigshot.
			Vars.op['targets'] = target_creatures.map { |c| c.sub(/.*: /, '.*\\b') }.join(', ') # .*\b at the start to match prefixes (e.g. ancient)
			Vars.op['always_flee_from'] = flee_creatures.map { |c| c.sub(/.*: /, '.*\\b') }.join(', ')
			Vars.op['bless'] = target_creatures.any? { |c| c =~ /u.*:/ }
			Vars.op['hunting_room_id'] = hrid.to_s
			Vars.op['resting_room_id'] = rrid.to_s
			if options.include?(:interior_rooms)
				# Area specifies hunting rooms rather than boundary rooms.  Determine the boundary rooms and load them into bigshot.
				Vars.op['hunting_boundaries'] = (bs.flat_map { |r| Room[r].wayto.keys.map { |r| r.to_i } }.uniq - bs).join(', ')
				char_settings['interior_rooms'] = bs
			else
				# Make sure the specified boundary rooms fully enclose an area.
				sanity_check_rooms = [hrid]
				loop {
					new_rooms = sanity_check_rooms.flat_map { |r| Room[r].wayto.keys.map { |w| w.to_i } }.uniq - sanity_check_rooms - bs
					break if new_rooms.empty?
					sanity_check_rooms += new_rooms
					if sanity_check_rooms.count > 200
						respond('Boundaries are broken.')
						exit
					end
				}
				# Load the boundary rooms into bigshot.
				Vars.op['hunting_boundaries'] = bs.join(', ')
				char_settings['interior_rooms'] = nil
			end
			# Remember some additional information about the selected hunting area.
			char_settings['bigshot_settings'] = [Vars.op['targets'], Vars.op['hunting_room_id'], Vars.op['hunting_boundaries']]
			char_settings['bounty_max_level'] = target_creatures.map { |c| c =~ /^(\d+)/; $1.to_i }.max
			char_settings['targets_carry_boxes'] = target_creatures.any? { |c| c =~ /b.*:/ }
			char_settings['options'] = options
			respond("Loaded hunting config: #{target_creatures.map { |c| c.sub(/.*: /, '') }.join(', ')}")
		else
			respond("Failed to find a hunting area for #{target}")
		end
	elsif opt =~ /^dump gems$/i
		respond("#{char_settings['sing-gems'] ? 'Purifying' : 'Not purifying'} gems.")
		respond("")
		respond("#{char_settings[:total_gems_purified] || 0} gems have been purified.")
		respond("#{char_settings[:total_gems_destroyed] || 0} gems have been destroyed.")
		respond("#{char_settings[:total_gems_skipped] || 0} gems have been skipped.")
	elsif opt =~ /^dump mana$/i
		for player, data in char_settings[:sent_mana].sort { |a, b| b[2] <=> a[2] }
			version, time, count = *data
			respond("   (#{count}) #{player}")
		end
	elsif opt =~ /^dump bounty gems$/i
		info = char_settings[:gem_bounties] # gem => [0, Time.now, Room.current.id]
		for room in info.keys.map { |g| info[g][2] }.uniq.sort { |a, b| Room[a].location <=> Room[b].location }
			respond("== #{Room[room].location}")
			count = 0
			for gem in info.keys.select { |gem| info[gem][2] == room }.sort
				count += 1
				respond("   #{count}. #{gem}")
			end
		end
	elsif opt =~ /^dump settings$/i
		for k in char_settings.keys.sort { |a,b| a.to_s <=> b.to_s }
			respond("#{k}: #{char_settings[k].inspect}")
		end
	elsif opt =~ /^bounty$/i
		respond("Bounty Settings:")
		respond("")
		respond("  #{cmd} fried-bounties=<yes/no>            #{char_settings['fried-bounties'] ? 'yes, doing bounties while fried' : 'no, not doing bounties while fried'}")
		respond("  #{cmd} stop-hunting=<yes/no>              #{char_settings['stop-hunting'] ? 'yes, ending hunt when a bounty is available' : 'no, not ending hunt when a bounty is available'}")
		respond("  #{cmd} adjust-difficulty=<yes/no>         #{char_settings['adjust-difficulty'] ? 'yes, adjusting bounty difficulty' : 'no, not adjusting bounty difficulty'}")
		respond("")
		respond("  #{cmd} procure-gems=<yes/no>              #{char_settings['procure-gems'] ? 'yes, doing Procure Gems bounties' : 'no, not doing Procure Gems bounties'}")
		respond("  #{cmd} procure-skins=<yes/no>             #{char_settings['procure-skins'] ? 'yes, doing Procure Skins bounties' : 'no, not doing Procure Skins bounties'}")
		respond("  #{cmd} kill-creatures=<yes/no>            #{char_settings['kill-creatures'] ? 'yes, doing Kill Creatures bounties' : 'no, not doing Kill Creatures bounties'}")
		respond("  #{cmd} kill-dangerous-creature=<yes/no>   #{char_settings['kill-dangerous-creature'] ? 'yes, doing Kill Dangerous Creature bounties' : 'no, not doing Kill Dangerous Creature bounties'}")
		respond("  #{cmd} kill-bandits=<yes/no>              #{char_settings['kill-bandits'] ? 'yes, doing Kill Bandits bounties' : 'no, not doing Kill Bandits bounties'}")
		respond("  #{cmd} rescue-child=<yes/no>              #{char_settings['rescue-child'] ? 'yes, doing Rescue Child bounties' : 'no, not doing Rescue Child bounties'}")
		respond("  #{cmd} retrieve-heirloom-loot=<yes/no>    #{char_settings['retrieve-heirloom-loot'] ? 'yes, doing Retrieve Heirloom (LOOT) bounties' : 'no, not doing Retrieve Heirloom (LOOT) bounties'}")
		respond("  #{cmd} retrieve-heirloom-search=<yes/no>  #{char_settings['retrieve-heirloom-search'] ? 'yes, doing Retrieve Heirloom (SEARCH) bounties' : 'no, not doing Retrieve Heirloom (SEARCH) bounties'}")
		respond("  #{cmd} escort-traveler-short=<yes/no>     #{char_settings['escort-traveler-short'] ? 'yes, doing Escort Traveler (short) bounties' : 'no, not doing Escort Traveler (short) bounties'}")
		respond("  #{cmd} escort-traveler-long=<yes/no>      #{char_settings['escort-traveler-long'] ? 'yes, doing Escort Traveler (long) bounties' : 'no, not doing Escort Traveler (long) bounties'}")
		respond("")
		respond("  #{cmd} attack=<cmd,cmd.../nil>            #{char_settings['attack'] || 'nil'}")
		respond("")
		respond("  #{cmd} boost-loot=<yes/no>                #{char_settings['boost-loot'] ? 'yes, using BOOST LOOT' : 'no, not using BOOST LOOT'}")
		respond("  #{cmd} boost-longterm=<yes/no>            #{char_settings['boost-longterm'] ? 'yes, using BOOST LONGTERM' : 'no, not using BOOST LONGTERM'}")
		respond("  #{cmd} boost-experience=<yes/no>          #{char_settings['boost-experience'] ? 'yes, using BOOST EXPERIENCE' : 'no, not using BOOST EXPERIENCE'}")
		respond("  #{cmd} boost-absorb=<yes/no>              #{char_settings['boost-absorb'] ? 'yes, using BOOST ABSORB' : 'no, not using BOOST ABSORB'}")
	else
		respond("Commands:")
		respond("")
		respond("  #{cmd}                                    start the script")
		respond("  #{cmd} stop                               stop the script")
		respond("  #{cmd} setup                              show setup instructions")
		respond("  #{cmd} hunt                               configure hunting areas")
		respond("")
		respond("Settings:")
		respond("")
		respond("  #{cmd} percentmind=<0-100>                hunt at #{char_settings['percentmind']}% mind or below")
		respond("  #{cmd} percentspirit=<0-100>              hunt at #{char_settings['percentspirit']}% spirit or above")
		respond("")
		respond("  #{cmd} bless=<weapon/nil>                 #{char_settings['bless'] || 'nil'}")
		respond("  #{cmd} symbol-blessing=<yes/no>           #{char_settings['symbol-blessing'] ? 'yes, using Symbol of Blessing' : 'no, not using Symbol of Blessing'}") if Spell[9802].known?
		respond("  #{cmd} 1009=<shield type/nil>             #{char_settings['1009'] || 'nil'}") if Char.prof == 'Bard'
		respond("  #{cmd} 1012=<weapon type/nil>             #{char_settings['1012'] || 'nil'}") if Char.prof == 'Bard'
		respond("  #{cmd} 1014=<armor AsG/nil>               #{char_settings['1014'] || 'nil'}") if Char.prof == 'Bard'
		respond("  #{cmd} skip-spells=<num,num.../nil>       #{char_settings['skip-spells'] ? "skipping #{char_settings['skip-spells'].join(',')}" : 'not skipping spells'}") if char_settings['skip-spells']
		respond("")
		respond("  #{cmd} get-deeds=<yes/no>                 #{char_settings['get-deeds'] ? 'yes, getting deeds' : 'no, not getting deeds'}")
		respond("  #{cmd} locksmith-pool=<yes/no/tip>        #{char_settings['locksmith-pool'] == true ? 'yes, using the locksmith pool' : char_settings['locksmith-pool'] ? "yes, using the locksmith pool with a #{char_settings['locksmith-pool']} silver tip" : 'no, not using the locksmith pool'}")
		respond("  #{cmd} collectibles=<yes/no>              #{char_settings['collectibles'] ? 'yes, depositing collectibles' : 'no, not depositing collectibles'}")
		respond("  #{cmd} sing-gems=<yes/no/value>           #{char_settings['sing-gems'] == true ? 'purifying all gems' : char_settings['sing-gems'] ? "purifying gems worth at least #{char_settings['sing-gems']}" : 'not purifying gems'}") if Char.prof == 'Bard' && char_settings['sing-gems']
		respond("  #{cmd} symbol-return=<yes/no>             #{char_settings['symbol-return'] ? 'yes, using Symbol of Return' : 'no, not using Symbol of Return'}") if Spell[9825].known?
		respond("  #{cmd} use-gold-ring=<yes/no>             #{char_settings['use-gold-ring'] ? 'yes, using gold rings' : 'no, not using gold rings'}")
		respond("  #{cmd} rest=<cmd,cmd.../nil>              #{char_settings['rest'] || 'nil'}")
		respond("  #{cmd} idle=<cmd,cmd.../nil>              #{char_settings['idle'] || 'nil'}") unless char_settings['idle'].nil?
		respond("")
		respond("  #{cmd} get-spellups=<yes/no>              #{char_settings['get-spellups'] ? 'yes, getting spells from players' : 'no, not getting spells from players'}") if gsf
		respond("  #{cmd} give-spellups=<yes/no>             #{char_settings['give-spellups'] ? 'yes, giving spells to players' : 'no, not giving spells to players'}") if gsf
		respond("  #{cmd} share-mana=<yes/no>                #{char_settings['share-mana'] ? 'yes, sharing spare mana' : 'no, not sharing spare mana'}") if gsf
		respond("  #{cmd} alfred-gems=<yes/no>               #{char_settings['alfred-gems'] ? 'yes, giving Alfred gems' : 'no, not giving Alfred gems'}") if gsf
		respond("  #{cmd} loresing=<yes/no>                  #{char_settings['loresing'] ? 'yes, loresinging for players' : 'no, not loresinging for players'}") if gsf && Char.prof == 'Bard'
		respond("")
		respond("  #{cmd} log-window=<window/nil>            #{char_settings['log-window'] || 'nil'}")
		respond("  #{cmd} log-flags=<flags>                  #{char_settings['log-flags'] || ''}") if char_settings['log-flags']
		respond("")
		respond("  #{cmd} bounty                             show bounty settings")
	end
	respond("")
}
if (opt = script.vars[0])
	$play_command.call(opt)
	exit
else
	upstream_hook = proc { |client_string|
		begin
			if client_string =~ /^(?:<c>)?#{$lich_char}#{script_name}\s+(.*)$/i
				$play_command.call($1)
				nil
			else
				client_string
			end
		rescue
			UpstreamHook.remove(script_name)
			client_string
		end
	}
	before_dying { UpstreamHook.remove(script_name) }
	UpstreamHook.add(script_name, upstream_hook)
end

# log:  log a message
log = proc { |message|
	stamp = Time.now.strftime('[%D %T] ')

	if char_settings['log-window'].nil?
		# no log window
	elsif char_settings['log-window'] == 'console'
		STDERR.puts("#{stamp}#{message}")
	elsif $frontend == 'profanity'
		_respond("<pushStream id=\"#{char_settings['log-window']}\" ifClosedStyle=\"watching\"/>#{stamp}#{message}\r\n<popStream/>\r\n")
	elsif $frontend == 'stormfront'
		puts("<pushStream id=\"#{char_settings['log-window']}\" ifClosedStyle=\"watching\"/>#{stamp}#{message}\r\n<popStream/>\r\n")
	elsif $frontend == 'wizard' || $frontend == 'avalon'
		puts("\034GSe\r\n#{stamp}#{message}\r\n\034GSf\r\n")
	end

	echo(message)
}

# panic:  handle an unrecoverable error
panic = proc { |reason|
	log.call("Panic (#{reason})")
	echo("Script will QUIT in 30 seconds!  To stay connected, type ;kill #{script_name}")
	sleep(30)
	ARGV.delete('--reconnect')
	loop { put('quit'); sleep(1) }
}

# throttle:  avoid performing an action too often
throttle_times = {}
throttle = proc { |key, cooldown = 60, delay = false|
	last = throttle_times[key]
	if last.nil? || last + cooldown <= Time.now
		throttle_times[key] = Time.now
		!(delay && last.nil?)
	else
		false
	end
}

# flush:  wait for all output from previously sent commands
flush = proc {
	# Send a command with known output and wait for the result.  This must be a command that doesn't stop Symbol of Dreams.
	dothis('exp', /^          Level: /)
}

# script_start:  start a script
script_start = proc { |script, *args|
	start_script(script, args)
}

# script_run:  run a script
script_run = proc { |script, *args|
	start_script(script, args)
	wait_while { Script.running?(script) }
}

# script_run_quietly:  run a script quietly
script_run_quietly = proc { |script, *args|
	start_script(script, args, :quiet => true)
	wait_while { Script.running?(script) }
}

# script_exec:  exec a script
script_exec = proc { |script|
	start_exec_script(script)
}

# run_commands:  run a list of commands in settings
run_commands = proc { |commands, quiet = false|
	for cmd in commands.split(/\s*,\s*/)
		if cmd =~ /^;(\S+)(?:\s+(\S.*))?/
			if quiet
				script_run_quietly.call($1, $2)
			else
				script_run.call($1, $2)
			end
		else
			fput(cmd)
		end
	end
}

# update_renewal_cost:  update spellsong renewal cost if necessary
$play_renewal_cost = 0
renewal_factors = nil
update_renewal_cost = proc {
	if Char.prof == 'Bard' && !Spell[9824].active? # don't use SONG STATUS while dreaming
		updated_factors = [Stats.dis, Stats.log, Spells.bard, Spells.active.select { |s| s.circle.to_i == 10 }.map { |s| s.num }.sort]
		if renewal_factors != updated_factors
			$play_renewal_cost = dothis('song status', /^You are not singing any songs\.$|Your current renewal cost is \d+ mana\.$/) =~ /is (\d+) mana/ ? $1.to_i : 0
			renewal_factors = updated_factors
		end
	end
}

# find_mapped_room:  get to a mapped room
find_mapped_room = proc {
	lost = proc { Room.current.nil? || (Room.current.wayto.empty? && !XMLData.room_exits.empty?) }

	if lost.call
		log.call("Lost in #{XMLData.room_title || 'no title'}")

		while lost.call
			move(XMLData.room_exits.sample) unless XMLData.room_exits.empty?
			sleep(0.5)
		end
	end
}

# go2:  go somewhere
go2 = proc { |target|
	find_mapped_room.call
	script_run.call('go2', "--disable-confirm #{target.to_s}")
}

# fly2:  go to the given room number, preferably by teleportation, otherwise use go2
fly2 = proc { |room|
	starting_room = Room.current.id

	if char_settings['use-gold-ring'] && (ring = GameObj.inv.find { |i| i.name =~ /\bgold ring$/ })
		empty_hand
		multifput("remove ##{ring.id}", "wear ##{ring.id}")
		flush.call
		fill_hand
	end

	spells = teleportation_spell_list
	spells.unshift(9825) if char_settings['symbol-return']
	for s in spells
		update_renewal_cost.call
		next unless Spell[s].known? && Spell[s].affordable? && checkmana(Spell[s].mana_cost + $play_renewal_cost)
		flush.call
		break unless Room.current.id == starting_room
		waitrt?
		waitcastrt?
		Spell[s].cast
		waitcastrt?
	end

	go2.call(room)

	fput("turn ##{ring.id}") if ring
	fput('sense pattern') if teleportation_spell_list.include?(740) && Spell[740].known?
}

# nexus:  go to the nexus
saw_alfred = false
nexus = proc {
	if gsf
		unless Room.current.id == nexus_room
			go2.call(nexus_room)
			saw_alfred = Time.now if checkpcs.include?('Alfred')
			if leader = group_pcs.find { |p| checkpcs.include?(p) }
				fput("join #{leader}")
			end
		end
	elsif (r = (Vars.home || Room.current.find_nearest_by_tag('town')))
		go2.call(r) unless r.to_i == Room.current.id
		fput('go table') if Room.current.wayto.any? { |w, _| Room[w].title.any? { |t| t =~ /Table\]$/ } }
	end
}

# hurt:  determine if we're injured
hurt = proc { |serious = false|
	if serious
		[Wounds.head, Wounds.neck, Wounds.nsys, Wounds.leftEye, Wounds.rightEye, Wounds.arms, Scars.head, Scars.neck, Scars.nsys, Scars.leftEye, Scars.rightEye, Scars.arms].max >= 2|| percenthealth <= 66
	else
		[Wounds.head, Wounds.neck, Wounds.torso, Wounds.limbs, Wounds.nsys, Scars.head, Scars.neck, Scars.torso, Scars.limbs, Scars.nsys].max > 0 || checkhealth + 7 < maxhealth
	end
}

# heal:  heal using spells or herbs
heal = proc {
	if hurt.call
		if gsf
			nexus.call
			150.times {
				# Give bots a chance to heal us.
				break if !hurt.call || hidden? || invisible?
				sleep(0.1)
			}
		end
		if hurt.call && Spells.empath >= 18 && Char.level >= 14 && Script.exists?('sheal')
			nexus.call
			script_run.call('sheal')
		end
		if hurt.call
			script_run.call('useherbs', '--buy=on')
		end
	end
}

# cure:  deal with disease and poison
cure = proc {
	if checkdisease
		update_renewal_cost.call
		if Spell[113].known? && Spell[113].affordable? && checkmana(Spell[113].mana_cost + $play_renewal_cost)
			nexus.call
			Spell[113].cast
		elsif gsf && checkpcs.include?('Alfred') && throttle.call(:alfred_undisease)
			nexus.call
			log.call('Requesting undisease.')
			fput('whisper Alfred undisease')
			sleep(6)
		end
	end
	if checkpoison
		update_renewal_cost.call
		if Spell[114].known? && Spell[114].affordable? && checkmana(Spell[114].mana_cost + $play_renewal_cost)
			nexus.call
			Spell[114].cast
		elsif gsf && checkpcs.include?('Alfred') && throttle.call(:alfred_unpoison)
			nexus.call
			log.call('Requesting unpoison.')
			fput('whisper Alfred unpoison')
			sleep(6)
		end
	end
}

# sack:  find, open and update the contents of a container
sack = proc { |id|
	if (obj = GameObj[id])
		if obj.contents.nil?
			dothistimeout("open ##{obj.id}", 5, /^You open|^That is already open\.$/)
			dothistimeout("look in ##{obj.id}", 5, /In .*? you see/)
		end

		obj
	end
}

# stowsack:  find, open and update the contents of our stowsack
stowsack = proc {
	sack.call(XMLData.stow_container_id)
}

# lootsack:  find, open and update the contents of our lootsack
lootsack = proc {
	sack.call(Vars.lootsack)
}

# skinsack:  find, open and update the contents of our skinsack
skinsack = proc {
	if Vars.skinsack
		sack.call(Vars.skinsack)
	else
		lootsack.call
	end
}

# skinweaponsack:  find, open and update the contents of our skinweaponsack
skinweaponsack = proc {
	sack.call(Vars.skinweaponsack)
}

# arrowsack:  find, open and update the contents of our arrowsack
arrowsack = proc {
	if Vars.arrowsack
		sack.call(Vars.arrowsack)
	elsif Vars.ammosack
		sack.call(Vars.ammosack)
	else
		nil
	end
}

# visit_locksmith_pool:  drop off and collect boxes from the locksmith pool
visit_locksmith_pool = proc {
	# Check our loot for boxes.
	loot = lootsack.call.contents
	disk = nil
	50.times {
		break if (disk = GameObj.loot.find { |l| l.name =~ /\b#{checkname} disk$/ })
		sleep(0.1)
	}
	if disk
		dothistimeout("look in ##{disk.id}", 5, /^There is nothing in the disk\.$|^In the .* disk/)
		loot += disk.contents || []
	end
	new_boxes = (char_settings['locksmith-pool'] ? loot.select { |c| c.type =~ /\bbox\b/ } : [])

	# Visit the pool if we have any boxes to drop off or collect.
	# Go as often as needed to drop off boxes, but limit visits just to collect them.
	if !new_boxes.empty? || (char_settings[:boxes_in_pool] && throttle.call(:collect_boxes, 300))
		# Don't try to collect boxes too soon after dropping them off.
		throttle.call(:collect_boxes)

		# Get coins for tips.
		tip = char_settings['locksmith-pool']
		tip = 100 if tip == true
		tip = 1 if tip < 1
		unless new_boxes.empty?
			go2.call('bank')
			fput("withdraw #{new_boxes.count * tip}")
		end

		# Go to the pool.
		go2.call('locksmith pool')
		trashcan = nil
		if Room.current.tags.find { |t| t =~ /^meta:trashcan:(.*)/ }
			trashcan_name = $1
			trashcan = GameObj.loot.find { |l| l.name == trashcan_name }
		end
		if trashcan.nil?
			echo('Locksmith pool trashcan not found.')
		end
		npc = nil
		if Room.current.tags.find { |t| t =~ /^meta:boxpool:npc:(.*)/ }
			npc_name = $1
			npc = GameObj.npcs.find { |n| n.name == npc_name }
		end
		if npc.nil?
			echo('Locksmith pool NPC not found.')
		else
			# Wait for our disk to catch up.
			if disk
				50.times {
					break if (disk = GameObj.loot.find { |l| l.name =~ /\b#{checkname} disk$/ })
					sleep(0.1)
				}
			end

			# Stow anything that we're holding.
			empty_hands

			# Drop off new boxes.
			for b in new_boxes
				multifput("get ##{b.id}", "give ##{npc.id} #{tip}", "give ##{npc.id} #{tip}")
				fput("put ##{b.id} in ##{disk.id}") if disk
				fput("put ##{b.id} in ##{lootsack.call.id}")
			end

			# Retrieve old boxes.
			loop {
				r = dothistimeout("ask ##{npc.id} for return", 5, /We don't have any boxes ready for you|Alright, here's your/)
				unless r =~ /Alright/
					break
				end
				b = GameObj.right_hand
				break if b.nil?
				fput("open ##{b.id}")
				dothistimeout("look in ##{b.id}", 5, /^In the |^There is nothing in /)
				dothistimeout("get coins from ##{b.id}", 5, /^You gather the remaining |^Get what\?$/)
				waitrt?
				for item in b.contents.select { |c| c.type !~ /\b(?:#{['cursed', *trash_loot_types].join('|')})\b/ }
					multifput("_drag ##{item.id} ##{lootsack.call.id}", "drop ##{item.id}")
				end
				fput("put ##{b.id} in ##{trashcan.id}") unless trashcan.nil?
				fput("drop ##{b.id}")
			}

			# Record whether to come back.
			char_settings[:boxes_in_pool] = (dothistimeout("ask ##{npc.id} for list", 5, /here's the list of boxes we have for you|You haven't given us any boxes to be worked on/) !~ /haven't/)

			# Grab anything we stowed to make room in our hands.
			fill_hands
		end
	end
}

# Restore loot-be-gone's settings on exit.
restore_loot_settings = proc {
	if char_settings[:restore_needed_reagents]
		Vars.needed_reagents = char_settings[:restore_needed_reagents_value]
		char_settings[:restore_needed_reagents] = nil
		char_settings[:restore_needed_reagents_value] = nil
	end
	if char_settings[:restore_purify_overrides]
		script_run.call('loot-be-gone', 'stockpile=on')
		script_run.call('loot-be-gone', 'exclude-types=cursed')
		char_settings[:restore_purify_overrides] = nil
	end
}
restore_loot_settings.call
before_dying { restore_loot_settings.call }

# sell_loot:  sell loot
need_to_sell_loot = false
sell_loot = proc { |sell_all_gems = false|
	need_to_sell_loot = false

	# Use the locksmith pool.
	visit_locksmith_pool.call

	# Save a black crystal if we can't cast Floating Disk.
	if !Spell[511].known? && lootsack.call.id != stowsack.call.id
		if (new_crystal = lootsack.call.contents.find { |c| c.name == 'black crystal' })
			if (old_crystal = stowsack.call.contents.find { |c| c.name == 'black crystal' })
				# If we have an old one, swap it for the fresh one.
				multifput("_drag ##{old_crystal.id} ##{lootsack.call.id}", "put ##{old_crystal.id} in ##{stowsack.call.id}")
			end
			multifput("_drag ##{new_crystal.id} ##{stowsack.call.id}", "put ##{new_crystal.id} in ##{lootsack.call.id}")
		end
	end

	# Save valuable gems for Alfred.
	if gsf && char_settings['alfred-gems'] && !sell_all_gems && saw_alfred && Time.now - saw_alfred < 60 * 60 * 24
		char_settings[:restore_needed_reagents_value] = (Vars.needed_reagents.nil? ? nil : Vars.needed_reagents.clone)
		char_settings[:restore_needed_reagents] = true
		Vars.needed_reagents = '^uncut (diamond|emerald)$'
	end

	# Save all gems if we're purifying them.
	if char_settings['sing-gems'] && !sell_all_gems && Spell[1004].known?
		char_settings[:restore_purify_overrides] = true
		script_run.call('loot-be-gone', 'stockpile=off')
		script_run.call('loot-be-gone', 'exclude-types=gem|cursed')
	end

	# Run loot-be-gone.
	find_mapped_room.call
	script_run.call('loot-be-gone')
	restore_loot_settings.call

	# Deposit/sell collectibles.
	if (collectibles = lootsack.call.contents.select { |c| c.type =~ /\bcollectible\b/ }) && collectibles.count > 0
		if char_settings['collectibles']
			go2.call('collectible')
			collectibles.each { |c| multifput("get ##{c.id}", "deposit ##{c.id}", "put ##{c.id} in ##{lootsack.call.id}") }
		else
			go2.call('pawnshop')
			collectibles.each { |c| multifput("get ##{c.id}", "sell ##{c.id}", "put ##{c.id} in ##{lootsack.call.id}") }
			go2.call('bank')
			fput('deposit all')
		end
	end

	# Try to deposit notes.
	if (lootsack.call.contents + stowsack.call.contents).any? { |c| %w(note scrip chit).include?(c.noun) } && throttle.call(:deposit_notes, 60 * 60)
		go2.call('bank')
		fput('deposit all')
	end
}

# full_mana:  check if mana is full, with some leeway
full_mana = proc {
	update_renewal_cost.call
	checkmana(maxmana - [$play_renewal_cost, noded_pulse - 1, 0].max)
}

# get_mana:  try to gain mana
get_mana = proc {
	if gsf && !checkmana(maxmana)
		nexus.call
		if checkpcs.include?('Tyrean') && (Skills.smc >= 10 || Skills.emc >= 24) && throttle.call(:tyrean_mana, 30)
			fput("whisper Tyrean mana")
		elsif checkpcs.include?('Ganz') && (Skills.smc >= 24 || Skills.emc >= 24) && throttle.call(:ganz_mana, 30)
			fput("whisper Ganz mana")
		end
		if char_settings['share-mana'] && [Skills.emc, Skills.mmc, Skills.smc].max >= 24 && throttle.call(:get_mana, 30)
			LNet.send_message(attr = { 'type' => 'channel', 'channel' => 'play' }, "mana #{Skills.emc} #{Skills.mmc} #{Skills.smc}")
		end
	end
}

# get_spirit:  try to gain spirit
get_spirit = proc {
	if percentspirit < 100
		nexus.call
		if gsf && checkpcs.include?('Alfred') && throttle.call(:alfred_spirit)
			log.call('Requesting spirit.')
			fput('whisper Alfred well of life')
			50.times {
				break if percentspirit == 100
				sleep(0.1)
			}
		elsif Spell[9819].known? && !Spell[9050].active?
			log.call('Renewing spirit.')
			Spell[9819].cast
		end
	end
}

# uncurse:  try to get items out of our hands
uncurse = proc {
	fix = proc { |hand|
		if throttle.call("uncurse_#{hand}")
			if dothistimeout("stow #{hand}", 5, /^For some reason, you are unable to do that\.$/)
				if gsf
					nexus.call
					if checkpcs.include?('Alfred')
						log.call('Requesting uncurse.')
						dothistimeout('whisper Alfred uncurse', 5, /^The .+ which you are holding suddenly glows with an intensely bright light!$/)
						fput("stow all")
					end
				end
			end
		end
	}

	fix.call('right') if checkright
	fix.call('left') if checkleft
}

# spare_mana:  determine how much mana will be wasted on the next noded pulse
spare_mana = proc {
	update_renewal_cost.call
	[noded_pulse + mana - maxmana - $play_renewal_cost, 0].max
}

# idle:  do things while resting
last_level = nil
idle = proc {
	# Check if we gained a level.
	if last_level != Stats.level
		log.call("You are now level #{Stats.level}!") unless last_level.nil?
		last_level = Stats.level
	end

	# Cast mass spells with spare mana when joined to a group.
	if char_settings['give-spellups'] && group?
		mass_spell_list.select { |s| Spell[s].known? }.each { |s|
			Spell[s].cast if Spell[s].known? && Spell[s].affordable? && Spell[s].mana_cost <= spare_mana.call && throttle.call("mass_#{s}", mass_spell_delay * 60, :delay)
		}
	end

	# Run idle commands.
	run_commands.call(char_settings['idle'], :quiet)
}

# spellup:  cast buff spells
skipped_songs = []
spellup = proc { |full = false|
	# Make sure we're not in an antimagic room.
	nexus.call

	# Cast spells that we know from self_cast_list.
	wanted = self_cast_list.select { |s| Spell[s].known? && !char_settings['skip-spells'].include?(s) }

	# If we're going to cast at least 3 spells, try to use mana spellup.
	if wanted.select { |s| !Spell[s].active? || (Spell[s].stackable? && Spell[s].timeleft < quick_spellup_time) }.count >= 3
		r = dothistimeout('mana spellup', 3, /^You are unable to control the flows of mana to perform this task\.$/)
		if r.nil?
			# durations are incorrect after mana spellup
			fput('spell active')
			flush.call
		end
	end

	# Start singing any bard songs that we're still missing and stop singing any bard songs that we don't want to keep up.
	skipped_songs = []
	for spell in Spells.known.select { |spell| spell.circle.to_i == 10 && ![1009, 1012, 1014].include?(spell.num) }
		if !spell.active? && wanted.include?(spell.num)
			update_renewal_cost.call
			unless maxmana >= spell.mana_cost + $play_renewal_cost
				skipped_songs.push(spell.num)
				next
			end
			get_mana.call unless checkmana(spell.mana_cost + $play_renewal_cost)
			wait_until { spell.affordable? && checkmana(spell.mana_cost + $play_renewal_cost) }
			spell.cast
		elsif spell.active? && !wanted.include?(spell.num) && spell.renew_cost != 0
			dothis("stop #{spell.num}", /^You stop singing|^You are not singing that song\.$/)
			spell.putdown
		end
	end

	# Waggle if this is a full spellup, or if we're still missing spells, or if a stackable spell has under quick_spellup_time left.
	wanted.select! { |s| Spell[s].circle.to_i != 10 }
	if wanted.any? { |s| full || !Spell[s].active? || (Spell[s].stackable? && Spell[s].timeleft < quick_spellup_time) }
		update_renewal_cost.call
		waggle_args = ["--cast-list=#{wanted.join(',')}", "--reserve-mana=#{$play_renewal_cost}", "--stop-before=999"]
		unless full
			waggle_args += ["--start-at=#{quick_spellup_time}", "--stop-at=#{quick_spellup_time}"]
		end
		script_run.call('waggle', *waggle_args)
	end
}

# hunt_setting:  get a setting for the current hunting area if the settings are still valid
hunt_setting = proc { |setting|
	if char_settings['bigshot_settings'] == [Vars.op['targets'].gsub(/\s*\(\w\)\s*/, ''), Vars.op['hunting_room_id'], Vars.op['hunting_boundaries']]
		char_settings[setting]
	else
		nil
	end
}

# do_escort_bounty:  decide if we want to do an escort bounty
do_escort_bounty = proc { |from_area, to_city|
	from_city = {
		"area just inside the North Gate" => "Wehnimer's Landing",
		"area just north of the South Gate, past the barbican" => "Icemule Trace",
		"south end of North Market" => "Solhaven",
		"Kresh'ar Deep monument" => "Zul Logoth",
		"area just inside the Sapphire Gate" => "Ta'Illistim",
		"area just inside the Amaranth Gate" => "Ta'Vaalor",
	}[from_area]
	panic.call("escort location: #{from}") unless from_city

	west = ["Wehnimer's Landing", "Solhaven", "Icemule Trace"]
	east = ["Ta'Illistim", "Ta'Vaalor"]

	if (west.include?(from_city) && west.include?(to_city)) || (east.include?(from_city) && east.include?(to_city))
		char_settings['escort-traveler-short']
	else
		char_settings['escort-traveler-long']
	end
}

# advguild:  get the room number for the advguild nearest to our resting room
advguild = proc {
	Room[Vars.op['resting_room_id'].length > 0 ? Vars.op['resting_room_id'].to_i : Room.current.id].find_nearest_by_tag('advguild')
}

# bounty_location:  determine if a bounty is in a location we can hunt
bandit_rooms = []
bounty_location = proc { |line|
	if line =~ /suppress bandit activity/
		# Bandits, try to find the hunting rooms.
		if line =~ /suppress bandit activity (?:in|on|near) (.*) (?:near|between|under)/
			location = $1
			p, s = Room[advguild.call].dijkstra
			bandit_rooms = Room.list.select { |r| r.location == location && s[r.id] && !bandit_exclude.include?(r.id) }.map { |r| r.id }.sort { |a, b| s[a] <=> s[b] }[0..2]
			if bandit_rooms.count > 0
				true
			else
				log.call('Failed to find bandit location.')
				false
			end
		else
			log.call('Failed to parse bandit location.')
			false
		end
	elsif (location = Room[Vars.op['hunting_room_id']].location)
		# Try to match the location that bigshot is hunting.
		line.include?(location)
	else
		# Can't tell.
		true
	end
}

# bounty:  turn in our bounty if it's done, get a new bounty if we're ready, remove our bounty if it's not one we want to do
activate_loot_boost = :no
bounty = proc {
	# Tell bigshot whether to stop hunting when fried based on percentmind setting.  This will be overridden below if we want to hunt fried because of our bounty.
	Vars.op['fried'] = char_settings['percentmind'] < 100 ? '100' : '999'
	# Only try to return an heirloom once, don't go into a loop.
	try_to_return_heirloom = true
	# Build a regex of creatures that bigshot's configured to hunt.
	target_re = '.*(?:' + Vars.op['targets'].split(/\s*,\s*/).map{ |i| i.sub(/\s*\([a-j]\)/i, '') }.select { |t| skip_creature_bounties.all? { |s| s !~ /#{t}/ } }.join('|') + ').*'

	# Enter a loop to deal with our current bounty status.
	loop {
		# Don't try to ASK about bounties if we might be silenced by cutthroat.
		heal.call while Wounds.neck > 0

		# Handle our current bounty status.
		line = checkbounty
		if line =~ /^You are not currently assigned a task\./
			# Get a bounty.
			break if Spell[9003].active?
			go2.call(advguild.call)
			char_settings[:bounty_time] = Time.now
			unless !char_settings['adjust-difficulty'] || hunt_setting.call('bounty_max_level').nil? || Stats.level < 15
				# Ask for bounties just hard enough to cover the creatures we're hunting.
				above = hunt_setting.call('bounty_max_level') - Stats.level
				above = 10 if above > 10
				above = 5 if above < 5
				change = 'harder'
				loop {
					r = dothistimeout("ask taskmaster about #{change}", 5, /^\w+ nods and says, "Very well, #{checkname}\.  You will now only get tasks involving creatures that we rate to be between \d+ ranks above your overall skill level and \d+ ranks below it\.(?:  This will result in a \d+% penalty to the rewards you receive when successfully completing tasks for us\.)?"$|^\w+ says, "You are already receiving tasks at what we consider to be your maximum level of competence\."$/)
					if r =~ /(\d+) ranks above your overall skill level and (\d+)/
						break if $1.to_i == above && $2.to_i == 5
						change = 'easier' if $1.to_i > above
					elsif r =~ /maximum level of competence/
						break if above == 10
						change = 'easier'
					end
				}
			end
			fput('ask taskmaster about bounty')
			fput('spell active') # fix next bounty time tracking
			flush.call
			log.call(checkbounty) unless char_settings['log-flags'] =~ /b/
			activate_loot_boost = :maybe if char_settings['boost-loot'] && hunt_setting.call('targets_carry_boxes')
		elsif line =~ /It appears they have a (?:creature|bandit) problem they'd like you to solve\.|It appears they need your help in tracking down some kind of lost heirloom\.|It appears that a local resident urgently needs our help in some matter\./
			# Get assignment from the guard.
			go2.call('advguard')
			GameObj.npcs.each { |n| fput("ask ##{n.id} about bounty") }
			flush.call
			if checkbounty == line
				go2.call('advguard2')
				GameObj.npcs.each { |n| fput("ask ##{n.id} about bounty") }
				flush.call
			end
			log.call(checkbounty) unless char_settings['log-flags'] =~ /b/
		elsif line =~ /The local gem dealer/ &&
				char_settings['procure-gems']
			# Get assignment from the gemshop, then let our loot script try to complete it.
			go2.call('gemshop')
			GameObj.npcs.each { |n| fput("ask ##{n.id} about bounty") }
			flush.call
			log.call(checkbounty) unless char_settings['log-flags'] =~ /b/
			if checkbounty =~ /customers requesting (.*?)\./
				char_settings[:gem_bounties] ||= Hash.new
				char_settings[:gem_bounties][$1] = [0, Time.now, Room.current.id]
			else
				log.call('Failed to parse gem bounty.')
			end
			sell_loot.call(:sell_all_gems)
		elsif line =~ /The local furrier/ &&
				char_settings['procure-skins']
			# Get assignment from the furrier.
			go2.call('furrier')
			GameObj.npcs.each { |n| fput("ask ##{n.id} about bounty") }
			flush.call
			log.call(checkbounty) unless char_settings['log-flags'] =~ /b/
		elsif line =~ /^You have been tasked to suppress #{target_re} activity / &&
				bounty_location.call(line) &&
				char_settings['kill-creatures']
			# Keep Kill Creatures bounty.
			if char_settings['fried-bounties']
				Vars.op['fried'] = '999'
				activate_loot_boost = :yes if activate_loot_boost == :maybe
			end
			break
		elsif line =~ /^You have been tasked to hunt down and kill a particularly dangerous #{target_re} that has / &&
				bounty_location.call(line) &&
				char_settings['kill-dangerous-creature'] &&
				!hunt_setting.call('options').include?(:no_boss_bounties)
			# Keep Kill Dangerous Creature bounty.
			if char_settings['fried-bounties']
				Vars.op['fried'] = '999'
				activate_loot_boost = :yes if activate_loot_boost == :maybe
			end
			break
		elsif line =~ /^You have been tasked to suppress bandit activity/ &&
				bounty_location.call(line) &&
				char_settings['kill-bandits']
			# Keep Kill Bandits bounty.
			if char_settings['fried-bounties']
				Vars.op['fried'] = '999'
			end
			break
		elsif line =~ /child fleeing from #{target_re} Find the area/ &&
				bounty_location.call(line) &&
				char_settings['rescue-child'] &&
				!hunt_setting.call('options').include?(:no_rescue_bounties) &&
				Script.exists?('child2') &&
				Script.exists?('step2')
			# Keep Rescue Child bounty.
			if char_settings['fried-bounties']
				Vars.op['fried'] = '999'
			end
			break
		elsif line =~ /lost after being attacked by #{target_re} LOOT the item from its corpse/ &&
				bounty_location.call(line) &&
				char_settings['retrieve-heirloom-loot']
			# Keep Retrieve Heirloom (LOOT) bounty.
			if char_settings['fried-bounties']
				Vars.op['fried'] = '999'
				activate_loot_boost = :yes if activate_loot_boost == :maybe
			end
			break
		elsif line =~ /lost after being attacked by #{target_re} SEARCH the area until you find it/ &&
				bounty_location.call(line) &&
				char_settings['retrieve-heirloom-search']
			# Keep Retrieve Heirloom (SEARCH) bounty.
			if char_settings['fried-bounties']
				Vars.op['fried'] = '999'
			end
			break
		elsif line =~ /^You have located / &&
				try_to_return_heirloom
			# Let loot-be-gone try to return the heirloom.  If it fails, move on to another bounty.
			sell_loot.call
			try_to_return_heirloom = false
		elsif line =~ /You can SKIN them off the corpse of #{target_re} or purchase them/ &&
				char_settings['procure-skins'] &&
				(sw = Vars.skinweapon) && (sws = Vars.skinweaponsack) &&
				skinweaponsack.call.contents.any? { |c| c.name =~ /#{sw}/ }
			# Keep Procure Skins bounty.
			if char_settings['fried-bounties']
				Vars.op['fried'] = '999'
				activate_loot_boost = :yes if activate_loot_boost == :maybe
			end
			break
		elsif line =~ /client has hired us to provide a protective escort .* Go to the (.*?) and WAIT .* guarantee .*? safety to (.*?) as soon as you can/ &&
				do_escort_bounty.call($1, $2) &&
				Script.exists?('ego2') &&
				!char_settings[:remove_escort_bounty]
			# Keep Protect Traveler bounty.
			if char_settings['fried-bounties']
				Vars.op['fried'] = '999'
			end
			break
		elsif line =~ /^You have failed in your task\.  Return to the Adventurer's Guild for further instructions\.$|^The child you were tasked to rescue is gone and your task is failed\.  Report this failure to the Adventurer's Guild\.$/
			# Report failure to the taskmaster.
			log.call('Reporting failed bounty.') unless char_settings['log-flags'] =~ /b/
			go2.call(advguild.call)
			fput('ask taskmaster about bounty')
			flush.call
		elsif line =~ /^You succeeded in your task and should report /
			# Report success to the guard.
			log.call('Reporting bounty to guard.') unless char_settings['log-flags'] =~ /b/
			go2.call('advguard')
			GameObj.npcs.each { |n| fput("ask ##{n.id} about bounty") }
			flush.call
			if checkbounty == line
				go2.call('advguard2')
				GameObj.npcs.each { |n| fput("ask ##{n.id} about bounty") }
				flush.call
			end
		elsif line =~ /^You have succeeded in your task and can return /
			# Report success to the taskmaster.
			break unless percentmind >= 90 && checkmind != 'saturated'
			if char_settings[:bounty_time].nil?
				log.call('Turning in bounty.') unless char_settings['log-flags'] =~ /b/
			else
				seconds = Time.now - char_settings[:bounty_time]
				elapsed = sprintf('%ds', seconds % 60)
				elapsed = sprintf('%dm %s', seconds % 3600 / 60, elapsed) if seconds >= 60
				elapsed = sprintf('%dh %s', seconds / 3600, elapsed) if seconds >= 3600
				log.call("Turning in bounty after #{elapsed}.") unless char_settings['log-flags'] =~ /b/
			end
			go2.call(advguild.call)
			fput('ask taskmaster about bounty')
			flush.call
			if checkmind == 'saturated'
				boost_absorb = char_settings['boost-absorb']
				if char_settings['boost-experience'] && Spell[9003].timeleft >= 10
					r = dothistimeout('boost experience', 5, /^\[You have activated a Doubled Experience Booster!  You will absorb twice as much experience for 15 minutes\.\]$|^You do not have any Doubled Experience Boosts to redeem\.$/)
					log.call('Activated experience boost.') if r =~ /^\[You have/
					boost_absorb = false unless r =~ /^You do not/
				end
				put('boost absorb') if boost_absorb
			end
			sell_loot.call
		else
			# Remove bounty.
			log.call('Removing bounty.') unless char_settings['log-flags'] =~ /b/
			go2.call(advguild.call)
			multifput('ask taskmaster about remove', 'ask taskmaster about remove')
			flush.call
		end
	}

	char_settings[:remove_escort_bounty] = false
}

# skinning_bounty_complete:  determine if the player should try to turn in a skinning bounty
skinning_bounty_complete = proc {
	if checkbounty =~ /You have been tasked to retrieve (\d+) (.+?)s? of at least/
		count, name = $1, $2
		for k, v in { 'teeth' => 'tooth', 'hoove' => 'hoof' }
			name.gsub!(/\b#{k}$/, v)
		end
		skinsack.call.contents.select { |c| c.name == name }.count >= count.to_i
	else
		false
	end
}

# recover:  recover from death
recover = proc {
	unless Spell[9824].active?
		unless Spell[203].active?
			# Eat Manna bread
			nexus.call
			update_renewal_cost.call
			if Spell[203].known? && Spell[203].affordable? && checkmana(Spell[203].mana_cost + $play_renewal_cost) && !checkright
				Spell[203].cast
				2.times { fput("gobble ##{GameObj.right_hand.id}") }
			elsif gsf && checkpcs.include?('Alfred') && (!checkright || !checkleft) && throttle.call(:alfred_bread)
				log.call('Requesting bread.')
				junk = GameObj.loot.map { |l| l.id }
				if dothistimeout('whisper Alfred bread', 10, /^Alfred drops a spinach-paste steamed dumpling\.$/)
					if (dumpling = GameObj.loot.find { |l| l.name == 'spinach-paste steamed dumpling' && !junk.include?(l.id) })
						fput("get ##{dumpling.id}")
						2.times { fput("gobble ##{dumpling.id}") }
					end
				end
			end
		end

		# Use Symbol of Dreams
		if Spell[9824].known? && throttle.call(:dream)
			heal.call
			bounty.call
			if gsf
				# Go to a table to avoid being woken with nudges.
				go2.call(table_room)
				fput('go table')
			else
				nexus.call
			end
			log.call('Dreaming.')
			Spell[9824].cast
			flush.call
		end
	end
}

# return_from_hunt:  get back to town from a hunting area
return_from_hunt = proc {
	# Stance.
	fput('stance defensive') unless checkstance('defensive')

	# Get to our resting room.
	go2.call(Vars.op['resting_room_id']) if Vars.op['resting_room_id'].length > 0

	# Try to teleport out of places that are annoying to leave.
	if Room.current.location == 'the Ruined Temple'
		fly2.call(1983) # fly to Teras Voln
		go2.call(1982) # go to an adjacent room, because disks won't follow us to Voln
	elsif Room.current.id == 2635 # Birthing Sands
		fly2.call(2804) # fly to Pinefar Voln
		go2.call(3234) # go to Icemule
	elsif !(Vars.op['resting_room_id'].length > 0)
		go2.call('town')
	end
}

# $play_stop_hunting:  decide if the current hunt should end
$play_stop_hunting = proc { |bandits = false|
	# serious injury
	hurt.call(:serious) ||
	# bounty complete
	((checkbounty =~ /^You (?:succeeded|have located)|your task is failed/ || skinning_bounty_complete.call) && Vars.op['fried'].to_i > 100 && (percentmind >= 100 || bandits)) ||
	# child found
	(checkbounty =~ /^You have made contact with the child/ && GameObj.npcs.any? { |npc| npc.name =~ /\bchild\b/ }) ||
	# new bounty available
	(checkbounty =~ /^You are not currently assigned / && !Spell[9003].active? && (char_settings['stop-hunting'] || char_settings['percentmind'] >= 100)) ||
	# dispelled
	self_cast_list.any? { |s| Spell[s].known? && !Spell[s].active? && (Spell[s].stackable? || Spell[s].renew_cost > 0) && !(char_settings['skip-spells'] + skipped_songs).include?(s) } ||
	# sonic gear failure
	[1009, 1012, 1014].any? { |s| !char_settings[s.to_s].nil? && Spell[s].known? && !Spell[s].active? } ||
	# stuck (set boundaries around rooms considered a fail state, e.g. the Thanatoph pile)
	(!bandits && (Room.current.wayto.keys - Vars.op['hunting_boundaries'].split(/ *, */)).empty?) ||
	# not in the list of hunting rooms
	(!bandits && hunt_setting.call('interior_rooms') && !hunt_setting.call('interior_rooms').include?(Room.current.id)) ||
	# play is stopping
	stop_script
}

# bandits:  do a bandit bounty
bandits = proc {
	signs = Vars.op['signs'].length > 0 ? Vars.op['signs'].split(/\s*,\s*/).map { |s| s.to_i } : []

	# Nudge for spells before bandits if not nudging before regular hunts.
	if char_settings['get-spellups'] && hunt_setting.call('options').include?(:dont_get_spellups)
		nexus.call
		fput('act just nudged you.')
		sleep(30)
	end

	# Go to the bounty location.
	go2.call(bandit_rooms[0])

	$bigshot_should_rest = false
	stop = proc {
		$play_stop_hunting.call(:bandits) || $bigshot_should_rest || percentmana < Vars.op['oom'].to_i || (Vars.op['encumbered'].length > 0 && percentencumbrance >= Vars.op['encumbered'].to_i)
	}

	loop {
		if checkpcs
			# Don't poach.
			fput('disband')
		else
			# Clear the room.
			until stop.call
				# Cast signs.
				for s in signs
					update_renewal_cost.call
					Spell[s].cast if !Spell[s].active? && Spell[s].affordable? && checkmana(Spell[s].mana_cost + $play_renewal_cost)
				end

				# Stance.
				waitrt?
				fput('stance defensive') unless checkstance('defensive')

				# Wait for bandits to appear.
				bandit = nil
				20.times {
					break if (bandit = GameObj.npcs.find { |n| n.type =~ /\bbandit\b/ && n.status !~ /\bdead\b/ })
					sleep(0.1)
				}
				break if bandit.nil?

				# Attack.
				$bigshot_headless = true
				run_commands.call(char_settings['attack'])
			end
		end
		break if stop.call

		# Wander.
		ways = Room.current.wayto.keys.select { |w| bandit_rooms.map { |r| r.to_s }.include?(w) && ((timeto = Room.current.timeto[w]).class != Proc || !timeto.call.nil?) }
		break unless (w = Room.current.wayto[ways.sample])
		if w.class == String
			move(w)
		else
			w.call
		end
	}

	# Get back to town.
	return_from_hunt.call
}

# search:  do a search bounty
search = proc {
	boundaries = Vars.op['hunting_boundaries'].split(/ *, */) + search_boundaries.map { |b| b.to_s }
	skip_rooms = []
	peace = false

	# Get to our hunting room.
	go2.call(Vars.op['hunting_room_id'])

	while checkbounty =~ /SEARCH the area until you find it/ && !hurt.call(:serious) && !stop_script
		# Wander.
		ways = (Room.current.wayto.keys - boundaries).select { |w| (timeto = Room.current.timeto[w]).class != Proc || !timeto.call.nil? }
		break unless (w = Room.current.wayto[ways.sample])
		if w.class == String
			move(w)
		else
			w.call
		end
		break if hunt_setting.call('interior_rooms') && !hunt_setting.call('interior_rooms').include?(Room.current.id)
		next if skip_rooms.include?(Room.current.id)
		next if GameObj.npcs.any? { |n| n.type =~ /\baggressive\b/ }

		# Peace.
		update_renewal_cost.call
		if !peace && Spell[1011].known? && Spell[1011].affordable? && checkmana(Spell[1011].mana_cost + $play_renewal_cost)
			Spell[1011].cast
			peace = true # Spell[1011].active? is unreliable so track this ourselves
		end

		# Haste.
		update_renewal_cost.call
		for s in [535, 1035]
			Spell[s].cast if Spell[s].known? && !Spell[s].active? && Spell[s].affordable? && checkmana(Spell[s].mana_cost + $play_renewal_cost)
		end

		# Search.
		fput('stance defensive') unless checkstance('defensive')
		fput('kneel')
		junk = GameObj.loot.map { |l| l.id }
		r = dothistimeout('search', 1, /^You intently search the area|^You put your head to the|^You don't find anything|^You spy/)
		skip_rooms.push(Room.current.id) if r =~ /^You don't find anything/
		waitrt?
		GameObj.loot.select { |l| !junk.include?(l.id) && l.name !~ /\b#{checkname} disk$/ }.each { |l| fput("_drag ##{l.id} ##{lootsack.call.id}") }
		fput('stand') until standing?
		waitrt?
	end

	# Get back to town.
	return_from_hunt.call

	# Stop Peace.
	if peace
		dothis('stop 1011', /^You stop singing Song of Peace\.$|^You stop singing\.$|^You are not singing that song\.$/)
		Spell[1011].putdown
	end
}

# escort:  do an escort bounty
escort = proc { |destination|
	log.call("Escorting traveler to #{destination}.") unless char_settings['log-flags'] =~ /b/

	# Top off spells.
	spellup.call(:full)

	# Nudge for spells before bandits if not nudging before regular hunts.
	if char_settings['get-spellups'] && hunt_setting.call('options').include?(:dont_get_spellups)
		nexus.call
		fput('act just nudged you.')
		sleep(30)
	end

	# Wait for mana after spelling up.
	get_mana.call unless full_mana.call
	wait_until { full_mana.call }

	# Stock up on herbs if we're close to WL (which is where ;useherbs fill always goes).
	if Room.current.dijkstra[1][325] < 60
		go2.call(325)
		empty_hands
		script_run.call('useherbs', 'fill')
		fill_hands
		sell_loot.call
	end

	# Create an attack script for ego2.
	attack_script_name = "attack-play-#{checkname.gsub(/[^a-z]/i, '')}"
	attack_script = "$bigshot_headless = true\n"
	for cmd in char_settings['attack'].split(/\s*,\s*/)
		if cmd =~ /^;(\S+)(?:\s+(\S.*))?/
			script, args = $1, $2
			attack_script += "start_script(#{script.inspect}, #{(args.nil? ? [] : [args]).inspect})\n"
		else
			cmd = $1
			attack_script += "fput(#{cmd.inspect})\n"
		end
	end
	File.write("#{SCRIPT_DIR}/#{attack_script_name}.lic", attack_script)

	# Run ego2.
	char_settings[:remove_escort_bounty] = true # if ego2 doesn't finish the bounty, don't try to start over
	update_renewal_cost.call
	script_run.call('ego2', "--attack-script=#{attack_script_name}", '--useherbs=yes')

	# Clean up.
	File.unlink("#{SCRIPT_DIR}/#{attack_script_name}.lic") rescue nil
}

# Restore bigshot's settings on exit.
old_wounded_eval = nil
before_dying {
	Vars.op['wounded_eval'] = old_wounded_eval unless old_wounded_eval.nil?
}

# hunt:  run bigshot
hunt = proc {
	# Get to our hunting room.
	go2.call(Vars.op['hunting_room_id'])

	# Activate a loot boost when starting a hunting bounty.
	if activate_loot_boost == :yes && !Spell[9100].active? && !Spell[9101].active?
		if dothistimeout('boost loot major', 5, /^\[You have activated a Major Loot Boost\.  Your chances for better LOOT will be boosted for 15 minutes\.\]$|^You do not have any Major Loot Boosts to redeem\.$/) =~ /^You do not/
			unless dothistimeout('boost loot minor', 5, /^\[You have activated a Minor Loot Boost\.  Your chances for better LOOT will be boosted for 15 minutes\.\]$|^You do not have any Minor Loot Boosts to redeem\.$/) =~ /^You do not/
				log.call('Activated minor loot boost.')
			end
		else
			log.call('Activated major loot boost.')
		end
	end
	activate_loot_boost = :no

	# Tell bigshot when to stop hunting.
	old_wounded_eval = Vars.op['wounded_eval']
	Vars.op['wounded_eval'] = '$play_stop_hunting.call'

	# Run bigshot.
	$bigshot_headless = true
	update_renewal_cost.call
	script_run.call('bigshot', 'bounty')

	# Restore original wounded_eval.
	Vars.op['wounded_eval'] = old_wounded_eval
	old_wounded_eval = nil

	# Get back to town.
	if checkbounty =~ /^You have made contact with the child/ && GameObj.npcs.any? { |npc| npc.name =~ /\bchild\b/ }
		# If we're bringing a child home, use child2.
		log.call('Rescuing child.') unless char_settings['log-flags'] =~ /b/
		fput('stance defensive') unless checkstance('defensive')
		update_renewal_cost.call
		script_run.call('child2', 'mana', $play_renewal_cost.to_s)
		script_start.call('child2')
		wait_while { Script.running?('child2') && !Script.paused?('child2') && checkbounty =~ /^You have made contact with the child/ }
		kill_script('child2') if Script.running?('child2')
		go2.call('advguard') # make sure we're back around town if child2 failed
		if Spell[1011].known?
			# This can stay active without lich realizing it, so always try to stop it.
			dothis('stop 1011', /^You stop singing Song of Peace\.$|^You stop singing\.$|^You are not singing that song\.$/)
			Spell[1011].putdown
		end
	else
		return_from_hunt.call
	end
}

# pay_debt:  pay off any town debt
pay_debt = proc {
	put('wealth quiet')
	if dothistimeout('exp', 5, /^In the back of your mind you remember you owe a debt of \d+ silvers in the town of .*\.$|^ +Level:/) =~ /(\d+) silvers in the town of (.*)\.$/
		debt, town = $1, $2
		room = {
			"Wehnimer's Landing" => 7971,
			"Icemule Trace" => 2438,
			"Solhaven" => 12821,
			"Kharam-Dzu" => 1893,
			"Ta'Illistim" => 18148,
			"Ta'Vaalor" => 12347,
		}[town]
		if room && Room.current.dijkstra[1][room] < 60
			log.call("Paying debt of #{debt} to #{town}.")
			go2.call('bank')
			empty_hands
			fput("withdraw #{debt} note")
			go2.call(room)
			fput("pay #{debt}")
			fill_hands
		end
	end
}

# get_deeds:  get deeds if needed
checked_deeds = false
get_deeds = proc {
	if !checked_deeds && char_settings['get-deeds'] && Script.exists?('ruby-deed') && Stats.level >= 10
		dothis('exp', /^ +Experience: [\d,]+ +Deeds: \d+ *$/) =~ /Deeds: (\d+)/
		checked_deeds, cur_deeds = true, $1.to_i
		if cur_deeds < min_deeds
			buy_deeds = max_deeds - cur_deeds

			if Room.current.dijkstra[1][400] < 300 && Script.exists?('ruby-deed') # Landing
				log.call("Getting #{buy_deeds} deeds.")
				script_run.call('ruby-deed', buy_deeds.to_s)
			end
		end
	end
}

sing_gems = proc { |min_value|
	if Spell[1004].known?
		char_settings[:total_gems_purified] ||= 0
		char_settings[:total_gems_destroyed] ||= 0
		char_settings[:total_gems_skipped] ||= 0
		for gem in lootsack.call.contents.select { |c| c.type =~ /\bgem\b/ && c.type !~ /\bcursed\b/ }
			need_to_sell_loot = true
			break if stop_script
			fput("get ##{gem.id}")
			if min_value > 0 && dothistimeout("appraise ##{gem.id}", 5, /^You peer intently/) =~ /(\d+) silver/ && $1.to_i < min_value
				fput("put ##{gem.id} in ##{lootsack.call.id}")
				char_settings[:total_gems_skipped] += 1
				next
			end
			last_cast = false
			loop {
				break if stop_script
				update_renewal_cost.call
				get_mana.call unless checkmana(Spell[1004].mana_cost + $play_renewal_cost)
				wait_until { Spell[1004].affordable? && checkmana(Spell[1004].mana_cost + $play_renewal_cost) }
				r = Spell[1004].cast("##{gem.id}", /^(?:In response to your voice|As you focus your voice|As the gem resonates|As the gem vibrates|As the song continues|Your focused voice causes)/)
				if r =~ /shatter into thousands/
					char_settings[:total_gems_destroyed] += 1
					break
				elsif last_cast || r =~ /cannot be purified|severely affecting|you hear it crack loudly and strain|improves somewhat/
					char_settings[:total_gems_purified] += 1
					break
				elsif r =~ /smoother and more pure in color/
					last_cast = true
				elsif r =~ /becomes more perfect/
					# Keep going.
				else
					echo("Unexpected result: #{r}")
					break
				end
			}
			fput("put ##{gem.id} in ##{lootsack.call.id}")
			heal.call
		end
	end
}

# Exit on death.
Thread.new {
	wait_until { dead? }
	Script.self.kill
}

# Use long-term experience boosts when hunting while fried.
Thread.new {
	loop {
		wait_until {
			char_settings['boost-longterm'] &&
			Script.running?('bigshot') &&
			!Script.running?('ego2') &&
			Vars.op['fried'].to_i > 100 &&
			percentmind == 100 &&
			checkbounty !~ /^You (?:succeeded|have located) / &&
			!GameObj.npcs.any? { |n| n.type =~ /\baggressive\b/ } &&
			[checkrt, checkcastrt].max == 0
		}
		put('boost longterm')
		sleep(60)
	}
}

# Deal with being stunned/webbed.
Thread.new {
	loop {
		wait_until { stunned? || webbed? }
		put('symbol transcend confirm') if Spell[9812].known? && !Spell[9812].active? && !Spell[9049].active? && GameObj.npcs.any? { |n| n.type =~ /\baggressive\b/ }
		put('stop time') if Spells.majorelemental >= 50 && Stats.level >= 50 && checkmana(50) && checkcastrt == 0 && throttle.call('stop_time')
		put('shout 1040') if Spell[1040].known? && Spell[1040].affordable? && checkrt == 0 && checkcastrt == 0
		sleep(1)
	}
}

# Connect to our LNet channel for sharing mana.
LNet.tune_channel('play') if char_settings['share-mana']

# Provide services.
bot_mutex = Mutex.new
bot_services = false
$play_bot_proc = proc { |instance|
	loop {
		line = get
		exit unless Script.running?(script_name) && $play_instance == instance
		bot_mutex.synchronize {
			if line =~ /^\w+ just gave you (?:\d+ coins|a coin) which you quickly pocket\.$/
				# Deposit coins.
				need_to_sell_loot = true
			elsif char_settings['share-mana'] && line =~ /^\[play\]-#{XMLData.game}:(\w+): "mana (\d+) (\d+) (\d+)"$/
				# Share spare mana.
				customer, emc, mmc, smc = $1, $2, $3, $4
				next unless bot_services
				next unless customer_id = GameObj.pcs.find { |pc| pc.noun == customer }.id
				next unless (Skills.emc >= 24 && emc.to_i >= 24) || (Skills.mmc >= 24 && mmc.to_i >= 24) || (Skills.smc >= 24 && smc.to_i >= 24)
				next unless Vars.op['fried'].to_i <= 100 && percentmind > char_settings['percentmind']
				amount = spare_mana.call
				if amount > 1
					next unless throttle.call("share_mana_#{customer}")
					fput("send #{amount} ##{customer_id}")
					char_settings[:sent_mana] ||= {}
					char_settings[:sent_mana][customer] ||= [0, nil, 0]
					char_settings[:sent_mana][customer][1] = Time.now
					char_settings[:sent_mana][customer][2] += 1
				end
			elsif char_settings['give-spellups'] && line =~ /^\(?(\w+) just nudged you\.\)?$/
				# Provide spellups when nudged.
				customer = $1
				next unless bot_services
				next if customer == checkname
				next unless Vars.op['fried'].to_i <= 100 && percentmind > char_settings['percentmind']
				next unless throttle.call("spellup_#{customer}")
				next unless spells = LNet.get_data(customer, 'spells')
				next unless skills = LNet.get_data(customer, 'skills')
				#echo("#{customer}: #{skills.collect { |k, v| sprintf('%s => %d', k.to_s.dump, v.to_i) }.join(', ') }")
				for s in nudge_cast_list
					next unless Spell[s].known?
					update_renewal_cost.call
					next unless Spell[s].affordable? && checkmana(Spell[s].mana_cost + $play_renewal_cost)
					next if spells[s.to_s].to_f >= eval(Spell[s].duration) - 10
					next if skills[Spells.get_circle_name(Spell[s].circle)].to_i >= s % 100
					break unless customer_id = GameObj.pcs.find { |pc| pc.noun == customer }.id
					cast(s, "at ##{customer_id}")
					sleep(3)
				end
			elsif char_settings['loresing'] && Script.exists?('testme') && line =~ /^(\w+) offers you (.+)\.  Click ACCEPT to accept the offer or DECLINE to decline it\.  The offer will expire in 30 seconds\.$/
				# Loresing items we're handed.
				customer, item = $1, $2
				unless bot_services
					multifput("whisper #{customer} Busy.", 'decline')
					next
				end
				next unless customer_id = GameObj.pcs.find { |pc| pc.noun == customer }.id
				next if checkright || checkleft
				update_renewal_cost.call
				mana_needed = $play_renewal_cost + Spell[405].mana_cost + 20
				if !checkmana(mana_needed)
					get_mana.call
					50.times {
						break if checkmana(mana_needed)
						sleep(0.1)
					}
				end
				if !checkmana(mana_needed)
					multifput("whisper #{customer} Not enough mana.", 'decline')
				elsif dothistimeout('accept', 5, /^You accept /)
					log.call("Loresinging #{item} for #{customer}.")
					File.unlink("#{$lich_dir}logs/testme.log") rescue nil
					begin
						Vars.testme_save = 'yes'
						start_script('testme', ['lore', 'skip'])
						wait_while { Script.running?('testme') && !stop_script }
						if stop_script
							kill_script('testme') if Script.running?('testme')
							next
						end
						lore = File.readlines("#{$lich_dir}logs/testme.log").map { |l|
							l.gsub(/[^A-Za-z0-9+\-:,'.\/() ]/, '').gsub(/  +/, ' ')
						}.select { |l|
							l =~ /\w/ &&
							l !~ /^(?:
								Look\ description: |
								Loresong\ information |
								Inspect\/Analyze\ Information |
								Ensorcell\ Information |
								Alteration\ restrictions: |
								Can\ be\ lightened: |
								Pockets\ can\ be\ deepened:\ Yes |
								I\ didn't\ find\ any\ zests
							)/x
						}.join(' - ')
						fput("whisper #{customer} #{lore}")
						waitrt?
					rescue
						echo('Loresinging failed.')
					end
					r = dothistimeout("give ##{customer_id}", 31, /^\w+ has accepted your offer |^\w+ has declined the offer\.$|^What is it you're trying to give\?$/)
					multifput('set saferdrop off', 'set nomarkeddrop off', 'put right in crater', 'drop right') unless r =~ /has accepted/
				end
			end
		}
	}
}
if gsf
	Thread.new {
		loop {
			bot = script_exec.call("hide_me; $play_bot_proc.call(#{$play_instance.inspect})")
			wait_while { Script.running?(bot) }
		}
	}
end

# Get healing and spells after dying.
rest_time = 0
if maxspirit < (Stats.aur[0] / 10.0).round
	fput('spell active') # durations are incorrect after symbol of recall
	if gsf
		nexus.call
		fput('act just nudged you.') if char_settings['get-spellups'] && !hunt_setting.call('options').include?(:dont_get_spellups)
		rest_time = 30
	end
end

# Begin the main loop.
loop {

# Empty hands.
fput('stow all') if checkright || checkleft

# Run errands.
get_deeds.call
pay_debt.call

# Start providing services.
bot_mutex.synchronize { bot_services = true }

# Stay still for a moment if needed.
rest_time.times {
	break if stop_script
	sleep(1)
}

# Wait until we're ready to hunt.
ready = !gsf
until ready
	break if stop_script

	bot_mutex.synchronize {
		# Try to solve problems that prevent us from hunting in order of priority.
		if checkpoison || checkdisease
			cure.call
		elsif checkright || checkleft
			uncurse.call
		elsif maxspirit < (Stats.aur[0] / 10.0).round
			recover.call
		elsif need_to_sell_loot || (Vars.op['encumbered'].length > 0 && percentencumbrance >= Vars.op['encumbered'].to_i)
			sell_loot.call(:sell_all_gems)
		elsif percentmind > (Vars.op['fried'].to_i > 100 ? 100 : char_settings['percentmind'])
			idle.call
		elsif !full_mana.call
			get_mana.call
		elsif percentspirit < char_settings['percentspirit']
			get_spirit.call
		else
			ready = true
		end

		# Check on health/bounty/location/spells while waiting to hunt.
		heal.call
		bounty.call unless Spell[9824].active? && !ready
		nexus.call unless Spell[9824].active? || ready
		spellup.call unless Spell[9824].active? && !ready

		# Healing or spelling up may have consumed mana.
		ready = false unless full_mana.call
	}

	sleep(1) unless ready
end

# Stop providing services.
bot_mutex.synchronize { bot_services = false }

# Stop if requested.
if stop_script
	if need_to_sell_loot
		sell_loot.call(:sell_all_gems)
		nexus.call
	end
	exit
end

# Get a disk.
crystal = stowsack.call.contents.find { |c| c.name == 'black crystal' }
if Spell[511].known? || (crystal && hunt_setting.call('targets_carry_boxes'))
	disk = nil
	50.times {
		break if (disk = GameObj.loot.find { |l| l.name =~ /\b#{checkname} disk$/ })
		sleep(0.1)
	}
	unless disk
		if Spell[511].known?
			update_renewal_cost.call
			get_mana.call unless checkmana(Spell[511].mana_cost + $play_renewal_cost)
			wait_until { Spell[511].affordable? && checkmana(Spell[511].mana_cost + $play_renewal_cost) }
			Spell[511].cast
		else
			multifput("get ##{crystal.id}", "rub ##{crystal.id}", "stow ##{crystal.id}")
		end
	end
end

# Get our equipment ready.
unless checkbounty =~ /SEARCH the area until you find it/
	fput('gird')
	if Vars.op['bless'] && (bless = char_settings['bless'])
		for item in [GameObj.right_hand, GameObj.left_hand, *GameObj.inv, *arrowsack.call.contents].select { |i| i.name =~ /#{bless}/ }
			if dothis("look ##{item.id}", /^You see nothing unusual|^You also notice a small enchanter's glyph|^A faint aura of holy light radiates|^You carefully count|^There appears to be something written on it/) !~ /aura of holy light/
				if Spell[1604].known?
					nexus.call
					update_renewal_cost.call
					get_mana.call unless checkmana(Spell[1604].mana_cost + $play_renewal_cost)
					wait_until { Spell[1604].affordable? && checkmana(Spell[1604].mana_cost + $play_renewal_cost) }
					Spell[1604].cast("##{item.id}")
				end
				if Spell[304].known?
					nexus.call
					update_renewal_cost.call
					get_mana.call unless checkmana(Spell[304].mana_cost + $play_renewal_cost)
					wait_until { Spell[304].affordable? && checkmana(Spell[304].mana_cost + $play_renewal_cost) }
					Spell[304].cast("##{item.id}")
				elsif Spell[9802].known? && char_settings['symbol-blessing']
					nexus.call
					Spell[9802].cast("##{item.id}")
				elsif gsf && item.id == GameObj.right_hand.id || item.id == GameObj.left_hand.id
					echo('Bless needed.')
					swap = (item.id == GameObj.left_hand.id)
					fput('swap') if swap
					loop {
						until checkpcs.include?('Alfred')
							heal.call
							nexus.call
							sleep(1)
						end
						log.call('Requesting bless.')
						break if dothistimeout('whisper Alfred bless', 60, /^A searing white light enfolds your .* for a moment and then appears to become incorporated into it\.$/)
						sleep(60)
					}
					fput('swap') if swap
				else
					panic.call("can't bless #{item.name}")
				end
			end
		end
	end
	for spell in [1009, 1012, 1014].select { |s| !char_settings[s.to_s].nil? && Spell[s].known? }
		if spell != 1014 && Spell[spell].active?
			dothis("stop #{spell}", /^You stop singing Sonic (?:Shield|Weapon) Song\.$|^You stop singing\.$|^You are not singing that song\.$/)
			Spell[spell].putdown
		end
		until Spell[spell].active?
			nexus.call
			panic.call("can't cast #{spell}") unless Spell[spell].known?
			update_renewal_cost.call
			get_mana.call unless checkmana(Spell[spell].mana_cost + $play_renewal_cost)
			wait_until { Spell[spell].affordable? && checkmana(Spell[spell].mana_cost + $play_renewal_cost) }
			Spell[spell].cast(char_settings[spell.to_s])
			flush.call
		end
	end
end

# Stance
fput('stance defensive') unless checkstance('defensive')

# Do a bounty or hunt.
if stop_script
	# nevermind
elsif checkbounty =~ /suppress bandit activity/
	bandits.call
elsif checkbounty =~ /SEARCH the area until you find it/
	search.call
elsif checkbounty =~ /safety to (.*?) as soon as you can/
	escort.call($1)
else
	hunt.call
end

# Put our equipment away.
if Spell[1009].active?
	dothis('stop 1009', /^You stop singing Sonic Shield Song\.$|^You stop singing\.$|^You are not singing that song\.$/)
	Spell[1009].putdown
elsif GameObj.left_hand.type =~ /\barmor\b/ || GameObj.left_hand.noun =~ /bow$/
	fput("wear ##{GameObj.left_hand.id}")
end
if Spell[1012].active?
	dothis('stop 1012', /^You stop singing Sonic Weapon Song\.$|^You stop singing\.$|^You are not singing that song\.$/)
	Spell[1012].putdown
end
fput('stow all') if checkright || checkleft

# Get healing if needed.
cure.call
heal.call

# Turn in bounties.
bounty.call

# Sell loot.
sell_loot.call

# Go to our resting spot.
nexus.call

# Purify gems.
if (min_value = char_settings['sing-gems'])
	min_value = 0 if min_value == true
	sing_gems.call(min_value)
end

# Give gems to Alfred.
if gsf && char_settings['alfred-gems'] && checkpcs.include?('Alfred') && !(gems = lootsack.call.contents.select { |c| c.name =~ /^uncut (?:diamond|emerald)$/ }).empty?
	for g in gems
		fput("get ##{g.id}")
		r = dothistimeout("give ##{g.id} to Alfred", 6, /^Alfred has accepted/)
		fput("put ##{g.id} in ##{lootsack.call.id}") unless r
	end
end

# Deal with items remaining in our lootsack.
if lootsack.call.id != stowsack.call.id
	for item in lootsack.call.contents.select { |i| i.type !~ /\b(?:cursed|gem)\b/ }
		fput("get ##{item.id}")
		if gsf && (!trash_loot_types.empty? && item.type =~ /\b(?:#{trash_loot_types.join('|')})\b/)
			log.call("Trashing #{item.name}.")
			fput("put ##{item.id} in #{nexus_trash}")
		else
			log.call("Stowing #{item.name}.")
			fput("stow ##{item.id}")
		end
		fput("put ##{item.id} in ##{lootsack.call.id}")
	end
end

# Run rest commands.
run_commands.call(char_settings['rest'])
nexus.call

# Top off spells.
spellup.call(:full)
if gsf
	fput('act just nudged you.') if char_settings['get-spellups'] && !hunt_setting.call('options').include?(:dont_get_spellups)
	rest_time = 30
end

# Exit after finishing a bounty/hunt in Prime.
unless gsf
	log.call('Done.')
	exit
end

# End the main loop.
}
