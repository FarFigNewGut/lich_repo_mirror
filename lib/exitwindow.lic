=begin
  Original Wrayth FE Window
    https://discordapp.com/channels/226045346399256576/1339018254517145681

    New GTK Window for Avalon and Wizard FEs
    https://discordapp.com/channels/226045346399256576/1386507836191670342

  This script creates a dedicated window to display room exit information in real time.

  Features:
  - Continuously updates with the current rooms exits.
  - Displays clickable exits for both standard and Lich exits.
  - Uses consistent window formatting.
  - Supports ;go2 navigation for Lich exits.
  - Trash containers added.
  - Lichid and Uid added.

    Commands:
         *ewgtk - Enable GTK window.

  Changelog:
   1.1.0 (2025-06-22)
        Added Wizard and Avalon FE compatability via implementation of a GTK window.
   1.0.0 (2025-02-11)
        Initial release.

author: Phocosoen, ChatGPT
tags: wrayth, frontend, mod, window, paths, navigation, wizard, avalon
version: 1.1.0

=end

no_kill_all

require 'yaml'
require 'gtk3'

# where to store our window settings
LICH5_PATHS = [
  "C:\\Lich5\\scripts",
  File.expand_path("~/Desktop/Lich5/scripts")
]

WINDOW_SETTINGS_PATH = nil

LICH5_PATHS.each do |path|
  next unless path && Dir.exist?(path)
  WINDOW_SETTINGS_PATH = File.join(path, "lichwraythwindows.yaml")
  break
end

# Fallback if nothing matched
WINDOW_SETTINGS_PATH ||= File.join(Dir.ewd, "lichwraythwindows.yaml")

def load_window_settings
  return {} unless File.exist?(WINDOW_SETTINGS_PATH)
  YAML.load_file(WINDOW_SETTINGS_PATH) || {}
end

def save_window_settings(settings)
  File.write(WINDOW_SETTINGS_PATH, settings.to_yaml)
rescue => e
  echo "exitwindow: failed to save window settings: #{e.message}"
end

$exit_settings       = load_window_settings
$exit_window         = $exit_settings["exitwindow"] ||= {}
$use_gtk_window = $exit_window["use_gtk_window"] || false

# if they’ve explicitly enabled GTK, always launch it
if $use_gtk_window
  respond ""
  respond " Initiating GTK window."
  respond ""
  respond " GTK Exitwindow is active."
  respond ""
  Gtk.queue do
    ExitWindowGtk.create_main_window
    Gtk.main
  end

# otherwise fall back to “if non-Stormfront” auto-GTK
elsif $frontend != "stormfront"
  respond ""
  respond " Using a frontend other than Wrayth."
  respond ""
  respond " Initiating GTK window."
  respond ""
  Gtk.queue do
    ExitWindowGtk.create_main_window
    Gtk.main
  end
end

if $frontend == "stormfront"
  # Open the room info window using Wrayth's dynamic dialog.
  puts("<closeDialog id='Exits'/><openDialog type='dynamic' id='Exits' title='Exits' target='Exits' scroll='manual' location='main' justify='3' height='100' width='100' resident='true' ><dialogData id='Exits'></dialogData></openDialog>")
end

@last_room_id = nil

class ExitWindowGtk
  @window       = nil
  @css_provider = nil
  @font_size    = nil

  # Regenerates & reapplies our CSS (called after font‐size, mode, etc. change)
  def self.reload_css
    css = <<~CSS
						/* tighten up header-bar buttons */
						window#exitwindow headerbar .header-toggle {
								margin: 0 2px;    /* horiz space between buttons */
								padding: 2px 4px; /* shrink the click target */
						}

						/* give the whole window a 2px solid grey border */
						window#exitwindow {
								border: 0px solid #888888;
								border-radius: 4px;
						}

      /* Base label font size */
      window#exitwindow label {
        font-size: #{@font_size}px;
      }

      /* Light-mode background */
      window#exitwindow:not(.dark),
      window#exitwindow:not(.dark) headerbar,
      window#exitwindow:not(.dark) GtkScrolledWindow,
      window#exitwindow:not(.dark) GtkFlowBox {
        background-color: #393939;
      }

      /* Light mode text */
      window#exitwindow:not(.dark) label {
        color: #FFFFFF;
      }

      /* Dark-mode background */
      window#exitwindow.dark,
      window#exitwindow.dark headerbar,
      window#exitwindow.dark GtkScrolledWindow,
      window#exitwindow.dark GtkFlowBox {
        background-color: #000000;
      }

      /* Dark-mode text */
      window#exitwindow.dark label {
        color: #FFFFFF;
      }

      /* HeaderBar toggles/buttons in dark mode */
      window#exitwindow.dark headerbar .header-toggle {
        background-image: none;
        background-color: transparent;
        color:            #FFFFFF;
        border:           none;
        box-shadow:       none;
      }

      /* Highlight “on” state */
      window#exitwindow.dark headerbar .header-toggle:checked {
        background-color: #444444;
      }

    CSS

    @css_provider.load(data: css)
  end

  def self.create_main_window
    return if @window

    # ——— load persisted settings ———
    settings = load_window_settings
    ew = settings["exitwindow"] ||= {}
    dark_mode = ew["dark_mode"] || false
    @font_size = ew["font_size"] || 14

    # ——— build top‐level window & HeaderBar ———
    @window = Gtk::Window.new(:toplevel)
    @window.set_name("exitwindow")
    @window.set_border_width(10)
    @window.set_type_hint(Gdk::WindowTypeHint::UTILITY)
    @window.set_keep_above(true)

    header = Gtk::HeaderBar.new
    header.show_close_button = true
    header.title = "EW"

    # — Font size buttons —
    dec_btn = Gtk::Button.new(label: "A−")
    inc_btn = Gtk::Button.new(label: "A+")
    [dec_btn, inc_btn].each { |b| b.style_context.add_class("header-toggle"); header.pack_start(b) }
    dec_btn.signal_connect("clicked") do
      @font_size = [@font_size - 1, 8].max
      ew["font_size"] = @font_size; save_window_settings(settings)
      reload_css
    end
    inc_btn.signal_connect("clicked") do
      @font_size = [@font_size + 1, 30].min
      ew["font_size"] = @font_size; save_window_settings(settings)
      reload_css
    end

    # — Dark/Light switch —
    theme_switch = Gtk::Switch.new
    theme_switch.active = dark_mode
    @window.style_context.add_class("dark") if dark_mode
    theme_switch.signal_connect("notify::active") do |sw, _|
      if sw.active?
        @window.style_context.add_class("dark")
      else
        @window.style_context.remove_class("dark")
      end
      ew["dark_mode"] = sw.active?; save_window_settings(settings)
      reload_css
    end
    header.pack_end(theme_switch)

    @window.set_titlebar(header)

    # — CSS provider & initial styling —
    @css_provider = Gtk::CssProvider.new
    reload_css
    screen = Gdk::Screen.default
    Gtk::StyleContext.add_provider_for_screen(
      screen,
      @css_provider,
      Gtk::StyleProvider::PRIORITY_APPLICATION
    )

    # — Restore geometry —
    @window.resize(ew["width"], ew["height"]) if ew["width"] && ew["height"]
    @window.move(ew["x"], ew["y"]) if ew["x"] && ew["y"]

    @scroll = Gtk::ScrolledWindow.new
    @scroll.set_policy(Gtk::PolicyType::AUTOMATIC, Gtk::PolicyType::AUTOMATIC)
    @scroll.set_hexpand(true)
    @scroll.set_vexpand(true)

    @flow = Gtk::FlowBox.new
    @flow.selection_mode        = :none
    @flow.max_children_per_line = 1
    @flow.column_spacing        = 0
    @flow.row_spacing           = 0
    @flow.set_vexpand(true)
    @flow.valign                = Gtk::Align::START
    @flow.homogeneous           = false
    @scroll.add(@flow)

    @window.add(@scroll)

    # — save geometry on move/resize —
    @ignore_next_configure = true
    @window.signal_connect("configure_event") do |_w, _ev|
      if @ignore_next_configure
        @ignore_next_configure = false
      else
        x, y = @window.position
        w, h = @window.size
        s = load_window_settings
        s["exitwindow"] ||= {}
        s["exitwindow"].merge!("x" => x, "y" => y, "width" => w, "height" => h)
        save_window_settings(s)
      end
      false
    end

    @window.signal_connect("destroy") do
      @window = nil
      Gtk.main_quit
    end
    @window.show_all

    # — initial fill —
    if defined?(Room) && Room.current
      std   = extract_exits_from_paths(Room.current.paths)
      lich  = extract_lich_exits(Room.current.id)
      trash = extract_trash_containers
      ExitWindowGtk.update_exits(std, lich, trash)
    end
  end

  def self.update_exits(standard, lich, trash)
    return unless @window
    Gtk.queue do
      # clear out old widgets
      @flow.children.each { |c| @flow.remove(c) }

      # ---- ROOM INFO: Add once at the top! ----
      room_info = Gtk::Label.new("Lid#: #{Room.current.id}   Uid#: #{Room.current.uid.to_s.gsub(/\[|\]/, '')}")
      room_info.set_xalign(0)
      room_info.style_context.add_class("room-info")
      @flow.add(room_info)

      # helper to render a titled section of plain labels/buttons
      render_section = ->(items) do
        items.each do |it|
          display_label = it.is_a?(Hash) ? it[:label] : it.to_s
          # Optionally: make them clickable here if you want, as previously suggested
          line = Gtk::Label.new("#{display_label}")
          line.set_xalign(0)
          @flow.add(line)
        end
      end
      render_section.call(standard)
      render_section.call(lich)
      @flow.add(Gtk::Label.new(""))
      render_section.call(trash)

      @flow.show_all
    end
  end
end

# Extract standard exits from the room's paths.
def extract_exits_from_paths(paths)
  room_exits = []
  paths.each do |path|
    if path =~ /Obvious (?:paths|exits):\s*(.*)/i
      exits = $1.strip.split(/,\s*/).map(&:capitalize)
      room_exits.concat(exits)
    end
  end
  room_exits
end

# Extract Lich exits that are not standard movement directions.
def valid_exits(room_id)
  room = Room[room_id]
  return {} unless room

  room_exits = {}
  room.wayto.each do |key, value|
    next unless value.is_a?(String) || value.is_a?(Proc) # Ensure only valid exits

    room_exits[key] = { wayto: value, name: Room[key].title.first.gsub(/\[|\]/, '') }
  end

  room_exits
end

# Extract Lich exits using the valid_exits function.
def extract_lich_exits(room_id)
  room_exits = valid_exits(room_id) # Use the valid_exits function
  return [] if room_exits.nil? || !room_exits.is_a?(Hash) || room_exits.empty?

  ignored_directions = /^(?:o|d|u|n|ne|e|se|s|sw|w|nw|out|down|up|north|northeast|east|southeast|south|southwest|west|northwest|StringProc)$/

  lich_exits = []
  room_exits.each do |key, value|
    next unless value.is_a?(Hash) && value[:wayto] # Ensure :wayto exists
    next if value[:wayto].to_s.match?(ignored_directions) # Ignore obvious directions

    wayto_cmd = if value[:wayto].is_a?(String)
                  value[:wayto]
                elsif value[:wayto] == "StringProc"
                  ";go2 #{key}" # Default for unknown procs
                else
                  next
                end

    lich_exits << { label: "#{wayto_cmd}", cmd: wayto_cmd, destination: value[:name] }
  end
  lich_exits
end

# Extract trash container using the meta tag method.
def extract_trash_containers
  if (match = Room.current.tags.find { |t| t =~ /meta:trashcan:(.*)/ })
    # Use the match object to extract the trash container name and strip any extra whitespace.
    [match.match(/meta:trashcan:(.*)/)[1].strip]
  else
    []
  end
end

# Push exit and trash container data to the ExitWindow
def push_room_info_to_window(standard_exits, lich_exits, trash_containers)
  output = "<dialogData id='Exits' clear='t' wrap='true'>"

  # Room info at top (occupies 36 pixels)
  output += "<label id='room_info' value='Lid#: #{Room.current.id}' left='0' top='0' />"
  output += "<label id='room_info_uid' value='Uid#: #{Room.current.uid.to_s.gsub(/\[|\]/, '')}' left='0' top='18' />"

  # Spacing constants
  room_info_height = 36    # room info block height (0-36)
  header_height = 18       # height for a header label
  link_height = 18         # height for each link/label
  section_gap = 18 # gap between sections

  # Standard exits block
  standard_exits_header_top = room_info_height + section_gap # start at 36
  output += "<label id='total' value='Exits: #{standard_exits.size}' left='0' top='#{standard_exits_header_top}' />"

  standard_exits.each_with_index do |exit, index|
    exit_top = standard_exits_header_top + header_height + (link_height * index)
    output += "<link id='room_exit_#{index}' value='#{exit}' cmd='go #{exit.downcase}' echo='go #{exit.downcase}' left='0' top='#{exit_top}' />"
  end

  # Calculate end of standard exits block
  standard_exits_block_end = standard_exits_header_top + header_height + (link_height * standard_exits.size)

  # Lich exits block
  lich_exits_start = standard_exits_block_end + section_gap
  if lich_exits.any?
    output += "<label id='lich_exits' value='Lich Exits: #{lich_exits.size}' left='0' top='#{lich_exits_start}' />"
    lich_base_top = lich_exits_start + header_height
    lich_exits.each_with_index do |lich_exit, index|
      lich_exit_top = lich_base_top + (link_height * index)
      output += "<link id='lich_exit_#{index}' value='#{lich_exit[:cmd]}' cmd='#{lich_exit[:cmd]}' echo='#{lich_exit[:cmd]}' left='0' top='#{lich_exit_top}' font='normal' />"
    end
  end

  # Calculate end of Lich exits block
  lich_exits_block_end = lich_exits.any? ? (lich_exits_start + header_height + (link_height * lich_exits.size)) : standard_exits_block_end

  # Trash containers block
  trash_containers_start = lich_exits_block_end + section_gap
  if trash_containers.any?
    output += "<label id='trash_containers' value='Trash Containers: #{trash_containers.size}' left='0' top='#{trash_containers_start}' />"
    trash_base_top = trash_containers_start + header_height
    trash_containers.each_with_index do |trash, index|
      trash_top = trash_base_top + (link_height * index)
      output += "<label id='trash_#{index}' value='#{trash}' left='0' top='#{trash_top}' font='small' />"
    end
  end

  output += "</dialogData>"
  puts(output)
end

# Update room exit information.
def update_room_info
  standard_exits = extract_exits_from_paths(Room.current.paths)
  lich_exits = extract_lich_exits(Room.current.id)
  trash_containers = extract_trash_containers

  push_room_info_to_window(standard_exits, lich_exits, trash_containers)
end

UPSTREAM_HOOK_ID = "#{Script.current.name}_upstream".freeze

UpstreamHook.remove(UPSTREAM_HOOK_ID) rescue nil

UpstreamHook.add("#{Script.current.name}_upstream", proc do |cmd|
  case cmd.strip.downcase
  when /\*ewgtk/i
    $use_gtk_window = !$use_gtk_window
    respond "GTK Exitwindow is now #{$use_gtk_window ? 'ENABLED' : 'DISABLED'}."

    # persist the new setting
    settings = load_window_settings
    settings["exitwindow"] ||= {}
    settings["exitwindow"]["use_gtk_window"] = $use_gtk_window
    save_window_settings(settings)

    if $use_gtk_window
      # launch it if not already up
      Gtk.queue do
        ExitWindowGtk.create_main_window
        Gtk.main
      end
    else
      # close it if it exists
      if defined?(ExitWindowGtk) && ExitWindowGtk.instance_variable_get(:@window)
        Gtk.queue do
          ExitWindowGtk.instance_variable_get(:@window).close
        end
      end
    end

    nil
  else
    cmd
  end
end)

before_dying do
  UpstreamHook.remove("#{Script.current.name}_upstream")

  if defined?(ExitWindowGtk) && ExitWindowGtk.instance_variable_get(:@window)
    Gtk.queue { ExitWindowGtk.instance_variable_get(:@window).close }
  end
end

echo "Exitwindow is active." if $frontend == "stormfront"

loop do
  if @last_room_id != Room.current.id
    std   = extract_exits_from_paths(Room.current.paths)
    lich  = extract_lich_exits(Room.current.id)
    trash = extract_trash_containers

    update_room_info if $frontend == "stormfront"
    ExitWindowGtk.update_exits(std, lich, trash) if $use_gtk_window

    @last_room_id = Room.current.id
  end
  sleep 0.05
end
