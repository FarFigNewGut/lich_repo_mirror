=begin
  htsorter - Container contents organized by item categories

  Displays container contents organized by item categories with optional column formatting.
  Integrates with high_type.lic for category-based highlighting and shares configuration
  via UserVars.types_to_color. Items without specific colors default to link color.
  Waits for high_type to be active before starting operation.

  Examples:
    ;htsorter                     - Start the sorter (waits for high_type)
    ;htsorter width=80            - Set window width for column display
    ;htsorter width=nil           - Disable column formatting

  Revision History:
    v1.0.6 - 2025-09-18 - Fixed dependency version requirement, corrected duplicate bold color handling
    v1.0.5 - 2025-09-18 - Updated header to match script header template, removed orphaned revision block
    v1.0.4 - 2025-09-14 - Removed old compatibility fallbacks, now uses only UserVars.types_to_color
    v1.0.3 - 2025-09-14 - Added startup wait for high_type dependency
    v1.0.2 - 2025-09-14 - Default unassigned item types to link color (matches linktothefast behavior)
    v1.0.1 - 2025-09-14 - Fixed coloring issue, restored local color function for compatibility
    v0.9 - 2016-08-17 - Fix for the last fix
    v0.8 - 2016-08-07 - Fix for containers with XML content display
    v0.7 - 2015-04-16 - Fix display of broken containers on WizardFE

          author: Ensayn (based on sorter by Tillmen)
            game: GS
            tags: utility, organization, containers, high_type
        required: Lich >= 4.6, high_type >= 2.1.0
         version: 1.0.6
=end

if script.vars[1] =~ /^width=([0-9]+|nil)$/
  if $1 == 'nil'
    CharSettings['screen_width'] = nil
  else
    CharSettings['screen_width'] = $1.to_i
  end
  echo 'setting saved'
  exit
elsif script.vars[1]
  output = "\n"
  output.concat "   #{$clean_lich_char}#{script.name} width=<#>     Specify how many characters wide your game window is, and the script will\n"
  output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}               display container contents in columns.\n"
  output.concat "\n"
  output.concat "   #{$clean_lich_char}#{script.name} width=nil     Clear the setting.\n"
  output.concat "\n"
  respond output  
  exit
end

if defined?(GameObj.type_data)
  GameObj.load_data if GameObj.type_data.empty? or GameObj.type_data.nil?
  if GameObj.type_data.nil?
    wait_while { running?('updater') }
    wait_while { running?('repository') }
    start_script 'repository', [ 'download', 'gameobj-data.xml' ]
    wait_while { running?('repository') }
    wait_while { running?('updater') }
    start_script 'updater', [ 'add', 'gameobj-data.xml' ]
    wait_while { running?('updater') }
    GameObj.load_data
    exit if GameObj.type_data.nil?
  end
end

script.want_downstream = false
script.want_downstream_xml = true
hide_me

#------------------------------------------------------------------------------#
# Wait for high_type to be fully initialized before starting
#------------------------------------------------------------------------------#
echo "htsorter starting - waiting for high_type to be fully active..."
wait_while { !running?('high_type') }
echo "htsorter detected high_type running - continuing startup..."

# Configuration compatibility - reads from UserVars (shared with high_type)
# htsorter maintains its own color function but uses shared configuration

show_sellable = false

# Helper method to get category color from UserVars (shared configuration)
def get_category_color(category_name)
  # Check UserVars first (new shared system)
  if UserVars.types_to_color && UserVars.types_to_color[category_name]
    return UserVars.types_to_color[category_name]
  end

  # Fall back to old high_type instance variables for compatibility
  if defined?(@types_to_color) && @types_to_color && @types_to_color[category_name]
    return @types_to_color[category_name]
  end

  if defined?(@types_to_preset) && @types_to_preset && @types_to_preset[category_name]
    return @types_to_preset[category_name]
  end

  # Return nil if no color configuration exists
  return nil
end

# Helper method to find matching color for multi-type items (like "gem,collectible")
def get_item_color(item_types)
  return nil unless item_types

  # Check each configured color type to see if it matches any of the item's types
  if UserVars.types_to_color
    UserVars.types_to_color.each do |config_type, color|
      # Use regex matching like high_type does
      if item_types =~ /#{config_type}/
        return color
      end
    end
  end

  return nil
end

# Helper method to format text with colors (restored local function for compatibility)
def format_with_high_type_color(text, category_name)
  # For multi-type items (like "gem,collectible"), use the new matching logic
  color = get_item_color(category_name)

  # Default to "link" color if no specific color assigned (matches linktothefast behavior)
  color ||= "link"

  # Use local color function with shared UserVars configuration
  return self.color(text, color, true)
end

# Simplified color function that only supports valid high_type colors
def self.color(msg, color_type, skip_encoding=false)
  encoded_msg = skip_encoding || msg.include?('<a ') ? msg : msg.encode(:xml => :text)

  case color_type.downcase
  when "monsterbold"
    monsterbold_start = $fake_stormfront ? "\034GSL\r\n " : "<pushBold\/>"
    monsterbold_end = $fake_stormfront ? "\034GSM\r\n " : "<popBold\/>"
    return "#{monsterbold_start}#{encoded_msg}#{monsterbold_end}"
  when "bold"
    return "<preset id=\"bold\">#{encoded_msg}</preset>"
  when "speech"
    return "<preset id=\"speech\">#{encoded_msg}</preset>"
  when "whisper"
    return "<preset id=\"whisper\">#{encoded_msg}</preset>"
  when "thought"
    return "<preset id=\"thought\">#{encoded_msg}</preset>"
  when "link"
    return "<preset id=\"link\">#{encoded_msg}</preset>"
  when "selectedlink", "selected"
    return "<preset id=\"selectedLink\">#{encoded_msg}</preset>"
  else
    # Default to link for unknown colors (matches high_type behavior)
    return "<preset id=\"link\">#{encoded_msg}</preset>"
  end
end

best_column_count = proc { |list|
  num_columns = 1
  loop {
    items_per_column = (list.length / num_columns.to_f).ceil
    total_width = 0
    for column_num in 0...num_columns
      max_width = 0
      list[(column_num*items_per_column)...((column_num+1)*items_per_column)].each { |item_name| max_width = [ max_width, item_name.length ].max }
      total_width += max_width
    end
    total_width += (num_columns - 1) * 8
    if total_width > CharSettings['screen_width'] - 8
      num_columns -= 1
      break
    elsif num_columns >= list.length
      break
    end
    num_columns += 1
  }
  [ num_columns, 1 ].max
}

begin
  action = proc { |s|
    if s =~ /^(<(?:c|clearC|exposeC)ontainer[^>]*>)?(?:[IO]n the .*? you see |Peering into the .*?, you see .*?(?:, | and )(?:a|an|some) <)/
      # If it's a container listing, hide the text content and only return XML tags (if any)
      xml_only = $1 || ""
      xml_only
    else
      s
    end
  }
  DownstreamHook.add('sorter', action)
  while (line = get)
    if line =~ /^(?:<container.*inv>|<clearContainer.*inv>|<exposeContainer.*inv>)([IO]n the .*?) you see .*\./
      container = $1
      next if line =~ /In the/ and line =~ /On the/
    elsif line =~ /^(?:<container.*inv>|<clearContainer.*inv>|<exposeContainer.*inv>)(Peering into the .*?, you see .*?)(?:, | and )(?:a|an|some) <.*\./
      container = $1.concat ' and'
      next if line =~ /In the/ and line =~ /On the/
    else
      next
    end
    if container =~ /exist="(.*?)"/
      container_id = $1
      # Retry logic for GameObj container lookup
      contents = GameObj.containers[container_id]
      if contents.nil?
        echo "Waiting on GameObj to update. Contents are nil for container ##{container_id}"
        retry_count = 0
        while contents.nil? && retry_count < 3
          sleep 0.5
          contents = GameObj.containers[container_id]
          retry_count += 1
        end
      end

      if contents
        sorted_contents = Hash.new
        for item in contents
          category_name = item.type || 'other'
          sorted_contents[category_name] ||= Hash.new
          if item.full_name =~ /^a crystalline flask containing/
            item_name = item.full_name.sub(/^a crystalline flask containing /, '')
          else
            item_name = item.full_name.sub(/containing (.*)$/) { "(#{$1})" }
          end
          if sorted_contents[category_name][item_name].nil?
            sorted_contents[category_name][item_name] = Hash.new
            sorted_contents[category_name][item_name]['noun'] = item.noun
            sorted_contents[category_name][item_name]['exist'] = item.id
            sorted_contents[category_name][item_name]['count'] = 1
          else
            sorted_contents[category_name][item_name]['count'] += 1
          end
        end
        if CharSettings['screen_width'] and $frontend == 'stormfront'
          output = "<output class=\"mono\"/>\n"
        else
          output = String.new
        end
        output.concat "#{container}:\n"
        if CharSettings['screen_width']
          for category_name, category_contents in sorted_contents
            count = 0
            category_contents.values.each { |value| count += value['count'] }
            output.concat "#{monsterbold_start}#{category_name} (#{count}):#{monsterbold_end} \n"
            category_contents = category_contents.sort { |a,b| a[0].split(/\s/).last <=>  b[0].split(/\s/).last }
            column_count = best_column_count.call(category_contents.collect { |a| a[0] })
            row_count = (category_contents.length / column_count.to_f).ceil
            column_count = (category_contents.length / row_count.to_f).ceil
            column_widths = Array.new
            for column_num in 0...column_count
              category_contents[(column_num*row_count)...((column_num+1)*row_count)].each { |item_name,item_info| column_widths[column_num] = [ column_widths[column_num].to_i, item_name.length ].max }
            end
            for row_num in 0...row_count
              output.concat '    '
              for column_num in 0...column_count
                item_name, item_info = category_contents[(column_num*row_count) + row_num]
                if item_info['count'] > 1
                  str = "<a exist=\"#{item_info['exist']}\" noun=\"#{item_info['noun']}\">#{item_name}</a> (#{item_info['count']})"
                else
                  str = "<a exist=\"#{item_info['exist']}\" noun=\"#{item_info['noun']}\">#{item_name}</a>"
                end
                str = str.ljust(column_widths[column_num] + str.slice(/<a.*?>/).length + 12)
                if column_num == column_count - 1
                  str = str.strip
                end
                output.concat str
              end
              output.concat "\n"
            end
            output.concat "\n"
          end
        else
          total_count = 0
          for category_name, category_contents in sorted_contents.sort
            count = 0
            category_contents.values.each { |value| count += value['count'] }
            total_count += count
            output.concat "#{monsterbold_start}#{category_name} (#{count}):#{monsterbold_end} "
            category_contents = category_contents.sort { |a,b| a[0].split(/\s/).last <=>  b[0].split(/\s/).last }
            category_items = []
            for item_name, item_info in category_contents
              if item_info['count'] > 1
                category_items << "<a exist=\"#{item_info['exist']}\" noun=\"#{item_info['noun']}\">#{item_name}</a> (#{item_info['count']})"
              else
                category_items << "<a exist=\"#{item_info['exist']}\" noun=\"#{item_info['noun']}\">#{item_name}</a>"
              end
            end
            items_text = category_items.join(", ")

            # Apply high_type coloring if available
            colored_items = format_with_high_type_color(items_text, category_name)
            output.concat colored_items
            output.concat ".\n"
          end
          output.concat "#{monsterbold_start}total (#{total_count})#{monsterbold_end} "
        end
        if CharSettings['screen_width'] and $frontend == 'stormfront'
          output.concat "<output class=\"\"/>\n"
        end
        output.gsub!(/<.*?>/, '') unless $frontend =~ /^(?:stormfront|profanity)$/
        if defined?(_respond)
          _respond output
        else
          $stdout.puts output
        end
        if show_sellable
          sorted_contents = Hash.new
          for item in contents
            category_name = item.sellable || 'nil'
            sorted_contents[category_name] ||= Hash.new
            if item.full_name =~ /^a crystalline flask containing/
              item_name = item.full_name.sub(/^a crystalline flask containing /, '')
            else
              item_name = item.full_name.sub(/containing (.*)$/) { "(#{$1})" }
            end
            if sorted_contents[category_name][item_name].nil?
              sorted_contents[category_name][item_name] = Hash.new
              sorted_contents[category_name][item_name]['noun'] = item.noun
              sorted_contents[category_name][item_name]['exist'] = item.id
              sorted_contents[category_name][item_name]['count'] = 1
            else
              sorted_contents[category_name][item_name]['count'] += 1
            end
          end
          output = "\n#{container}:\n"
          for category_name, contents in sorted_contents
            count = 0
            contents.values.each { |value| count += value['count'] }
            output.concat "#{monsterbold_start}#{category_name} (#{count}):#{monsterbold_end} "
            contents = contents.sort { |a,b| a[0].split(/\s/).last <=>  b[0].split(/\s/).last }
            for item_name, item_info in contents
              if item_info['count'] > 1
                output.concat "<a exist=\"#{item_info['exist']}\" noun=\"#{item_info['noun']}\">#{item_name}</a> (#{item_info['count']}), "
              else
                output.concat "<a exist=\"#{item_info['exist']}\" noun=\"#{item_info['noun']}\">#{item_name}</a>, "
              end
            end
            output.chop!
            output.chop!
            output.concat ".\n"
          end
          if CharSettings['screen_width'] and $frontend == 'stormfront'
            output.concat "<output class=\"\"/>\n"
          end
          output.gsub!(/<.*?>/, '') unless $frontend =~ /^(?:stormfront|profanity)$/
          if defined?(_respond)
            _respond output
          else
            $stdout.puts output
          end
        end
      else
        echo "WARNING: Unable to get contents for container ##{container_id} after 3 retries. Try looking in it again."
      end
    end
  end
ensure
  DownstreamHook.remove('sorter')
end
