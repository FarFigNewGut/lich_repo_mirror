=begin
	MechFire by Nisugi
	
	author: Nisugi
	  name: MechFire
	  tags: ranged crossbow mechanical combat
   version: 3.1
   

   This is a highly configurable combat script for use with a mechanical crossbow. 
   
   It is designed with the sniper in mind. Depending on your settings, it will kneel
   hide, and kill every critter in the room until the room is cleared or it reaches
   the amount of kills you set to come out of hiding and loot. It will jump back in
   hiding and resume killing after looting.
   
   If you disable looting I recommend enabling single kill mode to prevent losing any
   corpses to decay from the room swarming.
    
   For more information please run ;mechfire help
=end


UserVars.mf										  ||= {}
UserVars.mf[:cocked]								= false				if UserVars.mf[:cocked].nil?
UserVars.mf[:ammo_count]							= 0					if UserVars.mf[:ammo_count].nil?
UserVars.mf[:kill_total]							= 0					if UserVars.mf[:kill_total].nil?

settings_info = {
	:quiver => 'Name of your quiver. \"leather quiver\" or \"thigh-quiver\"',
	:weapon => 'Noun of your weapon. \"longbow\" or \"crossbow\"',
	:targets => 'Targets you wish to attack. \"Thunder Troll, Zombie, ect.\"',
	:loot_script => 'Script you use for looting. \"sloot\", \"slootbeta\"',
	:heal_room => 'Room you want to use herbs in. Default: \"3824\"',
	:ammo_name => 'Name of your ammo. \"a faewood arrow\"',
	
	:ammo => 'Type of ammo your weapon uses. \"arrow\", \"heavy bolt\"',
	:ammo_max => 'Maximum number of rounds your magazine will hold.',
	:reload => 'Reload magazine when you reach this many rounds.',
	:hide_max => 'Maximum number of times to attempt hiding. Default: \"2\"',
	:heal_town => 'Go to town and healup if this many critters in the room.',
	:loot_kill => 'Pause combat and loot dead critters after killing this many.',
	
	:hide => 'Enables hiding.',
	:camo => 'Enables camouflage.',
	:kneel => 'Enables kneeling.',
	:gather => 'Enables basic gathering of ammo',
	:useherbs => 'Enables the use of ;useherbs to heal up.',
	:panic => 'Enables running to town and logging off if in trouble.',
	:debug => 'Enables debug messages.',
	:silence => 'Enables silent operation of script.',
	:loot => 'Enables mechfire to handle looting.',
	:killstreak => 'Enables kill streak messages.',
	:bundling_quiver => 'Enable if you have a bundling quiver and wish to let mechfire gather ammo.',
	:prep => 'Reload and cock crossbow at the end of combat.',

}

settings = CharSettings.to_hash

if settings[:silence]
	silence_me
end

rounds = {
	0	=> 'Select one',		
	1	=> '1 round',
	2	=> '2 rounds',
	3	=> '3 rounds',
	4 	=> '4 rounds',
	5	=> '5 rounds',
}
ammo_types = {
	0	=> 'arrow',
	1	=> 'light bolt',
	2	=> 'heavy bolt',
	3	=> 'self-ammo cb',
}
attempts = {
	0	=> 'Select one',		
	1	=> '1 attempt',
	2	=> '2 attempts',
	3	=> '3 attempts',
	4 	=> '4 attempts',
	5	=> '5 attempts',
}
critters = {
	0	=> 'Select one',		
	1	=> '1 critter',
	2	=> '2 critters',
	3	=> '3 critters',
	4 	=> '4 critters',
	5	=> '5 critters',
}
kills = {
	0	=> 'Select one',		
	1	=> '1 kill',
	2	=> '2 kills',
	3	=> '3 kills',
	4 	=> '4 kills',
	5	=> '5 kills',
	6	=> '6 kills',
	7	=> '7 kills',
	8	=> '8 kills',
	9	=> '9 kills',
	10	=> '10 kills',
	11	=> '11 kills',
	12	=> '12 kills',
	13	=> '13 kills',
	14	=> '14 kills',
	15	=> '15 kills',
	16	=> '16 kills',
	17	=> '17 kills',
	18	=> '18 kills',
	19	=> '19 kills',
	20	=> '20 kills',
	21	=> '21 kills',
	22	=> '22 kills',
	23	=> '23 kills',
	24	=> '24 kills',
	25  => '25 kills',
}

quiver 			= GameObj[settings[:quiver]]
npcs			= Hash.new
valid_targets	= Hash.new
bundles			= Hash.new
need_heals		= nil
start_room		= nil
ammo 			= nil
ammo_max		= nil
reload 			= nil
threats 		= nil
tokens 			= nil
weapon 			= nil
hide_fail		= nil
hide_max		= nil
go_camo			= nil
no_camo			= nil
no_hide			= nil
target			= nil
gkt				= nil
kill_count		= nil
kill_total 		= nil
attack_count	= nil


fix_injury = proc{

	if settings[:debug]
		echo "fix_injury"
	end

	waitrt?
	fput "stand" until standing?
	fput "stance defensive" until checkstance == "defensive"
	
	if settings[:useherbs]
		Script.pause('mechfire')
		threats = GameObj.npcs.find_all {|i| i.status !~ /dead/}
		if threats.length > settings[:heal_town].to_i
			start_room = Room.current.id
			Script.run('go2', settings[:heal_room.to_s])
			Script.run('useherbs')
			Script.run('go2', start_room.to_s)
		else
			Script.run('useherbs', '--buy=off')
		end
	end
	
	need_heals = false
	
	if (Wounds.head > 0) || (Wounds.neck > 0) || (Wounds.abs > 0) || (Wounds.lhand > 0) || (Wounds.rhand > 0) || (Wounds.larm > 0) || (Wounds.rarm > 0) || (Wounds.chest > 0) || (Wounds.back > 0) || (Wounds.rleg > 0) || (Wounds.lleg > 0) || (Wounds.nerves > 0) || (Scars.head > 0) || (Scars.neck > 0) || (Scars.abs > 0) || (Scars.lhand > 0) || (Scars.rhand > 0) || (Scars.larm > 0) || (Scars.rarm > 0) || (Scars.chest > 0) || (Scars.back > 0) || (Scars.rleg > 0) || (Scars.lleg > 0) || (Scars.nerves > 0) || (percenthealth < 50)
		need_heals = true
	end
	
	if need_heals
		Script.pause('bigshot') if running? "bigshot"
		if settings[:panic]
			Script.run('go2', settings[:heal_room].to_s)
		end
		echo "***  Healing failed. Seek assistance.  ***"
		echo "***           Pausing Script           ***"
		Script.pause('mechfire')
	end

}

get_target = proc{

	if settings[:debug] == true
		echo "get_target"
	end
	
	tokens = settings[:targets].split(/,/)
	tokens.each do |i|
		if( i =~ /(.*)\(([a|b|c|d|e|f|g|h|i|j|A|B|C|D|E|F|G|H|I|J])\)/ )
			valid_targets[$1.downcase.strip] = $2.downcase.strip
		else
			valid_targets[i.downcase.strip] = 'a'
		end
	end
	
	npcs = GameObj.npcs.find_all { |i| i.status !~ /dead/ }
	if settings[:targets].length > 0
		npcs.delete_if { |npc| !valid_targets.include?(npc.name) }
	end
	npcs.delete_if { |npc| npc.noun =~ /child|traveller|scribe|merchant|dignitary|official|magistrate|jock/i && npc.name !~ /ethereal|celestial|unworldly/i }

	if (target == nil) && npcs.size > 0
		target = npcs.find { |npc| (npc.name =~ //)  && (npc.status !~ /dead|gone/) }
		(target = nil) if (target.name =~ /grizzled|ancient/) && (checkbounty !~ /hunt down and kill a particularly dangerous/)
		#(target = nil) if (target.type !~ /\baggressive\b/)
		attack_count = 0
	end

}

check_position = proc{

	if settings[:debug]
		echo "check_position"
	end
	
	if !checkleft
		fput "ready range"
	end
	
	if checkleft && GameObj.left_hand.name !~ /#{settings[:weapon]}/
		fput "stow left" until !checkleft
		fput "ready range"
	elsif checkleft && GameObj.left_hand.name =~ /#{settings[:weapon]}/
		weapon = GameObj.left_hand
	end
	
	if !checkleft
		echo "Cannot find your weapon."
		Script.pause('mechfire')
	end
	
	if checkright && (settings[:ammo].to_i != 0)
		fput "stow right"
	end
	
	while !checkkneeling && !checkstanding && !checkhidden
		sleep 0.1
		waitrt?
		fput "stand" until standing?
		fput "stance defensive" until checkstance == "defensive"
	end
	
}

check_kneel = proc{

	if settings[:debug] == true
		echo "check_kneel"
	end
	
	sleep 0.1
	waitrt?
	
	if (settings[:kneel] == true) && (checkkneeling != true)
		fput "kneel" until kneeling?
	end
	
}

check_hide = proc{

	if settings[:debug]
		echo "check_hide"
	end
	
	hide_fail = 0
	hide_max = settings[:hide_max].to_i	
	go_camo = false
	
	if checkoutside || (!checkoutside && Spell[625].active?)
		go_camo = true
	end
	
	fput "stance defensive" if checkstance != "defensive" && !checkhidden

=begin	
	while !checkhidden && settings[:hide] && (hide_fail < hide_max)
		if settings[:camo] && Spell[608].affordable? && !Spell[608].active? && Spell[608].known? && go_camo && !no_camo
			sleep 0.1
			waitcastrt?
			waitrt?
			fput "incant 608"
			
			while line = get
				if line =~ /^You are unable to call the power to camouflage yourself here\.$|but can\'t see anywhere to hide/
					no_camo = true
					break
				elsif line =~ /notices your attempt to hide\!$|^You don't have a spell prepared\!$|^Your armor prevents the spell from working correctly\.$/
					hide_fail += 1
					break
				elsif line =~ /^You blend into invisibility among the surroundings\.$/
					break
				end
			end
				
		elsif !checkhidden && !no_hide
			sleep 0.1
			waitrt?
			fput "hide"
			
			while line = get
				if line =~ /^You look around\, but can\'t see anywhere to hide\./
					no_hide = true
					break
				elsif line =~ /notices your attempt to hide\!$|^You fail to slip into hiding\.$/
					hide_fail += 1
					break
				elsif line =~ /^You attempt to blend with the surroundings\, and feel confident that no one has noticed your doing so\.$/
					break
				end
			end
			
		end
	end
=end	
	

	while !checkhidden && settings[:hide] && (hide_fail < hide_max)
		if settings[:camo] && Spell[608].affordable? && !Spell[608].active? && Spell[608].known? && go_camo && !no_camo
				waitcastrt?
				waitrt?
				res = dothistimeout "incant 608", 2, /^You are unable to call the power to camouflage yourself here\.$|^You look around\, but can\'t see anywhere to hide|^You attempt to blend with the surroundings\, and feel confident that no one has noticed your doing so\.$|You blend into invisibility among the surroundings\.$|^Your armor prevents the spell from working correctly\.$|notices your attempt to hide\!$|^You don't have a spell prepared\!$/
				if res =~ /^You are unable to call the power to camouflage yourself here\.$|but can\'t see anywhere to hide/
					echo "Can't camouflage here, moving on"
					no_camo = true
				elsif res =~ /notices your attempt to hide\!$|^You don't have a spell prepared\!$/
					hide_fail += 1
				end
		elsif !checkhidden && settings[:hide] && !no_hide
			res = dothistimeout "hide", 2, /^You are unable to call the power to camouflage yourself here\.$|^You look around\, but can\'t see anywhere to hide|^You attempt to blend with the surroundings\, and feel confident that no one has noticed your doing so\.$|You blend into invisibility among the surroundings\.$|^Your armor prevents the spell from working correctly\.$|notices your attempt to hide\!$|^You fail to slip into hiding\.$/
			if res =~ /but can\'t see anywhere to hide/
				echo "Can't hide here, moving on"
				no_hide = true
				break
			elsif res =~ /notices your attempt to hide\!$|^You fail to slip into hiding\.$/
				hide_fail += 1
			end
		end
	end
	
	
	if hide_fail >= hide_max
		echo "Perceptive creature preventing hide attempt. Increase max hide attempts if you want to attempt to hide more than #{settings[:hide_max]} times."
	end
	
}

check_reload = proc{
	
	if settings[:debug] == true
		echo "check_reload"
	end

	ammo = UserVars.mf[:ammo_count].to_i
	ammo_max = settings[:ammo_max].to_i
	reload = settings[:reload].to_i
	waitrt?
	
	if ammo <= reload
		while ammo < ammo_max
			sleep 0.1
			waitrt?
			fput "get 1 #{ammo_types[settings[:ammo]]} from ##{quiver.id}"
			while line = get
				if line =~ /^Get what\?$/
					echo "Out of ammo, Please restock."
					Script.pause('mechfire')
				elsif line =~ /^You get|^You remove/
					break
				end
			end
			
			sleep 0.1
			fput "load my #{weapon}"
			while line = get
				if line =~ /^You flip open the stock of your .+? and load .+? into it\./
					ammo += 1
					break
				elsif line =~ /^But your .+? can only hold up to .+?\!$/
					ammo = ammo_max
					fput "stow right" until !checkright
					break
				elsif line =~ /^You must be holding something to load into your .+?\.$/
					echo "Cannot find your ammo, Please restock."
					Script.pause('mechfire')
				end
			end
		end
	end
	
	UserVars.mf[:ammo_count] = ammo

}

check_cock = proc{

	if settings[:debug] == true
		echo "check_cock"
	end
	
	if UserVars.mf[:cocked] != true
		waitrt?
		fput "stance offensive" if checkstance != "offensive"
		res = dothistimeout "cock my #{weapon}", 2, /^You draw back on the bowstring of your .+? to whirl\, lifting .+? from the interior and snapping it into place\.|You cock your .+?\.$|^You must be holding .+? to cock it\.$|^The .+? is already cocked\.$/
		
		if res =~ /^You draw back on the bowstring of your .+? to whirl\, lifting .+? from the interior and snapping it into place\.|You cock your .+?\.$/
			UserVars.mf[:cocked] = true
			
		elsif res =~ /^You must be holding .+? to cock it\.$/
			echo "investigate how you got to check_cock without #{weapon} in hand."
			echo "*** Pausing Script ***"
			Script.pause('mechfire')
			#second attempt at cocking to added later
			#fput "stow left" if checkleft !~ /#{weapon}/
			#fput "ready ##{weapon.id}"
			#res2 = dothistimeout "cock my #{weapon}", 2, /^You draw back on the bowstring of your .+? to whirl\, lifting .+? from the interior and snapping it into place\.|You cock your .+?\.$|^You must be holding .+? to cock it\.$|^The .+? is already cocked\.$/
			
			#if res2 =~ /^You draw back on the bowstring of your .+? to whirl\, lifting .+? from the interior and snapping it into place\.|You cock your .+?\.$/
			#	UserVars.mf[:cocked] = true
			#elsif res2 =~ /^The .+? is already cocked\.$/
			#	UserVars.mf[:cocked] = true
			#	echo "Error cc-1: Please send log to investigate how you ended up here. @Getho#5573 on discord."
			#elsif res2 =~ /^You must be holding .+? to cock it\.$/
			#	echo "Cannot find your #{weapon}. Pausing."
			#	Script.pause('mechfire')
			#end
			
		elsif res =~ /^The .+? is already cocked\.$/
			UserVars.mf[:cocked] = true
			echo "Error cc-1: Please send log to investigate how you ended up here. @Getho#5573 on discord."
		end
	end

}

attack_target = proc{

	if settings[:debug]
		echo "attack_target"
	end

	fput "stance offensive" if checkstance != "offensive"
	if settings[:ammo] == 1 || settings[:ammo] == 2
		fput "fire ##{target.id}" if target != nil
		
		while line = get
			if line =~ /^You fire .+? at .+?\!$/
				UserVars.mf[:ammo_count] -= 1
				UserVars.mf[:cocked] = false
				attack_count += 1
				break
			elsif line =~ /^You dry fire your .+?\.$/
				UserVars.mf[:ammo_count] = 0
				UserVars.mf[:cocked] = false
				break
			elsif line =~ /\.\.\.wait .+? seconds\.$/
				break
			elsif line =~ /^But your .+? is not cocked\!$/
				UserVars.mf[:cocked] = false
				break
			elsif line =~ /^You do not currently have a target\.$|^I could not find what you were referring to\.$|^A .+? is quite dead already\.$/
				target = nil
				break
			elsif line =~ /^You are too injured to fire that\!$/
				fix_injury.call
				break
			end
		end
	
	elsif settings[:ammo] == 3
		fput "fire ##{target.id}" if target != nil
		
		while line = get
			if line =~ /^You fire .+? at .+?\!$/
				#UserVars.mf[:ammo_count] -= 1
				UserVars.mf[:cocked] = false
				attack_count += 1
				break
			elsif line =~ /^You dry fire your .+?\.$/
				#UserVars.mf[:ammo_count] = 0
				UserVars.mf[:cocked] = false
				break
			elsif line =~ /\.\.\.wait .+? seconds\.$/
				break
			elsif line =~ /^But your .+? is not cocked\!$/
				UserVars.mf[:cocked] = false
				break
			elsif line =~ /^You do not currently have a target\.$|^I could not find what you were referring to\.$|^A .+? is quite dead already\.$/
				target = nil
				break
			elsif line =~ /^You are too injured to fire that\!$/
				fix_injury.call
				break
			end
		end
	
	elsif settings[:ammo] == 0
		multifput "get 1 #{ammo_types[settings[:ammo]]} from ##{quiver.id}", "fire ##{target.id}"
		
		while line = get
			if line =~ /^Get what\?$/
				echo "Out of ammo, Please restock."
				Script.pause('mechfire')
				break
			elsif line =~ /^You fire .+? at .+?\!$/
				attack_count += 1
				break
			elsif line =~ /^You do not currently have a target\.$|^I could not find what you were referring to\.$|^A .+? is quite dead already\.$/
				target = nil
				break
			elsif line =~ /\.\.\.wait .+? seconds\.$/
				pause 0.1
				waitrt?
				check_position.call
				break
			elsif line =~ /^You are too injured to fire that\!$/
				fix_injury.call
				break
			end
		end
	end
	waitrt?
	
}

gather_ammo = proc{
	
	if settings[:debug]
		echo "gather_ammo"
	end

	if quiver.contents == nil
		fput "look in ##{quiver.id}"
	end

	quiver.contents.each do |b|
		if bundles[:b1] == nil
			bundles[:b1] = [b.id, b.noun]
		elsif bundles[:b2] == nil
			bundles[:b2] = [b.id, b.noun]
		elsif bundles[:b3] == nil
			bundles[:b3] = [b.id, b.noun]
		elsif bundles[:b4] == nil
			bundles[:b4] = [b.id, b.noun]
		elsif bundles[:b5] == nil
			bundles[:b5] = [b.id, b.noun]
		end
	end
	
	ammo = GameObj.loot.to_a.find do |l|
		l.type =~ /ammo/
	end

	if ammo.nil?
		exit
	end
	
	loop do
		res = dothistimeout "gather #{ammo_types[settings[:ammo]]}", 2, /out of your reach\.|^You gather \d+ (.*) into a bundle on the ground\.$|^You pick up the (.*), but can find no others like it\.$|^You gather \d+ (.*) into a bundle\.$|You may not combine/
		
		if res =~ /^You gather \d+ (.*) into a bundle on the ground\.$/
			fput "_drag ##{ammo.id} ##{bundles[:b1][0]}"
			break
			
		elsif res =~ /^You gather \d+ (.*) into a bundle\.$|^You pick up the (.*), but can find no others like it\.$/
			fput "put ##{GameObj.right_hand.id} in ##{bundles[:b1][0]}"
			break
			
		elsif res =~ /out of your/
			sleep 1
		end
		
	end
	
	
}

gather_ammo_quiver = proc{

	if settings[:debug]
		echo "gather_ammo_quiver"
	end
	
	ammo = GameObj.loot.to_a.find do |l|
		l.type =~ /ammo/
	end
	
	if ammo.nil?
		exit
	end
	
	loop do
		res = dothistimeout "gather #{ammo_types[settings[:ammo]]}", 2, /out of your reach\.|^You gather \d+ (.*) into a bundle on the ground\.$|^You pick up the (.*), but can find no others like it\.$|^You gather \d+ (.*) into a bundle\.$|You may not combine/
		
		if res =~ /^You gather \d+ (.*) into a bundle on the ground\.$/
			fput "_drag ##{ammo.id} #{quiver}"
			break
			
		elsif res =~ /^You gather \d+ (.*) into a bundle\.$|^You pick up the (.*), but can find no others like it\.$/
			fput "put #{GameObj.right_hand} in my #{quiver}"
			break
			
		elsif res =~ /out of your/
			sleep 1
		end
		
	end
		
}

kill_streak = proc{
	
	if settings[:debug]
		echo "kill_streak"
	end
	
	if kill_total == 5
		echo "** 5 KILL STREAK **"
	elsif kill_total == 10
		echo "** 10 KILL STREAK **"
	elsif kill_total == 15
		echo "** 15 KILL STREAK **"
	elsif kill_total == 20
		echo "** 20 KILL STREAK **"
	elsif kill_total == 25	
		echo "** 25 KILL STREAK **"
	elsif kill_total == 50
		echo "** 50 KILL STREAK **"
	elsif kill_total == 75
		echo "** 75 KILL STREAK **"
	elsif kill_total == 100
		echo "** 100 KILL STREAK **"
	end

}

setup = proc{

	gtk_locals = Hash.new
	window = window_action = nil
	
	Gtk.queue{
		ttips = Gtk::Tooltips.new.enable
		ttips_text = {
			:quiver => 'Name of the quiver you wish to use. ie, ebonwood thigh-quiver or leather quiver',
			:weapon => 'Noun of your weapon. ie, crossbow or longbow',
			:targets => 'Targets you wish to kill. Leave blank to clear entire room. If using bigshot, put the same targets in this box to only kill specific targets.',
			:loot_script => 'Script you use to loot with. ie, sloot or slootbeta',
			:heal_room => 'Room in town you want to ;useherbs in.',
			:ammo_name => 'Name of the ammo you wish to use. ie, a faewood bolt',
			
			:ammo => 'Type of ammo you are using. ie, arrow, light bolt, heavy bolt',
			:ammo_max => 'Maximum ammo your magazine will hold. Please select a value even if you\'re not using a mechanical crossbow.',
			:reload => 'Reload when your magazine reaches this number of rounds. Please select a value even if you\'re not using a mechanical crossbow.',
			:hide_max => 'Maximum attempts to hide before skipping. Please select a value even if you\'re not hiding.',
			:heal_town => 'Will go to town to heal if injured and there are this many creatures in your room. Please select a value even if you\'re not using the useherbs option.',
			:loot_kill => 'Will pause combat to loot corpses after killing this many creatures. Set low if you are slow to kill and do not want corpses decaying. Please select a high value if you don\'t enable the looting option.',
			
			:hide => 'Enables hiding.',
			:camo => 'Enables camouflage.',
			:kneel => 'Enables kneeling.',
			:gather => 'Enables basic ammo gathering and bundling. You can break your bundle up into bundles of 24 inside a warrior quiver for weightless bundles. This option will keep the bundles seperate. Multiple types of ammo in the same quiver can cause problems.',
			:useherbs => 'Enables using ;useherbs to heal.',
			:panic => 'Enables running back to town if you get in trouble.',
			:debug => 'Enables debug messages.',
			:silence => 'Enables silent mode.',
			:loot => 'Enables allowing mechfire to handle looting using your prefered loot script.',
			:killstreak => 'Enables kill streak messaging',
			:bundling_quiver => 'Enable if you have an auto bundling quiver and wish to allow mechfire to gather your ammo. Must also enable Gather Ammo.',
			:prep => 'Enables reloading and cocking of crossbow at end of combat.',
			:solo => 'Enables killing a single target and ending script.',
			:meh => 'Placeholder to make interface look nice.',
			:meh => 'Placeholder to make interface look nice',
		}
		
		gtk_locals[:quiver] = Gtk::Entry.new.set_text(settings[:quiver])
		gtk_locals[:weapon] = Gtk::Entry.new.set_text(settings[:weapon])
		gtk_locals[:targets] = Gtk::Entry.new.set_text(settings[:targets])
		gtk_locals[:loot_script] = Gtk::Entry.new.set_text(settings[:loot_script])
		gtk_locals[:heal_room] = Gtk::Entry.new.set_text(settings[:heal_room])
		gtk_locals[:ammo_name] = Gtk::Entry.new.set_text(settings[:ammo_name])
		
		gtk_locals[:ammo] = Gtk::ComboBox.new(is_text_only = true)
		gtk_locals[:ammo_max] = Gtk::ComboBox.new(is_text_only = true)
		gtk_locals[:reload] = Gtk::ComboBox.new(is_text_only = true)
		gtk_locals[:hide_max] = Gtk::ComboBox.new(is_text_only = true)
		gtk_locals[:heal_town] = Gtk::ComboBox.new(is_text_only = true)
		gtk_locals[:loot_kill] = Gtk::ComboBox.new(is_text_only = true)
		
		gtk_locals[:hide] = Gtk::CheckButton.new('Hide').set_active(settings[:hide])
		gtk_locals[:camo] = Gtk::CheckButton.new('Camouflage').set_active(settings[:camo])
		gtk_locals[:kneel] = Gtk::CheckButton.new('Kneel').set_active(settings[:kneel])
		gtk_locals[:gather] = Gtk::CheckButton.new('Gather Ammo').set_active(settings[:gather])
		gtk_locals[:useherbs] = Gtk::CheckButton.new('Useherbs').set_active(settings[:useherbs])
		gtk_locals[:panic] = Gtk::CheckButton.new('Panic Mode').set_active(settings[:panic])
		gtk_locals[:debug] = Gtk::CheckButton.new('Debug Mode').set_active(settings[:debug])
		gtk_locals[:silence] = Gtk::CheckButton.new('Silence').set_active(settings[:silence])
		gtk_locals[:loot] = Gtk::CheckButton.new('Loot').set_active(settings[:loot])
		gtk_locals[:killstreak] = Gtk::CheckButton.new('Kill Streak').set_active(settings[:killstreak])
		gtk_locals[:bundling_quiver] = Gtk::CheckButton.new('Bundling Quiv').set_active(settings[:bundling_quiver])
		gtk_locals[:prep] = Gtk::CheckButton.new('Prep').set_active(settings[:prep])
		gtk_locals[:solo] = Gtk::CheckButton.new('Single').set_active(settings[:solo])
		gtk_locals[:meh] = Gtk::CheckButton.new('TBD').set_active(settings[:meh])
		gtk_locals[:meh2] = Gtk::CheckButton.new('TBD').set_active(settings[:meh2])
		
		x = 0
		while x < ammo_types.length
			gtk_locals[:ammo].append_text(ammo_types[x])
			x += 1
		end
		x = 0
		while x < rounds.length
			gtk_locals[:ammo_max].append_text(rounds[x])
			gtk_locals[:reload].append_text(rounds[x])
			x += 1
		end
		x = 0
		while x < attempts.length
			gtk_locals[:hide_max].append_text(attempts[x])
			x += 1
		end
		x = 0
		while x < critters.length
			gtk_locals[:heal_town].append_text(critters[x])
			x += 1
		end
		x = 0
		while x < kills.length
			gtk_locals[:loot_kill].append_text(kills[x])
			x += 1
		end
		gtk_locals[:ammo].set_active(settings[:ammo].to_i)
		gtk_locals[:ammo_max].set_active(settings[:ammo_max].to_i)
		gtk_locals[:reload].set_active(settings[:reload].to_i)
		gtk_locals[:hide_max].set_active(settings[:hide_max].to_i)
		gtk_locals[:heal_town].set_active(settings[:heal_town].to_i)
		gtk_locals[:loot_kill].set_active(settings[:loot_kill].to_i)
		
		ttips_text.each_pair { |widget, tip|
			if widget = gtk_locals[widget]
				ttips.set_tip(widget,tip,'')
			end
		}

		#Primary window
		window = Gtk::Window.new
		window.title = "MechFire"
		window.border_width = 3
		window.resizable = true
	
		#Notebook for tabs
		nb = Gtk::Notebook.new.set_show_border(true).set_tab_border(3)
	
		#Notbeook 1 
		vb_pg1 = Gtk::VBox.new(false,1).set_border_width(3)
	
		#Page 1, Frame 1
		vb_pg1_1 = Gtk::VBox.new(false,1).set_border_width(3)
		fr_pg1_1 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Settings</b></big>'))
		fr_pg1_1.add(vb_pg1_1)
		vb_pg1.pack_start(fr_pg1_1,false)
		
		#Add label if wanted
		#lbl = Gtk::Label.new.set_markup("SLoot features sorting of loot by allowing you to specify " +
		#        "a sack for each type of loot. Use the fields below to set the sack(s) for " +
		#        "each loot type.")
		#    lbl.set_wrap(true).set_width_request(500).set_padding(0,10)
		#    vb_pg1_1.pack_start(lbl,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Ammo Type: ')).set_width_request(75))
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:ammo].set_width_request(100)))
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Quiver: ')).set_width_request(70))
		hb.pack_start(gtk_locals[:quiver],false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Max Ammo: ')).set_width_request(75))
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:ammo_max].set_width_request(100)))
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Weapon: ')).set_width_request(70))
		hb.pack_start(gtk_locals[:weapon],false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Reload at: ')).set_width_request(75))
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:reload].set_width_request(100)))
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Ammo: ')).set_width_request(70))
		hb.pack_start(gtk_locals[:ammo_name],false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Targets: ')).set_width_request(80))
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:targets].set_width_request(342)))
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Max Hide: ')).set_width_request(60))
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:hide_max].set_width_request(100)))
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:hide].set_width_request(100)),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:camo].set_width_request(120)),false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:meh].set_width_request(100)),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:solo].set_width_request(100)),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:prep].set_width_request(100)),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:kneel].set_width_request(100)),false)
		vb_pg1_1.pack_start(hb,false)
	
		#Page 1, Frame 2
		vb_pg1_2 = Gtk::VBox.new(false,1).set_border_width(3)
		fr_pg1_2 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Looting</b></big>'))
		fr_pg1_2.add(vb_pg1_2)
		vb_pg1.pack_start(fr_pg1_2,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:loot].set_width_request(100)),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:gather].set_width_request(100)),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:bundling_quiver].set_width_request(100)),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:meh2].set_width_request(100)),false)
		vb_pg1_2.pack_start(hb,false)
	
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Loot After: ')).set_width_request(80),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:loot_kill].set_width_request(100)))
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Loot Script: ')).set_width_request(70),false)
		hb.pack_start(gtk_locals[:loot_script],false)
		vb_pg1_2.pack_start(hb,false)

		#Page 1, Frame 3
		vb_pg1_3 = Gtk::VBox.new(false,1).set_border_width(3)
		fr_pg1_3 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Healing</b></big>'))
		fr_pg1_3.add(vb_pg1_3)
		vb_pg1.pack_start(fr_pg1_3,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:useherbs].set_width_request(129)),false)
		vb_pg1_3.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Heal In Town: ')).set_width_request(80),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:heal_town].set_width_request(100)))
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Heal Room: ')).set_width_request(70),false)
		hb.pack_start(gtk_locals[:heal_room],false)
		vb_pg1_3.pack_start(hb,false)
		
		#Page 1, Frame 4
		vb_pg1_4 = Gtk::VBox.new(false,1).set_border_width(3)
		fr_pg1_4 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Advanced</b></big>'))
		fr_pg1_4.add(vb_pg1_4)
		vb_pg1.pack_start(fr_pg1_4,false)
	
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:debug].set_width_request(100)),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:silence].set_width_request(100)),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:killstreak].set_width_request(100)),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:panic].set_width_request(100)),false)
		vb_pg1_4.pack_start(hb,false)
	
	
	
	
		nb.append_page(vb_pg1,Gtk::Label.new('Settings'))
		
		#Save/Close buttons
		hb_saveclose = Gtk::HBox.new
		save = Gtk::Button.new('_Save & Close')
		close = Gtk::Button.new('E_xit')
		
		save.signal_connect('clicked') { window_action = :save }
		close.signal_connect('clicked') { window_action = :done }
		
		hb_saveclose.pack_start(save,false)
		hb_saveclose.pack_start(close,false)
		
		vb_main = Gtk::VBox.new(false,5)
		vb_main.border_width = 3
		vb_main.pack_start(nb,false)
		vb_main.pack_start(Gtk::Alignment.new(1,0,0,0).add(hb_saveclose),false)
	
		window.signal_connect('delete_event') { window_action = :exit }
		
		window.add(vb_main)
		window.show_all
		window.keep_above = true

	}
	
	before_dying { Gtk::queue { window.destroy} }
	wait_while { window_action.nil? }
	
	if window_action == :save
		gtk_locals.each_pair {|k,v|
			if v.class == Gtk::CheckButton
				settings[k] = v.active?
			elsif v.class == Gtk::ComboBox
				settings[k] = v.active
			elsif v.class == Gtk::Entry
				settings[k] = v.text.strip.downcase
			else
				echo "error: unknown local settings #{k} [#{v.class}]"
			end
		}
		echo 'settings saved'
	else
		echo 'closed without saving'
	end
	
}

post_combat = proc{
	
	if settings[:debug]
		echo "post_combat"
	end
	
	sleep 0.1
	waitrt?
	fput "stand" if !checkstanding
	
	if settings[:loot]
		Script.run(settings[:loot_script])
	end
	
	if settings[:gather]
		if settings[:bundling_quiver]
			gather_ammo_quiver.call
		else
			gather_ammo.call
		end
	end
	
	if settings[:prep] && settings[:ammo] != 0
		check_reload.call if settings[:ammo] != 3
		check_cock.call
	end
	
	waitrt?
	fput "stance defensive" if checkstance != "defensive"
	
	gkt = UserVars.mf[:kill_total]
	gkt += kill_total
	UserVars.mf[:kill_total] = gkt
	
	if settings[:killstreak]
		echo "You have killed #{kill_total} critters this run!"
		echo "You have a lifetime kill total of #{gkt}!"
	end
	
	exit

}

if script.vars[1] == 'setup'
	setup.call
	exit
	
elsif variable[1].downcase == "help"

	print_option = proc do |option, msg, eg = "", pad = 2|
        if eg != ""
            msg = sprintf("%-20s #{$lich_char}#{script.name} #{eg}", msg)
        end

        respond(sprintf("  %s%-20s %s", " " * pad, option, msg))
    end

    respond("MechFire v2.0 by Getho")
    respond("")
    respond("MechFire is a combat script designed to be used with mechanical crossbows")
    respond("")
    respond("Basic usage: #{$lich_char}#{script.name}")
    respond("")
    respond("Extra commands:")
    print_option.call("help", "show this help message")
	print_option.call("setup", "GUI for setup")
    print_option.call("list", "list current settings")
    #print_option.call("stats", "displays your lifetime kills")
	#print_option.call("reload", "force a reload before you go into a big fight")
	#print_option.call("strike", "use blue crystal in holder on each first attack")
	#print_option.call("reset", "resets your settings back to nothing")
	#print_option.call("reset all", "resets global script variables used for tracking")
    respond("")
    respond("Available settings:")
	print_option.call("<option>", "<value>", "")
	respond ("")
    settings_info.each do |k, v|
        print_option.call(k, v)
    end
    respond("")
	
	exit
	
elsif script.vars[1] == 'list'

    respond('=======================')
    respond('   MechFire settings   ')
    respond('=======================')
	settings.each do |k, v|
		#if k !~ /is_cocked|death_count_total|need_crystal|ammo_count/
			puts("#{monsterbold_start}#{k}#{monsterbold_end}: #{v}")
		#end
	end
	exit
	
elsif script.vars[1] == 'test'
	
	settings.delete_if {|k,v| (k != nil) || (v != nil)}
	UserVars.mechfire.delete_if {|k,v| (k != nil) || (v != nil)}
	UserVars.mf.delete_if {|k,v| (k != nil) || (v != nil)}

	exit
	
end

warning_count = 0

if settings[:reload] == 0 && (settings[:ammo] != 0 || settings[:ammo] != 3)
	echo "Warning: Please run ;mechfire setup and select a value to reload at."
	warning_count += 1
end
if settings[:loot_kill] == 0 && settings[:loot]
	echo "Warning: Please run ;mechfire setup and select a value to loot at."
	warning_count += 1
end
if settings[:ammo_max] == 0 && (settings[:ammo] != 0 || settings[:ammo] != 3)
	echo "Warning: Please run ;mechfire setup and select a value for your maximum ammo."
	warning_count += 1
end
if settings[:hide_max] == 0 && settings[:hide]
	echo "Warning: Please run ;mechfire setup and select a value for your maximum hide attempts."
	warning_count += 1
end
if settings[:heal_town] == 0 && settings[:useherbs]
	echo "Warning: Please run ;mechfire setup and select a value for how many creatures will cause you to run to town if you need to heal."
	warning_count += 1
end
if warning_count > 0
	echo "Error: Please fix warnings."
	exit
end

	if checkleft && GameObj.left_hand.name !~ /#{settings[:weapon]}/
		fput "stow left" until !checkleft
		fput "ready range"
	elsif checkleft && GameObj.left_hand.name =~ /#{settings[:weapon]}/
		weapon = GameObj.left_hand
	end

	no_camo = false
	no_hide = false
	kill_count = 0
	kill_total = 0
	get_target.call
	
	while target != nil
		check_position.call
		check_kneel.call if (target != nil) && settings[:ammo] != 0
		check_hide.call if (target != nil)
		sleep 0.1
		waitrt?
		check_reload.call if (target != nil) && settings[:ammo] != 0 && settings[:ammo] != 3
		check_cock.call if (target != nil) && settings[:ammo] != 0
		sleep 0.1
		waitcastrt?
		waitrt?
		attack_target.call if (target != nil) && (target.status !~ /dead|gone/)

		if target.status =~ /dead|gone/
			if target.status =~ /dead/
				if attack_count > 0
					kill_count += 1
					kill_total += 1
				end
				if settings[:solo]
					post_combat.call
					exit
				end
				if settings[:killstreak]
					kill_streak.call
				end
				if kill_count >= settings[:loot_kill].to_i && settings[:loot]
					fput "stance defensive" if checkstance != "defensive"
					Script.run(settings[:loot_script])
					kill_count = 0
				end
			end			
			
			target = nil
		end
		
		get_target.call if (target == nil)
	end	
	
	post_combat.call








exit
=begin
:heal_room = "318"	#room you want to use herbs in back at town
:heal_town = 2		#how many creatures need to be in the room to run to town instead of healing on the spot.
:panic = false		#takes you back to your healing room in case of emergency.
:useherbs = true	#when hurt will ;useherbs.
:debug = false		#Debug messages
:weapon = "" 		#choice of bow
:quiver = ""		#quiver
:reload = 2  		#reload when down to this number
:ammo_max = 5		#number of rounds clip holds
:ammo = 2			#type of ammo 0 - arrow, 1 - light bolt, 2 - heavy bolt.
:targets = ""		#targets to attack, leave blank to kill anything in the room.
:hide = false
:hide_max = 2
:camo = false
:kneel = false
:gather = false
=end
=begin	
	fput "stance offensive" if checkstance != "offensive"
	if settings[:ammo].to_i == 1 || settings[:ammo].to_i == 2
		res = dothistimeout "fire ##{target.id}", 2, /^You fire .+? at .+?\!$|^You are too injured to fire that\!$|^You dry fire your .+?\.$|^You do not currently have a target\.$|^I could not find what you were referring to\.$|^A .+? is quite dead already\.$|^But your .+? is not cocked\!$|^\.\.\.wait .+? seconds\.$/
	
		if res =~ /^You fire .+? at .+?\!$/
			UserVars.mf[:ammo_count] -= 1
			UserVars.mf[:cocked] = false
			
		elsif res =~ /^But your .+? is not cocked\!$/
			UserVars.mf[:cocked] = false
			check_cock.call
		
		elsif res =~ /^You dry fire your .+?\.$/
			UserVars.mf[:ammo_count] = 0
			UserVars.mf[:cocked] = false
			fput "stance defensive" if checkstance != "defensive"
			check_reload.call
		
		elsif res =~ /\.\.\.wait .+? seconds\.$/
			pause 0.2
			waitrt?
			check_position.call
		
		elsif res =~ /^You do not currently have a target\.$|^I could not find what you were reffering to\.$|^A .+? is quite dead already\.$/
			target = nil
		
		elsif res =~ /^You are too injured to fire that\!$/
			fix_injury.call
		
		elsif res.nil?
			echo "*** Something is screwy in attack (1.1) ***"
			exit
		
		end
	elsif settings[:ammo].to_i == 0
		
		
		res = dothistimeout "get 1 #{ammo_types[settings[:ammo]]} from ##{quiver.id}", 1, /^You remove|^You get|^Get what\?$/
		
		if res =~ /^Get what\?$/
			echo "Out of ammo, Please restock."
			Script.pause('mechfire')
		elsif res.nil?
			echo "Error at-1: Please send log to investigate how you ended up here. @Getho#5573 on discord."
		end
		
		res = dothistimeout "fire ##{target.id}", 2, /^You fire .+? at .+?\!$|^You are too injured to fire that\!$|^You do not currently have a target\.$|^I could not find what you were referring to\.$|^A .+? is quite dead already\.$|^\.\.\.wait .+? seconds\.$/
	
		if res =~ /^You are too injured to fire that\!$/
			fix_injury.call
		
		elsif res =~ /\.\.\.wait .+? seconds\.$/
			pause 0.2
			waitrt?
			check_position.call
		
		elsif res =~ /^You do not currently have a target\.$|^I could not find what you were reffering to\.$|^A .+? is quite dead already\.$/
			target = nil
		
		elsif res =~ /^You fire .+? at .+?\!$/

		elsif res.nil?
			echo "*** Something is screwy in attack (1.1) ***"
			exit
		
		end
		
	end
=end
=begin
res = dothistimeout "get 1 #{ammo_types[settings[:ammo]]} from ##{quiver.id}", 1, /^You remove|^You get|^Get what\?$/
			if res =~ /^Get what\?$/
				echo "Out of ammo, Please restock."
				Script.pause('mechfire')
			elsif res.nil?
				echo "Error cr-1: Please send log to investigate how you ended up here. @Getho#5573 on discord."
			end
			
			res = dothistimeout "load my #{weapon}", 1, /^But your .+? can only hold up to .+?\!$|^You flip open the stock of your .+? and load .+? into it\.|You must be holding something to load into your .+?\.$/
			if res =~ /^You must be holding something to load into your .+?\.$/
				echo "Cannot find your ammo, Please restock."
				echo "Error cr-2: Please send log to investigate how you ended up here. @Getho#5573 on discord."
				Script.pause('mechfire')
			elsif res =~ /^But your .+? can only hold up to .+?\!$/
				ammo = ammo_max
				fput "stow right" until !checkright
			elsif res =~ /^You flip open the stock of your .+? and load .+? into it\./
				ammo += 1
			elsif res.nil?
				echo "Error cr-3: Please send log to investigate how you ended up here. @Getho#5573 on discord."
			end
=end