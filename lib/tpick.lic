=begin

	This script will disarm, measure, pick (and will use the appropriate lockpick based on your skill and lock difficulty) and empty your boxes into your container. This script can also be used to automatically accept, disarm, 			measure, pick and hand back other people's boxes.
	
	Script will attempt to read lock difficulty for Rogues using calipers and for Bards using loresinging. If you are a Rogue or Bard and would prefer to skip all that and always use a vaalin lock pick instead then use the v variables listed below.

	Script will attempt to use vials bundled into your locksmith's pouch first for plated boxes, if no vials are bundled into your locksmith's pouch it will attempt to use wedges found in your wedge sack.

	Usage:
	;tpick can now drop off boxes at the pool and pick them up!
	
	To drop off boxes at the pool to be picked do for example ";tpick drop 100" to tip 100 silvers per box, do ";tpick drop 10 percent" or ";tpick drop 10%" if you want to tip 10% per box
	
	To pick up boxes that have been picked do ";tpick pickup" or ";tpick return"
	
	;tpick <setup> must be done first before you can use this script. Be sure to fill out all of the settings.

	Use the following command line variables for how you want the script to run:

	other - will accept boxes handed to you, pick them, then hand them back to the person who handed you the box.
	ground - will pick all boxes on the ground but will not take loot out of them. Useful if you're picking boxes on the ground for someone else.
	worker - will get boxes from the worker and pick them.
	Not using "other", "ground", or "worker" will pick all boxes inside of your open containers and inside your disk.

	v - will skip measuring locks and always use a vaalin lockpick + 403 to pick all boxes.
	c - skips measuring and always starts with the lockpick in your copper lockpick setting then moves up list of lockpicks when needed.
	loot - to pick all boxes on the ground and take the loot out of each box.
	wedge - to always use a wedge to open boxes. In the case of scale traps the script will still attempt to pick the box first with a lockpick.
	bash - to bash open boxes
	relock - will relock the box after it has been opened and looted. Only works if you're picking your own boxes or you use both the ground and loot command line variables.
	pop - this will attempt to open boxes using 407 and 408 only. Does not work with the "other" variable but does work with "ground" picking. This option requires the knowledge of Piercing Gaze (416).
	disarm - this will ONLY check for and disarm traps, it will not open the boxes. Useful if you want to disarm traps for a warrior to bash them for guild reps. This feature only works with the ground variable.
	plin(ite) - will open all plinites in your open containers.

	The above commands can be used in any combination. Some examples:
	
	;tpick other v - will pick other people's boxes and always use a vaalin lockpick.
	;tpick loot ground v - will pick all boxes on the ground, will loot each box after picking them, and will always use a vaalin lockpick.
	;tpick - will pick all boxes in your open containers.


	The following commands cannot be used with the above commands:

	buy - script will fill up your locksmith's container with cotton balls and putty by buying them at the locksmith's shop. Script will exit once done.
	repair - script will repair any lockpicks that need repairing. Must be a rogue with the lmas skill to repair lockpicks.
	Currently repair only works in Icemule, Landing, Sol Haven and Illistim.


	Non Rogues and bards do not need to use the "v" command line, they will always pick boxes with a vaalin lockpick and won't use calipers.
	
	Changelog:
	See previous revisions to script here: http://forum.gsplayers.com/showthread.php?128853-Official-tpick-changes-and-discussion&p=2203268#post2203268
	Version 336: Fixed bug which caused script to crash while using the "auto" feature for the "calibrate count" setting.
	Version 337: Script will now DETECT boxes first to check for traps instead of DISARMing them.
	Version 337: Removed setting "Haste (506)" under "Spells" tab.
	Version 337: Added setting "Song of Tonis (1035)" under "Spells" tab.
	Version 337: New setting under "Spells" tab: "Percent mana to keep". For example you can enter "50" in this setting to stop casting spells once your mana falls below 50% of your max mana. Leave setting blank to always cast spells as long as you have enough mana.
	Version 338: Fixed bug with script attempting to pick anything with the noun of "case", whether the case in question was a box or not.
	Version 339: Fixed bug with script stalling when DETECTing a box that is already open.
	Version 340: Fixed bug with script not running properly when using a lockpick with a noun other than "lockpick".
	Version 340: Added setting "Max Lock Roll" under "Other" tab: For example enter 30 and when you roll lower than 30 when picking locks the script will attempt to pick again no matter what messaging you received. Enter 0 or leave blank if you want script to always move to higher lockpicks when receiving a message that you aren't able to pick the current lock, these messages are when your lockpick gets stuck in the lock or you bend the tip. If you break your lockpick you will always move to a higher lockpick.
	
	To do list:
		
	########################################################
	Ways to contact me:
	In game: Dreaven
	Player's Corner: Tgo01
	Discord: Dreaven#6436
	Email: LordDreaven@gmail.com
	If you like my scripts feel free to send me a tip via Paypal at: LordDreaven@gmail.com
	########################################################
	
	Author: Dreaven
	Version: 340

=end

lich_up_to_date = nil
version = LICH_VERSION.split(".")
if version[0].to_i > 4
	lich_up_to_date = true
elsif version[1].to_i > 6
	lich_up_to_date = true
elsif version[2].to_i > 53
	lich_up_to_date = true
end

if Gem.loaded_specs["gtk3"]
	gtk_version = 3
else
	gtk_version = 2
end

CharSettings['scarab'] = 0 unless CharSettings['scarab']
CharSettings['needle'] = 0 unless CharSettings['needle']
CharSettings['jaws'] = 0 unless CharSettings['jaws']
CharSettings['sphere'] = 0 unless CharSettings['sphere']
CharSettings['crystal'] = 0 unless CharSettings['crystal']
CharSettings['scales'] = 0 unless CharSettings['scales']
CharSettings['sulphur'] = 0 unless CharSettings['sulphur']
CharSettings['cloud'] = 0 unless CharSettings['cloud']
CharSettings['acid_vial'] = 0 unless CharSettings['acid_vial']
CharSettings['springs'] = 0 unless CharSettings['springs']
CharSettings['fire_vial'] = 0 unless CharSettings['fire_vial']
CharSettings['spores'] = 0 unless CharSettings['spores']
CharSettings['plate'] = 0 unless CharSettings['plate']
CharSettings['glyph'] = 0 unless CharSettings['glyph']
CharSettings['rods'] = 0 unless CharSettings['rods']
CharSettings['boomer'] = 0 unless CharSettings['boomer']
CharSettings['no_trap'] = 0 unless CharSettings['no_trap']
CharSettings['total_trap_count'] = 0.0 unless CharSettings['total_trap_count']
temp_copper_lockpicks_array = UserVars.tpick["copper"].split(",")
temp_steel_lockpicks_array = UserVars.tpick["steel"].split(",")
temp_gold_lockpicks_array = UserVars.tpick["gold"].split(",")
temp_silver_lockpicks_array = UserVars.tpick["silver"].split(",")
temp_mithril_lockpicks_array = UserVars.tpick["mithril"].split(",")
temp_ora_lockpicks_array = UserVars.tpick["ora"].split(",")
temp_glaes_lockpicks_array = UserVars.tpick["glaes"].split(",")
temp_laje_lockpicks_array = UserVars.tpick["laje"].split(",")
temp_vultite_lockpicks_array = UserVars.tpick["vultite"].split(",")
temp_rolaren_lockpicks_array = UserVars.tpick["rolaren"].split(",")
temp_veniom_lockpicks_array = UserVars.tpick["veniom"].split(",")
temp_invar_lockpicks_array = UserVars.tpick["invar"].split(",")
temp_alum_lockpicks_array = UserVars.tpick["alum"].split(",")
temp_golvern_lockpicks_array = UserVars.tpick["golvern"].split(",")
temp_kelyn_lockpicks_array = UserVars.tpick["kelyn"].split(",")
temp_vaalin_lockpicks_array = UserVars.tpick["vaalin"].split(",")
CharSettings["number_of_current_uses_for_lockpicks"] = Hash.new unless CharSettings["number_of_current_uses_for_lockpicks"]
CharSettings["number_of_locks_opened_since_last_broken_pick"] = 0 unless CharSettings["number_of_locks_opened_since_last_broken_pick"]
CharSettings["number_of_total_boxes_picked_pool_picking"] = 0 unless CharSettings["number_of_total_boxes_picked_pool_picking"]
CharSettings["total_silvers_earned_from_pool_picking"] = 0 unless CharSettings["total_silvers_earned_from_pool_picking"]
CharSettings["total_scarabs_received_pool_picking"] = 0 unless CharSettings["total_scarabs_received_pool_picking"]
CharSettings["total_time_spent_pool_picking"] = 0 unless CharSettings["total_time_spent_pool_picking"]
CharSettings['time_to_subtract_from_overall_actual_picking_time'] = 0 unless CharSettings['time_to_subtract_from_overall_actual_picking_time']
silvers_earned_from_pool_picking_this_session = 0
time_spent_pool_picking_this_session = 0
all_scarab_ids = Array.new
max_lock_attempt = 10000
minimum_tip_wanted = 0
scarabs_received_this_session_pool_picking = 0
number_of_boxes_picked_this_session_pool_picking = 0
minimum_tip_current = 0
total_number_of_boxes = 0
lock = 0
number_of_times_to_measure = 0
max_critter_level = 1000
CharSettings['total_boxes_picked'] = 0 unless CharSettings['total_boxes_picked']
CharSettings['total_time_spent_picking_boxes'] = 0 unless CharSettings['total_time_spent_picking_boxes']
time_to_subtract_from_actual_picking_time = 0
average_picking_time = 0
start_time = 0
max_roll_attempt_before_moving_to_new_pick = 0
starting_room = Room.current.id
check_all_ground_boxes_again = true
all_box_types = "(strongbox|box|chest|trunk|coffer|case)"
all_box_full_names = /(?:shifting )?((?:(?:acid-pitted|badly damaged|battered|corroded|dented|engraved|enruned|plain|scratched|sturdy) )?(?:brass|gold|iron|mithril|silver|steel) (?:box|chest|coffer|strongbox|trunk)|(?:(?:badly damaged|engraved|enruned|iron-bound|plain|rotting|scratched|simple|sturdy|weathered) )?(?:fel|haon|maoral|modwir|monir|tanik|thanot|wooden) (?:box|chest|coffer|strongbox|trunk)|(?:(?:austere|brass-inlaid|crude|gilded|ornate|scorched) )?(?:carved modwir|cracked|deeply-scored|delicate|red lacquered|stained) (?:box|chest|coffer|strongbox|trunk|case)|filigreed rolaren reliquary)/
$tpick_list_of_box_ids = Array.new
$tpick_copper_wire = nil unless $tpick_copper_wire
$tpick_copper_wire_cost = nil unless $tpick_copper_wire_cost
$tpick_brass_wire = nil unless $tpick_brass_wire
$tpick_brass_wire_cost = nil unless $tpick_brass_wire_cost
$tpick_steel_wire = nil unless $tpick_steel_wire
$tpick_steel_wire_cost = nil unless $tpick_steel_wire_cost
$tpick_gold_wire = nil unless $tpick_gold_wire
$tpick_gold_wire_cost = nil unless $tpick_gold_wire_cost
$tpick_silver_wire = nil unless $tpick_silver_wire
$tpick_silver_wire_cost = nil unless $tpick_silver_wire_cost
$tpick_ora_wire = nil unless $tpick_ora_wire
$tpick_ora_wire_cost = nil unless $tpick_ora_wire_cost
$tpick_mithril_wire = nil unless $tpick_mithril_wire
$tpick_mithril_wire_cost = nil unless $tpick_mithril_wire_cost
$tpick_laje_wire = nil unless $tpick_laje_wire
$tpick_laje_wire_cost = nil unless $tpick_laje_wire_cost
$tpick_alum_wire = nil unless $tpick_alum_wire
$tpick_alum_wire_cost = nil unless $tpick_alum_wire_cost
$tpick_vultite_wire = nil unless $tpick_vultite_wire
$tpick_vultite_wire_cost = nil unless $tpick_vultite_wire_cost
$tpick_rolaren_wire = nil unless $tpick_rolaren_wire
$tpick_rolaren_wire_cost = nil unless $tpick_rolaren_wire_cost
$tpick_veniom_wire = nil unless $tpick_veniom_wire
$tpick_veniom_wire_cost = nil unless $tpick_veniom_wire_cost
$tpick_kelyn_wire = nil unless $tpick_kelyn_wire
$tpick_kelyn_wire_cost = nil unless $tpick_kelyn_wire_cost
$tpick_invar_wire = nil unless $tpick_invar_wire
$tpick_invar_wire_cost = nil unless $tpick_invar_wire_cost
$tpick_golvern_wire = nil unless $tpick_golvern_wire
$tpick_golvern_wire_cost = nil unless $tpick_golvern_wire_cost
$tpick_vaalin_wire = nil unless $tpick_vaalin_wire
$tpick_vaalin_wire_cost = nil unless $tpick_vaalin_wire_cost
toolbenches_room_number = [ '17978', '16574', '17960', '17881', '17387', '21187' ]
spin_number = 0
copper_lock_pick_array = Array.new
steel_lock_pick_array = Array.new
gold_lock_pick_array = Array.new
silver_lock_pick_array = Array.new
mithril_lock_pick_array = Array.new
ora_lock_pick_array = Array.new
glaes_lock_pick_array = Array.new
laje_lock_pick_array = Array.new
vultite_lock_pick_array = Array.new
rolaren_lock_pick_array = Array.new
veniom_lock_pick_array = Array.new
invar_lock_pick_array = Array.new
alum_lock_pick_array = Array.new
golvern_lock_pick_array = Array.new
kelyn_lock_pick_array = Array.new
vaalin_lock_pick_array = Array.new
CharSettings['setup_required_again_for_version_332'] = nil unless CharSettings['setup_required_again_for_version_332']
all_variables_to_check = [ script.vars[1], script.vars[2], script.vars[3], script.vars[4], script.vars[5], script.vars[6], script.vars[7], script.vars[8], script.vars[9], script.vars[10] ]
$tpick_remove_armor_before_casting_spell = UserVars.tpick["remove_armor"] if UserVars.tpick["remove_armor"].length > 0 && UserVars.tpick["remove_armor"] != "nil"

@percentage_of_mana_to_keep = stop_trying_to_use_407 = use_unlock_407_settings = box_counts_for_math = max_lock_attempt_compared_to_max_skill = calibrate_auto_amount = calipers_measured_lock = same_scarab_found = box_was_not_locked = bash_the_box_open = bash_open_boxes = temp_math_number = check_for_lockpicks_etc = quick_maths = tip_is_a_percent = tip_being_offered = offered_tip_amount = detect_plinite = temp_id = worker_start_picking_time = temp_name = critter_level = current_item = picking_up = minimum_tip_start = minimum_tip_subtract = minimum_tip_floor = tpick_gather_the_loot = already_checked_for_disk = coins_from_boxes_comma_nonsense = gather_stuff = finished_it = loresong_stuff = $tpick_use_403_cancel = $tpick_use_404_cancel = temp_403_variable = temp_404_variable = current_room = scarab_name = total_silvers_from_box = scarab_object = encumbrance_check = starting_room_number = measure_detection = buy_locksmith_pouch = cast_704_at_box = detect_plinite_result = box_is_enruned_or_mithril = roll_amount_check = use_404_for_trap_difficulty = before_recommended_pick = i_need_403 = ask_worker = random_trick = start_values_nilled = total_picking_time = count_boxes_in_disk = total_boxes_count = update_math_information = total_boxes_number = reset_math = get_vials_and_stuff = total_boxes_picked_math = temp_picks_critter_level = bracers_temp = bracers_name = bracers_tier = nextpick2 = found_true_lock_difficulty = @tpick_lockpick_container = @tpick_broken_lockpick_container = lock_pick_information = always_use_wedge = @tpick_wedge_container = @tpick_calipers_container = @tpick_scale_weapon_container = @tpick_locksmiths_container = next_task = roll_amount = number_of_manual_trap_checks_remaining = time_to_disarm_trap = check_for_command = start_worker = start_worker2 = gem = reagent = herb = food = uncommon = jewelry = junk = lockpick = magic = scroll = wand = armor = weapon = clothing = other = pool_picking_fried_commands = pool_fried_start_time = starting_pool_room_number = stow_in_disk = check_for_boxes = remaining_416_casts = stuff_to_do = where_to_stow_box = check_locksmiths_container = putty_remaining = cotton_remaining = vials_remaining = fill_up_locksmith_container = order_number = trash_container = current_vial = use_spell_205 = use_spell_402 = use_spell_403 = use_spell_404 = use_spell_1035 = use_spell_613 = use_spell_704 = use_spell_1006 = pop_start = recommended_pick = recommended_pick_modifier = needed_pick_id = before_needed_pick = check_hands_status = current_trap_type = box_is_disarmed = box_is_open = check_for_trap = pop_open_box = disarm_trap = cast_402 = cast_403 = cast_404 = use_403_for_lock_difficulty = can_use_calipers = pop_boxes_begin = fused_lock_disarm = override_bracers = $scale_trap_weapon_id = finished_getting_coins = picks_to_use_based_on_critter_level = get_wire_order_numbers = current_pick_to_check = lockpick_type = stow_both = current_wire = find_gnomish_lockpick = current_wire_cost = popping = start_sorter = number = contents = container = scale_trap_found = gnomish_bracers = found_pick = disarm_only = gnomish_bracers_trap_check = gnomish_bracers_trap_check_result = stats_check = $copper_lockpick_id = $steel_lockpick_id = $gold_lockpick_id = $silver_lockpick_id = $mithril_lockpick_id = $ora_lockpick_id = $glaes_lockpick_id = $laje_lockpick_id = $vultite_lockpick_id = $rolaren_lockpick_id = $veniom_lockpick_id = $invar_lockpick_id = $alum_lockpick_id = $golvern_lockpick_id = $kelyn_lockpick_id = $vaalin_lockpick_id = start_with_copper = all_stats_to_check = all_stats_trap_names = math = open_plinites = start_plinites = open_current_plinite = plinite_already_open = cannot_determine_plinite_difficulty = critter_name = current_box = tpick_bundle_vials = $tpick_armor_has_been_removed = nil

stats_check = proc{
	if CharSettings['total_trap_count'] == 0.0
		echo "No trap information has been recorded yet. Get to checking boxes for traps!"
	else
		number = 0
		all_stats_to_check = [ CharSettings['scarab'], CharSettings['needle'], CharSettings['jaws'], CharSettings['sphere'], CharSettings['crystal'], CharSettings['scales'], CharSettings['sulphur'], CharSettings['cloud'], CharSettings['acid_vial'], CharSettings['springs'], CharSettings['fire_vial'], CharSettings['spores'], CharSettings['plate'], CharSettings['glyph'], CharSettings['rods'], CharSettings['boomer'], CharSettings['no_trap'] ]
		all_stats_trap_names = [ "Scarab         ", "Needle         ", "Jaws           ", "Sphere         ", "Crystal        ", "Scales         ", "Sulphur        ", "Cloud          ", "Acid Vial      ", "Springs        ", "Fire Vial      ", "Spores         ", "Plate          ", "Glyph          ", "Rods           ", "Boomer         ", "No Trap        " ]
		respond "##############################"
		respond "##############################"
		respond "All trap information"
		all_stats_to_check.each { |i|
			math = (((i / CharSettings['total_trap_count'])) * (100)).round(2)
			respond "#{all_stats_trap_names.at(number)} #{i} (#{math}%)"
			number += 1
		}
		respond "Total Trap      #{CharSettings['total_trap_count']}"
		respond "##############################"
		respond "##############################"
	end
		
}

reset_math = proc{
	CharSettings['total_boxes_picked'] = 0
	CharSettings['total_time_spent_picking_boxes'] = 0
}

$tpick_boxes_checked = nil
strongbox_count = 0
box_count = 0
chest_count = 0
trunk_count = 0
coffer_count = 0

gem_number = Array.new
reagent_number = Array.new
herb_number = Array.new
food_number = Array.new
uncommon_number = Array.new
jewelry_number = Array.new
junk_number = Array.new
lockpick_number = Array.new
magic_number = Array.new
scroll_number = Array.new
wand_number = Array.new
armor_number = Array.new
weapon_number = Array.new
clothing_number = Array.new
other_number = Array.new
all_box_ids_already_picked = Array.new

dex_bonus = nil

#The following is just for informational purposes, no need to change anything.

#Pick names and mod values:
#Copper		1.00
#Steel		1.10
#Gold		1.20
#Silver		1.30
#Mithril	1.45
#Ora		1.55
#Glaes		1.60
#Laje		1.75
#Vultite	1.80
#Rolaren	1.90
#Veniom		2.20
#Invar		2.25
#Alum		2.30
#Golvern	2.35
#Kelyn		2.40
#Vaalin		2.50

#Lock names and difficulty
#Primitive					35
#Rudimentary				75
#Extremely Easy				115
#Very Easy					155
#Easy						195
#Very Basic					235
#Fairly Easy				275
#Simple						315
#Fairly Simple				355
#Fairly Plain				395
#Moderately Well-Crafted	435
#Well-Crafted				475
#Tricky						515
#Somewhat Difficult			555
#Moderately Difficult		595
#Very Well-Crafted			635
#Difficult					675
#Extremely Well-Crafted		715
#Very Difficult				755
#Fairly Complicated			795
#Intricate					835
#Amazingly Well-Crafted		875
#Very Complex				915
#Impressively Complicated	955
#Amazingly Intricate		995
#Extremely Difficult		1035
#Extremely Complex			1075
#Masterfully Well-Crafted	1115
#Amazingly Complicated		1155
#Astoundingly Complex		1195
#Incredibly Intricate		1235
#Absurdly Well-Crafted		1275
#Exceedingly Complex		1315
#Absurdly Difficult			1355
#Unbelievably Complicated 	1395
#Masterfully Intricate		1435
#Absurdly Complex			1475
#Impossibly Complex			1515

worker = nil
if Room.current.id == 28937
	worker = "worker"
else
	Room.current.tags.find{ |i| i =~ /meta:boxpool:npc:(.*)/;worker = $1}
end
worker = GameObj.npcs.find {|i| worker =~ /#{i}/}

table = nil
if Room.current.id == 28937
	table = "table"
else
	Room.current.tags.find{ |i| i =~ /meta:boxpool:table:(.*)/;table = $1}
end
if GameObj.loot.find {|i| table =~ /#{i}/}
	table = GameObj.loot.find {|i| table =~ /#{i}/}
else
	table = GameObj.room_desc.find {|i| table =~ /#{i}/}
end

pick_mod = [ 1.00, 1.10, 1.20, 1.30, 1.45, 1.55, 1.60, 1.75, 1.80, 1.90, 2.20, 2.25, 2.30, 2.35, 2.40, 2.50 ]
lock_difficulty = [ 35, 75, 115, 155, 195, 235, 275, 315, 355, 395, 435, 475, 515, 555, 595, 635, 675, 715, 755, 795, 835, 875, 915, 955, 995, 1035, 1075, 1115, 1155, 1195, 1235, 1275, 1315, 1355, 1395, 1435, 1475, 1515 ]
if lich_up_to_date
	dex_bonus = Stats.enhanced_dex[1]
else
	dex_bonus = Stats.dex[1]
end
pick_skill = (Skills.to_bonus(Skills.pickinglocks) + dex_bonus)
pick_lore = [(Stats.level / 2) + (Skills.to_bonus(Skills.pickinglocks) / 10) + (dex_bonus) + (Spells.minorelemental / 4), Skills.to_bonus(Skills.pickinglocks)].min
disarm_skill = (dex_bonus + Skills.to_bonus(Skills.disarmingtraps))
if Spell[404].known?
	disarm_lore = [(Stats.level / 2) + (Skills.to_bonus(Skills.disarmingtraps) / 10) + dex_bonus + (Spells.minorelemental / 4), Skills.to_bonus(Skills.disarmingtraps)].min
else
	disarm_lore = 0
end
(start_solo = nil;start_others = nil;check_disk = nil;manually_disarm_trap = nil;scaledisarm = nil;plate = nil;measure = nil;pick2 = nil;pick3 = nil;nextpick = nil;open_solo = nil;open_others = nil;need_403 = nil;needed_pick = nil;total_pick_skill = nil;person = nil;box = "box";cast_404 = nil;solo_or_other = nil;always_use_vaalin = nil;wedge_lock = nil;ground_loot = nil;start_ground = nil;setup = nil;do_trick = nil;calibrate = nil;cast_403 = nil;cast_402 = nil;cast_613 = nil;cast_205 = nil;cast_1006 = nil;cast_1035 = nil;calibrate_count = nil;cast_407 = nil;current_box_name = nil;box_opened = true;cant_open_plated_box_count = nil;total_boxes_picked = 0;record_item_data = nil;silver_before = nil;silver_after = nil;wealth_before = nil;wealth_after = nil;silver_gained = 0;trash = nil;garbage_check = nil;trap_difficulty = nil;need_404 = nil;total_trap_skill = nil;relock_boxes = nil;do_relock_boxes = nil)

trash_container = /crate|barrel|wastebarrel|casket|bin|receptacle|basket/i

setup = proc{
	CharSettings['setup_required_again_for_version_332'] = true
	$copper_lockpick_id = nil
	$steel_lockpick_id = nil
	$gold_lockpick_id = nil
	$silver_lockpick_id = nil
	$mithril_lockpick_id = nil
	$ora_lockpick_id = nil
	$glaes_lockpick_id = nil
	$laje_lockpick_id = nil
	$vultite_lockpick_id = nil
	$rolaren_lockpick_id = nil
	$veniom_lockpick_id = nil
	$invar_lockpick_id = nil
	$alum_lockpick_id = nil
	$golvern_lockpick_id = nil
	$kelyn_lockpick_id = nil
	$vaalin_lockpick_id = nil
	Gtk.queue {
		$TPICK_WINDOW = Gtk::Window.new
		$TPICK_WINDOW.title = "tpick"
		$TPICK_WINDOW.set_border_width(10)
		
		#GTK2 and GTK3 nonsense:
		if gtk_version == 2
			$TPICK_BOX = Gtk::VBox.new(false)
			$TPICK_BOX.set_border_width(5)

			$TPICK_VERTICAL_BOX1 = Gtk::VBox.new(false, 0)
			$TPICK_VERTICAL_BOX2 = Gtk::VBox.new(false, 0)
			$TPICK_VERTICAL_BOX3 = Gtk::VBox.new(false, 0)
			$TPICK_VERTICAL_BOX4 = Gtk::VBox.new(false, 0)
			$TPICK_VERTICAL_BOX5 = Gtk::VBox.new(false, 0)
			$TPICK_VERTICAL_BOX6 = Gtk::VBox.new(false, 0)
			$TPICK_VERTICAL_BOX7 = Gtk::VBox.new(false, 0)
			$TPICK_VERTICAL_BOX8 = Gtk::VBox.new(false, 0)
			$TPICK_VERTICAL_BOX9 = Gtk::VBox.new(false, 0)
			$TPICK_VERTICAL_BOX10 = Gtk::VBox.new(false, 0)
			$TPICK_VERTICAL_BOX11 = Gtk::VBox.new(false, 0)
		else
			$TPICK_BOX = Gtk::Box.new(:vertical)
			$TPICK_BOX.set_border_width(5)

			$TPICK_VERTICAL_BOX1 = Gtk::Box.new(:vertical, 0)
			$TPICK_VERTICAL_BOX2 = Gtk::Box.new(:vertical, 0)
			$TPICK_VERTICAL_BOX3 = Gtk::Box.new(:vertical, 0)
			$TPICK_VERTICAL_BOX4 = Gtk::Box.new(:vertical, 0)
			$TPICK_VERTICAL_BOX5 = Gtk::Box.new(:vertical, 0)
			$TPICK_VERTICAL_BOX6 = Gtk::Box.new(:vertical, 0)
			$TPICK_VERTICAL_BOX7 = Gtk::Box.new(:vertical, 0)
			$TPICK_VERTICAL_BOX8 = Gtk::Box.new(:vertical, 0)
			$TPICK_VERTICAL_BOX9 = Gtk::Box.new(:vertical, 0)
			$TPICK_VERTICAL_BOX10 = Gtk::Box.new(:vertical, 0)
			$TPICK_VERTICAL_BOX11 = Gtk::Box.new(:vertical, 0)
		end
		#####

		$TPICK_WINDOW.add($TPICK_BOX)
		$TPICK_NOTEBOOK = Gtk::Notebook.new
		$TPICK_NOTEBOOK.set_show_border(true)
		$TPICK_BOX.add($TPICK_NOTEBOOK)
		$TPICK_NOTEBOOK.append_page($TPICK_VERTICAL_BOX1, Gtk::Label.new('Lockpicks'))
		$TPICK_NOTEBOOK.append_page($TPICK_VERTICAL_BOX2, Gtk::Label.new('More Lockpicks'))
		$TPICK_NOTEBOOK.append_page($TPICK_VERTICAL_BOX3, Gtk::Label.new('Containers'))
		$TPICK_NOTEBOOK.append_page($TPICK_VERTICAL_BOX4, Gtk::Label.new('Other'))
		$TPICK_NOTEBOOK.append_page($TPICK_VERTICAL_BOX5, Gtk::Label.new('More Other'))
		$TPICK_NOTEBOOK.append_page($TPICK_VERTICAL_BOX6, Gtk::Label.new('Yet More Other'))
		$TPICK_NOTEBOOK.append_page($TPICK_VERTICAL_BOX7, Gtk::Label.new('Spells'))
		$TPICK_NOTEBOOK.append_page($TPICK_VERTICAL_BOX8, Gtk::Label.new('Experience'))
		$TPICK_NOTEBOOK.append_page($TPICK_VERTICAL_BOX9, Gtk::Label.new('Speech'))
		$TPICK_NOTEBOOK.append_page($TPICK_VERTICAL_BOX10, Gtk::Label.new('Popping'))
		$TPICK_NOTEBOOK.append_page($TPICK_VERTICAL_BOX11, Gtk::Label.new('Pool/Worker'))
		$TPICK_ENTRY = Hash.new 
		$TPICK_TABLE_SIZE = Hash.new
	}

	Gtk.queue {
		$TPICK_TABLE1 = Gtk::Table.new(6, 3, false)
		$TPICK_TABLE1.row_spacings=3
		$TPICK_TABLE1.column_spacings=3
		$TPICK_VERTICAL_BOX1.pack_start($TPICK_TABLE1, false, false, 0)

		$TPICK_TABLE2 = Gtk::Table.new(6, 3, false)
		$TPICK_TABLE2.row_spacings=3
		$TPICK_TABLE2.column_spacings=3
		$TPICK_VERTICAL_BOX2.pack_start($TPICK_TABLE2, false, false, 0)

		$TPICK_TABLE3 = Gtk::Table.new(6, 3, false)
		$TPICK_TABLE3.row_spacings=3
		$TPICK_TABLE3.column_spacings=3
		$TPICK_VERTICAL_BOX3.pack_start($TPICK_TABLE3, false, false, 0)

		$TPICK_TABLE4 = Gtk::Table.new(6, 3, false)
		$TPICK_TABLE4.row_spacings=3
		$TPICK_TABLE4.column_spacings=3
		$TPICK_VERTICAL_BOX4.pack_start($TPICK_TABLE4, false, false, 0)

		$TPICK_TABLE5 = Gtk::Table.new(6, 3, false)
		$TPICK_TABLE5.row_spacings=3
		$TPICK_TABLE5.column_spacings=3
		$TPICK_VERTICAL_BOX5.pack_start($TPICK_TABLE5, false, false, 0)

		$TPICK_TABLE6 = Gtk::Table.new(6, 3, false)
		$TPICK_TABLE6.row_spacings=3
		$TPICK_TABLE6.column_spacings=3
		$TPICK_VERTICAL_BOX6.pack_start($TPICK_TABLE6, false, false, 0)

		$TPICK_TABLE7 = Gtk::Table.new(6, 3, false)
		$TPICK_TABLE7.row_spacings=3
		$TPICK_TABLE7.column_spacings=3
		$TPICK_VERTICAL_BOX7.pack_start($TPICK_TABLE7, false, false, 0)

		$TPICK_TABLE8 = Gtk::Table.new(6, 3, false)
		$TPICK_TABLE8.row_spacings=3
		$TPICK_TABLE8.column_spacings=3
		$TPICK_VERTICAL_BOX8.pack_start($TPICK_TABLE8, false, false, 0)

		$TPICK_TABLE9 = Gtk::Table.new(6, 3, false)
		$TPICK_TABLE9.row_spacings=3
		$TPICK_TABLE9.column_spacings=3
		$TPICK_VERTICAL_BOX9.pack_start($TPICK_TABLE9, false, false, 0)
		
		$TPICK_TABLE10 = Gtk::Table.new(6, 3, false)
		$TPICK_TABLE10.row_spacings=3
		$TPICK_TABLE10.column_spacings=3
		$TPICK_VERTICAL_BOX10.pack_start($TPICK_TABLE10, false, false, 0)
		
		$TPICK_TABLE11 = Gtk::Table.new(6, 3, false)
		$TPICK_TABLE11.row_spacings=3
		$TPICK_TABLE11.column_spacings=3
		$TPICK_VERTICAL_BOX11.pack_start($TPICK_TABLE11, false, false, 0)
	}

	def self.add_label_entry(table, label, variable)
		size = $TPICK_TABLE_SIZE[table] || 0

		label = Gtk::Label.new(label)
		align = Gtk::Alignment.new 1, 0, 0, 0
		align.set_padding(4, 0, 3, 4)
		align.add(label)
		table.attach(align, 0, 1, size, size + 1)

		entry = Gtk::Entry.new
		entry.text = UserVars.tpick[variable].to_s
		entry.set_width_request(157)
		table.attach(entry, 1, 2, size, size + 1)

		$TPICK_ENTRY[variable] = entry
		$TPICK_TABLE_SIZE[table] += 1
	end

	Gtk.queue {
		$TPICK_ENTRY = Hash.new
		add_label_entry($TPICK_TABLE1, "Copper Lockpick", 'copper')
		add_label_entry($TPICK_TABLE1, "Steel Lockpick", 'steel')
		add_label_entry($TPICK_TABLE1, "Gold Lockpick", 'gold')
		add_label_entry($TPICK_TABLE1, "Silver Lockpick", 'silver')
		add_label_entry($TPICK_TABLE1, "Mithril Lockpick", 'mithril')
		add_label_entry($TPICK_TABLE1, "Ora Lockpick", 'ora')
		add_label_entry($TPICK_TABLE1, "Glaes Lockpick", 'glaes')
		add_label_entry($TPICK_TABLE1, "Laje Lockpick", 'laje')
		add_label_entry($TPICK_TABLE2, "Vultite Lockpick", 'vultite')
		add_label_entry($TPICK_TABLE2, "Rolaren Lockpick", 'rolaren')
		add_label_entry($TPICK_TABLE2, "Veniom Lockpick", 'veniom')
		add_label_entry($TPICK_TABLE2, "Invar Lockpick", 'invar')
		add_label_entry($TPICK_TABLE2, "Alum Lockpick", 'alum')
		add_label_entry($TPICK_TABLE2, "Golvern Lockpick", 'golvern')
		add_label_entry($TPICK_TABLE2, "Kelyn Lockpick", 'kelyn')
		add_label_entry($TPICK_TABLE2, "Vaalin Lockpick", 'vaalin')
		add_label_entry($TPICK_TABLE3, "Lockpick Container", 'lockpick_container')
		add_label_entry($TPICK_TABLE3, "Broken Lockpick Container", 'broken_lockpick_container')
		add_label_entry($TPICK_TABLE3, "Wedge Container", 'wedge_container')
		add_label_entry($TPICK_TABLE3, "Calipers Container", 'calipers_container')
		add_label_entry($TPICK_TABLE3, "Scale Weapon Container", 'scale_weapon_container')
		add_label_entry($TPICK_TABLE3, "Locksmith's Container", 'locksmiths_container')
		add_label_entry($TPICK_TABLE3, "Containers to open at start", 'containers_open_to_start')
		add_label_entry($TPICK_TABLE3, "Containers to close before exit", 'containers_to_close_before_exit')
		add_label_entry($TPICK_TABLE3, "Other containers", 'all_other_containers')
		add_label_entry($TPICK_TABLE4, "Auto deposit silvers", 'auto_deposit_silvers')
		add_label_entry($TPICK_TABLE4, "Gnomish Bracer", 'gnomish_bracer')
		add_label_entry($TPICK_TABLE4, "Bashing Weapon", 'bashing_weapon')
		add_label_entry($TPICK_TABLE4, "Scale Trap Weapon", 'scale_trap_weapon')
		add_label_entry($TPICK_TABLE4, "Remove armor", 'remove_armor')
		add_label_entry($TPICK_TABLE4, "Max Lock", 'max_lock')
		add_label_entry($TPICK_TABLE4, "Max Lock Roll", 'max_lock_roll')
		add_label_entry($TPICK_TABLE4, "Trap Roll", 'trap_roll')
		add_label_entry($TPICK_TABLE5, "Trick", 'trick')
		add_label_entry($TPICK_TABLE5, "Log", 'log')
		add_label_entry($TPICK_TABLE5, "Trash boxes", 'trash_boxes')
		add_label_entry($TPICK_TABLE5, "Calibrate on startup", 'calibrate')
		add_label_entry($TPICK_TABLE5, "Calibrate count", 'calibratecount')
		add_label_entry($TPICK_TABLE5, "Auto Bundle Vials", 'auto_bundle_vials')
		add_label_entry($TPICK_TABLE5, "Auto repair bent lockpicks", 'auto_repair_bent_lockpicks')
		add_label_entry($TPICK_TABLE5, "Number of times to check for traps", 'number_of_times_to_check_for_traps')
		add_label_entry($TPICK_TABLE6, "Lock Roll", 'lock_roll')
		add_label_entry($TPICK_TABLE6, "Vaalin Lock Roll", 'vaalin_lock_roll')
		add_label_entry($TPICK_TABLE6, "Lock Buffer", 'lock_buffer')
		add_label_entry($TPICK_TABLE6, "Keep trying if within abilities", 'keep_trying_if_within_abilities')
		add_label_entry($TPICK_TABLE6, "Run silently", 'run_silently')
		add_label_entry($TPICK_TABLE7, "Light (205)", 'always_use_205')
		add_label_entry($TPICK_TABLE7, "Presence (402)", 'always_use_402')
		add_label_entry($TPICK_TABLE7, "Lock Pick Enhancement (403)", 'always_use_403')
		add_label_entry($TPICK_TABLE7, "Disarm Enhancement (404)", 'always_use_404')
		add_label_entry($TPICK_TABLE7, "Unlock (407)", 'always_use_407')
		add_label_entry($TPICK_TABLE7, "Self Control (613)", 'always_use_613')
		add_label_entry($TPICK_TABLE7, "Song of Luck (1006)", 'always_use_1006')
		add_label_entry($TPICK_TABLE7, "Song of Tonis (1035)", 'always_use_1035')
		add_label_entry($TPICK_TABLE7, "Percent mana to keep", 'percent_mana_to_keep')
		add_label_entry($TPICK_TABLE8, "Use Vaalin when Fried", 'use_vaalin_when_fried')
		add_label_entry($TPICK_TABLE8, "Rest at Percent", 'rest_percent')
		add_label_entry($TPICK_TABLE8, "Pick at Percent", 'pick_percent')
		add_label_entry($TPICK_TABLE9, "Ready", 'ready')
		add_label_entry($TPICK_TABLE9, "Can't Open Box", 'cant_open_box')
		add_label_entry($TPICK_TABLE9, "Scarab Found", 'scarab_found')
		add_label_entry($TPICK_TABLE9, "Scarab safe", 'scarab_safe')
		add_label_entry($TPICK_TABLE10, "Phase (704)", 'always_use_704')
		add_label_entry($TPICK_TABLE10, "Number of 416 casts", 'number_of_416_casts')
		add_label_entry($TPICK_TABLE10, "Only disarm safe", 'only_disarm_safe')
		add_label_entry($TPICK_TABLE11, "Max critter level", 'max_critter_level')
		add_label_entry($TPICK_TABLE11, "Minimum tip wanted", 'minimum_tip_wanted')
		add_label_entry($TPICK_TABLE11, "Use 403 based on critter level", 'use_403_based_on_critter_level')
		add_label_entry($TPICK_TABLE11, "Use 404 based on critter level", 'use_404_based_on_critter_level')
		add_label_entry($TPICK_TABLE11, "Rest when fried", 'pool_picking_rest_when_fried')
		add_label_entry($TPICK_TABLE11, "Picks to use based on critter level", 'picks_to_use_based_on_critter_level')
	}

	def self.add_checkbox(table, x_pos, label, variable, default = false)
		size = $TPICK_TABLE_SIZE[table] || 0
		checkbox = Gtk::CheckButton.new label
		value = UserVars.tpick[variable].nil? ? default : UserVars.tpick[variable]
		checkbox.set_active(value)
		table.attach(checkbox, x_pos, x_pos + 1, size, size + 1)
		$TPICK_ENTRY[variable] = checkbox
		$TPICK_TABLE_SIZE[table] += 1 if x_pos == 1
	end
        
	Gtk.queue {
		$TPICK_WINDOW.signal_connect("delete_event") {
			$TPICK_SETUP_COMPLETED = true
		}
	}
        
	Gtk.queue {

		label = Gtk::Label.new
		label.set_markup("Enter the FULL name of your lockpicks above, NOT including the words 'a' or 'an'.  If you don't have a particular lockpick use the next best lockpick.\nFor example if you don't have a steel lockpick then put the name of your gold lockpick in both the steel and gold lockpick variables.\nYou can enter multiple lockpicks of the same kind by separating them with a comma.\nFor example if you have two copper lockpicks you can enter the following in the Copper Lockpick setting: dark red copper lockpick,red tinted copper lockpick.\nNote no space after the comma.")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$TPICK_TABLE1.attach(align, 1, 2, 8, 9)

		label = Gtk::Label.new
		label.set_markup("Enter the FULL name of your lockpicks above, NOT including the words 'a' or 'an'.  If you don't have a particular lockpick use the next best lockpick.\nFor example if you don't have a steel lockpick then put the name of your gold lockpick in both the steel and gold lockpick variables.\nYou can enter multiple lockpicks of the same kind by separating them with a comma.\nFor example if you have two copper lockpicks you can enter the following in the Copper Lockpick setting: dark red copper lockpick,red tinted copper lockpick.\nNote no space after the comma.")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$TPICK_TABLE2.attach(align, 1, 2, 8, 9)

		label = Gtk::Label.new
		label.set_markup("Enter the FULL name of your container above where items can be found and will be stored, DON'T include the starting words of 'a' or 'an'.\n<b>Broken Lockpick Container:</b>  Container where script will store your broken lockpicks.\n<b>Locksmith's Container:</b>  Container where putty and cotton balls are found.\n<b>Containers to open at start:</b> Enter full names of every container you want opened when script starts, separated by a comma. Example: blue heavy backpack, black soft fur cloak\n<b>Containers to close before exit:</b> Same as above but for closing containers before script exits.\n<b>Other containers:</b> List all other item names/item types and the containers you want them to go into. Separate the names/types and containers by \":\" and separate each of these by a comma.\nExample: gem: sack, diamond: soft brown cloak, silver wand: ebony pack\nNote you can use either the full name of a container or just the noun, but if you are wearing more than one of a particular container (like two sacks) be sure to use full names.\nNames will be matched before types. Example if you have: \"gem: pack, diamond: cloak\" then all diamonds will be put into your cloak and all other gems will be put into your pack.\nAny Lich item types will work, here are the more common ones: herb, gem, armor, weapon, reagent, jewelry, uncommon, scroll, clothing, collectible, cursed, wand\nThis setting is completely optional. If you leave it blank the script will STOW everything other than your lockpicks, wedges, etc.")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$TPICK_TABLE3.attach(align, 1, 2, 8, 100)

		label = Gtk::Label.new
		label.set_markup("<b>Auto deposit silvers:</b> Enter <b>yes</b> to auto deposit silvers when encumbered and picking pool boxes or ground picking and looting.\n<b>Gnomish Bracer:</b>  Enter name and tier of your gnomish bracer (example: bracer,1), <b>nil</b> if none.\n<b>Gnomish Bracer:</b> Entering <b>,override</b> (for example: bracer,1,override) at the end will only use bracers for disarming and will use <b>lockpick container</b> setting to find and store lockpicks.\n<b>Bashing Weapon:</b>  Name of weapon to use for bashing boxes, <b>nil</b> if none.\n<b>Scale Trap Weapon:</b>  FULL name of weapon you use for disarming scale traps, not including 'a' or 'an'.\n<b>Remove armor:</b> Enter the name of your armor if you want script to remove your armor before casting a spell, script will automatically wear armor again before it exists.\n<b>Max Lock:</b> The highest lock you are willing to attempt (any locks higher than this will be wedged/popped or skipped). Enter 10000 to attempt all locks.\nDoing something like <b>-100</b> would instead only attempt locks that are at most 100 lower than your max skill with a vaalin lockpick.\n<b>Max Lock Roll:</b>  For example enter <b>30</b> and when you roll lower than 30 when picking locks the script will attempt to pick again no matter what messaging you received.\nEnter <b>0</b> or leave blank if you want script to always move to higher lockpicks when receiving a message that you aren't able to pick the current lock with the current lockpick.\nThe messages this setting is for is when you bend your lockpick, the script will always move to higher lockpick if you break your lockpick.\n<b>Trap Roll:</b>  Determines what difficulty boxes you want to attempt.\nSet to 0 to never try anything higher than your total disarm skill + lore bonus.\nSetting to 10 would attempt traps 10 points higher than your disarm skill + lore bonus.\nSetting to -10 would only attempt traps that are a maximum of 10 points lower than your disarm skill + lore bonus.\nSet this value to whatever number you want. A value of 1000 would attempt to disarm all traps.\nScript will always use 404 if it determines you need the spell to disarm a trap.")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$TPICK_TABLE4.attach(align, 1, 2, 8, 9)

		label = Gtk::Label.new
		label.set_markup("<b>Trick:</b>  Trick to use when picking locks. Enter: spin, twist, turn, twirl, toss, bend or flip.  Enter <b>pick</b> if you don't want to use a trick.\nEnter <b>random</b> to use a random trick each time you pick a box, ONLY USE THIS IF YOU KNOW ALL THE TRICKS.\n<b>Log:</b>  Enter <b>yes</b> to display a summary of all loot found when done.\n<b>Trash boxes:</b>  Enter <b>yes</b> to dispose of empty boxes if possible, <b>no</b> will drop them on the ground, <b>save</b> STOWS empty boxes.\n<b>Calibrate on startup:</b>  <b>yes</b> to calibrate your calipers when the script is started, <b>no</b> to skip calibrating, <b>never</b> to never use calipers/loresinging and default use a vaalin lockpick (use this if you have fewer than 40 ranks in lock mastery).\n<b>Calibrate Count:</b>  Will calibrate your calipers every time you pick this many boxes. (enter 999 to never calibrate)\nAnother option: Example: Enter \"auto 50\" for script to calibrate your calipers as soon as it notices your calipers readings are 50+ off from an actual lock difficulty.\n<b>Auto Bundle Vials:</b> Enter <b>yes</b> to have script bundle vials you get from disarming traps into your locksmith's container.\n<b>Auto repair bent lockpicks:</b>  Enter <b>yes</b> to have script automatically repair lockpicks after they have been bent. Only works if you have learned lmas repair.\n<b>Number of times to check for traps:</b>  How many times you want script to manually check for traps.")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$TPICK_TABLE5.attach(align, 1, 2, 8, 9)
		
		label = Gtk::Label.new
		label.set_markup("<b>Lock Roll:</b>  Maximum roll allowed before moving to a higher lockpick.\nExample if this value is 50 and you roll a 60 and didn't pick the lock the script will move to the next lockpick. 50 is a good starting number.\n<b>Vaalin Lock Roll:</b>  Same as above but just for vaalin picks if you want to attempt to pick locks with a higher needed roll than other lockpicks. 80 is a good starting number.\n<b>This number should be equal or higher than Lock Roll.</b>\nSet to 1000 to always try picking a lock with a vaalin lockpick before moving on to a wedge or 407.\n<b>Lock Buffer</b>  Example: Enter 50 and the script will add +50 to lock difficulty from all caliper readings, just in case your caliper readings aren't 100% accurate.\n<b>Keep trying if within abilities:</b>  Enter <b>yes</b> to have script keep trying current lockpick if you receive messaging indicating you can pick the lock with your current lockpick.\n<b>Run silently:</b> Enter <b>yes</b> to not see most calculations feedback while script is running, important feedback will still be shown.\n<b>IMPORTANT:</b> If you run into any bugs or issues it is best to see all feedback and provide a log to Dreaven so he can more easily find the problem.")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$TPICK_TABLE6.attach(align, 1, 2, 8, 9)

		label = Gtk::Label.new
		label.set_markup("Enter <b>yes</b> for any spells you want to keep on while disarming/picking, <b>no</b> for any spells you don't want to cast.\nIf 403 and 404 are set to <b>no</b> the script will cast the spells when needed (after a failure or for a very high lock) and if you know the spell.\nSet 403 and 404 to <b>cancel</b> if you want these spells stopped when starting on a new box.\nSet 403 to <b>never</b> to NEVER use 403.\nSet 403 or 404 to a number (like 100) to always use 403/404 if the lock/trap difficulty is above this number.\nYou can do something like <b>100,cancel</b> (note no spaces) if you still want to cancel 403/404 when starting a new box.\nIf <b>407</b> is set to <b>plate</b> the script will attempt to open plated boxes (except mithril or enruned) with 407 if you have no acid vials or wedges.\nIf <b>407</b> is set to <b>all</b> the script will attempt to open all boxes (except mithril and enruned) with 407.\nEnter <b>plate, 50</b> or <b>all, 50</b> if you want to use 407 until you reach 50% of your maximum mana, then script will give up and move on. 50 can be any percent mana you want.\nEnter <b>no</b> for <b>407</b> to skip using 407 on boxes.\n<b>1035:</b>  Script will not wait until you have enough mana to cast 1035, it will cast if you have enough mana or move on if you don't.\n<b>Percent mana to keep:</b>  For example enter <b>50</b> if you want to stop casting spells once your current mana reaches 50% or less than your max mana.\nLeave blank to always cast spells as long as you have enough mana.")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$TPICK_TABLE7.attach(align, 1, 2, 8, 100)

		label = Gtk::Label.new
		label.set_markup("<b>Use Vaalin when Fried:</b>  Enter <b>yes</b> to always use vaalin if you're fried.\n<b>Rest at Percent:</b>  Script will pause when your mind reaches this amount or higher.  Enter <b>200</b> to never rest.\n<b>Pick at Percent:</b>  Will start picking when your mind reaches this amount or lower.  Enter <b>100</b> to always pick.\nDoes not work when using OTHER command line.\nUse the following amounts\nmust rest:  100\nnumbed:  90\nbecoming numbed:  75\nmuddled:  62\nclear:  50\nfresh and clear:  25\nclear as a bell:  0")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$TPICK_TABLE8.attach(align, 1, 2, 8, 9)

		label = Gtk::Label.new
		label.set_markup("Enter <b>nil</b> for any option where you don't want to speak.\n<b>Ready:</b>  What to say when ready to be handed boxes from another person. Example: <b>Ready.</b>\n<b>Can't Open Box:</b>  What to say when you can't open a box for another person. Example: <b>Sorry can't open this box.</b>\n<b>Scarab Found:</b>  What to say before you disarm a scarab trap. Example: <b>Scarab coming down.</b>\n<b>Scarab Safe:</b> What to say after you have disarmed the scarab. For example: <b>Scarab safe.</b>")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$TPICK_TABLE9.attach(align, 1, 2, 8, 9)

		label = Gtk::Label.new
		label.set_markup("<b>Phase (704):</b>  Enter <b>yes</b> to use Phase (704) on each box to check for glyph traps, <b>no</b> to skip Phase.\n<b>Number of 416 casts:</b>  Number of times you want to check a box for traps using Piercing Gaze (416).\n<b>Only disarm safe:</b>  Some traps can be bypassed altogether when using 407 to open the box and some traps are always safe to use 408 on.\nHowever some traps have a chance of being set off when using 408. \nEnter <b>yes</b> here to skip boxes with traps that are not 100% safe, <b>no</b> to attempt disarming them with 408.\nSome traps are never safe to use 408 on and the script will always skip these boxes no matter what value you enter here.")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$TPICK_TABLE10.attach(align, 1, 2, 8, 9)
		
		label = Gtk::Label.new
		label.set_markup("<b>These options are only for pool/worker boxes.</b>\n<b>Max critter level:</b>  Maximum critter level of boxes you will work on, higher level boxes will be turned in. Enter <b>1000</b> to work on all boxes.\n<b>Minimum tip wanted:</b>  Example: enter 1000, 40, 500 script would start asking for 1000+ silver jobs, when none are available it would subtract 40 and start asking for 960+ silver jobs.\nIt would keep doing this until it reached 500 silvers, at which point it would start over again at 1000. Another example: Enter 200 to always ask for 200+ jobs. Enter <b>0</b> to work on all boxes.\n<b>Use 403 based on critter level:</b>  Example: Enter 80 to always use 403 on boxes which come from critters level 80+\n<b>Use 404 based on critter level:</b>  Same as above but with 404.\n<b>Rest when fried:</b>  Example enter <b>112</b> if you want script to move you to room number 112 when you're fried, enter <b>112:go table</b> if you want script to move you to room number 112 then GO TABLE.\nScript will move you back to pool room when your mind reaches the level you specify in the <b>Pick at Percent</b> setting under the <b>Experience</b> tab.\nNote this setting doesn't go by when you're fried but rather when you receive messaging from the pool worker that you can't do anymore boxes until you let your mind clear out a bit.\n<b>The below setting works by default for non-rogues/bards. If you are a rogue/bard this setting only works if you use 'v' command line variable or you have set 'Calibrate on startup' to 'never.'</b>\n<b>Picks to use based on critter level:</b>  Below is an example of how to use this setting:\n10 copper, 20 steel, 30 gold, 50 lage, 75 invar, 90 kelyn\nThis would use your copper lockpick for critters up to level 10, steel for critters up to 20, etc.\nVaalin is used for any levels not specified, in the above example that would be for critters 91+.\n<b>DO NOT</b> use the names of your lockpicks, use the lockpick type, use the below list as a reference:\ncopper, steel, gold, silver, mithril, ora, glaes, laje, vultite, rolaren, veniom, invar, alum, golvern, kelyn, vaalin\n<b>Leave this blank if you don't want to use this feature.</b>")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$TPICK_TABLE11.attach(align, 1, 2, 8, 9)

		$TPICK_WINDOW.show_all
	}
        
	$TPICK_SETUP_COMPLETED = false
	until($TPICK_SETUP_COMPLETED)
		sleep 1
	end
	
	UserVars.tpick ||= Hash.new
	$TPICK_ENTRY.keys.each { |key|
		if( $TPICK_ENTRY[key].class.to_s =~ /CheckButton/ )
			value = $TPICK_ENTRY[key].active?
			UserVars.tpick[key] = $TPICK_ENTRY[key].active?
		else
			UserVars.tpick[key] = $TPICK_ENTRY[key].text.strip.downcase
		end
	}

	UserVars.save()
        
	Gtk.queue {
		$TPICK_WINDOW.destroy
	}
}

check_locksmiths_container = proc{
	action = proc { |server_string|
		if server_string =~ /lump of squishy white putty with about (\d+) pinch|(\d+) little ball|(\d+) vials? of liquid|you see a pinch of squishy white putty/
			if server_string =~ /you see a lump of squishy white putty with about (\d+) pinch/
				putty_remaining = $1.to_i
			elsif server_string =~ /you see a pinch of squishy white putty/
				putty_remaining = 1
			else 
				putty_remaining = 0
			end
			if server_string =~ /(\d+) little ball/
				cotton_remaining = $1.to_i
			else
				cotton_remaining = 0
			end
			if server_string =~ /(\d+) vials? of liquid/
				vials_remaining = $1.to_i
			else
				vials_remaining = 0
			end
			DownstreamHook.remove("#{script.name}_check_locksmiths_container")
			nil
		elsif server_string =~ / and /
			(putty_remaining = 0) unless (putty_remaining)
			(cotton_remaining = 0) unless (cotton_remaining)
			(vials_remaining = 0) unless (vials_remaining)
			DownstreamHook.remove("#{script.name}_check_locksmiths_container")
			server_string
		else
			server_string
		end
	}
		DownstreamHook.add("#{script.name}_check_locksmiths_container", action)
		silence_me
		if running? "sorter"
			kill_script "sorter"
			wait_until { !running? "sorter" }
			start_sorter = true
		end
		fput "look in ##{@tpick_locksmiths_container.id}"
		silence_me
}

tpick_gather_the_loot = proc{
	waitrt?
	if current_item.name !~ /urglaes fang|doomstone/ && current_item.type != "box"
		gather_stuff.call
	end
	waitrt?
	if current_item.name !~ /coins/i && UserVars.tpick["log"] == "yes"
		record_item_data.call
	end
	if current_item.name !~ /urglaes fang|doomstone|coins/ && current_item.type != "box"
		tpick_bundle_vials.call if UserVars.tpick["auto_bundle_vials"] == "yes" && current_item.name =~ /vial/ && (GameObj.right_hand.name =~ /vial/ || GameObj.left_hand.name =~ /vial/)
		tpick_put_stuff_away
	end
	waitrt?
}

ask_worker = proc{
	waitrt?
	result = dothistimeout "ask ##{worker.id} to check", 3, /If you want to give up\, ASK me to CHECK it again within 30 seconds\.\"|\"That\'s some quality work\.  Here\'s your payment of (.*) silvers\.\"|You aren\'t working on a job\.|Too tough for ya\, eh\?/
	if result =~ /\"That\'s some quality work\.  Here\'s your payment of (.*) silvers\.\"/
		CharSettings["total_silvers_earned_from_pool_picking"] += $1.delete(",").to_i
		silvers_earned_from_pool_picking_this_session += $1.delete(",").to_i
		CharSettings["number_of_total_boxes_picked_pool_picking"] += 1
		number_of_boxes_picked_this_session_pool_picking += 1
	elsif result =~ /If you want to give up\, ASK me to CHECK it again within 30 seconds\.\"|You aren\'t working on a job\.|Too tough for ya\, eh\?/
		nil
	elsif result.nil?
		echo "Didn't recognize game line I was looking for, trying again."
		ask_worker.call
	end
}

open_current_plinite = proc{
	tpick_put_stuff_away
	waitrt?
	fput "pluck ##{current_box.id}"
	@tpick_stow_current_box = true
	tpick_put_stuff_away
}

start_plinites = proc{
	$tpick_list_of_box_ids.each{ |plinite|
		tpick_put_stuff_away
		plinite_already_open = nil
		cannot_determine_plinite_difficulty = nil
		until GameObj.right_hand.id == plinite || GameObj.left_hand.id == plinite
			waitrt?
			fput "get ##{plinite}"
			sleep 0.2
		end
		current_box = GameObj.right_hand if GameObj.right_hand.name =~ /plinite/
		current_box = GameObj.left_hand if GameObj.left_hand.name =~ /plinite/
		@tpick_current_box = current_box
		detect_plinite.call
	}
}

tpick_bundle_vials = proc{
	check_locksmiths_container.call
	wait_until { vials_remaining }
	start_script "sorter" if start_sorter
	if vials_remaining < 10
		if GameObj.right_hand.name =~ /vial/
			current_vial = GameObj.right_hand.id
		elsif GameObj.left_hand.name =~ /vial/
			current_vial = GameObj.left_hand.id
		end
		tpick_stow_box(current_box) if (solo_or_other == "solo" || solo_or_other == "other")
		tpick_put_stuff_away
		wait_until { checkright.nil? && checkleft.nil? }
		fput "remove ##{@tpick_locksmiths_container.id}"
		wait_until { checkright }
		fput "get ##{current_vial}"
		wait_until { checkleft }
		fput "bundle"
		fput "wear ##{@tpick_locksmiths_container.id}"
		wait_until { checkright.nil? }
		if solo_or_other == "solo" || solo_or_other == "other"	
			tpick_get_box(current_box)
			wait_until { checkright }
		end
	end
}

detect_plinite_result = proc{
	waitrt?
	plinite_already_open = nil
	(tpick_cast_spells (404)) if (use_spell_404) || (need_404)
	result = dothistimeout "detect ##{current_box.id}", 3, /It looks like it would be.*\(\-(\d+)\)\.|You struggle to determine the difficulty of the extraction \(somewhere between .* and \-(\d+)\)\.|You promptly discover that the core has already been removed\.|You are unable to determine the difficulty of the extraction\.|You promptly discover that the core has already been extracted and merely needs to be PLUCKed from the tip of the shard\./
	if result =~ /It looks like it would be.*\(\-(\d+)\)\./ || result =~ /You struggle to determine the difficulty of the extraction \(somewhere between .* and \-(\d+)\)\./
		lock = $1.to_i
	elsif result =~ /You promptly discover that the core has already been removed\./
		echo "This plinite has already been extracted."
		tpick_put_stuff_away
		plinite_already_open = true
	elsif result =~ /You are unable to determine the difficulty of the extraction\./
		cannot_determine_plinite_difficulty = true
		lock = 1000000
	elsif result =~ /You promptly discover that the core has already been extracted and merely needs to be PLUCKed from the tip of the shard\./
		open_current_plinite.call unless solo_or_other == "worker"
		plinite_already_open = true
	elsif result.nil?
		detect_plinite_result.call
	end
}

detect_plinite = proc{
	i_need_403 = nil
	need_404 = "yes" unless UserVars.tpick["always_use_404"] == "never"
	waitrt?
	3.times{
		waitrt?
		unless GameObj.right_hand.id == $vaalin_lockpick_id || GameObj.left_hand.id == $vaalin_lockpick_id
			fput "get ##{$vaalin_lockpick_id}"
			sleep 0.2
		end
	}
	if GameObj.right_hand.id != $vaalin_lockpick_id && GameObj.left_hand.id != $vaalin_lockpick_id
		echo "Couldn't find your #{UserVars.tpick["vaalin"]}."
		exit
	end
	detect_plinite_result.call
	tpick_put_stuff_away
	if plinite_already_open == nil
		total_pick_skill = (pick_skill + pick_lore) * 2.50
		if lock > (total_pick_skill + UserVars.tpick["vaalin_lock_roll"].to_i)
			if solo_or_other == "worker"
				echo "Can't extract this plinite based on my calculations. If you think this is in error increase the Vaalin Lock Roll setting in the setup menu."
				cannot_determine_plinite_difficulty = nil
				ask_worker.call
			else
				echo "Can't extract this plinite, OPENing it instead. If you think this is in error increase the Vaalin Lock Roll setting in the setup menu."
				cannot_determine_plinite_difficulty = nil
				waitrt?
				fput "open ##{current_box.id}"
			end
		else
			number = 0
			pick_mod.each do |i|
				total_pick_skill = (pick_skill + pick_lore)
				if (total_pick_skill) * 2.50 - lock + UserVars.tpick["lock_roll"].to_i < 100 || cannot_determine_plinite_difficulty
					needed_pick = UserVars.tpick["vaalin"]
					needed_pick_id = vaalin_lock_pick_array.first
					need_403 = "yes" unless UserVars.tpick["always_use_403"] == "never"
					need_404 = "yes" unless UserVars.tpick["always_use_404"] == "never"
					i_need_403 = true unless UserVars.tpick["always_use_403"] == "never"
					number = 15
					break
				else
					total_pick_skill = (pick_skill) * i
					if total_pick_skill - lock + UserVars.tpick["lock_roll"].to_i < 100
						number += 1
						unless UserVars.tpick["always_use_403"] == "never"
							i_need_403 = true if number > 14
						end
					else
						break
					end
				end
				if use_403_for_lock_difficulty && Spell[403].known? && lock > use_403_for_lock_difficulty
					i_need_403 = true
				end
			end
			if i_need_403
				number = 0
				need_403 = "yes" unless UserVars.tpick["always_use_403"] == "never"
				need_404 = "yes" unless UserVars.tpick["always_use_404"] == "never"
				pick_mod.each do |i|
					total_pick_skill = (pick_skill + pick_lore) * i
					if total_pick_skill - lock + UserVars.tpick["lock_roll"].to_i < 100
						number += 1
					else
						break
					end
				end
			end
			number = [15, number].min
			if number == 0
				recommended_pick = "copper"
			elsif number == 1
				recommended_pick = "steel"
			elsif number == 2
				recommended_pick = "gold"
			elsif number == 3
				recommended_pick = "silver"
			elsif number == 4
				recommended_pick = "mithril"
			elsif number == 5
				recommended_pick = "ora"
			elsif number == 6
				recommended_pick = "glaes"
			elsif number == 7
				recommended_pick = "laje"
			elsif number == 8
				recommended_pick = "vultite"
			elsif number == 9
				recommended_pick = "rolaren"
			elsif number == 10
				recommended_pick = "veniom"
			elsif number == 11
				recommended_pick = "invar"
			elsif number == 12
				recommended_pick = "alum"
			elsif number == 13
				recommended_pick = "golvern"
			elsif number == 14
				recommended_pick = "kelyn"
			elsif number > 14
				recommended_pick = "vaalin"
			end
			lock_pick_information.call
			echo "Recommended lock pick: #{recommended_pick} with a modifier of #{recommended_pick_modifier}" if UserVars.tpick["run_silently"] !~ /yes/i
			if need_403 == "yes"
				if use_403_for_lock_difficulty && Spell[403].known? && lock > use_403_for_lock_difficulty
					echo "Lock difficulty is higher than your 403 setting in setup menu, using 403." if UserVars.tpick["run_silently"] !~ /yes/i
				else
					echo "Recommend 403: Yes" if UserVars.tpick["run_silently"] !~ /yes/i
				end
				echo "Your calculated lockpicking skill: #{pick_skill}" if UserVars.tpick["run_silently"] !~ /yes/i
				echo "Your calculated lockpicking lore: #{pick_lore}" if UserVars.tpick["run_silently"] !~ /yes/i
				temp_math_number = pick_skill + pick_lore
			else
				echo "Recommend 403: No" if UserVars.tpick["run_silently"] !~ /yes/i
				echo "Your calculated lockpicking skill: #{pick_skill}" if UserVars.tpick["run_silently"] !~ /yes/i
				temp_math_number = pick_skill
			end
			quick_maths = (temp_math_number * recommended_pick_modifier).truncate
			echo "Your total picking skill for this attempt is: #{quick_maths}" if UserVars.tpick["run_silently"] !~ /yes/i
			echo "Lock difficulty: #{lock}" if UserVars.tpick["run_silently"] !~ /yes/i
			if needed_pick_id.nil?
				if recommended_pick == "vaalin"
					5.times{ echo "ALL OF YOUR VAALIN LOCKPICKS ARE BROKEN. YOU REALLY SHOULD HAVE AT LEAST 1 WORKING VAALIN LOCKPICK WHEN RUNNING THIS SCRIPT." }
					exit
				else
					echo "All of your #{recommended_pick} lockpicks seem to be broken, trying a higher tier lockpick."
				end
				nextpick.call
			else
				pick2.call
			end
		end
	elsif plinite_already_open
		ask_worker.call if solo_or_other == "worker"
	end
}

pop_start = proc{
	$tpick_list_of_box_ids.each{ |box|
		current_box = box
		@tpick_current_box = current_box
		pop_boxes_begin.call
	}
	check_disk.call
}

cast_704_at_box = proc{
	waitrt?
	waitcastrt?
	tpick_prep_spell(704, "Phase")
	result = dothistimeout "cast at ##{current_box.id}", 3, /resists the effects of your magic|appears lighter|then stabilizes|but quickly returns to normal|Roundtime/
	if result =~ /resists the effects of your magic/
		echo "Box has a glyph trap and cannot be opened."
		tpick_drop_box(current_box) if solo_or_other == "ground"
		where_to_stow_box.call if solo_or_other == "solo"
		box_opened = nil
	elsif result =~ /appears lighter|then stabilizes|but quickly returns to normal|Roundtime/
		echo "Box has no glyph trap. Checking for other traps."
		tpick_drop_box(current_box)
		tpick_get_box(current_box) if solo_or_other != "ground"
		check_for_trap.call
	elsif result.nil?
		cast_704_at_box.call
	end
}

pop_boxes_begin = proc{
	tpick_put_stuff_away
	until checkright
		fput "get ##{current_box}"
		sleep 0.2
	end
	current_box = GameObj.right_hand
	@tpick_current_box = current_box
	start_time = Time.now
	remaining_416_casts = UserVars.tpick["number_of_416_casts"].to_i
	stuff_to_do.call
	check_for_command = "glance"
	check_hands_status = nil
	check_for_boxes.call
	wait_until { check_hands_status }
	if check_hands_status == "mithril or enruned"
		echo "Can't open this box because it is mithril or enruned."
		waitrt?
		tpick_drop_box(current_box) if solo_or_other == "ground"
		where_to_stow_box.call if solo_or_other == "solo"
		box_opened = nil
	elsif check_hands_status == "empty"
		echo "No box was found in your hands."
		exit
	else
		if use_spell_704
			cast_704_at_box.call
		else
			echo "Checking for traps." if UserVars.tpick["run_silently"] !~ /yes/i
			tpick_drop_box(current_box) if solo_or_other == "ground"
			check_for_trap.call
		end
	end
}

where_to_stow_box = proc{
	if solo_or_other == "solo"
		if stow_in_disk
			fput "put ##{current_box.id} in #{checkname} disk"
		else
			tpick_stow_box(current_box)
		end
	end
}

gnomish_bracers_trap_check_result = proc{
	waitrt?
	result = dothistimeout "rub my #{gnomish_bracers}", 3, /begins to glow with a deep red light|begins to glow with a bright green light/
	if result =~ /begins to glow with a deep red light/
		waitrt?
		manually_disarm_trap.call
	elsif result =~ /begins to glow with a bright green light/
		waitrt?
		if (disarm_only)
			if (bash_open_boxes)
				bash_the_box_open.call
			else
				box_counts_for_math = nil
				tpick_drop_box(current_box)
			end
		else
			measure.call
		end
	elsif result.nil?
		gnomish_bracers_trap_check_result.call
	end
}

gnomish_bracers_trap_check = proc{
	if solo_or_other != "ground" && solo_or_other != "worker"
		wait_until { GameObj.right_hand.id != nil}
		current_box = GameObj.right_hand
		@tpick_current_box = current_box
	end
	tpick_get_box(current_box) if solo_or_other == "ground"
	if solo_or_other == "worker" && current_box.nil?
		until current_box
			dothistimeout "look on ##{table.id}", 3, /^On the/
			table.contents.each{ |item|
				if item.name =~ /#{checkname}/
					current_box = item
					@tpick_current_box = current_box
					break
				end
			}
			if current_box.nil?
				table.contents.each{ |item|
					fput "tap ##{item.id}"
					while line = get
						if line =~ /^You probably shouldn\'t do that\./
							break
						elsif line =~ /^You tap/
							current_box = item
							@tpick_current_box = current_box
							break
						end
					end
					break if current_box
				}
			end
			sleep 1
		end
		echo "Found your box/plinite! Name: #{current_box}, ID: #{current_box.id}, tip: #{offered_tip_amount}, critter name: #{critter_name}, critter level: #{critter_level}"
	end
	gnomish_bracers_trap_check_result.call
}

check_for_trap = proc{
	tpick_cast_spells (402)
	tpick_cast_spells (404)
	current_trap_type = nil
	tpick_prep_spell(416, "Piercing Gaze")
	fput "cast at ##{current_box.id}"
	while line = get
		if line =~ /Peering closely into the lock\, you spy an? [a-zA-Z]+ (.*) scarab wedged into the lock mechanism\./
			scarab_name = $1
			current_trap_type = "scarab"
			CharSettings['scarab'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /You notice what appears to be a sharp sliver of metal nestled in a hole next to the lock plate\./
			current_trap_type = "needle"
			CharSettings['needle'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /You notice a discolored oval ring around the outside of the.*which makes you suspicious\.\s+Your suspicions are confirmed when you look inside the keyhole and notice the spring\-loaded jaws pressed flush against the.*walls\./
			current_trap_type = "jaws"
			CharSettings['jaws'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /You see a tiny sphere imbedded in the lock mechanism\./
			current_trap_type = "sphere"
			CharSettings['sphere'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /You can see a small crystal imbedded in the locking mechanism\./
			current_trap_type = "crystal"
			CharSettings['crystal'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /You see a cord stretched between the lid and case\./
			current_trap_type = "scales"
			CharSettings['scales'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /Peering through the .*\, you notice that the lock casing is coated with a rough\, grainy substance\, and a small bladder is wedged between the tumblers of the lock\./
			current_trap_type = "sulphur"
			CharSettings['sulphur'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /Looking closely into the keyhole of the lock\, you spy a small vial of liquid and a tiny hammer device which seems poised to shatter it if the lock is tampered with\./
			current_trap_type = "cloud"
			CharSettings['cloud'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /You notice what appears to be a tiny vial placed just past the tumblers of the lock mechanism\.\s+It appears that any tampering with the lock mechanism will cause the tumblers to crush the vial\./
			current_trap_type = "acid vial"
			CharSettings['acid_vial'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /Peering through the .*\, you notice that the hinges have some springs incorporated into the design in an unusual fashion\./
			current_trap_type = "springs"
			CharSettings['springs'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /Looking closely into the keyhole of the lock\, you spy a small vial of fire\-red liquid and a tiny hammer device which seems poised to shatter it if the lock is tampered with\./
			current_trap_type = "fire vial"
			CharSettings['fire_vial'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /You see a thin tube extending from the lock mechanism down into the .*\.\s+The tube appears to be filled with a greenish powder\./
			current_trap_type = "spores"
			CharSettings['spores'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /There appears to be a plate over the lock\, sealing it and preventing any access to the tumblers\./
			current_trap_type = "plate"
			CharSettings['plate'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /Near the lock mechanism\, you notice a pair of small metal rods a hair\'s width from rubbing together\./
			current_trap_type = "rods"
			CharSettings['rods'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /The inside chamber is lined with some unidentifiable substance\./
			current_trap_type = "boomer"
			CharSettings['boomer'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /You gaze at the.*but your vision is obscured\./
			current_trap_type = "check again"
		elsif line =~ /Suddenly a dark splotch erupts from the lock mechanism and envelops you\!  Time seems to slow down and almost stop\.\.\./
			current_trap_type = "glyph"
			CharSettings['glyph'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /Roundtime/
			break
		end
	end
	if current_trap_type != "check again" && current_trap_type != nil
		echo "Found a #{current_trap_type} trap." if UserVars.tpick["run_silently"] !~ /yes/i
	end
	if current_trap_type == "check again"
		echo "Failed detecting a trap, trying again."
		check_for_trap.call
	elsif current_trap_type == "needle" || current_trap_type == "jaws" || current_trap_type == "plate"
		echo "Trap is safe to skip disarming."
		pop_open_box.call
	elsif current_trap_type == "crystal" || current_trap_type == "springs"
		echo "Trap is safe to use 408 on. Must be disarmed before popping."
		disarm_trap.call
	elsif current_trap_type == "scarab" || current_trap_type == "sphere" || current_trap_type == "scales" || current_trap_type == "acid vial" || current_trap_type == "fire vial" || current_trap_type == "spores" || current_trap_type == "boomer" || current_trap_type == "cloud" || current_trap_type == "rods"
		echo "408 might set off trap. Must be disarmed before popping."
		if UserVars.tpick["only_disarm_safe"] == "yes"
			echo "Skipping box due to tpick setting Only disarm safe is set to yes."
			where_to_stow_box.call
			box_opened = nil
		else
			disarm_trap.call
		end
	elsif current_trap_type == "sulphur"
		echo "Skipping box because 408 will set this trap off."
		where_to_stow_box.call
		box_opened = nil
	elsif current_trap_type == "glyph"
		echo "The box had a glyph trap on it. Taking you back to the room you started in."
		while checkroom =~ /Temporal Rift/
			move 'e'
			sleep 0.1
		end
		sleep 0.5
		start_script "go2", [starting_room]
		wait_while{ running?('go2') }
		echo "This box has a glyph trap and cannot be opened."
		where_to_stow_box.call
		box_opened = nil
	elsif current_trap_type == nil
		echo "No trap found." if UserVars.tpick["run_silently"] !~ /yes/i
		remaining_416_casts -= 1
		if remaining_416_casts < 1
			CharSettings['no_trap'] += 1
			CharSettings['total_trap_count'] += 1
			pop_open_box.call
		else
			echo "416 casts remaining: #{remaining_416_casts}."
			check_for_trap.call
		end
	end
}

fused_lock_disarm = proc{
	if Char.prof == 'Rogue'
		echo "Going to try wedging this box open."
		wedge_lock.call
	elsif Char.prof != 'Rogue' and !Spell[407].known?
		echo "Can't open this box."
		if solo_or_other == "solo"
			where_to_stow_box.call
		elsif solo_or_other == "other"
			tpick_say_cant
			open_others.call
		elsif solo_or_other == "ground"
			cant_open_plated_box_count += 1
			box_opened = nil
		elsif solo_or_other == "worker"
			nil
		end
	elsif Char.prof != 'Rogue' and Spell[407].known?
		tpick_get_box(current_box) if solo_or_other == "ground"
		echo "Going to try popping this box."
		cast_407.call
	end
}

pop_open_box = proc{
	box_is_open = nil
	echo "Popping box."
	loop{
		tpick_cast_spells (403) unless UserVars.tpick["always_use_403"] == "never"
		tpick_prep_spell(407, "Unlock")
		fput "cast at ##{current_box.id}"
		waitrt?
		while line = get
			if line =~ /The.*vibrates slightly but nothing else happens\.|Suddenly\, part of the.*face breaks away and a pair of gleaming jaws snap shut before the lockplate\!\s+Good thing your hand wasn\'t there\!|Roundtime/
				break
			elsif line =~ /You hear a soft click from the.*and it suddenly flies open\.|But the.*is already open\./
				box_is_open = true
				break
			end
		end
		break if box_is_open
	}
	open_solo.call if solo_or_other != "ground"
}

disarm_trap = proc{
	box_is_disarmed = nil
	loop{
		tpick_cast_spells (402)
		tpick_cast_spells (404)
		tpick_prep_spell(408, "Disarm")
		fput "cast at ##{current_box.id}"
		while line = get
			if line =~ /Now to isolate the offending mechanism and disable it\.\.\.The.*vibrates slightly but nothing else happens\.|You begin to probe the.*for unusual mechanisms\.\.\.The.*vibrates slightly but nothing else happens\./
				echo "Couldn't disarm trap. Tryin again."
				break
			elsif line =~ /Now to isolate the offending mechanism and disable it\.\.\.Your heart skips a beat as you hear a small sizzle from the.*keyhole\..*You begin to jump back\, but not in time as the entire.*explodes in a deafening\, fiery detonation\!/
				echo "The trap was set off! Script is now exiting."
				exit
			elsif line =~ /Now to isolate the offending mechanism and disable it\.\.\.The.*pulses once with a deep crimson light\!/
				box_is_disarmed = true
				echo "Box is disarmed."
				break
			end
		end
		break if box_is_disarmed
	}
	pop_open_box.call
}

fill_up_locksmith_container = proc{
	move 'out' if checkpaths 'out'
	start_script 'go2', [ 'bank', '--disable-confirm' ]
	wait_while{ running?('go2') }
	fput "unhide" if hidden?
	fput "depo all"
	fput "withdraw 1000"
	start_script 'go2', [ Room[Room.current.find_nearest_by_tag('locksmith')], '--disable-confirm' ]
	wait_while{ running?('go2') }
	waitrt?
	fput "order"
	while line = get
		if line =~ /\d+.*\s{2}(\d+).*locksmith\'s/
			order_number = $1
		elsif line =~ /(\d+).*locksmith\'s/
			order_number = $1
		end
		break if line =~ /You can APPRAISE/
	end
	tpick_put_stuff_away
	wait_until { checkright.nil? && checkleft.nil? }
	until checkright
		waitrt?
		fput "remove ##{@tpick_locksmiths_container.id}"
		sleep 0.2
	end
	buy_locksmith_pouch.call
	if putty_remaining < 50 || cotton_remaining < 50
		buy_locksmith_pouch.call
	end
	fput "wear ##{@tpick_locksmiths_container.id}"	
}

buy_locksmith_pouch = proc{
	fput "order #{order_number}"
	fput "buy"
	wait_until { checkleft }
	fput "open ##{GameObj.left_hand.id}"
	fput "bundle"
	trash_container = GameObj.loot.find { |trash| trash.name =~ trash_container }
	current_box = GameObj.left_hand
	@tpick_current_box = current_box
	if trash_container == nil
		tpick_drop_box(current_box)
	else
		fput "put ##{GameObj.left_hand.id} in #{trash_container}"
		sleep 0.2
		tpick_drop_box(current_box) if checkleft
	end
}

do_relock_boxes = proc{
	waitrt?
	tpick_get_box(current_box) if solo_or_other == "ground"
	fput "get ##{$vaalin_lockpick_id}"
	fput "close ##{current_box.id}"
	fput "lm relock ##{current_box.id}"
	tpick_drop_box(current_box) if solo_or_other == "ground"
	tpick_put_stuff_away
}

cast_407 = proc{
	if use_unlock_407_settings[1]
		stop_trying_to_use_407 = nil
		if checkmana < maxmana * (use_unlock_407_settings[1].to_i / 100.0)
			echo "According to your 407 settings your mana is too low to continue trying to open this box with 407."
			stop_trying_to_use_407 = true
		end
	end
	if current_box.name =~ /enruned|mithril/i || box_is_enruned_or_mithril || use_unlock_407_settings[0] =~ /no/i || stop_trying_to_use_407
		echo "Can't open this plated box because it is mithril or enruned or because your settings are set to not use 407 to open boxes." unless stop_trying_to_use_407
		if solo_or_other == "solo"
			where_to_stow_box.call
			tpick_put_stuff_away
			sleep 0.1
		elsif solo_or_other == "other"
			tpick_say_cant
			open_others.call
		elsif solo_or_other == "ground"
			tpick_drop_box(current_box)
			cant_open_plated_box_count += 1
			box_opened = nil
		elsif solo_or_other == "worker"
			ask_worker.call
		end
	else
		if checkmana < 10
			echo "Waiting for mana."
			wait_until { checkmana >= 10 }
		end
		tpick_cast_spells (403) unless UserVars.tpick["always_use_403"] == "never"
		tpick_prep_spell(407, "Unlock")
		result = dothistimeout "cast ##{current_box.id}", 4, /vibrates slightly but nothing else happens.|(suddenly flies open.|is already open.)/i
		if result =~ /(suddenly flies open.|is already open.)/i
			if solo_or_other == "solo"
				open_solo.call
			elsif solo_or_other == "other"
				open_others.call
			elsif solo_or_other == "ground"
				tpick_drop_box(current_box)
			elsif solo_or_other == "worker"
				nil
			end
		elsif result =~ /vibrates slightly but nothing else happens./i || result.nil?
			cast_407.call
		end
	end
}

wedge_lock = proc{
	waitrt?
	tpick_get_box(current_box) if solo_or_other == "ground" && checkright == nil
	if Char.prof == 'Rogue'
		3.times{
			waitrt?
			unless GameObj.right_hand.name =~ /wedge/ || GameObj.left_hand.name =~ /wedge/
				fput "get my wedge"
				sleep 0.2
			end
		}
	end
	if GameObj.right_hand.name !~ /wedge/ && GameObj.left_hand.name !~ /wedge/
		if use_unlock_407_settings[0] =~ /no/i or !Spell[407].known?
			if solo_or_other == "other"
				tpick_say_cant
				open_others.call
			elsif solo_or_other == "ground"
				echo "Couldn't open this box."
				box_opened = nil
			elsif solo_or_other == "solo"
				echo "Couldn't open this box."
				where_to_stow_box.call
				tpick_put_stuff_away
				sleep 0.1
			elsif solo_or_other == "worker"
				echo "Couldn't open this box."
				ask_worker.call
			end
		else
			if Char.prof == 'Rogue'
				echo "Couldn't find any wedges, going to try popping this box."
			else
				echo "Going to try popping this box."
			end
			cast_407.call
		end
	else
		result = dothistimeout "lmaster wedge ##{current_box.id}", 3, /What do you expect to wedge it with|(suddenly splits away from the casing|Why bother)|Roundtime/i
		if result =~ /What do you expect to wedge it with/i
			tpick_put_stuff_away
			wedge_lock.call
		elsif result =~ /(suddenly splits away from the casing|Why bother)/i
			tpick_put_stuff_away
			open_solo.call if solo_or_other == "solo"
			open_others.call if solo_or_other == "other"
			tpick_drop_box(current_box) if solo_or_other == "ground"
		elsif result =~ /Roundtime/i || result.nil?
			wedge_lock.call
		end
	end
}

calibrate = proc{
	echo "Calibrating calipers." if UserVars.tpick["run_silently"] !~ /yes/i
	3.times{
		waitrt?
		unless GameObj.right_hand.name =~ /calipers/ || GameObj.left_hand.name =~ /calipers/
			fput "get my calipers"
			sleep 0.2
		end
	}
	if GameObj.right_hand.name !~ /calipers/ && GameObj.left_hand.name !~ /calipers/
		echo "Couldn't find your calipers."
		exit
	end
	result = dothistimeout "lmas calibrate my calipers", 4, /You\'re good\, but you\'re not that good\.|You should leave them alone.|Roundtime/i
	if result =~ /You\'re good\, but you\'re not that good\.|You should leave them alone./i
		tpick_put_stuff_away
	elsif result =~ /Roundtime/i
		waitrt?
		calibrate.call if can_use_calipers
	elsif result.nil?
		calibrate.call
	end
}

check_for_lockpicks_etc = proc {
	action = proc { |server_string|
		if server_string =~ /\s{2}.*(an?|the|some) |\s{6}.*(an?|the|some) |^You are currently wearing and carrying\:/
			if server_string =~ /\<a exist\=\"(\d+)" noun\=\".*\"\>(.*)\<\/a\>/
				temp_id = $1
				temp_name = $2
				copper_lock_pick_array.push(temp_id) if temp_copper_lockpicks_array.include?(temp_name)
				steel_lock_pick_array.push(temp_id) if temp_steel_lockpicks_array.include?(temp_name)
				gold_lock_pick_array.push(temp_id) if temp_gold_lockpicks_array.include?(temp_name)
				silver_lock_pick_array.push(temp_id) if temp_silver_lockpicks_array.include?(temp_name)
				mithril_lock_pick_array.push(temp_id) if temp_mithril_lockpicks_array.include?(temp_name)
				ora_lock_pick_array.push(temp_id) if temp_ora_lockpicks_array.include?(temp_name)
				glaes_lock_pick_array.push(temp_id) if temp_glaes_lockpicks_array.include?(temp_name)
				laje_lock_pick_array.push(temp_id) if temp_laje_lockpicks_array.include?(temp_name)
				vultite_lock_pick_array.push(temp_id) if temp_vultite_lockpicks_array.include?(temp_name)
				rolaren_lock_pick_array.push(temp_id) if temp_rolaren_lockpicks_array.include?(temp_name)
				veniom_lock_pick_array.push(temp_id) if temp_veniom_lockpicks_array.include?(temp_name)
				invar_lock_pick_array.push(temp_id) if temp_invar_lockpicks_array.include?(temp_name)
				alum_lock_pick_array.push(temp_id) if temp_alum_lockpicks_array.include?(temp_name)
				golvern_lock_pick_array.push(temp_id) if temp_golvern_lockpicks_array.include?(temp_name)
				kelyn_lock_pick_array.push(temp_id) if temp_kelyn_lockpicks_array.include?(temp_name)
				vaalin_lock_pick_array.push(temp_id) if temp_vaalin_lockpicks_array.include?(temp_name)
				$scale_trap_weapon_id = temp_id if temp_name =~ /^#{UserVars.tpick["scale_trap_weapon"]}$/
			end
			nil
		elsif server_string =~ /^\(\d+ items? displayed\.\)/
			DownstreamHook.remove("#{script.name}_check_for_lockpicks_etc")
			$tpick_boxes_checked = true
			nil
		else
			server_string
		end
	}
		DownstreamHook.add("#{script.name}_check_for_lockpicks_etc", action)
		silence_me
		fput "inv full"
		silence_me
}

check_for_boxes = proc {
	action = proc { |server_string|
		if server_string =~ /\s{6}.*(an?|the|some) |\s{2}.*(an?|the|some) |^You are currently wearing and carrying\:/
			if (server_string =~ /(\s{6}.*(an?|the|some)|\s{2}.*(an?|the|some)).*exist="(\d+)".*(plinite)/) && (open_plinites)
				$tpick_list_of_box_ids.push($4)
			elsif (server_string =~ /(?:\s{6}.*(?:an?|the|some)|\s{2}.*(?:an?|the|some)).*exist="(\d+)" noun\=\".*\"\>#{all_box_full_names}\<\/a\>/) && (open_plinites.nil?)
				$tpick_list_of_box_ids.push($1)
			end
			nil
		elsif server_string =~ /^\(\d+ items? displayed\.\)/
			DownstreamHook.remove("#{script.name}_check_for_boxes")
			$tpick_boxes_checked = true
			nil
		elsif server_string =~ /You glance down to see.*mithril|enruned.*/
			check_hands_status = "mithril or enruned"
			DownstreamHook.remove("#{script.name}_check_for_boxes")
			nil
		elsif server_string =~ /You glance down.*left hand.*/
			check_hands_status = "good"
			DownstreamHook.remove("#{script.name}_check_for_boxes")
			nil
		elsif server_string =~ /You glance down at your empty hands\./
			check_hands_status = "empty"
			DownstreamHook.remove("#{script.name}_check_for_boxes")
			nil
		else
			server_string
		end
	}
		DownstreamHook.add("#{script.name}_check_for_boxes", action)
		silence_me
		fput "#{check_for_command}"
		silence_me
}

cast_205 = proc{
	if checkmana < 5
		echo "Waiting for mana."
		wait_until { checkmana(5) }
	end
	tpick_stow_armor
	Spell[205].cast
}

stuff_to_do = proc{
	if (UserVars.tpick["rest_percent"].to_i <= percentmind) && (UserVars.tpick["rest_percent"].length > 0)
		echo "Resting until mind reaches #{UserVars.tpick["pick_percent"]}%."
		wait_until { UserVars.tpick["pick_percent"].to_i >= percentmind }
	end
}

start_values_nilled = proc{
	scale_trap_found = nil
	current_trap_type = nil
	time_to_disarm_trap = nil
	found_true_lock_difficulty = nil
}

start_solo = proc{
	total_boxes_count.call
	$tpick_list_of_box_ids.each{ |box|
		tpick_stop_403_404
		fput "get ##{box}"
		start_time = Time.now
		critter_name = nil
		start_values_nilled.call
		stuff_to_do.call
		number_of_manual_trap_checks_remaining = UserVars.tpick["number_of_times_to_check_for_traps"].to_i
		if (gnomish_bracers) && (bracers_tier == "2")
			gnomish_bracers_trap_check.call
		else
			manually_disarm_trap.call
		end
	}
	check_disk.call
}

encumbrance_check = proc{
	if percentencumbrance > 99
		starting_room_number = Room.current.id
		start_script 'go2', [ 'bank', '--disable-confirm' ]
		wait_while{ running?('go2') }
		fput "depo all"
		start_script "go2", [starting_room_number]
		wait_while{ running?('go2') }
	end
}

start_worker = proc{
	tpick_put_stuff_away
	stuff_to_do.call
	current_box = nil
	@tpick_current_box = current_box
	waitrt?
	if worker.nil?
		echo "Get yourself to a worker who assigns you box jobs."
		exit
	end
	encumbrance_check.call if UserVars.tpick["auto_deposit_silvers"] =~ /yes/i
	offered_tip_amount = nil
	if minimum_tip_current > 0
		fput "ask ##{worker.id} for job minimum #{minimum_tip_current}"
	else
		fput "ask ##{worker.id} for job"
	end
	while line = get
		if line =~ /says\, \"You should finish the job you\'re working on first\.  If you\'re done\, ask me to CHECK it for you\.\"/
			next_task = nil
			break
		elsif line =~ /says\, \"Ah\, here we are\.  The client is offering a tip of (.*) silvers? and mentioned it being from [a-zA-Z]+ (.*) \(level (\d+)\)\./
			offered_tip_amount = $1.delete(",").to_i	
			critter_name = $2
			critter_level = $3.to_i
			next_task = nil
			break
		elsif line =~ /says\, \"Ah\, here we are\.  The client is offering a tip of (.*) silvers? and they aren't sure where it came from/
			offered_tip_amount = $1.delete(",").to_i	
			critter_level = 1
			next_task = nil
			break
		elsif line =~ /says\, \"You\'ve done enough boxes for now\.  Why don\'t you ask me again a few minutes from now\.\"/
			next_task = "2 minutes"
			break
		elsif line =~ /says\, \"You\'ve done enough for a while\.  Why don\'t you rest your mind a bit\?\"/
			next_task = "rest"
			break
		elsif line =~ /says\, \"You\'ve done enough boxes for now\.  Why don\'t you ask me again about a minute from now\.\"/
			next_task = "minute"
			break
		elsif line =~ /says\, \"What\, you think we have a job already\?  Wait a bit longer before asking again\.\"/
			next_task = "11 seconds"
			break
		elsif line =~ /says\, \"We don't have any jobs for you at the moment\./ || line =~ /says\, \"You haven\'t quite reflected on your past failure\.|says\, \"You\'ve done enough/
			next_task = "wait"
			break
		end
	end
	if next_task == "wait"
		if minimum_tip_start && minimum_tip_subtract
			if minimum_tip_current > minimum_tip_floor
				echo "No boxes at your current minimum rate. Lowering minimum tip wanted and trying again in 10 seconds."
				minimum_tip_current -= minimum_tip_subtract
				minimum_tip_current = [minimum_tip_current, minimum_tip_floor].max
				sleep 11
				time_to_subtract_from_actual_picking_time += 11
				start_worker.call
			else
				minimum_tip_current = minimum_tip_start
				echo "No boxes at your lowest minimum rate. Starting over again in 30 seconds."
				sleep 30
				time_to_subtract_from_actual_picking_time += 30
				start_worker.call
			end
		else
			echo "No boxes available at the moment, waiting 30 seconds and trying again."
			sleep 30
			time_to_subtract_from_actual_picking_time += 30
			start_worker.call
		end
	elsif next_task == "minute"
		echo "No boxes available at the moment, waiting 60 seconds and trying again."
		sleep 60
		time_to_subtract_from_actual_picking_time += 60
		start_worker.call
	elsif next_task == "2 minutes"
		echo "No boxes available at the moment, waiting 120 seconds and trying again."
		sleep 120
		time_to_subtract_from_actual_picking_time += 120
		start_worker.call
	elsif next_task == "rest"
		if pool_picking_fried_commands
			pool_fried_start_time = Time.now
			echo "Worker isn't assigning you boxes because your mind is too full. Running your resting routine then coming back to pick more boxes when your mind reaches #{UserVars.tpick["pick_percent"]}%."
			starting_pool_room_number = Room.current.id
			start_script "go2", [pool_picking_fried_commands[0]]
			wait_while { running? "go2" }
			fput "#{pool_picking_fried_commands[1]}" if pool_picking_fried_commands[1]
			echo "Resting until mind reaches #{UserVars.tpick["pick_percent"]}%."
			wait_until { UserVars.tpick["pick_percent"].to_i >= percentmind }
			echo "Mind cleared out! Heading back to pick more boxes!"
			start_script "go2", [starting_pool_room_number]
			wait_while { running? "go2" }
			time_to_subtract_from_actual_picking_time += (Time.now - pool_fried_start_time)
		else
			echo "Worker isn't assigning you boxes because your mind is too full. Waiting 120 seconds before asking again."
			sleep 120
			time_to_subtract_from_actual_picking_time += 120
		end
		start_worker.call
	elsif next_task == "11 seconds"
		echo "No boxes available at the moment, waiting 10 seconds and trying again."
		sleep 11
		time_to_subtract_from_actual_picking_time += 11
		start_worker.call
	else
		start_worker2.call
	end
}
	
start_worker2 = proc{
	if critter_level > max_critter_level
		echo "Critter level too high, turning in box."
		ask_worker.call
		ask_worker.call
		start_worker.call
	else
		tpick_stop_403_404
		start_values_nilled.call
		number_of_manual_trap_checks_remaining = UserVars.tpick["number_of_times_to_check_for_traps"].to_i
		if (gnomish_bracers) && (bracers_tier == "2")
			gnomish_bracers_trap_check.call
		else
			manually_disarm_trap.call
		end
		ask_worker.call
		start_worker.call
	end
}

start_others = proc{
	waitfor "has accepted your offer" if checkright != nil
	waitrt?
	fput "accept"
	while line = get
		if line =~ /^You accept ([a-zA-Z]+)\'s offer and are now holding.*\.$/i || line =~ /^([a-zA-Z]+) offers you (.*) #{all_box_types}\.  Click ACCEPT to accept the offer or DECLINE to decline it.  The offer will expire in 30 seconds\.$/
			person = $1
			fput "accept" if line =~ /^([a-zA-Z]+) offers you (.*) #{all_box_types}\.  Click ACCEPT to accept the offer or DECLINE to decline it.  The offer will expire in 30 seconds\.$/
			start_time = Time.now
			tpick_stop_403_404
			critter_name = nil
			start_values_nilled.call
			number_of_manual_trap_checks_remaining = UserVars.tpick["number_of_times_to_check_for_traps"].to_i
			if (gnomish_bracers) && (bracers_tier == "2")
				gnomish_bracers_trap_check.call
			else
				manually_disarm_trap.call
			end
			break
		end
	end
}

total_boxes_count = proc{
	total_boxes_number = 0
	if solo_or_other == "ground"
		GameObj.loot.each { |item|
			(total_boxes_number += 1) if (item.type == "box" && !all_box_ids_already_picked.include?(item.id))
		}
	elsif solo_or_other == "solo"
		total_boxes_number = $tpick_list_of_box_ids.length
		unless disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk|coffin/ }
			echo "Waiting 4 seconds for disk"
			40.times { break if GameObj.loot.any? { |obj| obj.name =~ /#{Char.name} disk|coffin/ }; sleep 0.1 }
				disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk|coffin/ }
			end
		(echo "No disk found.") if (disk == nil)
		already_checked_for_disk = true
		if (disk) && (disk.contents.nil?)
			dothistimeout "look in ##{disk.id}", 3, /In the|There is nothing in/
		end
		disk.contents.each{|item|
			if item.type =~ /box/i
				total_boxes_number += 1
			end
		}
	end
	total_boxes_picked_math.call
}

bash_the_box_open = proc{
	echo "Bashing open box."
	waitrt?
	result = dothistimeout "open ##{current_box.id}", 3, /That is already open\.|You open|It appears to be locked\./i
	if result =~ /That is already open\.|You open/
		box_counts_for_math = nil
		box_was_not_locked = true
	elsif result =~ /It appears to be locked\./ 
		fput "get my #{UserVars.tpick["bashing_weapon"]}"
		until current_box.status == "gone"
			waitrt?
			fput "bash ##{current_box.id}"
			waitrt?
			sleep 0.2
		end
	elsif result.nil?
		bash_the_box_open.call
	end	
}

coins_from_boxes_comma_nonsense = proc{
	if total_silvers_from_box < 625
		sleep 0.1
	else
		while line = get
			if line =~ /Roundtime\: (\d+) sec/
				sleep ($1.to_i + 1)
				break
			end
		end									
	end
	waitrt?
}

gather_stuff = proc{
	waitrt?
	if current_item.name =~ /coins/
		finished_getting_coins = nil
		loop{
			break if finished_getting_coins
			fput "get ##{current_item.id}"
			while line = get
				if line =~ /You gather the remaining (.*) coins?/
					total_silvers_from_box = $1.delete(",").to_i
					coins_from_boxes_comma_nonsense.call
					finished_getting_coins = true
					break
				elsif line =~ /^You can only collect (.*) of the coins due to your load\./
					total_silvers_from_box = $1.delete(",").to_i
					echo "You can't carry anymore silvers!"
					coins_from_boxes_comma_nonsense.call
					finished_getting_coins = true
					break
				elsif line =~ /^You cannot hold any more silvers\./
					echo "You can't carry anymore silvers!"
					finished_getting_coins = true
					break
				elsif line =~ /^You gather (.*) of the coins?/
					total_silvers_from_box = $1.delete(",").to_i
					coins_from_boxes_comma_nonsense.call
					break
				end
			end
		}
	else
		if picking_up
			tpick_put_stuff_away
		else
			fput "get ##{current_item.id}"
		end
	end
}

start_ground = proc{
	total_boxes_count.call
	GameObj.loot.each{ |box|
		if box.type =~ /box/ && !all_box_ids_already_picked.include?(box.id)
			all_box_ids_already_picked.push(box.id) unless all_box_ids_already_picked.include?(box.id)
			box_opened = true
			current_box = box
			@tpick_current_box = current_box
			tpick_stop_403_404
			if (UserVars.tpick["rest_percent"].to_i <= percentmind) && (UserVars.tpick["rest_percent"].length > 0)
				echo "Resting until mind reaches #{UserVars.tpick["pick_percent"]}%."
				wait_until { UserVars.tpick["pick_percent"].to_i >= percentmind }
			end
			waitrt?
			box_was_not_locked = nil
			start_time = Time.now
			critter_name = nil
			start_values_nilled.call
			number_of_manual_trap_checks_remaining = UserVars.tpick["number_of_times_to_check_for_traps"].to_i
			if popping
				@tpick_current_box = current_box
				current_box = current_box.id
				pop_boxes_begin.call
			elsif bash_open_boxes
				if disarm_only
					if (gnomish_bracers) && (bracers_tier == "2")
						gnomish_bracers_trap_check.call
					else
						manually_disarm_trap.call
					end
				else
					bash_the_box_open.call
				end
			else
				if (gnomish_bracers) && (bracers_tier == "2")
					gnomish_bracers_trap_check.call
				else
					manually_disarm_trap.call
				end
			end
			update_math_information = true
			total_boxes_picked_math.call
			if ground_loot
				encumbrance_check.call if UserVars.tpick["auto_deposit_silvers"] =~ /yes/i
				if (bash_open_boxes) && (box_was_not_locked.nil?)
					GameObj.loot.each{ |item|
						current_item = item
						tpick_gather_the_loot.call
					}
				elsif (box_opened) || (box_was_not_locked)
					waitrt?
					(tpick_cast_spells (1035)) if (use_spell_1035)
					total_boxes_picked += 1
					fput "open ##{current_box.id}" unless popping
					(dothistimeout "look in ##{box.id}", 10, /In .*? you see|In the .*\:|There is nothing in/i) if box.contents.nil?
					box.contents.each{ |item|
						current_item = item
						tpick_gather_the_loot.call
					}
					if relock_boxes
						do_relock_boxes.call
					end
					garbage_check.call
				end
			else
				if popping
					nil
				else
					fput "open ##{current_box.id}" if (box_opened) && (disarm_only == nil)
					fput "drop ##{current_box.id}" if GameObj.right_hand.id == current_box.id
				end
			end
			tpick_put_stuff_away
		end
	}
	if check_all_ground_boxes_again
		check_all_ground_boxes_again = nil
		echo "Checking for boxes I might have missed."
		start_ground.call
	else
		echo "All done!"
		echo "Couldn't open #{cant_open_plated_box_count} box(es), which are still on the ground." if cant_open_plated_box_count > 0
		exit
	end
}

check_disk = proc{
	stow_in_disk = true
	unless disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk|coffin/ }
		if already_checked_for_disk.nil?
			echo "Waiting 4 seconds for disk"
			40.times { break if GameObj.loot.any? { |obj| obj.name =~ /#{Char.name} disk|coffin/ }; sleep 0.1 }
				disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk|coffin/ }
			end
		end
	if disk == nil
		echo "No disk found." if already_checked_for_disk.nil?
		exit
	end
	if disk and disk.contents.nil?
		dothistimeout "look in ##{disk.id}", 3, /In the|There is nothing in/
	end
	disk.contents.each{|item|
		if item.type =~ /box/i
			waitrt?
			if popping
				current_box = item.id
				@tpick_current_box = item
				pop_boxes_begin.call
			else
				fput "get ##{item.id}"
				start_time = Time.now
				critter_name = nil
				start_values_nilled.call
				number_of_manual_trap_checks_remaining = UserVars.tpick["number_of_times_to_check_for_traps"].to_i
				if (gnomish_bracers) && (bracers_tier == "2")
					gnomish_bracers_trap_check.call
				else
					manually_disarm_trap.call
				end
			end
		end
	}
}

count_boxes_in_disk = proc{
	stow_in_disk = true
	unless disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk|coffin/ }
		echo "Waiting 4 seconds for disk"
		40.times { break if GameObj.loot.any? { |obj| obj.name =~ /#{Char.name} disk|coffin/ }; sleep 0.1 }
			disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk|coffin/ }
		end
	if disk and disk.contents.nil?
		dothistimeout "look in ##{disk.id}", 3, /In the|There is nothing in/
	end
	disk.contents.each{|item|
		if item.type =~ /box/i
			total_number_of_boxes += 1
			$tpick_list_of_box_ids.push(item.id)
		end
	}
}

manually_disarm_trap = proc{
	waitrt?
	if solo_or_other == "worker" && current_box.nil?
		until current_box
			dothistimeout "look on ##{table.id}", 3, /^On the/
			table.contents.each{ |item|
				if item.name =~ /#{checkname}/
					current_box = item
					@tpick_current_box = current_box
					break
				end
			}
			if current_box.nil?
				table.contents.each{ |item|
					fput "tap ##{item.id}"
					while line = get
						if line =~ /^You probably shouldn\'t do that\./
							break
						elsif line =~ /^You tap/
							current_box = item
							@tpick_current_box = current_box
							break
						end
					end
					break if current_box
				}
			end
			sleep 1
		end
		echo "Found your box/plinite! Name: #{current_box}, ID: #{current_box.id}, tip: #{offered_tip_amount}, critter name: #{critter_name}, critter level: #{critter_level}"
	end
	if current_box.name =~ /plinite/
		detect_plinite.call
	else
		if time_to_disarm_trap
			echo "Attempting to disarm trap." if UserVars.tpick["run_silently"] !~ /yes/i
		else
			echo "Checking for traps." if UserVars.tpick["run_silently"] !~ /yes/i
			need_403 = nil
			need_404 = nil
		end
		if (current_trap_type == "sphere") || (current_trap_type == "Sphere trap found, need to use lockpick to disarm.")
			3.times{
				waitrt?
				unless GameObj.right_hand.id == $vaalin_lockpick_id || GameObj.left_hand.id == $vaalin_lockpick_id
					fput "get ##{$vaalin_lockpick_id}"
					sleep 0.2
				end
			}
			if GameObj.right_hand.id != $vaalin_lockpick_id && GameObj.left_hand.id != $vaalin_lockpick_id
				echo "Couldn't find your #{UserVars.tpick["vaalin"]}."
				exit
			end
		end
		waitrt?
		if UserVars.tpick["use_404_based_on_critter_level"] =~ /\d+/ && need_404.nil?
			if critter_level.nil?
				echo "Critter level unknown, using 404 based on your settings."
				need_404 = "yes"
			else
				if UserVars.tpick["use_404_based_on_critter_level"].to_i <= critter_level
					echo "Critter level is #{critter_level}, using 404 based on your settings."
					need_404 = "yes"
				end
			end
		end
		(tpick_cast_spells (402)) if (use_spell_402)
		(tpick_cast_spells (404)) if (use_spell_404) || (need_404)
		(tpick_cast_spells (613)) if (use_spell_613)
		(tpick_cast_spells (1006)) if (use_spell_1006)
		(tpick_cast_spells (1035)) if (use_spell_1035)
		trap_difficulty = nil
		trap_cant_be_disarmed = nil
		if solo_or_other != "ground" && solo_or_other != "worker"
			wait_until { GameObj.right_hand.id}
			current_box = GameObj.right_hand
			@tpick_current_box = current_box
		end
		waitrt?
		sleep 1
		waitrt?
		sleep 0.3
		waitrt?
		sleep 0.1
		waitrt?
		if current_trap_type == "scarab"
			all_scarab_ids = Array.new
			GameObj.loot.each{ |i|
				all_scarab_ids.push(i.id) if i.noun == "scarab"
			}
		end
		tpick_say_scarab_found if current_trap_type == "scarab"
		if time_to_disarm_trap
			fput "disarm ##{current_box.id}"
		else
			fput "detect ##{current_box.id}"
		end
		while line = get
			if line =~ /\(.*\-(\d+)\)\./
				trap_difficulty = $1.to_i
				disarm_skill_plus_lore = (disarm_skill + disarm_lore)
				total_trap_skill = (disarm_skill + disarm_lore + UserVars.tpick["trap_roll"].to_i)
				if time_to_disarm_trap.nil?
					echo "Trap difficulty is: #{trap_difficulty}" if UserVars.tpick["run_silently"] !~ /yes/i
					echo "Your disarm skill is: #{disarm_skill}" if UserVars.tpick["run_silently"] !~ /yes/i
					echo "Your total disarm skill with lore is: #{disarm_skill_plus_lore}" if UserVars.tpick["run_silently"] !~ /yes/i
					echo "Highest trap you are willing to try is: #{total_trap_skill}" if UserVars.tpick["run_silently"] !~ /yes/i
				end
				if trap_difficulty > total_trap_skill
					trap_cant_be_disarmed = true
				elsif use_404_for_trap_difficulty && Spell[404].known?
					if trap_difficulty > use_404_for_trap_difficulty
						if time_to_disarm_trap.nil?
							echo "Trap difficulty is higher than your setting in the setup menu for when to use Disarm Enhancement (404), going to use Disarm Enhancement (404)." if UserVars.tpick["run_silently"] !~ /yes/i
						end
						need_404 = "yes"
					end
				elsif trap_difficulty > disarm_skill && Spell[404].known?
					if time_to_disarm_trap.nil?
						echo "This trap looks tough, going to use Disarm Enhancement (404)." if UserVars.tpick["run_silently"] !~ /yes/i
					end
					need_404 = "yes"
				elsif trap_difficulty > disarm_skill && !Spell[404].known?
					trap_cant_be_disarmed = true
				end
	#####Is box enruned or mithril?
			elsif line =~ /You carefully begin to examine (.*) for traps\.\.\./
				box_is_enruned_or_mithril = nil
				box_is_enruned_or_mithril = true if $1 =~ /enruned|mithril/
	#####Failed to disarm box
			elsif line =~ /Having discovered a trap on the.*#{all_box_types} you begin to carefully attempt to disarm it\.\.\./
				current_trap_type = "Couldn't disarm trap, trying again." if UserVars.tpick["run_silently"] !~ /yes/i
	#####Scarab information#####
			#Manual detection
			elsif line =~ /Peering closely into the lock\, you spy an? [a-zA-Z]+ (.*) scarab wedged into the lock mechanism\./
				scarab_name = $1
				CharSettings['scarab'] += 1
				CharSettings['total_trap_count'] += 1
				current_trap_type = "scarab"
			#Successful manual disarm
			elsif line =~ /You carefully nudge the scarab free of its prison without disturbing the lock too much\.\s+The scarab falls from the lock and onto the ground in front of you\./
				current_trap_type = "Scarab trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /The lock appears to be free of all obstructions\./
				current_trap_type = "Scarab trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /Looking closely at the lock\, you spy.*scarab wedged into the lock mechanism\.\s+The scarab is surrounded by crimson glow\./
				current_trap_type = "Scarab trap has already been disarmed with 408."
				break
	#####Needle information#####
			#Manual detection
			elsif line =~ /Hmmm\, you can see what appears to be a tiny hole next to the lock plate which doesn\'t seem to belong there\.\s+Looking closer you see a gleaming sliver of metal recessed in the hole\./
				current_trap_type = "needle"
				CharSettings['needle'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /Using a bit of putty from your.*\, you manage to block the tiny hole in the lock plate\.|Using a pair of metal grips\, you carefully remove .* from .* and cover the tip with a bit of putty\./
				current_trap_type = "Needle trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /You see a tiny hole next to the lock plate which has been completely plugged\.|You can see what appears to be a tiny hole next to the lock plate which doesn\'t seem to belong there\.  However\, nothing about it seems to indicate cause for alarm\.|You spot a shiny metal needle sticking out of a small hole next to the lockplate with some sort of dark paste on it\./
				current_trap_type = "Needle trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /You can see what appears to be a tiny hole next to the lock plate which doesn\'t belong there\.\s+An occasional glint of red winks at you from within the hole\./
				current_trap_type = "Needle trap has already been disarmed with 408."
				break
	#####Jaws information#####
			#Manual detection
			elsif line =~ /You notice a discolored oval ring around the outside of the .*#{all_box_types} which makes you suspicious\.\s+Your suspicions are confirmed when you look inside the keyhole and notice the spring\-loaded jaws pressed flush against the .*#{all_box_types} walls\./
				current_trap_type = "jaws"
				CharSettings['jaws'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /Using the pair of metal grips\, you manage to pull out the two pins that hold the upper and lower jaw pieces together\.\s+As the pins are removed\, the jaws suddenly close and warp under the tremendous strain applied by their arming mechanism\.|Using the pair of metal grips\, you manage to pull out the two pins that hold the upper and lower jaw pieces together\.|Using your metal grips\, you carefully remove a pair of small steel jaws from the .*#{all_box_types} before piecing the apparatus back together\./
				current_trap_type = "Jaws trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /You notice a discolored oval ring around the outside of the .#{all_box_types} which makes you suspicious\.\s+Your suspicions are confirmed when you look inside the keyhole and notice the spring\-loaded jaws pressed flush against the.*walls\, but the pins that hold the jaws together have been pushed out\.|You notice a discolored oval ring around the outside of the .*\, but further examination gives the impression that some vital part of whatever trap was here has been removed\./
				current_trap_type = "Jaws trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /You see a pair of metal jaws clamped tightly before the lockplate on the.*#{all_box_types}\.|The jaws are surrounded with a reddish glow\./
				current_trap_type = "Jaws trap has already been disarmed with 408. Can't pick it."
				break
			#Trap has already been set off
			elsif line =~ /You see a pair of bloody jaws clamped tightly before the lockplate on the/
				current_trap_type = "Jaws trap has already been set off."
				break
	#####Sphere information#####
			#Manual detection
			elsif line =~ /Examining the .*#{all_box_types}\, you locate.*sphere held in a metal bracket towards the back of the lock mechanism\..*It appears that were the tumblers to be activated\, the gem would be caught amongst them\./
				current_trap_type = "sphere"
				CharSettings['sphere'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /With utmost care\, you slip your.* into the lock and gently nudge the.*Another moment of prodding\, and you are able to poke the gem free of its metal housing\, whereupon it falls down into the lock mechanism and out of sight\.|With utmost care\, you slip your.* into the lock and gently nudge the.*Tilting the .*#{all_box_types} forward\, you knock the gem free of its metal housing and poke it out through the back of the lock\, allowing it to gently roll down the inside of the .*#{all_box_types}\'s front wall\./
				current_trap_type = "Sphere trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /A thorough search of the area inside the tumblers reveals what appears to be a metal bracket of some sort\, although it seems to be empty now\./
				current_trap_type = "Sphere trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /The sphere is surrounded by a crimson glow\./
				current_trap_type = "Sphere trap has already been disarmed with 408."
				break
			#Need pick in hand messaging
			elsif line =~ /No matter how you try\, your fingers are just too big to get back there to the gem\.\s+You\'ll need some sort of thin\, rigid implement like a lockpick\./
				current_trap_type = "Sphere trap found, need to use lockpick to disarm."
			#Setting off trap manually
			elsif line =~ /Suddenly\, you hear a sound like shattered crystal and .* light flashes from the lock mechanism\!/
				current_trap_type = "Sphere trap has been set off."
				echo "Sphere trap has been set off! Exiting."
				exit
			#Trap has already been set off
			elsif line =~ /A thorough and careful search of the lock mechanism indicates that the entire .* is MANGLED\. It\'s probably not trapped anymore\./
				current_trap_type = "Sphere trap has already been set off."
				break
	#####Crystal information#####
			#Manual detection
			elsif line =~ /Looking closely into the keyhole of the lock\, you spy.*crystal which seems imbedded in the locking mechanism\.\s+It looks as if opening the lock without the exact key could shatter it\./
				current_trap_type = "crystal"
				CharSettings['crystal'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /With a little ingenuity you manage to grind down parts of the lock mechanism with your metal file\, so it won\'t come in contact with the crystal when you try to open it\./
				current_trap_type = "Crystal trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /Looking closely into the keyhole of the lock\, you spy.*crystal which seems imbedded in the locking mechanism\.\s+It looks as if opening the lock without the exact key could shatter it\, but parts of the mechanism have been ground away to avoid unwanted contact with the crystal\./
				current_trap_type = "Crystal trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /You can see.*crystal imbedded in the locking mechanism\, with a slight reddish glow about it\./
				current_trap_type = "Crystal trap has already been disarmed with 408."
				break
	#####Scales information#####
			#Manual detection
			elsif line =~ /At first glance\, the.*#{all_box_types} appears to be covered with hundreds of tiny metal scales\.\s+Closer examination reveals the \"scales\" to be razor sharp at the edges and possessing of a downward\-facing needlelike tip\.\s+However\, you should be able to avoid cutting yourself if you are careful\.|Despite heavy scrutiny\, you can see no way to pry off any of the scales\, nor any particular reason to\.\s+With a modicum of caution\, they should present no danger\.\s+Nothing else about the.*#{all_box_types} suggests that it is trapped\./
				current_trap_type = "scales"
				CharSettings['scales'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /You gently slide your.*into the space under the lid and slice through the cord\.\s+That oughta do it\./
				current_trap_type = "Scales trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /Peering in through the crack between the lid and the casing\, you see what appears to be a thin cord dangling from the case\.\s+It looks to have been sliced through\./
				current_trap_type = "Scales trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /A crimson glow seeps between the lid and the casing of the .*#{all_box_types}\./
				current_trap_type = "Scales trap has already been disarmed with 408."
				break
			#Need dagger in hand messaging
			elsif line =~ /You figure that if you had a dagger\, you could probably cut the cord\./
				current_trap_type = "Scales trap found, need to use dagger to disarm."
				break
	#####Sulphur information#####
			#Manual detection
			elsif line =~ /Feeling around the inside of the lock\, you notice that the casing is coated with a rough\, grainy substance\.\s+You lean forward and peer between the walls of the casing\.\s+Examining the lock closely\, you notice a small bladder filled with a strange liquid wedged between the tumblers\.\s+With your face this close to the lock\, you pick up the faintest scent of sulphur\./
				current_trap_type = "sulphur"
				CharSettings['sulphur'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /You carefully use the tip of a small metal file to scrape away the rough\, grainy substance which lines the walls of the casing\.\s+After a few moments\, you feel comfortable with the small section you have cleaned\.\s+You take out a thin needle and carefully slide it between the walls of the casing\, taking great care not to touch them\.\s+As the tip of the needle punctures the small bladder\, a strange clear gel oozes forth from the hole\.\s+The gel gives off a strong odor of sulphur\.\s+As the air hits the gel\, it begins to harden and turn to dust\, blowing away in the wind as if it never existed\./
				current_trap_type = "Sulphur trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /Feeling around the inside of the lock\, you notice that the casing is coated with a rough\, grainy substance\.\s+A small section of the casing has been scraped clean of the strange substance\.\s+You lean forward and peer between the walls of the casing\.\s+Examining the lock closely\, you notice a deflated bladder wedged between the tumblers\.\s+There is a small hole in the bladder\, most likely from whatever ruptured it\.\s+The lock emanates a strong scent of sulphur\./
				current_trap_type = "Sulphur trap has already been disarmed."
				break
			#Already disarmed with 408
			#TRAP CANNOT BE DISARMED WITH 408
	#####Cloud information#####
			#Manual detection
			elsif line =~ /Looking closely into the keyhole of the lock\, you spy a small vial of liquid and a tiny hammer device which seems poised to shatter it if the lock is tampered with\./
				current_trap_type = "cloud"
				CharSettings['cloud'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /Using the metal grips from your.*\, you manage to reach in and grasp the post of the metal hammer\, and bend the weak metal out of striking range of the vial\.|Having rendered the hammer harmless\, you carefully remove a green\-tinted vial filled with thick acrid smoke from the .*#{all_box_types}\./
				current_trap_type = "Cloud trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /Looking closely into the keyhole of the lock\, you spy a tiny hammer device which has been bent back slightly\.|Looking closely into the keyhole of the lock\, you spy a small vial of liquid and a tiny hammer device which has been bent from striking range of the vial\./
				current_trap_type = "Cloud trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /Looking closely into the keyhole of the lock\, you spy a small vial of liquid and a tiny hammer device which has a red glow about it\./
				current_trap_type = "Cloud trap has already been disarmed with 408."
				break
	#####Acid vial information#####
			#Manual detection
			elsif line =~ /Peering closely into the lock\, you spy a tiny vial placed just past the tumblers of the lock mechanism\.\s+It would appear that any tampering with the lock mechanism would cause the tumblers to crush the vial and release whatever substance is inside\./
				current_trap_type = "acid vial"
				CharSettings['acid_vial'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /You carefully push a small ball of cotton into the lock mechanism\, surrounding and protecting the small vial from anything that may shatter it\.|Using a pair of metal grips\, you carefully remove the padded clear glass vial from the .*#{all_box_types}\./
				current_trap_type = "Acid vial trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /Peering closely into the lock\, you spy a tiny vial placed just past the tumblers of the lock mechanism\.\s+A small ball of cotton has been pushed up against the vial\, protecting it from anything that may shatter it\.|Looking closely at the lock\, you spy a small metal housing set just inside the lock mechanism\, but it appears empty\.|Looking closely into the keyhole of the lock\, you spy a small metal housing\, which appears to be empty\./
				current_trap_type = "Acid vial trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /You notice what appears to be a tiny vial placed just past the tumblers of the lock mechanism\.\s+A crimson glow surrounds the vial\.|Looking closely at the lock\, you spy a tiny vial set just inside the lock mechanism\.\s+The vial is surrounded by crimson glow\./
				current_trap_type = "Acid vial trap has already been disarmed with 408."
				break
			#Setting off trap manually
			elsif line =~ /You peer inside the lock and see that the tumblers have all been fused into a lump of useless metal/
				current_trap_type = "Acid vial trap has been set off."
				break
			#Trap has already been set off
			elsif line =~ /You peer inside the lock and see that the tumblers have been fused into a lump of useless metal./
				current_trap_type = "Acid vial trap has already been set off."
				break
	#####Springs information#####
			#Manual detection
			elsif line =~ /After carefully examining the lock\, you move on to the hinges of the .*#{all_box_types}\.\s+Just as you were to pass the.*#{all_box_types} off as safe\, you notice what appears to be the ends of springs incorporated with the hinges\.\s+Seems rather odd to have.*#{all_box_types} designed to spring open when it is unlocked\./
				current_trap_type = "springs"
				CharSettings['springs'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /With a little force applied to the springs\, you manage to pop them inside the.*#{all_box_types}\, from within which comes the tinkle of breaking glass\, followed by a strong acrid smell\.|With a little force applied to the springs\, you manage to pop them inside.*#{all_box_types}\, where they bounce around for a moment\.\s+You also hear something else rolling around in there\./
				current_trap_type = "Springs trap has been disarmed."
				break
			#Already manually disarmed
			#Same messaging as when no traps found.
			#Already disarmed with 408
			elsif line =~ /You spot a reddish glow about the hinges of the.*#{all_box_types}\./
				current_trap_type = "Springs trap has already been disarmed with 408."
				break
	#####Fire vial information#####
			#Manual detection
			elsif line =~ /Looking closely into the keyhole of the lock\, you spy a small vial of fire\-red liquid and a tiny hammer device which seems poised to shatter it if the lock is tampered with\./
				current_trap_type = "fire vial"
				CharSettings['fire_vial'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /Using the metal grips from your.*\, you manage to reach in and grasp the post of the metal hammer\, and bend the weak metal out of striking range of the vial\.|Having rendered the hammer harmless\, you carefully remove a thick glass vial filled with murky red liquid from the.*#{all_box_types}\./
				current_trap_type = "Fire vial trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /Looking closely into the keyhole of the lock\, you spy a tiny hammer device which has been bent back slightly\.|Looking closely into the keyhole of the lock\, you spy a small vial of fire\-red liquid and a tiny hammer device which has been bent from striking range of the vial\./
				current_trap_type = "Fire vial trap has already been disarmed."
				break
			#Already disarmed with 408 NEED MESSAGING
			#elsif line =~ //
			#	current_trap_type = "Fire vial trap has already been disarmed with 408."
			#	break
	#####Spores information#####
			#Manual detection
			elsif line =~ /Peering into the.*#{all_box_types}\'s lock\, you see a small tube towards the bottom of the tumbler mechanism\.\s+The tube is capped with a thin membrane\, but it seems likely that the tumblers would tear it off while turning\./
				current_trap_type = "spores"
				CharSettings['spores'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /Taking a lump of putty from your.*\, you carefully apply it to the end of the small tube\.\s+That should block whatever it\'s meant to deploy\./
				current_trap_type = "Spores trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /Peering into the.*#{all_box_types}\'s lock\, you see a small tube towards the bottom of the tumbler mechanism\.\s+It appears as though the tube has been plugged with something\./
				current_trap_type = "Spores trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /You see a thin tube extending from the lock mechanism down into the.*#{all_box_types}\.\s+The end of the tube is surrounded by a crimson glow\.|Peering into the.*#{all_box_types}\'s lock\, you see a small tube towards the bottom of the tumbler mechanism\.\s+A crimson glow surrounds the mouth of the tube\./
				current_trap_type = "Spores trap has already been disarmed with 408."
				break
			#Trap has already been set off
			elsif line =~ /Peering into the #{all_box_types}\'s lock\, you see a small tube towards the bottom of the tumbler mechanism\.\s+It appears as though the tube used to be covered with a thin membrane\, but it has torn mostly away\, and greyish\-green powder covers the area around it\./
				current_trap_type = "Spores trap has already been set off."
				break
	#####Plate information#####
			#Manual detection
			elsif line =~ /There appears to be a plate over the lock\, sealing it and preventing any access to the tumblers\.|Gonna chew through it/
				current_trap_type = "plate"
				CharSettings['plate'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /You carefully pour the contents of.*onto the .*#{all_box_types} where you think the keyhole ought to be\.\s+.*\, the metal plate covering the lock begins to melt away\./
				current_trap_type = "Plate trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /You see a metal plate covering the lock plate\, but it appears to have been melted through\, granting sufficient access to the lock to attempt picking it./
				current_trap_type = "Plate trap has already been disarmed."
				break
			#Already disarmed with 408
			#Trap can't be disarmed with 408
	#####Glyph information#####
			#Manual detection
			elsif line =~ /You notice some spiderweb\-like scratches on the lock plate which seem\, after some bit of scrutiny\, too organized to be just wear and tear \-\- it might be some type of glyph spell\./
				current_trap_type = "glyph"
				CharSettings['glyph'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /Knowing how delicate magical glyphs can be\, you scrape some extra lines into the markings hoping to alter their meaning and defeat the spell they may hold\./
				current_trap_type = "Glyph trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /You notice some spiderweb\-like scratches on the lock plate which seem\, after some bit of scrutiny\, too organized to be just wear and tear \-\- it might be some type of glyph spell\, but some of the markings have been altered\.\s+This may prevent any magical nature they have from manifesting itself\./
				current_trap_type = "Glyph trap has already been disarmed."
				break
			#Already disarmed with 408
			#Trap can't be disarmed with 408
	#####Rods information#####
			#Manual detection
			elsif line =~ /Looking closely into the keyhole\, you notice a pair of small metal rods a hair\'s width from touching each other\.\s+Peering around the inside of the keyhole\, you can see that the lock would push the two rods together should the lock be tampered with\./
				current_trap_type = "rods"
				CharSettings['rods'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /With great care you take a pair of metal grips and bend the sensitive metal rods out of alignment\.\s+It looks as though they cannot be pressed together by the lock mechanism any more\./
				current_trap_type = "Rods trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /Looking closely into the keyhole\, you notice a pair of small metal rods that have been bent in opposite directions of each other\./
				current_trap_type = "Rods trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /Near the lock mechanism\, you notice a pair of small metal rods surrounded by a crimson glow\.|Looking closely into the keyhole\, you notice a pair of small metal rods that have a slight reddish glow about them\./
				current_trap_type = "Rods trap has already been disarmed with 408."
				break
	#####Boomer information#####
			#Manual detection
			elsif line =~ /Carefully\, you feel around the lock and notice the inside chamber is coated with a strange white substance\.\s+From your experience you recognize this as a common.*detonation system for an explosive mixture that was used to treat the .*#{all_box_types}\./
				current_trap_type = "boomer"
				CharSettings['boomer'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /Using a bit of putty from your.*\, you cake a thin layer on the lock casing\, hopefully sufficient to prevent sparks when the metal arm strikes it\./
				current_trap_type = "Boomer trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /A thin layer of mud or putty has been dabbed on the connecting point of the striking arm and the white substance to prevent it from igniting the.*#{all_box_types} when it is unlocked\./
				current_trap_type = "Boomer trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /A deep red glow surrounds the striking arm of the trap mechanism\.\s+You hope it will keep the arm from making contact with the explosive white substance\./
				current_trap_type = "Boomer trap has already been disarmed with 408."
				break
	#####No trap found#####
			elsif line =~ /You discover no traps\./
				current_trap_type = "No trap found."
				break
	#####Box is already open#####
			elsif line =~ /Um, but it\'s open|There is no lock on that|You blink in surprise as though just becoming aware of.*presence\./
				current_trap_type = "Box is already open."
				box_counts_for_math = nil
				break
	#####No putty#####
			elsif line =~ /You figure that if you had some sort of putty/
				echo "No putty to disarm this trap. Exiting."
				exit
	#####Roundtime#####
			elsif line =~ /Roundtime/
				break
			end

		end

		time_to_disarm_trap = true
		if (current_trap_type == "No trap found." || current_trap_type == "Scarab trap has already been disarmed." || current_trap_type == "Scarab trap has already been disarmed with 408." || current_trap_type == "Needle trap has been disarmed." || current_trap_type == "Needle trap has already been disarmed." || current_trap_type == "Needle trap has already been disarmed with 408." || current_trap_type == "Jaws trap has been disarmed." || current_trap_type == "Jaws trap has already been disarmed." || current_trap_type == "Sphere trap has been disarmed." || current_trap_type == "Sphere trap has already been disarmed." || current_trap_type == "Sphere trap has already been disarmed with 408." || current_trap_type == "Crystal trap has been disarmed." || current_trap_type == "Crystal trap has already been disarmed." || current_trap_type == "Crystal trap has already been disarmed with 408." || current_trap_type == "Scales trap has been disarmed." || current_trap_type == "Scales trap has already been disarmed." || current_trap_type == "Scales trap has already been disarmed with 408." || current_trap_type == "Sulphur trap has been disarmed." || current_trap_type == "Sulphur trap has already been disarmed." || current_trap_type == "Cloud trap has been disarmed." || current_trap_type == "Cloud trap has already been disarmed." || current_trap_type == "Cloud trap has already been disarmed with 408." || current_trap_type == "Acid vial trap has been disarmed." || current_trap_type == "Acid vial trap has already been disarmed." || current_trap_type == "Acid vial trap has already been disarmed with 408." || current_trap_type == "Springs trap has been disarmed." || current_trap_type == "Springs trap has already been disarmed with 408." || current_trap_type == "Fire vial trap has been disarmed." || current_trap_type == "Fire vial trap has already been disarmed." || current_trap_type == "Fire vial trap has already been disarmed with 408." || current_trap_type == "Spores trap has been disarmed." || current_trap_type == "Spores trap has already been disarmed." || current_trap_type == "Spores trap has already been disarmed with 408." || current_trap_type == "Plate trap has been disarmed." || current_trap_type == "Plate trap has already been disarmed." || current_trap_type == "Glyph trap has been disarmed." || current_trap_type == "Glyph trap has already been disarmed." || current_trap_type == "Rods trap has been disarmed." || current_trap_type == "Rods trap has already been disarmed." || current_trap_type == "Rods trap has already been disarmed with 408." || current_trap_type == "Boomer trap has been disarmed." || current_trap_type == "Boomer trap has already been disarmed." || current_trap_type == "Boomer trap has already been disarmed with 408." || current_trap_type == "Scarab trap has been disarmed." || current_trap_type == "Spores trap has already been set off." || current_trap_type == "Sphere trap has already been set off.")
			echo "#{current_trap_type}" if UserVars.tpick["run_silently"] !~ /yes/i
			(box_counts_for_math = nil) if (current_trap_type =~ /already/)
			number_of_manual_trap_checks_remaining -= 1
			if current_trap_type == "No trap found." && number_of_manual_trap_checks_remaining > 0
				echo "Number of trap checks remaining: #{number_of_manual_trap_checks_remaining}"
				time_to_disarm_trap = nil
				manually_disarm_trap.call
			else
				if current_trap_type == "No trap found."
					CharSettings['no_trap'] += 1
					CharSettings['total_trap_count'] += 1
				end
				waitrt?
				if UserVars.tpick["auto_bundle_vials"] == "yes" && (GameObj.right_hand.name =~ /vial/ || GameObj.left_hand.name =~ /vial/)
					tpick_bundle_vials.call
				end
				if current_trap_type == "Scarab trap has been disarmed."
					echo "Disarming scarab."
					waitrt?
					(tpick_cast_spells (1035)) if (use_spell_1035)
					sleep 1
					waitrt?
					scarab_object = GameObj.loot.find{ |i| i.name =~ /#{scarab_name}/ && i.noun == "scarab" && !all_scarab_ids.include?(i.id) }
					fput "disarm ##{scarab_object.id}"
					tpick_say_scarab_safe
					until checkright == "scarab" || checkleft == "scarab"
						waitrt?
						fput "get ##{scarab_object.id}"
						sleep 0.1
					end
					if solo_or_other == "worker"
						CharSettings["total_scarabs_received_pool_picking"] += 1
						scarabs_received_this_session_pool_picking += 1
					end
					tpick_put_stuff_away
				end
				tpick_put_stuff_away
				if (disarm_only)
					if (bash_open_boxes)
						bash_the_box_open.call
					else
						box_counts_for_math = nil
						nil
					end
				else
					if always_use_wedge
						wedge_lock.call
					else
						measure.call
					end
				end
			end
		elsif current_trap_type == "Couldn't disarm trap, trying again."
			echo "#{current_trap_type}"
			tpick_cast_spells (404)
			manually_disarm_trap.call
		elsif current_trap_type == nil
			echo "Something went wrong on my end, repeating the DISARM command."
			tpick_cast_spells (404)
			manually_disarm_trap.call
		elsif (current_trap_type == "Acid vial trap has been set off." || current_trap_type == "Acid vial trap has already been set off.")
			echo "#{current_trap_type}"
			echo "Lock has been fused."
			if (disarm_only)
				if (bash_open_boxes)
					bash_the_box_open.call
				else
					box_counts_for_math = nil
					nil
				end
			else
				fused_lock_disarm.call
			end
		elsif current_trap_type == "Box is already open."
			echo "#{current_trap_type}"
			if solo_or_other == "solo"
				open_solo.call
			elsif solo_or_other == "other"
				open_others.call
			elsif solo_or_other == "ground"
				nil
			elsif solo_or_other == "worker"
				nil
			end
		elsif current_trap_type == "plate"
			echo "Found a #{current_trap_type} trap."
			if (disarm_only)
				if (bash_open_boxes)
					bash_the_box_open.call
				else
					box_counts_for_math = nil
					nil
				end
			else
				plate.call
			end
		elsif current_trap_type == "Jaws trap has already been disarmed with 408. Can't pick it." || current_trap_type == "Jaws trap has already been set off."
			echo "#{current_trap_type}"
			if (disarm_only)
				if (bash_open_boxes)
					bash_the_box_open.call
				else
					box_counts_for_math = nil
					nil
				end
			else
				fused_lock_disarm.call
			end
		else
			if current_trap_type == "Scales trap found, need to use dagger to disarm." || current_trap_type == "Sphere trap found, need to use lockpick to disarm."
				echo "#{current_trap_type}"
			else
				echo "Found a #{current_trap_type} trap." if UserVars.tpick["run_silently"] !~ /yes/i
			end
			if trap_cant_be_disarmed
				echo "Trap difficulty is too high according to your settings. Can't open box."
				if solo_or_other == "solo"
					where_to_stow_box.call
				elsif solo_or_other == "other"
					tpick_say_cant
					open_others.call
				elsif solo_or_other == "ground"
					cant_open_plated_box_count += 1
				elsif solo_or_other == "worker"
					ask_worker.call
				end
			else
				echo "Attempting to disarm trap." if current_trap_type != "scales" && time_to_disarm_trap == nil && UserVars.tpick["run_silently"] !~ /yes/i
				if current_trap_type == "scales"
					echo "Scales trap found, picking lock first then disarming."
					scale_trap_found = true
					measure.call
				elsif current_trap_type == "Scales trap found, need to use dagger to disarm."
					scaledisarm.call
				elsif (current_trap_type == "needle" || current_trap_type == "jaws" || current_trap_type == "crystal" || current_trap_type == "sulphur" || current_trap_type == "cloud" || current_trap_type == "acid vial" || current_trap_type == "springs" || current_trap_type == "fire vial" || current_trap_type == "spores" || current_trap_type == "glyph" || current_trap_type == "rods" || current_trap_type == "boomer" || current_trap_type == "sphere" || current_trap_type == "Sphere trap found, need to use lockpick to disarm." || current_trap_type == "scarab")
					manually_disarm_trap.call
				end
			end
		end
	end
}

scaledisarm = proc{
	echo "Attempting to disarm scales trap." if UserVars.tpick["run_silently"] !~ /yes/i
	3.times{
		waitrt?
		unless GameObj.right_hand.id == $scale_trap_weapon_id || GameObj.left_hand.id == $scale_trap_weapon_id
			fput "get ##{$scale_trap_weapon_id}"
			sleep 0.2
		end
	}
	if GameObj.right_hand.id != $scale_trap_weapon_id && GameObj.left_hand.id != $scale_trap_weapon_id
		echo "Couldn't find your #{UserVars.tpick["scale_trap_weapon"]}."
		exit
	end
	(tpick_cast_spells (404)) if (need_404 == "yes") || (use_spell_404)
	(tpick_cast_spells (613)) if (use_spell_613)
	(tpick_cast_spells (1006)) if (use_spell_1006)
	(tpick_cast_spells (1035)) if (use_spell_1035)
	result = dothistimeout "disarm ##{current_box.id}", 3, /slice through the cord/i
	if result =~ /slice through the cord/
		waitrt?
		tpick_put_stuff_away
		if solo_or_other == "solo"
			open_solo.call
		elsif solo_or_other == "other"
			open_others.call
		elsif solo_or_other == "ground"
			sleep 0.1
		elsif solo_or_other == "worker"
			sleep 0.1
		end
	elsif result.nil?
		waitrt?
		tpick_put_stuff_away
		tpick_cast_spells (404)
		scaledisarm.call
	end
}

get_vials_and_stuff = proc{
	wait_until { checkrt == 0 }
	3.times{
		waitrt?
		wait_until { checkrt == 0 }
		unless GameObj.right_hand.name =~ /vial/ || GameObj.left_hand.name =~ /vial/
			fput "get vial from ##{@tpick_locksmiths_container.id}"
			sleep 0.2
		end
	}
	if GameObj.right_hand.name !~ /vial/ && GameObj.left_hand.name !~ /vial/
		echo "No vials found bundled in your locksmith's container and no loose vials found in your locksmith's container"
		if Char.prof == 'Rogue'
			echo "Going to try wedging this box open."
			wedge_lock.call
		elsif Char.prof != 'Rogue' and (!Spell[407].known? or (use_unlock_407_settings[0] != "plate" and use_unlock_407_settings[0] != "all"))
			echo "Can't open this plated box."
			if solo_or_other == "solo"
				exit
			elsif solo_or_other == "other"
				tpick_say_cant
				open_others.call
			elsif solo_or_other == "ground"
				(cant_open_plated_box_count += 1;box_opened = nil)
			elsif solo_or_other == "worker"
				nil
			end
		elsif Char.prof != 'Rogue' and Spell[407].known? and use_unlock_407_settings[0] == "plate"
			tpick_get_box(current_box) if solo_or_other == "ground"
			echo "Going to try popping this box."
			cast_407.call
		elsif Char.prof != 'Rogue' and Spell[407].known? and use_unlock_407_settings[0] == "all"
			tpick_get_box(current_box) if solo_or_other == "ground"
			echo "Going to try popping this box."
			cast_407.call
		end
	else
		echo "Found a loose vial! Let's do this!"
		plate.call
	end
}

plate = proc{
	echo "Disarming trap."
	waitrt?
	tpick_cast_spells (1035) if use_spell_1035
	if always_use_wedge
		wedge_lock.call
	else
		tpick_cast_spells (404) if need_404
		result = dothistimeout "disarm ##{current_box.id}", 3, /You try to pour .* onto the .*\, but it just won\'t pour\!|the metal plate covering the lock begins to melt away|Gonna chew through it|The darn thing is built too tightly|You still have a good enough picture of the trap in your mind/i
		if result =~ /the metal plate covering the lock begins to melt away/i
			measure.call
		elsif result =~ /Gonna chew through it/i
			echo "No vials found bundled in your locksmith's container, going to look for loose vials in your locksmith's container."
			get_vials_and_stuff.call
		elsif result =~ /The darn thing is built too tightly|You still have a good enough picture of the trap in your mind/
			plate.call
		elsif result =~ /You try to pour .* onto the .*\, but it just won\'t pour\!/
			echo "THIS IS A BUG WITH THE GAME: IT IS TRYING TO POUR YOUR LOCKSMITH'S CONTAINER ON THE BOX. Looking for loose vials in your locksmith's container."
			get_vials_and_stuff.call
		elsif result.nil?
			plate.call
		end
	end
}

measure_detection = proc{
	lock = nil
	calipers_measured_lock = nil
	if Char.prof == 'Rogue'
		echo "Measuring lock." if UserVars.tpick["run_silently"] !~ /yes/i
		3.times{
			waitrt?
			unless GameObj.right_hand.name =~ /calipers/ || GameObj.left_hand.name =~ /calipers/
				fput "get my calipers"
				sleep 0.2
			end
		}
		if GameObj.right_hand.name !~ /calipers/ && GameObj.left_hand.name !~ /calipers/
			echo "Couldn't find your calipers."
			exit
		end
		fput "lmaster measure ##{current_box.id}"
	elsif Char.prof == 'Bard'
		echo "Loresinging to box to find out lock difficulty."
		if solo_or_other == "ground"
			tpick_get_box(current_box)
			wait_until { GameObj.right_hand.id == current_box.id || GameObj.left_hand.id == current_box.id }
		end
		waitrt?
		fput "speak bard"
		finished_it = nil
		if solo_or_other == "worker"
			loresong_stuff = "loresing ::#{checkname} #{current_box.noun} on #{table}:: #{current_box.noun} that looks like a clock;What's the purpose of your lock?"
		else
			loresong_stuff = "loresing #{checkright} that I hold;let your purpose now be told"
		end
		loop{
			break if finished_it
			result = dothistimeout "#{loresong_stuff}", 2, /^You sing/i
			if result =~ /^You sing/
				finished_it = true
			end
		}
	end
	while line = get
		if line =~ /\-(\d+) in thief\-lingo difficulty ranking/
			lock = $1.to_i
			break
		end
		(lock = lock_difficulty[0];break) if line =~ /a primitive lock/i
		(lock = lock_difficulty[1];break) if line =~ /a rudimentary lock/i
		(lock = lock_difficulty[2];break) if line =~ /an extremely easy lock/i
		(lock = lock_difficulty[3];break) if line =~ /a very easy lock/i
		(lock = lock_difficulty[4];break) if line =~ /an easy lock/i
		(lock = lock_difficulty[5];break) if line =~ /a very basic lock/i
		(lock = lock_difficulty[6];break) if line =~ /a fairly easy lock/i
		(lock = lock_difficulty[7];break) if line =~ /a simple lock/i
		(lock = lock_difficulty[8];break) if line =~ /a fairly simple lock/i
		(lock = lock_difficulty[9];break) if line =~ /a fairly plain lock/i
		(lock = lock_difficulty[10];break) if line =~ /a moderately well-crafted lock/i
		(lock = lock_difficulty[11];break) if line =~ /a well-crafted lock/i
		(lock = lock_difficulty[12];break) if line =~ /a tricky lock/i
		(lock = lock_difficulty[13];break) if line =~ /a somewhat difficult lock/i
		(lock = lock_difficulty[14];break) if line =~ /a moderately difficult lock/i
		(lock = lock_difficulty[15];break) if line =~ /a very well-crafted lock/i
		(lock = lock_difficulty[16];break) if line =~ /a difficult lock/i
		(lock = lock_difficulty[17];break) if line =~ /an extremely well-crafted lock/i
		(lock = lock_difficulty[18];break) if line =~ /a very difficult lock/i
		(lock = lock_difficulty[19];break) if line =~ /a fairly complicated lock/i
		(lock = lock_difficulty[20];break) if line =~ /an intricate lock/i
		(lock = lock_difficulty[21];break) if line =~ /an amazingly well-crafted lock/i
		(lock = lock_difficulty[22];break) if line =~ /a very complex lock/i
		(lock = lock_difficulty[23];break) if line =~ /an impressively complicated lock/i
		(lock = lock_difficulty[24];break) if line =~ /an amazingly intricate lock/i
		(lock = lock_difficulty[25];break) if line =~ /an extremely difficult lock/i
		(lock = lock_difficulty[26];break) if line =~ /an extremely complex lock/i
		(lock = lock_difficulty[27];break) if line =~ /a masterfully well-crafted lock/i
		(lock = lock_difficulty[28];break) if line =~ /an amazingly complicated lock/i
		(lock = lock_difficulty[29];break) if line =~ /an astoundingly complex lock/i
		(lock = lock_difficulty[30];break) if line =~ /an incredibly intricate lock/i
		(lock = lock_difficulty[31];break) if line =~ /an absurdly well-crafted lock/i
		(lock = lock_difficulty[32];break) if line =~ /an exceedingly complex lock/i
		(lock = lock_difficulty[33];break) if line =~ /an absurdly difficult lock/i
		(lock = lock_difficulty[34];break) if line =~ /an unbelievably complicated lock/i
		(lock = lock_difficulty[35];break) if line =~ /a masterfully intricate lock/i
		(lock = lock_difficulty[36];break) if line =~ /an absurdly complex lock/i
		(lock = lock_difficulty[37];break) if line =~ /an impossibly complex lock/i
		if line =~ /You place the probe in the lock and grimace as something feels horribly wrong/i #This game line indicates the rogue is trying to measure a box with calipers when the box still has an active trap, since all soul golem boxes are technically trapped (the trap just randomizes the difficulty of the lock) this line will appear on every soul golem box. The solution below is to use a vaalin lockpick on soul golem boxes from the worker and to turn in all other boxes when this message appears. When not picking boxes from the worker the script will still use a vaalin lockpick.
			if critter_name =~ /soul golem/i
				lock = "need vaalin"
				break
			else
				if solo_or_other == "worker"
					ask_worker.call
					break
				else
					lock = "need vaalin"
					break
				end
			end
		end
		(lock = "not locked";break) if line =~ /has already been unlocked/i
		(lock = "can't find trap";break) if line =~ /As you start to place the probe in the lock/
		(lock = "can't measure";break) if line =~ /but your song simply wasn't powerful enough/
	end
	waitrt?
	calipers_measured_lock = lock if lock.is_a?(Numeric)
	if lock.is_a?(Numeric) && UserVars.tpick["lock_buffer"] =~ /\d+/ && Char.prof == "Rogue"
		lock += UserVars.tpick["lock_buffer"].to_i
		echo "You have lock buffer set to #{UserVars.tpick["lock_buffer"]}, going to assume this lock is +#{UserVars.tpick["lock_buffer"]} higher at -#{lock}"
	end
	number_of_times_to_measure += 1
	if lock == "can't measure" && number_of_times_to_measure < 3
		measure_detection.call
	end
}

lock_pick_information = proc{
	if recommended_pick == "copper"
		needed_pick = UserVars.tpick["copper"]
		needed_pick_id = copper_lock_pick_array.first
		recommended_pick_modifier = 1.00
	elsif recommended_pick == "steel"
		needed_pick = UserVars.tpick["steel"]
		needed_pick_id = steel_lock_pick_array.first
		recommended_pick_modifier = 1.10
	elsif recommended_pick == "gold"
		needed_pick = UserVars.tpick["gold"]
		needed_pick_id = gold_lock_pick_array.first
		recommended_pick_modifier = 1.20
	elsif recommended_pick == "silver"
		needed_pick = UserVars.tpick["silver"]
		needed_pick_id = silver_lock_pick_array.first
		recommended_pick_modifier = 1.30
	elsif recommended_pick == "mithril"
		needed_pick = UserVars.tpick["mithril"]
		needed_pick_id = mithril_lock_pick_array.first
		recommended_pick_modifier = 1.45
	elsif recommended_pick == "ora"
		needed_pick = UserVars.tpick["ora"]
		needed_pick_id = ora_lock_pick_array.first
		recommended_pick_modifier = 1.55
	elsif recommended_pick == "glaes"
		needed_pick = UserVars.tpick["glaes"]
		needed_pick_id = glaes_lock_pick_array.first
		recommended_pick_modifier = 1.60
	elsif recommended_pick == "laje"
		needed_pick = UserVars.tpick["laje"]
		needed_pick_id = laje_lock_pick_array.first
		recommended_pick_modifier = 1.75
	elsif recommended_pick == "vultite"
		needed_pick = UserVars.tpick["vultite"]
		needed_pick_id = vultite_lock_pick_array.first
		recommended_pick_modifier = 1.80
	elsif recommended_pick == "rolaren"
		needed_pick = UserVars.tpick["rolaren"]
		needed_pick_id = rolaren_lock_pick_array.first
		recommended_pick_modifier = 1.90
	elsif recommended_pick == "veniom"
		needed_pick = UserVars.tpick["veniom"]
		needed_pick_id = veniom_lock_pick_array.first
		recommended_pick_modifier = 2.20
	elsif recommended_pick == "invar"
		needed_pick = UserVars.tpick["invar"]
		needed_pick_id = invar_lock_pick_array.first
		recommended_pick_modifier = 2.25
	elsif recommended_pick == "alum"
		needed_pick = UserVars.tpick["alum"]
		needed_pick_id = alum_lock_pick_array.first
		recommended_pick_modifier = 2.30
	elsif recommended_pick == "golvern"
		needed_pick = UserVars.tpick["golvern"]
		needed_pick_id = golvern_lock_pick_array.first
		recommended_pick_modifier = 2.35
	elsif recommended_pick == "kelyn"
		needed_pick = UserVars.tpick["kelyn"]
		needed_pick_id = kelyn_lock_pick_array.first
		recommended_pick_modifier = 2.40
	elsif recommended_pick == "vaalin"
		needed_pick = UserVars.tpick["vaalin"]
		needed_pick_id = vaalin_lock_pick_array.first
		recommended_pick_modifier = 2.50
	end
}

measure = proc{
	stuff_to_do.call if solo_or_other == "solo"
	waitrt?
	(tpick_cast_spells (1035)) if (use_spell_1035)
	i_need_403 = nil
	recommended_pick = nil
	if UserVars.tpick["use_403_based_on_critter_level"] =~ /\d+/
		if critter_level.nil?
			echo "Critter level unknown, using 403 based on your settings. "
			need_403 = "yes"
		else
			if UserVars.tpick["use_403_based_on_critter_level"].to_i <= critter_level
				echo "Critter level is #{critter_level}, using 403 based on your settings. "
				need_403 = "yes"
			end
		end
	end
	if picks_to_use_based_on_critter_level && solo_or_other == "worker" && found_true_lock_difficulty.nil?
		needed_pick = nil
		if critter_level.nil?
			recommended_pick = "vaalin"
		else
			picks_to_use_based_on_critter_level.each{ |i|
				temp_picks_critter_level = i.split(" ")
				if temp_picks_critter_level[0].to_i >= critter_level
					if temp_picks_critter_level[1] == "copper"
						recommended_pick = "copper"
					elsif temp_picks_critter_level[1] == "steel"
						recommended_pick = "steel"
					elsif temp_picks_critter_level[1] == "gold"
						recommended_pick = "gold"
					elsif temp_picks_critter_level[1] == "silver"
						recommended_pick = "silver"
					elsif temp_picks_critter_level[1] == "mithril"
						recommended_pick = "mithril"
					elsif temp_picks_critter_level[1] == "ora"
						recommended_pick = "ora"
					elsif temp_picks_critter_level[1] == "glaes"
						recommended_pick = "glaes"
					elsif temp_picks_critter_level[1] == "laje"
						recommended_pick = "laje"
					elsif temp_picks_critter_level[1] == "vultite"
						recommended_pick = "vultite"
					elsif temp_picks_critter_level[1] == "rolaren"
						recommended_pick = "rolaren"
					elsif temp_picks_critter_level[1] == "veniom"
						recommended_pick = "veniom"
					elsif temp_picks_critter_level[1] == "invar"
						recommended_pick = "invar"
					elsif temp_picks_critter_level[1] == "alum"
						recommended_pick = "alum"
					elsif temp_picks_critter_level[1] == "golvern"
						recommended_pick = "golvern"
					elsif temp_picks_critter_level[1] == "kelyn"
						recommended_pick = "kelyn"
					elsif temp_picks_critter_level[1] == "vaalin"
						recommended_pick = "vaalin"
					end
					break
				end
			}
		end
		recommended_pick = "vaalin" if recommended_pick.nil?
		lock_pick_information.call
		if critter_level
			echo "Critter level is #{critter_level}, using a #{recommended_pick} lockpick based on your settings."
		else
			echo "Critter level is unknown, using a #{recommended_pick} lockpick."
		end
		pick2.call
	elsif always_use_vaalin && picks_to_use_based_on_critter_level.nil?
		echo "Always use vaalin setting enabled, using a vaalin lockpick."
		recommended_pick = "vaalin"
		lock_pick_information.call
		need_403 = "yes" unless UserVars.tpick["always_use_403"] == "never"
		pick2.call
	elsif (UserVars.tpick["use_vaalin_when_fried"] =~ /yes/i) && ((percentmind >= 100))
		echo "Always use vaalin when fried enabled, using a vaalin lockpick."
		(box_counts_for_math = nil)
		recommended_pick = "vaalin"
		lock_pick_information.call
		need_403 = "yes" unless UserVars.tpick["always_use_403"] == "never"
		pick2.call
	elsif start_with_copper && found_true_lock_difficulty.nil?
		echo "Start with copper option enabled, starting with lockpick in your copper lockpick setting."
		recommended_pick = "copper"
		lock_pick_information.call
		pick2.call	
	elsif use_unlock_407_settings[0] == "all"
		echo "Always use 407 setting enabled, using 407."
		if (scale_trap_found)
			echo "Can't open a scales trap with 407."
			if solo_or_other == "solo"
				where_to_stow_box.call
			elsif solo_or_other == "other"
				tpick_say_cant
				open_others.call
			elsif solo_or_other == "ground"
				cant_open_plated_box_count += 1
				box_opened = nil
			elsif solo_or_other == "worker"
				ask_worker.call
			end
		else
			tpick_get_box(current_box) if solo_or_other == "ground"
			cast_407.call
		end
	else
		waitrt?
		if (found_true_lock_difficulty.nil?)
			number_of_times_to_measure = 0
			measure_detection.call
			fput "speak common" if Char.prof == 'Bard'
			if Char.prof == 'Rogue'
				tpick_put_stuff_away
			elsif Char.prof == 'Bard' && solo_or_other == "ground"
				tpick_drop_box(current_box)
			end
		end
		number = 0
		needed_pick = nil
		needed_pick_id = nil
		if lock == "not locked"
			box_counts_for_math = nil
			if solo_or_other == "solo"
				open_solo.call
			elsif solo_or_other == "other"
				open_others.call
			elsif solo_or_other == "ground"
				nil
			elsif solo_or_other == "worker"
				nil
			end
		elsif lock == "can't find trap"
			echo "Doesn't look like you have the skill to detect the trap on this box."
			box_counts_for_math = nil
			if solo_or_other == "solo"
				where_to_stow_box.call
			elsif solo_or_other == "other"
				tpick_say_cant
				open_others.call
			elsif solo_or_other == "ground"
				nil
			elsif solo_or_other == "worker"
				ask_worker.call
			end
		elsif lock == "can't measure"
			echo "You can't determine the lock difficulty."
			box_counts_for_math = nil
			if solo_or_other == "solo"
				where_to_stow_box.call
			elsif solo_or_other == "other"
				tpick_say_cant
				open_others.call
			elsif solo_or_other == "ground"
				nil
			elsif solo_or_other == "worker"
				ask_worker.call
			end
		elsif lock == "need vaalin"
			recommended_pick = "vaalin"
			lock_pick_information.call
			echo "Recommended lock pick: #{recommended_pick} with a modifier of #{recommended_pick_modifier}" if UserVars.tpick["run_silently"] !~ /yes/i
			echo "Recommend 403: No" if UserVars.tpick["run_silently"] !~ /yes/i
			echo "Your calculated lockpicking skill: #{pick_skill}" if UserVars.tpick["run_silently"] !~ /yes/i
			temp_math_number = pick_skill
			quick_maths = (temp_math_number * recommended_pick_modifier).truncate
			echo "Your total picking skill for this attempt is: #{quick_maths}" if UserVars.tpick["run_silently"] !~ /yes/i
			echo "Lock difficulty: #{lock}" if UserVars.tpick["run_silently"] !~ /yes/i
			pick2.call
		else
			total_pick_skill = (pick_skill + pick_lore) * 2.50
			if max_lock_attempt_compared_to_max_skill && lock > (total_pick_skill - max_lock_attempt)
				if (scale_trap_found)
					echo "Lock difficulty: #{lock}, your max picking skill with a vaalin lockpick: #{total_pick_skill}, you won't pick anything higher than #{max_lock_attempt} points below your max skill according to the Max Lock setting in the ;setup menu. This box also has a scales trap so can't be popped or wedged open. Skipping box."
					if solo_or_other == "solo"
						where_to_stow_box.call
					elsif solo_or_other == "other"
						tpick_say_cant
						open_others.call
					elsif solo_or_other == "ground"
						cant_open_plated_box_count += 1
						box_opened = nil
					elsif solo_or_other == "worker"
						ask_worker.call
					end
				else
					echo "Lock difficulty: #{lock}, your max picking skill with a vaalin lockpick: #{total_pick_skill}, you won't pick anything higher than #{max_lock_attempt} points below your max skill according to the Max Lock setting in the ;setup menu so a lockpick won't be used."
						wedge_lock.call
				end
			elsif lock > max_lock_attempt && max_lock_attempt_compared_to_max_skill.nil?
				if (scale_trap_found)
					echo "This lock is higher than the Max Lock setting you entered in the ;setup menu so a lockpick won't be used. This box also has a scales trap so can't be popped or wedged open. Skipping box."
					if solo_or_other == "solo"
						where_to_stow_box.call
					elsif solo_or_other == "other"
						tpick_say_cant
						open_others.call
					elsif solo_or_other == "ground"
						cant_open_plated_box_count += 1
						box_opened = nil
					elsif solo_or_other == "worker"
						ask_worker.call
					end
				else
					echo "This lock is higher than the Max Lock setting you entered in the ;setup menu so a lockpick won't be used."
					wedge_lock.call
				end
			else
				if lock > (total_pick_skill + UserVars.tpick["vaalin_lock_roll"].to_i)
					if (scale_trap_found)
						echo "Can't pick this box based on my calculations (and it has a scales trap.) If you think this is in error increase the Vaalin Lock Roll setting in the setup menu. Skipping box."
						if solo_or_other == "solo"
							where_to_stow_box.call
						elsif solo_or_other == "other"
							tpick_say_cant
							open_others.call
						elsif solo_or_other == "ground"
							cant_open_plated_box_count += 1
							box_opened = nil
						elsif solo_or_other == "worker"
							ask_worker.call
						end
					else
						echo "Can't pick this box based on my calculations. If you think this is in error increase the Vaalin Lock Roll setting in the setup menu."
						wedge_lock.call
					end
				else
					pick_mod.each do |i|
						total_pick_skill = (pick_skill + pick_lore)
						if (total_pick_skill) * 2.50 - lock + UserVars.tpick["lock_roll"].to_i < 100
							needed_pick = UserVars.tpick["vaalin"]
							needed_pick_id = vaalin_lock_pick_array.first
							need_403 = "yes" unless UserVars.tpick["always_use_403"] == "never"
							i_need_403 = true unless UserVars.tpick["always_use_403"] == "never"
							number = 15
							break
						else
							total_pick_skill = (pick_skill) * i
							if total_pick_skill - lock + UserVars.tpick["lock_roll"].to_i < 100
								number += 1
								unless UserVars.tpick["always_use_403"] == "never"
									i_need_403 = true if number > 14
								end
							else
								break
							end
						end
						if use_403_for_lock_difficulty && Spell[403].known? && lock > use_403_for_lock_difficulty
							i_need_403 = true
						end
					end
					if i_need_403
						number = 0
						need_403 = "yes" unless UserVars.tpick["always_use_403"] == "never"
						pick_mod.each do |i|
							total_pick_skill = (pick_skill + pick_lore) * i
							if total_pick_skill - lock + UserVars.tpick["lock_roll"].to_i < 100
								number += 1
							else
								break
							end
						end
					end
					if number == 0
						recommended_pick = "copper"
					elsif number == 1
						recommended_pick = "steel"
					elsif number == 2
						recommended_pick = "gold"
					elsif number == 3
						recommended_pick = "silver"
					elsif number == 4
						recommended_pick = "mithril"
					elsif number == 5
						recommended_pick = "ora"
					elsif number == 6
						recommended_pick = "glaes"
					elsif number == 7
						recommended_pick = "laje"
					elsif number == 8
						recommended_pick = "vultite"
					elsif number == 9
						recommended_pick = "rolaren"
					elsif number == 10
						recommended_pick = "veniom"
					elsif number == 11
						recommended_pick = "invar"
					elsif number == 12
						recommended_pick = "alum"
					elsif number == 13
						recommended_pick = "golvern"
					elsif number == 14
						recommended_pick = "kelyn"
					elsif number > 14
						recommended_pick = "vaalin"
					end
					lock_pick_information.call
					echo "Recommended lock pick: #{recommended_pick} with a modifier of #{recommended_pick_modifier}" if UserVars.tpick["run_silently"] !~ /yes/i
					if need_403 == "yes"
						if use_403_for_lock_difficulty && Spell[403].known? && lock > use_403_for_lock_difficulty
							echo "Lock difficulty is higher than your 403 setting in setup menu, using 403." if UserVars.tpick["run_silently"] !~ /yes/i
						else
							echo "Recommend 403: Yes" if UserVars.tpick["run_silently"] !~ /yes/i
						end
						echo "Your calculated lockpicking skill: #{pick_skill}" if UserVars.tpick["run_silently"] !~ /yes/i
						echo "Your calculated lockpicking lore: #{pick_lore}" if UserVars.tpick["run_silently"] !~ /yes/i
						temp_math_number = pick_skill + pick_lore
					else
						echo "Recommend 403: No" if UserVars.tpick["run_silently"] !~ /yes/i
						echo "Your calculated lockpicking skill: #{pick_skill}" if UserVars.tpick["run_silently"] !~ /yes/i
						temp_math_number = pick_skill
					end
					quick_maths = (temp_math_number * recommended_pick_modifier).truncate
					echo "Your total picking skill for this attempt is: #{quick_maths}" if UserVars.tpick["run_silently"] !~ /yes/i
					echo "Lock difficulty: #{lock}" if UserVars.tpick["run_silently"] !~ /yes/i
					if needed_pick_id.nil?
						if recommended_pick == "vaalin"
							5.times{ echo "ALL OF YOUR VAALIN LOCKPICKS ARE BROKEN. YOU REALLY SHOULD HAVE AT LEAST 1 WORKING VAALIN LOCKPICK WHEN RUNNING THIS SCRIPT." }
							exit
						else
							echo "All of your #{recommended_pick} lockpicks seem to be broken, trying a higher tier lockpick."
						end
						nextpick.call
					else
						pick2.call
					end
				end
			end
		end
	end
}

find_gnomish_lockpick = proc{
	found_pick = nil
	spin_number = 0
	waitrt?
	fput "turn my #{gnomish_bracers}"
	while line = get
		if line =~ /^You spin your/
			(found_pick = true) if (line =~ /#{needed_pick}/)
			break
		end
	end
	if found_pick == nil
		loop{
			spin_number += 1
			waitrt?
			fput "spin my #{gnomish_bracers}"
			while line = get
				if line =~ /^You spin your/
					(found_pick = true) if (line =~ /#{needed_pick}/)
					break
				end
			end
			break if (found_pick) || (spin_number > 18)
		}
	end
	if (spin_number > 18)
		echo "Couldn't find the lockpick needed to pick this lock in your #{gnomish_bracers}."
		nextpick.call
	else
		pick3.call
	end
}

roll_amount_check = proc{
	waitrt?
	if needed_pick != UserVars.tpick["vaalin"]
		if roll_amount > UserVars.tpick["lock_roll"].to_i
			echo "You rolled: #{roll_amount}, your Lock Roll setting: #{UserVars.tpick["lock_roll"]}. Trying next pick."
			tpick_put_stuff_away
			next_task = "nextpick"
		else
			echo "You rolled: #{roll_amount}, your Lock Roll setting: #{UserVars.tpick["lock_roll"]}. Trying same pick again"
			next_task = "pick3"
		end
	elsif needed_pick == UserVars.tpick["vaalin"]
		if roll_amount > UserVars.tpick["vaalin_lock_roll"].to_i
			if need_403.nil?
				echo "You rolled: #{roll_amount}, your Vaalin Lock Roll setting: #{UserVars.tpick["vaalin_lock_roll"]}. Going to use 403 now."
				roll_amount = 99
			else
				echo "You rolled: #{roll_amount}, your Vaalin Lock Roll setting: #{UserVars.tpick["vaalin_lock_roll"]}. You are already using 403. According to your Vaalin Lock Roll setting you should stop trying to use lockpicks."
				roll_amount = 100
			end
			tpick_put_stuff_away
			next_task = "nextpick"
		else
			echo "You rolled: #{roll_amount}, your Vaalin Lock Roll setting: #{UserVars.tpick["vaalin_lock_roll"]}. Trying same pick again"
			next_task = "pick3"
		end
	end
}

pick2 = proc{
	waitrt?
	if (gnomish_bracers) && override_bracers != "override"
		find_gnomish_lockpick.call
	else
		3.times{
			waitrt?
			unless GameObj.right_hand.id == needed_pick_id || GameObj.left_hand.id == needed_pick_id
				fput "get ##{needed_pick_id}"
				sleep 0.2
			end
		}
		if GameObj.right_hand.id != needed_pick_id && GameObj.left_hand.id != needed_pick_id
			echo "Couldn't find #{needed_pick}."
			waitrt?
			roll_amount = 100
			nextpick.call
		else
			pick3.call
		end
	end
}

pick3 = proc{
	next_task = nil
	roll_amount = nil
	if (open_plinites) || current_box.name =~ /plinite/
		echo "Attempting to extract plinite."
	else
		echo "Attempting to pick lock." if UserVars.tpick["run_silently"] !~ /yes/i
	end
	waitrt?
	(tpick_cast_spells (1035)) if (use_spell_1035)
	unless UserVars.tpick["always_use_403"] == "never"
		(tpick_cast_spells (403)) if (need_403 == "yes" || use_spell_403)
	end
	if (open_plinites) || current_box.name =~ /plinite/
		fput "extract ##{current_box.id}"
	elsif gnomish_bracers && override_bracers != "override"
		tpick_get_box(current_box) if solo_or_other == "ground"
		fput "push my #{gnomish_bracers}"
	else
		if UserVars.tpick["trick"] == "random" && Char.prof =~ /Rogue/
			random_trick = [ "spin", "twist", "turn", "twirl", "toss", "bend", "flip" ].sample
			do_trick = "lmas ptrick #{random_trick}"
		end
		wait_until { checkrt == 0 }
		fput "#{do_trick} ##{current_box.id}"
	end
	if (open_plinites) || current_box.name =~ /plinite/
		while line = get
			if line =~ /\(d100\=(\d+)\)/
				roll_amount = $1.to_i
				if roll_amount == 1
					waitrt?
					next_task = "pick3"
					break
				end
			elsif line =~ /As you do you so\, you push just a little too hard and rupture the core\!/
				waitrt?
				next_task = "next plinite"
				break
			elsif line =~ /you withdraw your .* with the feeling that retrieving the core is within your abilities/
				waitrt?
				next_task = "pick3"
				break
			elsif line =~ /with the feeling that your abilities are probably not sufficient to retrieve the core/ || line =~ /You fumble about for a bit before you realize you are using a broken/
				if (GameObj.right_hand.id != current_box.id) && (solo_or_other == "ground" || solo_or_other == "worker")
					if line =~ /You fumble about for a bit before you realize you are using a broken/
						@tpick_lockpick_is_broken = true
						tpick_put_stuff_away
						@tpick_all_lockpick_id_arrays.each{ |i| i.delete(i.first) if needed_pick_id == i.first }
						roll_amount = 100 if vaalin_lock_pick_array.length < 1
					else
						tpick_put_stuff_away
					end
				end
				tpick_put_stuff_away
				if needed_pick == UserVars.tpick["vaalin"]
					if solo_or_other == "worker"
						echo "Can't extract this plinite based on my calculations. If you think this is in error increase the Vaalin Lock Roll setting in the setup menu."
						next_task = "next plinite"
					else
						echo "Can't extract this plinite, OPENing it instead. If you think this is in error increase the Vaalin Lock Roll setting in the setup menu."
						waitrt?
						fput "open ##{current_box.id}"
						next_task = "next plinite"
					end
				else
					next_task = "nextpick"
				end
				break
			elsif line =~ /where it can be easily PLUCKed/
				next_task = "open plinite"
				break
			elsif line =~ /^Roundtime\:/
				break
			end
		end
	else
		while line = get
			#Get roll amount:
			if line =~ /^You make .* attempt \(d100\=(\d+)\)\./
				roll_amount = $1.to_i
				next_task = "pick3" if roll_amount == 1
			####################################################################################################
			#Box has been opened or was already open:
			elsif line =~ /^You struggle with the .*\.  As you do\, you get a sense that the .* has .* \(\-(\d+) thief\-lingo difficulty ranking\)\.  Then\.\.\.CLICK\!  It opens\!|^The .* gives off an audible \*click\* as the tumblers snap open\.|^It does not appear to be locked./
				calibrate_count += 1
				waitrt?
				tpick_put_stuff_away
				if line =~ /^It does not appear to be locked./
					box_counts_for_math = nil
				elsif line =~ /^You struggle with the .*\.  As you do\, you get a sense that the .* has .* \(\-(\d+) thief\-lingo difficulty ranking\)\.  Then\.\.\.CLICK\!  It opens\!|^The .* gives off an audible \*click\* as the tumblers snap open\./
					actual_lock_difficulty = $1.to_i if line =~ /^You struggle with the .*\.  As you do\, you get a sense that the .* has .* \(\-(\d+) thief\-lingo difficulty ranking\)\.  Then\.\.\.CLICK\!  It opens\!/
					CharSettings["number_of_locks_opened_since_last_broken_pick"] += 1
					CharSettings["number_of_current_uses_for_lockpicks"][recommended_pick] += 1
					successful_lockpick_text = "Number of locks successfully opened since last broken lockpick: "
					CharSettings["number_of_current_uses_for_lockpicks"].each{ |key,value|
						successful_lockpick_text += "#{key}: #{value}, "
					}
					successful_lockpick_text = successful_lockpick_text.chop.chop
					successful_lockpick_text += ". Number of total locks picked since any lockpick broke: #{CharSettings["number_of_locks_opened_since_last_broken_pick"]}"
					echo "#{successful_lockpick_text}"
					if Char.prof == "Rogue"
						if calibrate_auto_amount && calipers_measured_lock.is_a?(Numeric) && actual_lock_difficulty.is_a?(Numeric)
							calibrate_auto_math = (calipers_measured_lock - actual_lock_difficulty).abs
							if calibrate_auto_math >= calibrate_auto_amount
								unless popping
									echo "The difference between calipers reading and actual lock difficulty was #{calibrate_auto_math}. According to your settings you want your calipers calibrated."
									calibrate.call
								end
							end
						elsif (calibrate_count >= UserVars.tpick["calibratecount"].to_i) && (calibrate_auto_amount.nil?)
							if can_use_calipers && always_use_vaalin.nil? && start_with_copper.nil?
								calibrate.call unless popping
							end
							calibrate_count = 0
						end
					end
				end
				if scale_trap_found
					scaledisarm.call
				elsif solo_or_other == "solo"
					next_task = "open_solo"
				elsif solo_or_other == "other"
					next_task = "open_other"
				elsif solo_or_other == "ground"
					tpick_drop_box(current_box) if gnomish_bracers && override_bracers != "override"
					next_task = "open_ground"
				elsif solo_or_other == "worker"
					next_task = "worker finished"
				end
				break
			####################################################################################################
			#No read from the box:
			elsif line =~ /^You are not able to pick the lock\, and learn little about it\./
				if roll_amount == 1
					echo "This attempt was a fumble, going to try again."
					next_task = "pick3"
				else
					roll_amount_check.call
				end
				break
			####################################################################################################
			#Box can be opened with current lockpick:
			elsif line =~ /^You are not able to pick the .*\, but you get a sense that it has .* lock\.  About a \-(\d+) difficulty lock \(in thief\-lingo\)\.|^You are not able to pick the lock\, but you get a feeling that it is within your abilities\./
				if line =~ /^You are not able to pick the .*\, but you get a sense that it has .* lock\.  About a \-(\d+) difficulty lock \(in thief\-lingo\)\./ && found_true_lock_difficulty.nil?
					lock = $1.to_i
					found_true_lock_difficulty = true
					next_task = "measure again"
				else
					if roll_amount == 1
						echo "This attempt was a fumble, going to try again."
						next_task = "pick3"
					else
						if UserVars.tpick["keep_trying_if_within_abilities"] =~ /yes/i
							echo "Messaging indicates you can open this box with current lockpick, according to your settings you want to try same lockpick again."
							next_task = "pick3"
						else
							echo "Messaging indicates you can open this box with current lockpick, but according to your settings you don't want to try same lockpick again."
							roll_amount_check.call
						end
					end
				end
				break
			####################################################################################################
			#Lockpick has been damaged, most likely box can't be opened with current lockpick:		
			elsif line =~ /^Your .* gets stuck in the lock\!  You carefully try to work it free but end up bending the tip\!|^Your .* gets stuck in the lock\!  You carefully try to work it free\, but it may have been weakened by the stress\./
				waitrt?
				wait_until { checkrt == 0 }
				if line =~ /^Your .* stuck in the lock\!  You carefully try to work it free but end up bending the tip\!/ && UserVars.tpick["auto_repair_bent_lockpicks"] == "yes" && Char.prof == "Rogue"
					waitrt?
					wait_until { checkrt == 0 }
					echo "Lockpick tip was bent, going to try repairing it."
					tpick_stow_box(current_box) if solo_or_other !~ /ground|worker/
					fput "lmas repair ##{needed_pick_id}"
					waitrt?
					sleep 1
					wait_until { checkrt == 0 }
					tpick_get_box(current_box) if solo_or_other !~ /ground|worker/
				end
				if roll_amount == 1
					echo "This attempt was a fumble, going to try again."
					next_task = "pick3"
				elsif roll_amount < max_roll_attempt_before_moving_to_new_pick
					echo "You rolled #{roll_amount}, your settings are to try again because you rolled less than #{max_roll_attempt_before_moving_to_new_pick}."
					next_task = "pick3"
				else
					if needed_pick != UserVars.tpick["vaalin"]
						echo "This pick doesn't seem to be cutting it, going to try a different one."
					elsif needed_pick == UserVars.tpick["vaalin"]
						if need_403.nil?
							echo "A vaalin pick doesn't seem to be cutting it alone, going to try 403."
							roll_amount = 99
						else
							echo "A vaalin pick with 403 doesn't seem to be cutting it, going to try wedges or 407."
							roll_amount = 100
						end
					end
					tpick_put_stuff_away
					next_task = "nextpick"
				end
				break
			####################################################################################################
			#Lockpick has been broken or was already broken:
			elsif line =~ /^\* SNAP \*  Crud\!  You broke your .* in the attempt\!|^You attempt to pick the .* and fumble about for a bit before you realize you are using a broken .*\.|^Your .* gets stuck in the lock\!  You carefully try to work it free but end up snapping off the tip\!/
				if line =~ /^\* SNAP \*  Crud\!  You broke your .* in the attempt\!|^Your .* gets stuck in the lock\!  You carefully try to work it free but end up snapping off the tip\!/
					echo "Your #{recommended_pick} lockpick successfully picked #{CharSettings["number_of_current_uses_for_lockpicks"][recommended_pick]} locks before it broke. You successfully picked #{CharSettings["number_of_locks_opened_since_last_broken_pick"]} locks since you last broke any lockpick."
					CharSettings["number_of_locks_opened_since_last_broken_pick"] = 0
					CharSettings["number_of_current_uses_for_lockpicks"][recommended_pick] = 0
				end
				echo "#{needed_pick} is broken."
				waitrt?
				next_task = "broken lockpick stow"
				break
			####################################################################################################
			#Not holding a lockpick, either because the person doesn't have the needed pick or the needed pick is broken:
			elsif line =~ /^You must be holding a lockpick to perform that trick\.|^You didn\'t mention what you want to pick the lock with\./
				echo "Couldn't find #{needed_pick}."
				waitrt?
				next_task = "nextpick"
				break
			####################################################################################################
			elsif line =~ /^Roundtime\:/
				break
			end
		end
	end
	if next_task == "open_solo"
		open_solo.call
	elsif next_task == "open_other"
		open_others.call
	elsif next_task == "worker finished"
		nil
	elsif next_task == "open_ground"
		nil
	elsif next_task == "pick3"
		pick3.call
	elsif next_task == "nextpick"
		nextpick.call
	elsif next_task == "measure again"
		echo "Got a read on this box, going to change to best suited lockpick."
		waitrt?
		tpick_put_stuff_away
		measure.call
	elsif next_task == "broken lockpick stow"
		if gnomish_bracers && override_bracers != "override"
			nextpick.call
		else
			@tpick_lockpick_is_broken = true
			tpick_put_stuff_away
			@tpick_all_lockpick_id_arrays.each{ |i| i.delete(i.first) if needed_pick_id == i.first }
			roll_amount = 100 if vaalin_lock_pick_array.length < 1
			nextpick.call
		end
	elsif next_task == "open plinite"
		if solo_or_other == "worker"
			ask_worker.call
		else
			open_current_plinite.call
		end
	elsif next_task == "next plinite"
		tpick_put_stuff_away
		ask_worker.call if solo_or_other == "worker"
	end
}

nextpick = proc{
	before_needed_pick = needed_pick
	before_recommended_pick = recommended_pick
	if recommended_pick == "copper"
		needed_pick = UserVars.tpick["steel"]
		needed_pick_id = steel_lock_pick_array.first
		recommended_pick = "steel"
	elsif recommended_pick == "steel"
		needed_pick = UserVars.tpick["gold"]
		needed_pick_id = gold_lock_pick_array.first
		recommended_pick = "gold"
	elsif recommended_pick == "gold"
		needed_pick = UserVars.tpick["silver"]
		needed_pick_id = silver_lock_pick_array.first
		recommended_pick = "silver"
	elsif recommended_pick == "silver"
		needed_pick = UserVars.tpick["mithril"]
		needed_pick_id = mithril_lock_pick_array.first
		recommended_pick = "mithril"
	elsif recommended_pick == "mithril"
		needed_pick = UserVars.tpick["ora"]
		needed_pick_id = ora_lock_pick_array.first
		recommended_pick = "ora"
	elsif recommended_pick == "ora"
		needed_pick = UserVars.tpick["glaes"]
		needed_pick_id = glaes_lock_pick_array.first
		recommended_pick = "glaes"
	elsif recommended_pick == "glaes"
		needed_pick = UserVars.tpick["laje"]
		needed_pick_id = laje_lock_pick_array.first
		recommended_pick = "laje"
	elsif recommended_pick == "laje"
		needed_pick = UserVars.tpick["vultite"]
		needed_pick_id = vultite_lock_pick_array.first
		recommended_pick = "vultite"
	elsif recommended_pick == "vultite"
		needed_pick = UserVars.tpick["rolaren"]
		needed_pick_id = rolaren_lock_pick_array.first
		recommended_pick = "rolaren"
	elsif recommended_pick == "rolaren"
		needed_pick = UserVars.tpick["veniom"]
		needed_pick_id = veniom_lock_pick_array.first
		recommended_pick = "veniom"
	elsif recommended_pick == "veniom"
		needed_pick = UserVars.tpick["invar"]
		needed_pick_id = invar_lock_pick_array.first
		recommended_pick = "invar"
	elsif recommended_pick == "invar"
		needed_pick = UserVars.tpick["alum"]
		needed_pick_id = alum_lock_pick_array.first
		recommended_pick = "alum"
	elsif recommended_pick == "alum"
		needed_pick = UserVars.tpick["golvern"]
		needed_pick_id = golvern_lock_pick_array.first
		recommended_pick = "golvern"
	elsif recommended_pick == "golvern"
		needed_pick = UserVars.tpick["kelyn"]
		needed_pick_id = kelyn_lock_pick_array.first
		recommended_pick = "kelyn"
	elsif recommended_pick == "kelyn"
		needed_pick = UserVars.tpick["vaalin"]
		needed_pick_id = vaalin_lock_pick_array.first
		recommended_pick = "vaalin"
	elsif recommended_pick == "vaalin" && roll_amount != 100
		need_403 = "yes" unless UserVars.tpick["always_use_403"] == "never"
		needed_pick = UserVars.tpick["vaalin"]
		needed_pick_id = vaalin_lock_pick_array.first
		recommended_pick = "vaalin"
	elsif recommended_pick == "vaalin" && roll_amount == 100
		needed_pick = "wedge"
	end
	if needed_pick_id.nil?
		if recommended_pick == "vaalin"
			5.times{ echo "ALL OF YOUR VAALIN LOCKPICKS ARE BROKEN. YOU REALLY SHOULD HAVE AT LEAST 1 WORKING VAALIN LOCKPICK WHEN RUNNING THIS SCRIPT." }
			exit
		else
			echo "All of your #{recommended_pick} lockpicks seem to be broken, trying a higher tier lockpick."
			nextpick.call
		end
	elsif before_needed_pick == needed_pick && recommended_pick != "vaalin"
		nextpick.call
	else
		nextpick2.call
	end
}

nextpick2 = proc{
	if needed_pick == "wedge"
		if open_plinites || current_box.name =~ /plinite/
			if solo_or_other == "worker"
				echo "Can't extract this plinite based on my calculations. If you think this is in error increase the Vaalin Lock Roll setting in the setup menu."
				ask_worker.call
			else
				echo "Can't extract this plinite, OPENing it instead. If you think this is in error increase the Vaalin Lock Roll setting in the setup menu."
				waitrt?
				fput "open ##{current_box.id}"
			end
		elsif (scale_trap_found)
			echo "Can't pick this box and it has a scales trap."
			if solo_or_other == "solo"
				where_to_stow_box.call
			elsif solo_or_other == "other"
				tpick_say_cant
				open_others.call
			elsif solo_or_other == "ground"
				cant_open_plated_box_count += 1
				box_opened = nil
			end
		else
			if Char.prof =~ /Rogue/
				echo "Can't pick this lock, going to try to wedge it open."
				wedge_lock.call
			elsif Spell[407].known?
				echo "Can't pick this lock, going to try to pop it open."
				cast_407.call
			else
				if solo_or_other == "other"
					tpick_say_cant
					open_others.call
				elsif solo_or_other == "ground"
					echo "Couldn't open this box."
					box_opened = nil
				elsif solo_or_other == "solo"
					echo "Couldn't open this box."
					where_to_stow_box.call
					tpick_put_stuff_away
					sleep 0.1
				end
			end
		end
	elsif before_needed_pick == UserVars.tpick["vaalin"]
		echo "Trying to pick with vaalin lockpick again."
		pick2.call
	else
		echo "Couldn't pick lock with #{before_recommended_pick} pick, trying #{recommended_pick} pick."
		pick2.call
	end
}

total_boxes_picked_math = proc{
	if (update_math_information)
		if (box_counts_for_math == nil)
			echo "This box was not added to your total boxes picked nor was the time spent opening it recorded."
		else
			total_picking_time = (Time.now - start_time)
			CharSettings['total_boxes_picked'] += 1
			(CharSettings['total_time_spent_picking_boxes'] += total_picking_time)
		end
		if solo_or_other == "solo" || solo_or_other == "ground"
			total_boxes_number -= 1
			total_boxes_number = [total_boxes_number, 0].max
		end
	end
	CharSettings['total_time_spent_picking_boxes'] = CharSettings['total_time_spent_picking_boxes'].round(2) unless CharSettings['total_time_spent_picking_boxes'] == 0
	average_picking_time = (CharSettings['total_time_spent_picking_boxes'] / CharSettings['total_boxes_picked']).round(2) unless CharSettings['total_boxes_picked'] == 0
	if CharSettings['total_boxes_picked'] > 0
		respond "\n"
		respond "####################"
		respond "####################"
		respond "Total boxes picked: #{CharSettings['total_boxes_picked']}"
		respond "Total time picking: #{CharSettings['total_time_spent_picking_boxes']} seconds"
		respond "Average time per box: #{average_picking_time} seconds"
		respond "####################"
		respond "####################"
		respond "\n"
	end
	if solo_or_other == "solo" || solo_or_other == "ground"
		(calculate_time_left = (total_boxes_number * average_picking_time).round(2)) unless CharSettings['total_boxes_picked'] == 0
		respond "\n"
		respond "####################"
		respond "####################"
		respond "Boxes remaining: #{total_boxes_number}"
		(respond "Estimated time remaining: #{calculate_time_left} seconds") unless CharSettings['total_boxes_picked'] == 0
		respond "####################"
		respond "####################"
		respond "\n"
	end
	box_counts_for_math = true
}

open_solo = proc{
	update_math_information = true
	total_boxes_picked_math.call
	waitrt?
	(tpick_cast_spells (1035)) if (use_spell_1035)	
	total_boxes_picked += 1
	fput "open ##{current_box.id}" unless popping
	lootbox = GameObj.right_hand
	(dothistimeout "look in my #{lootbox}", 10, /In .*? you see|In the .*\:|There is nothing in/) if lootbox.contents.nil?
	waitrt?
	fput "swap"
	lootbox.contents.each{ |item|
		current_item = item
		tpick_gather_the_loot.call
	}
	do_relock_boxes.call if relock_boxes
	garbage_check.call
	if box != "none"
		tpick_put_stuff_away
		sleep 0.1
	else
		tpick_put_stuff_away
	end
}

garbage_check = proc{
	waitrt?
	if UserVars.tpick["trash_boxes"] == "yes"
		if checkroom =~ /table|booth/i
			tpick_drop_box(current_box) if solo_or_other == "solo"
			fput "clean table"
		elsif GameObj.loot.find { |loot| trash = loot if loot.name =~ trash_container }
			waitrt?
			tpick_get_box(current_box) if solo_or_other == "ground"
			fput "put ##{current_box.id} in #{trash}"
		else
			tpick_drop_box(current_box) if solo_or_other == "solo"
		end
	elsif UserVars.tpick["trash_boxes"] == "save"
		@tpick_stow_current_box = true
		tpick_put_stuff_away
	else
		tpick_drop_box(current_box) if solo_or_other == "solo"
	end
	waitrt?
}

record_item_data = proc{
		if GameObj.right_hand.type =~ /gem/i
			gem = Array.new if gem == nil
			(gem.push(GameObj.right_hand.name);gem_number[gem.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /reagent/i
			reagent = Array.new if reagent == nil
			(reagent.push(GameObj.right_hand.name);reagent_number[reagent.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /herb/i
			herb = Array.new if herb == nil
			(herb.push(GameObj.right_hand.name);herb_number[herb.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /food/i
			food = Array.new if food == nil
			(food.push(GameObj.right_hand.name);food_number[food.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /uncommon/i
			uncommon = Array.new if uncommon == nil
			(uncommon.push(GameObj.right_hand.name);uncommon_number[uncommon.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /jewelry/i
			jewelry = Array.new if jewelry == nil
			(jewelry.push(GameObj.right_hand.name);jewelry_number[jewelry.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /junk/i
			junk = Array.new if junk == nil
			(junk.push(GameObj.right_hand.name);junk_number[junk.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /lockpick/i
			lockpick = Array.new if lockpick == nil
			(lockpick.push(GameObj.right_hand.name);lockpick_number[lockpick.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /magic/i
			magic = Array.new if magic == nil
			(magic.push(GameObj.right_hand.name);magic_number[magic.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /scroll/i
			scroll = Array.new if scroll == nil
			(scroll.push(GameObj.right_hand.name);scroll_number[scroll.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /wand/i
			wand = Array.new if wand == nil
			(wand.push(GameObj.right_hand.name);wand_number[wand.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /armor/i
			armor = Array.new if armor == nil
			(armor.push(GameObj.right_hand.name);armor_number[armor.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /weapon/i
			weapon = Array.new if weapon == nil
			(weapon.push(GameObj.right_hand.name);weapon_number[weapon.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /clothing/i
			clothing = Array.new if clothing == nil
			(clothing.push(GameObj.right_hand.name);clothing_number[clothing.index(GameObj.right_hand.name)] += 1)
		else
			other = Array.new if other == nil
			(other.push(GameObj.right_hand.name);other_number[other.index(GameObj.right_hand.name)] += 1)
		end
}

open_others = proc{
	update_math_information = true
	total_boxes_picked_math.call
	waitrt?
	fput "give ##{current_box.id} to #{person}"
	start_others.call
}

before_dying { 
	if ground_loot || solo_or_other == "solo"
		wealth_after.call
		wait_until { silver_after }
		silver_gained = silver_after - silver_before
	end
	
	DownstreamHook.remove("#{script.name}_check_locksmiths_container")
	DownstreamHook.remove("#{script.name}_check_for_boxes")
	DownstreamHook.remove("#{script.name}_wealth_before")
	DownstreamHook.remove("#{script.name}_wealth_after")

	respond "Total boxes picked: #{total_boxes_picked}" if ground_loot || solo_or_other == "solo"
	respond "Total silvers gained: #{silver_gained}" if ground_loot || solo_or_other == "solo"
	(gem.uniq! if gem != nil;reagent.uniq! if reagent != nil;herb.uniq! if herb != nil;food.uniq! if food != nil;uncommon.uniq! if uncommon != nil;jewelry.uniq! if jewelry != nil;junk.uniq! if junk != nil;lockpick.uniq!if lockpick != nil;magic.uniq! if magic != nil;scroll.uniq! if scroll != nil;wand.uniq! if wand != nil;armor.uniq! if armor != nil;weapon.uniq! if weapon != nil;other.uniq! if other != nil;clothing.uniq if clothing != nil) if ground_loot || solo_or_other == "solo"
	(respond "\nGems:\n";gem.each{|item|respond "#{item} x#{gem_number[gem.index(item)]}"}) if gem != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nReagents:\n";reagent.each{|item|respond "#{item} x#{reagent_number[reagent.index(item)]}"}) if reagent != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nHerbs:\n";herb.each{|item|respond "#{item} x#{herb_number[herb.index(item)]}"}) if herb != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nFood:\n";food.each{|item|respond "#{item} x#{food_number[food.index(item)]}"}) if food != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nUncommon:\n";uncommon.each{|item|respond "#{item} x#{uncommon_number[uncommon.index(item)]}"}) if uncommon != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nJewelry:\n";jewelry.each{|item|respond "#{item} x#{jewelry_number[jewelry.index(item)]}"}) if jewelry != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nJunk:\n";junk.each{|item|respond "#{item} x#{junk_number[junk.index(item)]}"}) if junk != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nLockpicks:\n";lockpick.each{|item|respond "#{item} x#{lockpick_number[lockpick.index(item)]}"}) if lockpick != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nMagic:\n";magic.each{|item|respond "#{item} x#{magic_number[magic.index(item)]}"}) if magic != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nScrolls:\n";scroll.each{|item|respond "#{item} x#{scroll_number[scroll.index(item)]}"}) if scroll != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nWands:\n";wand.each{|item|respond "#{item} x#{wand_number[wand.index(item)]}"}) if wand != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nArmor:\n";armor.each{|item|respond "#{item} x#{armor_number[armor.index(item)]}"}) if armor != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nWeapons:\n";weapon.each{|item|respond "#{item} x#{weapon_number[weapon.index(item)]}"}) if weapon != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nClothing:\n";clothing.each{|item|respond "#{item} x#{clothing_number[clothing.index(item)]}"}) if clothing != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nOther:\n";other.each{|item|respond "#{item} x#{other_number[other.index(item)]}"}) if other != nil and (ground_loot or solo_or_other == "solo")
	all_containers_to_close_before_exit = UserVars.tpick["containers_to_close_before_exit"].split(",")
	if worker_start_picking_time
		time_spent_pool_picking_this_session = Time.now - worker_start_picking_time
		CharSettings["total_time_spent_pool_picking"] += time_spent_pool_picking_this_session
		####################################################################################################
		t = time_spent_pool_picking_this_session
		time_spent_picking = "%02d:%02d:%02d" % [t/3600%24, t/60%60, t%60]
		total_scarab_value = (scarabs_received_this_session_pool_picking * 5000)
		silver_tips_plus_scarab_value = silvers_earned_from_pool_picking_this_session + total_scarab_value
		silvers_earned_hour = ((silver_tips_plus_scarab_value / time_spent_pool_picking_this_session) * 3600).truncate
		silvers_earned_hour = silvers_earned_hour.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse
		commas_for_silvers_earned = silvers_earned_from_pool_picking_this_session.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse
		total_scarab_value_commas = total_scarab_value.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse
		silver_tips_plus_scarab_value_commas = silver_tips_plus_scarab_value.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse
		if scarabs_received_this_session_pool_picking > 0
			scarab_frequency = (((scarabs_received_this_session_pool_picking *1.0) / number_of_boxes_picked_this_session_pool_picking) * 100).round(2)
		else
			scarab_frequency = 0
		end
		respond "This session:\nTime: #{time_spent_picking}\nNumber of boxes: #{number_of_boxes_picked_this_session_pool_picking}\nNumber of scarabs: #{scarabs_received_this_session_pool_picking}\nSilver tips: #{commas_for_silvers_earned}\nScarab value (5k per scarab): #{total_scarab_value_commas}\nScarab frequency: #{scarab_frequency}%\nTotal silvers: #{silver_tips_plus_scarab_value_commas}\nSilvers earned per hour: #{silvers_earned_hour}"
		respond "####################################################################################################"
		grand_total_time_spent_actual_picking = (time_spent_pool_picking_this_session - time_to_subtract_from_actual_picking_time)
		t = grand_total_time_spent_actual_picking
		time_spent_picking = "%02d:%02d:%02d" % [t/3600%24, t/60%60, t%60]
		silvers_earned_hour = ((silver_tips_plus_scarab_value / grand_total_time_spent_actual_picking) * 3600).truncate
		silvers_earned_hour = silvers_earned_hour.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse
		respond "This session (not including time waiting for boxes):\nTime: #{time_spent_picking}\nSilvers earned per hour: #{silvers_earned_hour}"
		respond "####################################################################################################"
		t = CharSettings["total_time_spent_pool_picking"]
		time_spent_picking = "%02d:%02d:%02d" % [t/3600%24, t/60%60, t%60]
		total_scarab_value = (CharSettings["total_scarabs_received_pool_picking"] * 5000)
		silver_tips_plus_scarab_value = CharSettings["total_silvers_earned_from_pool_picking"] + total_scarab_value
		silvers_earned_hour = ((silver_tips_plus_scarab_value / CharSettings["total_time_spent_pool_picking"]) * 3600).truncate
		silvers_earned_hour = silvers_earned_hour.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse
		commas_for_silvers_earned = CharSettings["total_silvers_earned_from_pool_picking"].to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse
		total_scarab_value_commas = total_scarab_value.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse
		silver_tips_plus_scarab_value_commas = silver_tips_plus_scarab_value.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse
		scarab_frequency = (((CharSettings["total_scarabs_received_pool_picking"] *1.0) / CharSettings["number_of_total_boxes_picked_pool_picking"]) * 100).round(2)
		respond "Total:\nTime: #{time_spent_picking}\nNumber of boxes: #{CharSettings["number_of_total_boxes_picked_pool_picking"]}\nNumber of scarabs: #{CharSettings["total_scarabs_received_pool_picking"]}\nSilver tips: #{commas_for_silvers_earned}\nScarab value (5k per scarab): #{total_scarab_value_commas}\nScarab frequency: #{scarab_frequency}%\nTotal silvers: #{silver_tips_plus_scarab_value_commas}\nSilvers earned per hour: #{silvers_earned_hour}"
		respond "####################################################################################################"
		CharSettings['time_to_subtract_from_overall_actual_picking_time'] += time_to_subtract_from_actual_picking_time
		grand_total_time_spent_actual_picking = (CharSettings["total_time_spent_pool_picking"] - CharSettings['time_to_subtract_from_overall_actual_picking_time'])
		t = grand_total_time_spent_actual_picking
		time_spent_picking = "%02d:%02d:%02d" % [t/3600%24, t/60%60, t%60]
		silvers_earned_hour = ((silver_tips_plus_scarab_value / grand_total_time_spent_actual_picking) * 3600).truncate
		silvers_earned_hour = silvers_earned_hour.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse
		respond "Total (not including time waiting for boxes):\nTime: #{time_spent_picking}\nSilvers earned per hour: #{silvers_earned_hour}"
		respond "####################################################################################################"
	end
	if all_containers_to_close_before_exit.length > 1
		echo "I will close your containers as soon as you're out of RT then I will exit." if checkrt > 0
		wait_until { checkrt == 0 }
		all_containers_to_close_before_exit.each{ |i|
			i = i[1..-1] if i[0] == " "
			container_to_close = GameObj.inv.find{ |t| t.name == i }
			fput "close ##{container_to_close.id}" if container_to_close
		}
	end
	if $tpick_armor_has_been_removed
		echo "I will equip your armor as soon as you're out of RT then I will exit." if checkrt > 0
		wait_until { checkrt == 0 }
		tpick_put_stuff_away
		fput "get #{$tpick_remove_armor_before_casting_spell}"
		wait_until { checkright }
		fput "wear #{$tpick_remove_armor_before_casting_spell}"
	end
}

gem = nil
reagent = nil
herb = nil
food = nil
uncommon = nil
jewelry = nil
junk = nil
lockpick = nil
magic = nil
scroll = nil
wand = nil
armor = nil
weapon = nil
clothing = nil
other = nil

gem_number = Array.new
reagent_number = Array.new
herb_number = Array.new
food_number = Array.new
uncommon_number = Array.new
jewelry_number = Array.new
junk_number = Array.new
lockpick_number = Array.new
magic_number = Array.new
scroll_number = Array.new
wand_number = Array.new
armor_number = Array.new
weapon_number = Array.new
clothing_number = Array.new
other_number = Array.new

wealth_before = proc {
	action = proc { |server_string|
		if server_string =~ /^\s*Name\:|^\s*Gender\:|^\s*Normal \(Bonus\)|^\s*Strength \(STR\)\:|^\s*Constitution \(CON\)\:|^\s*Dexterity \(DEX\)\:|^\s*Agility \(AGI\)\:|^\s*Discipline \(DIS\)\:|^\s*Aura \(AUR\)\:|^\s*Logic \(LOG\)\:|^\s*Intuition \(INT\)\:|^\s*Wisdom \(WIS\)\:|^\s*Influence \(INF\)\:/
			nil
		elsif server_string =~ /^\s*Mana\:\s+\-?[0-9]+\s+Silver\:\s+([0-9]+)/
			silver_before = $1.to_i
			DownstreamHook.remove("#{script.name}_wealth_before")
			nil
		else
			server_string
		end
	}
		DownstreamHook.add("#{script.name}_wealth_before", action)
		silence_me
		fput "info"
		silence_me
}

wealth_after = proc{
	action = proc { |server_string|
		if server_string =~ /^\s*Name\:|^\s*Gender\:|^\s*Normal \(Bonus\)|^\s*Strength \(STR\)\:|^\s*Constitution \(CON\)\:|^\s*Dexterity \(DEX\)\:|^\s*Agility \(AGI\)\:|^\s*Discipline \(DIS\)\:|^\s*Aura \(AUR\)\:|^\s*Logic \(LOG\)\:|^\s*Intuition \(INT\)\:|^\s*Wisdom \(WIS\)\:|^\s*Influence \(INF\)\:/
			nil
		elsif server_string =~ /^\s*Mana\:\s+\-?[0-9]+\s+Silver\:\s+([0-9]+)/
			silver_after = $1.to_i
			DownstreamHook.remove("#{script.name}_wealth_after")
			nil
		else
			server_string
		end
	}
		DownstreamHook.add("#{script.name}_wealth_after", action)
		silence_me
		put "info"
		silence_me
}
					
get_wire_order_numbers = proc{
	move 'out' if checkpaths 'out'
	target_room = Room.current.find_nearest(toolbenches_room_number)
	start_script 'go2', [ target_room.to_s ]
	wait_while{ running?('go2') }
	move 'go toolbench'
	fput "read sign"
	while line = get
		if line =~ /\s*(\d+)\..*copper wire\s+(\d+)/
			$tpick_copper_wire = $1
			$tpick_copper_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*brass wire\s+(\d+)/
			$tpick_brass_wire = $1
			$tpick_brass_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*steel wire\s+(\d+)/
			$tpick_steel_wire = $1
			$tpick_steel_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*gold wire\s+(\d+)/
			$tpick_gold_wire = $1
			$tpick_gold_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*silver wire\s+(\d+)/
			$tpick_silver_wire = $1
			$tpick_silver_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*ora wire\s+(\d+)/
			$tpick_ora_wire = $1
			$tpick_ora_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*mithril wire\s+(\d+)/
			$tpick_mithril_wire = $1
			$tpick_mithril_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*laje wire\s+(\d+)/
			$tpick_laje_wire = $1
			$tpick_laje_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*alum wire\s+(\d+)/
			$tpick_alum_wire = $1
			$tpick_alum_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*vultite wire\s+(\d+)/
			$tpick_vultite_wire = $1
			$tpick_vultite_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*rolaren wire\s+(\d+)/
			$tpick_rolaren_wire = $1
			$tpick_rolaren_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*veniom wire\s+(\d+)/
			$tpick_veniom_wire = $1
			$tpick_veniom_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*kelyn wire\s+(\d+)/
			$tpick_kelyn_wire = $1
			$tpick_kelyn_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*invar wire\s+(\d+)/
			$tpick_invar_wire = $1
			$tpick_invar_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*golvern wire\s+(\d+)/
			$tpick_golvern_wire = $1
			$tpick_golvern_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*vaalin wire\s+(\d+)/
			$tpick_vaalin_wire = $1
			$tpick_vaalin_wire_cost = $2
		elsif line =~ /a thin bar of vaalin/
			break
		end
	end
	move 'out' if checkpaths 'out'
}

all_variables_to_check.each{|i|
	if i == "percent" || i =~ /\%/
		tip_is_a_percent = true
		break
	end
}

all_variables_to_check.each{|i|
	if i =~ /\d+/
		tip_being_offered = i.to_i
	end
}

all_variables_to_check.each{|i|
	if i == "drop"
		current_room = Room.current.id
		if worker.nil?
			echo "The \"drop\" command only works at locksmith pools."
			exit
		end
		if tip_being_offered.nil?
			echo "You need to specify how much you are tipping and if you want it to be a percent."
			echo "For example do \";tpick drop 100\" to tip 100 silvers per box, do \";tpick drop 10 percent\" or \";tpick drop 10%\" if you want to tip 10% per box"
			exit
		end
		if tip_is_a_percent && tip_being_offered > 100
			echo "Wise guy, huh? You can't tip more than 100%!"
			exit
		end
		tpick_put_stuff_away
		$tpick_boxes_checked = nil
		check_for_command = "inv full"
		check_for_boxes.call
		wait_until { $tpick_boxes_checked }
		total_number_of_boxes = $tpick_list_of_box_ids.length
		count_boxes_in_disk.call
		echo "Total number of boxes: #{total_number_of_boxes}"
		if total_number_of_boxes == 0
			echo "You don't have any boxes!"
			exit
		end
		if tip_is_a_percent
			echo "You are tipping #{tip_being_offered}% for each box."
			sleep 1
			start_script 'go2', [ 'bank', '--disable-confirm' ]
			wait_while{ running?('go2') }
			fput "depo all"
			fput "withdraw #{2000 * total_number_of_boxes} silvers"
			start_script 'go2', [ current_room ]
			wait_while{ running?('go2') }
			$tpick_list_of_box_ids.each{ |box|
				fput "get ##{box}"
				fput "give #{worker} #{tip_being_offered} percent"
				fput "give #{worker} #{tip_being_offered} percent"
			}
		else
			echo "You are tipping #{tip_being_offered} silvers for each box for a total tip needed of #{tip_being_offered * total_number_of_boxes}"
			sleep 1
			start_script 'go2', [ 'bank', '--disable-confirm' ]
			wait_while{ running?('go2') }
			fput "depo all"
			fput "withdraw #{tip_being_offered * total_number_of_boxes} silvers"
			start_script 'go2', [ current_room ]
			wait_while{ running?('go2') }
			$tpick_list_of_box_ids.each{ |box|
				fput "get ##{box}"
				fput "give #{worker} #{tip_being_offered}"
				fput "give #{worker} #{tip_being_offered}"
			}
		end
		exit
	end
}

all_variables_to_check.each{|i|
	if i == "return" || i == "pickup"
		if worker.nil?
			echo "This command only works at locksmith pools."
			exit
		end
		tpick_put_stuff_away
		loop{
			fput "ask #{worker} about return"
			while line = get
				if line =~ /We don\'t have any boxes ready for you/
					exit
				elsif line =~ /here\'s your .* back/
					wait_until { checkright }
					picking_up = true
					sleep 0.2
					lootbox = GameObj.right_hand
					fput "open ##{lootbox.id}"
					lootbox.contents.each{|item|
						current_item = item
						waitrt?
						if (item.name !~ /urglaes fang/) && (item.name !~ /doomstone/)
							gather_stuff.call
						end
					}
					tpick_put_stuff_away
					break
				end
			end
		}
	exit
	end
}

if (CharSettings['setup_required_again_for_version_332'].nil? || UserVars.tpick.nil?) && (script.vars[1] != 'setup')
	10.times { echo "The options in the setup menu have changed for Version 332, be sure to do ;tpick setup and check all settings, particularly the new settings and changes to existing settings under the \"Containers\" tab. If you have ,close listed after any container be sure to delete ,close as it is no longer required, instead just list the full name of each container and check out the new open and close settings under the same tab.\n\n"}
	exit
end
if script.vars[1] == 'setup'
	setup.call
	exit
end

if UserVars.tpick["trap_roll"].length <= 0 || UserVars.tpick["lock_roll"].length <= 0 || UserVars.tpick["vaalin_lock_roll"].length <= 0
	echo "One or more of the following settings isn't setup properly: Trap Roll, Lock Roll, Vaalin Lock Roll."
	echo "These settings are found in the \"Options\" tab of the setup menu. Run ;tpick setup, click on the \"Options\" tab, read the instructions on the bottom, and please fill in these values."
	exit
end

if script.vars[1] =~ /stat/
	stats_check.call
	exit
end

if (UserVars.tpick["gnomish_bracer"] != "nil") && (UserVars.tpick["gnomish_bracer"] != nil) && (UserVars.tpick["gnomish_bracer"].length > 1)
	bracers_temp = UserVars.tpick["gnomish_bracer"].split(",")
	bracers_name = bracers_temp[0]
	bracers_tier = bracers_temp[1]
	override_bracers = bracers_temp[2]
	gnomish_bracers = bracers_name
end

all_containers_open_to_start = UserVars.tpick["containers_open_to_start"].split(",")
if all_containers_open_to_start
	all_containers_open_to_start.each{ |i|
		i.strip!
		i.rstrip!
		container_to_open = GameObj.inv.find{ |t| t.name == i }
		fput "open ##{container_to_open.id}" if container_to_open
	}
end

if UserVars.tpick["pool_picking_rest_when_fried"].length > 1
	pool_picking_fried_commands = UserVars.tpick["pool_picking_rest_when_fried"].split(":")
	pool_picking_fried_commands[0].strip!
	pool_picking_fried_commands[0].rstrip!
	pool_picking_fried_commands[1].strip!
	pool_picking_fried_commands[1].rstrip!
end

@tpick_lockpick_container = GameObj.inv.find{ |i| i.name =~ /#{UserVars.tpick["lockpick_container"]}/ }
@tpick_broken_lockpick_container = GameObj.inv.find{ |i| i.name =~ /#{UserVars.tpick["broken_lockpick_container"]}/ }
@tpick_wedge_container = GameObj.inv.find{ |i| i.name =~ /#{UserVars.tpick["wedge_container"]}/ }
@tpick_calipers_container = GameObj.inv.find{ |i| i.name =~ /#{UserVars.tpick["calipers_container"]}/ }
@tpick_scale_weapon_container = GameObj.inv.find{ |i| i.name =~ /#{UserVars.tpick["scale_weapon_container"]}/ }
@tpick_locksmiths_container = GameObj.inv.find{ |i| i.name =~ /#{UserVars.tpick["locksmiths_container"]}/ }

fput "stow right" if checkright
fput "stow left" if checkleft

@all_other_container_options = nil
@all_other_container_options = UserVars.tpick["all_other_containers"].split(",")

if UserVars.tpick["calibratecount"] =~ /auto/i
	calibrate_auto_amount = UserVars.tpick["calibratecount"].split(" ")
	calibrate_auto_amount = calibrate_auto_amount[1].to_i
end

$tpick_boxes_checked = nil
check_for_lockpicks_etc.call
wait_until { $tpick_boxes_checked }
$copper_lockpick_id = copper_lock_pick_array.first
$steel_lockpick_id = steel_lock_pick_array.first
$gold_lockpick_id = gold_lock_pick_array.first
$silver_lockpick_id = silver_lock_pick_array.first
$mithril_lockpick_id = mithril_lock_pick_array.first
$ora_lockpick_id = ora_lock_pick_array.first
$glaes_lockpick_id = glaes_lock_pick_array.first
$laje_lockpick_id = laje_lock_pick_array.first
$vultite_lockpick_id = vultite_lock_pick_array.first
$rolaren_lockpick_id = rolaren_lock_pick_array.first
$veniom_lockpick_id = veniom_lock_pick_array.first
$invar_lockpick_id = invar_lock_pick_array.first
$alum_lockpick_id = alum_lock_pick_array.first
$golvern_lockpick_id = golvern_lock_pick_array.first
$kelyn_lockpick_id = kelyn_lock_pick_array.first
$vaalin_lockpick_id = vaalin_lock_pick_array.first

@tpick_all_lockpick_id_arrays = [ copper_lock_pick_array, steel_lock_pick_array, gold_lock_pick_array, silver_lock_pick_array, mithril_lock_pick_array, ora_lock_pick_array, glaes_lock_pick_array, laje_lock_pick_array, vultite_lock_pick_array, rolaren_lock_pick_array, veniom_lock_pick_array, invar_lock_pick_array, alum_lock_pick_array, golvern_lock_pick_array, kelyn_lock_pick_array, vaalin_lock_pick_array ]

(echo "Couldn't find your copper lockpick";sleep 2) if $copper_lockpick_id.nil? && UserVars.tpick["copper"] != "nil" && UserVars.tpick["copper"].length > 1
(echo "Couldn't find your steel lockpick";sleep 2) if $steel_lockpick_id.nil? && UserVars.tpick["steel"] != "nil" && UserVars.tpick["steel"].length > 1
(echo "Couldn't find your gold lockpick";sleep 2) if $gold_lockpick_id.nil? && UserVars.tpick["gold"] != "nil" && UserVars.tpick["gold"].length > 1
(echo "Couldn't find your silver lockpick";sleep 2) if $silver_lockpick_id.nil? && UserVars.tpick["silver"] != "nil" && UserVars.tpick["silver"].length > 1
(echo "Couldn't find your mithril lockpick";sleep 2) if $mithril_lockpick_id.nil? && UserVars.tpick["mithril"] != "nil" && UserVars.tpick["mithril"].length > 1
(echo "Couldn't find your ora lockpick";sleep 2) if $ora_lockpick_id.nil? && UserVars.tpick["ora"] != "nil" && UserVars.tpick["ora"].length > 1
(echo "Couldn't find your glaes lockpick";sleep 2) if $glaes_lockpick_id.nil? && UserVars.tpick["glaes"] != "nil" && UserVars.tpick["glaes"].length > 1
(echo "Couldn't find your laje lockpick";sleep 2) if $laje_lockpick_id.nil? && UserVars.tpick["laje"] != "nil" && UserVars.tpick["laje"].length > 1
(echo "Couldn't find your vultite lockpick";sleep 2) if $vultite_lockpick_id.nil? && UserVars.tpick["vultite"] != "nil" && UserVars.tpick["vultite"].length > 1
(echo "Couldn't find your rolaren lockpick";sleep 2) if $rolaren_lockpick_id.nil? && UserVars.tpick["rolaren"] != "nil" && UserVars.tpick["rolaren"].length > 1
(echo "Couldn't find your veniom lockpick";sleep 2) if $veniom_lockpick_id.nil? && UserVars.tpick["veniom"] != "nil" && UserVars.tpick["veniom"].length > 1
(echo "Couldn't find your invar lockpick";sleep 2) if $invar_lockpick_id.nil? && UserVars.tpick["invar"] != "nil" && UserVars.tpick["invar"].length > 1
(echo "Couldn't find your alum lockpick";sleep 2) if $alum_lockpick_id.nil? && UserVars.tpick["alum"] != "nil" && UserVars.tpick["alum"].length > 1
(echo "Couldn't find your golvern lockpick";sleep 2) if $golvern_lockpick_id.nil? && UserVars.tpick["golvern"] != "nil" && UserVars.tpick["golvern"].length > 1
(echo "Couldn't find your kelyn lockpick";sleep 2) if $kelyn_lockpick_id.nil? && UserVars.tpick["kelyn"] != "nil" && UserVars.tpick["kelyn"].length > 1
(echo "Couldn't find your vaalin lockpick";sleep 2) if $vaalin_lockpick_id.nil? && UserVars.tpick["vaalin"] != "nil" && UserVars.tpick["vaalin"].length > 1
(echo "Couldn't find your scale trap weapon";sleep 2) if $scale_trap_weapon_id.nil? && UserVars.tpick["scale_trap_weapon"] != "nil" && UserVars.tpick["scale_trap_weapon"].length > 1

if script.vars[1] =~ /buy/
	check_locksmiths_container.call
	wait_until { putty_remaining }
	wait_until { cotton_remaining }
	start_script "sorter" if start_sorter
	if putty_remaining >= 100 && cotton_remaining >= 100
		echo "You already have 100 each of putty and cotton balls."
		exit
	else
		if Wounds.lhand >= 3 || Wounds.rhand >= 3 || Wounds.larm >= 3 || Wounds.rarm >= 3 || Scars.lhand >= 3 || Scars.rhand >= 3 || Scars.larm >= 3 || Scars.rarm >= 3 
			echo "Your wounds are too great to do this task. You can't have a missing hand or arm to do this."
			exit
		else
			tpick_put_stuff_away
			fill_up_locksmith_container.call
		end
	end
	exit
end

repair_stuff_and_stuff = proc{
	result = dothistimeout "look ##{current_pick_to_check}", 1, /The.*appears to be broken\.|You see nothing unusual\.|I could not find what you were referring to\.|appears to be somewhat damaged/
	if result =~ /The.*appears to be broken\./
		if $tpick_vaalin_wire == nil
			get_wire_order_numbers.call
		end
		if number == 1
			lockpick_type = "vaalin"
			current_wire = $tpick_vaalin_wire
			current_wire_cost = $tpick_vaalin_wire_cost
		elsif number == 2
			lockpick_type = "kelyn"
			current_wire = $tpick_kelyn_wire
			current_wire_cost = $tpick_kelyn_wire_cost
		elsif number == 3
			lockpick_type = "golvern"
			current_wire = $tpick_golvern_wire
			current_wire_cost = $tpick_golvern_wire_cost
		elsif number == 4
			lockpick_type = "alum"
			current_wire = $tpick_alum_wire
			current_wire_cost = $tpick_alum_wire_cost
		elsif number == 5
			lockpick_type = "invar"
			current_wire = $tpick_invar_wire
			current_wire_cost = $tpick_invar_wire_cost
		elsif number == 6
			lockpick_type = "veniom"
			current_wire = $tpick_veniom_wire
			current_wire_cost = $tpick_veniom_wire_cost
		elsif number == 7
			lockpick_type = "rolaren"
			current_wire = $tpick_rolaren_wire
			current_wire_cost = $tpick_rolaren_wire_cost
		elsif number == 8
			lockpick_type = "vultite"
			current_wire = $tpick_vultite_wire
			current_wire_cost = $tpick_vultite_wire_cost
		elsif number == 9
			lockpick_type = "laje"
			current_wire = $tpick_laje_wire
			current_wire_cost = $tpick_laje_wire_cost
		elsif number == 10
			lockpick_type = "ora"
			current_wire = $tpick_ora_wire 
			current_wire_cost = $tpick_ora_wire_cost
		elsif number == 11
			lockpick_type = "mithril"
			current_wire = $tpick_mithril_wire 
			current_wire_cost = $tpick_mithril_wire_cost
		elsif number == 12
			lockpick_type = "silver"
			current_wire = $tpick_silver_wire
			current_wire_cost = $tpick_silver_wire_cost
		elsif number == 13
			lockpick_type = "gold"
			current_wire = $tpick_gold_wire
			current_wire_cost = $tpick_gold_wire_cost
		elsif number == 14
			lockpick_type = "steel"
			current_wire = $tpick_steel_wire
			current_wire_cost = $tpick_steel_wire_cost
		elsif number > 14
			lockpick_type = "copper"
			current_wire = $tpick_copper_wire
			current_wire_cost = $tpick_copper_wire_cost
		end
		fput "get ##{current_pick_to_check}"
		move 'out' if checkpaths 'out'
		start_script 'go2', [ 'bank', '--disable-confirm' ]
		wait_while{ running?('go2') }
		multifput "depo all", "withdraw #{current_wire_cost} silvers"
		target_room = Room.current.find_nearest(toolbenches_room_number)
		start_script 'go2', [ target_room.to_s ]
		wait_while{ running?('go2') }
		move 'go toolbench'
		waitrt?
		fput "order #{current_wire}"
		fput "buy"
		waitrt?
		result = dothistimeout "lmas repair ##{current_pick_to_check}", 2, /cooling rapidly to form a tight bond|but the broken tip refuses to work free/
		if result =~ /cooling rapidly to form a tight bond/
			waitrt?
			fput "put ##{current_pick_to_check} in ##{@tpick_lockpick_container.id}"
		elsif result =~ /but the broken tip refuses to work free/
			echo "This lockpick cannot be repaired."
			exit
		elsif result.nil?
			echo "Didn't recognize any game lines."
			exit
		end
	elsif result =~ /You see nothing unusual\.|I could not find what you were referring to\.|appears to be somewhat damaged/
		nil
	end
}

def tpick_put_stuff_away
	both_hands = [ GameObj.right_hand, GameObj.left_hand]
	both_hands.each{ |item|
		if item.name != "Empty" && (item.id != @tpick_current_box.id || @tpick_stow_current_box)
			container_id_to_stow_item_in = nil
			short_name_container = nil
			if @tpick_all_lockpick_id_arrays.any?{ |i| i.include?(item.id) }
				if @tpick_lockpick_is_broken
					container_id_to_stow_item_in = @tpick_broken_lockpick_container.id
				else
					container_id_to_stow_item_in = @tpick_lockpick_container.id
				end
			elsif item.name =~ /wedge/
				container_id_to_stow_item_in = @tpick_wedge_container.id
			elsif item.name =~ /caliper/
				container_id_to_stow_item_in = @tpick_calipers_container.id
			elsif item.id == $scale_trap_weapon_id
				container_id_to_stow_item_in = @tpick_scale_weapon_container.id
			end
			if container_id_to_stow_item_in.nil? && @all_other_container_options.length > 1
				name_match = nil
				type_match = nil
				name_match_container_full_name = nil
				name_match_container_short_name = nil
				type_match_container_full_name = nil
				type_match_container_short_name = nil
				@all_other_container_options.each{ |i|
					i.strip!
					i.rstrip!
					i = i.split(":")
					i[1].strip!
					i[1].rstrip!
					if item.name =~ /#{i[0]}/
						name_match_container_full_name = GameObj.inv.find{ |t| t.name == i[1] }
						name_match_container_short_name = i[1]
						name_match = true
					elsif item.type =~ /#{i[0]}/
						type_match_container_full_name = GameObj.inv.find{ |t| t.name == i[1] }
						type_match_container_short_name = i[1]
						type_match = true
					end
					break if name_match && type_match
				}
				if name_match
					if name_match_container_full_name
						container_id_to_stow_item_in = name_match_container_full_name.id
					else
						short_name_container = name_match_container_short_name
					end
				else
					if type_match_container_full_name
						container_id_to_stow_item_in = type_match_container_full_name.id
					else
						short_name_container = type_match_container_short_name
					end
				end
			end
			if container_id_to_stow_item_in || short_name_container
				3.times{
					waitrt?
					unless GameObj.right_hand.id != item.id && GameObj.left_hand.id != item.id
						if container_id_to_stow_item_in
							fput "put ##{item.id} in ##{container_id_to_stow_item_in}"
						else
							fput "put ##{item.id} in my #{short_name_container}"
						end
						sleep 0.2
					end
				}
				echo "Couldn't put #{item.name} in its proper container, STOWing it instead." if GameObj.right_hand.id == item.id || GameObj.left_hand.id == item.id
			end
			until GameObj.right_hand.id != item.id && GameObj.left_hand.id != item.id
				waitrt?
				fput "stow ##{item.id}"
				sleep 0.2
			end
		end
	}
	@tpick_stow_current_box = nil
	@tpick_lockpick_is_broken = nil
end
	
def tpick_stow_armor
	if $tpick_remove_armor_before_casting_spell && $tpick_armor_has_been_removed.nil? && checkroom !~ /table/i
		$tpick_armor_has_been_removed = true
		wait_until { checkrt == 0 }
		fput "remove #{$tpick_remove_armor_before_casting_spell}"
		fput "stow #{$tpick_remove_armor_before_casting_spell}"
	end
end

def tpick_cast_spells (number)
	if @percentage_of_mana_to_keep > percentmana
		echo "According to your settings your current mana is too low to cast spells."
	else
		if Spell[number].known? && 0.10 > Spell[number].timeleft
			if number == 1035 && !Spell[number].affordable?
				nil
			else
				until 0.10 < Spell[number].timeleft
					if !Spell[number].affordable?
						echo "Waiting for mana."
						wait_until { Spell[number].affordable? }
					end
					tpick_stow_armor
					Spell[number].cast
					sleep 0.2
				end
			end
		end
	end
end

def tpick_prep_spell(number, name)
	if Spell[number].known?
		if !Spell[number].affordable?
			echo "Waiting for mana."
			wait_until { Spell[number].affordable? }
		end
		until checkprep == "#{name}"
			waitrt?
			waitcastrt?
			fput "release" if checkprep !~ /None|#{name}/i
			fput "prep #{number}"
			sleep 0.2
		end
	end
end

def tpick_drop_box(current_box)
	if GameObj.right_hand.id == current_box.id
		until checkright.nil?
			waitrt?
			fput "drop ##{current_box.id}"
			sleep 0.2
		end
	else
		until checkleft.nil?
			waitrt?
			fput "drop ##{current_box.id}"
			sleep 0.2
		end
	end
end

def tpick_get_box(current_box)
	until GameObj.right_hand.id == current_box.id || GameObj.left_hand.id == current_box.id
		waitrt?
		fput "get ##{current_box.id}"
		sleep 0.2
	end
end

def tpick_stop_403_404		
	waitrt?
	fput "stop 403" if Spell[403].active? && ($tpick_use_403_cancel =~ /cancel/i || UserVars.tpick["always_use_403"] =~ /cancel/i)
	fput "stop 404" if Spell[404].active? && ($tpick_use_404_cancel =~ /cancel/i || UserVars.tpick["always_use_404"] =~ /cancel/i)
end

def tpick_stow_box(current_box)
	until GameObj.right_hand.id != current_box.id && GameObj.left_hand.id != current_box.id
		waitrt?
		fput "stow ##{current_box.id}"
		sleep 0.2
	end
end

def tpick_say_cant
	fput "say #{UserVars.tpick["cant_open_box"]}" if UserVars.tpick["cant_open_box"] != "nil" && UserVars.tpick["cant_open_box"].length > 0
end

def tpick_say_scarab_found
	fput "say #{UserVars.tpick["scarab_found"]}" if UserVars.tpick["scarab_found"] != "nil" && UserVars.tpick["scarab_found"].length > 0
end

def tpick_say_scarab_safe
	fput "say #{UserVars.tpick["scarab_safe"]}" if UserVars.tpick["scarab_safe"] != "nil" && UserVars.tpick["scarab_safe"].length > 0
end

if script.vars[1] =~ /repair/ && Char.prof =~ /Rogue/
	tpick_put_stuff_away
	number = 1
	vaalin_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	kelyn_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	golvern_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	alum_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	invar_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	veniom_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	rolaren_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	vultite_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	laje_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	ora_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	mithril_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	silver_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	gold_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	steel_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	copper_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	move 'out' if checkroom =~ /workbench/i
	exit
elsif script.vars[1] =~ /repair/ && Char.prof !~ /Rogue/
	echo "Only rogues can repair lockpicks."
	exit
end

if @tpick_locksmiths_container
	check_locksmiths_container.call
	wait_until { putty_remaining }
	wait_until { cotton_remaining }
	wait_until { vials_remaining }
	echo "Putty remaining: #{putty_remaining}"
	echo "Cotton balls remaining: #{cotton_remaining}"
	echo "Vials of acid remaining: #{vials_remaining}"
	start_script "sorter" if start_sorter
end

if (script.vars[1] == "reset" || script.vars[2] == "reset" || script.vars[3] == "reset" || script.vars[4] == "reset" || script.vars[5] == "reset" || script.vars[6] == "reset" || script.vars[7] == "reset" || script.vars[8] == "reset" || script.vars[9] == "reset" || script.vars[10] == "reset")
	reset_math.call
end

if Char.prof =~ /Rogue/
	can_use_calipers = true
	if (UserVars.tpick["trick"] == "spin" or UserVars.tpick["trick"] == "twist" or UserVars.tpick["trick"] == "turn" or UserVars.tpick["trick"] == "twirl" or UserVars.tpick["trick"] == "toss" or UserVars.tpick["trick"] == "bend" or UserVars.tpick["trick"] == "flip")
		do_trick = "lmas ptrick #{UserVars.tpick["trick"]}"	
	elsif UserVars.tpick["trick"] == "pick"
		do_trick = "pick"
	elsif UserVars.tpick["trick"] == "random"
		nil
	else
		(echo "Wrong value for TRICK in settings. Type ;tpick setup and enter spin, twist, turn, twirl, toss, bend, flip, pick, or random for the TRICK setting.";exit)
	end
else
	can_use_calipers = nil
	UserVars.tpick["calibrate"] = "no"
	do_trick = "pick"
end

tpick_put_stuff_away
calibrate_count = 0

if UserVars.tpick["max_lock"] =~ /\d+/ && UserVars.tpick["max_lock"] =~ /\-/
	temp_max_lock = UserVars.tpick["max_lock"].split("-")
	max_lock_attempt = temp_max_lock[1].to_i
	echo "Max lock: #{max_lock_attempt}"
	max_lock_attempt_compared_to_max_skill = true
elsif UserVars.tpick["max_lock"] =~ /\d+/
	max_lock_attempt = UserVars.tpick["max_lock"].to_i
end

if Spell[205].known? && UserVars.tpick["always_use_205"] == "yes"
	use_spell_205 = true
end

if Spell[402].known? && UserVars.tpick["always_use_402"] == "yes"
	use_spell_402 = true
end

if Spell[403].known?
	if UserVars.tpick["always_use_403"] =~ /\,/
		temp_403_variable = UserVars.tpick["always_use_403"].split(",")
		if temp_403_variable[0] =~ /\d+/
			use_403_for_lock_difficulty = temp_403_variable[0].to_i
		elsif temp_403_variable[1] =~ /\d+/
			use_403_for_lock_difficulty = temp_403_variable[1].to_i
		end
		$tpick_use_403_cancel = "cancel" if temp_403_variable[0] =~ /cancel/i || temp_403_variable[1] =~ /cancel/i
	else
		if UserVars.tpick["always_use_403"] =~ /\d+/
			use_403_for_lock_difficulty = UserVars.tpick["always_use_403"].to_i
		elsif UserVars.tpick["always_use_403"] == "yes"
			use_spell_403 = true
		end
	end
end

if Spell[404].known?
	if UserVars.tpick["always_use_404"] =~ /\,/
		temp_404_variable = UserVars.tpick["always_use_404"].split(",")
		if temp_404_variable[0] =~ /\d+/
			use_404_for_trap_difficulty = temp_404_variable[0].to_i
		elsif temp_404_variable[1] =~ /\d+/
			use_404_for_trap_difficulty = temp_404_variable[1].to_i
		end
		$tpick_use_404_cancel = "cancel" if temp_404_variable[0] =~ /cancel/i || temp_404_variable[1] =~ /cancel/i
	else
		if UserVars.tpick["always_use_404"] =~ /\d+/
			use_404_for_trap_difficulty = UserVars.tpick["always_use_404"].to_i
		elsif UserVars.tpick["always_use_404"] == "yes"
			use_spell_404 = true
		end
	end
end

use_unlock_407_settings = UserVars.tpick["always_use_407"].split(",")
use_unlock_407_settings[0].strip!
use_unlock_407_settings[0].rstrip!
use_unlock_407_settings[1].strip!
use_unlock_407_settings[1].rstrip!

use_spell_1035 = true if Spell[1035].known? && UserVars.tpick["always_use_1035"] == "yes"
use_spell_613 = true if Spell[613].known? && UserVars.tpick["always_use_613"] == "yes"
use_spell_704 = true if Spell[704].known? && UserVars.tpick["always_use_704"] == "yes"
use_spell_1006 = true if Spell[1006].known? && UserVars.tpick["always_use_1006"] == "yes"

if UserVars.tpick["percent_mana_to_keep"] =~ /\d+/
	@percentage_of_mana_to_keep = UserVars.tpick["percent_mana_to_keep"].to_i
else
	@percentage_of_mana_to_keep = -100
end

all_variables_to_check.each{|i|
	if i == "loot"
		ground_loot = true
		wealth_before.call
		wait_until { silver_before }
		break
	end
}

max_roll_attempt_before_moving_to_new_pick = UserVars.tpick["max_lock_roll"].to_i if UserVars.tpick["max_lock_roll"].length > 0 && UserVars.tpick["max_lock_roll"] =~ /\d+/

minimum_tip_wanted = UserVars.tpick["minimum_tip_wanted"].to_i if UserVars.tpick["minimum_tip_wanted"].length > 0
max_critter_level = UserVars.tpick["max_critter_level"].to_i if UserVars.tpick["max_critter_level"].length > 0

all_variables_to_check.each{|i|
	if i =~ /\d+/ && i !~ /level/i
		minimum_tip_wanted = i.to_i
	end
}

all_variables_to_check.each{|i|
	if i =~ /level(\d+)/i
		max_critter_level = $1.to_i
	end
}

temp_minimum_tip_stuff = UserVars.tpick["minimum_tip_wanted"].split(",")
minimum_tip_start = temp_minimum_tip_stuff[0].to_i
minimum_tip_subtract = temp_minimum_tip_stuff[1].to_i
minimum_tip_floor = temp_minimum_tip_stuff[2].to_i
minimum_tip_current = minimum_tip_start if minimum_tip_start

echo "Max level wanted: #{max_critter_level}" if max_critter_level != 1000

all_variables_to_check.each{|i|
	if i =~ /plin/
		open_plinites = true
		break
	end
}

all_variables_to_check.each{|i|
	if i == "v"
		always_use_vaalin = true
		break
	end
}

all_variables_to_check.each{|i|
	if i == "wedge"
		always_use_wedge = true
		break
	end
}

all_variables_to_check.each{|i|
	if i == "c"
		start_with_copper = true
		break
	end
}

always_use_vaalin = true if UserVars.tpick["calibrate"] =~ /never/i && start_with_copper.nil?

if (always_use_vaalin) && (start_with_copper)
	start_with_copper = nil
end

if (Char.prof !~ /Rogue|Bard/) && (start_with_copper == nil)
	always_use_vaalin = true
end

if UserVars.tpick["picks_to_use_based_on_critter_level"].length > 0 && always_use_vaalin
	picks_to_use_based_on_critter_level = UserVars.tpick["picks_to_use_based_on_critter_level"].split(",")
	picks_information_text = "Your picks to use based on critter level settings: "
	number = 0
	picks_to_use_based_on_critter_level.each{ |i|
		temp_picks_critter_level = i.split(" ")
		if number == 0
			picks_information_text += "Levels #{number}-#{temp_picks_critter_level[0]}: #{temp_picks_critter_level[1]}. "
		else
			picks_information_text += "Levels #{number + 1}-#{temp_picks_critter_level[0]}: #{temp_picks_critter_level[1]}. "
		end
		number = temp_picks_critter_level[0].to_i
	}
	picks_information_text += "All higher levels: vaalin"
end
	
all_variables_to_check.each{|i|
	if i == "bash"
		if open_plinites
			echo "Bash feature cannot be used when opening plinites."
			exit
		end
		bash_open_boxes = true
		break
	end
}

all_variables_to_check.each{ |i|
	if i =~ /worker/i
		solo_or_other = "worker"
		break
	end
}

all_variables_to_check.each{ |i|
	if i =~ /ground/i
		solo_or_other = "ground"
		break
	end
}

all_variables_to_check.each{ |i|
	if i =~ /other/i
		solo_or_other = "other"
		break
	end
}

if (bash_open_boxes) && (Char.prof != "Warrior")
	echo "Only warriors can bash boxes."
	exit
end

all_variables_to_check.each{|i|
	if i == "disarm"
		if open_plinites
			echo "Disarm feature cannot be used when opening plinites."
			exit
		end
		disarm_only = true
		break
	end
}

all_variables_to_check.each{|i|
	if i == "relock"
		if open_plinites
			echo "Relock feature cannot be used when opening plinites."
			exit
		end
		relock_boxes = true
		break
	end
}

if (relock_boxes) && (bash_open_boxes)
	echo "\"relock\" and \"bash\" cannot both be used together."
	exit
end

all_variables_to_check.each{|i|
	if i == "pop"
		if open_plinites
			echo "Popping feature cannot be used when opening plinites."
			exit
		end
		popping = true
		break
	end
}

if popping && !Spell[416].known?
	echo "This feature requires the knowledge of Piercing Gaze (416)."
	exit
end

if popping && (UserVars.tpick["always_use_704"].nil? || UserVars.tpick["number_of_416_casts"].nil? || UserVars.tpick["only_disarm_safe"].nil? || UserVars.tpick["always_use_704"].empty? || UserVars.tpick["number_of_416_casts"].empty? || UserVars.tpick["only_disarm_safe"].empty?)
	echo "This feature requires all settings in the Popping tab in setup to be filled out before using."
	exit
end

(cast_205.call) if (use_spell_205) && (Spell[205].known?)

if solo_or_other == "ground" || bash_open_boxes
	if open_plinites
		echo "Ground feature cannot be used when opening plinites."
		exit
	end
	calibrate.call if (UserVars.tpick["calibrate"] == "yes") && (always_use_vaalin == nil) && (popping == nil) && (can_use_calipers) && (start_with_copper == nil)
	start_ground.call
elsif solo_or_other == "other"
	if open_plinites
		echo "Other feature cannot be used when opening plinites."
		exit
	end
	if popping
		echo "Popping feature does not work when popping other people's boxes."
		exit
	end
	if (disarm_only) && (bash_open_boxes == nil)
		echo "Disarm only feature only works for ground picking."
		exit
	end
	fput "say #{UserVars.tpick["ready"]}" if UserVars.tpick["ready"] != "nil"
	start_others.call
elsif solo_or_other == "worker"
	if open_plinites
		echo "Worker feature cannot be used when opening plinites."
		exit
	end
	if popping
		echo "Popping feature does not work when popping other people's boxes."
		exit
	end
	if (disarm_only) && (bash_open_boxes == nil)
		echo "Disarm only feature only works for ground picking."
		exit
	end
	calibrate.call if (UserVars.tpick["calibrate"] == "yes") && (always_use_vaalin == nil) && (popping == nil) && (can_use_calipers) && (start_with_copper == nil)
	echo "#{picks_information_text}" if picks_to_use_based_on_critter_level
	worker_start_picking_time = Time.now
	start_worker.call
else
	if (disarm_only) && (bash_open_boxes == nil)
		echo "Disarm only feature only works for ground picking."
		exit
	end
	solo_or_other = "solo"
	wealth_before.call
	wait_until { silver_before }
	$tpick_boxes_checked = nil
	check_for_command = "inv full"
	check_for_boxes.call
	wait_until { $tpick_boxes_checked }
	if popping
		pop_start.call
	elsif open_plinites
		start_plinites.call
	else
		calibrate.call if (UserVars.tpick["calibrate"] == "yes") && (always_use_vaalin == nil) && (popping == nil) && (can_use_calipers) && (start_with_copper == nil)
		start_solo.call
	end
end