=begin

	This script fulfills all of your lockpicking needs!
	
	It will automatically disarm traps and pick locks. It has 4 different picking modes:
	
	;tpick solo: will open boxes in all of your open containers and your disk.
	;tpick other: will accept boxes handed to you, pick them, then hand them back to the person who handed you the box.
	;tpick ground: will pick all boxes on the ground but will not take loot out of them. Do ;tpick ground loot to also loot the boxes.
	;tpick worker: will get boxes from the worker and pick them.
	Starting script as just ';tpick' will give you some basic instructions on how to use the script.

	Script has many other settings and features, too many to list here. Do ;tpick help to see all of them.
		
	Changelog:
	See previous revisions to script here: http://forum.gsplayers.com/showthread.php?128853-Official-tpick-changes-and-discussion&p=2203268#post2203268
	Version 371: Added "woodstove" to the list of trash containers. Also script can now find trash containers if they are part of the room's description.
	Version 372: Added messaging for when a Sulphur trap has already been set off when trying to DETECT a trap.
	Version 373: Messages from the script should now properly use MONSTERBOLD in StormFront FE.
	Version 374: Fixed bug with script not using Lock Mastery Focus on traps which are higher than base disarm skill level.
	Version 375: Script can now find your lockpicks in your vambraces.
	Version 376: Fixed issue with script sometimes hanging when trying to pick a box while still in roundtime.
	Version 377: Added message about worker saying to wait 10 mintues for new boxes to the script.
	Version 378: Removed all of the warnings about the script settings not being setup properly and removed the script looking for lockpicks if using the drop or pickup/return commands. This way you can drop off boxes and pick up boxes at the locksmith's pool without having to fiddle with any settings.
	Version 379: Fixed bugs with picking boxes up from the locksmith's pool. Everything regarding dropping off and picking up boxes from locksmith's pool should be working now.
	Version 380: Fixed various issues with dropping off and picking up boxes from the locksmith's pool.
	Version 381: Bug fix.
	Version 382: Script should now auotmatically deposit silvers in bank when picking up boxes and locksmith NPC says you have to lighten your load before accepting boxes back.
	Version 383: More bug fixes. Also trash boxes option should now work for picking up boxes at the locksmith pool.
	Version 384: Fixed bug with lmaster focus not being stopped when it should.
	Version 385: ;tpick stats provides many more stats now.
	Version 386: Bug fixes.
	Version 387: Bug fix in regards to always using a vaalin lockpick as a rogue.
	Version 388: Integration with ;rogues script.
	Version 389: More integration with ;rogues script.
	Version 390: More integration with ;rogues script.
	Version 391: New spell option under "Spells" tab: Disarm (408). Enter "scarab" in this setting to use 408 to disarm scarabs ONLY WHEN THEY ARE ON THE GROUND. This is currently the only use for this setting.
	Version 392: Added a mana check for casting 408.
	Version 393: More integration with ;rogues script.
	Version 394: Bug fix with script having trouble finding lockpicks on keyrings.
	
	To do list:
		
	########################################################
	Ways to contact me:
	In game: Dreaven
	Player's Corner: Tgo01
	Discord: Dreaven#6436
	Email: LordDreaven@gmail.com
	If you like my scripts feel free to send me a tip via Paypal at: LordDreaven@gmail.com
	########################################################
	
	Author: Dreaven
	Version: 394

=end

lich_up_to_date = nil
version = LICH_VERSION.split(".")
if version[0].to_i > 4
	lich_up_to_date = true
elsif version[1].to_i > 6
	lich_up_to_date = true
elsif version[2].to_i > 53
	lich_up_to_date = true
end

$use_effects_for_spell_data = nil
version = LICH_VERSION.split(".")
if version[0].to_i > 5
	$use_effects_for_spell_data = true
elsif version[1].to_i > 0 && version[0].to_i > 4
	$use_effects_for_spell_data = true
elsif version[2].to_i > 15 && version[0].to_i > 4
	$use_effects_for_spell_data = true
end

if Gem.loaded_specs["gtk3"]
	gtk_version = 3
else
	gtk_version = 2
end

CharSettings['scarab'] = 0 unless CharSettings['scarab']
CharSettings['needle'] = 0 unless CharSettings['needle']
CharSettings['jaws'] = 0 unless CharSettings['jaws']
CharSettings['sphere'] = 0 unless CharSettings['sphere']
CharSettings['crystal'] = 0 unless CharSettings['crystal']
CharSettings['scales'] = 0 unless CharSettings['scales']
CharSettings['sulphur'] = 0 unless CharSettings['sulphur']
CharSettings['cloud'] = 0 unless CharSettings['cloud']
CharSettings['acid_vial'] = 0 unless CharSettings['acid_vial']
CharSettings['springs'] = 0 unless CharSettings['springs']
CharSettings['fire_vial'] = 0 unless CharSettings['fire_vial']
CharSettings['spores'] = 0 unless CharSettings['spores']
CharSettings['plate'] = 0 unless CharSettings['plate']
CharSettings['glyph'] = 0 unless CharSettings['glyph']
CharSettings['rods'] = 0 unless CharSettings['rods']
CharSettings['boomer'] = 0 unless CharSettings['boomer']
CharSettings['no_trap'] = 0 unless CharSettings['no_trap']
CharSettings['total_trap_count'] = 0.0 unless CharSettings['total_trap_count']
temp_copper_lockpicks_array = UserVars.tpick["copper"].split(",")
temp_steel_lockpicks_array = UserVars.tpick["steel"].split(",")
temp_gold_lockpicks_array = UserVars.tpick["gold"].split(",")
temp_silver_lockpicks_array = UserVars.tpick["silver"].split(",")
temp_mithril_lockpicks_array = UserVars.tpick["mithril"].split(",")
temp_ora_lockpicks_array = UserVars.tpick["ora"].split(",")
temp_glaes_lockpicks_array = UserVars.tpick["glaes"].split(",")
temp_laje_lockpicks_array = UserVars.tpick["laje"].split(",")
temp_vultite_lockpicks_array = UserVars.tpick["vultite"].split(",")
temp_rolaren_lockpicks_array = UserVars.tpick["rolaren"].split(",")
temp_veniom_lockpicks_array = UserVars.tpick["veniom"].split(",")
temp_invar_lockpicks_array = UserVars.tpick["invar"].split(",")
temp_alum_lockpicks_array = UserVars.tpick["alum"].split(",")
temp_golvern_lockpicks_array = UserVars.tpick["golvern"].split(",")
temp_kelyn_lockpicks_array = UserVars.tpick["kelyn"].split(",")
temp_vaalin_lockpicks_array = UserVars.tpick["vaalin"].split(",")
CharSettings["number_of_current_uses_for_lockpicks"] = Hash.new unless CharSettings["number_of_current_uses_for_lockpicks"]
CharSettings["number_of_locks_opened_since_last_broken_pick"] = 0 unless CharSettings["number_of_locks_opened_since_last_broken_pick"]
CharSettings["number_of_total_boxes_picked_pool_picking"] = 0 unless CharSettings["number_of_total_boxes_picked_pool_picking"]
CharSettings["total_silvers_earned_from_pool_picking"] = 0 unless CharSettings["total_silvers_earned_from_pool_picking"]
CharSettings["total_scarabs_received_pool_picking"] = 0 unless CharSettings["total_scarabs_received_pool_picking"]
CharSettings["total_time_spent_pool_picking"] = 0 unless CharSettings["total_time_spent_pool_picking"]
CharSettings['time_to_subtract_from_overall_actual_picking_time'] = 0 unless CharSettings['time_to_subtract_from_overall_actual_picking_time']
silvers_earned_from_pool_picking_this_session = 0
time_spent_pool_picking_this_session = 0
all_scarab_ids = Array.new
max_lock_attempt = 10000
minimum_tip_wanted = 0
scarabs_received_this_session_pool_picking = 0
number_of_boxes_picked_this_session_pool_picking = 0
minimum_tip_current = 0
total_number_of_boxes = 0
lock = 0
number_of_times_to_measure = 0
max_critter_level = 1000
CharSettings['total_boxes_picked'] = 0 unless CharSettings['total_boxes_picked']
CharSettings['total_time_spent_picking_boxes'] = 0 unless CharSettings['total_time_spent_picking_boxes']
time_to_subtract_from_actual_picking_time = 0
average_picking_time = 0
start_time = 0
max_roll_attempt_before_moving_to_new_pick = 0
starting_room = Room.current.id
check_all_ground_boxes_again = true
all_box_types = "(strongbox|box|chest|trunk|coffer|case)"
all_box_full_names = /(?:shifting )?((?:(?:acid-pitted|badly damaged|battered|corroded|dented|engraved|enruned|plain|scratched|sturdy) )?(?:brass|gold|iron|mithril|silver|steel) (?:box|chest|coffer|strongbox|trunk)|(?:(?:badly damaged|engraved|enruned|iron-bound|plain|rotting|scratched|simple|sturdy|weathered) )?(?:fel|haon|maoral|modwir|monir|tanik|thanot|wooden) (?:box|chest|coffer|strongbox|trunk)|(?:(?:austere|brass-inlaid|crude|gilded|ornate|scorched) )?(?:carved modwir|cracked|deeply-scored|delicate|red lacquered|stained) (?:box|chest|coffer|strongbox|trunk|case)|filigreed rolaren reliquary)/
$tpick_list_of_box_ids = Array.new
$tpick_copper_wire = nil unless $tpick_copper_wire
$tpick_copper_wire_cost = nil unless $tpick_copper_wire_cost
$tpick_brass_wire = nil unless $tpick_brass_wire
$tpick_brass_wire_cost = nil unless $tpick_brass_wire_cost
$tpick_steel_wire = nil unless $tpick_steel_wire
$tpick_steel_wire_cost = nil unless $tpick_steel_wire_cost
$tpick_gold_wire = nil unless $tpick_gold_wire
$tpick_gold_wire_cost = nil unless $tpick_gold_wire_cost
$tpick_silver_wire = nil unless $tpick_silver_wire
$tpick_silver_wire_cost = nil unless $tpick_silver_wire_cost
$tpick_ora_wire = nil unless $tpick_ora_wire
$tpick_ora_wire_cost = nil unless $tpick_ora_wire_cost
$tpick_mithril_wire = nil unless $tpick_mithril_wire
$tpick_mithril_wire_cost = nil unless $tpick_mithril_wire_cost
$tpick_laje_wire = nil unless $tpick_laje_wire
$tpick_laje_wire_cost = nil unless $tpick_laje_wire_cost
$tpick_alum_wire = nil unless $tpick_alum_wire
$tpick_alum_wire_cost = nil unless $tpick_alum_wire_cost
$tpick_vultite_wire = nil unless $tpick_vultite_wire
$tpick_vultite_wire_cost = nil unless $tpick_vultite_wire_cost
$tpick_rolaren_wire = nil unless $tpick_rolaren_wire
$tpick_rolaren_wire_cost = nil unless $tpick_rolaren_wire_cost
$tpick_veniom_wire = nil unless $tpick_veniom_wire
$tpick_veniom_wire_cost = nil unless $tpick_veniom_wire_cost
$tpick_kelyn_wire = nil unless $tpick_kelyn_wire
$tpick_kelyn_wire_cost = nil unless $tpick_kelyn_wire_cost
$tpick_invar_wire = nil unless $tpick_invar_wire
$tpick_invar_wire_cost = nil unless $tpick_invar_wire_cost
$tpick_golvern_wire = nil unless $tpick_golvern_wire
$tpick_golvern_wire_cost = nil unless $tpick_golvern_wire_cost
$tpick_vaalin_wire = nil unless $tpick_vaalin_wire
$tpick_vaalin_wire_cost = nil unless $tpick_vaalin_wire_cost
toolbenches_room_number = [ '17978', '16574', '17960', '17881', '17387', '21187' ]
spin_number = 0
copper_lock_pick_array = Array.new
steel_lock_pick_array = Array.new
gold_lock_pick_array = Array.new
silver_lock_pick_array = Array.new
mithril_lock_pick_array = Array.new
ora_lock_pick_array = Array.new
glaes_lock_pick_array = Array.new
laje_lock_pick_array = Array.new
vultite_lock_pick_array = Array.new
rolaren_lock_pick_array = Array.new
veniom_lock_pick_array = Array.new
invar_lock_pick_array = Array.new
alum_lock_pick_array = Array.new
golvern_lock_pick_array = Array.new
kelyn_lock_pick_array = Array.new
vaalin_lock_pick_array = Array.new
CharSettings['setup_required_again_for_version_332'] = nil unless CharSettings['setup_required_again_for_version_332']
CharSettings['setup_required_again_for_version_345'] = nil unless CharSettings['setup_required_again_for_version_345']
$tpick_remove_armor_before_casting_spell = UserVars.tpick["remove_armor"] if UserVars.tpick["remove_armor"].length > 0
all_lockpicks_to_break_for_rogue = Array.new
@rogue_lockpicks_to_break_and_repair.each{ |i| all_lockpicks_to_break_for_rogue << i.dup } if @rogue_lockpicks_to_break_and_repair.count > 0
@tpick_finished_with_current_rogue_task = nil

check_for_mithril_or_enruned = picks_information_text = help_menu_display = display_the_help_menu = display_no_mode_specified_message = start_up_procedure = pick_up_boxes = drop_off_boxes = @percentage_of_mana_to_keep = stop_trying_to_use_407 = use_unlock_407_settings = box_counts_for_math = max_lock_attempt_compared_to_max_skill = calibrate_auto_amount = calipers_measured_lock = same_scarab_found = box_was_not_locked = bash_the_box_open = bash_open_boxes = temp_math_number = check_for_lockpicks_etc = quick_maths = tip_is_a_percent = tip_being_offered = offered_tip_amount = detect_plinite = temp_id = worker_start_picking_time = temp_name = critter_level = current_item = picking_up = minimum_tip_start = minimum_tip_subtract = minimum_tip_floor = tpick_gather_the_loot = already_checked_for_disk = coins_from_boxes_comma_nonsense = gather_stuff = finished_it = loresong_stuff = $tpick_use_403_cancel = $tpick_use_404_cancel = temp_403_variable = temp_404_variable = current_room = scarab_name = total_silvers_from_box = scarab_object = encumbrance_check = starting_room_number = measure_detection = buy_locksmith_pouch = cast_704_at_box = detect_plinite_result = box_is_enruned_or_mithril = roll_amount_check = use_404_for_trap_difficulty = before_recommended_pick = i_need_403 = ask_worker = random_trick = start_values_nilled = total_picking_time = count_boxes_in_disk = total_boxes_count = update_math_information = total_boxes_number = reset_math = get_vials_and_stuff = total_boxes_picked_math = temp_picks_critter_level = bracers_temp = bracers_name = bracers_tier = nextpick2 = found_true_lock_difficulty = @tpick_lockpick_container = @tpick_broken_lockpick_container = lock_pick_information = always_use_wedge = @tpick_wedge_container = @tpick_calipers_container = @tpick_scale_weapon_container = @tpick_locksmiths_container = next_task = roll_amount = number_of_manual_trap_checks_remaining = time_to_disarm_trap = check_for_command = start_worker = start_worker2 = gem = reagent = herb = food = uncommon = jewelry = junk = lockpick = magic = scroll = wand = armor = weapon = clothing = other = pool_picking_fried_commands = pool_fried_start_time = starting_pool_room_number = stow_in_disk = check_for_boxes = remaining_416_casts = stuff_to_do = where_to_stow_box = check_locksmiths_container = putty_remaining = cotton_remaining = vials_remaining = fill_up_locksmith_container = order_number = trash_container = current_vial = use_spell_205 = use_spell_402 = use_spell_403 = use_spell_404 = use_spell_1035 = use_spell_613 = use_spell_704 = use_spell_1006 = pop_start = $tpick_recommended_pick = recommended_pick_modifier = needed_pick_id = before_needed_pick = check_hands_status = current_trap_type = box_is_disarmed = box_is_open = check_for_trap = pop_open_box = disarm_trap = cast_402 = cast_403 = cast_404 = use_403_for_lock_difficulty = can_use_calipers = pop_boxes_begin = fused_lock_disarm = override_bracers = $scale_trap_weapon_id = finished_getting_coins = picks_to_use_based_on_critter_level = get_wire_order_numbers = current_pick_to_check = lockpick_type = stow_both = current_wire = find_gnomish_lockpick = current_wire_cost = popping = start_sorter = number = contents = container = scale_trap_found = gnomish_bracers = found_pick = disarm_only = gnomish_bracers_trap_check = gnomish_bracers_trap_check_result = stats_check = $copper_lockpick_id = $steel_lockpick_id = $gold_lockpick_id = $silver_lockpick_id = $mithril_lockpick_id = $ora_lockpick_id = $glaes_lockpick_id = $laje_lockpick_id = $vultite_lockpick_id = $rolaren_lockpick_id = $veniom_lockpick_id = $invar_lockpick_id = $alum_lockpick_id = $golvern_lockpick_id = $kelyn_lockpick_id = $vaalin_lockpick_id = start_with_copper = all_stats_to_check = all_stats_trap_names = math = open_plinites = start_plinites = open_current_plinite = plinite_already_open = cannot_determine_plinite_difficulty = critter_name = current_box = tpick_bundle_vials = $tpick_armor_has_been_removed = exit_when_waiting = use_a_wedge = relock_boxes_for_rogues = $tpick_waiting_for_another_job = $tpick_exit_tpick_immediately = nil

stats_check = proc{
	_respond
	_respond "#{monsterbold_start}#################################################################################{monsterbold_end}\n"
	if CharSettings['total_trap_count'] == 0.0
		_respond "#{monsterbold_start}No trap information has been recorded yet. Get to checking boxes for traps!#{monsterbold_end}\n"
	else
		number = 0
		all_stats_to_check = [ CharSettings['scarab'], CharSettings['needle'], CharSettings['jaws'], CharSettings['sphere'], CharSettings['crystal'], CharSettings['scales'], CharSettings['sulphur'], CharSettings['cloud'], CharSettings['acid_vial'], CharSettings['springs'], CharSettings['fire_vial'], CharSettings['spores'], CharSettings['plate'], CharSettings['glyph'], CharSettings['rods'], CharSettings['boomer'], CharSettings['no_trap'] ]
		all_stats_trap_names = [ "Scarab         ", "Needle         ", "Jaws           ", "Sphere         ", "Crystal        ", "Scales         ", "Sulphur        ", "Cloud          ", "Acid Vial      ", "Springs        ", "Fire Vial      ", "Spores         ", "Plate          ", "Glyph          ", "Rods           ", "Boomer         ", "No Trap        " ]
		_respond "#{monsterbold_start}All trap information#{monsterbold_end}\n"
		all_stats_to_check.each { |i|
			math = (((i / CharSettings['total_trap_count'])) * (100)).round(2)
			_respond "#{all_stats_trap_names.at(number)} #{i} (#{math}%)"
			number += 1
		}
		_respond "Total Traps     #{CharSettings['total_trap_count'].to_i.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}"
	end
	
	_respond
	_respond "#{monsterbold_start}Time spent picking boxes#{monsterbold_end}\n"
	CharSettings['total_time_spent_picking_boxes'] = CharSettings['total_time_spent_picking_boxes'].round(2) unless CharSettings['total_time_spent_picking_boxes'] == 0
	average_picking_time = (CharSettings['total_time_spent_picking_boxes'] / CharSettings['total_boxes_picked']).round(2) unless CharSettings['total_boxes_picked'] == 0
	if CharSettings['total_boxes_picked'] > 0
		_respond "Total boxes picked:     #{CharSettings['total_boxes_picked'].to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}"
		_respond "Total time picking:     #{CharSettings['total_time_spent_picking_boxes'].to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse} seconds"
		_respond "Average time per box:   #{average_picking_time} seconds"
	end
	
	_respond
	_respond "#{monsterbold_start}Number of locks successfully opened since last broken lockpick:#{monsterbold_end}\n"
	successful_lockpick_text = "Number of locks successfully opened since last broken lockpick: "
	_respond "copper:    #{CharSettings["number_of_current_uses_for_lockpicks"]["copper"].to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}"
	_respond "steel:     #{CharSettings["number_of_current_uses_for_lockpicks"]["steel"].to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}"
	_respond "gold:      #{CharSettings["number_of_current_uses_for_lockpicks"]["gold"].to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}"
	_respond "silver:    #{CharSettings["number_of_current_uses_for_lockpicks"]["silver"].to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}"
	_respond "mithril:   #{CharSettings["number_of_current_uses_for_lockpicks"]["mithril"].to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}"
	_respond "ora:       #{CharSettings["number_of_current_uses_for_lockpicks"]["ora"].to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}"
	_respond "glaes:     #{CharSettings["number_of_current_uses_for_lockpicks"]["glaes"].to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}"
	_respond "laje:      #{CharSettings["number_of_current_uses_for_lockpicks"]["laje"].to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}"
	_respond "vultite:   #{CharSettings["number_of_current_uses_for_lockpicks"]["vultite"].to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}"
	_respond "rolaren:   #{CharSettings["number_of_current_uses_for_lockpicks"]["rolaren"].to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}"
	_respond "veniom:    #{CharSettings["number_of_current_uses_for_lockpicks"]["veniom"].to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}"
	_respond "invar:     #{CharSettings["number_of_current_uses_for_lockpicks"]["invar"].to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}"
	_respond "alum:      #{CharSettings["number_of_current_uses_for_lockpicks"]["alum"].to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}"
	_respond "golvern:   #{CharSettings["number_of_current_uses_for_lockpicks"]["golvern"].to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}"
	_respond "kelyn:     #{CharSettings["number_of_current_uses_for_lockpicks"]["kelyn"].to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}"
	_respond "vaalin:    #{CharSettings["number_of_current_uses_for_lockpicks"]["vaalin"].to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}"	
	_respond "Number of total locks picked since any lockpick broke: #{CharSettings["number_of_locks_opened_since_last_broken_pick"].to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}"
	_respond
	
	_respond "#{monsterbold_start}Locksmith pool income:#{monsterbold_end}\n"
	if CharSettings["total_time_spent_pool_picking"] > 0
		t = CharSettings["total_time_spent_pool_picking"]
		time_spent_picking = "%02d:%02d:%02d" % [t/3600%24, t/60%60, t%60]
		total_scarab_value = (CharSettings["total_scarabs_received_pool_picking"] * 5000)
		silver_tips_plus_scarab_value = CharSettings["total_silvers_earned_from_pool_picking"] + total_scarab_value
		silvers_earned_hour = ((silver_tips_plus_scarab_value / CharSettings["total_time_spent_pool_picking"]) * 3600).truncate
		scarab_frequency = (((CharSettings["total_scarabs_received_pool_picking"] *1.0) / CharSettings["number_of_total_boxes_picked_pool_picking"]) * 100).round(2)
		_respond "Total:"
		_respond "Time:                    #{time_spent_picking}"
		_respond "Number of boxes:         #{CharSettings["number_of_total_boxes_picked_pool_picking"]}"
		_respond "Number of scarabs:       #{CharSettings["total_scarabs_received_pool_picking"]}"
		_respond "Silver tips:             #{CharSettings["total_silvers_earned_from_pool_picking"].to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}"
		_respond "Scarab value (5k per):   #{total_scarab_value.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}"
		_respond "Scarab frequency:        #{scarab_frequency}%"
		_respond "Total silvers:           #{silver_tips_plus_scarab_value.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}"
		_respond "Silvers earned/hour:     #{silvers_earned_hour.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}"
	else
		_respond "You haven't done any locksmith pool picking yet."
	end
	
	_respond "#{monsterbold_start}#################################################################################{monsterbold_end}\n"
}

reset_math = proc{
	CharSettings['total_boxes_picked'] = 0
	CharSettings['total_time_spent_picking_boxes'] = 0
	exit
}

def tpick_put_stuff_away
	both_hands = [ GameObj.right_hand, GameObj.left_hand]
	both_hands.each{ |item|
		if @rogue_trap_components_needed_nouns.include?(item.noun)
			if @rogue_trap_components_needed_nouns =~ /vial/
				@rogue_trap_components_needed_array.push(item.id) if (item.name =~ /clear glass vial/ && @rogue_trap_components_needed_names.include?("clear vial")) || (item.name =~ /thick glass vial|green\-tinted vial/ && @rogue_trap_components_needed_names.include?("thick vial"))
			else
				@rogue_trap_components_needed_array.push(item.id)
			end
		end
		if item.name != "Empty" && (item.id != @tpick_current_box.id || @tpick_stow_current_box)
			container_id_to_stow_item_in = nil
			short_name_container = nil
			if @tpick_all_lockpick_id_arrays.any?{ |i| i.include?(item.id) }
				if @tpick_lockpick_is_broken
					container_id_to_stow_item_in = @tpick_broken_lockpick_container.id
				else
					container_id_to_stow_item_in = @tpick_lockpick_container.id
				end
			elsif item.name =~ /wedge/
				container_id_to_stow_item_in = @tpick_wedge_container.id
			elsif item.name =~ /caliper/
				container_id_to_stow_item_in = @tpick_calipers_container.id
			elsif item.id == $scale_trap_weapon_id
				container_id_to_stow_item_in = @tpick_scale_weapon_container.id
			end
			if container_id_to_stow_item_in.nil? && @all_other_container_options.length > 1
				name_match = nil
				type_match = nil
				name_match_container_full_name = nil
				name_match_container_short_name = nil
				type_match_container_full_name = nil
				type_match_container_short_name = nil
				@all_other_container_options.each{ |i|
					i.strip!
					i.rstrip!
					i = i.split(":")
					i[1].strip!
					i[1].rstrip!
					if item.name =~ /#{i[0]}/
						name_match_container_full_name = GameObj.inv.find{ |t| t.name == i[1] }
						name_match_container_short_name = i[1]
						name_match = true
					elsif item.type =~ /#{i[0]}/
						type_match_container_full_name = GameObj.inv.find{ |t| t.name == i[1] }
						type_match_container_short_name = i[1]
						type_match = true
					end
					break if name_match && type_match
				}
				if name_match
					if name_match_container_full_name
						container_id_to_stow_item_in = name_match_container_full_name.id
					else
						short_name_container = name_match_container_short_name
					end
				else
					if type_match_container_full_name
						container_id_to_stow_item_in = type_match_container_full_name.id
					else
						short_name_container = type_match_container_short_name
					end
				end
			end
			if container_id_to_stow_item_in || short_name_container
				3.times{
					waitrt?
					unless GameObj.right_hand.id != item.id && GameObj.left_hand.id != item.id
						if container_id_to_stow_item_in
							fput "put ##{item.id} in ##{container_id_to_stow_item_in}"
						else
							fput "put ##{item.id} in my #{short_name_container}"
						end
						sleep 0.2
					end
				}
				echo "Couldn't put #{item.name} in its proper container, STOWing it instead." if GameObj.right_hand.id == item.id || GameObj.left_hand.id == item.id
			end
			until GameObj.right_hand.id != item.id && GameObj.left_hand.id != item.id
				waitrt?
				fput "stow ##{item.id}"
				sleep 0.2
			end
		end
	}
	@tpick_stow_current_box = nil
	@tpick_lockpick_is_broken = nil
end
	
def tpick_stow_armor
	if $tpick_remove_armor_before_casting_spell && $tpick_armor_has_been_removed.nil? && checkroom !~ /table/i
		$tpick_armor_has_been_removed = true
		wait_until { checkrt == 0 }
		fput "remove #{$tpick_remove_armor_before_casting_spell}"
		fput "stow #{$tpick_remove_armor_before_casting_spell}"
	end
end

def tpick_cast_spells (number)
	if $use_effects_for_spell_data
		if number == 402
			spell_name_to_check = "Presence"
		elsif number == 403
			spell_name_to_check = "Lock Pick Enhancement"
		elsif number == 404
			spell_name_to_check = "Disarm Enhancement"
		elsif number == 613
			spell_name_to_check = "Self Control"
		elsif number == 1006
			spell_name_to_check = "Song of Luck"
		elsif number == 1035
			spell_name_to_check = "Song of Tonis"
		end
		if UserVars.tpick["use_lmaster_focus"] =~ /yes/i && (number == 403 || number == 404)
			if (Effects::Buffs.active?('Focused') && 10 > (Time.now - Effects::Buffs.to_h["Focused"]).abs) || (!Effects::Buffs.active?('Focused'))
				successful_action = nil
				until successful_action
					result = dothistimeout "lmaster focus", 2, /You focus intently on your picking and disarm skill\./
					if result =~ /You focus intently on your picking and disarm skill\./
						successful_action = true
					end
				end
			end
		elsif @percentage_of_mana_to_keep > percentmana
			echo "According to your settings your current mana is too low to cast spells."
		else
			spell_needs_to_be_recast = nil
			if number == 402 || number == 1035
				spell_needs_to_be_recast = true if (Spell[spell_name_to_check].known?) && ((Effects::Buffs.active?(spell_name_to_check) && 10 > (Time.now - Effects::Buffs.to_h[spell_name_to_check]).abs) || (!Effects::Buffs.active?(spell_name_to_check)))
			else
				spell_needs_to_be_recast = true if (Spell[spell_name_to_check].known?) && ((Effects::Spells.active?(spell_name_to_check) && 10 > (Time.now - Effects::Spells.to_h[spell_name_to_check]).abs) || (!Effects::Spells.active?(spell_name_to_check)))
			end
			if spell_needs_to_be_recast
				if number == 1035 && !Spell[spell_name_to_check].affordable?
					nil
				else
					if !Spell[spell_name_to_check].affordable?
						echo "Waiting for mana."
						wait_until { Spell[spell_name_to_check].affordable? }
					end
					tpick_stow_armor
					Spell[spell_name_to_check].cast
					sleep 0.2
				end
			end
		end
	else
		if UserVars.tpick["use_lmaster_focus"] =~ /yes/i && (number == 403 || number == 404)
			if 0.10 > Spell["Focused"].timeleft
				until 0.10 < Spell["Focused"].timeleft
					fput "lmaster focus"
					sleep 0.2
				end
			end
		elsif @percentage_of_mana_to_keep > percentmana
			echo "According to your settings your current mana is too low to cast spells."
		else
			if Spell[number].known? && 0.10 > Spell[number].timeleft
				if number == 1035 && !Spell[number].affordable?
					nil
				else
					until 0.10 < Spell[number].timeleft
						if !Spell[number].affordable?
							echo "Waiting for mana."
							wait_until { Spell[number].affordable? }
						end
						tpick_stow_armor
						Spell[number].cast
						sleep 0.2
					end
				end
			end
		end
	end
end

def tpick_prep_spell(number, name)
	if Spell[number].known?
		if !Spell[number].affordable?
			echo "Waiting for mana."
			wait_until { Spell[number].affordable? }
		end
		until checkprep == "#{name}"
			waitrt?
			waitcastrt?
			fput "release" if checkprep !~ /None|#{name}/i
			fput "prep #{number}"
			sleep 0.2
		end
	end
end

def tpick_drop_box(current_box)
	until GameObj.right_hand.id != current_box.id && GameObj.left_hand.id != current_box.id
		waitrt?
		fput "drop ##{current_box.id}"
		sleep 0.2
	end
end

def tpick_get_box(current_box)
	until GameObj.right_hand.id == current_box.id || GameObj.left_hand.id == current_box.id
		waitrt?
		fput "get ##{current_box.id}"
		sleep 0.2
	end
end

def tpick_stop_403
	fput "stop 403" if Spell[403].active?
	if $use_effects_for_spell_data
		fput "stop lmaster focus" if Effects::Buffs.active?('Focused')
	else
		fput "stop lmaster focus" if Spell["Focused"].active?
	end
end

def tpick_stop_404
	fput "stop 404" if Spell[404].active?
	if $use_effects_for_spell_data
		fput "stop lmaster focus" if Effects::Buffs.active?('Focused')
	else
		fput "stop lmaster focus" if Spell["Focused"].active?
	end
end

def tpick_stop_403_404		
	waitrt?
	fput "stop 403" if Spell[403].active? && ($tpick_use_403_cancel =~ /cancel/i || UserVars.tpick["always_use_403"] =~ /cancel/i)
	fput "stop 404" if Spell[404].active? && ($tpick_use_404_cancel =~ /cancel/i || UserVars.tpick["always_use_404"] =~ /cancel/i)
	if $use_effects_for_spell_data
		fput "stop lmaster focus" if Effects::Buffs.active?('Focused') && ($tpick_use_403_cancel =~ /cancel/i || UserVars.tpick["always_use_403"] =~ /cancel/i || $tpick_use_404_cancel =~ /cancel/i || UserVars.tpick["always_use_404"] =~ /cancel/i)
	else
		fput "stop lmaster focus" if Spell["Focused"].active? && ($tpick_use_403_cancel =~ /cancel/i || UserVars.tpick["always_use_403"] =~ /cancel/i || $tpick_use_404_cancel =~ /cancel/i || UserVars.tpick["always_use_404"] =~ /cancel/i)
	end
end

def tpick_stow_box(current_box)
	until GameObj.right_hand.id != current_box.id && GameObj.left_hand.id != current_box.id
		waitrt?
		fput "stow ##{current_box.id}"
		sleep 0.2
	end
end

def tpick_say_cant
	fput "say #{UserVars.tpick["cant_open_box"]}" if UserVars.tpick["cant_open_box"].length > 0
end

def tpick_say_scarab_found
	fput "say #{UserVars.tpick["scarab_found"]}" if UserVars.tpick["scarab_found"].length > 0
end

def tpick_say_scarab_safe
	fput "say #{UserVars.tpick["scarab_safe"]}" if UserVars.tpick["scarab_safe"].length > 0
end

$tpick_boxes_checked = nil
strongbox_count = 0
box_count = 0
chest_count = 0
trunk_count = 0
coffer_count = 0

gem_number = Array.new
reagent_number = Array.new
herb_number = Array.new
food_number = Array.new
uncommon_number = Array.new
jewelry_number = Array.new
junk_number = Array.new
lockpick_number = Array.new
magic_number = Array.new
scroll_number = Array.new
wand_number = Array.new
armor_number = Array.new
weapon_number = Array.new
clothing_number = Array.new
other_number = Array.new
all_box_ids_already_picked = Array.new

dex_bonus = nil

#The following is just for informational purposes, no need to change anything.

#Pick names and mod values:
#Copper		1.00
#Steel		1.10
#Gold		1.20
#Silver		1.30
#Mithril	1.45
#Ora		1.55
#Glaes		1.60
#Laje		1.75
#Vultite	1.80
#Rolaren	1.90
#Veniom		2.20
#Invar		2.25
#Alum		2.30
#Golvern	2.35
#Kelyn		2.40
#Vaalin		2.50

#Lock names and difficulty
#Primitive					35
#Rudimentary				75
#Extremely Easy				115
#Very Easy					155
#Easy						195
#Very Basic					235
#Fairly Easy				275
#Simple						315
#Fairly Simple				355
#Fairly Plain				395
#Moderately Well-Crafted	435
#Well-Crafted				475
#Tricky						515
#Somewhat Difficult			555
#Moderately Difficult		595
#Very Well-Crafted			635
#Difficult					675
#Extremely Well-Crafted		715
#Very Difficult				755
#Fairly Complicated			795
#Intricate					835
#Amazingly Well-Crafted		875
#Very Complex				915
#Impressively Complicated	955
#Amazingly Intricate		995
#Extremely Difficult		1035
#Extremely Complex			1075
#Masterfully Well-Crafted	1115
#Amazingly Complicated		1155
#Astoundingly Complex		1195
#Incredibly Intricate		1235
#Absurdly Well-Crafted		1275
#Exceedingly Complex		1315
#Absurdly Difficult			1355
#Unbelievably Complicated 	1395
#Masterfully Intricate		1435
#Absurdly Complex			1475
#Impossibly Complex			1515

worker = nil
Room.current.tags.find{ |i| i =~ /meta:boxpool:npc:(.*)/;worker = $1}
worker = GameObj.npcs.find{ |i| worker == i.name }

table = nil
Room.current.tags.find{ |i| i =~ /meta:boxpool:table:(.*)/;table = $1}
if GameObj.loot.find {|i| table =~ /#{i}/}
	table = GameObj.loot.find {|i| table =~ /#{i}/}
else
	table = GameObj.room_desc.find {|i| table =~ /#{i}/}
end

pick_mod = [ 1.00, 1.10, 1.20, 1.30, 1.45, 1.55, 1.60, 1.75, 1.80, 1.90, 2.20, 2.25, 2.30, 2.35, 2.40, 2.50 ]
lock_difficulty = [ 35, 75, 115, 155, 195, 235, 275, 315, 355, 395, 435, 475, 515, 555, 595, 635, 675, 715, 755, 795, 835, 875, 915, 955, 995, 1035, 1075, 1115, 1155, 1195, 1235, 1275, 1315, 1355, 1395, 1435, 1475, 1515 ]
if lich_up_to_date
	dex_bonus = Stats.enhanced_dex[1]
else
	dex_bonus = Stats.dex[1]
end
pick_skill = (Skills.to_bonus(Skills.pickinglocks) + dex_bonus)
pick_lore = [(Stats.level / 2) + (Skills.to_bonus(Skills.pickinglocks) / 10) + (dex_bonus) + (Spells.minorelemental / 4), Skills.to_bonus(Skills.pickinglocks)].min
disarm_skill = (dex_bonus + Skills.to_bonus(Skills.disarmingtraps))
if Spell[404].known?
	disarm_lore = [(Stats.level / 2) + (Skills.to_bonus(Skills.disarmingtraps) / 10) + dex_bonus + (Spells.minorelemental / 4), Skills.to_bonus(Skills.disarmingtraps)].min
else
	disarm_lore = 0
end
(start_solo = nil;start_others = nil;check_disk = nil;manually_disarm_trap = nil;scaledisarm = nil;plate = nil;measure = nil;pick2 = nil;pick3 = nil;nextpick = nil;open_solo = nil;open_others = nil;need_403 = nil;needed_pick = nil;total_pick_skill = nil;person = nil;box = "box";cast_404 = nil;solo_or_other = nil;always_use_vaalin = nil;wedge_lock = nil;ground_loot = nil;start_ground = nil;setup = nil;do_trick = nil;calibrate = nil;cast_403 = nil;cast_402 = nil;cast_613 = nil;cast_1006 = nil;cast_1035 = nil;calibrate_count = nil;cast_407 = nil;current_box_name = nil;box_opened = true;cant_open_plated_box_count = nil;total_boxes_picked = 0;record_item_data = nil;silver_before = nil;silver_after = nil;wealth_before = nil;wealth_after = nil;silver_gained = 0;trash = nil;garbage_check = nil;trap_difficulty = nil;need_404 = nil;total_trap_skill = nil;relock_boxes = nil;do_relock_boxes = nil)

trash_container = /crate|barrel|wastebarrel|casket|bin|receptacle|basket|woodstove/i

setup = proc{
	CharSettings['setup_required_again_for_version_332'] = true
	CharSettings['setup_required_again_for_version_345'] = true
	$copper_lockpick_id = nil
	$steel_lockpick_id = nil
	$gold_lockpick_id = nil
	$silver_lockpick_id = nil
	$mithril_lockpick_id = nil
	$ora_lockpick_id = nil
	$glaes_lockpick_id = nil
	$laje_lockpick_id = nil
	$vultite_lockpick_id = nil
	$rolaren_lockpick_id = nil
	$veniom_lockpick_id = nil
	$invar_lockpick_id = nil
	$alum_lockpick_id = nil
	$golvern_lockpick_id = nil
	$kelyn_lockpick_id = nil
	$vaalin_lockpick_id = nil
	Gtk.queue {
		$TPICK_WINDOW = Gtk::Window.new
		$TPICK_WINDOW.title = "tpick"
		$TPICK_WINDOW.set_border_width(10)
		
		#GTK2 and GTK3 nonsense:
		if gtk_version == 2
			$TPICK_BOX = Gtk::VBox.new(false)
			$TPICK_BOX.set_border_width(5)

			$TPICK_VERTICAL_BOX1 = Gtk::VBox.new(false, 0)
			$TPICK_VERTICAL_BOX2 = Gtk::VBox.new(false, 0)
			$TPICK_VERTICAL_BOX3 = Gtk::VBox.new(false, 0)
			$TPICK_VERTICAL_BOX4 = Gtk::VBox.new(false, 0)
			$TPICK_VERTICAL_BOX5 = Gtk::VBox.new(false, 0)
			$TPICK_VERTICAL_BOX6 = Gtk::VBox.new(false, 0)
			$TPICK_VERTICAL_BOX7 = Gtk::VBox.new(false, 0)
			$TPICK_VERTICAL_BOX8 = Gtk::VBox.new(false, 0)
			$TPICK_VERTICAL_BOX9 = Gtk::VBox.new(false, 0)
			$TPICK_VERTICAL_BOX10 = Gtk::VBox.new(false, 0)
			$TPICK_VERTICAL_BOX11 = Gtk::VBox.new(false, 0)
			$TPICK_VERTICAL_BOX12 = Gtk::VBox.new(false, 0)
		else
			$TPICK_BOX = Gtk::Box.new(:vertical)
			$TPICK_BOX.set_border_width(5)

			$TPICK_VERTICAL_BOX1 = Gtk::Box.new(:vertical, 0)
			$TPICK_VERTICAL_BOX2 = Gtk::Box.new(:vertical, 0)
			$TPICK_VERTICAL_BOX3 = Gtk::Box.new(:vertical, 0)
			$TPICK_VERTICAL_BOX4 = Gtk::Box.new(:vertical, 0)
			$TPICK_VERTICAL_BOX5 = Gtk::Box.new(:vertical, 0)
			$TPICK_VERTICAL_BOX6 = Gtk::Box.new(:vertical, 0)
			$TPICK_VERTICAL_BOX7 = Gtk::Box.new(:vertical, 0)
			$TPICK_VERTICAL_BOX8 = Gtk::Box.new(:vertical, 0)
			$TPICK_VERTICAL_BOX9 = Gtk::Box.new(:vertical, 0)
			$TPICK_VERTICAL_BOX10 = Gtk::Box.new(:vertical, 0)
			$TPICK_VERTICAL_BOX11 = Gtk::Box.new(:vertical, 0)
			$TPICK_VERTICAL_BOX12 = Gtk::Box.new(:vertical, 0)
		end
		#####

		$TPICK_WINDOW.add($TPICK_BOX)
		$TPICK_NOTEBOOK = Gtk::Notebook.new
		$TPICK_NOTEBOOK.set_show_border(true)
		$TPICK_BOX.add($TPICK_NOTEBOOK)
		$TPICK_NOTEBOOK.append_page($TPICK_VERTICAL_BOX1, Gtk::Label.new('Lockpicks'))
		$TPICK_NOTEBOOK.append_page($TPICK_VERTICAL_BOX2, Gtk::Label.new('Lockpicks 2'))
		$TPICK_NOTEBOOK.append_page($TPICK_VERTICAL_BOX3, Gtk::Label.new('Containers'))
		$TPICK_NOTEBOOK.append_page($TPICK_VERTICAL_BOX4, Gtk::Label.new('Other'))
		$TPICK_NOTEBOOK.append_page($TPICK_VERTICAL_BOX5, Gtk::Label.new('More Other'))
		$TPICK_NOTEBOOK.append_page($TPICK_VERTICAL_BOX6, Gtk::Label.new('Yet More Other'))
		$TPICK_NOTEBOOK.append_page($TPICK_VERTICAL_BOX7, Gtk::Label.new('Spells'))
		$TPICK_NOTEBOOK.append_page($TPICK_VERTICAL_BOX8, Gtk::Label.new('Experience'))
		$TPICK_NOTEBOOK.append_page($TPICK_VERTICAL_BOX9, Gtk::Label.new('Speech'))
		$TPICK_NOTEBOOK.append_page($TPICK_VERTICAL_BOX10, Gtk::Label.new('Popping'))
		$TPICK_NOTEBOOK.append_page($TPICK_VERTICAL_BOX11, Gtk::Label.new('Pool/Worker'))
		$TPICK_NOTEBOOK.append_page($TPICK_VERTICAL_BOX12, Gtk::Label.new(';rogues integration'))
		$TPICK_ENTRY = Hash.new 
		$TPICK_TABLE_SIZE = Hash.new
	}

	Gtk.queue {
		$TPICK_TABLE1 = Gtk::Table.new(6, 3, false)
		$TPICK_TABLE1.row_spacings=3
		$TPICK_TABLE1.column_spacings=3
		$TPICK_VERTICAL_BOX1.pack_start($TPICK_TABLE1, false, false, 0)

		$TPICK_TABLE2 = Gtk::Table.new(6, 3, false)
		$TPICK_TABLE2.row_spacings=3
		$TPICK_TABLE2.column_spacings=3
		$TPICK_VERTICAL_BOX2.pack_start($TPICK_TABLE2, false, false, 0)

		$TPICK_TABLE3 = Gtk::Table.new(6, 3, false)
		$TPICK_TABLE3.row_spacings=3
		$TPICK_TABLE3.column_spacings=3
		$TPICK_VERTICAL_BOX3.pack_start($TPICK_TABLE3, false, false, 0)

		$TPICK_TABLE4 = Gtk::Table.new(6, 3, false)
		$TPICK_TABLE4.row_spacings=3
		$TPICK_TABLE4.column_spacings=3
		$TPICK_VERTICAL_BOX4.pack_start($TPICK_TABLE4, false, false, 0)

		$TPICK_TABLE5 = Gtk::Table.new(6, 3, false)
		$TPICK_TABLE5.row_spacings=3
		$TPICK_TABLE5.column_spacings=3
		$TPICK_VERTICAL_BOX5.pack_start($TPICK_TABLE5, false, false, 0)

		$TPICK_TABLE6 = Gtk::Table.new(6, 3, false)
		$TPICK_TABLE6.row_spacings=3
		$TPICK_TABLE6.column_spacings=3
		$TPICK_VERTICAL_BOX6.pack_start($TPICK_TABLE6, false, false, 0)

		$TPICK_TABLE7 = Gtk::Table.new(6, 3, false)
		$TPICK_TABLE7.row_spacings=3
		$TPICK_TABLE7.column_spacings=3
		$TPICK_VERTICAL_BOX7.pack_start($TPICK_TABLE7, false, false, 0)

		$TPICK_TABLE8 = Gtk::Table.new(6, 3, false)
		$TPICK_TABLE8.row_spacings=3
		$TPICK_TABLE8.column_spacings=3
		$TPICK_VERTICAL_BOX8.pack_start($TPICK_TABLE8, false, false, 0)

		$TPICK_TABLE9 = Gtk::Table.new(6, 3, false)
		$TPICK_TABLE9.row_spacings=3
		$TPICK_TABLE9.column_spacings=3
		$TPICK_VERTICAL_BOX9.pack_start($TPICK_TABLE9, false, false, 0)
		
		$TPICK_TABLE10 = Gtk::Table.new(6, 3, false)
		$TPICK_TABLE10.row_spacings=3
		$TPICK_TABLE10.column_spacings=3
		$TPICK_VERTICAL_BOX10.pack_start($TPICK_TABLE10, false, false, 0)
		
		$TPICK_TABLE11 = Gtk::Table.new(6, 3, false)
		$TPICK_TABLE11.row_spacings=3
		$TPICK_TABLE11.column_spacings=3
		$TPICK_VERTICAL_BOX11.pack_start($TPICK_TABLE11, false, false, 0)
		
		$TPICK_TABLE12 = Gtk::Table.new(6, 3, false)
		$TPICK_TABLE12.row_spacings=3
		$TPICK_TABLE12.column_spacings=3
		$TPICK_VERTICAL_BOX12.pack_start($TPICK_TABLE12, false, false, 0)
	}

	def self.add_label_entry(table, label, variable)
		size = $TPICK_TABLE_SIZE[table] || 0

		label = Gtk::Label.new(label)
		align = Gtk::Alignment.new 1, 0, 0, 0
		align.set_padding(4, 0, 3, 4)
		align.add(label)
		table.attach(align, 0, 1, size, size + 1)

		entry = Gtk::Entry.new
		entry.text = UserVars.tpick[variable].to_s
		entry.set_width_request(157)
		table.attach(entry, 1, 2, size, size + 1)

		$TPICK_ENTRY[variable] = entry
		$TPICK_TABLE_SIZE[table] += 1
	end

	Gtk.queue {
		$TPICK_ENTRY = Hash.new
		add_label_entry($TPICK_TABLE1, "Copper Lockpick", 'copper')
		add_label_entry($TPICK_TABLE1, "Steel Lockpick", 'steel')
		add_label_entry($TPICK_TABLE1, "Gold Lockpick", 'gold')
		add_label_entry($TPICK_TABLE1, "Silver Lockpick", 'silver')
		add_label_entry($TPICK_TABLE1, "Mithril Lockpick", 'mithril')
		add_label_entry($TPICK_TABLE1, "Ora Lockpick", 'ora')
		add_label_entry($TPICK_TABLE1, "Glaes Lockpick", 'glaes')
		add_label_entry($TPICK_TABLE1, "Laje Lockpick", 'laje')
		add_label_entry($TPICK_TABLE2, "Vultite Lockpick", 'vultite')
		add_label_entry($TPICK_TABLE2, "Rolaren Lockpick", 'rolaren')
		add_label_entry($TPICK_TABLE2, "Veniom Lockpick", 'veniom')
		add_label_entry($TPICK_TABLE2, "Invar Lockpick", 'invar')
		add_label_entry($TPICK_TABLE2, "Alum Lockpick", 'alum')
		add_label_entry($TPICK_TABLE2, "Golvern Lockpick", 'golvern')
		add_label_entry($TPICK_TABLE2, "Kelyn Lockpick", 'kelyn')
		add_label_entry($TPICK_TABLE2, "Vaalin Lockpick", 'vaalin')
		add_label_entry($TPICK_TABLE3, "Lockpick Container", 'lockpick_container')
		add_label_entry($TPICK_TABLE3, "Broken Lockpick Container", 'broken_lockpick_container')
		add_label_entry($TPICK_TABLE3, "Wedge Container", 'wedge_container')
		add_label_entry($TPICK_TABLE3, "Calipers Container", 'calipers_container')
		add_label_entry($TPICK_TABLE3, "Scale Weapon Container", 'scale_weapon_container')
		add_label_entry($TPICK_TABLE3, "Locksmith's Container", 'locksmiths_container')
		add_label_entry($TPICK_TABLE3, "Containers to open at start", 'containers_open_to_start')
		add_label_entry($TPICK_TABLE3, "Containers to close before exit", 'containers_to_close_before_exit')
		add_label_entry($TPICK_TABLE3, "Other containers", 'all_other_containers')
		add_label_entry($TPICK_TABLE4, "Auto deposit silvers", 'auto_deposit_silvers')
		add_label_entry($TPICK_TABLE4, "Gnomish Bracer", 'gnomish_bracer')
		add_label_entry($TPICK_TABLE4, "Bashing Weapon", 'bashing_weapon')
		add_label_entry($TPICK_TABLE4, "Scale Trap Weapon", 'scale_trap_weapon')
		add_label_entry($TPICK_TABLE4, "Remove armor", 'remove_armor')
		add_label_entry($TPICK_TABLE4, "Max Lock", 'max_lock')
		add_label_entry($TPICK_TABLE4, "Max Lock Roll", 'max_lock_roll')
		add_label_entry($TPICK_TABLE4, "Trap Roll", 'trap_roll')
		add_label_entry($TPICK_TABLE5, "Trick", 'trick')
		add_label_entry($TPICK_TABLE5, "Log", 'log')
		add_label_entry($TPICK_TABLE5, "Trash boxes", 'trash_boxes')
		add_label_entry($TPICK_TABLE5, "Calibrate on startup", 'calibrate')
		add_label_entry($TPICK_TABLE5, "Calibrate count", 'calibratecount')
		add_label_entry($TPICK_TABLE5, "Auto Bundle Vials", 'auto_bundle_vials')
		add_label_entry($TPICK_TABLE5, "Auto repair bent lockpicks", 'auto_repair_bent_lockpicks')
		add_label_entry($TPICK_TABLE5, "Number of times to check for traps", 'number_of_times_to_check_for_traps')
		add_label_entry($TPICK_TABLE6, "Lock Roll", 'lock_roll')
		add_label_entry($TPICK_TABLE6, "Vaalin Lock Roll", 'vaalin_lock_roll')
		add_label_entry($TPICK_TABLE6, "Lock Buffer", 'lock_buffer')
		add_label_entry($TPICK_TABLE6, "Keep trying if within abilities", 'keep_trying_if_within_abilities')
		add_label_entry($TPICK_TABLE6, "Run silently", 'run_silently')
		add_label_entry($TPICK_TABLE6, "Default mode", 'default_mode')
		add_label_entry($TPICK_TABLE7, "Use Lmaster Focus", 'use_lmaster_focus')
		add_label_entry($TPICK_TABLE7, "Light (205)", 'always_use_205')
		add_label_entry($TPICK_TABLE7, "Presence (402)", 'always_use_402')
		add_label_entry($TPICK_TABLE7, "Lock Pick Enhancement (403)", 'always_use_403')
		add_label_entry($TPICK_TABLE7, "Disarm Enhancement (404)", 'always_use_404')
		add_label_entry($TPICK_TABLE7, "Unlock (407)", 'always_use_407')
		add_label_entry($TPICK_TABLE7, "Disarm (408)", 'always_use_408')
		add_label_entry($TPICK_TABLE7, "Self Control (613)", 'always_use_613')
		add_label_entry($TPICK_TABLE7, "Song of Luck (1006)", 'always_use_1006')
		add_label_entry($TPICK_TABLE7, "Song of Tonis (1035)", 'always_use_1035')
		add_label_entry($TPICK_TABLE7, "Percent mana to keep", 'percent_mana_to_keep')
		add_label_entry($TPICK_TABLE8, "Use Vaalin when Fried", 'use_vaalin_when_fried')
		add_label_entry($TPICK_TABLE8, "Rest at Percent", 'rest_percent')
		add_label_entry($TPICK_TABLE8, "Pick at Percent", 'pick_percent')
		add_label_entry($TPICK_TABLE9, "Ready", 'ready')
		add_label_entry($TPICK_TABLE9, "Can't Open Box", 'cant_open_box')
		add_label_entry($TPICK_TABLE9, "Scarab Found", 'scarab_found')
		add_label_entry($TPICK_TABLE9, "Scarab safe", 'scarab_safe')
		add_label_entry($TPICK_TABLE10, "Phase (704)", 'always_use_704')
		add_label_entry($TPICK_TABLE10, "Number of 416 casts", 'number_of_416_casts')
		add_label_entry($TPICK_TABLE10, "Only disarm safe", 'only_disarm_safe')
		add_label_entry($TPICK_TABLE11, "Max critter level", 'max_critter_level')
		add_label_entry($TPICK_TABLE11, "Minimum tip wanted", 'minimum_tip_wanted')
		add_label_entry($TPICK_TABLE11, "Use 403 based on critter level", 'use_403_based_on_critter_level')
		add_label_entry($TPICK_TABLE11, "Use 404 based on critter level", 'use_404_based_on_critter_level')
		add_label_entry($TPICK_TABLE11, "Rest when fried", 'pool_picking_rest_when_fried')
		add_label_entry($TPICK_TABLE11, "Picks to use based on critter level", 'picks_to_use_based_on_critter_level')
		add_label_entry($TPICK_TABLE12, "Lockpick", 'lockpick_to_use_for_rogues_tasks')
	}

	def self.add_checkbox(table, x_pos, label, variable, default = false)
		size = $TPICK_TABLE_SIZE[table] || 0
		checkbox = Gtk::CheckButton.new label
		value = UserVars.tpick[variable].nil? ? default : UserVars.tpick[variable]
		checkbox.set_active(value)
		table.attach(checkbox, x_pos, x_pos + 1, size, size + 1)
		$TPICK_ENTRY[variable] = checkbox
		$TPICK_TABLE_SIZE[table] += 1 if x_pos == 1
	end
        
	Gtk.queue {
		$TPICK_WINDOW.signal_connect("delete_event") {
			$TPICK_SETUP_COMPLETED = true
		}
	}
        
	Gtk.queue {

		label = Gtk::Label.new
		label.set_markup("
		<b>YOU MUST FILL OUT EACH FIELD IN THIS TAB. READ THE BELOW INSTRUCTIONS.</b>
		Enter the FULL name of your lockpicks above, NOT including the words 'a' or 'an'.
		If you are using a <b>KEYRING</b> for your lockpicks enter the full name as they appear when you LOOK ON KEYRING.
		If you don't have a particular lockpick use the next best lockpick.
		For example if you don't have a steel lockpick then put the name of your gold lockpick in both the steel and gold lockpick variables.
		You can enter multiple lockpicks of the same kind by separating them with a comma.
		For example if you have two copper lockpicks you can enter the following in the Copper Lockpick setting: dark red copper lockpick,red tinted copper lockpick.
		Note no space after the comma.
		")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$TPICK_TABLE1.attach(align, 1, 2, 8, 20)

		label = Gtk::Label.new
		label.set_markup("
		<b>YOU MUST FILL OUT EACH FIELD IN THIS TAB. READ THE BELOW INSTRUCTIONS.</b>
		Enter the FULL name of your lockpicks above, NOT including the words 'a' or 'an'.
		If you are using a <b>KEYRING</b> for your lockpicks enter the full name as they appear when you LOOK ON KEYRING.
		If you don't have a particular lockpick use the next best lockpick.
		For example if you don't have a steel lockpick then put the name of your gold lockpick in both the steel and gold lockpick variables.
		You can enter multiple lockpicks of the same kind by separating them with a comma.
		For example if you have two copper lockpicks you can enter the following in the Copper Lockpick setting: dark red copper lockpick,red tinted copper lockpick.
		Note no space after the comma.
		")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$TPICK_TABLE2.attach(align, 1, 2, 8, 100)

		label = Gtk::Label.new
		label.set_markup("<b>IF YOU DO NOT WANT TO USE A SETTING IN THIS TAB THEN LEAVE THE FIELD BLANK.</b>\nEnter the LONG NAME of your container, for example if you TAP your 'a long red flowing cloak' and the game says 'You tap a red cloak.' enter 'red cloak' for your container.\n<b>Broken Lockpick Container:</b>  Container where script will store your broken lockpicks.\n<b>Locksmith's Container:</b>  Container where putty and cotton balls are found.\n<b>Containers to open at start:</b> Enter full names of every container you want opened when script starts, separated by a comma. Example: blue heavy backpack, black soft fur cloak\n<b>Containers to close before exit:</b> Same as above but for closing containers before script exits.\n<b>Other containers:</b> List all other item names/item types and the containers you want them to go into. Separate the names/types and containers by \":\" and separate each of these by a comma.\nExample: gem: sack, diamond: soft brown cloak, silver wand: ebony pack\nNote you can use either the full name of a container or just the noun, but if you are wearing more than one of a particular container (like two sacks) be sure to use full names.\nNames will be matched before types. Example if you have: \"gem: pack, diamond: cloak\" then all diamonds will be put into your cloak and all other gems will be put into your pack.\nAny Lich item types will work, here are the more common ones: herb, gem, armor, weapon, reagent, jewelry, uncommon, scroll, clothing, collectible, cursed, wand\nThis setting is completely optional. If you leave it blank the script will STOW everything other than your lockpicks, wedges, etc.")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$TPICK_TABLE3.attach(align, 1, 2, 8, 100)

		label = Gtk::Label.new
		label.set_markup("<b>IF YOU DO NOT WANT TO USE A SETTING IN THIS TAB THEN LEAVE THE FIELD BLANK.</b>\n<b>Auto deposit silvers:</b> Enter <b>yes</b> to auto deposit silvers when encumbered and picking pool boxes or ground picking and looting.\n<b>Gnomish Bracer:</b>  Enter name and tier of your gnomish bracer (example: bracer,1).\n<b>Gnomish Bracer:</b> Entering <b>,override</b> (for example: bracer,1,override) at the end will only use bracers for disarming and will use <b>lockpick container</b> setting to find and store lockpicks.\n<b>Bashing Weapon:</b>  Name of weapon to use for bashing boxes.\n<b>Scale Trap Weapon:</b>  FULL name of weapon you use for disarming scale traps, not including 'a' or 'an'.\n<b>Remove armor:</b> Enter the name of your armor if you want script to remove your armor before casting a spell, script will automatically wear armor again before it exists.\n<b>Max Lock:</b> The highest lock you are willing to attempt (any locks higher than this will be wedged/popped or skipped).\nDoing something like <b>-100</b> would instead only attempt locks that are at most 100 lower than your max skill with a vaalin lockpick.\n<b>Max Lock Roll:</b>  For example enter <b>30</b> and when you roll lower than 30 when picking locks the script will attempt to pick again no matter what messaging you received.\nLeave blank if you want script to always move to higher lockpicks when receiving a message that you aren't able to pick the current lock with the current lockpick.\nThe messages this setting is for is when you bend your lockpick, the script will always move to higher lockpick if you break your lockpick.\n<b>Trap Roll:</b>  Determines what difficulty boxes you want to attempt.\nSet to 0 to never try anything higher than your total disarm skill + lore bonus.\nSetting to 10 would attempt traps 10 points higher than your disarm skill + lore bonus.\nSetting to -10 would only attempt traps that are a maximum of 10 points lower than your disarm skill + lore bonus.\nSet this value to whatever number you want. A value of 1000 would attempt to disarm all traps.\nScript will always use 404 if it determines you need the spell to disarm a trap.")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$TPICK_TABLE4.attach(align, 1, 2, 8, 100)

		label = Gtk::Label.new
		label.set_markup("<b>IF YOU DO NOT WANT TO USE A SETTING IN THIS TAB THEN LEAVE THE FIELD BLANK.</b>\n<b>Trick:</b>  Trick to use when picking locks. Enter: spin, twist, turn, twirl, toss, bend or flip.  Enter <b>pick</b> if you don't want to use a trick.\nEnter <b>random</b> to use a random trick each time you pick a box, ONLY USE THIS IF YOU KNOW ALL THE TRICKS.\n<b>Log:</b>  Enter <b>yes</b> to display a summary of all loot found when done.\n<b>Trash boxes:</b>  Enter <b>yes</b> to dispose of empty boxes if possible, <b>no</b> will drop them on the ground, <b>save</b> STOWS empty boxes.\n<b>Calibrate on startup:</b>  <b>yes</b> to calibrate your calipers when the script is started, <b>no</b> to skip calibrating, <b>never</b> to never use calipers/loresinging and default to using a vaalin lockpick.\n<b>Calibrate Count:</b>  Will calibrate your calipers every time you pick this many boxes. (enter 999 to never calibrate)\nAnother option: Example: Enter \"auto 50\" for script to calibrate your calipers as soon as it notices your calipers readings are 50+ off from an actual lock difficulty.\n<b>Auto Bundle Vials:</b> Enter <b>yes</b> to have script bundle vials you get from disarming traps into your locksmith's container.\n<b>Auto repair bent lockpicks:</b>  Enter <b>yes</b> to have script automatically repair lockpicks after they have been bent. Only works if you have learned lmas repair.\n<b>Number of times to check for traps:</b>  How many times you want script to manually check for traps.")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$TPICK_TABLE5.attach(align, 1, 2, 8, 100)
		
		label = Gtk::Label.new
		label.set_markup("<b>IF YOU DO NOT WANT TO USE A SETTING IN THIS TAB THEN LEAVE THE FIELD BLANK.</b>\n<b>Lock Roll:</b>  Maximum roll allowed before moving to a higher lockpick.\nExample if this value is 50 and you roll a 60 and didn't pick the lock the script will move to the next lockpick. 50 is a good starting number.\n<b>Vaalin Lock Roll:</b>  Same as above but just for vaalin picks if you want to attempt to pick locks with a higher needed roll than other lockpicks. 80 is a good starting number.\n<b>This number should be equal or higher than Lock Roll.</b>\nSet to 1000 to always try picking a lock with a vaalin lockpick before moving on to a wedge or 407.\n<b>Lock Buffer</b>  Example: Enter 50 and the script will add +50 to lock difficulty from all caliper readings, just in case your caliper readings aren't 100% accurate.\n<b>Keep trying if within abilities:</b>  Enter <b>yes</b> to have script keep trying current lockpick if you receive messaging indicating you can pick the lock with your current lockpick.\n<b>Run silently:</b> Enter <b>yes</b> to not see most calculations feedback while script is running, important feedback will still be shown.\n<b>IMPORTANT:</b> If you run into any bugs or issues it is best to see all feedback and provide a log to Dreaven so he can more easily find the problem.\n<b>Default mode:</b> For example enter <b>solo</b> and solo will be the default mode if you don't specify one when starting script.\nOptions are: solo, other, ground, worker")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$TPICK_TABLE6.attach(align, 1, 2, 8, 100)

		label = Gtk::Label.new
		label.set_markup("<b>IF YOU DO NOT WANT TO USE A SETTING IN THIS TAB THEN LEAVE THE FIELD BLANK.
		</b>Enter <b>yes</b> for any spells you want to keep on while disarming/picking.
		<b>Use Lmaster Focus:</b> Enter <b>yes</b> to use LMASTER FOCUS instead of 403/404. You can still fill out the 403/404 settings below to work with LMASTER FOCUS.
		Set 403 and 404 to <b>no</b> to use these spells when needed (after a failure or for a very high lock).
		Set 403 and 404 to <b>cancel</b> to have these spells stopped when starting a new box.
		Set 404 to <b>detect</b> to use 404 when detecting traps but will cancel 404 if it's not needed to disarm the trap.
		Set 403/404 to <b>never</b> to NEVER use them.
		Set 403 or 404 to a number (like 100) to always use 403/404 if the lock/trap difficulty is above this number.
		Set 403/404 to <b>auto</b> to have script cast these spells when they are needed and to STOP these spells before disarming/picking if they aren't needed.
		You can combine these options by separating each command with a space or comma, for example you can do: auto 100 detect
		If <b>407</b> is set to <b>plate</b> the script will attempt to open plated boxes (except mithril or enruned) with 407 if you have no acid vials or wedges.
		If <b>407</b> is set to <b>all</b> the script will attempt to open all boxes (except mithril and enruned) with 407.
		Enter <b>plate, 50</b> or <b>all, 50</b> if you want to use 407 until you reach 50% of your maximum mana, then script will give up and move on. 50 can be any percent mana you want.
		Enter <b>no</b> for <b>407</b> to skip using 407 on boxes.
		<b>408:</b> Enter <b>scarab</b> to use 408 to disarm scarabs WHEN THEY ARE ON THE GROUND. This is currently the only use for this setting.
		<b>1035:</b> Script will not wait until you have enough mana to cast 1035, it will cast if you have enough mana or move on if you don't.
		<b>Percent mana to keep:</b>  For example enter <b>50</b> if you want to stop casting spells once your current mana reaches 50% or less than your max mana.
		Leave blank to always cast spells as long as you have enough mana.")
		align = Gtk::Alignment.new(1, 40, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$TPICK_TABLE7.attach(align, 1, 2, 8, 100)

		label = Gtk::Label.new
		label.set_markup("<b>IF YOU DO NOT WANT TO USE A SETTING IN THIS TAB THEN LEAVE THE FIELD BLANK.</b>\n<b>Use Vaalin when Fried:</b>  Enter <b>yes</b> to always use vaalin if you're fried.\n<b>Rest at Percent:</b>  Script will pause when your mind reaches this amount or higher.\n<b>Pick at Percent:</b>  Will start picking when your mind reaches this amount or lower.\nDoes not work when using OTHER command line.\nUse the following amounts\nmust rest:  100\nnumbed:  90\nbecoming numbed:  75\nmuddled:  62\nclear:  50\nfresh and clear:  25\nclear as a bell:  0")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$TPICK_TABLE8.attach(align, 1, 2, 8, 100)

		label = Gtk::Label.new
		label.set_markup("<b>IF YOU DO NOT WANT TO USE A SETTING IN THIS TAB THEN LEAVE THE FIELD BLANK.</b>\n<b>Ready:</b>  What to say when ready to be handed boxes from another person. Example: <b>Ready.</b>\n<b>Can't Open Box:</b>  What to say when you can't open a box for another person. Example: <b>Sorry can't open this box.</b>\n<b>Scarab Found:</b>  What to say before you disarm a scarab trap. Example: <b>Scarab coming down.</b>\n<b>Scarab Safe:</b> What to say after you have disarmed the scarab. For example: <b>Scarab safe.</b>")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$TPICK_TABLE9.attach(align, 1, 2, 8, 100)

		label = Gtk::Label.new
		label.set_markup("<b>IF YOU DO NOT WANT TO USE A SETTING IN THIS TAB THEN LEAVE THE FIELD BLANK.</b>\n<b>Phase (704):</b>  Enter <b>yes</b> to use Phase (704) on each box to check for glyph traps, <b>no</b> to skip Phase.\n<b>Number of 416 casts:</b>  Number of times you want to check a box for traps using Piercing Gaze (416).\n<b>Only disarm safe:</b>  Some traps can be bypassed altogether when using 407 to open the box and some traps are always safe to use 408 on.\nHowever some traps have a chance of being set off when using 408. \nEnter <b>yes</b> here to skip boxes with traps that are not 100% safe, <b>no</b> to attempt disarming them with 408.\nSome traps are never safe to use 408 on and the script will always skip these boxes no matter what value you enter here.")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$TPICK_TABLE10.attach(align, 1, 2, 8, 100)
		
		label = Gtk::Label.new
		label.set_markup("<b>IF YOU DO NOT WANT TO USE A SETTING IN THIS TAB THEN LEAVE THE FIELD BLANK.</b>\n<b>These options are only for pool/worker boxes.</b>\n<b>Max critter level:</b>  Maximum critter level of boxes you will work on, higher level boxes will be turned in.\n<b>Minimum tip wanted:</b>  Example: enter 1000, 40, 500 script would start asking for 1000+ silver jobs, when none are available it would subtract 40 and start asking for 960+ silver jobs.\nIt would keep doing this until it reached 500 silvers, at which point it would start over again at 1000. Another example: Enter 200 to always ask for 200+ jobs.\n<b>Use 403 based on critter level:</b>  Example: Enter 80 to always use 403 on boxes which come from critters level 80+\n<b>Use 404 based on critter level:</b>  Same as above but with 404.\n<b>Rest when fried:</b>  Example enter <b>112</b> if you want script to move you to room number 112 when you're fried, enter <b>112:go table</b> if you want script to move you to room number 112 then GO TABLE.\nScript will move you back to pool room when your mind reaches the level you specify in the <b>Pick at Percent</b> setting under the <b>Experience</b> tab.\nNote this setting doesn't go by when you're fried but rather when you receive messaging from the pool worker that you can't do anymore boxes until you let your mind clear out a bit.\n<b>The below setting works by default for non-rogues/bards. If you are a rogue/bard this setting only works if you use 'v' command line variable or you have set 'Calibrate on startup' to 'never.'</b>\n<b>Picks to use based on critter level:</b>  Below is an example of how to use this setting:\n10 copper, 20 steel, 30 gold, 50 lage, 75 invar, 90 kelyn\nThis would use your copper lockpick for critters up to level 10, steel for critters up to 20, etc.\nVaalin is used for any levels not specified, in the above example that would be for critters 91+.\n<b>DO NOT</b> use the names of your lockpicks, use the lockpick type, use the below list as a reference:\ncopper, steel, gold, silver, mithril, ora, glaes, laje, vultite, rolaren, veniom, invar, alum, golvern, kelyn, vaalin\n<b>Leave this blank if you don't want to use this feature.</b>")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$TPICK_TABLE11.attach(align, 1, 2, 8, 100)
		
	label = Gtk::Label.new
		label.set_markup("
		<b>Lockpick:</b> Leave blank to ignore this feature and use other settings to determine which pick to use.
		Enter the <b>QUALITY</b> of the lockpick to use when doing ;rogues tasks.
		For example enter \"steel\" to use whatever you have listed in your steel lockpick setting.
		If the script notices you can't get a rep using whatever you have set then it will change this setting to go up 1 level of quality.
		It's a good idea to have one lockpick of each kind to ensure you can easily get reps with these tasks.
		")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$TPICK_TABLE12.attach(align, 1, 2, 8, 100)

		$TPICK_WINDOW.show_all
	}
        
	$TPICK_SETUP_COMPLETED = false
	until($TPICK_SETUP_COMPLETED)
		sleep 1
	end
	
	UserVars.tpick ||= Hash.new
	$TPICK_ENTRY.keys.each { |key|
		if( $TPICK_ENTRY[key].class.to_s =~ /CheckButton/ )
			value = $TPICK_ENTRY[key].active?
			UserVars.tpick[key] = $TPICK_ENTRY[key].active?
		else
			UserVars.tpick[key] = $TPICK_ENTRY[key].text.strip.downcase
		end
	}

	UserVars.save()
        
	Gtk.queue {
		$TPICK_WINDOW.destroy
	}
}

if script.vars.any?{ |i| i =~ /setup/i }
	setup.call
	exit
end

if script.vars.any?{ |i| i =~ /return|pickup|drop|help/i }
	nil
else
	@tpick_lockpick_container = GameObj.inv.find{ |i| i.name =~ /#{UserVars.tpick["lockpick_container"]}/ }
	@tpick_broken_lockpick_container = GameObj.inv.find{ |i| i.name =~ /#{UserVars.tpick["broken_lockpick_container"]}/ }
	@tpick_wedge_container = GameObj.inv.find{ |i| i.name =~ /#{UserVars.tpick["wedge_container"]}/ }
	@tpick_calipers_container = GameObj.inv.find{ |i| i.name =~ /#{UserVars.tpick["calipers_container"]}/ }
	@tpick_scale_weapon_container = GameObj.inv.find{ |i| i.name =~ /#{UserVars.tpick["scale_weapon_container"]}/ }
	@tpick_locksmiths_container = GameObj.inv.find{ |i| i.name =~ /#{UserVars.tpick["locksmiths_container"]}/ }
end

check_locksmiths_container = proc{
	action = proc { |server_string|
		if server_string =~ /lump of squishy white putty with about (\d+) pinch|(\d+) little ball|(\d+) vials? of liquid|you see a pinch of squishy white putty/
			if server_string =~ /you see a lump of squishy white putty with about (\d+) pinch/
				putty_remaining = $1.to_i
			elsif server_string =~ /you see a pinch of squishy white putty/
				putty_remaining = 1
			else 
				putty_remaining = 0
			end
			if server_string =~ /(\d+) little ball/
				cotton_remaining = $1.to_i
			else
				cotton_remaining = 0
			end
			if server_string =~ /(\d+) vials? of liquid/
				vials_remaining = $1.to_i
			else
				vials_remaining = 0
			end
			DownstreamHook.remove("#{script.name}_check_locksmiths_container")
			nil
		elsif server_string =~ / and /
			(putty_remaining = 0) unless (putty_remaining)
			(cotton_remaining = 0) unless (cotton_remaining)
			(vials_remaining = 0) unless (vials_remaining)
			DownstreamHook.remove("#{script.name}_check_locksmiths_container")
			server_string
		else
			server_string
		end
	}
		DownstreamHook.add("#{script.name}_check_locksmiths_container", action)
		silence_me
		if running? "sorter"
			kill_script "sorter"
			wait_until { !running? "sorter" }
			start_sorter = true
		end
		fput "look in ##{@tpick_locksmiths_container.id}"
		silence_me
}

tpick_gather_the_loot = proc{
	waitrt?
	if current_item.name !~ /urglaes fang|doomstone/ && current_item.type != "box"
		gather_stuff.call
	end
	waitrt?
	if current_item.name !~ /coins/i && UserVars.tpick["log"] == "yes"
		record_item_data.call
	end
	if current_item.name !~ /urglaes fang|doomstone|coins/ && current_item.type != "box"
		wait_until { GameObj.right_hand.id == current_item.id || GameObj.left_hand.id == current_item.id }
		tpick_bundle_vials.call if UserVars.tpick["auto_bundle_vials"] == "yes" && current_item.name =~ /vial/ && (GameObj.right_hand.name =~ /vial/ || GameObj.left_hand.name =~ /vial/)
		tpick_put_stuff_away
	end
	waitrt?
}

ask_worker = proc{
	waitrt?
	result = dothistimeout "ask ##{worker.id} to check", 3, /If you want to give up\, ASK me to CHECK it again within 30 seconds\.\"|\"That\'s some quality work\.  Here\'s your payment of (.*) silvers?\.\"|You aren\'t working on a job\.|Too tough for ya\, eh\?/
	if result =~ /\"That\'s some quality work\.  Here\'s your payment of (.*) silvers?\.\"/
		CharSettings["total_silvers_earned_from_pool_picking"] += $1.delete(",").to_i
		silvers_earned_from_pool_picking_this_session += $1.delete(",").to_i
		CharSettings["number_of_total_boxes_picked_pool_picking"] += 1
		number_of_boxes_picked_this_session_pool_picking += 1
	elsif result =~ /If you want to give up\, ASK me to CHECK it again within 30 seconds\.\"|You aren\'t working on a job\.|Too tough for ya\, eh\?/
		nil
	elsif result.nil?
		echo "Didn't recognize game line I was looking for, trying again."
		ask_worker.call
	end
}

open_current_plinite = proc{
	tpick_put_stuff_away
	waitrt?
	fput "pluck ##{current_box.id}"
	@tpick_stow_current_box = true
	tpick_put_stuff_away
}

start_plinites = proc{
	$tpick_list_of_box_ids.each{ |plinite|
		tpick_put_stuff_away
		plinite_already_open = nil
		cannot_determine_plinite_difficulty = nil
		until GameObj.right_hand.id == plinite || GameObj.left_hand.id == plinite
			waitrt?
			fput "get ##{plinite}"
			sleep 0.2
		end
		current_box = GameObj.right_hand if GameObj.right_hand.name =~ /plinite/
		current_box = GameObj.left_hand if GameObj.left_hand.name =~ /plinite/
		@tpick_current_box = current_box
		detect_plinite.call
	}
}

tpick_bundle_vials = proc{
	start_script "sorter" if start_sorter
	if GameObj.right_hand.name =~ /vial/
		current_vial = GameObj.right_hand.id
	elsif GameObj.left_hand.name =~ /vial/
		current_vial = GameObj.left_hand.id
	end
	tpick_stow_box(current_box) if (solo_or_other == "solo" || solo_or_other == "other")
	tpick_put_stuff_away
	wait_until { checkright.nil? && checkleft.nil? }
	fput "remove ##{@tpick_locksmiths_container.id}"
	wait_until { checkright }
	fput "get ##{current_vial}"
	wait_until { checkleft }
	fput "bundle"
	fput "wear ##{@tpick_locksmiths_container.id}"
	wait_until { checkright.nil? }
	if solo_or_other == "solo" || solo_or_other == "other"	
		tpick_get_box(current_box)
		wait_until { checkright }
	end
}

detect_plinite_result = proc{
	waitrt?
	plinite_already_open = nil
	(tpick_cast_spells (404)) if (use_spell_404) || (need_404)
	result = dothistimeout "detect ##{current_box.id}", 3, /It looks like it would be.*\(\-(\d+)\)\.|You struggle to determine the difficulty of the extraction \(somewhere between .* and \-(\d+)\)\.|You promptly discover that the core has already been removed\.|You are unable to determine the difficulty of the extraction\.|You promptly discover that the core has already been extracted and merely needs to be PLUCKed from the tip of the shard\./
	if result =~ /It looks like it would be.*\(\-(\d+)\)\./ || result =~ /You struggle to determine the difficulty of the extraction \(somewhere between .* and \-(\d+)\)\./
		lock = $1.to_i
	elsif result =~ /You promptly discover that the core has already been removed\./
		echo "This plinite has already been extracted."
		tpick_put_stuff_away
		plinite_already_open = true
	elsif result =~ /You are unable to determine the difficulty of the extraction\./
		cannot_determine_plinite_difficulty = true
		lock = 1000000
	elsif result =~ /You promptly discover that the core has already been extracted and merely needs to be PLUCKed from the tip of the shard\./
		open_current_plinite.call unless solo_or_other == "worker"
		plinite_already_open = true
	elsif result.nil?
		detect_plinite_result.call
	end
}

detect_plinite = proc{
	i_need_403 = nil
	need_404 = "yes" unless UserVars.tpick["always_use_404"] =~ /never/i
	waitrt?
	3.times{
		waitrt?
		unless GameObj.right_hand.id == $vaalin_lockpick_id || GameObj.left_hand.id == $vaalin_lockpick_id
			fput "get ##{$vaalin_lockpick_id}"
			sleep 0.2
		end
	}
	if GameObj.right_hand.id != $vaalin_lockpick_id && GameObj.left_hand.id != $vaalin_lockpick_id
		echo "Couldn't find your #{UserVars.tpick["vaalin"]}."
		exit
	end
	detect_plinite_result.call
	tpick_put_stuff_away
	if plinite_already_open == nil
		total_pick_skill = (pick_skill + pick_lore) * 2.50
		if lock > (total_pick_skill + UserVars.tpick["vaalin_lock_roll"].to_i)
			if solo_or_other == "worker"
				echo "Can't extract this plinite based on my calculations. If you think this is in error increase the Vaalin Lock Roll setting in the setup menu."
				cannot_determine_plinite_difficulty = nil
				ask_worker.call
			else
				echo "Can't extract this plinite, OPENing it instead. If you think this is in error increase the Vaalin Lock Roll setting in the setup menu."
				cannot_determine_plinite_difficulty = nil
				waitrt?
				fput "open ##{current_box.id}"
			end
		else
			number = 0
			pick_mod.each do |i|
				total_pick_skill = (pick_skill + pick_lore)
				if (total_pick_skill) * 2.50 - lock + UserVars.tpick["lock_roll"].to_i < 100 || cannot_determine_plinite_difficulty
					needed_pick = UserVars.tpick["vaalin"]
					needed_pick_id = vaalin_lock_pick_array.first
					need_403 = "yes" unless UserVars.tpick["always_use_403"] =~ /never/i
					need_404 = "yes" unless UserVars.tpick["always_use_404"] =~ /never/i
					i_need_403 = true unless UserVars.tpick["always_use_403"] =~ /never/i
					number = 15
					break
				else
					total_pick_skill = (pick_skill) * i
					if total_pick_skill - lock + UserVars.tpick["lock_roll"].to_i < 100
						number += 1
						unless UserVars.tpick["always_use_403"] =~ /never/i
							i_need_403 = true if number > 14
						end
					else
						break
					end
				end
				if use_403_for_lock_difficulty && Spell[403].known? && lock > use_403_for_lock_difficulty
					i_need_403 = true
				end
			end
			if i_need_403
				number = 0
				need_403 = "yes" unless UserVars.tpick["always_use_403"] =~ /never/i
				need_404 = "yes" unless UserVars.tpick["always_use_404"] =~ /never/i
				pick_mod.each do |i|
					total_pick_skill = (pick_skill + pick_lore) * i
					if total_pick_skill - lock + UserVars.tpick["lock_roll"].to_i < 100
						number += 1
					else
						break
					end
				end
			end
			number = [15, number].min
			if number == 0
				$tpick_recommended_pick = "copper"
			elsif number == 1
				$tpick_recommended_pick = "steel"
			elsif number == 2
				$tpick_recommended_pick = "gold"
			elsif number == 3
				$tpick_recommended_pick = "silver"
			elsif number == 4
				$tpick_recommended_pick = "mithril"
			elsif number == 5
				$tpick_recommended_pick = "ora"
			elsif number == 6
				$tpick_recommended_pick = "glaes"
			elsif number == 7
				$tpick_recommended_pick = "laje"
			elsif number == 8
				$tpick_recommended_pick = "vultite"
			elsif number == 9
				$tpick_recommended_pick = "rolaren"
			elsif number == 10
				$tpick_recommended_pick = "veniom"
			elsif number == 11
				$tpick_recommended_pick = "invar"
			elsif number == 12
				$tpick_recommended_pick = "alum"
			elsif number == 13
				$tpick_recommended_pick = "golvern"
			elsif number == 14
				$tpick_recommended_pick = "kelyn"
			elsif number > 14
				$tpick_recommended_pick = "vaalin"
			end
			lock_pick_information.call
			echo "Recommended lock pick: #{$tpick_recommended_pick} with a modifier of #{recommended_pick_modifier}" if UserVars.tpick["run_silently"] !~ /yes/i
			if need_403 == "yes"
				if use_403_for_lock_difficulty && Spell[403].known? && lock > use_403_for_lock_difficulty
					echo "Lock difficulty is higher than your 403 setting in setup menu, using 403." if UserVars.tpick["run_silently"] !~ /yes/i
				else
					echo "Recommend 403: Yes" if UserVars.tpick["run_silently"] !~ /yes/i
				end
				echo "Your calculated lockpicking skill: #{pick_skill}" if UserVars.tpick["run_silently"] !~ /yes/i
				echo "Your calculated lockpicking lore: #{pick_lore}" if UserVars.tpick["run_silently"] !~ /yes/i
				temp_math_number = pick_skill + pick_lore
			else
				echo "Recommend 403: No" if UserVars.tpick["run_silently"] !~ /yes/i
				echo "Your calculated lockpicking skill: #{pick_skill}" if UserVars.tpick["run_silently"] !~ /yes/i
				temp_math_number = pick_skill
			end
			quick_maths = (temp_math_number * recommended_pick_modifier).truncate
			echo "Your total picking skill for this attempt is: #{quick_maths}" if UserVars.tpick["run_silently"] !~ /yes/i
			echo "Lock difficulty: #{lock}" if UserVars.tpick["run_silently"] !~ /yes/i
			if needed_pick_id.nil?
				if $tpick_recommended_pick == "vaalin"
					5.times{ echo "ALL OF YOUR VAALIN LOCKPICKS ARE BROKEN. YOU REALLY SHOULD HAVE AT LEAST 1 WORKING VAALIN LOCKPICK WHEN RUNNING THIS SCRIPT." }
					exit
				else
					echo "All of your #{$tpick_recommended_pick} lockpicks seem to be broken, trying a higher tier lockpick."
				end
				nextpick.call
			else
				pick2.call
			end
		end
	elsif plinite_already_open
		ask_worker.call if solo_or_other == "worker"
	end
}

pop_start = proc{
	$tpick_list_of_box_ids.each{ |box|
		current_box = box
		@tpick_current_box = current_box
		pop_boxes_begin.call
	}
	check_disk.call
}

cast_704_at_box = proc{
	waitrt?
	waitcastrt?
	tpick_prep_spell(704, "Phase")
	result = dothistimeout "cast at ##{current_box.id}", 3, /resists the effects of your magic|appears lighter|then stabilizes|but quickly returns to normal|Roundtime/
	if result =~ /resists the effects of your magic/
		echo "Box has a glyph trap and cannot be opened."
		tpick_drop_box(current_box) if solo_or_other == "ground"
		where_to_stow_box.call if solo_or_other == "solo"
		box_opened = nil
	elsif result =~ /appears lighter|then stabilizes|but quickly returns to normal|Roundtime/
		echo "Box has no glyph trap. Checking for other traps."
		tpick_drop_box(current_box)
		tpick_get_box(current_box) if solo_or_other != "ground"
		check_for_trap.call
	elsif result.nil?
		cast_704_at_box.call
	end
}

pop_boxes_begin = proc{
	tpick_put_stuff_away
	until checkright
		fput "get ##{current_box}"
		sleep 0.2
	end
	current_box = GameObj.right_hand
	@tpick_current_box = current_box
	start_time = Time.now
	remaining_416_casts = UserVars.tpick["number_of_416_casts"].to_i
	stuff_to_do.call
	check_for_command = "glance"
	check_hands_status = nil
	check_for_mithril_or_enruned.call
	wait_until { check_hands_status }
	if check_hands_status == "mithril or enruned"
		echo "Can't open this box because it is mithril or enruned."
		waitrt?
		tpick_drop_box(current_box) if solo_or_other == "ground"
		where_to_stow_box.call if solo_or_other == "solo"
		box_opened = nil
	elsif check_hands_status == "empty"
		echo "No box was found in your hands."
		exit
	else
		if use_spell_704
			cast_704_at_box.call
		else
			echo "Checking for traps." if UserVars.tpick["run_silently"] !~ /yes/i
			tpick_drop_box(current_box) if solo_or_other == "ground"
			check_for_trap.call
		end
	end
}

where_to_stow_box = proc{
	if solo_or_other == "solo"
		if stow_in_disk
			fput "put ##{current_box.id} in #{checkname} disk"
		else
			tpick_stow_box(current_box)
		end
	end
}

gnomish_bracers_trap_check_result = proc{
	waitrt?
	result = dothistimeout "rub my #{gnomish_bracers}", 3, /begins to glow with a deep red light|begins to glow with a bright green light/
	if result =~ /begins to glow with a deep red light/
		waitrt?
		manually_disarm_trap.call
	elsif result =~ /begins to glow with a bright green light/
		waitrt?
		if (disarm_only)
			if (bash_open_boxes)
				bash_the_box_open.call
			else
				box_counts_for_math = nil
				tpick_drop_box(current_box)
			end
		else
			measure.call
		end
	elsif result.nil?
		gnomish_bracers_trap_check_result.call
	end
}

help_menu_display = proc{
	respond
	5.times{ _respond "#{monsterbold_start}#################################################################################{monsterbold_end}\n" }
	_respond "#{monsterbold_start}TPICK HELP MENU#{monsterbold_end}\n"
	_respond "#{monsterbold_start}Help options:#{monsterbold_end}\n"
	_respond "Enter #{monsterbold_start}1#{monsterbold_end} for more information about picking modes and command line variables."
	_respond "Enter #{monsterbold_start}2#{monsterbold_end} for more information about settings under the Lockpicks/Lockpicks 2 tabs."
	_respond "Enter #{monsterbold_start}3#{monsterbold_end} for more information about settings under the Containers tab."
	_respond "Enter #{monsterbold_start}4#{monsterbold_end} for more information about settings under the Other tab."
	_respond "Enter #{monsterbold_start}5#{monsterbold_end} for more information about settings under the More Other tab."
	_respond "Enter #{monsterbold_start}6#{monsterbold_end} for more information about settings under the Yet More Other tab."
	_respond "Enter #{monsterbold_start}7#{monsterbold_end} for more information about settings under the Spells tab."
	_respond "Enter #{monsterbold_start}8#{monsterbold_end} for more information about settings under the Experience tab."
	_respond "Enter #{monsterbold_start}9#{monsterbold_end} for more information about settings under the Speech tab."
	_respond "Enter #{monsterbold_start}10#{monsterbold_end} for more information about settings under the Popping tab."
	_respond "Enter #{monsterbold_start}11#{monsterbold_end} for more information about settings under the Pool/Worker tab."
	_respond "Enter #{monsterbold_start}anything else#{monsterbold_end} to exit ;tpick and the help menu."
	5.times{ _respond "#{monsterbold_start}#################################################################################{monsterbold_end}\n" }
	respond
	toggle_upstream
	command = upstream_get
	if command =~ /^\<c\>1$/
		respond
		5.times{ _respond "#{monsterbold_start}#################################################################################{monsterbold_end}\n" }
		_respond "#{monsterbold_start}Picking modes:#{monsterbold_end}\n"
		_respond "#{monsterbold_start}You must enter a picking mode when starting the script.#{monsterbold_end}\n"
		_respond "#{monsterbold_start};tpick solo:#{monsterbold_end} Pick all boxes in your open containers."
		_respond "#{monsterbold_start};tpick other:#{monsterbold_end} Wait for someone to GIVE you a box, you will then pick the box and GIVE it back to the person."
		_respond "#{monsterbold_start};tpick ground:#{monsterbold_end} Pick all boxes on the ground."
		_respond "#{monsterbold_start};tpick worker:#{monsterbold_end} Pick boxes at a pool. Only works if you're in a pool room when starting script."
		respond
		_respond "#{monsterbold_start}Command line variables:#{monsterbold_end}\n"
		_respond "#{monsterbold_start}Command line variables must be entered when starting the script and do different things. For example you can do ;tpick solo v relock. The order doesn't matter, ;tpick solo v relock and ;tpick relock solo v would both work and do the same thing.#{monsterbold_end} "
		_respond "#{monsterbold_start}plin:#{monsterbold_end} Will open plinites."
		_respond "#{monsterbold_start}bash:#{monsterbold_end} Attempt to bash open boxes instead of picking them."
		_respond "#{monsterbold_start}disarm:#{monsterbold_end} ONLY disarm traps, won't pick the lock."
		_respond "#{monsterbold_start}relock:#{monsterbold_end} Will relock boxes after picking them, this is useful if you're working on guild reps."
		_respond "#{monsterbold_start}drop:#{monsterbold_end} Drop off all boxes in open container at the pool. Example: ';tpick drop 100' would tip 100 silvers per box, ';tpick drop 10 percent' or ';tpick drop 10%' would tip 10% per box."
		_respond "#{monsterbold_start}return or pickup:#{monsterbold_end} Pick up all boxes from the pool."
		_respond "#{monsterbold_start}c:#{monsterbold_end} Always start with a copper lockpick and work up towards higher lockpicks when necessary based on messaging."
		_respond "#{monsterbold_start}v:#{monsterbold_end} Skip using calipers or loresinging and always use a vaalin lockpick. Non-rogues/bards by default always use vaalin lockpicks."
		_respond "#{monsterbold_start}wedge:#{monsterbold_end} Always use wedges to open boxes instead of using lockpicks."
		_respond "#{monsterbold_start}pop:#{monsterbold_end} Use 407/408 to disarm and open all boxes."
		_respond "#{monsterbold_start}reset:#{monsterbold_end} Reset the number of boxes picked and average time to open each box stats."
		_respond "#{monsterbold_start}stat:#{monsterbold_end} View various stats ;tpick keeps track of."
		_respond "#{monsterbold_start}buy:#{monsterbold_end} Script will go to nearest locksmith shop and fill your locksmith container with putty and cotton balls."
		_respond "#{monsterbold_start}repair:#{monsterbold_end} Script will repair any lockpicks that need repairing. Must be a rogue with the lmas skill to repair lockpicks. Currently repair only works in Icemule, Landing, Sol Haven and Illistim."
		_respond "#{monsterbold_start}loot:#{monsterbold_end} This is used with ground picking mode. By default ground picking just picks boxes on the ground but doesn't take the loot out of the boxes, use this command line variable to loot boxes after opening them."
	elsif command =~ /^\<c\>2$/
		5.times{ _respond "#{monsterbold_start}#################################################################################{monsterbold_end}\n" }
		_respond "#{monsterbold_start}Lockpicks and Lockpicks 2 tabs:#{monsterbold_end}\n"
		_respond "Enter the FULL name of your lockpicks in each setting, DO NOT include the beginning 'a' or 'an'."
		_respond "If you don't use a specific lockpick then enter the name of your next highest lockpick that you do use in that setting."
		_respond "For example: if you don't use steel or gold lockpicks then enter the name of your Silver Lockpick in the Steel Lockpicking setting, Gold Lockpick setting, and Silver Lockpick setting."
	elsif command =~ /^\<c\>3$/
		respond
		5.times{ _respond "#{monsterbold_start}#################################################################################{monsterbold_end}\n" }
		_respond "#{monsterbold_start}FOR ANY SETTING YOU DO NOT WANT TO USE LEAVE THAT SETTING BLANK#{monsterbold_end}\n"
		respond
		_respond "#{monsterbold_start}Containers tab:#{monsterbold_end}\n"
		_respond "#{monsterbold_start}FOR BELOW DO THIS: Enter the LONG NAME of your container, for example if you TAP your 'a long red flowing cloak' and the game says 'You tap a red cloak.' enter 'red cloak' for your container.#{monsterbold_end}\n"
		_respond "#{monsterbold_start}Lockpick container:#{monsterbold_end} Enter the LONG NAME of the container where you store your lockpicks."
		_respond "#{monsterbold_start}Broken lockpick container:#{monsterbold_end} Enter the LONG NAME of the container where you want your broken lockpicks stored."
		_respond "#{monsterbold_start}Wedge container:#{monsterbold_end} Enter the LONG NAME of the container where you store your wedges."
		_respond "#{monsterbold_start}Calipers container:#{monsterbold_end} Enter the LONG NAME of the container where you store your calipers."
		_respond "#{monsterbold_start}Scale weapon container:#{monsterbold_end} Enter the LONG NAME of the container where you store your weapon for disarming scale traps."
		_respond "#{monsterbold_start}Locksmith's container:#{monsterbold_end} Enter the LONG NAME of the container which stores your putty and cotton balls."
		_respond "#{monsterbold_start}Containers to open at start:#{monsterbold_end} Enter the LONG NAME of all containers you want the script to open when started, separated by a comma. For example enter: blue heavy backpack, black soft fur cloak, green knapsack and the script will open these containers whenever it is started."
		_respond "#{monsterbold_start}Containers to close before exit:#{monsterbold_end} Same as the above setting but this is for containers you want the script to close before it exits."
		_respond "#{monsterbold_start}Other containers:#{monsterbold_end} List all other item names/item types and the containers you want them to go into. Separate the names/types and containers by ':' and separate each of these by a comma. For example enter: gem: sack, diamond: soft brown cloak, silver wand: ebony pack and the script will store all gems in your sack, all diamonds in your soft brown cloak, and all silver wands in your ebony pack."
		_respond "Names will be matched before types, in the example above diamonds will always be put into your soft brown cloak and all other gems will be put into your sack."
		_respond "Any Lich item type will work, here are the more common ones: herb, gem, armor, weapon, reagent, jewelry, uncommon, scroll, clothing, collectible, cursed, wand"
	elsif command =~ /^\<c\>4$/
		respond
		5.times{ _respond "#{monsterbold_start}#################################################################################{monsterbold_end}\n" }
		_respond "#{monsterbold_start}FOR ANY SETTING YOU DO NOT WANT TO USE LEAVE THAT SETTING BLANK#{monsterbold_end}\n"
		respond
		_respond "#{monsterbold_start}Other tab:#{monsterbold_end}\n"
		_respond "#{monsterbold_start}Auto deposit silvers:#{monsterbold_end} Enter 'yes' to have script auto deposit your silvers at the nearest bank when encumbered and picking pool boxes or ground picking with looting option."
		_respond "#{monsterbold_start}Gnomish Bracer:#{monsterbold_end} Enter name and tier of your gnomish bracer. For example: bracer, 1. Enter: bracer, 1, override to only use bracers for disarming."
		_respond "#{monsterbold_start}Bashing weapon:#{monsterbold_end} Enter name of weapon to use for bashing boxes."
		_respond "#{monsterbold_start}Scale trap weapon:#{monsterbold_end} Enter name of weapon you use to disarm scale traps."
		_respond "#{monsterbold_start}Remove armor:#{monsterbold_end} Enter the name of your armor if you want the script to remove your armor before casting a spell (script won't remove armor at tables). Script will automatically wear your armor again before exiting."
		_respond "#{monsterbold_start}Max Lock:#{monsterbold_end} Enter the highest number lock you are willing to attempt to pick, any lock higher than this will be wedged/popped or skipped altogether."
		_respond "If you enter for example -100 in the Max Lock setting then the script will only attempt to pick locks that are at most 100 lower than your skill with a vaalin lockpick. For example if your total skill wih a vaalin lockpick is 1000 then setting this to -100 would only attempt to pick locks with a difficulty of at most 900."
		_respond "#{monsterbold_start}Max Lock Roll:#{monsterbold_end} By default the script will move on to the next highest lockpick/wedge/popping whenever you receive messaging that you bent your lockpick (to avoid potentially breaking your lockpick.) In this setting you can enter for example 30 and if you roll lower than 30 then the script will ignore any bent lockpick messaging and attempt to pick the lock again with the same lockpick."
		_respond "#{monsterbold_start}Trap Roll:#{monsterbold_end} Highest trap difficulty you want to try to disarm. Setting this to 0 would never try anything higher than your total disarm skill + lore bonus. For example set this to 10 to attempt traps 10 points higher than your total disarm skill + lore bonus. For example set this to -10 to only attempt traps 10 points lower than your total disamr skill + lore bonus. Set this value to whatever you wish, a value of 1000 would attempt to disarm all traps."
	elsif command =~ /^\<c\>5$/
		respond
		5.times{ _respond "#{monsterbold_start}#################################################################################{monsterbold_end}\n" }
		_respond "#{monsterbold_start}FOR ANY SETTING YOU DO NOT WANT TO USE LEAVE THAT SETTING BLANK#{monsterbold_end}\n"
		respond
		_respond "#{monsterbold_start}More Other tab:#{monsterbold_end}\n"
		_respond "#{monsterbold_start}Trick:#{monsterbold_end} Enter trick you want to use when picking locks. Options are: spin, twist, turn, twirl, toss, bend, flip. Enter pick to not use a trick. You can also enter 'random' to use a random trick, ONLY USE RANDOM IF YOU KNOW ALL TRICKS."
		_respond "#{monsterbold_start}Log:#{monsterbold_end} Enter 'yes' to display a summary of all loot found before script exits."
		_respond "#{monsterbold_start}Trash boxes:#{monsterbold_end} This setting is for solo mode. Enter 'yes' to dispose of empty boxes in trash containers if one is in the room/do 'clean table' if at a table, enter 'no' to drop empty boxes on the ground, enter 'save' to stow empty boxes."
		_respond "#{monsterbold_start}Calibrate on startup:#{monsterbold_end} Enter 'yes' to calibrate your calipers when script is started. Enter 'never' to NEVER use calipers or loresinging to get lock difficulty and instead you will ALWAYS use a vaalin lockpick. There is one exception to the 'never' setting: if you're using 'worker' mode then script can use picks based on the critter levels from which the box came from, these settings are found under the 'Pool/Worker' tab. Using 'never' setting will always use vaalin lockpicks when doing solo, other, or ground modes."
		_respond "#{monsterbold_start}Calibrate count:#{monsterbold_end} For example enter '5' to calibrate your calipers after you have picked 5 boxes. Enter 999 to never calibrate your calipers. Another option: Example: Enter 'auto 50' to have script calibrate your calipers whenever your caliper readings are 50+ off from the actual lock difficulty."
		_respond "#{monsterbold_start}Auto Bundle Vials:#{monsterbold_end} Enter 'yes' to have script bundle vials into your locksmith's container while disarming traps which give vials."
		_respond "#{monsterbold_start}Auto repair bent lockpicks:#{monsterbold_end} Enter 'yes' to have script automatically repair lockpicks after they have been bent. This setting only works if you have learned lmas repair."
		_respond "#{monsterbold_start}Number of times to check for traps:#{monsterbold_end} For example enter '2' to have script check for traps 2 times before attempting to pick the lock. By default the script only checks for traps 1 time."
	elsif command =~ /^\<c\>6$/
		respond
		5.times{ _respond "#{monsterbold_start}#################################################################################{monsterbold_end}\n" }
		_respond "#{monsterbold_start}FOR ANY SETTING YOU DO NOT WANT TO USE LEAVE THAT SETTING BLANK#{monsterbold_end}\n"
		respond
		_respond "#{monsterbold_start}Yet More Other tab:#{monsterbold_end}\n"
		_respond "#{monsterbold_start}Lock Roll:#{monsterbold_end} Example if you enter '50' and roll a 60 and didn't pick the lock the script will move to the next lockpick. If you roll less than 50 the script will keep trying with the current lockpick."
		_respond "#{monsterbold_start}Vaalin Lock Roll#{monsterbold_end} Same as above but for when you are using a vaalin lockpick. THIS NUMBER SHOULD BE EQUAL TO OR HIGHER THAN LOCK ROLL VALUE. Set to 1000 to always use a vaalin lockpick instead of moving on to wedges or 407."
		_respond "#{monsterbold_start}Lock Buffer:#{monsterbold_end} Example enter '50' and the script will add +50 to lock difficulty from all caliper readings, just in case your caliper readings aren't 100% accurate."
		_respond "#{monsterbold_start}Keep trying if within abilities:#{monsterbold_end} By default script will always move on to next lockpick if you roll higher than your 'Lock Roll' setting. Example: Enter 'yes' for this setting and script won't move on to next lockpick if you receive messaging indicating the lock is within your abilities for the current lockpick."
		_respond "#{monsterbold_start}Run silently:#{monsterbold_end} Enter 'yes' to not see most calculations feedback while script is running, important feedback will still be shown."
		_respond "#{monsterbold_start}Default mode:#{monsterbold_end} For example enter 'solo' and solo will be the default mode if you don't specify one when starting script. Options are: solo, other, ground, worker."
	elsif command =~ /^\<c\>7$/
		respond
		5.times{ _respond "#{monsterbold_start}#################################################################################{monsterbold_end}\n" }
		_respond "#{monsterbold_start}FOR ANY SETTING YOU DO NOT WANT TO USE LEAVE THAT SETTING BLANK#{monsterbold_end}\n"
		respond
		_respond "#{monsterbold_start}Spells tab:#{monsterbold_end}\n"
		_respond "#{monsterbold_start}Enter yes for any spells you want to keep on while disarming/picking. The following spells have additional options:#{monsterbold_end}"
		_respond "#{monsterbold_start}403 and 404:#{monsterbold_end} With no option set the script will still cast these spells if it determines you need them. Set to 'cancel' to stop these spells when starting a new box. Enter 'never' for 403 to NEVER cast 403, even if script determines you need it. You can also enter for example 100 to always use 403/404 if the lock/trap difficulty is above 100. Finally you can enter for example '100,cancel' to use the previous setting and still have the spells canceled when starting a new box."
		_respond "#{monsterbold_start}407:#{monsterbold_end} Enter 'plate' to attempt to open all boxes (except mithril/enruned) with 407 if you have no acid vials or wedges. Enter 'all' to attempt to open all boxes with 407. Enter for example 'plate, 50' or 'all, 50' if you want to use 407 until you reach 50% of your maximum mana, then script will give up and move on. 50 can be any percent you want."
	elsif command =~ /^\<c\>8$/
		respond
		5.times{ _respond "#{monsterbold_start}#################################################################################{monsterbold_end}\n" }
		_respond "#{monsterbold_start}FOR ANY SETTING YOU DO NOT WANT TO USE LEAVE THAT SETTING BLANK#{monsterbold_end}\n"
		respond
		_respond "#{monsterbold_start}Experience tab:#{monsterbold_end}\n"
		_respond "#{monsterbold_start}Use vaalin when fried:#{monsterbold_end} Enter 'yes' to always use a vaalin lockpick when fried."
		_respond "#{monsterbold_start}Rest at percent:#{monsterbold_end} This doesn't work for 'other' mode: Script will pause when your mind reaches this amount or higher."
		_respond "#{monsterbold_start}Pick at percent:#{monsterbold_end} This doesn't work for 'other' mode: Script will start pickign when your mind reaches this amount or lower."
		_respond "#{monsterbold_start}Use the following amounts: must rest: 100, numbed: 90, becoming numbed: 75, muddled: 62, clear: 50, fresh and clear: 25, clear as a bell: 0#{monsterbold_end}"
	elsif command =~ /^\<c\>9$/
		respond
		5.times{ _respond "#{monsterbold_start}#################################################################################{monsterbold_end}\n" }
		_respond "#{monsterbold_start}FOR ANY SETTING YOU DO NOT WANT TO USE LEAVE THAT SETTING BLANK#{monsterbold_end}\n"
		respond
		_respond "#{monsterbold_start}Speech tab:#{monsterbold_end}\n"
		_respond "#{monsterbold_start}Ready:#{monsterbold_end} What to say when ready to be handed boxes from another person. Example: 'Ready.'"
		_respond "#{monsterbold_start}Can't open box:#{monsterbold_end} What to say when you can't open a box from another person. Example: 'Sorry can't open this box.'"
		_respond "#{monsterbold_start}Scarab found:#{monsterbold_end} What to say before you disarm a scarab trap. Example: 'Scarab coming down.'"
		_respond "#{monsterbold_start}Scarab safe:#{monsterbold_end} What to say after you have disarmed the scarab. Example: 'Scarab safe.'"
	elsif command =~ /^\<c\>10$/
		respond
		5.times{ _respond "#{monsterbold_start}#################################################################################{monsterbold_end}\n" }
		_respond "#{monsterbold_start}FOR ANY SETTING YOU DO NOT WANT TO USE LEAVE THAT SETTING BLANK#{monsterbold_end}\n"
		respond
		_respond "#{monsterbold_start}Popping tab:#{monsterbold_end}\n"
		_respond "#{monsterbold_start}Phase (704):#{monsterbold_end} Enter 'yes' to use Phase (704) on each box to check for glyph traps."
		_respond "#{monsterbold_start}Number of 416 casts:#{monsterbold_end} Number of times you want to check a box for traps using Piercing Gaze (416)."
		_respond "#{monsterbold_start}Only disarm safe:#{monsterbold_end} Some traps can be bypassed when using 407 and don't require 408 to be used, some traps are always safe to use 408 on. However some traps have a chance of being set off when using 408. Enter 'yes' here to skip boxes that are not 100% safe to use 408 on. Some traps are never safe to use 408 on and the script will always skip these boxes no matter what value you enter here."
	elsif command =~ /^\<c\>11$/
		respond
		5.times{ _respond "#{monsterbold_start}#################################################################################{monsterbold_end}\n" }
		_respond "#{monsterbold_start}FOR ANY SETTING YOU DO NOT WANT TO USE LEAVE THAT SETTING BLANK#{monsterbold_end}\n"
		respond
		_respond "#{monsterbold_start}Pool/Worker tab:#{monsterbold_end}\n"
		_respond "#{monsterbold_start}These options are only for pool/worker boxes.#{monsterbold_end}"
		_respond "#{monsterbold_start}Max critter level:#{monsterbold_end} Example enter '80' and you will work on boxes from critters level 80 or lower, higher level boxed will be turned in. Enter '1000' to work on all boxes."
		_respond "#{monsterbold_start}Minimum tip wanted:#{monsterbold_end} Example enter 1000, 40, 500 and script will start asking for 1000+ silver tip jobs, when none are available at that tip amount it would subtract 40 and start asking for 960+ silver jobs. It would continue this until it reached 500 then script would start over again at 1000. Another example: Enter '200' to always ask for 200+ jobs."
		_respond "#{monsterbold_start}Use 403 based on critter level:#{monsterbold_end} Example enter '80' to always use 403 on boxes which come from critters level 80+."
		_respond "#{monsterbold_start}Use 404 based on critter level:#{monsterbold_end} Same as above but for 404."
		_respond "#{monsterbold_start}Rest when fried:#{monsterbold_end} Example enter '112' if you want script to move you to room number 112 when you're friend, enter '112:go table' if you want script to move you to room 112 then GO TABLE. Script will move you back to the pool room when your mind reaches the level you specify in the 'Pick at Percent' setting under the 'Experience' tab."
		_respond "#{monsterbold_start} Picks to use based on critter level:#{monsterbold_end} This setting works by default for non-rogues/bards. If you are a rogue/bard this setting only works if you use the 'v' command line variable of you have set 'Calibrate on start' under the 'More Other' tab to 'never'"
		_respond "#{monsterbold_start}Picks to use based on critter level:#{monsterbold_end} Example: enter 10 copper, 20 steel, 30 gold, 50 lage, 75 invar, 90 kelyn. This would use your copper lockpick for critters up to level 10, steel for critters up to level 20, etc. Vaalin is used for any levels not specified, in the above example that would be for critters 91+. DO NOT use the names of your lockpicks, use the lockpick type, use this list as a reference: copper, steel, gold, silver, mithril, ora, glaes, laje, vultite, rolaren, veniom, invar, alum, golvern, kelyn, vaalin."
	else
		5.times{ _respond "#{monsterbold_start}#################################################################################{monsterbold_end}\n" }
		_respond "#{monsterbold_start}No help information was requested. Script is now exiting.#{monsterbold_end}"
	end
	respond
	5.times{ _respond "#{monsterbold_start}#################################################################################{monsterbold_end}\n" }
}

gnomish_bracers_trap_check = proc{
	if solo_or_other != "ground" && solo_or_other != "worker"
		wait_until { GameObj.right_hand.id != nil}
		current_box = GameObj.right_hand
		@tpick_current_box = current_box
	end
	tpick_get_box(current_box) if solo_or_other == "ground"
	if solo_or_other == "worker" && current_box.nil?
		until current_box
			dothistimeout "look on ##{table.id}", 3, /^On the/
			table.contents.each{ |item|
				if item.name =~ /#{checkname}/
					current_box = item
					@tpick_current_box = current_box
					break
				end
			}
			if current_box.nil?
				table.contents.each{ |item|
					fput "tap ##{item.id}"
					while line = get
						if line =~ /^You probably shouldn\'t do that\./
							break
						elsif line =~ /^You tap/
							current_box = item
							@tpick_current_box = current_box
							break
						end
					end
					break if current_box
				}
			end
			sleep 1
		end
		echo "Found your box/plinite! Name: #{current_box}, ID: #{current_box.id}, tip: #{offered_tip_amount}, critter name: #{critter_name}, critter level: #{critter_level}"
	end
	gnomish_bracers_trap_check_result.call
}

check_for_trap = proc{
	tpick_cast_spells (402) if use_spell_402
	tpick_cast_spells (404) if use_spell_404
	current_trap_type = nil
	tpick_prep_spell(416, "Piercing Gaze")
	fput "cast at ##{current_box.id}"
	while line = get
		if line =~ /Peering closely into the lock\, you spy an? [a-zA-Z]+ (.*) scarab wedged into the lock mechanism\./
			scarab_name = $1
			current_trap_type = "scarab"
			CharSettings['scarab'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /You notice what appears to be a sharp sliver of metal nestled in a hole next to the lock plate\./
			current_trap_type = "needle"
			CharSettings['needle'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /You notice a discolored oval ring around the outside of the.*which makes you suspicious\.\s+Your suspicions are confirmed when you look inside the keyhole and notice the spring\-loaded jaws pressed flush against the.*walls\./
			current_trap_type = "jaws"
			CharSettings['jaws'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /You see a tiny sphere imbedded in the lock mechanism\./
			current_trap_type = "sphere"
			CharSettings['sphere'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /You can see a small crystal imbedded in the locking mechanism\./
			current_trap_type = "crystal"
			CharSettings['crystal'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /You see a cord stretched between the lid and case\./
			current_trap_type = "scales"
			CharSettings['scales'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /Peering through the .*\, you notice that the lock casing is coated with a rough\, grainy substance\, and a small bladder is wedged between the tumblers of the lock\./
			current_trap_type = "sulphur"
			CharSettings['sulphur'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /Looking closely into the keyhole of the lock\, you spy a small vial of liquid and a tiny hammer device which seems poised to shatter it if the lock is tampered with\./
			current_trap_type = "cloud"
			CharSettings['cloud'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /You notice what appears to be a tiny vial placed just past the tumblers of the lock mechanism\.\s+It appears that any tampering with the lock mechanism will cause the tumblers to crush the vial\./
			current_trap_type = "acid vial"
			CharSettings['acid_vial'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /Peering through the .*\, you notice that the hinges have some springs incorporated into the design in an unusual fashion\./
			current_trap_type = "springs"
			CharSettings['springs'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /Looking closely into the keyhole of the lock\, you spy a small vial of fire\-red liquid and a tiny hammer device which seems poised to shatter it if the lock is tampered with\./
			current_trap_type = "fire vial"
			CharSettings['fire_vial'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /You see a thin tube extending from the lock mechanism down into the .*\.\s+The tube appears to be filled with a greenish powder\./
			current_trap_type = "spores"
			CharSettings['spores'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /There appears to be a plate over the lock\, sealing it and preventing any access to the tumblers\./
			current_trap_type = "plate"
			CharSettings['plate'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /Near the lock mechanism\, you notice a pair of small metal rods a hair\'s width from rubbing together\./
			current_trap_type = "rods"
			CharSettings['rods'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /The inside chamber is lined with some unidentifiable substance\./
			current_trap_type = "boomer"
			CharSettings['boomer'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /You gaze at the.*but your vision is obscured\./
			current_trap_type = "check again"
		elsif line =~ /Suddenly a dark splotch erupts from the lock mechanism and envelops you\!  Time seems to slow down and almost stop\.\.\./
			current_trap_type = "glyph"
			CharSettings['glyph'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /Roundtime/
			break
		end
	end
	if current_trap_type != "check again" && current_trap_type != nil
		echo "Found a #{current_trap_type} trap." if UserVars.tpick["run_silently"] !~ /yes/i
	end
	if current_trap_type == "check again"
		echo "Failed detecting a trap, trying again."
		check_for_trap.call
	elsif current_trap_type == "needle" || current_trap_type == "jaws" || current_trap_type == "plate"
		echo "Trap is safe to skip disarming."
		pop_open_box.call
	elsif current_trap_type == "crystal" || current_trap_type == "springs"
		echo "Trap is safe to use 408 on. Must be disarmed before popping."
		disarm_trap.call
	elsif current_trap_type == "scarab" || current_trap_type == "sphere" || current_trap_type == "scales" || current_trap_type == "acid vial" || current_trap_type == "fire vial" || current_trap_type == "spores" || current_trap_type == "boomer" || current_trap_type == "cloud" || current_trap_type == "rods"
		echo "408 might set off trap. Must be disarmed before popping."
		if UserVars.tpick["only_disarm_safe"] == "yes"
			echo "Skipping box due to tpick setting Only disarm safe is set to yes."
			where_to_stow_box.call
			box_opened = nil
		else
			disarm_trap.call
		end
	elsif current_trap_type == "sulphur"
		echo "Skipping box because 408 will set this trap off."
		where_to_stow_box.call
		box_opened = nil
	elsif current_trap_type == "glyph"
		echo "The box had a glyph trap on it. Taking you back to the room you started in."
		while checkroom =~ /Temporal Rift/
			move 'e'
			sleep 0.1
		end
		sleep 0.5
		start_script "go2", [starting_room]
		wait_while{ running?('go2') }
		echo "This box has a glyph trap and cannot be opened."
		where_to_stow_box.call
		box_opened = nil
	elsif current_trap_type == nil
		echo "No trap found." if UserVars.tpick["run_silently"] !~ /yes/i
		remaining_416_casts -= 1
		if remaining_416_casts < 1
			CharSettings['no_trap'] += 1
			CharSettings['total_trap_count'] += 1
			pop_open_box.call
		else
			echo "416 casts remaining: #{remaining_416_casts}."
			check_for_trap.call
		end
	end
}

fused_lock_disarm = proc{
	if @rogue_current_task == "Wedge open boxes" && @rogue_automate_current_task_with_tpick && solo_or_other == "worker"
		@rogue_text_to_display.push("Working on a ;rogues task to use wedges so I'm going to use a wedge on this box.")
		rogue_display_message
		use_a_wedge = true
		wedge_lock.call
	elsif Char.prof == 'Rogue'
		echo "Going to try wedging this box open."
	elsif Char.prof != 'Rogue' and !Spell[407].known?
		echo "Can't open this box."
		if solo_or_other == "solo"
			where_to_stow_box.call
		elsif solo_or_other == "other"
			tpick_say_cant
			open_others.call
		elsif solo_or_other == "ground"
			cant_open_plated_box_count += 1
			box_opened = nil
		elsif solo_or_other == "worker"
			nil
		end
	elsif Char.prof != 'Rogue' and Spell[407].known?
		tpick_get_box(current_box) if solo_or_other == "ground"
		echo "Going to try popping this box."
		cast_407.call
	end
}

pop_open_box = proc{
	box_is_open = nil
	echo "Popping box."
	loop{
		tpick_cast_spells (403) unless UserVars.tpick["always_use_403"] =~ /never/i
		tpick_prep_spell(407, "Unlock")
		fput "cast at ##{current_box.id}"
		waitrt?
		while line = get
			if line =~ /The.*vibrates slightly but nothing else happens\.|Suddenly\, part of the.*face breaks away and a pair of gleaming jaws snap shut before the lockplate\!\s+Good thing your hand wasn\'t there\!|Roundtime/
				break
			elsif line =~ /You hear a soft click from the.*and it suddenly flies open\.|But the.*is already open\./
				box_is_open = true
				break
			end
		end
		break if box_is_open
	}
	open_solo.call if solo_or_other != "ground"
}

disarm_trap = proc{
	box_is_disarmed = nil
	loop{
		tpick_cast_spells (402) if use_spell_402
		tpick_cast_spells (404) if use_spell_404
		tpick_prep_spell(408, "Disarm")
		fput "cast at ##{current_box.id}"
		while line = get
			if line =~ /Now to isolate the offending mechanism and disable it\.\.\.The.*vibrates slightly but nothing else happens\.|You begin to probe the.*for unusual mechanisms\.\.\.The.*vibrates slightly but nothing else happens\./
				echo "Couldn't disarm trap. Tryin again."
				break
			elsif line =~ /Now to isolate the offending mechanism and disable it\.\.\.Your heart skips a beat as you hear a small sizzle from the.*keyhole\..*You begin to jump back\, but not in time as the entire.*explodes in a deafening\, fiery detonation\!/
				echo "The trap was set off! Script is now exiting."
				exit
			elsif line =~ /Now to isolate the offending mechanism and disable it\.\.\.The.*pulses once with a deep crimson light\!/
				box_is_disarmed = true
				echo "Box is disarmed."
				break
			end
		end
		break if box_is_disarmed
	}
	pop_open_box.call
}

fill_up_locksmith_container = proc{
	move 'out' if checkpaths 'out'
	start_script 'go2', [ 'bank', '--disable-confirm' ]
	wait_while{ running?('go2') }
	fput "unhide" if hidden?
	fput "depo all"
	fput "withdraw 1000"
	start_script 'go2', [ Room[Room.current.find_nearest_by_tag('locksmith')], '--disable-confirm' ]
	wait_while{ running?('go2') }
	waitrt?
	fput "order"
	while line = get
		if line =~ /\d+.*\s{2}(\d+).*locksmith\'s/
			order_number = $1
		elsif line =~ /(\d+).*locksmith\'s/
			order_number = $1
		end
		break if line =~ /You can APPRAISE/
	end
	tpick_put_stuff_away
	wait_until { checkright.nil? && checkleft.nil? }
	until checkright
		waitrt?
		fput "remove ##{@tpick_locksmiths_container.id}"
		sleep 0.2
	end
	buy_locksmith_pouch.call
	if putty_remaining < 50 || cotton_remaining < 50
		buy_locksmith_pouch.call
	end
	fput "wear ##{@tpick_locksmiths_container.id}"	
}

buy_locksmith_pouch = proc{
	fput "order #{order_number}"
	fput "buy"
	wait_until { checkleft }
	fput "open ##{GameObj.left_hand.id}"
	fput "bundle"
	trash_container = GameObj.loot.find { |trash| trash.name =~ trash_container }
	current_box = GameObj.left_hand
	@tpick_current_box = current_box
	if trash_container == nil
		tpick_drop_box(current_box)
	else
		fput "put ##{GameObj.left_hand.id} in #{trash_container}"
		sleep 0.2
		tpick_drop_box(current_box) if checkleft
	end
}

do_relock_boxes = proc{
	waitrt?
	tpick_get_box(current_box) if solo_or_other == "ground"
	fput "get ##{$vaalin_lockpick_id}"
	fput "close ##{current_box.id}"
	fput "lm relock ##{current_box.id}"
	tpick_drop_box(current_box) if solo_or_other == "ground"
	tpick_put_stuff_away
}

cast_407 = proc{
	if use_unlock_407_settings[1]
		stop_trying_to_use_407 = nil
		if checkmana < maxmana * (use_unlock_407_settings[1].to_i / 100.0)
			echo "According to your 407 settings your mana is too low to continue trying to open this box with 407."
			stop_trying_to_use_407 = true
		end
	end
	if current_box.name =~ /enruned|mithril/i || box_is_enruned_or_mithril || use_unlock_407_settings[0] =~ /no/i || stop_trying_to_use_407
		echo "Can't open this plated box because it is mithril or enruned or because your settings are set to not use 407 to open boxes." unless stop_trying_to_use_407
		if solo_or_other == "solo"
			where_to_stow_box.call
			tpick_put_stuff_away
			sleep 0.1
		elsif solo_or_other == "other"
			tpick_say_cant
			open_others.call
		elsif solo_or_other == "ground"
			tpick_drop_box(current_box)
			cant_open_plated_box_count += 1
			box_opened = nil
		elsif solo_or_other == "worker"
			ask_worker.call
		end
	else
		if checkmana < 10
			echo "Waiting for mana."
			wait_until { checkmana >= 10 }
		end
		tpick_cast_spells (403) unless UserVars.tpick["always_use_403"] =~ /never/i
		tpick_prep_spell(407, "Unlock")
		result = dothistimeout "cast ##{current_box.id}", 4, /vibrates slightly but nothing else happens.|(suddenly flies open.|is already open.)/i
		if result =~ /(suddenly flies open.|is already open.)/i
			if solo_or_other == "solo"
				open_solo.call
			elsif solo_or_other == "other"
				open_others.call
			elsif solo_or_other == "ground"
				tpick_drop_box(current_box)
			elsif solo_or_other == "worker"
				nil
			end
		elsif result =~ /vibrates slightly but nothing else happens./i || result.nil?
			cast_407.call
		end
	end
}

wedge_lock = proc{
	waitrt?
	tpick_get_box(current_box) if solo_or_other == "ground" && checkright == nil
	if Char.prof == 'Rogue'
		3.times{
			waitrt?
			unless GameObj.right_hand.name =~ /wedge/ || GameObj.left_hand.name =~ /wedge/
				fput "get my wedge"
				sleep 0.2
			end
		}
	end
	if GameObj.right_hand.name !~ /wedge/ && GameObj.left_hand.name !~ /wedge/
		if use_a_wedge
			@rogue_text_to_display.push("Currently working on a ;rogues task for using a wedge but you appear to be out of wedges.")
			@rogue_text_to_display.push(";tpick will now exit and ;rogues will create more wedges then start ;tpick again.")
			rogue_display_message
			exit
		else
			if use_unlock_407_settings[0] =~ /no/i or !Spell[407].known?
				if solo_or_other == "other"
					tpick_say_cant
					open_others.call
				elsif solo_or_other == "ground"
					echo "Couldn't open this box."
					box_opened = nil
				elsif solo_or_other == "solo"
					echo "Couldn't open this box."
					where_to_stow_box.call
					tpick_put_stuff_away
					sleep 0.1
				elsif solo_or_other == "worker"
					echo "Couldn't open this box."
					ask_worker.call
				end
			else
				if Char.prof == 'Rogue'
					echo "Couldn't find any wedges, going to try popping this box."
				else
					echo "Going to try popping this box."
				end
				cast_407.call
			end
		end
	else
		result = dothistimeout "lmaster wedge ##{current_box.id}", 3, /What do you expect to wedge it with|(suddenly splits away from the casing|Why bother)|Roundtime/i
		if result =~ /What do you expect to wedge it with/i
			tpick_put_stuff_away
			wedge_lock.call
		elsif result =~ /(suddenly splits away from the casing|Why bother)/i
			tpick_put_stuff_away
			open_solo.call if solo_or_other == "solo"
			open_others.call if solo_or_other == "other"
			tpick_drop_box(current_box) if solo_or_other == "ground"
		elsif result =~ /Roundtime/i || result.nil?
			wedge_lock.call
		end
	end
}

calibrate = proc{
	echo "Calibrating calipers." if UserVars.tpick["run_silently"] !~ /yes/i
	3.times{
		waitrt?
		unless GameObj.right_hand.name =~ /calipers/ || GameObj.left_hand.name =~ /calipers/
			fput "get my calipers"
			sleep 0.2
		end
	}
	if GameObj.right_hand.name !~ /calipers/ && GameObj.left_hand.name !~ /calipers/
		echo "Couldn't find your calipers."
		exit
	end
	result = dothistimeout "lmas calibrate my calipers", 4, /You\'re good\, but you\'re not that good\.|You should leave them alone.|Roundtime/i
	if result =~ /You\'re good\, but you\'re not that good\.|You should leave them alone./i
		tpick_put_stuff_away
	elsif result =~ /Roundtime/i
		waitrt?
		calibrate.call if can_use_calipers
	elsif result.nil?
		calibrate.call
	end
}

check_for_lockpicks_etc = proc{
	container = GameObj.inv.find{ |i| i.name =~ /#{UserVars.tpick["lockpick_container"]}/}
	if container.contents.nil?
		fput "look in ##{container.id}"
		sleep 1
	end
	container = GameObj.inv.find{ |i| i.name =~ /#{UserVars.tpick["scale_weapon_container"]}/}
	if container.contents.nil?
		fput "look in ##{container.id}"
		sleep 1
	end
	GameObj.containers.values.flatten.each{ |i| 
		copper_lock_pick_array.push(i.id) if temp_copper_lockpicks_array.include?(i.name)
		steel_lock_pick_array.push(i.id) if temp_steel_lockpicks_array.include?(i.name)
		gold_lock_pick_array.push(i.id) if temp_gold_lockpicks_array.include?(i.name)
		silver_lock_pick_array.push(i.id) if temp_silver_lockpicks_array.include?(i.name)
		mithril_lock_pick_array.push(i.id) if temp_mithril_lockpicks_array.include?(i.name)
		ora_lock_pick_array.push(i.id) if temp_ora_lockpicks_array.include?(i.name)
		glaes_lock_pick_array.push(i.id) if temp_glaes_lockpicks_array.include?(i.name)
		laje_lock_pick_array.push(i.id) if temp_laje_lockpicks_array.include?(i.name)
		vultite_lock_pick_array.push(i.id) if temp_vultite_lockpicks_array.include?(i.name)
		rolaren_lock_pick_array.push(i.id) if temp_rolaren_lockpicks_array.include?(i.name)
		veniom_lock_pick_array.push(i.id) if temp_veniom_lockpicks_array.include?(i.name)
		invar_lock_pick_array.push(i.id) if temp_invar_lockpicks_array.include?(i.name)
		alum_lock_pick_array.push(i.id) if temp_alum_lockpicks_array.include?(i.name)
		golvern_lock_pick_array.push(i.id) if temp_golvern_lockpicks_array.include?(i.name)
		kelyn_lock_pick_array.push(i.id) if temp_kelyn_lockpicks_array.include?(i.name)
		vaalin_lock_pick_array.push(i.id) if temp_vaalin_lockpicks_array.include?(i.name)
		$scale_trap_weapon_id = i.id if i.name =~ /^#{UserVars.tpick["scale_trap_weapon"]}$/		
	}
	if copper_lock_pick_array.count == 0 || steel_lock_pick_array.count == 0 || gold_lock_pick_array.count == 0 || silver_lock_pick_array.count == 0 || kelyn_lock_pick_array.count == 0 || vaalin_lock_pick_array.count == 0
		if UserVars.tpick["lockpick_container"] =~ /vambrace/i
			command_to_use = "look in ##{@tpick_lockpick_container.id}"
		else
			command_to_use = "look on ##{@tpick_lockpick_container.id}"
		end
		status_tags
		fput "#{command_to_use}"
		while line = get
			if line =~ /you see/
				lockpick_container_contents = line
				lockpick_container_contents = lockpick_container_contents.split(/\,|and |you see/)
				break
			elsif line =~ /There is nothing on/
				break
			end
		end
		status_tags
		if lockpick_container_contents
			lockpick_container_contents_hash = Hash.new
			lockpick_container_contents.each{ |i|
				temp = i.split(/an? \<a exist\=\"|\" noun\=\".*\"\>|\<\/a\>/)
				lockpick_container_contents_hash[temp[2]] = temp[1]
			}
			lockpick_container_contents_hash.each{ |key,value|
				copper_lock_pick_array.push(value) if temp_copper_lockpicks_array.include?(key)
				steel_lock_pick_array.push(value) if temp_steel_lockpicks_array.include?(key)
				gold_lock_pick_array.push(value) if temp_gold_lockpicks_array.include?(key)
				silver_lock_pick_array.push(value) if temp_silver_lockpicks_array.include?(key)
				mithril_lock_pick_array.push(value) if temp_mithril_lockpicks_array.include?(key)
				ora_lock_pick_array.push(value) if temp_ora_lockpicks_array.include?(key)
				glaes_lock_pick_array.push(value) if temp_glaes_lockpicks_array.include?(key)
				laje_lock_pick_array.push(value) if temp_laje_lockpicks_array.include?(key)
				vultite_lock_pick_array.push(value) if temp_vultite_lockpicks_array.include?(key)
				rolaren_lock_pick_array.push(value) if temp_rolaren_lockpicks_array.include?(key)
				veniom_lock_pick_array.push(value) if temp_veniom_lockpicks_array.include?(key)
				invar_lock_pick_array.push(value) if temp_invar_lockpicks_array.include?(key)
				alum_lock_pick_array.push(value) if temp_alum_lockpicks_array.include?(key)
				golvern_lock_pick_array.push(value) if temp_golvern_lockpicks_array.include?(key)
				kelyn_lock_pick_array.push(value) if temp_kelyn_lockpicks_array.include?(key)
				vaalin_lock_pick_array.push(value) if temp_vaalin_lockpicks_array.include?(key)
			}
		end
	end
}

check_for_boxes = proc {
	if open_plinites
		GameObj.containers.values.flatten.each{ |i| $tpick_list_of_box_ids.push(i.id) if i.name =~ /plinite/ }
	else
		GameObj.containers.values.flatten.each{ |i| $tpick_list_of_box_ids.push(i.id) if i.type == "box" }
	end
}

check_for_mithril_or_enruned = proc {
	action = proc { |server_string|
		if server_string =~ /You glance down to see.*mithril|enruned.*/
			check_hands_status = "mithril or enruned"
			DownstreamHook.remove("#{script.name}_check_for_mithril_or_enruned")
			nil
		elsif server_string =~ /You glance down.*left hand.*/
			check_hands_status = "good"
			DownstreamHook.remove("#{script.name}_check_for_mithril_or_enruned")
			nil
		elsif server_string =~ /You glance down at your empty hands\./
			check_hands_status = "empty"
			DownstreamHook.remove("#{script.name}_check_for_mithril_or_enruned")
			nil
		else
			server_string
		end
	}
		DownstreamHook.add("#{script.name}_check_for_mithril_or_enruned", action)
		silence_me
		fput "#{check_for_command}"
		silence_me
}

stuff_to_do = proc{
	if (UserVars.tpick["rest_percent"].to_i <= percentmind) && (UserVars.tpick["rest_percent"].length > 0)
		echo "Resting until mind reaches #{UserVars.tpick["pick_percent"]}%."
		wait_until { UserVars.tpick["pick_percent"].to_i >= percentmind }
	end
}

start_values_nilled = proc{
	scale_trap_found = nil
	current_trap_type = nil
	time_to_disarm_trap = nil
	found_true_lock_difficulty = nil
	trap_difficulty = nil
}

start_solo = proc{
	total_boxes_count.call
	$tpick_list_of_box_ids.each{ |box|
		tpick_stop_403_404
		fput "get ##{box}"
		start_time = Time.now
		critter_name = nil
		start_values_nilled.call
		stuff_to_do.call
		number_of_manual_trap_checks_remaining = UserVars.tpick["number_of_times_to_check_for_traps"].to_i
		if (gnomish_bracers) && (bracers_tier == "2")
			gnomish_bracers_trap_check.call
		else
			manually_disarm_trap.call
		end
	}
	check_disk.call
}

encumbrance_check = proc{
	if percentencumbrance > 99
		starting_room_number = Room.current.id
		start_script 'go2', [ 'bank', '--disable-confirm' ]
		wait_while{ running?('go2') }
		fput "depo all"
		start_script "go2", [starting_room_number]
		wait_while{ running?('go2') }
	end
}

start_worker = proc{
	$tpick_waiting_for_another_job = nil
	tpick_put_stuff_away
	stuff_to_do.call
	current_box = nil
	@tpick_current_box = current_box
	waitrt?
	if worker.nil?
		echo "Get yourself to a worker who assigns you box jobs."
		exit
	end
	encumbrance_check.call if UserVars.tpick["auto_deposit_silvers"] =~ /yes/i
	offered_tip_amount = nil
	exit if @rogue_the_current_task_is_finished || $tpick_exit_tpick_immediately
	if minimum_tip_current > 0
		fput "ask ##{worker.id} for job minimum #{minimum_tip_current}"
	else
		fput "ask ##{worker.id} for job"
	end
	while line = get
		if line =~ /says\, \"You should finish the job you\'re working on first\.  If you\'re done\, ask me to CHECK it for you\.\"/
			next_task = nil
			break
		elsif line =~ /says\, \"Ah\, here we are\.  The client is offering a tip of (.*) silvers? and mentioned it being from [a-zA-Z]+ (.*) \(level (\d+)\)\./
			offered_tip_amount = $1.delete(",").to_i	
			critter_name = $2
			critter_level = $3.to_i
			next_task = nil
			break
		elsif line =~ /says\, \"Ah\, here we are\.  The client is offering a tip of (.*) silvers? and they aren't sure where it came from/
			offered_tip_amount = $1.delete(",").to_i	
			critter_level = Char.level
			next_task = nil
			break
		elsif line =~ /says\, \"You\'ve done enough boxes for now\.  Why don\'t you ask me again about 10 minutes from now\.\"/
			next_task = "10 minutes"
			exit if exit_when_waiting
			break
		elsif line =~ /says\, \"You\'ve done enough boxes for now\.  Why don\'t you ask me again a few minutes from now\.\"/
			next_task = "2 minutes"
			exit if exit_when_waiting
			break
		elsif line =~ /says\, \"You\'ve done enough for a while\.  Why don\'t you rest your mind a bit\?\"/
			next_task = "rest"
			exit if exit_when_waiting
			break
		elsif line =~ /says\, \"You\'ve done enough boxes for now\.  Why don\'t you ask me again about a minute from now\.\"/
			next_task = "minute"
			exit if exit_when_waiting
			break
		elsif line =~ /says\, \"What\, you think we have a job already\?  Wait a bit longer before asking again\.\"/
			next_task = "11 seconds"
			exit if exit_when_waiting
			break
		elsif line =~ /says\, \"We don't have any jobs for you at the moment\./ || line =~ /says\, \"You haven\'t quite reflected on your past failure\.|says\, \"You\'ve done enough/
			next_task = "wait"
			exit if exit_when_waiting
			break
		end
	end
	$tpick_waiting_for_another_job = true
	if next_task == "wait"
		if minimum_tip_start && minimum_tip_subtract
			if minimum_tip_current > minimum_tip_floor
				echo "No boxes at your current minimum rate. Lowering minimum tip wanted and trying again in 10 seconds."
				minimum_tip_current -= minimum_tip_subtract
				minimum_tip_current = [minimum_tip_current, minimum_tip_floor].max
				sleep 11
				time_to_subtract_from_actual_picking_time += 11
				start_worker.call
			else
				minimum_tip_current = minimum_tip_start
				echo "No boxes at your lowest minimum rate. Starting over again in 30 seconds."
				sleep 30
				time_to_subtract_from_actual_picking_time += 30
				start_worker.call
			end
		else
			echo "No boxes available at the moment, waiting 30 seconds and trying again."
			sleep 30
			time_to_subtract_from_actual_picking_time += 30
			start_worker.call
		end
	elsif next_task == "minute"
		echo "No boxes available at the moment, waiting 60 seconds and trying again."
		sleep 60
		time_to_subtract_from_actual_picking_time += 60
		start_worker.call
	elsif next_task == "10 minutes"
		echo "No boxes available at the moment, waiting 5 minutes and trying again."
		sleep 300
		time_to_subtract_from_actual_picking_time += 300
		start_worker.call
	elsif next_task == "2 minutes"
		echo "No boxes available at the moment, waiting 120 seconds and trying again."
		sleep 120
		time_to_subtract_from_actual_picking_time += 120
		start_worker.call
	elsif next_task == "rest"
		if pool_picking_fried_commands
			pool_fried_start_time = Time.now
			echo "Worker isn't assigning you boxes because your mind is too full. Running your resting routine then coming back to pick more boxes when your mind reaches #{UserVars.tpick["pick_percent"]}%."
			starting_pool_room_number = Room.current.id
			start_script "go2", [pool_picking_fried_commands[0]]
			wait_while { running? "go2" }
			fput "#{pool_picking_fried_commands[1]}" if pool_picking_fried_commands[1]
			echo "Resting until mind reaches #{UserVars.tpick["pick_percent"]}%."
			wait_until { UserVars.tpick["pick_percent"].to_i >= percentmind }
			echo "Mind cleared out! Heading back to pick more boxes!"
			start_script "go2", [starting_pool_room_number]
			wait_while { running? "go2" }
			time_to_subtract_from_actual_picking_time += (Time.now - pool_fried_start_time)
		else
			echo "Worker isn't assigning you boxes because your mind is too full. Waiting 120 seconds before asking again."
			sleep 120
			time_to_subtract_from_actual_picking_time += 120
		end
		start_worker.call
	elsif next_task == "11 seconds"
		echo "No boxes available at the moment, waiting 10 seconds and trying again."
		sleep 11
		time_to_subtract_from_actual_picking_time += 11
		start_worker.call
	else
		$tpick_waiting_for_another_job = nil
		start_worker2.call
	end
}
	
start_worker2 = proc{
	if critter_level > max_critter_level
		echo "Critter level too high, turning in box."
		ask_worker.call
		ask_worker.call
		start_worker.call
	else
		if @rogue_current_task == "Gather trap components" && @rogue_task_for_footpad_or_administrator == "Footpad"
			@rogue_text_to_display.push("Need #{@rogue_reps_remaining - @rogue_trap_components_needed_array.count} more trap components.")
			rogue_display_message
		end
		tpick_stop_403_404
		start_values_nilled.call
		number_of_manual_trap_checks_remaining = UserVars.tpick["number_of_times_to_check_for_traps"].to_i
		if (gnomish_bracers) && (bracers_tier == "2")
			gnomish_bracers_trap_check.call
		else
			manually_disarm_trap.call
		end
		ask_worker.call
		start_worker.call
	end
}

start_others = proc{
	waitfor "has accepted your offer" if checkright != nil
	waitrt?
	fput "accept"
	while line = get
		if line =~ /^You accept ([a-zA-Z]+)\'s offer and are now holding.*\.$/i || line =~ /^([a-zA-Z]+) offers you (.*) #{all_box_types}\.  Click ACCEPT to accept the offer or DECLINE to decline it.  The offer will expire in 30 seconds\.$/
			person = $1
			fput "accept" if line =~ /^([a-zA-Z]+) offers you (.*) #{all_box_types}\.  Click ACCEPT to accept the offer or DECLINE to decline it.  The offer will expire in 30 seconds\.$/
			start_time = Time.now
			tpick_stop_403_404
			critter_name = nil
			start_values_nilled.call
			number_of_manual_trap_checks_remaining = UserVars.tpick["number_of_times_to_check_for_traps"].to_i
			if (gnomish_bracers) && (bracers_tier == "2")
				gnomish_bracers_trap_check.call
			else
				manually_disarm_trap.call
			end
			break
		end
	end
}

total_boxes_count = proc{
	total_boxes_number = 0
	if solo_or_other == "ground"
		GameObj.loot.each { |item|
			(total_boxes_number += 1) if (item.type == "box" && !all_box_ids_already_picked.include?(item.id))
		}
	elsif solo_or_other == "solo"
		total_boxes_number = $tpick_list_of_box_ids.length
		unless disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk|coffin/ }
			echo "Waiting 4 seconds for disk"
			40.times { break if GameObj.loot.any? { |obj| obj.name =~ /#{Char.name} disk|coffin/ }; sleep 0.1 }
				disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk|coffin/ }
			end
		(echo "No disk found.") if (disk == nil)
		already_checked_for_disk = true
		if (disk) && (disk.contents.nil?)
			dothistimeout "look in ##{disk.id}", 3, /In the|There is nothing in/
		end
		disk.contents.each{|item|
			if item.type =~ /box/i
				total_boxes_number += 1
			end
		}
	end
	total_boxes_picked_math.call
}

bash_the_box_open = proc{
	echo "Bashing open box."
	waitrt?
	result = dothistimeout "open ##{current_box.id}", 3, /That is already open\.|You open|It appears to be locked\./i
	if result =~ /That is already open\.|You open/
		box_counts_for_math = nil
		box_was_not_locked = true
	elsif result =~ /It appears to be locked\./ 
		fput "get my #{UserVars.tpick["bashing_weapon"]}"
		until current_box.status == "gone"
			waitrt?
			fput "bash ##{current_box.id}"
			waitrt?
			sleep 0.2
		end
	elsif result.nil?
		bash_the_box_open.call
	end	
}

coins_from_boxes_comma_nonsense = proc{
	if total_silvers_from_box < 625
		sleep 0.1
	else
		while line = get
			if line =~ /Roundtime\: (\d+) sec/
				sleep ($1.to_i + 1)
				break
			end
		end									
	end
	waitrt?
}

gather_stuff = proc{
	waitrt?
	if current_item.name =~ /coins/
		finished_getting_coins = nil
		loop{
			break if finished_getting_coins
			fput "get ##{current_item.id}"
			while line = get
				if line =~ /You gather the remaining (.*) coins?/
					total_silvers_from_box = $1.delete(",").to_i
					coins_from_boxes_comma_nonsense.call
					finished_getting_coins = true
					break
				elsif line =~ /^You can only collect (.*) of the coins due to your load\./
					total_silvers_from_box = $1.delete(",").to_i
					echo "You can't carry anymore silvers!"
					coins_from_boxes_comma_nonsense.call
					finished_getting_coins = true
					break
				elsif line =~ /^You cannot hold any more silvers\./
					echo "You can't carry anymore silvers!"
					finished_getting_coins = true
					break
				elsif line =~ /^You gather (.*) of the coins?/
					total_silvers_from_box = $1.delete(",").to_i
					coins_from_boxes_comma_nonsense.call
					break
				end
			end
		}
	else
		if picking_up
			fput "get ##{current_item.id}"
			wait_until{ checkleft }
			tpick_put_stuff_away
		else
			fput "get ##{current_item.id}"
		end
	end
}

display_no_mode_specified_message = proc{
	respond
	5.times{ _respond "#{monsterbold_start}#################################################################################{monsterbold_end}\n" }
	_respond "#{monsterbold_start}TPICK#{monsterbold_end}\n"
	_respond "You must specify which mode you want when starting this script."
	_respond ";tpick solo = Pick all boxes in your open containers."
	_respond ";tpick other = Wait for someone to GIVE you a box, you will then pick the box and GIVE it back to the person."
	_respond ";tpick ground = Pick all boxes on the ground."
	_respond ";tpick worker = Pick boxes at a pool. Only works if you're in a pool room when starting script."
	_respond ";tpick setup = Enter setup menu."
	_respond ";tpick help = Display the help message which explains settings in the setup menu and command line variables."
	5.times{ _respond "#{monsterbold_start}#################################################################################{monsterbold_end}\n" }
	respond
}

start_up_procedure = proc{
	if drop_off_boxes
		current_room = Room.current.id
		if worker.nil?
			echo "The \"drop\" command only works at locksmith pools."
			exit
		end
		if tip_being_offered.nil?
			echo "You need to specify how much you are tipping and if you want it to be a percent."
			echo "For example do \";tpick drop 100\" to tip 100 silvers per box, do \";tpick drop 10 percent\" or \";tpick drop 10%\" if you want to tip 10% per box"
			exit
		end
		if tip_is_a_percent && tip_being_offered > 100
			echo "Wise guy, huh? You can't tip more than 100%!"
			exit
		end
		tpick_put_stuff_away
		$tpick_boxes_checked = nil
		check_for_boxes.call
		total_number_of_boxes = $tpick_list_of_box_ids.length
		count_boxes_in_disk.call
		echo "Total number of boxes: #{total_number_of_boxes}"
		if total_number_of_boxes == 0
			echo "You don't have any boxes!"
			exit
		end
		if tip_is_a_percent
			echo "You are tipping #{tip_being_offered}% for each box."
			sleep 1
			start_script 'go2', [ 'bank', '--disable-confirm' ]
			wait_while{ running?('go2') }
			fput "depo all"
			fput "withdraw #{3500 * total_number_of_boxes} silvers"
			start_script 'go2', [ current_room ]
			wait_while{ running?('go2') }
			40.times { break if GameObj.loot.any? { |obj| obj.name =~ /#{Char.name} disk|coffin/ }; sleep 0.1 }
			$tpick_list_of_box_ids.each{ |box|
				tpick_put_stuff_away
				fput "get ##{box}"
				fput "give #{worker} #{tip_being_offered} percent"
				fput "give #{worker} #{tip_being_offered} percent"
			}
		else
			echo "You are tipping #{tip_being_offered} silvers for each box for a total tip needed of #{tip_being_offered * total_number_of_boxes}"
			sleep 1
			start_script 'go2', [ 'bank', '--disable-confirm' ]
			wait_while{ running?('go2') }
			fput "depo all"
			fput "withdraw #{tip_being_offered * total_number_of_boxes} silvers"
			start_script 'go2', [ current_room ]
			wait_while{ running?('go2') }
			40.times { break if GameObj.loot.any? { |obj| obj.name =~ /#{Char.name} disk|coffin/ }; sleep 0.1 }
			$tpick_list_of_box_ids.each{ |box|
				tpick_put_stuff_away
				fput "get ##{box}"
				fput "give #{worker} #{tip_being_offered}"
				fput "give #{worker} #{tip_being_offered}"
			}
		end
	elsif pick_up_boxes
		if worker.nil?
			echo "This command only works at locksmith pools."
			exit
		end
		tpick_put_stuff_away
		loop{
			fput "ask #{worker} about return"
			while line = get
				if line =~ /We don\'t have any boxes ready for you/
					exit
				elsif line =~ /here\'s your .* back/
					wait_until { checkright }
					picking_up = true
					sleep 0.2
					lootbox = GameObj.right_hand
					current_box = GameObj.right_hand
					@tpick_current_box = GameObj.right_hand
					fput "open ##{lootbox.id}"
					25.times{
						break if lootbox.contents
						fput "look in ##{lootbox.id}"
						sleep 0.2
					}
					lootbox.contents.each{|item|
						current_item = item
						waitrt?
						gather_stuff.call if (item.name !~ /urglaes fang/) && (item.name !~ /doomstone/)
					}
					garbage_check.call
					@tpick_current_box = nil
					tpick_put_stuff_away
					break
				elsif line =~ /\"You need to lighten your load first\.\"/
					starting_room_number = Room.current.id
					start_script 'go2', [ 'bank', '--disable-confirm' ]
					wait_while{ running?('go2') }
					fput "depo all"
					start_script "go2", [starting_room_number]
					wait_while{ running?('go2') }
					break
				end
			end
		}
	elsif solo_or_other == "ground" || bash_open_boxes
		if open_plinites
			echo "Ground feature cannot be used when opening plinites."
			exit
		end
		calibrate.call if (UserVars.tpick["calibrate"] == "yes") && (always_use_vaalin == nil) && (popping == nil) && (can_use_calipers) && (start_with_copper == nil)
		start_ground.call
	elsif solo_or_other == "other"
		if open_plinites
			echo "Other feature cannot be used when opening plinites."
			exit
		end
		if popping
			echo "Popping feature does not work when popping other people's boxes."
			exit
		end
		if (disarm_only) && (bash_open_boxes == nil)
			echo "Disarm only feature only works for ground picking."
			exit
		end
		fput "say #{UserVars.tpick["ready"]}" if UserVars.tpick["ready"].length > 0
		start_others.call
	elsif solo_or_other == "worker"
		if open_plinites
			echo "Worker feature cannot be used when opening plinites."
			exit
		end
		if popping
			echo "Popping feature does not work when popping other people's boxes."
			exit
		end
		if (disarm_only) && (bash_open_boxes == nil)
			echo "Disarm only feature only works for ground picking."
			exit
		end
		calibrate.call if (UserVars.tpick["calibrate"] == "yes") && (always_use_vaalin == nil) && (popping == nil) && (can_use_calipers) && (start_with_copper == nil)
		echo "#{picks_information_text}" if picks_to_use_based_on_critter_level
		worker_start_picking_time = Time.now
		start_worker.call
	elsif solo_or_other == "solo"
		if (disarm_only) && (bash_open_boxes == nil)
			echo "Disarm only feature only works for ground picking."
			exit
		end
		wealth_before.call
		wait_until { silver_before }
		$tpick_boxes_checked = nil
		check_for_boxes.call
		if popping
			pop_start.call
		elsif open_plinites
			start_plinites.call
		else
			calibrate.call if (UserVars.tpick["calibrate"] == "yes") && (always_use_vaalin == nil) && (popping == nil) && (can_use_calipers) && (start_with_copper == nil)
			start_solo.call
		end
	end
}

start_ground = proc{
	total_boxes_count.call
	GameObj.loot.each{ |box|
		if box.type =~ /box/ && !all_box_ids_already_picked.include?(box.id)
			all_box_ids_already_picked.push(box.id) unless all_box_ids_already_picked.include?(box.id)
			box_opened = true
			current_box = box
			@tpick_current_box = current_box
			tpick_stop_403_404
			if (UserVars.tpick["rest_percent"].to_i <= percentmind) && (UserVars.tpick["rest_percent"].length > 0)
				echo "Resting until mind reaches #{UserVars.tpick["pick_percent"]}%."
				wait_until { UserVars.tpick["pick_percent"].to_i >= percentmind }
			end
			waitrt?
			box_was_not_locked = nil
			start_time = Time.now
			critter_name = nil
			start_values_nilled.call
			number_of_manual_trap_checks_remaining = UserVars.tpick["number_of_times_to_check_for_traps"].to_i
			if popping
				@tpick_current_box = current_box
				current_box = current_box.id
				pop_boxes_begin.call
			elsif bash_open_boxes
				if disarm_only
					if (gnomish_bracers) && (bracers_tier == "2")
						gnomish_bracers_trap_check.call
					else
						manually_disarm_trap.call
					end
				else
					bash_the_box_open.call
				end
			else
				if (gnomish_bracers) && (bracers_tier == "2")
					gnomish_bracers_trap_check.call
				else
					manually_disarm_trap.call
				end
			end
			update_math_information = true
			total_boxes_picked_math.call
			tpick_drop_box(current_box)
			if ground_loot
				encumbrance_check.call if UserVars.tpick["auto_deposit_silvers"] =~ /yes/i
				if (bash_open_boxes) && (box_was_not_locked.nil?)
					GameObj.loot.each{ |item|
						current_item = item
						tpick_gather_the_loot.call
					}
				elsif (box_opened) || (box_was_not_locked)
					waitrt?
					tpick_cast_spells (1035) if use_spell_1035
					total_boxes_picked += 1
					fput "open ##{current_box.id}" unless popping
					(dothistimeout "look in ##{box.id}", 10, /In .*? you see|In the .*\:|There is nothing in/i) if box.contents.nil?
					box.contents.each{ |item|
						current_item = item
						tpick_gather_the_loot.call
					}
					if relock_boxes
						do_relock_boxes.call
					end
					garbage_check.call
				end
			else
				if popping
					nil
				else
					fput "open ##{current_box.id}" if (box_opened) && (disarm_only == nil)
				end
			end
			tpick_put_stuff_away
		end
	}
	if check_all_ground_boxes_again
		check_all_ground_boxes_again = nil
		echo "Checking for boxes I might have missed."
		start_ground.call
	else
		echo "All done!"
		echo "Couldn't open #{cant_open_plated_box_count} box(es), which are still on the ground." if cant_open_plated_box_count > 0
		exit
	end
}

check_disk = proc{
	stow_in_disk = true
	unless disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk|coffin/ }
		if already_checked_for_disk.nil?
			echo "Waiting 4 seconds for disk"
			40.times { break if GameObj.loot.any? { |obj| obj.name =~ /#{Char.name} disk|coffin/ }; sleep 0.1 }
				disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk|coffin/ }
			end
		end
	if disk == nil
		echo "No disk found." if already_checked_for_disk.nil?
		exit
	end
	if disk and disk.contents.nil?
		dothistimeout "look in ##{disk.id}", 3, /In the|There is nothing in/
	end
	disk.contents.each{|item|
		if item.type =~ /box/i
			waitrt?
			if popping
				current_box = item.id
				@tpick_current_box = item
				pop_boxes_begin.call
			else
				fput "get ##{item.id}"
				start_time = Time.now
				critter_name = nil
				start_values_nilled.call
				number_of_manual_trap_checks_remaining = UserVars.tpick["number_of_times_to_check_for_traps"].to_i
				if (gnomish_bracers) && (bracers_tier == "2")
					gnomish_bracers_trap_check.call
				else
					manually_disarm_trap.call
				end
			end
		end
	}
}

count_boxes_in_disk = proc{
	stow_in_disk = true
	unless disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk|coffin/ }
		echo "Waiting 4 seconds for disk"
		40.times { break if GameObj.loot.any? { |obj| obj.name =~ /#{Char.name} disk|coffin/ }; sleep 0.1 }
			disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk|coffin/ }
		end
	if disk and disk.contents.nil?
		dothistimeout "look in ##{disk.id}", 3, /In the|There is nothing in/
	end
	disk.contents.each{|item|
		if item.type =~ /box/i
			total_number_of_boxes += 1
			$tpick_list_of_box_ids.push(item.id)
		end
	}
}

manually_disarm_trap = proc{
	waitrt?
	if solo_or_other == "worker" && current_box.nil?
		until current_box
			dothistimeout "look on ##{table.id}", 3, /^On the/
			table.contents.each{ |item|
				if item.name =~ /#{checkname}/
					current_box = item
					@tpick_current_box = current_box
					break
				end
			}
			if current_box.nil?
				table.contents.each{ |item|
					fput "tap ##{item.id}"
					while line = get
						if line =~ /^You probably shouldn\'t do that\./
							break
						elsif line =~ /^You tap/
							current_box = item
							@tpick_current_box = current_box
							break
						end
					end
					break if current_box
				}
			end
			sleep 1
		end
		echo "Found your box/plinite! Name: #{current_box}, ID: #{current_box.id}, tip: #{offered_tip_amount}, critter name: #{critter_name}, critter level: #{critter_level}"
	end
	if current_box.name =~ /plinite/
		detect_plinite.call
	else
		if time_to_disarm_trap
			echo "Attempting to disarm trap." if UserVars.tpick["run_silently"] !~ /yes/i
		else
			echo "Checking for traps." if UserVars.tpick["run_silently"] !~ /yes/i
			need_403 = nil
			need_404 = nil
		end
		if (current_trap_type == "sphere") || (current_trap_type == "Sphere trap found, need to use lockpick to disarm.")
			3.times{
				waitrt?
				unless GameObj.right_hand.id == $vaalin_lockpick_id || GameObj.left_hand.id == $vaalin_lockpick_id
					fput "get ##{$vaalin_lockpick_id}"
					sleep 0.2
				end
			}
			if GameObj.right_hand.id != $vaalin_lockpick_id && GameObj.left_hand.id != $vaalin_lockpick_id
				echo "Couldn't find your #{UserVars.tpick["vaalin"]}."
				exit
			end
		end
		waitrt?
		if UserVars.tpick["use_404_based_on_critter_level"] =~ /\d+/ && need_404.nil?
			if critter_level.nil?
				echo "Critter level unknown, using 404 based on your settings."
				need_404 = "yes"
			else
				if UserVars.tpick["use_404_based_on_critter_level"].to_i <= critter_level
					echo "Critter level is #{critter_level}, using 404 based on your settings."
					need_404 = "yes"
				end
			end
		end
		tpick_cast_spells (402) if use_spell_402
		tpick_cast_spells (404) if use_spell_404 || need_404
		tpick_cast_spells (613) if use_spell_613
		tpick_cast_spells (1006) if use_spell_1006
		tpick_cast_spells (1035) if use_spell_1035
		trap_cant_be_disarmed = nil
		if solo_or_other != "ground" && solo_or_other != "worker"
			wait_until { GameObj.right_hand.id}
			current_box = GameObj.right_hand
			@tpick_current_box = current_box
		end
		waitrt?
		sleep 1
		waitrt?
		sleep 0.3
		waitrt?
		sleep 0.1
		waitrt?
		if current_trap_type == "scarab"
			all_scarab_ids = Array.new
			GameObj.loot.each{ |i|
				all_scarab_ids.push(i.id) if i.noun == "scarab"
			}
		end
		tpick_say_scarab_found if current_trap_type == "scarab"
		if time_to_disarm_trap
			if UserVars.tpick["always_use_404"] =~ /detect/i && disarm_skill > trap_difficulty && trap_difficulty
				echo "According to your settings you want to stop 404 when it's not needed to disarm a trap." if UserVars.tpick["run_silently"] !~ /yes/i
				tpick_stop_404
			end
			if UserVars.tpick["always_use_404"] =~ /auto/i && use_spell_404.nil? && need_404.nil?
				tpick_stop_404
			end
			fput "disarm ##{current_box.id}"
		else
			tpick_cast_spells (404) if UserVars.tpick["always_use_404"] =~ /detect/i
			fput "detect ##{current_box.id}"
		end
		while line = get
			if line =~ /\(.*\-(\d+)\)\./
				trap_difficulty = $1.to_i
				disarm_skill_plus_lore = (disarm_skill + disarm_lore)
				total_trap_skill = (disarm_skill + disarm_lore + UserVars.tpick["trap_roll"].to_i)
				if time_to_disarm_trap.nil?
					echo "Trap difficulty is: #{trap_difficulty}" if UserVars.tpick["run_silently"] !~ /yes/i
					echo "Your disarm skill is: #{disarm_skill}" if UserVars.tpick["run_silently"] !~ /yes/i
					echo "Your total disarm skill with lore is: #{disarm_skill_plus_lore}" if UserVars.tpick["run_silently"] !~ /yes/i
					echo "Highest trap you are willing to try is: #{total_trap_skill}" if UserVars.tpick["run_silently"] !~ /yes/i
				end
				if trap_difficulty > total_trap_skill
					trap_cant_be_disarmed = true
				elsif use_404_for_trap_difficulty && Spell[404].known?
					if trap_difficulty > use_404_for_trap_difficulty
						if time_to_disarm_trap.nil?
							echo "Trap difficulty is higher than your setting in the setup menu for when to use Disarm Enhancement (404), going to use Disarm Enhancement (404)." if UserVars.tpick["run_silently"] !~ /yes/i
						end
						need_404 = "yes"
					end
				elsif (trap_difficulty > disarm_skill) && (Spell[404].known? || UserVars.tpick["use_lmaster_focus"] =~ /yes/i)
					if time_to_disarm_trap.nil?
						echo "This trap looks tough, going to use Disarm Enhancement (404) or Lock Mastery Focus." if UserVars.tpick["run_silently"] !~ /yes/i
					end
					need_404 = "yes"
				elsif trap_difficulty > disarm_skill && !Spell[404].known? && UserVars.tpick["use_lmaster_focus"] !~ /yes/i
					trap_cant_be_disarmed = true
				end
	#####Is box enruned or mithril?
			elsif line =~ /You carefully begin to examine (.*) for traps\.\.\./
				box_is_enruned_or_mithril = nil
				box_is_enruned_or_mithril = true if $1 =~ /enruned|mithril/
	#####Failed to disarm box
			elsif line =~ /Having discovered a trap on the.* you begin to carefully attempt to disarm it\.\.\./
				current_trap_type = "Couldn't disarm trap, trying again." if UserVars.tpick["run_silently"] !~ /yes/i
	#####Scarab information#####
			#Manual detection
			elsif line =~ /Peering closely into the lock\, you spy an? [a-zA-Z]+ (.*) scarab wedged into the lock mechanism\./
				scarab_name = $1
				CharSettings['scarab'] += 1
				CharSettings['total_trap_count'] += 1
				current_trap_type = "scarab"
			#Successful manual disarm
			elsif line =~ /You carefully nudge the scarab free of its prison without disturbing the lock too much\.\s+The scarab falls from the lock and onto the ground in front of you\./
				current_trap_type = "Scarab trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /The lock appears to be free of all obstructions\./
				current_trap_type = "Scarab trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /Looking closely at the lock\, you spy.*scarab wedged into the lock mechanism\.\s+The scarab is surrounded by crimson glow\./
				current_trap_type = "Scarab trap has already been disarmed with 408."
				break
	#####Needle information#####
			#Manual detection
			elsif line =~ /Hmmm\, you can see what appears to be a tiny hole next to the lock plate which doesn\'t seem to belong there\.\s+Looking closer you see a gleaming sliver of metal recessed in the hole\./
				current_trap_type = "needle"
				CharSettings['needle'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /Using a bit of putty from your.*\, you manage to block the tiny hole in the lock plate\.|Using a pair of metal grips\, you carefully remove .* from .* and cover the tip with a bit of putty\./
				current_trap_type = "Needle trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /You see a tiny hole next to the lock plate which has been completely plugged\.|You can see what appears to be a tiny hole next to the lock plate which doesn\'t seem to belong there\.  However\, nothing about it seems to indicate cause for alarm\.|You spot a shiny metal needle sticking out of a small hole next to the lockplate with some sort of dark paste on it\./
				current_trap_type = "Needle trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /You can see what appears to be a tiny hole next to the lock plate which doesn\'t belong there\.\s+An occasional glint of red winks at you from within the hole\./
				current_trap_type = "Needle trap has already been disarmed with 408."
				break
	#####Jaws information#####
			#Manual detection
			elsif line =~ /You notice a discolored oval ring around the outside of the .* which makes you suspicious\.\s+Your suspicions are confirmed when you look inside the keyhole and notice the spring\-loaded jaws pressed flush against the .* walls\./
				current_trap_type = "jaws"
				CharSettings['jaws'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /Using the pair of metal grips\, you manage to pull out the two pins that hold the upper and lower jaw pieces together\.\s+As the pins are removed\, the jaws suddenly close and warp under the tremendous strain applied by their arming mechanism\.|Using the pair of metal grips\, you manage to pull out the two pins that hold the upper and lower jaw pieces together\.|Using your metal grips\, you carefully remove a pair of small steel jaws from the .* before piecing the apparatus back together\./
				current_trap_type = "Jaws trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /You notice a discolored oval ring around the outside of the .* which makes you suspicious\.\s+Your suspicions are confirmed when you look inside the keyhole and notice the spring\-loaded jaws pressed flush against the.*walls\, but the pins that hold the jaws together have been pushed out\.|You notice a discolored oval ring around the outside of the .*\, but further examination gives the impression that some vital part of whatever trap was here has been removed\./
				current_trap_type = "Jaws trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /You see a pair of metal jaws clamped tightly before the lockplate on the.*\.|The jaws are surrounded with a reddish glow\./
				current_trap_type = "Jaws trap has already been disarmed with 408. Can't pick it."
				break
			#Trap has already been set off
			elsif line =~ /You see a pair of bloody jaws clamped tightly before the lockplate on the/
				current_trap_type = "Jaws trap has already been set off."
				break
	#####Sphere information#####
			#Manual detection
			elsif line =~ /Examining the .*\, you locate.*sphere held in a metal bracket towards the back of the lock mechanism\..*It appears that were the tumblers to be activated\, the gem would be caught amongst them\./
				current_trap_type = "sphere"
				CharSettings['sphere'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /With utmost care\, you slip your.* into the lock and gently nudge the.*Another moment of prodding\, and you are able to poke the gem free of its metal housing\, whereupon it falls down into the lock mechanism and out of sight\.|With utmost care\, you slip your.* into the lock and gently nudge the.*Tilting the .* forward\, you knock the gem free of its metal housing and poke it out through the back of the lock\, allowing it to gently roll down the inside of the .*\'s front wall\./
				current_trap_type = "Sphere trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /A thorough search of the area inside the tumblers reveals what appears to be a metal bracket of some sort\, although it seems to be empty now\./
				current_trap_type = "Sphere trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /The sphere is surrounded by a crimson glow\./
				current_trap_type = "Sphere trap has already been disarmed with 408."
				break
			#Need pick in hand messaging
			elsif line =~ /No matter how you try\, your fingers are just too big to get back there to the gem\.\s+You\'ll need some sort of thin\, rigid implement like a lockpick\./
				current_trap_type = "Sphere trap found, need to use lockpick to disarm."
			#Setting off trap manually
			elsif line =~ /Suddenly\, you hear a sound like shattered crystal and .* light flashes from the lock mechanism\!/
				current_trap_type = "Sphere trap has been set off."
				echo "Sphere trap has been set off! Exiting."
				exit
			#Trap has already been set off
			elsif line =~ /A thorough and careful search of the lock mechanism indicates that the entire .* is MANGLED\. It\'s probably not trapped anymore\./
				current_trap_type = "Sphere trap has already been set off."
				break
	#####Crystal information#####
			#Manual detection
			elsif line =~ /Looking closely into the keyhole of the lock\, you spy.*crystal which seems imbedded in the locking mechanism\.\s+It looks as if opening the lock without the exact key could shatter it\./
				current_trap_type = "crystal"
				CharSettings['crystal'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /With a little ingenuity you manage to grind down parts of the lock mechanism with your metal file\, so it won\'t come in contact with the crystal when you try to open it\./
				current_trap_type = "Crystal trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /Looking closely into the keyhole of the lock\, you spy.*crystal which seems imbedded in the locking mechanism\.\s+It looks as if opening the lock without the exact key could shatter it\, but parts of the mechanism have been ground away to avoid unwanted contact with the crystal\./
				current_trap_type = "Crystal trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /You can see.*crystal imbedded in the locking mechanism\, with a slight reddish glow about it\./
				current_trap_type = "Crystal trap has already been disarmed with 408."
				break
	#####Scales information#####
			#Manual detection
			elsif line =~ /At first glance\, the.* appears to be covered with hundreds of tiny metal scales\.\s+Closer examination reveals the \"scales\" to be razor sharp at the edges and possessing of a downward\-facing needlelike tip\.\s+However\, you should be able to avoid cutting yourself if you are careful\.|Despite heavy scrutiny\, you can see no way to pry off any of the scales\, nor any particular reason to\.\s+With a modicum of caution\, they should present no danger\.\s+Nothing else about the.* suggests that it is trapped\./
				current_trap_type = "scales"
				CharSettings['scales'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /You gently slide your.*into the space under the lid and slice through the cord\.\s+That oughta do it\./
				current_trap_type = "Scales trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /Peering in through the crack between the lid and the casing\, you see what appears to be a thin cord dangling from the case\.\s+It looks to have been sliced through\./
				current_trap_type = "Scales trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /A crimson glow seeps between the lid and the casing of the .*\./
				current_trap_type = "Scales trap has already been disarmed with 408."
				break
			#Need dagger in hand messaging
			elsif line =~ /You figure that if you had a dagger\, you could probably cut the cord\./
				current_trap_type = "Scales trap found, need to use dagger to disarm."
				break
	#####Sulphur information#####
			#Manual detection
			elsif line =~ /Feeling around the inside of the lock\, you notice that the casing is coated with a rough\, grainy substance\.\s+You lean forward and peer between the walls of the casing\.\s+Examining the lock closely\, you notice a small bladder filled with a strange liquid wedged between the tumblers\.\s+With your face this close to the lock\, you pick up the faintest scent of sulphur\./
				current_trap_type = "sulphur"
				CharSettings['sulphur'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /You carefully use the tip of a small metal file to scrape away the rough\, grainy substance which lines the walls of the casing\.\s+After a few moments\, you feel comfortable with the small section you have cleaned\.\s+You take out a thin needle and carefully slide it between the walls of the casing\, taking great care not to touch them\.\s+As the tip of the needle punctures the small bladder\, a strange clear gel oozes forth from the hole\.\s+The gel gives off a strong odor of sulphur\.\s+As the air hits the gel\, it begins to harden and turn to dust\, blowing away in the wind as if it never existed\./
				current_trap_type = "Sulphur trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /Feeling around the inside of the lock\, you notice that the casing is coated with a rough\, grainy substance\.\s+A small section of the casing has been scraped clean of the strange substance\.\s+You lean forward and peer between the walls of the casing\.\s+Examining the lock closely\, you notice a deflated bladder wedged between the tumblers\.\s+There is a small hole in the bladder\, most likely from whatever ruptured it\.\s+The lock emanates a strong scent of sulphur\./
				current_trap_type = "Sulphur trap has already been disarmed."
				break
			#Trap has already been set off
			elsif line =~ /A thorough and careful search of the lock mechanism indicates that the entire .* is MANGLED\./
				current_trap_type = "Sulphur trap has already been set off."
				break
			#Already disarmed with 408
			#TRAP CANNOT BE DISARMED WITH 408
	#####Cloud information#####
			#Manual detection
			elsif line =~ /Looking closely into the keyhole of the lock\, you spy a small vial of liquid and a tiny hammer device which seems poised to shatter it if the lock is tampered with\./
				current_trap_type = "cloud"
				CharSettings['cloud'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /Using the metal grips from your.*\, you manage to reach in and grasp the post of the metal hammer\, and bend the weak metal out of striking range of the vial\.|Having rendered the hammer harmless\, you carefully remove a green\-tinted vial filled with thick acrid smoke from the .*\./
				current_trap_type = "Cloud trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /Looking closely into the keyhole of the lock\, you spy a tiny hammer device which has been bent back slightly\.|Looking closely into the keyhole of the lock\, you spy a small vial of liquid and a tiny hammer device which has been bent from striking range of the vial\./
				current_trap_type = "Cloud trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /Looking closely into the keyhole of the lock\, you spy a small vial of liquid and a tiny hammer device which has a red glow about it\./
				current_trap_type = "Cloud trap has already been disarmed with 408."
				break
	#####Acid vial information#####
			#Manual detection
			elsif line =~ /Peering closely into the lock\, you spy a tiny vial placed just past the tumblers of the lock mechanism\.\s+It would appear that any tampering with the lock mechanism would cause the tumblers to crush the vial and release whatever substance is inside\./
				current_trap_type = "acid vial"
				CharSettings['acid_vial'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /You carefully push a small ball of cotton into the lock mechanism\, surrounding and protecting the small vial from anything that may shatter it\.|Using a pair of metal grips\, you carefully remove the padded clear glass vial from the .*\./
				current_trap_type = "Acid vial trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /Peering closely into the lock\, you spy a tiny vial placed just past the tumblers of the lock mechanism\.\s+A small ball of cotton has been pushed up against the vial\, protecting it from anything that may shatter it\.|Looking closely at the lock\, you spy a small metal housing set just inside the lock mechanism\, but it appears empty\.|Looking closely into the keyhole of the lock\, you spy a small metal housing\, which appears to be empty\./
				current_trap_type = "Acid vial trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /You notice what appears to be a tiny vial placed just past the tumblers of the lock mechanism\.\s+A crimson glow surrounds the vial\.|Looking closely at the lock\, you spy a tiny vial set just inside the lock mechanism\.\s+The vial is surrounded by crimson glow\./
				current_trap_type = "Acid vial trap has already been disarmed with 408."
				break
			#Setting off trap manually
			elsif line =~ /You peer inside the lock and see that the tumblers have all been fused into a lump of useless metal/
				current_trap_type = "Acid vial trap has been set off."
				break
			#Trap has already been set off
			elsif line =~ /You peer inside the lock and see that the tumblers have been fused into a lump of useless metal./
				current_trap_type = "Acid vial trap has already been set off."
				break
	#####Springs information#####
			#Manual detection
			elsif line =~ /After carefully examining the lock\, you move on to the hinges of the .*\.\s+Just as you were to pass the.* off as safe\, you notice what appears to be the ends of springs incorporated with the hinges\.\s+Seems rather odd to have.* designed to spring open when it is unlocked\./
				current_trap_type = "springs"
				CharSettings['springs'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /With a little force applied to the springs\, you manage to pop them inside the.*\, from within which comes the tinkle of breaking glass\, followed by a strong acrid smell\.|With a little force applied to the springs\, you manage to pop them inside.*\, where they bounce around for a moment\.\s+You also hear something else rolling around in there\./
				current_trap_type = "Springs trap has been disarmed."
				break
			#Already manually disarmed
			#Same messaging as when no traps found.
			#Already disarmed with 408
			elsif line =~ /You spot a reddish glow about the hinges of the.*\./
				current_trap_type = "Springs trap has already been disarmed with 408."
				break
	#####Fire vial information#####
			#Manual detection
			elsif line =~ /Looking closely into the keyhole of the lock\, you spy a small vial of fire\-red liquid and a tiny hammer device which seems poised to shatter it if the lock is tampered with\./
				current_trap_type = "fire vial"
				CharSettings['fire_vial'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /Using the metal grips from your.*\, you manage to reach in and grasp the post of the metal hammer\, and bend the weak metal out of striking range of the vial\.|Having rendered the hammer harmless\, you carefully remove a thick glass vial filled with murky red liquid from the.*\./
				current_trap_type = "Fire vial trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /Looking closely into the keyhole of the lock\, you spy a tiny hammer device which has been bent back slightly\.|Looking closely into the keyhole of the lock\, you spy a small vial of fire\-red liquid and a tiny hammer device which has been bent from striking range of the vial\./
				current_trap_type = "Fire vial trap has already been disarmed."
				break
			#Already disarmed with 408 NEED MESSAGING
			#elsif line =~ //
			#	current_trap_type = "Fire vial trap has already been disarmed with 408."
			#	break
	#####Spores information#####
			#Manual detection
			elsif line =~ /Peering into the.*\'s lock\, you see a small tube towards the bottom of the tumbler mechanism\.\s+The tube is capped with a thin membrane\, but it seems likely that the tumblers would tear it off while turning\./
				current_trap_type = "spores"
				CharSettings['spores'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /Taking a lump of putty from your.*\, you carefully apply it to the end of the small tube\.\s+That should block whatever it\'s meant to deploy\./
				current_trap_type = "Spores trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /Peering into the.*\'s lock\, you see a small tube towards the bottom of the tumbler mechanism\.\s+It appears as though the tube has been plugged with something\./
				current_trap_type = "Spores trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /You see a thin tube extending from the lock mechanism down into the.*\.\s+The end of the tube is surrounded by a crimson glow\.|Peering into the.*\'s lock\, you see a small tube towards the bottom of the tumbler mechanism\.\s+A crimson glow surrounds the mouth of the tube\./
				current_trap_type = "Spores trap has already been disarmed with 408."
				break
			#Trap has already been set off
			elsif line =~ /Peering into the .*\'s lock\, you see a small tube towards the bottom of the tumbler mechanism\.\s+It appears as though the tube used to be covered with a thin membrane\, but it has torn mostly away\, and greyish\-green powder covers the area around it\./
				current_trap_type = "Spores trap has already been set off."
				break
	#####Plate information#####
			#Manual detection
			elsif line =~ /There appears to be a plate over the lock\, sealing it and preventing any access to the tumblers\.|Gonna chew through it/
				current_trap_type = "plate"
				CharSettings['plate'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /You carefully pour the contents of.*onto the .* where you think the keyhole ought to be\.\s+.*\, the metal plate covering the lock begins to melt away\./
				current_trap_type = "Plate trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /You see a metal plate covering the lock plate\, but it appears to have been melted through\, granting sufficient access to the lock to attempt picking it./
				current_trap_type = "Plate trap has already been disarmed."
				break
			#Already disarmed with 408
			#Trap can't be disarmed with 408
	#####Glyph information#####
			#Manual detection
			elsif line =~ /You notice some spiderweb\-like scratches on the lock plate which seem\, after some bit of scrutiny\, too organized to be just wear and tear \-\- it might be some type of glyph spell\./
				current_trap_type = "glyph"
				CharSettings['glyph'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /Knowing how delicate magical glyphs can be\, you scrape some extra lines into the markings hoping to alter their meaning and defeat the spell they may hold\./
				current_trap_type = "Glyph trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /You notice some spiderweb\-like scratches on the lock plate which seem\, after some bit of scrutiny\, too organized to be just wear and tear \-\- it might be some type of glyph spell\, but some of the markings have been altered\.\s+This may prevent any magical nature they have from manifesting itself\./
				current_trap_type = "Glyph trap has already been disarmed."
				break
			#Already disarmed with 408
			#Trap can't be disarmed with 408
	#####Rods information#####
			#Manual detection
			elsif line =~ /Looking closely into the keyhole\, you notice a pair of small metal rods a hair\'s width from touching each other\.\s+Peering around the inside of the keyhole\, you can see that the lock would push the two rods together should the lock be tampered with\./
				current_trap_type = "rods"
				CharSettings['rods'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /With great care you take a pair of metal grips and bend the sensitive metal rods out of alignment\.\s+It looks as though they cannot be pressed together by the lock mechanism any more\./
				current_trap_type = "Rods trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /Looking closely into the keyhole\, you notice a pair of small metal rods that have been bent in opposite directions of each other\./
				current_trap_type = "Rods trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /Near the lock mechanism\, you notice a pair of small metal rods surrounded by a crimson glow\.|Looking closely into the keyhole\, you notice a pair of small metal rods that have a slight reddish glow about them\./
				current_trap_type = "Rods trap has already been disarmed with 408."
				break
	#####Boomer information#####
			#Manual detection
			elsif line =~ /Carefully\, you feel around the lock and notice the inside chamber is coated with a strange white substance\.\s+From your experience you recognize this as a common.*detonation system for an explosive mixture that was used to treat the .*\./
				current_trap_type = "boomer"
				CharSettings['boomer'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /Using a bit of putty from your.*\, you cake a thin layer on the lock casing\, hopefully sufficient to prevent sparks when the metal arm strikes it\./
				current_trap_type = "Boomer trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /A thin layer of mud or putty has been dabbed on the connecting point of the striking arm and the white substance to prevent it from igniting the.* when it is unlocked\./
				current_trap_type = "Boomer trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /A deep red glow surrounds the striking arm of the trap mechanism\.\s+You hope it will keep the arm from making contact with the explosive white substance\./
				current_trap_type = "Boomer trap has already been disarmed with 408."
				break
	#####No trap found#####
			elsif line =~ /You discover no traps\./
				current_trap_type = "No trap found."
				break
	#####Box is already open#####
			elsif line =~ /Um, but it\'s open|There is no lock on that|You blink in surprise as though just becoming aware of.*presence\./
				current_trap_type = "Box is already open."
				box_counts_for_math = nil
				break
	#####No putty#####
			elsif line =~ /You figure that if you had some sort of putty/
				echo "No putty to disarm this trap. Exiting."
				exit
	#####Roundtime#####
			elsif line =~ /Roundtime/
				break
			end

		end

		time_to_disarm_trap = true
		if (current_trap_type == "No trap found." || current_trap_type == "Scarab trap has already been disarmed." || current_trap_type == "Scarab trap has already been disarmed with 408." || current_trap_type == "Needle trap has been disarmed." || current_trap_type == "Needle trap has already been disarmed." || current_trap_type == "Needle trap has already been disarmed with 408." || current_trap_type == "Jaws trap has been disarmed." || current_trap_type == "Jaws trap has already been disarmed." || current_trap_type == "Sphere trap has been disarmed." || current_trap_type == "Sphere trap has already been disarmed." || current_trap_type == "Sphere trap has already been disarmed with 408." || current_trap_type == "Crystal trap has been disarmed." || current_trap_type == "Crystal trap has already been disarmed." || current_trap_type == "Crystal trap has already been disarmed with 408." || current_trap_type == "Scales trap has been disarmed." || current_trap_type == "Scales trap has already been disarmed." || current_trap_type == "Scales trap has already been disarmed with 408." || current_trap_type == "Sulphur trap has been disarmed." || current_trap_type == "Sulphur trap has already been disarmed." || current_trap_type == "Cloud trap has been disarmed." || current_trap_type == "Cloud trap has already been disarmed." || current_trap_type == "Cloud trap has already been disarmed with 408." || current_trap_type == "Acid vial trap has been disarmed." || current_trap_type == "Acid vial trap has already been disarmed." || current_trap_type == "Acid vial trap has already been disarmed with 408." || current_trap_type == "Springs trap has been disarmed." || current_trap_type == "Springs trap has already been disarmed with 408." || current_trap_type == "Fire vial trap has been disarmed." || current_trap_type == "Fire vial trap has already been disarmed." || current_trap_type == "Fire vial trap has already been disarmed with 408." || current_trap_type == "Spores trap has been disarmed." || current_trap_type == "Spores trap has already been disarmed." || current_trap_type == "Spores trap has already been disarmed with 408." || current_trap_type == "Plate trap has been disarmed." || current_trap_type == "Plate trap has already been disarmed." || current_trap_type == "Glyph trap has been disarmed." || current_trap_type == "Glyph trap has already been disarmed." || current_trap_type == "Rods trap has been disarmed." || current_trap_type == "Rods trap has already been disarmed." || current_trap_type == "Rods trap has already been disarmed with 408." || current_trap_type == "Boomer trap has been disarmed." || current_trap_type == "Boomer trap has already been disarmed." || current_trap_type == "Boomer trap has already been disarmed with 408." || current_trap_type == "Scarab trap has been disarmed." || current_trap_type == "Spores trap has already been set off." || current_trap_type == "Sphere trap has already been set off." || current_trap_type == "Sulphur trap has already been set off.")
			echo "#{current_trap_type}" if UserVars.tpick["run_silently"] !~ /yes/i
			(box_counts_for_math = nil) if (current_trap_type =~ /already/)
			number_of_manual_trap_checks_remaining -= 1
			if current_trap_type == "No trap found." && number_of_manual_trap_checks_remaining > 0
				echo "Number of trap checks remaining: #{number_of_manual_trap_checks_remaining}"
				time_to_disarm_trap = nil
				manually_disarm_trap.call
			else
				if current_trap_type == "No trap found."
					CharSettings['no_trap'] += 1
					CharSettings['total_trap_count'] += 1
				end
				waitrt?
				if UserVars.tpick["auto_bundle_vials"] == "yes" && (GameObj.right_hand.name =~ /vial/ || GameObj.left_hand.name =~ /vial/)
					if @rogue_automate_current_task_with_tpick && solo_or_other == "worker" && @rogue_current_task == "Gather trap components" && @rogue_trap_components_needed_names.find{ |name| name =~ /clear vial|thick vial|green vial/ }
						@rogue_text_to_display.push("This vial is needed for your task so we are not bundling it in your locksmith's kit.")
						rogue_display_message
					else
						tpick_bundle_vials.call
					end
				end
				if current_trap_type == "Scarab trap has been disarmed."
					echo "Disarming scarab."
					waitrt?
					tpick_cast_spells (1035) if use_spell_1035
					sleep 1
					waitrt?
					scarab_object = nil
					GameObj.loot.each{ |i|
						if i.name =~ /#{scarab_name}/ && i.noun == "scarab" && !all_scarab_ids.include?(i.id)
							if UserVars.tpick["always_use_408"] =~ /scarab/i
								loop{
									if checkmana < 8
										echo "Waiting for mana."
										wait_until { checkmana(8) }
									end
									until checkprep == "Disarm"
										waitrt?
										waitcastrt?
										fput "release" unless checkprep == "Disarm"
										fput "prep 408"
										sleep 0.5
									end
									result = dothistimeout "cast ##{i.id}", 3, /The runes on the scarab go still\.|Cast Roundtime/
									if result =~ /The runes on the scarab go still\./
										scarab_object = i
										break
									elsif result =~ /Cast Roundtime/
										nil
									end
								}
							else
								waitrt?
								result = dothistimeout "disarm ##{i.id}", 5, /^As you reach for the|^Knowing how delicate magical runes can be/i
								if result =~ /^As you reach for the/
									nil
								elsif result =~ /^Knowing how delicate magical runes can be/
									scarab_object = i
								end
							end
						end
						break if scarab_object
					}
					tpick_say_scarab_safe
					until checkright == "scarab" || checkleft == "scarab"
						waitrt?
						fput "get ##{scarab_object.id}"
						sleep 0.1
					end
					if solo_or_other == "worker"
						CharSettings["total_scarabs_received_pool_picking"] += 1
						scarabs_received_this_session_pool_picking += 1
					end
					tpick_put_stuff_away
				end
				tpick_put_stuff_away
				if (disarm_only)
					if (bash_open_boxes)
						bash_the_box_open.call
					else
						box_counts_for_math = nil
						nil
					end
				else
					if always_use_wedge
						wedge_lock.call
					else
						measure.call
					end
				end
			end
		elsif current_trap_type == "Couldn't disarm trap, trying again."
			echo "#{current_trap_type}"
			tpick_cast_spells (404)
			manually_disarm_trap.call
		elsif current_trap_type == nil
			echo "Something went wrong on my end, repeating the DISARM command."
			tpick_cast_spells (404)
			manually_disarm_trap.call
		elsif (current_trap_type == "Acid vial trap has been set off." || current_trap_type == "Acid vial trap has already been set off.")
			echo "#{current_trap_type}"
			echo "Lock has been fused."
			if (disarm_only)
				if (bash_open_boxes)
					bash_the_box_open.call
				else
					box_counts_for_math = nil
					nil
				end
			else
				fused_lock_disarm.call
			end
		elsif current_trap_type == "Box is already open."
			echo "#{current_trap_type}"
			if solo_or_other == "solo"
				open_solo.call
			elsif solo_or_other == "other"
				open_others.call
			elsif solo_or_other == "ground"
				nil
			elsif solo_or_other == "worker"
				nil
			end
		elsif current_trap_type == "plate"
			echo "Found a #{current_trap_type} trap."
			if (disarm_only)
				if (bash_open_boxes)
					bash_the_box_open.call
				else
					box_counts_for_math = nil
					nil
				end
			else
				if UserVars.tpick["always_use_404"] =~ /detect/i && disarm_skill > trap_difficulty && trap_difficulty
					echo "According to your settings you want to stop 404 when it's not needed to disarm a trap." if UserVars.tpick["run_silently"] !~ /yes/i
					tpick_stop_404
				end
				plate.call
			end
		elsif current_trap_type == "Jaws trap has already been disarmed with 408. Can't pick it." || current_trap_type == "Jaws trap has already been set off."
			echo "#{current_trap_type}"
			if (disarm_only)
				if (bash_open_boxes)
					bash_the_box_open.call
				else
					box_counts_for_math = nil
					nil
				end
			else
				fused_lock_disarm.call
			end
		else
			if current_trap_type == "Scales trap found, need to use dagger to disarm." || current_trap_type == "Sphere trap found, need to use lockpick to disarm."
				echo "#{current_trap_type}"
			else
				echo "Found a #{current_trap_type} trap." if UserVars.tpick["run_silently"] !~ /yes/i
			end
			if trap_cant_be_disarmed
				echo "Trap difficulty is too high according to your settings. Can't open box."
				if solo_or_other == "solo"
					where_to_stow_box.call
				elsif solo_or_other == "other"
					tpick_say_cant
					open_others.call
				elsif solo_or_other == "ground"
					cant_open_plated_box_count += 1
				elsif solo_or_other == "worker"
					ask_worker.call
				end
			else
				echo "Attempting to disarm trap." if current_trap_type != "scales" && time_to_disarm_trap == nil && UserVars.tpick["run_silently"] !~ /yes/i
				if current_trap_type == "scales"
					echo "Scales trap found, picking lock first then disarming."
					scale_trap_found = true
					measure.call
				elsif current_trap_type == "Scales trap found, need to use dagger to disarm."
					scaledisarm.call
				elsif (current_trap_type == "needle" || current_trap_type == "jaws" || current_trap_type == "crystal" || current_trap_type == "sulphur" || current_trap_type == "cloud" || current_trap_type == "acid vial" || current_trap_type == "springs" || current_trap_type == "fire vial" || current_trap_type == "spores" || current_trap_type == "glyph" || current_trap_type == "rods" || current_trap_type == "boomer" || current_trap_type == "sphere" || current_trap_type == "Sphere trap found, need to use lockpick to disarm." || current_trap_type == "scarab")
					manually_disarm_trap.call
				end
			end
		end
	end
}

scaledisarm = proc{
	echo "Attempting to disarm scales trap." if UserVars.tpick["run_silently"] !~ /yes/i
	3.times{
		waitrt?
		unless GameObj.right_hand.id == $scale_trap_weapon_id || GameObj.left_hand.id == $scale_trap_weapon_id
			fput "get ##{$scale_trap_weapon_id}"
			sleep 0.2
		end
	}
	if GameObj.right_hand.id != $scale_trap_weapon_id && GameObj.left_hand.id != $scale_trap_weapon_id
		echo "Couldn't find your #{UserVars.tpick["scale_trap_weapon"]}."
		exit
	end
	tpick_cast_spells (404) if need_404 == "yes" || use_spell_404
	tpick_cast_spells (613) if use_spell_613
	tpick_cast_spells (1006) if use_spell_1006
	tpick_cast_spells (1035) if use_spell_1035
	result = dothistimeout "disarm ##{current_box.id}", 3, /slice through the cord/i
	if result =~ /slice through the cord/
		waitrt?
		tpick_put_stuff_away
		if solo_or_other == "solo"
			open_solo.call
		elsif solo_or_other == "other"
			open_others.call
		elsif solo_or_other == "ground"
			sleep 0.1
		elsif solo_or_other == "worker"
			sleep 0.1
		end
	elsif result.nil?
		waitrt?
		tpick_put_stuff_away
		tpick_cast_spells (404)
		scaledisarm.call
	end
}

get_vials_and_stuff = proc{
	wait_until { checkrt == 0 }
	3.times{
		waitrt?
		wait_until { checkrt == 0 }
		unless GameObj.right_hand.name =~ /vial/ || GameObj.left_hand.name =~ /vial/
			fput "get vial from ##{@tpick_locksmiths_container.id}"
			sleep 0.2
		end
	}
	if GameObj.right_hand.name !~ /vial/ && GameObj.left_hand.name !~ /vial/
		echo "No vials found bundled in your locksmith's container and no loose vials found in your locksmith's container"
		if Char.prof == 'Rogue'
			echo "Going to try wedging this box open."
			wedge_lock.call
		elsif Char.prof != 'Rogue' and (!Spell[407].known? or (use_unlock_407_settings[0] != "plate" and use_unlock_407_settings[0] != "all"))
			echo "Can't open this plated box."
			if solo_or_other == "solo"
				exit
			elsif solo_or_other == "other"
				tpick_say_cant
				open_others.call
			elsif solo_or_other == "ground"
				(cant_open_plated_box_count += 1;box_opened = nil)
			elsif solo_or_other == "worker"
				nil
			end
		elsif Char.prof != 'Rogue' and Spell[407].known? and use_unlock_407_settings[0] == "plate"
			tpick_get_box(current_box) if solo_or_other == "ground"
			echo "Going to try popping this box."
			cast_407.call
		elsif Char.prof != 'Rogue' and Spell[407].known? and use_unlock_407_settings[0] == "all"
			tpick_get_box(current_box) if solo_or_other == "ground"
			echo "Going to try popping this box."
			cast_407.call
		end
	else
		echo "Found a loose vial! Let's do this!"
		plate.call
	end
}

plate = proc{
	if @rogue_current_task == "Wedge open boxes" && @rogue_automate_current_task_with_tpick && solo_or_other == "worker"
		@rogue_text_to_display.push("Working on a ;rogues task to use wedges so I'm going to use a wedge on this box.")
		rogue_display_message
		use_a_wedge = true
		wedge_lock.call
	else
		echo "Disarming trap."
		waitrt?
		tpick_cast_spells (1035) if use_spell_1035
		if always_use_wedge
			wedge_lock.call
		else
			tpick_cast_spells (404) if need_404
			result = dothistimeout "disarm ##{current_box.id}", 3, /You try to pour .* onto the .*\, but it just won\'t pour\!|the metal plate covering the lock begins to melt away|Gonna chew through it|The darn thing is built too tightly|You still have a good enough picture of the trap in your mind/i
			if result =~ /the metal plate covering the lock begins to melt away/i
				measure.call
			elsif result =~ /Gonna chew through it/i
				echo "No vials found bundled in your locksmith's container, going to look for loose vials in your locksmith's container."
				get_vials_and_stuff.call
			elsif result =~ /The darn thing is built too tightly|You still have a good enough picture of the trap in your mind/
				plate.call
			elsif result =~ /You try to pour .* onto the .*\, but it just won\'t pour\!/
				echo "THIS IS A BUG WITH THE GAME: IT IS TRYING TO POUR YOUR LOCKSMITH'S CONTAINER ON THE BOX. Looking for loose vials in your locksmith's container."
				get_vials_and_stuff.call
			elsif result.nil?
				plate.call
			end
		end
	end
}

measure_detection = proc{
	lock = nil
	calipers_measured_lock = nil
	if Char.prof == 'Rogue'
		echo "Measuring lock." if UserVars.tpick["run_silently"] !~ /yes/i
		3.times{
			waitrt?
			unless GameObj.right_hand.name =~ /calipers/ || GameObj.left_hand.name =~ /calipers/
				fput "get my calipers"
				sleep 0.2
			end
		}
		if GameObj.right_hand.name !~ /calipers/ && GameObj.left_hand.name !~ /calipers/
			echo "Couldn't find your calipers."
			exit
		end
		fput "lmaster measure ##{current_box.id}"
	elsif Char.prof == 'Bard'
		echo "Loresinging to box to find out lock difficulty."
		if solo_or_other == "ground"
			tpick_get_box(current_box)
			wait_until { GameObj.right_hand.id == current_box.id || GameObj.left_hand.id == current_box.id }
		end
		waitrt?
		fput "speak bard"
		finished_it = nil
		if solo_or_other == "worker"
			loresong_stuff = "loresing ::#{checkname} #{current_box.noun} on #{table}:: #{current_box.noun} that looks like a clock;What's the purpose of your lock?"
		else
			loresong_stuff = "loresing #{checkright} that I hold;let your purpose now be told"
		end
		loop{
			break if finished_it
			result = dothistimeout "#{loresong_stuff}", 2, /^You sing/i
			if result =~ /^You sing/
				finished_it = true
			end
		}
	end
	while line = get
		if line =~ /\-(\d+) in thief\-lingo difficulty ranking/
			lock = $1.to_i
			break
		end
		(lock = lock_difficulty[0];break) if line =~ /a primitive lock/i
		(lock = lock_difficulty[1];break) if line =~ /a rudimentary lock/i
		(lock = lock_difficulty[2];break) if line =~ /an extremely easy lock/i
		(lock = lock_difficulty[3];break) if line =~ /a very easy lock/i
		(lock = lock_difficulty[4];break) if line =~ /an easy lock/i
		(lock = lock_difficulty[5];break) if line =~ /a very basic lock/i
		(lock = lock_difficulty[6];break) if line =~ /a fairly easy lock/i
		(lock = lock_difficulty[7];break) if line =~ /a simple lock/i
		(lock = lock_difficulty[8];break) if line =~ /a fairly simple lock/i
		(lock = lock_difficulty[9];break) if line =~ /a fairly plain lock/i
		(lock = lock_difficulty[10];break) if line =~ /a moderately well-crafted lock/i
		(lock = lock_difficulty[11];break) if line =~ /a well-crafted lock/i
		(lock = lock_difficulty[12];break) if line =~ /a tricky lock/i
		(lock = lock_difficulty[13];break) if line =~ /a somewhat difficult lock/i
		(lock = lock_difficulty[14];break) if line =~ /a moderately difficult lock/i
		(lock = lock_difficulty[15];break) if line =~ /a very well-crafted lock/i
		(lock = lock_difficulty[16];break) if line =~ /a difficult lock/i
		(lock = lock_difficulty[17];break) if line =~ /an extremely well-crafted lock/i
		(lock = lock_difficulty[18];break) if line =~ /a very difficult lock/i
		(lock = lock_difficulty[19];break) if line =~ /a fairly complicated lock/i
		(lock = lock_difficulty[20];break) if line =~ /an intricate lock/i
		(lock = lock_difficulty[21];break) if line =~ /an amazingly well-crafted lock/i
		(lock = lock_difficulty[22];break) if line =~ /a very complex lock/i
		(lock = lock_difficulty[23];break) if line =~ /an impressively complicated lock/i
		(lock = lock_difficulty[24];break) if line =~ /an amazingly intricate lock/i
		(lock = lock_difficulty[25];break) if line =~ /an extremely difficult lock/i
		(lock = lock_difficulty[26];break) if line =~ /an extremely complex lock/i
		(lock = lock_difficulty[27];break) if line =~ /a masterfully well-crafted lock/i
		(lock = lock_difficulty[28];break) if line =~ /an amazingly complicated lock/i
		(lock = lock_difficulty[29];break) if line =~ /an astoundingly complex lock/i
		(lock = lock_difficulty[30];break) if line =~ /an incredibly intricate lock/i
		(lock = lock_difficulty[31];break) if line =~ /an absurdly well-crafted lock/i
		(lock = lock_difficulty[32];break) if line =~ /an exceedingly complex lock/i
		(lock = lock_difficulty[33];break) if line =~ /an absurdly difficult lock/i
		(lock = lock_difficulty[34];break) if line =~ /an unbelievably complicated lock/i
		(lock = lock_difficulty[35];break) if line =~ /a masterfully intricate lock/i
		(lock = lock_difficulty[36];break) if line =~ /an absurdly complex lock/i
		(lock = lock_difficulty[37];break) if line =~ /an impossibly complex lock/i
		if line =~ /You place the probe in the lock and grimace as something feels horribly wrong/i #This game line indicates the rogue is trying to measure a box with calipers when the box still has an active trap, since all soul golem boxes are technically trapped (the trap just randomizes the difficulty of the lock) this line will appear on every soul golem box. The solution below is to use a vaalin lockpick on soul golem boxes from the worker and to turn in all other boxes when this message appears. When not picking boxes from the worker the script will still use a vaalin lockpick.
			if critter_name =~ /soul golem/i
				lock = "need vaalin"
				break
			else
				if solo_or_other == "worker"
					ask_worker.call
					break
				else
					lock = "need vaalin"
					break
				end
			end
		end
		(lock = "not locked";break) if line =~ /has already been unlocked/i
		(lock = "can't find trap";break) if line =~ /As you start to place the probe in the lock/
		(lock = "can't measure";break) if line =~ /but your song simply wasn't powerful enough/
	end
	waitrt?
	calipers_measured_lock = lock if lock.is_a?(Numeric)
	if lock.is_a?(Numeric) && UserVars.tpick["lock_buffer"] =~ /\d+/ && Char.prof == "Rogue"
		lock += UserVars.tpick["lock_buffer"].to_i
		echo "You have lock buffer set to #{UserVars.tpick["lock_buffer"]}, going to assume this lock is +#{UserVars.tpick["lock_buffer"]} higher at -#{lock}"
	end
	number_of_times_to_measure += 1
	if lock == "can't measure" && number_of_times_to_measure < 3
		measure_detection.call
	end
}

lock_pick_information = proc{
	if $tpick_recommended_pick == "copper"
		needed_pick = UserVars.tpick["copper"]
		needed_pick_id = copper_lock_pick_array.first
		recommended_pick_modifier = 1.00
	elsif $tpick_recommended_pick == "steel"
		needed_pick = UserVars.tpick["steel"]
		needed_pick_id = steel_lock_pick_array.first
		recommended_pick_modifier = 1.10
	elsif $tpick_recommended_pick == "gold"
		needed_pick = UserVars.tpick["gold"]
		needed_pick_id = gold_lock_pick_array.first
		recommended_pick_modifier = 1.20
	elsif $tpick_recommended_pick == "silver"
		needed_pick = UserVars.tpick["silver"]
		needed_pick_id = silver_lock_pick_array.first
		recommended_pick_modifier = 1.30
	elsif $tpick_recommended_pick == "mithril"
		needed_pick = UserVars.tpick["mithril"]
		needed_pick_id = mithril_lock_pick_array.first
		recommended_pick_modifier = 1.45
	elsif $tpick_recommended_pick == "ora"
		needed_pick = UserVars.tpick["ora"]
		needed_pick_id = ora_lock_pick_array.first
		recommended_pick_modifier = 1.55
	elsif $tpick_recommended_pick == "glaes"
		needed_pick = UserVars.tpick["glaes"]
		needed_pick_id = glaes_lock_pick_array.first
		recommended_pick_modifier = 1.60
	elsif $tpick_recommended_pick == "laje"
		needed_pick = UserVars.tpick["laje"]
		needed_pick_id = laje_lock_pick_array.first
		recommended_pick_modifier = 1.75
	elsif $tpick_recommended_pick == "vultite"
		needed_pick = UserVars.tpick["vultite"]
		needed_pick_id = vultite_lock_pick_array.first
		recommended_pick_modifier = 1.80
	elsif $tpick_recommended_pick == "rolaren"
		needed_pick = UserVars.tpick["rolaren"]
		needed_pick_id = rolaren_lock_pick_array.first
		recommended_pick_modifier = 1.90
	elsif $tpick_recommended_pick == "veniom"
		needed_pick = UserVars.tpick["veniom"]
		needed_pick_id = veniom_lock_pick_array.first
		recommended_pick_modifier = 2.20
	elsif $tpick_recommended_pick == "invar"
		needed_pick = UserVars.tpick["invar"]
		needed_pick_id = invar_lock_pick_array.first
		recommended_pick_modifier = 2.25
	elsif $tpick_recommended_pick == "alum"
		needed_pick = UserVars.tpick["alum"]
		needed_pick_id = alum_lock_pick_array.first
		recommended_pick_modifier = 2.30
	elsif $tpick_recommended_pick == "golvern"
		needed_pick = UserVars.tpick["golvern"]
		needed_pick_id = golvern_lock_pick_array.first
		recommended_pick_modifier = 2.35
	elsif $tpick_recommended_pick == "kelyn"
		needed_pick = UserVars.tpick["kelyn"]
		needed_pick_id = kelyn_lock_pick_array.first
		recommended_pick_modifier = 2.40
	elsif $tpick_recommended_pick == "vaalin"
		needed_pick = UserVars.tpick["vaalin"]
		needed_pick_id = vaalin_lock_pick_array.first
		recommended_pick_modifier = 2.50
	end
}

relock_boxes_for_rogues = proc{
	#tpick_put_stuff_away
	#3.times{
	#	waitrt?
	#	fput "get ##{vaalin_lock_pick_array.first}"
	#	sleep 0.3
	#	break if checkright
	#}
	#if checkright.nil?
	#	@rogue_text_to_display.push("To automate this task it requires a vaalin lockpick and you don't appear to have one.")
	#	@rogue_text_to_display.push("Acquire a vaalin lockpick and start up ;rogues again.")
	#	rogue_display_message
	#	exit
	#end
	until checkright
		waitrt?
		fput "get ##{needed_pick_id}"
		sleep 0.3
	end
	loop{
		waitrt?
		result = dothistimeout "lmas relock ##{current_box.id}", 5, /Then\.\.\.CLICK\!  It locks\!/
		break if result =~ /Then\.\.\.CLICK\!  It locks\!/
	}
	loop{
		waitrt?
		result = dothistimeout "pick ##{current_box.id}", 5, /Then\.\.\.CLICK\!  It opens\!/
		break if result =~ /Then\.\.\.CLICK\!  It opens\!/
	}
	tpick_put_stuff_away
}

measure = proc{
	stuff_to_do.call if solo_or_other == "solo"
	waitrt?
	tpick_cast_spells (1035) if use_spell_1035
	i_need_403 = nil
	$tpick_recommended_pick = nil
	if UserVars.tpick["use_403_based_on_critter_level"] =~ /\d+/
		if critter_level.nil?
			echo "Critter level unknown, using 403 based on your settings. "
			need_403 = "yes"
		else
			if UserVars.tpick["use_403_based_on_critter_level"].to_i <= critter_level
				echo "Critter level is #{critter_level}, using 403 based on your settings. "
				need_403 = "yes"
			end
		end
	end
	use_a_wedge = nil
	if @rogue_current_task == "Wedge open boxes" && @rogue_automate_current_task_with_tpick && solo_or_other == "worker"
		required_plated_boxes = 0
		fput "gld"
		while line = get
			if line =~ /The Training Administrator told you to wedge open some boxes\./
				while line = get
					if line =~ /At least (\d+) more should have a plated lock or fused tumblers\, or be out of your league with a pick\./
						required_plated_boxes = $1.to_i
					elsif line =~ /You have (.*) repetitions? remaining (?:for|to complete) this task\./
						if $1 == "no"
							total_reps_remaining = 0
						else
							total_reps_remaining = $1.to_i
						end
						break
					end
				end
				break
			end
		end
		if required_plated_boxes == total_reps_remaining
			@rogue_text_to_display.push("Either no more plated boxes or only plated boxes are required for your task.")
			@rogue_text_to_display.push("Therefore I am not using a wedge on this box.")
			rogue_display_message
			use_a_wedge = nil
		elsif required_plated_boxes != total_reps_remaining || required_plated_boxes == 0
			@rogue_text_to_display.push("Non-plated boxes are required to get a rep for your current task.")
			@rogue_text_to_display.push("Therefore I am using a wedge on this box.")
			rogue_display_message
			use_a_wedge = true
		end
	end
	if use_a_wedge
		wedge_lock.call
	elsif @rogue_automate_current_task_with_tpick && solo_or_other == "worker" && @rogue_current_task == "Repair broken lockpicks"
		@rogue_text_to_display.push("Trying to break a lockpick.")
		rogue_display_message
		always_use_vaalin = nil
		if all_lockpicks_to_break_for_rogue.count == 0
			@tpick_finished_with_current_rogue_task = true
			exit
		else
			until checkright
				break if all_lockpicks_to_break_for_rogue.count == 0
				waitrt?
				fput "get ##{all_lockpicks_to_break_for_rogue.first}"
				sleep 0.2
			end
		end
		pick3.call
	elsif @rogue_automate_current_task_with_tpick && solo_or_other == "worker" && found_true_lock_difficulty.nil? && UserVars.tpick["lockpick_to_use_for_rogues_tasks"].length > 1 && @rogue_current_task !~ /Measure then pick tough boxes|Calibrate calipers in the field|Gather trap components|Melt open plated boxes/
		@rogue_text_to_display.push(";tpick is automating your current ;rogues task.")
		@rogue_text_to_display.push(";tpick will use the lockpick in the \"Lockpick\" setting under the \";rogues integration\" tab.")
		@rogue_text_to_display.push(";rogue will automatically adjust this setting as necessary.")
		rogue_display_message
		always_use_vaalin = nil
		$tpick_recommended_pick = UserVars.tpick["lockpick_to_use_for_rogues_tasks"]
		lock_pick_information.call
		pick2.call
	elsif picks_to_use_based_on_critter_level && solo_or_other == "worker" && found_true_lock_difficulty.nil?
		needed_pick = nil
		if critter_level.nil?
			$tpick_recommended_pick = "vaalin"
		else
			picks_to_use_based_on_critter_level.each{ |i|
				temp_picks_critter_level = i.split(" ")
				if temp_picks_critter_level[0].to_i >= critter_level
					if temp_picks_critter_level[1] == "copper"
						$tpick_recommended_pick = "copper"
					elsif temp_picks_critter_level[1] == "steel"
						$tpick_recommended_pick = "steel"
					elsif temp_picks_critter_level[1] == "gold"
						$tpick_recommended_pick = "gold"
					elsif temp_picks_critter_level[1] == "silver"
						$tpick_recommended_pick = "silver"
					elsif temp_picks_critter_level[1] == "mithril"
						$tpick_recommended_pick = "mithril"
					elsif temp_picks_critter_level[1] == "ora"
						$tpick_recommended_pick = "ora"
					elsif temp_picks_critter_level[1] == "glaes"
						$tpick_recommended_pick = "glaes"
					elsif temp_picks_critter_level[1] == "laje"
						$tpick_recommended_pick = "laje"
					elsif temp_picks_critter_level[1] == "vultite"
						$tpick_recommended_pick = "vultite"
					elsif temp_picks_critter_level[1] == "rolaren"
						$tpick_recommended_pick = "rolaren"
					elsif temp_picks_critter_level[1] == "veniom"
						$tpick_recommended_pick = "veniom"
					elsif temp_picks_critter_level[1] == "invar"
						$tpick_recommended_pick = "invar"
					elsif temp_picks_critter_level[1] == "alum"
						$tpick_recommended_pick = "alum"
					elsif temp_picks_critter_level[1] == "golvern"
						$tpick_recommended_pick = "golvern"
					elsif temp_picks_critter_level[1] == "kelyn"
						$tpick_recommended_pick = "kelyn"
					elsif temp_picks_critter_level[1] == "vaalin"
						$tpick_recommended_pick = "vaalin"
					end
					break
				end
			}
		end
		$tpick_recommended_pick = "vaalin" if $tpick_recommended_pick.nil?
		lock_pick_information.call
		if critter_level
			echo "Critter level is #{critter_level}, using a #{$tpick_recommended_pick} lockpick based on your settings."
		else
			echo "Critter level is unknown, using a #{$tpick_recommended_pick} lockpick."
		end
		pick2.call
	elsif always_use_vaalin
		echo "Always use vaalin setting enabled, using a vaalin lockpick."
		$tpick_recommended_pick = "vaalin"
		lock_pick_information.call
		need_403 = "yes" unless UserVars.tpick["always_use_403"] =~ /never/i
		pick2.call
	elsif (UserVars.tpick["use_vaalin_when_fried"] =~ /yes/i) && ((percentmind >= 100))
		echo "Always use vaalin when fried enabled, using a vaalin lockpick."
		(box_counts_for_math = nil)
		$tpick_recommended_pick = "vaalin"
		lock_pick_information.call
		need_403 = "yes" unless UserVars.tpick["always_use_403"] =~ /never/i
		pick2.call
	elsif start_with_copper && found_true_lock_difficulty.nil?
		echo "Start with copper option enabled, starting with lockpick in your copper lockpick setting."
		$tpick_recommended_pick = "copper"
		lock_pick_information.call
		pick2.call	
	elsif use_unlock_407_settings[0] == "all"
		echo "Always use 407 setting enabled, using 407."
		if (scale_trap_found)
			echo "Can't open a scales trap with 407."
			if solo_or_other == "solo"
				where_to_stow_box.call
			elsif solo_or_other == "other"
				tpick_say_cant
				open_others.call
			elsif solo_or_other == "ground"
				cant_open_plated_box_count += 1
				box_opened = nil
			elsif solo_or_other == "worker"
				ask_worker.call
			end
		else
			tpick_get_box(current_box) if solo_or_other == "ground"
			cast_407.call
		end
	else
		waitrt?
		if (found_true_lock_difficulty.nil?)
			number_of_times_to_measure = 0
			measure_detection.call
			fput "speak common" if Char.prof == 'Bard'
			if Char.prof == 'Rogue'
				tpick_put_stuff_away
			elsif Char.prof == 'Bard' && solo_or_other == "ground"
				tpick_drop_box(current_box)
			end
		end
		number = 0
		needed_pick = nil
		needed_pick_id = nil
		if lock == "not locked"
			box_counts_for_math = nil
			if solo_or_other == "solo"
				open_solo.call
			elsif solo_or_other == "other"
				open_others.call
			elsif solo_or_other == "ground"
				nil
			elsif solo_or_other == "worker"
				nil
			end
		elsif lock == "can't find trap"
			echo "Doesn't look like you have the skill to detect the trap on this box."
			box_counts_for_math = nil
			if solo_or_other == "solo"
				where_to_stow_box.call
			elsif solo_or_other == "other"
				tpick_say_cant
				open_others.call
			elsif solo_or_other == "ground"
				nil
			elsif solo_or_other == "worker"
				ask_worker.call
			end
		elsif lock == "can't measure"
			echo "You can't determine the lock difficulty."
			box_counts_for_math = nil
			if solo_or_other == "solo"
				where_to_stow_box.call
			elsif solo_or_other == "other"
				tpick_say_cant
				open_others.call
			elsif solo_or_other == "ground"
				nil
			elsif solo_or_other == "worker"
				ask_worker.call
			end
		elsif lock == "need vaalin"
			$tpick_recommended_pick = "vaalin"
			lock_pick_information.call
			echo "Recommended lock pick: #{$tpick_recommended_pick} with a modifier of #{recommended_pick_modifier}" if UserVars.tpick["run_silently"] !~ /yes/i
			echo "Recommend 403: No" if UserVars.tpick["run_silently"] !~ /yes/i
			echo "Your calculated lockpicking skill: #{pick_skill}" if UserVars.tpick["run_silently"] !~ /yes/i
			temp_math_number = pick_skill
			quick_maths = (temp_math_number * recommended_pick_modifier).truncate
			echo "Your total picking skill for this attempt is: #{quick_maths}" if UserVars.tpick["run_silently"] !~ /yes/i
			echo "Lock difficulty: #{lock}" if UserVars.tpick["run_silently"] !~ /yes/i
			pick2.call
		else
			total_pick_skill = (pick_skill + pick_lore) * 2.50
			if max_lock_attempt_compared_to_max_skill && lock > (total_pick_skill - max_lock_attempt)
				if (scale_trap_found)
					echo "Lock difficulty: #{lock}, your max picking skill with a vaalin lockpick: #{total_pick_skill}, you won't pick anything higher than #{max_lock_attempt} points below your max skill according to the Max Lock setting in the ;setup menu. This box also has a scales trap so can't be popped or wedged open. Skipping box."
					if solo_or_other == "solo"
						where_to_stow_box.call
					elsif solo_or_other == "other"
						tpick_say_cant
						open_others.call
					elsif solo_or_other == "ground"
						cant_open_plated_box_count += 1
						box_opened = nil
					elsif solo_or_other == "worker"
						ask_worker.call
					end
				else
					echo "Lock difficulty: #{lock}, your max picking skill with a vaalin lockpick: #{total_pick_skill}, you won't pick anything higher than #{max_lock_attempt} points below your max skill according to the Max Lock setting in the ;setup menu so a lockpick won't be used."
						wedge_lock.call
				end
			elsif lock > max_lock_attempt && max_lock_attempt_compared_to_max_skill.nil?
				if (scale_trap_found)
					echo "This lock is higher than the Max Lock setting you entered in the ;setup menu so a lockpick won't be used. This box also has a scales trap so can't be popped or wedged open. Skipping box."
					if solo_or_other == "solo"
						where_to_stow_box.call
					elsif solo_or_other == "other"
						tpick_say_cant
						open_others.call
					elsif solo_or_other == "ground"
						cant_open_plated_box_count += 1
						box_opened = nil
					elsif solo_or_other == "worker"
						ask_worker.call
					end
				else
					echo "This lock is higher than the Max Lock setting you entered in the ;setup menu so a lockpick won't be used."
					wedge_lock.call
				end
			else
				if lock > (total_pick_skill + UserVars.tpick["vaalin_lock_roll"].to_i)
					if (scale_trap_found)
						echo "Can't pick this box based on my calculations (and it has a scales trap.) If you think this is in error increase the Vaalin Lock Roll setting in the setup menu. Skipping box."
						if solo_or_other == "solo"
							where_to_stow_box.call
						elsif solo_or_other == "other"
							tpick_say_cant
							open_others.call
						elsif solo_or_other == "ground"
							cant_open_plated_box_count += 1
							box_opened = nil
						elsif solo_or_other == "worker"
							ask_worker.call
						end
					else
						echo "Can't pick this box based on my calculations. If you think this is in error increase the Vaalin Lock Roll setting in the setup menu."
						wedge_lock.call
					end
				else
					pick_mod.each do |i|
						total_pick_skill = (pick_skill + pick_lore)
						if (total_pick_skill) * 2.50 - lock + UserVars.tpick["lock_roll"].to_i < 100
							needed_pick = UserVars.tpick["vaalin"]
							needed_pick_id = vaalin_lock_pick_array.first
							need_403 = "yes" unless UserVars.tpick["always_use_403"] =~ /never/i
							i_need_403 = true unless UserVars.tpick["always_use_403"] =~ /never/i
							number = 15
							break
						else
							total_pick_skill = (pick_skill) * i
							if total_pick_skill - lock + UserVars.tpick["lock_roll"].to_i < 100
								number += 1
								unless UserVars.tpick["always_use_403"] =~ /never/i
									i_need_403 = true if number > 14
								end
							else
								break
							end
						end
						if use_403_for_lock_difficulty && Spell[403].known? && lock > use_403_for_lock_difficulty
							i_need_403 = true
						end
					end
					if i_need_403
						number = 0
						need_403 = "yes" unless UserVars.tpick["always_use_403"] =~ /never/i
						pick_mod.each do |i|
							total_pick_skill = (pick_skill + pick_lore) * i
							if total_pick_skill - lock + UserVars.tpick["lock_roll"].to_i < 100
								number += 1
							else
								break
							end
						end
					end
					if number == 0
						$tpick_recommended_pick = "copper"
					elsif number == 1
						$tpick_recommended_pick = "steel"
					elsif number == 2
						$tpick_recommended_pick = "gold"
					elsif number == 3
						$tpick_recommended_pick = "silver"
					elsif number == 4
						$tpick_recommended_pick = "mithril"
					elsif number == 5
						$tpick_recommended_pick = "ora"
					elsif number == 6
						$tpick_recommended_pick = "glaes"
					elsif number == 7
						$tpick_recommended_pick = "laje"
					elsif number == 8
						$tpick_recommended_pick = "vultite"
					elsif number == 9
						$tpick_recommended_pick = "rolaren"
					elsif number == 10
						$tpick_recommended_pick = "veniom"
					elsif number == 11
						$tpick_recommended_pick = "invar"
					elsif number == 12
						$tpick_recommended_pick = "alum"
					elsif number == 13
						$tpick_recommended_pick = "golvern"
					elsif number == 14
						$tpick_recommended_pick = "kelyn"
					elsif number > 14
						$tpick_recommended_pick = "vaalin"
					end
					lock_pick_information.call
					echo "Recommended lock pick: #{$tpick_recommended_pick} with a modifier of #{recommended_pick_modifier}" if UserVars.tpick["run_silently"] !~ /yes/i
					if need_403 == "yes"
						if use_403_for_lock_difficulty && Spell[403].known? && lock > use_403_for_lock_difficulty
							echo "Lock difficulty is higher than your 403 setting in setup menu, using 403." if UserVars.tpick["run_silently"] !~ /yes/i
						else
							echo "Recommend 403: Yes" if UserVars.tpick["run_silently"] !~ /yes/i
						end
						echo "Your calculated lockpicking skill: #{pick_skill}" if UserVars.tpick["run_silently"] !~ /yes/i
						echo "Your calculated lockpicking lore: #{pick_lore}" if UserVars.tpick["run_silently"] !~ /yes/i
						temp_math_number = pick_skill + pick_lore
					else
						echo "Recommend 403: No" if UserVars.tpick["run_silently"] !~ /yes/i
						echo "Your calculated lockpicking skill: #{pick_skill}" if UserVars.tpick["run_silently"] !~ /yes/i
						temp_math_number = pick_skill
					end
					quick_maths = (temp_math_number * recommended_pick_modifier).truncate
					echo "Your total picking skill for this attempt is: #{quick_maths}" if UserVars.tpick["run_silently"] !~ /yes/i
					echo "Lock difficulty: #{lock}" if UserVars.tpick["run_silently"] !~ /yes/i
					if needed_pick_id.nil?
						if $tpick_recommended_pick == "vaalin"
							5.times{ echo "ALL OF YOUR VAALIN LOCKPICKS ARE BROKEN. YOU REALLY SHOULD HAVE AT LEAST 1 WORKING VAALIN LOCKPICK WHEN RUNNING THIS SCRIPT." }
							exit
						else
							echo "All of your #{$tpick_recommended_pick} lockpicks seem to be broken, trying a higher tier lockpick."
						end
						nextpick.call
					else
						pick2.call
					end
				end
			end
		end
	end
}

find_gnomish_lockpick = proc{
	found_pick = nil
	spin_number = 0
	waitrt?
	fput "turn my #{gnomish_bracers}"
	while line = get
		if line =~ /^You spin your/
			(found_pick = true) if (line =~ /#{needed_pick}/)
			break
		end
	end
	if found_pick == nil
		loop{
			spin_number += 1
			waitrt?
			fput "spin my #{gnomish_bracers}"
			while line = get
				if line =~ /^You spin your/
					(found_pick = true) if (line =~ /#{needed_pick}/)
					break
				end
			end
			break if (found_pick) || (spin_number > 18)
		}
	end
	if (spin_number > 18)
		echo "Couldn't find the lockpick needed to pick this lock in your #{gnomish_bracers}."
		nextpick.call
	else
		pick3.call
	end
}

roll_amount_check = proc{
	waitrt?
	if needed_pick != UserVars.tpick["vaalin"]
		if roll_amount > UserVars.tpick["lock_roll"].to_i
			echo "You rolled: #{roll_amount}, your Lock Roll setting: #{UserVars.tpick["lock_roll"]}. Trying next pick."
			tpick_put_stuff_away
			next_task = "nextpick"
		else
			echo "You rolled: #{roll_amount}, your Lock Roll setting: #{UserVars.tpick["lock_roll"]}. Trying same pick again"
			next_task = "pick3"
		end
	elsif needed_pick == UserVars.tpick["vaalin"]
		if roll_amount > UserVars.tpick["vaalin_lock_roll"].to_i
			if need_403.nil?
				echo "You rolled: #{roll_amount}, your Vaalin Lock Roll setting: #{UserVars.tpick["vaalin_lock_roll"]}. Going to use 403 now."
				roll_amount = 99
			else
				echo "You rolled: #{roll_amount}, your Vaalin Lock Roll setting: #{UserVars.tpick["vaalin_lock_roll"]}. You are already using 403. According to your Vaalin Lock Roll setting you should stop trying to use lockpicks."
				roll_amount = 100
			end
			tpick_put_stuff_away
			next_task = "nextpick"
		else
			echo "You rolled: #{roll_amount}, your Vaalin Lock Roll setting: #{UserVars.tpick["vaalin_lock_roll"]}. Trying same pick again"
			next_task = "pick3"
		end
	end
}

pick2 = proc{
	waitrt?
	if (gnomish_bracers) && override_bracers != "override"
		find_gnomish_lockpick.call
	else
		3.times{
			waitrt?
			unless GameObj.right_hand.id == needed_pick_id || GameObj.left_hand.id == needed_pick_id
				fput "get ##{needed_pick_id}"
				sleep 0.2
			end
		}
		if GameObj.right_hand.id != needed_pick_id && GameObj.left_hand.id != needed_pick_id
			echo "Couldn't find #{needed_pick}."
			waitrt?
			roll_amount = 100
			nextpick.call
		else
			pick3.call
		end
	end
}

pick3 = proc{
	next_task = nil
	roll_amount = nil
	if (open_plinites) || current_box.name =~ /plinite/
		echo "Attempting to extract plinite."
	else
		echo "Attempting to pick lock." if UserVars.tpick["run_silently"] !~ /yes/i
	end
	waitrt?
	tpick_cast_spells (1035) if use_spell_1035
	unless UserVars.tpick["always_use_403"] =~ /never/i
		(tpick_cast_spells (403)) if (need_403 == "yes" || use_spell_403)
	end
	if UserVars.tpick["always_use_403"] =~ /auto/i && need_403.nil? && i_need_403.nil? && use_spell_403.nil?
		tpick_stop_403
	end
	finished_task = nil
	loop{
		if (open_plinites) || current_box.name =~ /plinite/
			fput "extract ##{current_box.id}"
		elsif gnomish_bracers && override_bracers != "override"
			tpick_get_box(current_box) if solo_or_other == "ground"
			fput "push my #{gnomish_bracers}"
		else
			if UserVars.tpick["trick"] == "random" && Char.prof =~ /Rogue/
				random_trick = [ "spin", "twist", "turn", "twirl", "toss", "bend", "flip" ].sample
				do_trick = "lmas ptrick #{random_trick}"
			end
			wait_until { checkrt == 0 }
			fput "#{do_trick} ##{current_box.id}"
		end
		if (open_plinites) || current_box.name =~ /plinite/
			while line = get
				if line =~ /^You make .* attempt \(d100(?:\(open\))?\=(\d+)\)\./
					roll_amount = $1.to_i
					if roll_amount == 1
						waitrt?
						next_task = "pick3"
						finished_task = true
						break
					end
				elsif line =~ /As you do you so\, you push just a little too hard and rupture the core\!/
					waitrt?
					next_task = "next plinite"
					finished_task = true
					break
				elsif line =~ /you withdraw your .* with the feeling that retrieving the core is within your abilities/
					waitrt?
					next_task = "pick3"
					finished_task = true
					break
				elsif line =~ /with the feeling that your abilities are probably not sufficient to retrieve the core/ || line =~ /You fumble about for a bit before you realize you are using a broken/
					if (GameObj.right_hand.id != current_box.id) && (solo_or_other == "ground" || solo_or_other == "worker")
						if line =~ /You fumble about for a bit before you realize you are using a broken/
							@tpick_lockpick_is_broken = true
							tpick_put_stuff_away
							@tpick_all_lockpick_id_arrays.each{ |i| i.delete(i.first) if needed_pick_id == i.first }
							roll_amount = 100 if vaalin_lock_pick_array.length < 1
						else
							tpick_put_stuff_away
						end
					end
					tpick_put_stuff_away
					if needed_pick == UserVars.tpick["vaalin"]
						if solo_or_other == "worker"
							echo "Can't extract this plinite based on my calculations. If you think this is in error increase the Vaalin Lock Roll setting in the setup menu."
							next_task = "next plinite"
						else
							echo "Can't extract this plinite, OPENing it instead. If you think this is in error increase the Vaalin Lock Roll setting in the setup menu."
							waitrt?
							fput "open ##{current_box.id}"
							next_task = "next plinite"
						end
					else
						next_task = "nextpick"
					end
					finished_task = true
					break
				elsif line =~ /where it can be easily PLUCKed/
					next_task = "open plinite"
					finished_task = true
					break
				elsif line =~ /^Roundtime\:/
					finished_task = true
					break
				elsif line =~ /\.\.\.wait/
					break
				end
			end
		else
			while line = get
				#Get roll amount:
				if line =~ /^You make .* attempt \(d100(?:\(open\))?\=(\d+)\)\./
					roll_amount = $1.to_i
					next_task = "pick3" if roll_amount == 1
				####################################################################################################
				#Box has been opened or was already open:
				elsif line =~ /^You struggle with the .*\.  As you do\, you get a sense that the .* has .* \(\-(\d+) thief\-lingo difficulty ranking\)\.  Then\.\.\.CLICK\!  It opens\!|^The .* gives off an audible \*click\* as the tumblers snap open\.|^It does not appear to be locked./
					calibrate_count += 1
					waitrt?
					tpick_put_stuff_away
					if line =~ /^It does not appear to be locked./
						box_counts_for_math = nil
					elsif line =~ /^You struggle with the .*\.  As you do\, you get a sense that the .* has .* \(\-(\d+) thief\-lingo difficulty ranking\)\.  Then\.\.\.CLICK\!  It opens\!|^The .* gives off an audible \*click\* as the tumblers snap open\./
						actual_lock_difficulty = $1.to_i if line =~ /^You struggle with the .*\.  As you do\, you get a sense that the .* has .* \(\-(\d+) thief\-lingo difficulty ranking\)\.  Then\.\.\.CLICK\!  It opens\!/
						if @rogue_automate_current_task_with_tpick && solo_or_other == "worker" && @rogue_current_task == "Repair broken lockpicks"
							box_counts_for_math = nil
						else
							CharSettings["number_of_locks_opened_since_last_broken_pick"] += 1
							CharSettings["number_of_current_uses_for_lockpicks"][$tpick_recommended_pick] += 1
							successful_lockpick_text = "Number of locks successfully opened since last broken lockpick: "
							CharSettings["number_of_current_uses_for_lockpicks"].each{ |key,value| successful_lockpick_text += "#{key}: #{value}, "	}
							successful_lockpick_text = successful_lockpick_text.chop.chop
							successful_lockpick_text += ". Number of total locks picked since any lockpick broke: #{CharSettings["number_of_locks_opened_since_last_broken_pick"]}"
							echo "#{successful_lockpick_text}"
							if Char.prof == "Rogue"
								if calibrate_auto_amount && calipers_measured_lock.is_a?(Numeric) && actual_lock_difficulty.is_a?(Numeric)
									calibrate_auto_math = (calipers_measured_lock - actual_lock_difficulty).abs
									if calibrate_auto_math >= calibrate_auto_amount
										unless popping
											echo "The difference between calipers reading and actual lock difficulty was #{calibrate_auto_math}. According to your settings you want your calipers calibrated."
											calibrate.call
										end
									end
								elsif (calibrate_count >= UserVars.tpick["calibratecount"].to_i) && (calibrate_auto_amount.nil?)
									if can_use_calipers && always_use_vaalin.nil? && start_with_copper.nil?
										calibrate.call unless popping
									end
									calibrate_count = 0
								end
							end
						end
					end
					if scale_trap_found
						next_task = "scale_disarm_call"
					elsif solo_or_other == "solo"
						next_task = "open_solo"
					elsif solo_or_other == "other"
						next_task = "open_other"
					elsif solo_or_other == "ground"
						tpick_drop_box(current_box) if gnomish_bracers && override_bracers != "override"
						next_task = "open_ground"
					elsif solo_or_other == "worker"
						next_task = "worker finished"
					end
					finished_task = true
					break
				####################################################################################################
				#No read from the box:
				elsif line =~ /^You are not able to pick the lock\, and learn little about it\./
					if roll_amount == 1
						echo "This attempt was a fumble, going to try again."
						next_task = "pick3"
					else
						roll_amount_check.call
					end
					finished_task = true
					break
				####################################################################################################
				#Box can be opened with current lockpick:
				elsif line =~ /^You are not able to pick the .*\, but you get a sense that it has .* lock\.  About a \-(\d+) difficulty lock \(in thief\-lingo\)\.|^You are not able to pick the lock\, but you get a feeling that it is within your abilities\.|^You get a sense that the .* \(\-(\d+) thief\-lingo difficulty ranking\)\./
					if (line =~ /^You are not able to pick the .*\, but you get a sense that it has .* lock\.  About a \-(\d+) difficulty lock \(in thief\-lingo\)\./ || line =~ /^You get a sense that the .* \(\-(\d+) thief\-lingo difficulty ranking\)\./) && found_true_lock_difficulty.nil?
						lock = $1.to_i
						found_true_lock_difficulty = true
						next_task = "measure again"
					else
						if roll_amount == 1
							echo "This attempt was a fumble, going to try again."
							next_task = "pick3"
						else
							if UserVars.tpick["keep_trying_if_within_abilities"] =~ /yes/i
								echo "Messaging indicates you can open this box with current lockpick, according to your settings you want to try same lockpick again."
								next_task = "pick3"
							else
								echo "Messaging indicates you can open this box with current lockpick, but according to your settings you don't want to try same lockpick again."
								roll_amount_check.call
							end
						end
					end
					finished_task = true
					break unless line =~ /^You get a sense that the .* \(\-(\d+) thief\-lingo difficulty ranking\)\./
				####################################################################################################
				#Lockpick has been damaged, most likely box can't be opened with current lockpick:			
				elsif line =~ /^Your .* gets stuck in the lock\!  You carefully try to work it free but end up bending the tip\!|^Your .* gets stuck in the lock\!  You carefully try to work it free\, but it may have been weakened by the stress\./
					waitrt?
					wait_until { checkrt == 0 }
					if line =~ /^Your .* stuck in the lock\!  You carefully try to work it free but end up bending the tip\!/ && UserVars.tpick["auto_repair_bent_lockpicks"] == "yes" && Char.prof == "Rogue"
						waitrt?
						wait_until { checkrt == 0 }
						echo "Lockpick tip was bent, going to try repairing it."
						tpick_stow_box(current_box) if solo_or_other !~ /ground|worker/
						fput "lmas repair ##{needed_pick_id}"
						waitrt?
						sleep 1
						wait_until { checkrt == 0 }
						tpick_get_box(current_box) if solo_or_other !~ /ground|worker/
					end
					if roll_amount == 1
						echo "This attempt was a fumble, going to try again."
						next_task = "pick3"
					elsif roll_amount < max_roll_attempt_before_moving_to_new_pick
						echo "You rolled #{roll_amount}, your settings are to try again because you rolled less than #{max_roll_attempt_before_moving_to_new_pick}."
						next_task = "pick3"
					else
						if needed_pick != UserVars.tpick["vaalin"]
							echo "This pick doesn't seem to be cutting it, going to try a different one."
						elsif needed_pick == UserVars.tpick["vaalin"]
							if need_403.nil?
								echo "A vaalin pick doesn't seem to be cutting it alone, going to try 403."
								roll_amount = 99
							else
								echo "A vaalin pick with 403 doesn't seem to be cutting it, going to try wedges or 407."
								roll_amount = 100
							end
						end
						tpick_put_stuff_away
						next_task = "nextpick"
					end
					finished_task = true
					break
				####################################################################################################
				#Lockpick has been broken or was already broken:
				elsif line =~ /^\* SNAP \*  Crud\!  You broke your .* in the attempt\!|^You attempt to pick the .* and fumble about for a bit before you realize you are using a broken .*\.|^Your .* gets stuck in the lock\!  You carefully try to work it free but end up snapping off the tip\!/
					if @rogue_automate_current_task_with_tpick && solo_or_other == "worker" && @rogue_current_task == "Repair broken lockpicks"
						all_lockpicks_to_break_for_rogue.delete(GameObj.right_hand.id)
						until checkright.nil?
							waitrt?
							fput "stow ##{GameObj.right_hand.id}"
							sleep 0.2
						end
						if all_lockpicks_to_break_for_rogue.count == 0
							@rogue_text_to_display.push("That's the last lockpick to break! Let's repair them all now.")
							rogue_display_message
							@tpick_finished_with_current_rogue_task = true
							exit
						else
							@rogue_text_to_display.push("Broke this lockpick! #{all_lockpicks_to_break_for_rogue.count} more to go!")
							rogue_display_message
						end
					else
						if line =~ /^\* SNAP \*  Crud\!  You broke your .* in the attempt\!|^Your .* gets stuck in the lock\!  You carefully try to work it free but end up snapping off the tip\!/
							echo "Your #{$tpick_recommended_pick} lockpick successfully picked #{CharSettings["number_of_current_uses_for_lockpicks"][$tpick_recommended_pick]} locks before it broke. You successfully picked #{CharSettings["number_of_locks_opened_since_last_broken_pick"]} locks since you last broke any lockpick."
							CharSettings["number_of_locks_opened_since_last_broken_pick"] = 0
							CharSettings["number_of_current_uses_for_lockpicks"][$tpick_recommended_pick] = 0
						end
						echo "#{needed_pick} is broken."
						waitrt?
						next_task = "broken lockpick stow"
					end
					finished_task = true
					break
				####################################################################################################
				#Not holding a lockpick, either because the person doesn't have the needed pick or the needed pick is broken:
				elsif line =~ /^You must be holding a lockpick to perform that trick\.|^You didn\'t mention what you want to pick the lock with\./
					echo "Couldn't find #{needed_pick}."
					waitrt?
					next_task = "nextpick"
					finished_task = true
					break
				####################################################################################################
				elsif line =~ /^Roundtime\:/
					finished_task = true
					break
				elsif line =~ /\.\.\.wait/
					break
				end
			end
		end
		break if finished_task
	}
	if @rogue_automate_current_task_with_tpick && solo_or_other == "worker" && @rogue_current_task == "Repair broken lockpicks"
		if next_task == "scale_disarm_call"
			scaledisarm.call
		elsif next_task == "worker finished"
			nil
		elsif next_task == "open plinite"
			if solo_or_other == "worker"
				ask_worker.call
			end
		elsif next_task == "next plinite"
			tpick_put_stuff_away
			ask_worker.call if solo_or_other == "worker"
		else
			measure.call
		end
	else
		if next_task == "open_solo"
			open_solo.call
		elsif next_task == "open_other"
			open_others.call
		elsif next_task == "worker finished"
			relock_boxes_for_rogues.call if @rogue_automate_current_task_with_tpick && solo_or_other == "worker" && @rogue_current_task == "Relock tough boxes"
		elsif next_task == "open_ground"
			nil
		elsif next_task == "pick3"
			pick3.call
		elsif next_task == "nextpick"
			nextpick.call
		elsif next_task == "measure again"
			echo "Got a read on this box, going to change to best suited lockpick."
			waitrt?
			tpick_put_stuff_away
			measure.call
		elsif next_task == "broken lockpick stow"
			if gnomish_bracers && override_bracers != "override"
				nextpick.call
			else
				@tpick_lockpick_is_broken = true
				tpick_put_stuff_away
				@tpick_all_lockpick_id_arrays.each{ |i| i.delete(i.first) if needed_pick_id == i.first }
				roll_amount = 100 if vaalin_lock_pick_array.length < 1
				nextpick.call
			end
		elsif next_task == "open plinite"
			if solo_or_other == "worker"
				ask_worker.call
			else
				open_current_plinite.call
			end
		elsif next_task == "next plinite"
			tpick_put_stuff_away
			ask_worker.call if solo_or_other == "worker"
		elsif next_task == "scale_disarm_call"
			scaledisarm.call
		end
	end
}

nextpick = proc{
	before_needed_pick = needed_pick
	before_recommended_pick = $tpick_recommended_pick
	if $tpick_recommended_pick == "copper"
		needed_pick = UserVars.tpick["steel"]
		needed_pick_id = steel_lock_pick_array.first
		$tpick_recommended_pick = "steel"
	elsif $tpick_recommended_pick == "steel"
		needed_pick = UserVars.tpick["gold"]
		needed_pick_id = gold_lock_pick_array.first
		$tpick_recommended_pick = "gold"
	elsif $tpick_recommended_pick == "gold"
		needed_pick = UserVars.tpick["silver"]
		needed_pick_id = silver_lock_pick_array.first
		$tpick_recommended_pick = "silver"
	elsif $tpick_recommended_pick == "silver"
		needed_pick = UserVars.tpick["mithril"]
		needed_pick_id = mithril_lock_pick_array.first
		$tpick_recommended_pick = "mithril"
	elsif $tpick_recommended_pick == "mithril"
		needed_pick = UserVars.tpick["ora"]
		needed_pick_id = ora_lock_pick_array.first
		$tpick_recommended_pick = "ora"
	elsif $tpick_recommended_pick == "ora"
		needed_pick = UserVars.tpick["glaes"]
		needed_pick_id = glaes_lock_pick_array.first
		$tpick_recommended_pick = "glaes"
	elsif $tpick_recommended_pick == "glaes"
		needed_pick = UserVars.tpick["laje"]
		needed_pick_id = laje_lock_pick_array.first
		$tpick_recommended_pick = "laje"
	elsif $tpick_recommended_pick == "laje"
		needed_pick = UserVars.tpick["vultite"]
		needed_pick_id = vultite_lock_pick_array.first
		$tpick_recommended_pick = "vultite"
	elsif $tpick_recommended_pick == "vultite"
		needed_pick = UserVars.tpick["rolaren"]
		needed_pick_id = rolaren_lock_pick_array.first
		$tpick_recommended_pick = "rolaren"
	elsif $tpick_recommended_pick == "rolaren"
		needed_pick = UserVars.tpick["veniom"]
		needed_pick_id = veniom_lock_pick_array.first
		$tpick_recommended_pick = "veniom"
	elsif $tpick_recommended_pick == "veniom"
		needed_pick = UserVars.tpick["invar"]
		needed_pick_id = invar_lock_pick_array.first
		$tpick_recommended_pick = "invar"
	elsif $tpick_recommended_pick == "invar"
		needed_pick = UserVars.tpick["alum"]
		needed_pick_id = alum_lock_pick_array.first
		$tpick_recommended_pick = "alum"
	elsif $tpick_recommended_pick == "alum"
		needed_pick = UserVars.tpick["golvern"]
		needed_pick_id = golvern_lock_pick_array.first
		$tpick_recommended_pick = "golvern"
	elsif $tpick_recommended_pick == "golvern"
		needed_pick = UserVars.tpick["kelyn"]
		needed_pick_id = kelyn_lock_pick_array.first
		$tpick_recommended_pick = "kelyn"
	elsif $tpick_recommended_pick == "kelyn"
		needed_pick = UserVars.tpick["vaalin"]
		needed_pick_id = vaalin_lock_pick_array.first
		$tpick_recommended_pick = "vaalin"
	elsif $tpick_recommended_pick == "vaalin" && roll_amount != 100
		need_403 = "yes" unless UserVars.tpick["always_use_403"] =~ /never/i
		needed_pick = UserVars.tpick["vaalin"]
		needed_pick_id = vaalin_lock_pick_array.first
		$tpick_recommended_pick = "vaalin"
	elsif $tpick_recommended_pick == "vaalin" && roll_amount == 100
		needed_pick = "wedge"
	end
	if needed_pick_id.nil?
		if $tpick_recommended_pick == "vaalin"
			5.times{ echo "ALL OF YOUR VAALIN LOCKPICKS ARE BROKEN. YOU REALLY SHOULD HAVE AT LEAST 1 WORKING VAALIN LOCKPICK WHEN RUNNING THIS SCRIPT." }
			exit
		else
			echo "All of your #{$tpick_recommended_pick} lockpicks seem to be broken, trying a higher tier lockpick."
			nextpick.call
		end
	elsif before_needed_pick == needed_pick && $tpick_recommended_pick != "vaalin"
		nextpick.call
	else
		nextpick2.call
	end
}

nextpick2 = proc{
	if needed_pick == "wedge"
		if open_plinites || current_box.name =~ /plinite/
			if solo_or_other == "worker"
				echo "Can't extract this plinite based on my calculations. If you think this is in error increase the Vaalin Lock Roll setting in the setup menu."
				ask_worker.call
			else
				echo "Can't extract this plinite, OPENing it instead. If you think this is in error increase the Vaalin Lock Roll setting in the setup menu."
				waitrt?
				fput "open ##{current_box.id}"
			end
		elsif (scale_trap_found)
			echo "Can't pick this box and it has a scales trap."
			if solo_or_other == "solo"
				where_to_stow_box.call
			elsif solo_or_other == "other"
				tpick_say_cant
				open_others.call
			elsif solo_or_other == "ground"
				cant_open_plated_box_count += 1
				box_opened = nil
			end
		else
			if Char.prof =~ /Rogue/
				echo "Can't pick this lock, going to try to wedge it open."
				wedge_lock.call
			elsif Spell[407].known?
				echo "Can't pick this lock, going to try to pop it open."
				cast_407.call
			else
				if solo_or_other == "other"
					tpick_say_cant
					open_others.call
				elsif solo_or_other == "ground"
					echo "Couldn't open this box."
					box_opened = nil
				elsif solo_or_other == "solo"
					echo "Couldn't open this box."
					where_to_stow_box.call
					tpick_put_stuff_away
					sleep 0.1
				end
			end
		end
	elsif before_needed_pick == UserVars.tpick["vaalin"]
		echo "Trying to pick with vaalin lockpick again."
		pick2.call
	else
		echo "Couldn't pick lock with #{before_recommended_pick} pick, trying #{$tpick_recommended_pick} pick."
		pick2.call
	end
}

total_boxes_picked_math = proc{
	if (update_math_information)
		if (box_counts_for_math == nil)
			echo "This box was not added to your total boxes picked nor was the time spent opening it recorded."
		else
			total_picking_time = (Time.now - start_time)
			CharSettings['total_boxes_picked'] += 1
			(CharSettings['total_time_spent_picking_boxes'] += total_picking_time)
		end
		if solo_or_other == "solo" || solo_or_other == "ground"
			total_boxes_number -= 1
			total_boxes_number = [total_boxes_number, 0].max
		end
	end
	CharSettings['total_time_spent_picking_boxes'] = CharSettings['total_time_spent_picking_boxes'].round(2) unless CharSettings['total_time_spent_picking_boxes'] == 0
	average_picking_time = (CharSettings['total_time_spent_picking_boxes'] / CharSettings['total_boxes_picked']).round(2) unless CharSettings['total_boxes_picked'] == 0
	if CharSettings['total_boxes_picked'] > 0
		_respond "\n"
		_respond "####################"
		_respond "####################"
		_respond "Total boxes picked: #{CharSettings['total_boxes_picked'].to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}"
		_respond "Total time picking: #{CharSettings['total_time_spent_picking_boxes'].to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse} seconds"
		_respond "Average time per box: #{average_picking_time} seconds"
		_respond "####################"
		_respond "####################"
		_respond "\n"
	end
	if solo_or_other == "solo" || solo_or_other == "ground"
		(calculate_time_left = (total_boxes_number * average_picking_time).round(2)) unless CharSettings['total_boxes_picked'] == 0
		_respond "\n"
		_respond "####################"
		_respond "####################"
		_respond "Boxes remaining: #{total_boxes_number}"
		(_respond "Estimated time remaining: #{calculate_time_left} seconds") unless CharSettings['total_boxes_picked'] == 0
		_respond "####################"
		_respond "####################"
		_respond "\n"
	end
	box_counts_for_math = true
}

open_solo = proc{
	update_math_information = true
	total_boxes_picked_math.call
	waitrt?
	tpick_cast_spells (1035) if use_spell_1035	
	total_boxes_picked += 1
	fput "open ##{current_box.id}" unless popping
	lootbox = GameObj.right_hand
	(dothistimeout "look in my #{lootbox}", 10, /In .*? you see|In the .*\:|There is nothing in/) if lootbox.contents.nil?
	waitrt?
	fput "swap"
	lootbox.contents.each{ |item|
		current_item = item
		tpick_gather_the_loot.call
	}
	do_relock_boxes.call if relock_boxes
	garbage_check.call
	if box != "none"
		tpick_put_stuff_away
		sleep 0.1
	else
		tpick_put_stuff_away
	end
}

garbage_check = proc{
	waitrt?
	if UserVars.tpick["trash_boxes"] == "yes"
		if checkroom =~ /table|booth/i
			tpick_drop_box(current_box) if solo_or_other == "solo"
			fput "clean table"
		elsif GameObj.loot.find { |loot| trash = loot if loot.name =~ trash_container } || GameObj.room_desc.find { |loot| trash = loot if loot.name =~ trash_container }
			waitrt?
			tpick_get_box(current_box) if solo_or_other == "ground"
			fput "put ##{current_box.id} in #{trash}"
		else
			tpick_drop_box(current_box) if solo_or_other == "solo"
		end
	elsif UserVars.tpick["trash_boxes"] == "save"
		@tpick_stow_current_box = true
		tpick_put_stuff_away
	else
		tpick_drop_box(current_box) if solo_or_other == "solo"
	end
	waitrt?
}

record_item_data = proc{
		if GameObj.right_hand.type =~ /gem/i
			gem = Array.new if gem == nil
			(gem.push(GameObj.right_hand.name);gem_number[gem.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /reagent/i
			reagent = Array.new if reagent == nil
			(reagent.push(GameObj.right_hand.name);reagent_number[reagent.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /herb/i
			herb = Array.new if herb == nil
			(herb.push(GameObj.right_hand.name);herb_number[herb.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /food/i
			food = Array.new if food == nil
			(food.push(GameObj.right_hand.name);food_number[food.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /uncommon/i
			uncommon = Array.new if uncommon == nil
			(uncommon.push(GameObj.right_hand.name);uncommon_number[uncommon.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /jewelry/i
			jewelry = Array.new if jewelry == nil
			(jewelry.push(GameObj.right_hand.name);jewelry_number[jewelry.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /junk/i
			junk = Array.new if junk == nil
			(junk.push(GameObj.right_hand.name);junk_number[junk.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /lockpick/i
			lockpick = Array.new if lockpick == nil
			(lockpick.push(GameObj.right_hand.name);lockpick_number[lockpick.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /magic/i
			magic = Array.new if magic == nil
			(magic.push(GameObj.right_hand.name);magic_number[magic.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /scroll/i
			scroll = Array.new if scroll == nil
			(scroll.push(GameObj.right_hand.name);scroll_number[scroll.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /wand/i
			wand = Array.new if wand == nil
			(wand.push(GameObj.right_hand.name);wand_number[wand.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /armor/i
			armor = Array.new if armor == nil
			(armor.push(GameObj.right_hand.name);armor_number[armor.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /weapon/i
			weapon = Array.new if weapon == nil
			(weapon.push(GameObj.right_hand.name);weapon_number[weapon.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /clothing/i
			clothing = Array.new if clothing == nil
			(clothing.push(GameObj.right_hand.name);clothing_number[clothing.index(GameObj.right_hand.name)] += 1)
		else
			other = Array.new if other == nil
			(other.push(GameObj.right_hand.name);other_number[other.index(GameObj.right_hand.name)] += 1)
		end
}

open_others = proc{
	update_math_information = true
	total_boxes_picked_math.call
	waitrt?
	fput "give ##{current_box.id} to #{person}"
	start_others.call
}

before_dying {
	DownstreamHook.remove("#{script.name}_check_locksmiths_container")
	DownstreamHook.remove("#{script.name}_check_for_mithril_or_enruned")
	DownstreamHook.remove("#{script.name}_wealth_before")
	DownstreamHook.remove("#{script.name}_wealth_after")
	if display_the_help_menu.nil? && script.vars.any?{ |i| i !~ /buy|repair|setup/i }
		if ground_loot || solo_or_other == "solo"
			wealth_after.call
			wait_until { silver_after }
			silver_gained = silver_after - silver_before if silver_after && silver_before
		end

		_respond "Total boxes picked: #{total_boxes_picked}" if ground_loot || solo_or_other == "solo"
		_respond "Total silvers gained: #{silver_gained}" if ground_loot || solo_or_other == "solo"
		(gem.uniq! if gem != nil;reagent.uniq! if reagent != nil;herb.uniq! if herb != nil;food.uniq! if food != nil;uncommon.uniq! if uncommon != nil;jewelry.uniq! if jewelry != nil;junk.uniq! if junk != nil;lockpick.uniq!if lockpick != nil;magic.uniq! if magic != nil;scroll.uniq! if scroll != nil;wand.uniq! if wand != nil;armor.uniq! if armor != nil;weapon.uniq! if weapon != nil;other.uniq! if other != nil;clothing.uniq if clothing != nil) if ground_loot || solo_or_other == "solo"
		(_respond "\nGems:\n";gem.each{|item|_respond "#{item} x#{gem_number[gem.index(item)]}"}) if gem != nil and (ground_loot or solo_or_other == "solo")
		(_respond "\nReagents:\n";reagent.each{|item|_respond "#{item} x#{reagent_number[reagent.index(item)]}"}) if reagent != nil and (ground_loot or solo_or_other == "solo")
		(_respond "\nHerbs:\n";herb.each{|item|_respond "#{item} x#{herb_number[herb.index(item)]}"}) if herb != nil and (ground_loot or solo_or_other == "solo")
		(_respond "\nFood:\n";food.each{|item|_respond "#{item} x#{food_number[food.index(item)]}"}) if food != nil and (ground_loot or solo_or_other == "solo")
		(_respond "\nUncommon:\n";uncommon.each{|item|_respond "#{item} x#{uncommon_number[uncommon.index(item)]}"}) if uncommon != nil and (ground_loot or solo_or_other == "solo")
		(_respond "\nJewelry:\n";jewelry.each{|item|_respond "#{item} x#{jewelry_number[jewelry.index(item)]}"}) if jewelry != nil and (ground_loot or solo_or_other == "solo")
		(_respond "\nJunk:\n";junk.each{|item|_respond "#{item} x#{junk_number[junk.index(item)]}"}) if junk != nil and (ground_loot or solo_or_other == "solo")
		(_respond "\nLockpicks:\n";lockpick.each{|item|_respond "#{item} x#{lockpick_number[lockpick.index(item)]}"}) if lockpick != nil and (ground_loot or solo_or_other == "solo")
		(_respond "\nMagic:\n";magic.each{|item|_respond "#{item} x#{magic_number[magic.index(item)]}"}) if magic != nil and (ground_loot or solo_or_other == "solo")
		(_respond "\nScrolls:\n";scroll.each{|item|_respond "#{item} x#{scroll_number[scroll.index(item)]}"}) if scroll != nil and (ground_loot or solo_or_other == "solo")
		(_respond "\nWands:\n";wand.each{|item|_respond "#{item} x#{wand_number[wand.index(item)]}"}) if wand != nil and (ground_loot or solo_or_other == "solo")
		(_respond "\nArmor:\n";armor.each{|item|_respond "#{item} x#{armor_number[armor.index(item)]}"}) if armor != nil and (ground_loot or solo_or_other == "solo")
		(_respond "\nWeapons:\n";weapon.each{|item|_respond "#{item} x#{weapon_number[weapon.index(item)]}"}) if weapon != nil and (ground_loot or solo_or_other == "solo")
		(_respond "\nClothing:\n";clothing.each{|item|_respond "#{item} x#{clothing_number[clothing.index(item)]}"}) if clothing != nil and (ground_loot or solo_or_other == "solo")
		(_respond "\nOther:\n";other.each{|item|_respond "#{item} x#{other_number[other.index(item)]}"}) if other != nil and (ground_loot or solo_or_other == "solo")
		all_containers_to_close_before_exit = UserVars.tpick["containers_to_close_before_exit"].split(",")
		if worker_start_picking_time
			time_spent_pool_picking_this_session = Time.now - worker_start_picking_time
			CharSettings["total_time_spent_pool_picking"] += time_spent_pool_picking_this_session
			####################################################################################################
			t = time_spent_pool_picking_this_session
			time_spent_picking = "%02d:%02d:%02d" % [t/3600%24, t/60%60, t%60]
			total_scarab_value = (scarabs_received_this_session_pool_picking * 5000)
			silver_tips_plus_scarab_value = silvers_earned_from_pool_picking_this_session + total_scarab_value
			silvers_earned_hour = ((silver_tips_plus_scarab_value / time_spent_pool_picking_this_session) * 3600).truncate
			if scarabs_received_this_session_pool_picking > 0
				scarab_frequency = (((scarabs_received_this_session_pool_picking *1.0) / number_of_boxes_picked_this_session_pool_picking) * 100).round(2)
			else
				scarab_frequency = 0
			end
			_respond "This session:\nTime: #{time_spent_picking}\nNumber of boxes: #{number_of_boxes_picked_this_session_pool_picking}\nNumber of scarabs: #{scarabs_received_this_session_pool_picking}\nSilver tips: #{silvers_earned_from_pool_picking_this_session.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}\nScarab value (5k per scarab): #{total_scarab_value.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}\nScarab frequency: #{scarab_frequency}%\nTotal silvers: #{silver_tips_plus_scarab_value.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}\nSilvers earned per hour: #{silvers_earned_hour.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}"
			_respond "####################################################################################################"
			grand_total_time_spent_actual_picking = (time_spent_pool_picking_this_session - time_to_subtract_from_actual_picking_time)
			t = grand_total_time_spent_actual_picking
			time_spent_picking = "%02d:%02d:%02d" % [t/3600%24, t/60%60, t%60]
			silvers_earned_hour = ((silver_tips_plus_scarab_value / grand_total_time_spent_actual_picking) * 3600).truncate
			_respond "This session (not including time waiting for boxes):\nTime: #{time_spent_picking}\nSilvers earned per hour: #{silvers_earned_hour.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}"
			_respond "####################################################################################################"
			t = CharSettings["total_time_spent_pool_picking"]
			time_spent_picking = "%02d:%02d:%02d" % [t/3600%24, t/60%60, t%60]
			total_scarab_value = (CharSettings["total_scarabs_received_pool_picking"] * 5000)
			silver_tips_plus_scarab_value = CharSettings["total_silvers_earned_from_pool_picking"] + total_scarab_value
			silvers_earned_hour = ((silver_tips_plus_scarab_value / CharSettings["total_time_spent_pool_picking"]) * 3600).truncate
			scarab_frequency = (((CharSettings["total_scarabs_received_pool_picking"] *1.0) / CharSettings["number_of_total_boxes_picked_pool_picking"]) * 100).round(2)
			_respond "Total:\nTime: #{time_spent_picking}\nNumber of boxes: #{CharSettings["number_of_total_boxes_picked_pool_picking"]}\nNumber of scarabs: #{CharSettings["total_scarabs_received_pool_picking"]}\nSilver tips: #{CharSettings["total_silvers_earned_from_pool_picking"].to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}\nScarab value (5k per scarab): #{total_scarab_value.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}\nScarab frequency: #{scarab_frequency}%\nTotal silvers: #{silver_tips_plus_scarab_value.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}\nSilvers earned per hour: #{silvers_earned_hour.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}"
			_respond "####################################################################################################"
			CharSettings['time_to_subtract_from_overall_actual_picking_time'] += time_to_subtract_from_actual_picking_time
			grand_total_time_spent_actual_picking = (CharSettings["total_time_spent_pool_picking"] - CharSettings['time_to_subtract_from_overall_actual_picking_time'])
			t = grand_total_time_spent_actual_picking
			time_spent_picking = "%02d:%02d:%02d" % [t/3600%24, t/60%60, t%60]
			silvers_earned_hour = ((silver_tips_plus_scarab_value / grand_total_time_spent_actual_picking) * 3600).truncate
			_respond "Total (not including time waiting for boxes):\nTime: #{time_spent_picking}\nSilvers earned per hour: #{silvers_earned_hour.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}"
			_respond "####################################################################################################"
		end
		if all_containers_to_close_before_exit.length > 1
			echo "I will close your containers as soon as you're out of RT then I will exit." if checkrt > 0
			wait_until { checkrt == 0 }
			all_containers_to_close_before_exit.each{ |i|
				i = i[1..-1] if i[0] == " "
				container_to_close = GameObj.inv.find{ |t| t.name == i }
				fput "close ##{container_to_close.id}" if container_to_close
			}
		end
		if $tpick_armor_has_been_removed
			echo "I will equip your armor as soon as you're out of RT then I will exit." if checkrt > 0
			wait_until { checkrt == 0 }
			tpick_put_stuff_away
			fput "get #{$tpick_remove_armor_before_casting_spell}"
			wait_until { checkright }
			fput "wear #{$tpick_remove_armor_before_casting_spell}"
		end
	end
}

gem = nil
reagent = nil
herb = nil
food = nil
uncommon = nil
jewelry = nil
junk = nil
lockpick = nil
magic = nil
scroll = nil
wand = nil
armor = nil
weapon = nil
clothing = nil
other = nil

gem_number = Array.new
reagent_number = Array.new
herb_number = Array.new
food_number = Array.new
uncommon_number = Array.new
jewelry_number = Array.new
junk_number = Array.new
lockpick_number = Array.new
magic_number = Array.new
scroll_number = Array.new
wand_number = Array.new
armor_number = Array.new
weapon_number = Array.new
clothing_number = Array.new
other_number = Array.new

wealth_before = proc {
	action = proc { |server_string|
		if server_string =~ /^\s*Name\:|^\s*Gender\:|^\s*Normal \(Bonus\)|^\s*Strength \(STR\)\:|^\s*Constitution \(CON\)\:|^\s*Dexterity \(DEX\)\:|^\s*Agility \(AGI\)\:|^\s*Discipline \(DIS\)\:|^\s*Aura \(AUR\)\:|^\s*Logic \(LOG\)\:|^\s*Intuition \(INT\)\:|^\s*Wisdom \(WIS\)\:|^\s*Influence \(INF\)\:/
			nil
		elsif server_string =~ /^\s*Mana\:\s+\-?[0-9]+\s+Silver\:\s+(.*)/
			silver_before = $1.delete(",").to_i
			DownstreamHook.remove("#{script.name}_wealth_before")
			nil
		else
			server_string
		end
	}
		DownstreamHook.add("#{script.name}_wealth_before", action)
		silence_me
		fput "info"
		silence_me
}

wealth_after = proc{
	action = proc { |server_string|
		if server_string =~ /^\s*Name\:|^\s*Gender\:|^\s*Normal \(Bonus\)|^\s*Strength \(STR\)\:|^\s*Constitution \(CON\)\:|^\s*Dexterity \(DEX\)\:|^\s*Agility \(AGI\)\:|^\s*Discipline \(DIS\)\:|^\s*Aura \(AUR\)\:|^\s*Logic \(LOG\)\:|^\s*Intuition \(INT\)\:|^\s*Wisdom \(WIS\)\:|^\s*Influence \(INF\)\:/
			nil
		elsif server_string =~ /^\s*Mana\:\s+\-?[0-9]+\s+Silver\:\s+(.*)/
			silver_after = $1.delete(",").to_i
			DownstreamHook.remove("#{script.name}_wealth_after")
			nil
		else
			server_string
		end
	}
		DownstreamHook.add("#{script.name}_wealth_after", action)
		silence_me
		put "info"
		silence_me
}
					
get_wire_order_numbers = proc{
	move 'out' if checkpaths 'out'
	target_room = Room.current.find_nearest(toolbenches_room_number)
	start_script 'go2', [ target_room.to_s ]
	wait_while{ running?('go2') }
	move 'go toolbench'
	fput "read sign"
	while line = get
		if line =~ /\s*(\d+)\..*copper wire\s+(\d+)/
			$tpick_copper_wire = $1
			$tpick_copper_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*brass wire\s+(\d+)/
			$tpick_brass_wire = $1
			$tpick_brass_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*steel wire\s+(\d+)/
			$tpick_steel_wire = $1
			$tpick_steel_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*gold wire\s+(\d+)/
			$tpick_gold_wire = $1
			$tpick_gold_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*silver wire\s+(\d+)/
			$tpick_silver_wire = $1
			$tpick_silver_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*ora wire\s+(\d+)/
			$tpick_ora_wire = $1
			$tpick_ora_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*mithril wire\s+(\d+)/
			$tpick_mithril_wire = $1
			$tpick_mithril_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*laje wire\s+(\d+)/
			$tpick_laje_wire = $1
			$tpick_laje_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*alum wire\s+(\d+)/
			$tpick_alum_wire = $1
			$tpick_alum_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*vultite wire\s+(\d+)/
			$tpick_vultite_wire = $1
			$tpick_vultite_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*rolaren wire\s+(\d+)/
			$tpick_rolaren_wire = $1
			$tpick_rolaren_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*veniom wire\s+(\d+)/
			$tpick_veniom_wire = $1
			$tpick_veniom_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*kelyn wire\s+(\d+)/
			$tpick_kelyn_wire = $1
			$tpick_kelyn_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*invar wire\s+(\d+)/
			$tpick_invar_wire = $1
			$tpick_invar_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*golvern wire\s+(\d+)/
			$tpick_golvern_wire = $1
			$tpick_golvern_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*vaalin wire\s+(\d+)/
			$tpick_vaalin_wire = $1
			$tpick_vaalin_wire_cost = $2
		elsif line =~ /a thin bar of vaalin/
			break
		end
	end
	move 'out' if checkpaths 'out'
}

if UserVars.tpick.nil?
	if script.vars.any?{ |i| i =~ /setup|return|pickup|drop|help/i }
		nil
	else
		5.times{
			echo "This appears to be your first time using this script. You need to run setup and fill out the settings. Be sure to go through each tab and read the instructions at the bottom of each tab for information on how to fill out each setting. If you don't want to use a setting simply leave it blank. You MUST fill out every setting under the 'Lockpicks' and 'Lockpicks 2' tabs, read the instructions at the bottom of the tab for what to do if you don't use all lockpicks. To run the setup menu do ;tpick setup."
		}
		exit
	end
end

if CharSettings['setup_required_again_for_version_332'].nil?
	if script.vars.any?{ |i| i =~ /setup/i }
		nil
	else
		5.times { 
			echo "The options in the setup menu have changed for Version 332, be sure to do ;tpick setup and check all settings, particularly the new settings and changes to existing settings under the \"Containers\" tab. If you have ,close listed after any container be sure to delete ,close as it is no longer required, instead just list the full name of each container and check out the new open and close settings under the same tab.\n\n"
		}
		exit
	end
end

if CharSettings['setup_required_again_for_version_345'].nil?
	if script.vars.any?{ |i| i !~ /setup/i }
		nil
	else
		5.times { 
			echo "The options in setup menu have changed for version 345. Now if you don't want to use a specific setting simply leave the setting blank, DO NOT use 'nil'. Do ;tpick setup and delete nil or anything else in any setting field for any setting you don't want to use. You have to do ;tpick setup to remove this message.\n\n"
		}
		exit
	end
end

if UserVars.tpick["trap_roll"].length <= 0 || UserVars.tpick["lock_roll"].length <= 0 || UserVars.tpick["vaalin_lock_roll"].length <= 0
	unless script.vars.any?{ |i| i =~ /return|pickup|drop|help/i }
		echo "One or more of the following settings isn't setup properly: Trap Roll, Lock Roll, Vaalin Lock Roll."
		echo "These settings are found in the \"Options\" tab of the setup menu. Run ;tpick setup, click on the \"Options\" tab, read the instructions on the bottom, and please fill in these values."
		exit
	end
end

if script.vars.any?{ |i| i =~ /stat/i }
	stats_check.call
	exit
end

if UserVars.tpick["gnomish_bracer"].length > 0
	bracers_temp = UserVars.tpick["gnomish_bracer"].split(",")
	bracers_name = bracers_temp[0]
	bracers_tier = bracers_temp[1]
	override_bracers = bracers_temp[2]
	gnomish_bracers = bracers_name
end

all_containers_open_to_start = UserVars.tpick["containers_open_to_start"].split(",")
if all_containers_open_to_start
	all_containers_open_to_start.each{ |i|
		i.strip!
		i.rstrip!
		container_to_open = GameObj.inv.find{ |t| t.name == i }
		fput "open ##{container_to_open.id}" if container_to_open
	}
end

if UserVars.tpick["pool_picking_rest_when_fried"].length > 1
	pool_picking_fried_commands = UserVars.tpick["pool_picking_rest_when_fried"].split(":")
	pool_picking_fried_commands[0].strip!
	pool_picking_fried_commands[0].rstrip!
	pool_picking_fried_commands[1].strip!
	pool_picking_fried_commands[1].rstrip!
end

fput "stow right" if checkright
fput "stow left" if checkleft

@all_other_container_options = nil
@all_other_container_options = UserVars.tpick["all_other_containers"].split(",")

if UserVars.tpick["calibratecount"] =~ /auto/i
	calibrate_auto_amount = UserVars.tpick["calibratecount"].split(" ")
	calibrate_auto_amount = calibrate_auto_amount[1].to_i
end

unless script.vars.any?{ |i| i =~ /return|pickup|drop|help/i }
	check_for_lockpicks_etc.call
	$copper_lockpick_id = copper_lock_pick_array.first
	$steel_lockpick_id = steel_lock_pick_array.first
	$gold_lockpick_id = gold_lock_pick_array.first
	$silver_lockpick_id = silver_lock_pick_array.first
	$mithril_lockpick_id = mithril_lock_pick_array.first
	$ora_lockpick_id = ora_lock_pick_array.first
	$glaes_lockpick_id = glaes_lock_pick_array.first
	$laje_lockpick_id = laje_lock_pick_array.first
	$vultite_lockpick_id = vultite_lock_pick_array.first
	$rolaren_lockpick_id = rolaren_lock_pick_array.first
	$veniom_lockpick_id = veniom_lock_pick_array.first
	$invar_lockpick_id = invar_lock_pick_array.first
	$alum_lockpick_id = alum_lock_pick_array.first
	$golvern_lockpick_id = golvern_lock_pick_array.first
	$kelyn_lockpick_id = kelyn_lock_pick_array.first
	$vaalin_lockpick_id = vaalin_lock_pick_array.first
end

@tpick_all_lockpick_id_arrays = [ copper_lock_pick_array, steel_lock_pick_array, gold_lock_pick_array, silver_lock_pick_array, mithril_lock_pick_array, ora_lock_pick_array, glaes_lock_pick_array, laje_lock_pick_array, vultite_lock_pick_array, rolaren_lock_pick_array, veniom_lock_pick_array, invar_lock_pick_array, alum_lock_pick_array, golvern_lock_pick_array, kelyn_lock_pick_array, vaalin_lock_pick_array ]

unless script.vars.any?{ |i| i =~ /return|pickup|drop|help/i }
	(echo "Couldn't find your copper lockpick";sleep 2) if $copper_lockpick_id.nil? && UserVars.tpick["copper"].length > 0
	(echo "Couldn't find your steel lockpick";sleep 2) if $steel_lockpick_id.nil? && UserVars.tpick["steel"].length > 0
	(echo "Couldn't find your gold lockpick";sleep 2) if $gold_lockpick_id.nil? && UserVars.tpick["gold"].length > 0
	(echo "Couldn't find your silver lockpick";sleep 2) if $silver_lockpick_id.nil? && UserVars.tpick["silver"].length > 0
	(echo "Couldn't find your mithril lockpick";sleep 2) if $mithril_lockpick_id.nil? && UserVars.tpick["mithril"].length > 0
	(echo "Couldn't find your ora lockpick";sleep 2) if $ora_lockpick_id.nil? && UserVars.tpick["ora"].length > 0
	(echo "Couldn't find your glaes lockpick";sleep 2) if $glaes_lockpick_id.nil? && UserVars.tpick["glaes"].length > 0
	(echo "Couldn't find your laje lockpick";sleep 2) if $laje_lockpick_id.nil? && UserVars.tpick["laje"].length > 0
	(echo "Couldn't find your vultite lockpick";sleep 2) if $vultite_lockpick_id.nil? && UserVars.tpick["vultite"].length > 0
	(echo "Couldn't find your rolaren lockpick";sleep 2) if $rolaren_lockpick_id.nil? && UserVars.tpick["rolaren"].length > 0
	(echo "Couldn't find your veniom lockpick";sleep 2) if $veniom_lockpick_id.nil? && UserVars.tpick["veniom"].length > 0
	(echo "Couldn't find your invar lockpick";sleep 2) if $invar_lockpick_id.nil? && UserVars.tpick["invar"].length > 0
	(echo "Couldn't find your alum lockpick";sleep 2) if $alum_lockpick_id.nil? && UserVars.tpick["alum"].length > 0
	(echo "Couldn't find your golvern lockpick";sleep 2) if $golvern_lockpick_id.nil? && UserVars.tpick["golvern"].length > 0
	(echo "Couldn't find your kelyn lockpick";sleep 2) if $kelyn_lockpick_id.nil? && UserVars.tpick["kelyn"].length > 0
	(echo "Couldn't find your vaalin lockpick";sleep 2) if $vaalin_lockpick_id.nil? && UserVars.tpick["vaalin"].length > 0
	(echo "Couldn't find your scale trap weapon";sleep 2) if $scale_trap_weapon_id.nil? && UserVars.tpick["scale_trap_weapon"].length > 0
end

if script.vars.any?{ |i| i =~ /buy/i }
	check_locksmiths_container.call
	wait_until { putty_remaining }
	wait_until { cotton_remaining }
	start_script "sorter" if start_sorter
	if putty_remaining >= 100 && cotton_remaining >= 100
		echo "You already have 100 each of putty and cotton balls."
		exit
	else
		if Wounds.lhand >= 3 || Wounds.rhand >= 3 || Wounds.larm >= 3 || Wounds.rarm >= 3 || Scars.lhand >= 3 || Scars.rhand >= 3 || Scars.larm >= 3 || Scars.rarm >= 3 
			echo "Your wounds are too great to do this task. You can't have a missing hand or arm to do this."
			exit
		else
			tpick_put_stuff_away
			fill_up_locksmith_container.call
		end
	end
	exit
end

repair_stuff_and_stuff = proc{
	result = dothistimeout "look ##{current_pick_to_check}", 1, /The.*appears to be broken\.|You see nothing unusual\.|I could not find what you were referring to\.|appears to be somewhat damaged/
	if result =~ /The.*appears to be broken\./
		if $tpick_vaalin_wire == nil
			get_wire_order_numbers.call
		end
		if number == 1
			lockpick_type = "vaalin"
			current_wire = $tpick_vaalin_wire
			current_wire_cost = $tpick_vaalin_wire_cost
		elsif number == 2
			lockpick_type = "kelyn"
			current_wire = $tpick_kelyn_wire
			current_wire_cost = $tpick_kelyn_wire_cost
		elsif number == 3
			lockpick_type = "golvern"
			current_wire = $tpick_golvern_wire
			current_wire_cost = $tpick_golvern_wire_cost
		elsif number == 4
			lockpick_type = "alum"
			current_wire = $tpick_alum_wire
			current_wire_cost = $tpick_alum_wire_cost
		elsif number == 5
			lockpick_type = "invar"
			current_wire = $tpick_invar_wire
			current_wire_cost = $tpick_invar_wire_cost
		elsif number == 6
			lockpick_type = "veniom"
			current_wire = $tpick_veniom_wire
			current_wire_cost = $tpick_veniom_wire_cost
		elsif number == 7
			lockpick_type = "rolaren"
			current_wire = $tpick_rolaren_wire
			current_wire_cost = $tpick_rolaren_wire_cost
		elsif number == 8
			lockpick_type = "vultite"
			current_wire = $tpick_vultite_wire
			current_wire_cost = $tpick_vultite_wire_cost
		elsif number == 9
			lockpick_type = "laje"
			current_wire = $tpick_laje_wire
			current_wire_cost = $tpick_laje_wire_cost
		elsif number == 10
			lockpick_type = "ora"
			current_wire = $tpick_ora_wire 
			current_wire_cost = $tpick_ora_wire_cost
		elsif number == 11
			lockpick_type = "mithril"
			current_wire = $tpick_mithril_wire 
			current_wire_cost = $tpick_mithril_wire_cost
		elsif number == 12
			lockpick_type = "silver"
			current_wire = $tpick_silver_wire
			current_wire_cost = $tpick_silver_wire_cost
		elsif number == 13
			lockpick_type = "gold"
			current_wire = $tpick_gold_wire
			current_wire_cost = $tpick_gold_wire_cost
		elsif number == 14
			lockpick_type = "steel"
			current_wire = $tpick_steel_wire
			current_wire_cost = $tpick_steel_wire_cost
		elsif number > 14
			lockpick_type = "copper"
			current_wire = $tpick_copper_wire
			current_wire_cost = $tpick_copper_wire_cost
		end
		fput "get ##{current_pick_to_check}"
		move 'out' if checkpaths 'out'
		start_script 'go2', [ 'bank', '--disable-confirm' ]
		wait_while{ running?('go2') }
		multifput "depo all", "withdraw #{current_wire_cost} silvers"
		target_room = Room.current.find_nearest(toolbenches_room_number)
		start_script 'go2', [ target_room.to_s ]
		wait_while{ running?('go2') }
		move 'go toolbench'
		waitrt?
		fput "order #{current_wire}"
		fput "buy"
		waitrt?
		result = dothistimeout "lmas repair ##{current_pick_to_check}", 2, /cooling rapidly to form a tight bond|but the broken tip refuses to work free/
		if result =~ /cooling rapidly to form a tight bond/
			waitrt?
			fput "put ##{current_pick_to_check} in ##{@tpick_lockpick_container.id}"
		elsif result =~ /but the broken tip refuses to work free/
			echo "This lockpick cannot be repaired."
			exit
		elsif result.nil?
			echo "Didn't recognize any game lines."
			exit
		end
	elsif result =~ /You see nothing unusual\.|I could not find what you were referring to\.|appears to be somewhat damaged/
		nil
	end
}

if script.vars.any?{ |i| i =~ /repair/i } && Char.prof =~ /Rogue/
	tpick_put_stuff_away
	number = 1
	vaalin_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	kelyn_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	golvern_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	alum_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	invar_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	veniom_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	rolaren_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	vultite_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	laje_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	ora_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	mithril_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	silver_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	gold_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	steel_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	copper_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	move 'out' if checkroom =~ /workbench/i
	exit
elsif script.vars.any?{ |i| i =~ /repair/i } && Char.prof !~ /Rogue/
	echo "Only rogues can repair lockpicks."
	exit
end



if @tpick_locksmiths_container
	check_locksmiths_container.call
	wait_until { putty_remaining }
	wait_until { cotton_remaining }
	wait_until { vials_remaining }
	echo "Putty remaining: #{putty_remaining}"
	echo "Cotton balls remaining: #{cotton_remaining}"
	echo "Vials of acid remaining: #{vials_remaining}"
	start_script "sorter" if start_sorter
end

if Char.prof =~ /Rogue/
	can_use_calipers = true
	if (UserVars.tpick["trick"] == "spin" or UserVars.tpick["trick"] == "twist" or UserVars.tpick["trick"] == "turn" or UserVars.tpick["trick"] == "twirl" or UserVars.tpick["trick"] == "toss" or UserVars.tpick["trick"] == "bend" or UserVars.tpick["trick"] == "flip")
		do_trick = "lmas ptrick #{UserVars.tpick["trick"]}"	
	elsif UserVars.tpick["trick"] == "pick"
		do_trick = "pick"
	elsif UserVars.tpick["trick"] == "random"
		nil
	else
		(echo "Wrong value for TRICK in settings. Type ;tpick setup and enter spin, twist, turn, twirl, toss, bend, flip, pick, or random for the TRICK setting.";exit)
	end
	if UserVars.tpick["use_lmaster_focus"] =~ /yes/i && $tpick_lmaster_focus_boost.nil?
		successful_action = nil
		until successful_action
			waitrt?
			result = dothistimeout "gld", 2, /You are a Master of Lock Mastery\.|You have (\d+) ranks? in the Lock Mastery skill\.|Click GLD MENU for additional commands\.|You have no guild affiliation\./i
			if result =~ /You are a Master of Lock Mastery\./
				$tpick_lmaster_focus_boost = (2 * 63 + (dex_bonus / 2))
				successful_action = true
			elsif result =~ /You have (\d+) ranks? in the Lock Mastery skill\./
				$tpick_lmaster_focus_boost = (2 * $1.to_i + (dex_bonus / 2))
				successful_action = true
			elsif result =~ /Click GLD MENU for additional commands\.|You have no guild affiliation\./
				successful_action = true
				$tpick_lmaster_focus_boost = 0
			end
		end
	end
	if UserVars.tpick["use_lmaster_focus"] =~ /yes/i
		disarm_lore = $tpick_lmaster_focus_boost
		pick_lore = $tpick_lmaster_focus_boost
	end
else
	can_use_calipers = nil
	UserVars.tpick["calibrate"] = "no"
	do_trick = "pick"
end

tpick_put_stuff_away
calibrate_count = 0

if UserVars.tpick["max_lock"] =~ /\d+/ && UserVars.tpick["max_lock"] =~ /\-/
	temp_max_lock = UserVars.tpick["max_lock"].split("-")
	max_lock_attempt = temp_max_lock[1].to_i
	echo "Max lock: #{max_lock_attempt}"
	max_lock_attempt_compared_to_max_skill = true
elsif UserVars.tpick["max_lock"] =~ /\d+/
	max_lock_attempt = UserVars.tpick["max_lock"].to_i
end

if Spell[403].known?
	use_403_for_lock_difficulty = $1.to_i if UserVars.tpick["always_use_403"] =~ /(\d+)/
	use_spell_403 = true if UserVars.tpick["always_use_403"] =~ /yes/
	$tpick_use_403_cancel = "cancel" if UserVars.tpick["always_use_403"] =~ /cancel/
end

if Spell[404].known?
	use_404_for_trap_difficulty = $1.to_i if UserVars.tpick["always_use_404"] =~ /(\d+)/
	use_spell_404 = true if UserVars.tpick["always_use_404"] =~ /yes/
	$tpick_use_404_cancel = "cancel" if UserVars.tpick["always_use_404"] =~ /cancel/
end

use_unlock_407_settings = UserVars.tpick["always_use_407"].split(",")
use_unlock_407_settings[0].strip!
use_unlock_407_settings[0].rstrip!
use_unlock_407_settings[1].strip!
use_unlock_407_settings[1].rstrip!

use_spell_205 = true if Spell[205].known? && UserVars.tpick["always_use_205"] == "yes"
use_spell_402 = true if Spell[402].known? && UserVars.tpick["always_use_402"] == "yes"
use_spell_1035 = true if Spell[1035].known? && UserVars.tpick["always_use_1035"] == "yes"
use_spell_613 = true if Spell[613].known? && UserVars.tpick["always_use_613"] == "yes"
use_spell_704 = true if Spell[704].known? && UserVars.tpick["always_use_704"] == "yes"
use_spell_1006 = true if Spell[1006].known? && UserVars.tpick["always_use_1006"] == "yes"

if UserVars.tpick["percent_mana_to_keep"] =~ /\d+/
	@percentage_of_mana_to_keep = UserVars.tpick["percent_mana_to_keep"].to_i
else
	@percentage_of_mana_to_keep = -100
end

max_roll_attempt_before_moving_to_new_pick = UserVars.tpick["max_lock_roll"].to_i if UserVars.tpick["max_lock_roll"].length > 0 && UserVars.tpick["max_lock_roll"] =~ /\d+/

minimum_tip_wanted = UserVars.tpick["minimum_tip_wanted"].to_i if UserVars.tpick["minimum_tip_wanted"].length > 0
max_critter_level = UserVars.tpick["max_critter_level"].to_i if UserVars.tpick["max_critter_level"].length > 0

temp_minimum_tip_stuff = UserVars.tpick["minimum_tip_wanted"].split(",")
minimum_tip_start = temp_minimum_tip_stuff[0].to_i
minimum_tip_subtract = temp_minimum_tip_stuff[1].to_i
minimum_tip_floor = temp_minimum_tip_stuff[2].to_i
minimum_tip_current = minimum_tip_start if minimum_tip_start

echo "Max level wanted: #{max_critter_level}" if max_critter_level != 1000

always_use_vaalin = true if UserVars.tpick["calibrate"] =~ /never/i && start_with_copper.nil?

if (always_use_vaalin) && (start_with_copper)
	start_with_copper = nil
end

if (Char.prof !~ /Rogue|Bard/) && (start_with_copper == nil)
	always_use_vaalin = true
end

if UserVars.tpick["picks_to_use_based_on_critter_level"].length > 0 && always_use_vaalin
	picks_to_use_based_on_critter_level = UserVars.tpick["picks_to_use_based_on_critter_level"].split(",")
	picks_information_text = "Your picks to use based on critter level settings: "
	number = 0
	picks_to_use_based_on_critter_level.each{ |i|
		temp_picks_critter_level = i.split(" ")
		if number == 0
			picks_information_text += "Levels #{number}-#{temp_picks_critter_level[0]}: #{temp_picks_critter_level[1]}. "
		else
			picks_information_text += "Levels #{number + 1}-#{temp_picks_critter_level[0]}: #{temp_picks_critter_level[1]}. "
		end
		number = temp_picks_critter_level[0].to_i
	}
	picks_information_text += "All higher levels: vaalin"
end

display_the_help_menu = true if script.vars[1] =~ /help/i
open_plinites = true if script.vars.any?{ |i| i =~ /plin/i }
bash_open_boxes = true if script.vars.any?{ |i| i =~ /bash/i }
disarm_only = true if script.vars.any?{ |i| i =~ /disarm/i }
relock_boxes = true if script.vars.any?{ |i| i =~ /relock/i }
drop_off_boxes = true if script.vars.any?{ |i| i =~ /drop/i }
pick_up_boxes = true if script.vars.any?{ |i| i =~ /return|pickup/i }
tip_is_a_percent = true if script.vars.any?{ |i| i =~ /percent|\%/i }
start_with_copper = true if script.vars.any?{ |i| i.downcase == "c" }
always_use_vaalin = true if script.vars.any?{ |i| i.downcase == "v" }
always_use_wedge = true if script.vars.any?{ |i| i =~ /wedge/i }
ground_loot = true if script.vars.any?{ |i| i =~ /loot/i }
popping = true if script.vars.any?{ |i| i =~ /pop/i }
script.vars.each{ |i| tip_being_offered = i.to_i if i =~ /\d+/ }
solo_or_other = "ground" if script.vars.any?{ |i| i =~ /ground/i }
solo_or_other = "other" if script.vars.any?{ |i| i =~ /other/i }
solo_or_other = "worker" if script.vars.any?{ |i| i =~ /worker/i }
solo_or_other = "solo" if script.vars.any?{ |i| i =~ /solo/i }
solo_or_other = true if script.vars.any?{ |i| i =~ /return|pickup|drop/i }
exit_when_waiting = true if script.vars.any?{ |i| i =~ /exit/i }

if ground_loot
	wealth_before.call
	wait_until { silver_before }
end

if bash_open_boxes && Char.prof != "Warrior"
	echo "Only warriors can bash boxes."
	exit
end

if open_plinites
	if disarm_only
		echo "Disarm feature cannot be used when opening plinites."
		exit
	elsif relock_boxes
		echo "Relock feature cannot be used when opening plinites."
		exit
	elsif bash_open_boxes
		echo "Bash feature cannot be used when opening plinites."
		exit
	elsif popping
		echo "Popping feature cannot be used when opening plinites."
		exit
	end
end

if relock_boxes && bash_open_boxes
	echo "\"relock\" and \"bash\" cannot both be used together."
	exit
end


if popping && !Spell[416].known?
	echo "Popping feature requires the knowledge of Piercing Gaze (416)."
	exit
end

Spell[205].cast if use_spell_205

all_lockpick_settings_to_check = [ UserVars.tpick["copper"], UserVars.tpick["steel"], UserVars.tpick["gold"], UserVars.tpick["silver"], UserVars.tpick["mithril"], UserVars.tpick["ora"], UserVars.tpick["glaes"], UserVars.tpick["laje"], UserVars.tpick["vultite"], UserVars.tpick["rolaren"], UserVars.tpick["veniom"], UserVars.tpick["invar"], UserVars.tpick["alum"], UserVars.tpick["golvern"], UserVars.tpick["kelyn"], UserVars.tpick["vaalin"] ]

if all_lockpick_settings_to_check.find{ |i| i.length == 0 }
	unless script.vars.any?{ |i| i =~ /return|pickup|drop|help/i }
		respond
		5.times{ _respond "#{monsterbold_start}#################################################################################{monsterbold_end}\n" }
		respond _respond "#{monsterbold_start}TPICK#{monsterbold_end}\n"
		_respond "You must fill out EVERY setting under the 'Lockpicks' and 'Lockpicks 2' tabs."
		_respond "If you don't use a specific lockpick then enter the name of your next highest lockpick that you do use in that setting."
		_respond "For example: if you don't use steel or gold lockpicks then enter the name of your Silver Lockpick in the Steel Lockpicking setting, Gold Lockpick setting, and Silver Lockpick setting."
		5.times{ _respond "#{monsterbold_start}#################################################################################{monsterbold_end}\n" }
		respond
		exit
	end
end

solo_or_other = UserVars.tpick["default_mode"] if UserVars.tpick["default_mode"].length > 0 && solo_or_other.nil?
reset_math.call if script.vars.any?{ |i| i =~ /reset/i }

if UserVars.tpick["use_lmaster_focus"] =~ /yes/i && $use_effects_for_spell_data.nil? && Spell[2001].nil?
	5.times{ _respond "#{monsterbold_start}#################################################################################{monsterbold_end}\n" }
	_respond "You have chosen to use LMASTER FOCUS but your Lich isn't set up to make use of this ability. You have three options:"
	_respond "1) You can update Lich to the latest version."
	_respond "2) You can forgo using LMASTER FOCUS and remove the option from the setup menu."
	_respond "3) You can edit your spell-list.xml file found in your \"data\" folder within your Lich folder. You will need to add the following information:"
    _respond "<spell availability='self-cast' name='Focused' number='2001' type='utility'>"
    _respond "   <duration span='refreshable' max='2'>2</duration>"
    _respond "   <message type='start'>You focus intently on your picking and disarm skill\.</message>"
    _respond "   <message type='end'>You no longer appear focused\.</message>"
    _respond "</spell>"
	5.times{ _respond "#{monsterbold_start}#################################################################################{monsterbold_end}\n" }
	exit
end

if display_the_help_menu
	help_menu_display.call
elsif drop_off_boxes || pick_up_boxes || solo_or_other
	start_up_procedure.call
else
	display_no_mode_specified_message.call
end