=begin

	This script will disarm, measure, pick (and will use the appropriate lockpick based on your skill and lock difficulty) and empty your boxes into your container. This script can also be used to automatically accept, disarm, 			measure, pick and hand back other people's boxes.
	
	Script will attempt to read lock difficulty for Rogues using calipers and for Bards using loresinging. If you are a Rogue or Bard and would prefer to skip all that and always use a vaalin lock pick instead then use the v variables listed below.

	Script will attempt to use vials bundled into your locksmith's pouch first for plated boxes, if no vials are bundled into your locksmith's pouch it will attempt to use wedges found in your wedge sack.

	Usage:
	;tpick can now drop off boxes at the pool and pick them up!
	
	To drop off boxes at the pool to be picked do for example ";tpick drop 100" to tip 100 silvers per box, do ";tpick drop 10 percent" or ";tpick drop 10%" if you want to tip 10% per box
	
	To pick up boxes that have been picked do ";tpick pickup" or ";tpick return"
	
	;tpick <setup> must be done first before you can use this script. Be sure to fill out all of the settings.

	Use the following command line variables for how you want the script to run:

	other - will accept boxes handed to you, pick them, then hand them back to the person who handed you the box.
	ground - will pick all boxes on the ground but will not take loot out of them. Useful if you're picking boxes on the ground for someone else.
	worker - will get boxes from the worker and pick them.
	Not using "other", "ground", or "worker" will pick all boxes inside of your open containers and inside your disk.

	v - will skip measuring locks and always use a vaalin lockpick + 403 to pick all boxes.
	c - skips measuring and always starts with the lockpick in your copper lockpick setting then moves up list of lockpicks when needed.
	loot - to pick all boxes on the ground and take the loot out of each box.
	wedge - to always use a wedge to open boxes. In the case of scale traps the script will still attempt to pick the box first with a lockpick.
	bash - to bash open boxes
	relock - will relock the box after it has been opened and looted. Only works if you're picking your own boxes or you use both the ground and loot command line variables.
	pop - this will attempt to open boxes using 407 and 408 only. Does not work with the "other" variable but does work with "ground" picking. This option requires the knowledge of Piercing Gaze (416).
	disarm - this will ONLY check for and disarm traps, it will not open the boxes. Useful if you want to disarm traps for a warrior to bash them for guild reps. This feature only works with the ground variable.
	plin(ite) - will open all plinites in your open containers.

	The above commands can be used in any combination. Some examples:
	
	;tpick other v - will pick other people's boxes and always use a vaalin lockpick.
	;tpick loot ground v - will pick all boxes on the ground, will loot each box after picking them, and will always use a vaalin lockpick.
	;tpick - will pick all boxes in your open containers.


	The following commands cannot be used with the above commands:

	buy - script will fill up your locksmith's container with cotton balls and putty by buying them at the locksmith's shop. Script will exit once done.
	repair - script will repair any lockpicks that need repairing. Must be a rogue with the lmas skill to repair lockpicks.
	Currently repair only works in Icemule, Landing, Sol Haven and Illistim.


	Non Rogues and bards do not need to use the "v" command line, they will always pick boxes with a vaalin lockpick and won't use calipers.
	
	Changelog:
	Version 325: Hopefully fixed bug which crashed the script when character only gathers some coins from a box instead of gathering all at once.
	Version 326: Fixed bug with "picks to use based on critter level" setting that wasn't using a vaalin lockpick if the critter level was higher than the highest level you put in the setting.
	Version 326: Fixed some bugs with script sometimes hanging.
	Version 326: Fixed bug with script not using 404 when disarming plated boxes.
	Version 327: Changes to comma nonsense. This didn't actually fix or change anything, was just some code that was bugging me so I decided to change it.
	
	Author: Tgo01
	Version: 327

=end

lich_up_to_date = nil
version = LICH_VERSION.split(".")
if version[0].to_i > 4
	lich_up_to_date = true
elsif version[1].to_i > 6
	lich_up_to_date = true
elsif version[2].to_i > 53
	lich_up_to_date = true
end

if Gem.loaded_specs["gtk3"]
	gtk_version = 3
else
	gtk_version = 2
end

CharSettings['scarab'] = 0 unless CharSettings['scarab']
CharSettings['needle'] = 0 unless CharSettings['needle']
CharSettings['jaws'] = 0 unless CharSettings['jaws']
CharSettings['sphere'] = 0 unless CharSettings['sphere']
CharSettings['crystal'] = 0 unless CharSettings['crystal']
CharSettings['scales'] = 0 unless CharSettings['scales']
CharSettings['sulphur'] = 0 unless CharSettings['sulphur']
CharSettings['cloud'] = 0 unless CharSettings['cloud']
CharSettings['acid_vial'] = 0 unless CharSettings['acid_vial']
CharSettings['springs'] = 0 unless CharSettings['springs']
CharSettings['fire_vial'] = 0 unless CharSettings['fire_vial']
CharSettings['spores'] = 0 unless CharSettings['spores']
CharSettings['plate'] = 0 unless CharSettings['plate']
CharSettings['glyph'] = 0 unless CharSettings['glyph']
CharSettings['rods'] = 0 unless CharSettings['rods']
CharSettings['boomer'] = 0 unless CharSettings['boomer']
CharSettings['no_trap'] = 0 unless CharSettings['no_trap']
CharSettings['total_trap_count'] = 0.0 unless CharSettings['total_trap_count']
temp_copper_lockpicks_array = UserVars.tpick["copper"].split(",")
temp_steel_lockpicks_array = UserVars.tpick["steel"].split(",")
temp_gold_lockpicks_array = UserVars.tpick["gold"].split(",")
temp_silver_lockpicks_array = UserVars.tpick["silver"].split(",")
temp_mithril_lockpicks_array = UserVars.tpick["mithril"].split(",")
temp_ora_lockpicks_array = UserVars.tpick["ora"].split(",")
temp_glaes_lockpicks_array = UserVars.tpick["glaes"].split(",")
temp_laje_lockpicks_array = UserVars.tpick["laje"].split(",")
temp_vultite_lockpicks_array = UserVars.tpick["vultite"].split(",")
temp_rolaren_lockpicks_array = UserVars.tpick["rolaren"].split(",")
temp_veniom_lockpicks_array = UserVars.tpick["veniom"].split(",")
temp_invar_lockpicks_array = UserVars.tpick["invar"].split(",")
temp_alum_lockpicks_array = UserVars.tpick["alum"].split(",")
temp_golvern_lockpicks_array = UserVars.tpick["golvern"].split(",")
temp_kelyn_lockpicks_array = UserVars.tpick["kelyn"].split(",")
temp_vaalin_lockpicks_array = UserVars.tpick["vaalin"].split(",")
all_scarab_ids = Array.new
max_lock_attempt_compared_to_max_skill = nil
max_lock_attempt = 10000
same_scarab_found = nil
box_was_not_locked = nil
bash_the_box_open = nil
bash_open_boxes = nil
temp_math_number = nil
check_for_lockpicks_etc = nil
quick_maths = nil
tip_is_a_percent = nil
tip_being_offered = nil
offered_tip_amount = nil
minimum_tip_wanted = 0
detect_plinite = nil
temp_id = nil
temp_name = nil
stow_calipers = nil
stow_wedge = nil
critter_level = nil
current_item = nil
picking_up = nil
already_checked_for_disk = nil
total_number_of_boxes = 0
lock = 0
coins_from_boxes_comma_nonsense = nil
gather_stuff = nil
finished_it = nil
loresong_stuff = nil
$tpick_use_403_cancel = nil
$tpick_use_404_cancel = nil
temp_403_variable = nil
temp_404_variable = nil
current_room = nil
scarab_name = nil
total_silvers_from_box = nil
scarab_object = nil
encumbrance_check = nil
starting_room_number = nil
number_of_times_to_measure = 0
measure_detection = nil
max_critter_level = 1000
open_or_close_containers = Array.new
buy_locksmith_pouch = nil
cast_704_at_box = nil
detect_plinite_result = nil
box_is_enruned_or_mithril = nil
CharSettings['total_boxes_picked'] = 0 unless CharSettings['total_boxes_picked']
CharSettings['total_time_spent_picking_boxes'] = 0 unless CharSettings['total_time_spent_picking_boxes']
average_picking_time = 0
start_time = 0
roll_amount_check = nil
use_404_for_trap_difficulty = nil
before_recommended_pick = nil
i_need_403 = nil
stow_both = nil
ask_worker = nil
random_trick = nil
start_values_nilled = nil
total_picking_time = nil
count_boxes_in_disk = nil
total_boxes_count = nil
update_math_information = nil
box_counts_for_math = true
total_boxes_number = nil
reset_math = nil
total_boxes_picked_math = nil
temp_picks_critter_level = nil
bracers_temp = nil
bracers_name = nil
bracers_tier = nil
nextpick2 = nil
gem_container_close = nil
found_true_lock_difficulty = nil
lockpick_container = nil
lockpick_container_close = nil
broken_lockpick_container = nil
lock_pick_information = nil
broken_lockpick_container_close = nil
always_use_wedge = nil
wedge_container = nil
wedge_container_close = nil
calipers_container = nil
calipers_container_close = nil
scale_weapon_container = nil
scale_weapon_container_close = nil
locksmiths_container = nil
locksmiths_container_close = nil
open_all_containers = nil
close_all_containers = nil
next_task = nil
roll_amount = nil
number_of_manual_trap_checks_remaining = nil
second_trap_check = nil
check_for_command = nil
start_worker = nil
start_worker2 = nil
gem = nil
reagent = nil
herb = nil
food = nil
uncommon = nil
jewelry = nil
junk = nil
lockpick = nil
magic = nil
scroll = nil
wand = nil
armor = nil
weapon = nil
clothing = nil
other = nil
stow_in_disk = nil
check_for_boxes = nil
remaining_416_casts = nil
stuff_to_do = nil
where_to_stow_box = nil
check_locksmiths_container = nil
putty_remaining = nil
cotton_remaining = nil
vials_remaining = nil
fill_up_locksmith_container = nil
order_number = nil
trash_container = nil
current_vial = nil
use_spell_205 = nil
use_spell_402 = nil
use_spell_403 = nil
use_spell_404 = nil
use_spell_506 = nil
use_spell_613 = nil
use_spell_704 = nil
use_spell_1006 = nil
pop_start = nil
recommended_pick = nil
recommended_pick_modifier = nil
needed_pick_id = nil
before_needed_pick = nil
check_hands_status = nil
current_trap_type = nil
box_is_disarmed = nil
box_is_open = nil
check_for_trap = nil
pop_open_box = nil
disarm_trap = nil
cast_402 = nil
cast_403 = nil
cast_404 = nil
use_403_for_lock_difficulty = nil
can_use_calipers = nil
pop_boxes_begin = nil
fused_lock_disarm = nil
starting_room = Room.current.id
override_bracers = nil
$scale_trap_weapon_id = nil
finished_getting_coins = nil
check_all_ground_boxes_again = true
picks_to_use_based_on_critter_level = nil

$tpick_list_of_box_ids = Array.new
$tpick_copper_wire = nil unless $tpick_copper_wire
$tpick_copper_wire_cost = nil unless $tpick_copper_wire_cost
$tpick_brass_wire = nil unless $tpick_brass_wire
$tpick_brass_wire_cost = nil unless $tpick_brass_wire_cost
$tpick_steel_wire = nil unless $tpick_steel_wire
$tpick_steel_wire_cost = nil unless $tpick_steel_wire_cost
$tpick_gold_wire = nil unless $tpick_gold_wire
$tpick_gold_wire_cost = nil unless $tpick_gold_wire_cost
$tpick_silver_wire = nil unless $tpick_silver_wire
$tpick_silver_wire_cost = nil unless $tpick_silver_wire_cost
$tpick_ora_wire = nil unless $tpick_ora_wire
$tpick_ora_wire_cost = nil unless $tpick_ora_wire_cost
$tpick_mithril_wire = nil unless $tpick_mithril_wire
$tpick_mithril_wire_cost = nil unless $tpick_mithril_wire_cost
$tpick_laje_wire = nil unless $tpick_laje_wire
$tpick_laje_wire_cost = nil unless $tpick_laje_wire_cost
$tpick_alum_wire = nil unless $tpick_alum_wire
$tpick_alum_wire_cost = nil unless $tpick_alum_wire_cost
$tpick_vultite_wire = nil unless $tpick_vultite_wire
$tpick_vultite_wire_cost = nil unless $tpick_vultite_wire_cost
$tpick_rolaren_wire = nil unless $tpick_rolaren_wire
$tpick_rolaren_wire_cost = nil unless $tpick_rolaren_wire_cost
$tpick_veniom_wire = nil unless $tpick_veniom_wire
$tpick_veniom_wire_cost = nil unless $tpick_veniom_wire_cost
$tpick_kelyn_wire = nil unless $tpick_kelyn_wire
$tpick_kelyn_wire_cost = nil unless $tpick_kelyn_wire_cost
$tpick_invar_wire = nil unless $tpick_invar_wire
$tpick_invar_wire_cost = nil unless $tpick_invar_wire_cost
$tpick_golvern_wire = nil unless $tpick_golvern_wire
$tpick_golvern_wire_cost = nil unless $tpick_golvern_wire_cost
$tpick_vaalin_wire = nil unless $tpick_vaalin_wire
$tpick_vaalin_wire_cost = nil unless $tpick_vaalin_wire_cost
get_wire_order_numbers = nil
current_pick_to_check = nil
lockpick_type = nil
current_wire = nil
find_gnomish_lockpick = nil
current_wire_cost = nil
popping = nil
gem_container = nil
start_sorter = nil
toolbenches_room_number = [ '17978', '16574', '17960', '17881', '17387', '21187' ]
number = nil
contents = nil
container = nil
scale_trap_found = nil
gnomish_bracers = nil
found_pick = nil
spin_number = 0
disarm_only = nil
gnomish_bracers_trap_check = nil
gnomish_bracers_trap_check_result = nil
stats_check = nil
$copper_lockpick_id = nil
$steel_lockpick_id = nil
$gold_lockpick_id = nil
$silver_lockpick_id = nil
$mithril_lockpick_id = nil
$ora_lockpick_id = nil
$glaes_lockpick_id = nil
$laje_lockpick_id = nil
$vultite_lockpick_id = nil
$rolaren_lockpick_id = nil
$veniom_lockpick_id = nil
$invar_lockpick_id = nil
$alum_lockpick_id = nil
$golvern_lockpick_id = nil
$kelyn_lockpick_id = nil
$vaalin_lockpick_id = nil
copper_lock_pick_array = Array.new
steel_lock_pick_array = Array.new
gold_lock_pick_array = Array.new
silver_lock_pick_array = Array.new
mithril_lock_pick_array = Array.new
ora_lock_pick_array = Array.new
glaes_lock_pick_array = Array.new
laje_lock_pick_array = Array.new
vultite_lock_pick_array = Array.new
rolaren_lock_pick_array = Array.new
veniom_lock_pick_array = Array.new
invar_lock_pick_array = Array.new
alum_lock_pick_array = Array.new
golvern_lock_pick_array = Array.new
kelyn_lock_pick_array = Array.new
vaalin_lock_pick_array = Array.new
CharSettings['setup_has_been_run'] = nil unless CharSettings['setup_has_been_run']
CharSettings['setup_has_been_run_again'] = nil unless CharSettings['setup_has_been_run_again']
start_with_copper = nil
all_stats_to_check = nil
all_stats_trap_names = nil
math = nil
open_plinites = nil
start_plinites = nil
all_variables_to_check = [ script.vars[1], script.vars[2], script.vars[3], script.vars[4], script.vars[5], script.vars[6], script.vars[7], script.vars[8], script.vars[9], script.vars[10] ]
open_current_plinite = nil
plinite_already_open = nil
cannot_determine_plinite_difficulty = nil
critter_name = nil

stats_check = proc{
	if CharSettings['total_trap_count'] == 0.0
		echo "No trap information has been recorded yet. Get to checking boxes for traps!"
	else
		number = 0
		all_stats_to_check = [ CharSettings['scarab'], CharSettings['needle'], CharSettings['jaws'], CharSettings['sphere'], CharSettings['crystal'], CharSettings['scales'], CharSettings['sulphur'], CharSettings['cloud'], CharSettings['acid_vial'], CharSettings['springs'], CharSettings['fire_vial'], CharSettings['spores'], CharSettings['plate'], CharSettings['glyph'], CharSettings['rods'], CharSettings['boomer'], CharSettings['no_trap'] ]
		all_stats_trap_names = [ "Scarab         ", "Needle         ", "Jaws           ", "Sphere         ", "Crystal        ", "Scales         ", "Sulphur        ", "Cloud          ", "Acid Vial      ", "Springs        ", "Fire Vial      ", "Spores         ", "Plate          ", "Glyph          ", "Rods           ", "Boomer         ", "No Trap        " ]
		respond "##############################"
		respond "##############################"
		respond "All trap information"
		all_stats_to_check.each { |i|
			math = (((i / CharSettings['total_trap_count'])) * (100)).round(2)
			respond "#{all_stats_trap_names.at(number)} #{i} (#{math}%)"
			number += 1
		}
		respond "Total Trap      #{CharSettings['total_trap_count']}"
		respond "##############################"
		respond "##############################"
	end
		
}

reset_math = proc{
	CharSettings['total_boxes_picked'] = 0
	CharSettings['total_time_spent_picking_boxes'] = 0
}

$tpick_boxes_checked = nil
strongbox_count = 0
box_count = 0
chest_count = 0
trunk_count = 0
coffer_count = 0

gem_number = Array.new
reagent_number = Array.new
herb_number = Array.new
food_number = Array.new
uncommon_number = Array.new
jewelry_number = Array.new
junk_number = Array.new
lockpick_number = Array.new
magic_number = Array.new
scroll_number = Array.new
wand_number = Array.new
armor_number = Array.new
weapon_number = Array.new
clothing_number = Array.new
other_number = Array.new
all_box_ids_already_picked = Array.new

dex_bonus = nil

#The following is just for informational purposes, no need to change anything.

#Pick names and mod values:
#Copper		1.00
#Steel		1.10
#Gold		1.20
#Silver		1.30
#Mithril	1.45
#Ora		1.55
#Glaes		1.60
#Laje		1.75
#Vultite	1.80
#Rolaren	1.90
#Veniom		2.20
#Invar		2.25
#Alum		2.30
#Golvern	2.35
#Kelyn		2.40
#Vaalin		2.50

#Lock names and difficulty
#Primitive					35
#Rudimentary				75
#Extremely Easy				115
#Very Easy					155
#Easy						195
#Very Basic					235
#Fairly Easy				275
#Simple						315
#Fairly Simple				355
#Fairly Plain				395
#Moderately Well-Crafted	435
#Well-Crafted				475
#Tricky						515
#Somewhat Difficult			555
#Moderately Difficult		595
#Very Well-Crafted			635
#Difficult					675
#Extremely Well-Crafted		715
#Very Difficult				755
#Fairly Complicated			795
#Intricate					835
#Amazingly Well-Crafted		875
#Very Complex				915
#Impressively Complicated	955
#Amazingly Intricate		995
#Extremely Difficult		1035
#Extremely Complex			1075
#Masterfully Well-Crafted	1115
#Amazingly Complicated		1155
#Astoundingly Complex		1195
#Incredibly Intricate		1235
#Absurdly Well-Crafted		1275
#Exceedingly Complex		1315
#Absurdly Difficult			1355
#Unbelievably Complicated 	1395
#Masterfully Intricate		1435
#Absurdly Complex			1475
#Impossibly Complex			1515

worker = nil
if Room.current.id == 28937
	worker = "worker"
else
	Room.current.tags.find{ |i| i =~ /meta:boxpool:npc:(.*)/;worker = $1}
end
worker = GameObj.npcs.find {|i| worker =~ /#{i}/}

table = nil
if Room.current.id == 28937
	table = "table"
else
	Room.current.tags.find{ |i| i =~ /meta:boxpool:table:(.*)/;table = $1}
end
if GameObj.loot.find {|i| table =~ /#{i}/}
	table = GameObj.loot.find {|i| table =~ /#{i}/}
else
	table = GameObj.room_desc.find {|i| table =~ /#{i}/}
end

pick_mod = [ 1.00, 1.10, 1.20, 1.30, 1.45, 1.55, 1.60, 1.75, 1.80, 1.90, 2.20, 2.25, 2.30, 2.35, 2.40, 2.50 ]
lock_difficulty = [ 35, 75, 115, 155, 195, 235, 275, 315, 355, 395, 435, 475, 515, 555, 595, 635, 675, 715, 755, 795, 835, 875, 915, 955, 995, 1035, 1075, 1115, 1155, 1195, 1235, 1275, 1315, 1355, 1395, 1435, 1475, 1515 ]
if lich_up_to_date
	dex_bonus = Stats.enhanced_dex[1]
else
	dex_bonus = Stats.dex[1]
end
pick_skill = (Skills.to_bonus(Skills.pickinglocks) + dex_bonus)
pick_lore = [(Stats.level / 2) + (Skills.to_bonus(Skills.pickinglocks) / 10) + (dex_bonus) + (Spells.minorelemental / 4), Skills.to_bonus(Skills.pickinglocks)].min
disarm_skill = (dex_bonus + Skills.to_bonus(Skills.disarmingtraps))
if Spell[404].known?
	disarm_lore = [(Stats.level / 2) + (Skills.to_bonus(Skills.disarmingtraps) / 10) + dex_bonus + (Spells.minorelemental / 4), Skills.to_bonus(Skills.disarmingtraps)].min
else
	disarm_lore = 0
end
(stow_left = nil;stow_right = nil;start_solo = nil;start_others = nil;check_disk = nil;manually_disarm_trap = nil;scaledisarm = nil;plate = nil;measure = nil;pick2 = nil;pick3 = nil;nextpick = nil;open_solo = nil;open_others = nil;need_403 = nil;needed_pick = nil;total_pick_skill = nil;person = nil;box = "box";cast_404 = nil;solo_or_other = nil;always_use_vaalin = nil;wedge_lock = nil;ground_loot = nil;start_ground = nil;current_box = nil;setup = nil;do_trick = nil;calibrate = nil;cast_403 = nil;cast_402 = nil;cast_613 = nil;cast_205 = nil;cast_1006 = nil;cast_506 = nil;calibrate_count = nil;cast_407 = nil;current_box_name = nil;box_opened = true;cant_open_plated_box_count = nil;total_boxes_picked = 0;record_item_data = nil;silver_before = nil;silver_after = nil;wealth_before = nil;wealth_after = nil;silver_gained = 0;trash = nil;garbage_check = nil;trap_difficulty = nil;need_404 = nil;total_trap_skill = nil;broken_lockpick_stow = nil;relock_boxes = nil;do_relock_boxes = nil)

trash_container = /crate|barrel|wastebarrel|casket|bin|receptacle|basket/i

setup = proc{
	CharSettings['setup_has_been_run'] = true
	CharSettings['setup_has_been_run_again'] = true
	$copper_lockpick_id = nil
	$steel_lockpick_id = nil
	$gold_lockpick_id = nil
	$silver_lockpick_id = nil
	$mithril_lockpick_id = nil
	$ora_lockpick_id = nil
	$glaes_lockpick_id = nil
	$laje_lockpick_id = nil
	$vultite_lockpick_id = nil
	$rolaren_lockpick_id = nil
	$veniom_lockpick_id = nil
	$invar_lockpick_id = nil
	$alum_lockpick_id = nil
	$golvern_lockpick_id = nil
	$kelyn_lockpick_id = nil
	$vaalin_lockpick_id = nil
	Gtk.queue {
		$TPICK_WINDOW = Gtk::Window.new
		$TPICK_WINDOW.title = "tpick"
		$TPICK_WINDOW.set_border_width(10)
		
		#GTK2 and GTK3 nonsense:
		if gtk_version == 2
			$TPICK_BOX = Gtk::VBox.new(false)
			$TPICK_BOX.set_border_width(5)

			$TPICK_VERTICAL_BOX1 = Gtk::VBox.new(false, 0)
			$TPICK_VERTICAL_BOX2 = Gtk::VBox.new(false, 0)
			$TPICK_VERTICAL_BOX3 = Gtk::VBox.new(false, 0)
			$TPICK_VERTICAL_BOX4 = Gtk::VBox.new(false, 0)
			$TPICK_VERTICAL_BOX5 = Gtk::VBox.new(false, 0)
			$TPICK_VERTICAL_BOX6 = Gtk::VBox.new(false, 0)
			$TPICK_VERTICAL_BOX7 = Gtk::VBox.new(false, 0)
			$TPICK_VERTICAL_BOX8 = Gtk::VBox.new(false, 0)
			$TPICK_VERTICAL_BOX9 = Gtk::VBox.new(false, 0)
			$TPICK_VERTICAL_BOX10 = Gtk::VBox.new(false, 0)
		else
			$TPICK_BOX = Gtk::Box.new(:vertical)
			$TPICK_BOX.set_border_width(5)

			$TPICK_VERTICAL_BOX1 = Gtk::Box.new(:vertical, 0)
			$TPICK_VERTICAL_BOX2 = Gtk::Box.new(:vertical, 0)
			$TPICK_VERTICAL_BOX3 = Gtk::Box.new(:vertical, 0)
			$TPICK_VERTICAL_BOX4 = Gtk::Box.new(:vertical, 0)
			$TPICK_VERTICAL_BOX5 = Gtk::Box.new(:vertical, 0)
			$TPICK_VERTICAL_BOX6 = Gtk::Box.new(:vertical, 0)
			$TPICK_VERTICAL_BOX7 = Gtk::Box.new(:vertical, 0)
			$TPICK_VERTICAL_BOX8 = Gtk::Box.new(:vertical, 0)
			$TPICK_VERTICAL_BOX9 = Gtk::Box.new(:vertical, 0)
			$TPICK_VERTICAL_BOX10 = Gtk::Box.new(:vertical, 0)
		end
		#####

		$TPICK_WINDOW.add($TPICK_BOX)
		$TPICK_NOTEBOOK = Gtk::Notebook.new
		$TPICK_NOTEBOOK.set_show_border(true)
		$TPICK_BOX.add($TPICK_NOTEBOOK)
		$TPICK_NOTEBOOK.append_page($TPICK_VERTICAL_BOX1, Gtk::Label.new('Lockpicks'))
		$TPICK_NOTEBOOK.append_page($TPICK_VERTICAL_BOX2, Gtk::Label.new('More Lockpicks'))
		$TPICK_NOTEBOOK.append_page($TPICK_VERTICAL_BOX3, Gtk::Label.new('Containers'))
		$TPICK_NOTEBOOK.append_page($TPICK_VERTICAL_BOX4, Gtk::Label.new('Other'))
		$TPICK_NOTEBOOK.append_page($TPICK_VERTICAL_BOX5, Gtk::Label.new('More Other'))
		$TPICK_NOTEBOOK.append_page($TPICK_VERTICAL_BOX6, Gtk::Label.new('Spells'))
		$TPICK_NOTEBOOK.append_page($TPICK_VERTICAL_BOX7, Gtk::Label.new('Experience'))
		$TPICK_NOTEBOOK.append_page($TPICK_VERTICAL_BOX8, Gtk::Label.new('Speech'))
		$TPICK_NOTEBOOK.append_page($TPICK_VERTICAL_BOX9, Gtk::Label.new('Popping'))
		$TPICK_NOTEBOOK.append_page($TPICK_VERTICAL_BOX10, Gtk::Label.new('Pool/Worker'))
		$TPICK_ENTRY = Hash.new 
		$TPICK_TABLE_SIZE = Hash.new
	}

	Gtk.queue {
		$TPICK_TABLE1 = Gtk::Table.new(6, 3, false)
		$TPICK_TABLE1.row_spacings=3
		$TPICK_TABLE1.column_spacings=3
		$TPICK_VERTICAL_BOX1.pack_start($TPICK_TABLE1, false, false, 0)

		$TPICK_TABLE2 = Gtk::Table.new(6, 3, false)
		$TPICK_TABLE2.row_spacings=3
		$TPICK_TABLE2.column_spacings=3
		$TPICK_VERTICAL_BOX2.pack_start($TPICK_TABLE2, false, false, 0)

		$TPICK_TABLE3 = Gtk::Table.new(6, 3, false)
		$TPICK_TABLE3.row_spacings=3
		$TPICK_TABLE3.column_spacings=3
		$TPICK_VERTICAL_BOX3.pack_start($TPICK_TABLE3, false, false, 0)

		$TPICK_TABLE4 = Gtk::Table.new(6, 3, false)
		$TPICK_TABLE4.row_spacings=3
		$TPICK_TABLE4.column_spacings=3
		$TPICK_VERTICAL_BOX4.pack_start($TPICK_TABLE4, false, false, 0)

		$TPICK_TABLE5 = Gtk::Table.new(6, 3, false)
		$TPICK_TABLE5.row_spacings=3
		$TPICK_TABLE5.column_spacings=3
		$TPICK_VERTICAL_BOX5.pack_start($TPICK_TABLE5, false, false, 0)

		$TPICK_TABLE6 = Gtk::Table.new(6, 3, false)
		$TPICK_TABLE6.row_spacings=3
		$TPICK_TABLE6.column_spacings=3
		$TPICK_VERTICAL_BOX6.pack_start($TPICK_TABLE6, false, false, 0)

		$TPICK_TABLE7 = Gtk::Table.new(6, 3, false)
		$TPICK_TABLE7.row_spacings=3
		$TPICK_TABLE7.column_spacings=3
		$TPICK_VERTICAL_BOX7.pack_start($TPICK_TABLE7, false, false, 0)

		$TPICK_TABLE8 = Gtk::Table.new(6, 3, false)
		$TPICK_TABLE8.row_spacings=3
		$TPICK_TABLE8.column_spacings=3
		$TPICK_VERTICAL_BOX8.pack_start($TPICK_TABLE8, false, false, 0)

		$TPICK_TABLE9 = Gtk::Table.new(6, 3, false)
		$TPICK_TABLE9.row_spacings=3
		$TPICK_TABLE9.column_spacings=3
		$TPICK_VERTICAL_BOX9.pack_start($TPICK_TABLE9, false, false, 0)
		
		$TPICK_TABLE10 = Gtk::Table.new(6, 3, false)
		$TPICK_TABLE10.row_spacings=3
		$TPICK_TABLE10.column_spacings=3
		$TPICK_VERTICAL_BOX10.pack_start($TPICK_TABLE10, false, false, 0)
	}

	def self.add_label_entry(table, label, variable)
		size = $TPICK_TABLE_SIZE[table] || 0

		label = Gtk::Label.new(label)
		align = Gtk::Alignment.new 1, 0, 0, 0
		align.set_padding(4, 0, 3, 4)
		align.add(label)
		table.attach(align, 0, 1, size, size + 1)

		entry = Gtk::Entry.new
		entry.text = UserVars.tpick[variable].to_s
		entry.set_width_request(157)
		table.attach(entry, 1, 2, size, size + 1)

		$TPICK_ENTRY[variable] = entry
		$TPICK_TABLE_SIZE[table] += 1
	end

	Gtk.queue {
		$TPICK_ENTRY = Hash.new
		add_label_entry($TPICK_TABLE1, "Copper Lockpick", 'copper')
		add_label_entry($TPICK_TABLE1, "Steel Lockpick", 'steel')
		add_label_entry($TPICK_TABLE1, "Gold Lockpick", 'gold')
		add_label_entry($TPICK_TABLE1, "Silver Lockpick", 'silver')
		add_label_entry($TPICK_TABLE1, "Mithril Lockpick", 'mithril')
		add_label_entry($TPICK_TABLE1, "Ora Lockpick", 'ora')
		add_label_entry($TPICK_TABLE1, "Glaes Lockpick", 'glaes')
		add_label_entry($TPICK_TABLE1, "Laje Lockpick", 'laje')
		add_label_entry($TPICK_TABLE2, "Vultite Lockpick", 'vultite')
		add_label_entry($TPICK_TABLE2, "Rolaren Lockpick", 'rolaren')
		add_label_entry($TPICK_TABLE2, "Veniom Lockpick", 'veniom')
		add_label_entry($TPICK_TABLE2, "Invar Lockpick", 'invar')
		add_label_entry($TPICK_TABLE2, "Alum Lockpick", 'alum')
		add_label_entry($TPICK_TABLE2, "Golvern Lockpick", 'golvern')
		add_label_entry($TPICK_TABLE2, "Kelyn Lockpick", 'kelyn')
		add_label_entry($TPICK_TABLE2, "Vaalin Lockpick", 'vaalin')
		add_label_entry($TPICK_TABLE3, "Lockpick Container", 'lockpick_container')
		add_label_entry($TPICK_TABLE3, "Broken Lockpick Container", 'broken_lockpick_container')
		add_label_entry($TPICK_TABLE3, "Wedge Container", 'wedge_container')
		add_label_entry($TPICK_TABLE3, "Calipers Container", 'calipers_container')
		add_label_entry($TPICK_TABLE3, "Scale Weapon Container", 'scale_weapon_container')
		add_label_entry($TPICK_TABLE3, "Locksmith's Container", 'locksmiths_container')
		add_label_entry($TPICK_TABLE3, "Gem Container", 'gem_container')
		#add_label_entry($TPICK_TABLE4, "Run silently", 'run_silently')
		add_label_entry($TPICK_TABLE4, "Auto deposit silvers", 'auto_deposit_silvers')
		add_label_entry($TPICK_TABLE4, "Gnomish Bracer", 'gnomish_bracer')
		add_label_entry($TPICK_TABLE4, "Bashing Weapon", 'bashing_weapon')
		add_label_entry($TPICK_TABLE4, "Scale Trap Weapon", 'scale_trap_weapon')
		add_label_entry($TPICK_TABLE4, "Max Lock", 'max_lock')
		add_label_entry($TPICK_TABLE4, "Trap Roll", 'trap_roll')
		add_label_entry($TPICK_TABLE4, "Lock Roll", 'lock_roll')
		add_label_entry($TPICK_TABLE4, "Vaalin Lock Roll", 'vaalin_lock_roll')
		add_label_entry($TPICK_TABLE5, "Trick", 'trick')
		add_label_entry($TPICK_TABLE5, "Log", 'log')
		add_label_entry($TPICK_TABLE5, "Trash boxes", 'trash_boxes')
		add_label_entry($TPICK_TABLE5, "Calibrate on startup", 'calibrate')
		add_label_entry($TPICK_TABLE5, "Calibrate count", 'calibratecount')
		add_label_entry($TPICK_TABLE5, "Auto Bundle Vials", 'auto_bundle_vials')
		add_label_entry($TPICK_TABLE5, "Auto repair bent lockpicks", 'auto_repair_bent_lockpicks')
		add_label_entry($TPICK_TABLE5, "Number of times to check for traps", 'number_of_times_to_check_for_traps')
		add_label_entry($TPICK_TABLE6, "Light (205)", 'always_use_205')
		add_label_entry($TPICK_TABLE6, "Presence (402)", 'always_use_402')
		add_label_entry($TPICK_TABLE6, "Lock Pick Enhancement (403)", 'always_use_403')
		add_label_entry($TPICK_TABLE6, "Disarm Enhancement (404)", 'always_use_404')
		add_label_entry($TPICK_TABLE6, "Unlock (407)", 'always_use_407')
		add_label_entry($TPICK_TABLE6, "Haste (506)", 'always_use_506')
		add_label_entry($TPICK_TABLE6, "Self Control (613)", 'always_use_613')
		add_label_entry($TPICK_TABLE6, "Song of Luck (1006)", 'always_use_1006')
		add_label_entry($TPICK_TABLE7, "Use Vaalin when Fried", 'use_vaalin_when_fried')
		add_label_entry($TPICK_TABLE7, "Rest at Percent", 'rest_percent')
		add_label_entry($TPICK_TABLE7, "Pick at Percent", 'pick_percent')
		add_label_entry($TPICK_TABLE8, "Ready", 'ready')
		add_label_entry($TPICK_TABLE8, "Can't Open Box", 'cant_open_box')
		add_label_entry($TPICK_TABLE8, "Scarab Found", 'scarab_found')
		add_label_entry($TPICK_TABLE8, "Scarab safe", 'scarab_safe')
		add_label_entry($TPICK_TABLE9, "Phase (704)", 'always_use_704')
		add_label_entry($TPICK_TABLE9, "Number of 416 casts", 'number_of_416_casts')
		add_label_entry($TPICK_TABLE9, "Only disarm safe", 'only_disarm_safe')
		add_label_entry($TPICK_TABLE10, "Max critter level", 'max_critter_level')
		add_label_entry($TPICK_TABLE10, "Minimum tip wanted", 'minimum_tip_wanted')
		add_label_entry($TPICK_TABLE10, "Picks to use based on critter level", 'picks_to_use_based_on_critter_level')
	}

	def self.add_checkbox(table, x_pos, label, variable, default = false)
		size = $TPICK_TABLE_SIZE[table] || 0
		checkbox = Gtk::CheckButton.new label
		value = UserVars.tpick[variable].nil? ? default : UserVars.tpick[variable]
		checkbox.set_active(value)
		table.attach(checkbox, x_pos, x_pos + 1, size, size + 1)
		$TPICK_ENTRY[variable] = checkbox
		$TPICK_TABLE_SIZE[table] += 1 if x_pos == 1
	end
        
	Gtk.queue {
		$TPICK_WINDOW.signal_connect("delete_event") {
			$TPICK_SETUP_COMPLETED = true
		}
	}
        
	Gtk.queue {

		label = Gtk::Label.new
		label.set_markup("Enter the FULL name of your lockpicks above, NOT including the words 'a' or 'an'.  If you don't have a particular lockpick use the next best lockpick.\nFor example if you don't have a steel lockpick then put the name of your gold lockpick in both the steel and gold lockpick variables.\nYou can enter multiple lockpicks of the same kind by separating them with a comma.\nFor example if you have two copper lockpicks you can enter the following in the Copper Lockpick setting: dark red copper lockpick,red tinted copper lockpick.\nNote no space after the comma.")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$TPICK_TABLE1.attach(align, 1, 2, 8, 9)

		label = Gtk::Label.new
		label.set_markup("Enter the FULL name of your lockpicks above, NOT including the words 'a' or 'an'.  If you don't have a particular lockpick use the next best lockpick.\nFor example if you don't have a steel lockpick then put the name of your gold lockpick in both the steel and gold lockpick variables.\nYou can enter multiple lockpicks of the same kind by separating them with a comma.\nFor example if you have two copper lockpicks you can enter the following in the Copper Lockpick setting: dark red copper lockpick,red tinted copper lockpick.\nNote no space after the comma.")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$TPICK_TABLE2.attach(align, 1, 2, 8, 9)

		label = Gtk::Label.new
		label.set_markup("Enter the FULL name of your container above where items can be found and will be stored, DON'T include the starting words of 'a' or 'an'.\nEnter <b>,close</b> after any container you want script to close when finished.\nFor example: <b>pack,close</b>\n<b>Broken Lockpick Container:</b>  Container where script will store your broken lockpicks.\n<b>Locksmith's Container:</b>  Container where putty and cotton balls are found.\n<b>Gem Container</b>  Enter name of container where script should stow all gems found from looting boxes.")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$TPICK_TABLE3.attach(align, 1, 2, 8, 9)

		label = Gtk::Label.new
		label.set_markup("<b>Auto deposit silvers:</b> Enter <b>yes</b> to auto deposit silvers when encumbered and picking pool boxes or ground picking and looting.\n<b>Gnomish Bracer:</b>  Enter name and tier of your gnomish bracer (example: bracer,1), <b>nil</b> if none.\n<b>Gnomish Bracer:</b> Entering <b>,override</b> (for example: bracer,1,override) at the end will only use bracers for disarming and will use <b>lockpick container</b> setting to find and store lockpicks.\n<b>Bashing Weapon:</b>  Name of weapon to use for bashing boxes, <b>nil</b> if none.\n<b>Scale Trap Weapon:</b>  FULL name of weapon you use for disarming scale traps, not including 'a' or 'an'.\n<b>Max Lock:</b> The highest lock you are willing to attempt (any locks higher than this will be wedged/popped or skipped). Enter 10000 to attempt all locks.\nDoing something like <b>-100</b> would instead only attempt locks that are at most 100 lower than your max skill with a vaalin lockpick.\n<b>Trap Roll:</b>  Determines what difficulty boxes you want to attempt.\nSet to 0 to never try anything higher than your total disarm skill + lore bonus.\nSetting to 10 would attempt traps 10 points higher than your disarm skill + lore bonus.\nSetting to -10 would only attempt traps that are a maximum of 10 points lower than your disarm skill + lore bonus.\nSet this value to whatever number you want. A value of 1000 would attempt to disarm all traps.\nScript will always use 404 if it determines you need the spell to disarm a trap.\n<b>Lock Roll:</b>  Maximum roll allowed before moving to a higher lockpick.\nExample if this value is 50 and you roll a 60 and didn't pick the lock the script will move to the next lockpick. 50 is a good starting number.\n<b>Vaalin Lock Roll:</b>  Same as above but just for vaalin picks if you want to attempt to pick locks with a higher needed roll than other lockpicks. 80 is a good starting number.\nSet to 1000 to always try picking a lock with a vaalin lockpick before moving on to a wedge or 407.\n<b>This number should be equal or higher than Lock Roll.</b>")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$TPICK_TABLE4.attach(align, 1, 2, 8, 9)

		label = Gtk::Label.new
		label.set_markup("<b>Trick:</b>  Trick to use when picking locks. Enter: spin, twist, turn, twirl, toss, bend or flip.  Enter <b>pick</b> if you don't want to use a trick.\nEnter <b>random</b> to use a random trick each time you pick a box, ONLY USE THIS IF YOU KNOW ALL THE TRICKS.\n<b>Log:</b>  Enter <b>yes</b> to display a summary of all loot found when done.\n<b>Trash boxes:</b>  Enter <b>yes</b> to dispose of empty boxes if possible, <b>no</b> will drop them on the ground, <b>save</b> STOWS empty boxes.\n<b>Calibrate on startup:</b>  <b>yes</b> to calibrate your calipers when the script is started, <b>no</b> to skip calibrating, <b>never</b> to never use calipers/loresinging and default use a vaalin lockpick (use this if you have fewer than 40 ranks in lock mastery).\n<b>Calibrate Count:</b>  Will calibrate your calipers every time you pick this many boxes. (enter 999 to never calibrate)\n<b>Auto Bundle Vials:</b> Enter <b>yes</b> to have script bundle vials you get from disarming traps into your locksmith's container.\n<b>Auto repair bent lockpicks:</b>  Enter <b>yes</b> to have script automatically repair lockpicks after they have been bent. Only works if you have learned lmas repair.\n<b>Number of times to check for traps:</b>  How many times you want script to manually check for traps.")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$TPICK_TABLE5.attach(align, 1, 2, 8, 9)

		label = Gtk::Label.new
		label.set_markup("Enter <b>yes</b> for any spells you want to keep on while disarming/picking, <b>no</b> for any spells you don't want to cast.\nIf 403 and 404 are set to <b>no</b> the script will cast the spells when needed (after a failure or for a very high lock) and if you know the spell.\nSet 403 and 404 to <b>cancel</b> if you want these spells stopped when starting on a new box.\nSet 403 to <b>never</b> to NEVER use 403.\nSet 403 or 404 to a number (like 100) to always use 403/404 if the lock/trap difficulty is above this number.\nYou can do something like <b>100,cancel</b> (note no spaces) if you still want to cancel 403/404 when starting a new box.\nIf <b>407</b> is set to <b>plate</b> the script will attempt to open plated boxes (except mithril or enruned) with 407 if you have no acid vials or wedges.\nIf <b>407</b> is set to <b>all</b> the script will attempt to open all boxes (except mithril and enruned) with 407.\nEnter <b>no</b> for <b>407</b> to skip using 407 on boxes.")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$TPICK_TABLE6.attach(align, 1, 2, 8, 9)

		label = Gtk::Label.new
		label.set_markup("<b>Use Vaalin when Fried:</b>  Enter <b>yes</b> to always use vaalin if you're fried.\n<b>Rest at Percent:</b>  Script will pause when your mind reaches this amount or higher.  Enter <b>200</b> to never rest.\n<b>Pick at Percent:</b>  Will start picking when your mind reaches this amount or lower.  Enter <b>100</b> to always pick.\nDoes not work when using OTHER command line.\nUse the following amounts\nmust rest:  100\nnumbed:  90\nbecoming numbed:  75\nmuddled:  62\nclear:  50\nfresh and clear:  25\nclear as a bell:  0")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$TPICK_TABLE7.attach(align, 1, 2, 8, 9)

		label = Gtk::Label.new
		label.set_markup("Enter <b>nil</b> for any option where you don't want to speak.\n<b>Ready:</b>  What to say when ready to be handed boxes from another person. Example: <b>Ready.</b>\n<b>Can't Open Box:</b>  What to say when you can't open a box for another person. Example: <b>Sorry can't open this box.</b>\n<b>Scarab Found:</b>  What to say before you disarm a scarab trap. Example: <b>Scarab coming down.</b>\n<b>Scarab Safe:</b> What to say after you have disarmed the scarab. For example: <b>Scarab safe.</b>")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$TPICK_TABLE8.attach(align, 1, 2, 8, 9)

		label = Gtk::Label.new
		label.set_markup("<b>Phase (704):</b>  Enter <b>yes</b> to use Phase (704) on each box to check for glyph traps, <b>no</b> to skip Phase.\n<b>Number of 416 casts:</b>  Number of times you want to check a box for traps using Piercing Gaze (416).\n<b>Only disarm safe:</b>  Some traps can be bypassed altogether when using 407 to open the box and some traps are always safe to use 408 on.\nHowever some traps have a chance of being set off when using 408. \nEnter <b>yes</b> here to skip boxes with traps that are not 100% safe, <b>no</b> to attempt disarming them with 408.\nSome traps are never safe to use 408 on and the script will always skip these boxes no matter what value you enter here.")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$TPICK_TABLE9.attach(align, 1, 2, 8, 9)
		
		label = Gtk::Label.new
		label.set_markup("<b>These options are only for pool/worker boxes.</b>\n<b>Max critter level:</b>  Maximum critter level of boxes you will work on, higher level boxes will be turned in. Enter <b>1000</b> to work on all boxes.\n<b>Minimum tip wanted:</b>  Minimum tip wanted, lower tips will be turned in. Enter <b>0</b> to work on all boxes.\n<b>The below setting works by default for non-rogues/bards. If you are a rogue/bard this setting only works if you use 'v' command line variable or you have set 'Calibrate on startup' to 'never.'</b>\n<b>Picks to use based on critter level:</b>  Below is an example of how to use this setting:\n10 copper, 20 steel, 30 gold, 50 lage, 75 invar, 90 kelyn\nThis would use your copper lockpick for critters up to level 10, steel for critters up to 20, etc.\nVaalin is used for any levels not specified, in the above example that would be for critters 91+.\n<b>DO NOT</b> use the names of your lockpicks, use the lockpick type, use the below list as a reference:\ncopper, steel, gold, silver, mithril, ora, glaes, laje, vultite, rolaren, veniom, invar, alum, golvern, kelyn, vaalin\n<b>Leave this blank if you don't want to use this feature.</b>")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$TPICK_TABLE10.attach(align, 1, 2, 8, 9)

		$TPICK_WINDOW.show_all
	}
        
	$TPICK_SETUP_COMPLETED = false
	until($TPICK_SETUP_COMPLETED)
		sleep 1
	end
	
	UserVars.tpick ||= Hash.new
	$TPICK_ENTRY.keys.each { |key|
		if( $TPICK_ENTRY[key].class.to_s =~ /CheckButton/ )
			value = $TPICK_ENTRY[key].active?
			UserVars.tpick[key] = $TPICK_ENTRY[key].active?
		else
			if(key == 'wounded_eval')
				UserVars.tpick[key] = $TPICK_ENTRY[key].text
			else
				UserVars.tpick[key] = $TPICK_ENTRY[key].text.strip.downcase
			end
		end
	}

	UserVars.save()
        
	Gtk.queue {
		$TPICK_WINDOW.destroy
	}
}

def tpick_cast_spells (number)
	if Spell[number].known? && 0.10 > Spell[number].timeleft
		until 0.10 < Spell[number].timeleft
			if !Spell[number].affordable?
				echo "Waiting for mana."
				wait_until { Spell[number].affordable? }
			end
			Spell[number].cast
			sleep 0.2
		end
	end
end

def tpick_prep_spell(number, name)
	if Spell[number].known?
		if !Spell[number].affordable?
			echo "Waiting for mana."
			wait_until { Spell[number].affordable? }
		end
		until checkprep == "#{name}"
			waitrt?
			waitcastrt?
			fput "release" if checkprep !~ /None|#{name}/i
			fput "prep #{number}"
			sleep 0.2
		end
	end
end

def tpick_drop_box(current_box)
	if GameObj.right_hand.id == current_box.id
		until checkright.nil?
			waitrt?
			fput "drop ##{current_box.id}"
			sleep 0.2
		end
	else
		until checkleft.nil?
			waitrt?
			fput "drop ##{current_box.id}"
			sleep 0.2
		end
	end
end

def tpick_get_box(current_box)
	until GameObj.right_hand.id == current_box.id || GameObj.left_hand.id == current_box.id
		waitrt?
		fput "get ##{current_box.id}"
		sleep 0.2
	end
end

def tpick_stop_403_404		
	waitrt?
	fput "stop 403" if Spell[403].active? && ($tpick_use_403_cancel =~ /cancel/i || UserVars.tpick["always_use_403"] =~ /cancel/i)
	fput "stop 404" if Spell[404].active? && ($tpick_use_404_cancel =~ /cancel/i || UserVars.tpick["always_use_404"] =~ /cancel/i)
end

def tpick_stow_box(current_box)
	until GameObj.right_hand.id != current_box.id && GameObj.left_hand.id != current_box.id
		waitrt?
		fput "stow ##{current_box.id}"
		sleep 0.2
	end
end

def tpick_say_cant
	fput "say #{UserVars.tpick["cant_open_box"]}" if UserVars.tpick["cant_open_box"] != "nil" && UserVars.tpick["cant_open_box"].length > 0
end

def tpick_say_scarab_found
	fput "say #{UserVars.tpick["scarab_found"]}" if UserVars.tpick["scarab_found"] != "nil" && UserVars.tpick["scarab_found"].length > 0
end

def tpick_say_scarab_safe
	fput "say #{UserVars.tpick["scarab_safe"]}" if UserVars.tpick["scarab_safe"] != "nil" && UserVars.tpick["scarab_safe"].length > 0
end

ask_worker = proc{
	waitrt?
	result = dothistimeout "ask ##{worker.id} to check", 3, /If you want to give up\, ASK me to CHECK it again within 30 seconds\.\"|Here\'s your payment of|You aren\'t working on a job\.|Too tough for ya\, eh\?/
	if result =~ /If you want to give up\, ASK me to CHECK it again within 30 seconds\.\"|Here\'s your payment of|You aren\'t working on a job\.|Too tough for ya\, eh\?/
		nil
	elsif result.nil?
		echo "Didn't recognize game line I was looking for, trying again."
		ask_worker.call
	end
}

stow_calipers = proc{
	until GameObj.right_hand.name !~ /calipers/ && GameObj.left_hand.name !~ /calipers/
		waitrt?
		fput "put my calipers in ##{calipers_container.id}"
		sleep 0.1
	end
}

stow_wedge = proc{
	until GameObj.right_hand.name !~ /wedge/ && GameObj.left_hand.name !~ /wedge/
		waitrt?
		fput "put my wedge in ##{wedge_container.id}"
		sleep 0.1
	end
}

open_current_plinite = proc{
	stow_left.call unless GameObj.left_hand.id == current_box.id
	waitrt?
	fput "pluck ##{current_box.id}"
	stow_both.call
}

start_plinites = proc{
	$tpick_list_of_box_ids.each{ |plinite|
		stow_both.call
		plinite_already_open = nil
		cannot_determine_plinite_difficulty = nil
		until GameObj.right_hand.id == plinite || GameObj.left_hand.id == plinite
			waitrt?
			fput "get ##{plinite}"
			sleep 0.2
		end
		current_box = GameObj.right_hand if GameObj.right_hand.name =~ /plinite/
		current_box = GameObj.left_hand if GameObj.left_hand.name =~ /plinite/
		detect_plinite.call
	}
}

detect_plinite_result = proc{
	waitrt?
	(tpick_cast_spells (404)) if (use_spell_404) || (need_404)
	result = dothistimeout "detect ##{current_box.id}", 3, /It looks like it would be.*\(\-(\d+)\)\.|You struggle to determine the difficulty of the extraction \(somewhere between .* and \-(\d+)\)\.|You promptly discover that the core has already been removed\.|You are unable to determine the difficulty of the extraction\.|You promptly discover that the core has already been extracted and merely needs to be PLUCKed from the tip of the shard\./
	if result =~ /It looks like it would be.*\(\-(\d+)\)\./ || result =~ /You struggle to determine the difficulty of the extraction \(somewhere between .* and \-(\d+)\)\./
		lock = $1.to_i
	elsif result =~ /You promptly discover that the core has already been removed\./
		echo "This plinite has already been extracted."
		stow_both.call
		plinite_already_open = true
	elsif result =~ /You are unable to determine the difficulty of the extraction\./
		cannot_determine_plinite_difficulty = true
		lock = 1000000
	elsif result =~ /You promptly discover that the core has already been extracted and merely needs to be PLUCKed from the tip of the shard\./
		open_current_plinite.call
		plinite_already_open = true
	elsif result.nil?
		detect_plinite_result.call
	end
}

detect_plinite = proc{
	i_need_403 = nil
	need_404 = "yes" unless UserVars.tpick["always_use_404"] == "never"
	waitrt?
	3.times{
		waitrt?
		unless GameObj.right_hand.id == $vaalin_lockpick_id || GameObj.left_hand.id == $vaalin_lockpick_id
			fput "get ##{$vaalin_lockpick_id}"
			sleep 0.2
		end
	}
	if GameObj.right_hand.id != $vaalin_lockpick_id && GameObj.left_hand.id != $vaalin_lockpick_id
		echo "Couldn't find your #{UserVars.tpick["vaalin"]}."
		exit
	end
	detect_plinite_result.call
	until GameObj.right_hand.id != $vaalin_lockpick_id && GameObj.left_hand.id != $vaalin_lockpick_id
		waitrt?
		fput "put ##{$vaalin_lockpick_id} in ##{lockpick_container.id}"
		sleep 0.2
	end
	if plinite_already_open == nil
		total_pick_skill = (pick_skill + pick_lore) * 2.50
		if lock > (total_pick_skill + UserVars.tpick["vaalin_lock_roll"].to_i)
			if solo_or_other == "worker"
				echo "Can't extract this plinite based on my calculations. If you think this is in error increase the Vaalin Lock Roll setting in the setup menu."
				cannot_determine_plinite_difficulty = nil
				ask_worker.call
			else
				echo "Can't extract this plinite, OPENing it instead. If you think this is in error increase the Vaalin Lock Roll setting in the setup menu."
				cannot_determine_plinite_difficulty = nil
				waitrt?
				fput "open ##{current_box.id}"
			end
		else
			number = 0
			pick_mod.each do |i|
				total_pick_skill = (pick_skill + pick_lore)
				if (total_pick_skill) * 2.50 - lock + UserVars.tpick["lock_roll"].to_i < 100 || cannot_determine_plinite_difficulty
					needed_pick = UserVars.tpick["vaalin"]
					needed_pick_id = vaalin_lock_pick_array.first
					need_403 = "yes" unless UserVars.tpick["always_use_403"] == "never"
					need_404 = "yes" unless UserVars.tpick["always_use_404"] == "never"
					i_need_403 = true unless UserVars.tpick["always_use_403"] == "never"
					number = 15
					break
				else
					total_pick_skill = (pick_skill) * i
					if total_pick_skill - lock + UserVars.tpick["lock_roll"].to_i < 100
						number += 1
						unless UserVars.tpick["always_use_403"] == "never"
							i_need_403 = true if number > 14
						end
					else
						break
					end
				end
				if use_403_for_lock_difficulty && Spell[403].known? && lock > use_403_for_lock_difficulty
					i_need_403 = true
				end
			end
			if i_need_403
				number = 0
				need_403 = "yes" unless UserVars.tpick["always_use_403"] == "never"
				need_404 = "yes" unless UserVars.tpick["always_use_404"] == "never"
				pick_mod.each do |i|
					total_pick_skill = (pick_skill + pick_lore) * i
					if total_pick_skill - lock + UserVars.tpick["lock_roll"].to_i < 100
						number += 1
					else
						break
					end
				end
			end
			number = [15, number].min
			if number == 0
				recommended_pick = "copper"
			elsif number == 1
				recommended_pick = "steel"
			elsif number == 2
				recommended_pick = "gold"
			elsif number == 3
				recommended_pick = "silver"
			elsif number == 4
				recommended_pick = "mithril"
			elsif number == 5
				recommended_pick = "ora"
			elsif number == 6
				recommended_pick = "glaes"
			elsif number == 7
				recommended_pick = "laje"
			elsif number == 8
				recommended_pick = "vultite"
			elsif number == 9
				recommended_pick = "rolaren"
			elsif number == 10
				recommended_pick = "veniom"
			elsif number == 11
				recommended_pick = "invar"
			elsif number == 12
				recommended_pick = "alum"
			elsif number == 13
				recommended_pick = "golvern"
			elsif number == 14
				recommended_pick = "kelyn"
			elsif number > 14
				recommended_pick = "vaalin"
			end
			lock_pick_information.call
			echo "Recommended lock pick: #{recommended_pick} with a modifier of #{recommended_pick_modifier}"
			if need_403 == "yes"
				if use_403_for_lock_difficulty && Spell[403].known? && lock > use_403_for_lock_difficulty
					echo "Lock difficulty is higher than your 403 setting in setup menu, using 403."
				else
					echo "Recommend 403: Yes"
				end
				echo "Your calculated lockpicking skill: #{pick_skill}"
				echo "Your calculated lockpicking lore: #{pick_lore}"
				temp_math_number = pick_skill + pick_lore
			else
				echo "Recommend 403: No"
				echo "Your calculated lockpicking skill: #{pick_skill}"
				temp_math_number = pick_skill
			end
			quick_maths = (temp_math_number * recommended_pick_modifier).truncate
			echo "Your total picking skill for this attempt is: #{quick_maths}"
			echo "Lock difficulty: #{lock}"
			if needed_pick_id.nil?
				echo "All of your #{recommended_pick} lockpicks seem to be broken, trying a higher tier lockpick."
				nextpick.call
			else
				pick2.call
			end
		end	
	end
}

pop_start = proc{
	$tpick_list_of_box_ids.each{ |box|
		current_box = box
		pop_boxes_begin.call
	}
	check_disk.call
}

cast_704_at_box = proc{
	waitrt?
	waitcastrt?
	tpick_prep_spell(704, "Phase")
	result = dothistimeout "cast at ##{current_box.id}", 3, /resists the effects of your magic|appears lighter|then stabilizes|but quickly returns to normal|Roundtime/
	if result =~ /resists the effects of your magic/
		echo "Box has a glyph trap and cannot be opened."
		tpick_drop_box(current_box) if solo_or_other == "ground"
		where_to_stow_box.call if solo_or_other == "solo"
		box_opened = nil
	elsif result =~ /appears lighter|then stabilizes|but quickly returns to normal|Roundtime/
		echo "Box has no glyph trap. Checking for other traps."
		tpick_drop_box(current_box)
		tpick_get_box(current_box) if solo_or_other != "ground"
		check_for_trap.call
	elsif result.nil?
		cast_704_at_box.call
	end
}

pop_boxes_begin = proc{
	stow_both.call
	until checkright
		fput "get ##{current_box}"
		sleep 0.2
	end
	current_box = GameObj.right_hand
	start_time = Time.now
	remaining_416_casts = UserVars.tpick["number_of_416_casts"].to_i
	stuff_to_do.call
	check_for_command = "glance"
	check_hands_status = nil
	check_for_boxes.call
	wait_until { check_hands_status }
	if check_hands_status == "mithril or enruned"
		echo "Can't open this box because it is mithril or enruned."
		waitrt?
		tpick_drop_box(current_box) if solo_or_other == "ground"
		where_to_stow_box.call if solo_or_other == "solo"
		box_opened = nil
	elsif check_hands_status == "empty"
		echo "No box was found in your hands."
		exit
	else
		if use_spell_704
			cast_704_at_box.call
		else
			echo "Checking for traps."
			tpick_drop_box(current_box) if solo_or_other == "ground"
			check_for_trap.call
		end
	end
}

where_to_stow_box = proc{
	if solo_or_other == "solo"
		if stow_in_disk
			fput "put ##{current_box.id} in #{checkname} disk"
		else
			tpick_stow_box(current_box)
		end
	end
}

gnomish_bracers_trap_check_result = proc{
	waitrt?
	result = dothistimeout "rub my #{gnomish_bracers}", 3, /begins to glow with a deep red light|begins to glow with a bright green light/
	if result =~ /begins to glow with a deep red light/
		waitrt?
		manually_disarm_trap.call
	elsif result =~ /begins to glow with a bright green light/
		waitrt?
		if (disarm_only)
			if (bash_open_boxes)
				bash_the_box_open.call
			else
				box_counts_for_math = nil
				tpick_drop_box(current_box)
			end
		else
			measure.call
		end
	elsif result.nil?
		gnomish_bracers_trap_check_result.call
	end
}

gnomish_bracers_trap_check = proc{
	if solo_or_other != "ground" && solo_or_other != "worker"
		wait_until { GameObj.right_hand.id != nil}
		current_box = GameObj.right_hand
	end
	tpick_get_box(current_box) if solo_or_other == "ground"
	if solo_or_other == "worker" && current_box.nil?
		until current_box
			dothistimeout "look on ##{table.id}", 3, /^On the/
			table.contents.each{ |item|
				if item.name =~ /#{checkname}/
					current_box = item
					break
				end
			}
			if current_box.nil?
				table.contents.each{ |item|
					fput "tap ##{item.id}"
					while line = get
						if line =~ /^You probably shouldn\'t do that\./
							break
						elsif line =~ /^You tap/
							current_box = item
							break
						end
					end
					break if current_box
				}
			end
			sleep 1
		end
		echo "Found your box/plinite! Name: #{current_box}, ID: #{current_box.id}, tip: #{offered_tip_amount}, critter name: #{critter_name}, critter level: #{critter_level}"
	end
	gnomish_bracers_trap_check_result.call
}

check_for_trap = proc{
	tpick_cast_spells (402)
	tpick_cast_spells (404)
	current_trap_type = nil
	tpick_prep_spell(416, "Piercing Gaze")
	fput "cast at ##{current_box.id}"
	while line = get
		if line =~ /Peering closely into the lock\, you spy an? [a-zA-Z]+ (.*) scarab wedged into the lock mechanism\./
			scarab_name = $1
			current_trap_type = "scarab"
			CharSettings['scarab'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /You notice what appears to be a sharp sliver of metal nestled in a hole next to the lock plate\./
			current_trap_type = "needle"
			CharSettings['needle'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /You notice a discolored oval ring around the outside of the.*which makes you suspicious\.\s+Your suspicions are confirmed when you look inside the keyhole and notice the spring\-loaded jaws pressed flush against the.*walls\./
			current_trap_type = "jaws"
			CharSettings['jaws'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /You see a tiny sphere imbedded in the lock mechanism\./
			current_trap_type = "sphere"
			CharSettings['sphere'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /You can see a small crystal imbedded in the locking mechanism\./
			current_trap_type = "crystal"
			CharSettings['crystal'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /You see a cord stretched between the lid and case\./
			current_trap_type = "scales"
			CharSettings['scales'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /Peering through the .*\, you notice that the lock casing is coated with a rough\, grainy substance\, and a small bladder is wedged between the tumblers of the lock\./
			current_trap_type = "sulphur"
			CharSettings['sulphur'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /Looking closely into the keyhole of the lock\, you spy a small vial of liquid and a tiny hammer device which seems poised to shatter it if the lock is tampered with\./
			current_trap_type = "cloud"
			CharSettings['cloud'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /You notice what appears to be a tiny vial placed just past the tumblers of the lock mechanism\.\s+It appears that any tampering with the lock mechanism will cause the tumblers to crush the vial\./
			current_trap_type = "acid vial"
			CharSettings['acid_vial'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /Peering through the .*\, you notice that the hinges have some springs incorporated into the design in an unusual fashion\./
			current_trap_type = "springs"
			CharSettings['springs'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /Looking closely into the keyhole of the lock\, you spy a small vial of fire\-red liquid and a tiny hammer device which seems poised to shatter it if the lock is tampered with\./
			current_trap_type = "fire vial"
			CharSettings['fire_vial'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /You see a thin tube extending from the lock mechanism down into the .*\.\s+The tube appears to be filled with a greenish powder\./
			current_trap_type = "spores"
			CharSettings['spores'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /There appears to be a plate over the lock\, sealing it and preventing any access to the tumblers\./
			current_trap_type = "plate"
			CharSettings['plate'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /Near the lock mechanism\, you notice a pair of small metal rods a hair\'s width from rubbing together\./
			current_trap_type = "rods"
			CharSettings['rods'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /The inside chamber is lined with some unidentifiable substance\./
			current_trap_type = "boomer"
			CharSettings['boomer'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /You gaze at the.*but your vision is obscured\./
			current_trap_type = "check again"
		elsif line =~ /Suddenly a dark splotch erupts from the lock mechanism and envelops you\!  Time seems to slow down and almost stop\.\.\./
			current_trap_type = "glyph"
			CharSettings['glyph'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /Roundtime/
			break
		end
	end
	if current_trap_type != "check again" && current_trap_type != nil
		echo "Found a #{current_trap_type} trap."
	end
	if current_trap_type == "check again"
		echo "Failed detecting a trap, trying again."
		check_for_trap.call
	elsif current_trap_type == "needle" || current_trap_type == "jaws" || current_trap_type == "plate"
		echo "Trap is safe to skip disarming."
		pop_open_box.call
	elsif current_trap_type == "crystal" || current_trap_type == "springs"
		echo "Trap is safe to use 408 on. Must be disarmed before popping."
		disarm_trap.call
	elsif current_trap_type == "scarab" || current_trap_type == "sphere" || current_trap_type == "scales" || current_trap_type == "acid vial" || current_trap_type == "fire vial" || current_trap_type == "spores" || current_trap_type == "boomer" || current_trap_type == "cloud" || current_trap_type == "rods"
		echo "408 might set off trap. Must be disarmed before popping."
		if UserVars.tpick["only_disarm_safe"] == "yes"
			echo "Skipping box due to tpick setting Only disarm safe is set to yes."
			where_to_stow_box.call
			box_opened = nil
		else
			disarm_trap.call
		end
	elsif current_trap_type == "sulphur"
		echo "Skipping box because 408 will set this trap off."
		where_to_stow_box.call
		box_opened = nil
	elsif current_trap_type == "glyph"
		echo "The box had a glyph trap on it. Taking you back to the room you started in."
		while checkroom =~ /Temporal Rift/
			move 'e'
			sleep 0.1
		end
		sleep 0.5
		start_script "go2", [starting_room]
		wait_while{ running?('go2') }
		echo "This box has a glyph trap and cannot be opened."
		where_to_stow_box.call
		box_opened = nil
	elsif current_trap_type == nil
		echo "No trap found."
		remaining_416_casts -= 1
		if remaining_416_casts < 1
			CharSettings['no_trap'] += 1
			CharSettings['total_trap_count'] += 1
			pop_open_box.call
		else
			echo "416 casts remaining: #{remaining_416_casts}."
			check_for_trap.call
		end
	end
}

fused_lock_disarm = proc{
	if Char.prof == 'Rogue'
		echo "Going to try wedging this box open."
		wedge_lock.call
	elsif Char.prof != 'Rogue' and !Spell[407].known?
		echo "Can't open this box."
		if solo_or_other == "solo"
			where_to_stow_box.call
		elsif solo_or_other == "other"
			tpick_say_cant
			open_others.call
		elsif solo_or_other == "ground"
			cant_open_plated_box_count += 1
			box_opened = nil
		elsif solo_or_other == "worker"
			nil
		end
	elsif Char.prof != 'Rogue' and Spell[407].known?
		tpick_get_box(current_box) if solo_or_other == "ground"
		echo "Going to try popping this box."
		cast_407.call
	end
}

pop_open_box = proc{
	box_is_open = nil
	echo "Popping box."
	loop{
		tpick_cast_spells (403) unless UserVars.tpick["always_use_403"] == "never"
		tpick_prep_spell(407, "Unlock")
		fput "cast at ##{current_box.id}"
		waitrt?
		while line = get
			if line =~ /The.*vibrates slightly but nothing else happens\.|Suddenly\, part of the.*face breaks away and a pair of gleaming jaws snap shut before the lockplate\!\s+Good thing your hand wasn\'t there\!|Roundtime/
				break
			elsif line =~ /You hear a soft click from the.*and it suddenly flies open\.|But the.*is already open\./
				box_is_open = true
				break
			end
		end
		break if box_is_open
	}
	open_solo.call if solo_or_other != "ground"
}

disarm_trap = proc{
	box_is_disarmed = nil
	loop{
		tpick_cast_spells (402)
		tpick_cast_spells (404)
		tpick_prep_spell(408, "Disarm")
		fput "cast at ##{current_box.id}"
		while line = get
			if line =~ /Now to isolate the offending mechanism and disable it\.\.\.The.*vibrates slightly but nothing else happens\.|You begin to probe the.*for unusual mechanisms\.\.\.The.*vibrates slightly but nothing else happens\./
				echo "Couldn't disarm trap. Tryin again."
				break
			elsif line =~ /Now to isolate the offending mechanism and disable it\.\.\.Your heart skips a beat as you hear a small sizzle from the.*keyhole\..*You begin to jump back\, but not in time as the entire.*explodes in a deafening\, fiery detonation\!/
				echo "The trap was set off! Script is now exiting."
				exit
			elsif line =~ /Now to isolate the offending mechanism and disable it\.\.\.The.*pulses once with a deep crimson light\!/
				box_is_disarmed = true
				echo "Box is disarmed."
				break
			end
		end
		break if box_is_disarmed
	}
	pop_open_box.call
}

fill_up_locksmith_container = proc{
	move 'out' if checkpaths 'out'
	start_script 'go2', [ 'bank', '--disable-confirm' ]
	wait_while{ running?('go2') }
	fput "unhide" if hidden?
	fput "depo all"
	fput "withdraw 1000"
	start_script 'go2', [ Room[Room.current.find_nearest_by_tag('locksmith')], '--disable-confirm' ]
	wait_while{ running?('go2') }
	waitrt?
	fput "order"
	while line = get
		if line =~ /\d+.*\s{2}(\d+).*locksmith\'s/
			order_number = $1
		elsif line =~ /(\d+).*locksmith\'s/
			order_number = $1
		end
		break if line =~ /You can APPRAISE/
	end
	stow_both.call
	wait_until { checkleft.nil? }
	wait_until { checkright.nil? }
	until checkright
		waitrt?
		fput "remove ##{locksmiths_container.id}"
		sleep 0.2
	end
	buy_locksmith_pouch.call
	if putty_remaining < 50 || cotton_remaining < 50
		buy_locksmith_pouch.call
	end
	fput "wear ##{locksmiths_container.id}"	
}

buy_locksmith_pouch = proc{
	fput "order #{order_number}"
	fput "buy"
	wait_until { checkleft }
	fput "bundle"
	trash_container = GameObj.loot.find { |trash| trash.name =~ trash_container }
	current_box = GameObj.left_hand
	if trash_container == nil
		tpick_drop_box(current_box)
	else
		fput "put ##{GameObj.left_hand.id} in #{trash_container}"
		sleep 0.2
		tpick_drop_box(current_box) if checkleft
	end
}

check_locksmiths_container = proc{
	action = proc { |server_string|
		if server_string =~ /lump of squishy white putty with about (\d+) pinch|(\d+) little ball|(\d+) vials? of liquid|you see a pinch of squishy white putty/
			if server_string =~ /you see a lump of squishy white putty with about (\d+) pinch/
				putty_remaining = $1.to_i
			elsif server_string =~ /you see a pinch of squishy white putty/
				putty_remaining = 1
			else 
				putty_remaining = 0
			end
			if server_string =~ /(\d+) little ball/
				cotton_remaining = $1.to_i
			else
				cotton_remaining = 0
			end
			if server_string =~ /(\d+) vials? of liquid/
				vials_remaining = $1.to_i
			else
				vials_remaining = 0
			end
			DownstreamHook.remove("#{script.name}_check_locksmiths_container")
			nil
		elsif server_string =~ / and /
			(putty_remaining = 0) unless (putty_remaining)
			(cotton_remaining = 0) unless (cotton_remaining)
			(vials_remaining = 0) unless (vials_remaining)
			DownstreamHook.remove("#{script.name}_check_locksmiths_container")
			server_string
		else
			server_string
		end
	}
		DownstreamHook.add("#{script.name}_check_locksmiths_container", action)
		silence_me
		if running? "sorter"
			kill_script "sorter"
			wait_until { !running? "sorter" }
			start_sorter = true
		end
		fput "look in ##{locksmiths_container.id}"
		silence_me
}

do_relock_boxes = proc{
	waitrt?
	tpick_get_box(current_box) if solo_or_other == "ground"
	fput "get ##{$vaalin_lockpick_id}"
	fput "close ##{current_box.id}"
	fput "lm relock ##{current_box.id}"
	tpick_drop_box(current_box) if solo_or_other == "ground"
	fput "put ##{$vaalin_lockpick_id} in ##{lockpick_container.id}"
}

cast_407 = proc{
	if current_box.name =~ /enruned|mithril/i || box_is_enruned_or_mithril || UserVars.tpick["always_use_407"] =~ /no/i
		echo "Can't open this plated box because it is mithril or enruned or because your settings are set to not use 407 to open boxes."
		if solo_or_other == "solo"
			where_to_stow_box.call
			stow_both.call
			sleep 0.1
		elsif solo_or_other == "other"
			tpick_say_cant
			open_others.call
		elsif solo_or_other == "ground"
			tpick_drop_box(current_box)
			cant_open_plated_box_count += 1
			box_opened = nil
		elsif solo_or_other == "worker"
			ask_worker.call
		end
	else
		if checkmana < 10
			echo "Waiting for mana."
			wait_until { checkmana >= 10 }
		end
		tpick_cast_spells (403) unless UserVars.tpick["always_use_403"] == "never"
		tpick_prep_spell(407, "Unlock")
		result = dothistimeout "cast ##{current_box.id}", 4, /vibrates slightly but nothing else happens.|(suddenly flies open.|is already open.)/i
		if result =~ /(suddenly flies open.|is already open.)/i
			if solo_or_other == "solo"
				open_solo.call
			elsif solo_or_other == "other"
				open_others.call
			elsif solo_or_other == "ground"
				tpick_drop_box(current_box)
			elsif solo_or_other == "worker"
				nil
			end
		elsif result =~ /vibrates slightly but nothing else happens./i || result.nil?
			cast_407.call
		end
	end
}

wedge_lock = proc{
	waitrt?
	tpick_get_box(current_box) if solo_or_other == "ground" && checkright == nil
	if Char.prof == 'Rogue'
		3.times{
			waitrt?
			unless GameObj.right_hand.name =~ /wedge/ || GameObj.left_hand.name =~ /wedge/
				fput "get my wedge"
				sleep 0.2
			end
		}
	end
	if GameObj.right_hand.name !~ /wedge/ && GameObj.left_hand.name !~ /wedge/
		if UserVars.tpick["always_use_407"] =~ /no/i or !Spell[407].known?
			if solo_or_other == "other"
				tpick_say_cant
				open_others.call
			elsif solo_or_other == "ground"
				echo "Couldn't open this box."
				box_opened = nil
			elsif solo_or_other == "solo"
				echo "Couldn't open this box."
				where_to_stow_box.call
				stow_both.call
				sleep 0.1
			elsif solo_or_other == "worker"
				echo "Couldn't open this box."
				ask_worker.call
			end
		else
			if Char.prof == 'Rogue'
				echo "Couldn't find any wedges, going to try popping this box."
			else
				echo "Going to try popping this box."
			end
			cast_407.call
		end
	else
		result = dothistimeout "lmaster wedge ##{current_box.id}", 3, /What do you expect to wedge it with|(suddenly splits away from the casing|Why bother)|Roundtime/i
		if result =~ /What do you expect to wedge it with/i
			stow_wedge.call
			wedge_lock.call
		elsif result =~ /(suddenly splits away from the casing|Why bother)/i
			stow_wedge.call
			open_solo.call if solo_or_other == "solo"
			open_others.call if solo_or_other == "other"
			tpick_drop_box(current_box) if solo_or_other == "ground"
		elsif result =~ /Roundtime/i || result.nil?
			wedge_lock.call
		end
	end
}

calibrate = proc{
	echo "Calibrating calipers."
	3.times{
		waitrt?
		unless GameObj.right_hand.name =~ /calipers/ || GameObj.left_hand.name =~ /calipers/
			fput "get my calipers"
			sleep 0.2
		end
	}
	if GameObj.right_hand.name !~ /calipers/ && GameObj.left_hand.name !~ /calipers/
		echo "Couldn't find your calipers."
		exit
	end
	result = dothistimeout "lmas calibrate my calipers", 4, /You\'re good\, but you\'re not that good\.|You should leave them alone.|Roundtime/i
	if result =~ /You\'re good\, but you\'re not that good\.|You should leave them alone./i
		stow_calipers.call
	elsif result =~ /Roundtime/i
		waitrt?
		calibrate.call if can_use_calipers
	elsif result.nil?
		calibrate.call
	end
}

check_for_lockpicks_etc = proc {
	action = proc { |server_string|
		if server_string =~ /\s{2}.*(an?|the|some) |\s{6}.*(an?|the|some) |^You are currently wearing and carrying\:/
			if server_string =~ /\<a exist\=\"(\d+)" noun\=\".*\"\>(.*)\<\/a\>/
				temp_id = $1
				temp_name = $2
				copper_lock_pick_array.push(temp_id) if temp_copper_lockpicks_array.include?(temp_name)
				steel_lock_pick_array.push(temp_id) if temp_steel_lockpicks_array.include?(temp_name)
				gold_lock_pick_array.push(temp_id) if temp_gold_lockpicks_array.include?(temp_name)
				silver_lock_pick_array.push(temp_id) if temp_silver_lockpicks_array.include?(temp_name)
				mithril_lock_pick_array.push(temp_id) if temp_mithril_lockpicks_array.include?(temp_name)
				ora_lock_pick_array.push(temp_id) if temp_ora_lockpicks_array.include?(temp_name)
				glaes_lock_pick_array.push(temp_id) if temp_glaes_lockpicks_array.include?(temp_name)
				laje_lock_pick_array.push(temp_id) if temp_laje_lockpicks_array.include?(temp_name)
				vultite_lock_pick_array.push(temp_id) if temp_vultite_lockpicks_array.include?(temp_name)
				rolaren_lock_pick_array.push(temp_id) if temp_rolaren_lockpicks_array.include?(temp_name)
				veniom_lock_pick_array.push(temp_id) if temp_veniom_lockpicks_array.include?(temp_name)
				invar_lock_pick_array.push(temp_id) if temp_invar_lockpicks_array.include?(temp_name)
				alum_lock_pick_array.push(temp_id) if temp_alum_lockpicks_array.include?(temp_name)
				golvern_lock_pick_array.push(temp_id) if temp_golvern_lockpicks_array.include?(temp_name)
				kelyn_lock_pick_array.push(temp_id) if temp_kelyn_lockpicks_array.include?(temp_name)
				vaalin_lock_pick_array.push(temp_id) if temp_vaalin_lockpicks_array.include?(temp_name)
				$scale_trap_weapon_id = temp_id if temp_name =~ /^#{UserVars.tpick["scale_trap_weapon"]}$/
			end
			nil
		elsif server_string =~ /^\(\d+ items? displayed\.\)/
			DownstreamHook.remove("#{script.name}_check_for_lockpicks_etc")
			$tpick_boxes_checked = true
			nil
		else
			server_string
		end
	}
		DownstreamHook.add("#{script.name}_check_for_lockpicks_etc", action)
		silence_me
		fput "inv full"
		silence_me
}

check_for_boxes = proc {
	action = proc { |server_string|
		if server_string =~ /\s{6}.*(an?|the|some) |\s{2}.*(an?|the|some) |^You are currently wearing and carrying\:/
			if (server_string =~ /(\s{6}.*(an?|the|some)|\s{2}.*(an?|the|some)).*exist="(\d+)".*(plinite)/) && (open_plinites)
				$tpick_list_of_box_ids.push($4)
			elsif (server_string =~ /(\s{6}.*(an?|the|some)|\s{2}.*(an?|the|some)).*exist="(\d+)" noun="(strongbox|box|chest|trunk|coffer)".*/) && (open_plinites == nil)
				$tpick_list_of_box_ids.push($4)
			end
			nil
		elsif server_string =~ /^\(\d+ items? displayed\.\)/
			DownstreamHook.remove("#{script.name}_check_for_boxes")
			$tpick_boxes_checked = true
			nil
		elsif server_string =~ /You glance down to see.*mithril|enruned.*/
			check_hands_status = "mithril or enruned"
			DownstreamHook.remove("#{script.name}_check_for_boxes")
			nil
		elsif server_string =~ /You glance down.*left hand.*/
			check_hands_status = "good"
			DownstreamHook.remove("#{script.name}_check_for_boxes")
			nil
		elsif server_string =~ /You glance down at your empty hands\./
			check_hands_status = "empty"
			DownstreamHook.remove("#{script.name}_check_for_boxes")
			nil
		else
			server_string
		end
	}
		DownstreamHook.add("#{script.name}_check_for_boxes", action)
		silence_me
		fput "#{check_for_command}"
		silence_me
}

cast_205 = proc{
	if checkmana < 5
		echo "Waiting for mana."
	end
	Spell[205].cast
}

stuff_to_do = proc{
	if (UserVars.tpick["rest_percent"].to_i <= percentmind) && (UserVars.tpick["rest_percent"].length > 0)
		echo "Resting until mind reaches #{UserVars.tpick["pick_percent"]}%."
		wait_until { UserVars.tpick["pick_percent"].to_i >= percentmind }
	end
}

start_values_nilled = proc{
	scale_trap_found = nil
	current_trap_type = nil
	second_trap_check = nil
	found_true_lock_difficulty = nil
}

start_solo = proc{
	total_boxes_count.call
	$tpick_list_of_box_ids.each{ |box|
		tpick_stop_403_404
		fput "get ##{box}"
		start_time = Time.now
		critter_name = nil
		start_values_nilled.call
		stuff_to_do.call
		number_of_manual_trap_checks_remaining = UserVars.tpick["number_of_times_to_check_for_traps"].to_i
		if (gnomish_bracers) && (bracers_tier == "2")
			gnomish_bracers_trap_check.call
		else
			manually_disarm_trap.call
		end
	}
	check_disk.call
}

encumbrance_check = proc{
	if percentencumbrance > 99
		starting_room_number = Room.current.id
		start_script 'go2', [ 'bank', '--disable-confirm' ]
		wait_while{ running?('go2') }
		fput "depo all"
		start_script "go2", [starting_room_number]
		wait_while{ running?('go2') }
	end
}

start_worker = proc{
	stow_both.call
	stuff_to_do.call
	current_box = nil
	waitrt?
	if worker.nil?
		echo "Get yourself to a worker who assigns you box jobs."
		exit
	end
	encumbrance_check.call if UserVars.tpick["auto_deposit_silvers"] =~ /yes/i
	fput "ask ##{worker.id} for job"
	offered_tip_amount = nil
	while line = get
		if line =~ /says\, \"You should finish the job you\'re working on first\.  If you\'re done\, ask me to CHECK it for you\.\"/
			next_task = nil
			break
		elsif line =~ /says\, \"Ah\, here we are\.  The client is offering a tip of (.*) silvers? and mentioned it being from [a-zA-Z]+ (.*) \(level (\d+)\)\./
			offered_tip_amount = $1.delete(",").to_i	
			critter_name = $6
			critter_level = $7.to_i
			next_task = nil
			break
		elsif line =~ /says\, \"Ah\, here we are\.  The client is offering a tip of (.*) silvers? and they aren't sure where it came from/
			offered_tip_amount = $1.delete(",").to_i	
			critter_level = 1
			next_task = nil
			break
		elsif line =~ /says\, \"You\'ve done enough boxes for now\.  Why don\'t you ask me again a few minutes from now\.\"/ || line =~ /says\, \"You\'ve done enough for a while\.  Why don\'t you rest your mind a bit\?\"/
			next_task = "2 minutes"
			break
		elsif line =~ /says\, \"You\'ve done enough boxes for now\.  Why don\'t you ask me again about a minute from now\.\"/
			next_task = "minute"
			break
		elsif line =~ /says\, \"We don't have any jobs for you at the moment\./ || line =~ /says\, \"You haven\'t quite reflected on your past failure\.|says\, \"You\'ve done enough/
			next_task = "wait"
			break
		end
	end
	if next_task == "wait"
		echo "No boxes available at the moment, waiting 30 seconds and trying again."
		sleep 30
		start_worker.call
	elsif next_task == "minute"
		echo "No boxes available at the moment, waiting 60 seconds and trying again."
		sleep 60
		start_worker.call
	elsif next_task == "2 minutes"
		echo "No boxes available at the moment, waiting 120 seconds and trying again."
		sleep 120
		start_worker.call
	else
		start_worker2.call
	end
}
	
start_worker2 = proc{
	if offered_tip_amount < minimum_tip_wanted
		echo "Minimum tip wanted not met, turning in box."
		ask_worker.call
		ask_worker.call
		start_worker.call
	elsif critter_level > max_critter_level
		echo "Critter level too high, turning in box."
		ask_worker.call
		ask_worker.call
		start_worker.call
	else
		tpick_stop_403_404
		start_values_nilled.call
		number_of_manual_trap_checks_remaining = UserVars.tpick["number_of_times_to_check_for_traps"].to_i
		if (gnomish_bracers) && (bracers_tier == "2")
			gnomish_bracers_trap_check.call
		else
			manually_disarm_trap.call
		end
		ask_worker.call
		start_worker.call
	end
}

start_others = proc{
	waitfor "has accepted your offer" if checkright != nil
	waitrt?
	fput "accept"
	while line = get
		if line =~ /^You accept ([a-zA-Z]+)\'s offer and are now holding.*\.$/i || line =~ /^([a-zA-Z]+) offers you (.*) (box|strongbox|coffer|chest|trunk).  Click ACCEPT to accept the offer or DECLINE to decline it.  The offer will expire in 30 seconds\.$/
			person = $1
			fput "accept" if line =~ /^([a-zA-Z]+) offers you (.*) (box|strongbox|coffer|chest|trunk).  Click ACCEPT to accept the offer or DECLINE to decline it.  The offer will expire in 30 seconds\.$/
			start_time = Time.now
			tpick_stop_403_404
			critter_name = nil
			start_values_nilled.call
			number_of_manual_trap_checks_remaining = UserVars.tpick["number_of_times_to_check_for_traps"].to_i
			if (gnomish_bracers) && (bracers_tier == "2")
				gnomish_bracers_trap_check.call
			else
				manually_disarm_trap.call
			end
			break
		end
	end
}

total_boxes_count = proc{
	total_boxes_number = 0
	if solo_or_other == "ground"
		GameObj.loot.each { |item|
			(total_boxes_number += 1) if (item.type == "box" && !all_box_ids_already_picked.include?(item.id))
		}
	elsif solo_or_other == "solo"
		total_boxes_number = $tpick_list_of_box_ids.length
		unless disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk|coffin/ }
			echo "Waiting 4 seconds for disk"
			40.times { break if GameObj.loot.any? { |obj| obj.name =~ /#{Char.name} disk|coffin/ }; sleep 0.1 }
				disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk|coffin/ }
			end
		(echo "No disk found.") if (disk == nil)
		already_checked_for_disk = true
		if (disk) && (disk.contents.nil?)
			dothistimeout "look in ##{disk.id}", 3, /In the|There is nothing in/
		end
		disk.contents.each{|item|
			if item.type =~ /box/i
				total_boxes_number += 1
			end
		}
	end
	total_boxes_picked_math.call
}

bash_the_box_open = proc{
	echo "Bashing open box."
	waitrt?
	result = dothistimeout "open ##{current_box.id}", 3, /That is already open\.|You open|It appears to be locked\./i
	if result =~ /That is already open\.|You open/
		box_counts_for_math = nil
		box_was_not_locked = true
	elsif result =~ /It appears to be locked\./ 
		fput "get my #{UserVars.tpick["bashing_weapon"]}"
		until current_box.status == "gone"
			waitrt?
			fput "bash ##{current_box.id}"
			waitrt?
			sleep 0.2
		end
	elsif result.nil?
		bash_the_box_open.call
	end	
}

coins_from_boxes_comma_nonsense = proc{
	if total_silvers_from_box < 625
		sleep 0.1
	else
		while line = get
			if line =~ /Roundtime\: (\d+) sec/
				sleep ($1.to_i + 1)
				break
			end
		end									
	end
	waitrt?
}

gather_stuff = proc{
	waitrt?
	if current_item.name =~ /coins/
		finished_getting_coins = nil
		loop{
			break if finished_getting_coins
			fput "get ##{current_item.id}"
			while line = get
				if line =~ /You gather the remaining (.*) coins?/
					total_silvers_from_box = $1.delete(",").to_i
					coins_from_boxes_comma_nonsense.call
					finished_getting_coins = true
					break
				elsif line =~ /^You can only collect (.*) of the coins due to your load\./
					total_silvers_from_box = $1.delete(",").to_i
					echo "You can't carry anymore silvers!"
					coins_from_boxes_comma_nonsense.call
					finished_getting_coins = true
					break
				elsif line =~ /^You cannot hold any more silvers\./
					echo "You can't carry anymore silvers!"
					finished_getting_coins = true
					break
				elsif line =~ /^You gather (.*) of the coins?/
					total_silvers_from_box = $1.delete(",").to_i
					coins_from_boxes_comma_nonsense.call
					break
				end
			end
		}
	else
		if picking_up
			fput "stow left"
		else
			fput "get ##{current_item.id}"
		end
	end
}

start_ground = proc{
	total_boxes_count.call
	GameObj.loot.each{ |box|
		if box.type =~ /box/ && !all_box_ids_already_picked.include?(box.id)
			all_box_ids_already_picked.push(box.id) unless all_box_ids_already_picked.include?(box.id)
			box_opened = true
			current_box = box
			tpick_stop_403_404
			if (UserVars.tpick["rest_percent"].to_i <= percentmind) && (UserVars.tpick["rest_percent"].length > 0)
				echo "Resting until mind reaches #{UserVars.tpick["pick_percent"]}%."
				wait_until { UserVars.tpick["pick_percent"].to_i >= percentmind }
			end
			waitrt?
			box_was_not_locked = nil
			start_time = Time.now
			critter_name = nil
			start_values_nilled.call
			number_of_manual_trap_checks_remaining = UserVars.tpick["number_of_times_to_check_for_traps"].to_i
			if popping
				current_box = current_box.id
				pop_boxes_begin.call
			elsif bash_open_boxes
				if disarm_only
					if (gnomish_bracers) && (bracers_tier == "2")
						gnomish_bracers_trap_check.call
					else
						manually_disarm_trap.call
					end
				else
					bash_the_box_open.call
				end
			else
				if (gnomish_bracers) && (bracers_tier == "2")
					gnomish_bracers_trap_check.call
				else
					manually_disarm_trap.call
				end
			end
			update_math_information = true
			total_boxes_picked_math.call
			if ground_loot
				encumbrance_check.call if UserVars.tpick["auto_deposit_silvers"] =~ /yes/i
				if (bash_open_boxes) && (box_was_not_locked == nil)
					GameObj.loot.each{ |item|
						current_item = item
						waitrt?
						if (item.name !~ /urglaes fang|doomstone|disk|coffin|stairs/) && (item.type != "box")
							gather_stuff.call
						end
						waitrt?
						if item.name !~ /coins/i && UserVars.tpick["log"] == "yes"
							record_item_data.call
						end
						if (item.name !~ /urglaes fang|doomstone|disk|coffin|stairs|coins/) && (item.type != "box")
							if UserVars.tpick["auto_bundle_vials"] == "yes" && item.name =~ /vial/ && (GameObj.right_hand.name =~ /vial/ || GameObj.left_hand.name =~ /vial/)
								check_locksmiths_container.call
								wait_until { vials_remaining }
								start_script "sorter" if start_sorter
								if vials_remaining < 10
									if GameObj.right_hand.name =~ /vial/
										current_vial = GameObj.right_hand.id
									elsif GameObj.left_hand.name =~ /vial/
										current_vial = GameObj.left_hand.id
									end
									fput "stow ##{current_vial}"
									sleep 0.2
									stow_both.call
									wait_until { checkleft == nil }
									wait_until { checkright == nil }
									fput "remove ##{locksmiths_container.id}"
									wait_until { checkright != nil }
									fput "get ##{current_vial}"
									wait_until { checkleft != nil }
									fput "bundle"
									fput "wear ##{locksmiths_container.id}"
									wait_until { checkright == nil }			
								end
							else
								if (item.type =~ /gem/) && (gem_container)
									fput "put #{item} in ##{gem_container.id}"
								else
									fput "stow #{item}"
								end
							end
						end
						waitrt?
					}
				elsif (box_opened) || (box_was_not_locked)
					waitrt?
					(tpick_cast_spells (506)) if (use_spell_506)
					total_boxes_picked += 1
					fput "open ##{current_box.id}" unless popping
					(dothistimeout "look in ##{box.id}", 10, /In .*? you see|In the .*\:|There is nothing in/i) if box.contents.nil?
					box.contents.each{ |item|
						current_item = item
						waitrt?
						if (item.name !~ /urglaes fang/) && (item.name !~ /doomstone/)
							gather_stuff.call
						end
						waitrt?
						if item.name !~ /coins/i && UserVars.tpick["log"] == "yes"
							record_item_data.call
						end
						if item.name !~ /coins/i && item.name !~ /urglaes fang/ && item.name !~ /doomstone/
							if UserVars.tpick["auto_bundle_vials"] == "yes" && item.name =~ /vial/ && (GameObj.right_hand.name =~ /vial/ || GameObj.left_hand.name =~ /vial/)
								check_locksmiths_container.call
								wait_until { vials_remaining }
								start_script "sorter" if start_sorter
								if vials_remaining < 10
									if GameObj.right_hand.name =~ /vial/
										current_vial = GameObj.right_hand.id
									elsif GameObj.left_hand.name =~ /vial/
										current_vial = GameObj.left_hand.id
									end
									fput "stow ##{current_vial}"
									sleep 0.2
									stow_both.call
									wait_until { checkleft == nil }
									wait_until { checkright == nil }
									fput "remove ##{locksmiths_container.id}"
									wait_until { checkright != nil }
									fput "get ##{current_vial}"
									wait_until { checkleft != nil }
									fput "bundle"
									fput "wear ##{locksmiths_container.id}"
									wait_until { checkright == nil }			
								end
							else
								if (item.type =~ /gem/) && (gem_container)
									fput "put #{item} in ##{gem_container.id}"
								else
									fput "stow #{item}"
								end
							end
						end
						waitrt?
					}
					if relock_boxes
						do_relock_boxes.call
					end
					garbage_check.call
				end
			else
				if popping
					nil
				else
					fput "open ##{current_box.id}" if (box_opened) && (disarm_only == nil)
					fput "drop ##{current_box.id}" if GameObj.right_hand.id == current_box.id
				end
			end
			stow_both.call
		end
	}
	if check_all_ground_boxes_again
		check_all_ground_boxes_again = nil
		echo "Checking for boxes I might have missed."
		start_ground.call
	else
		echo "All done!"
		echo "Couldn't open #{cant_open_plated_box_count} box(es), which are still on the ground." if cant_open_plated_box_count > 0
		exit
	end
}

check_disk = proc{
	stow_in_disk = true
	unless disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk|coffin/ }
		if already_checked_for_disk.nil?
			echo "Waiting 4 seconds for disk"
			40.times { break if GameObj.loot.any? { |obj| obj.name =~ /#{Char.name} disk|coffin/ }; sleep 0.1 }
				disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk|coffin/ }
			end
		end
	if disk == nil
		echo "No disk found." if already_checked_for_disk.nil?
		exit
	end
	if disk and disk.contents.nil?
		dothistimeout "look in ##{disk.id}", 3, /In the|There is nothing in/
	end
	disk.contents.each{|item|
		if item.type =~ /box/i
			waitrt?
			if popping
				current_box = item.id
				pop_boxes_begin.call
			else
				fput "get ##{item.id}"
				start_time = Time.now
				critter_name = nil
				start_values_nilled.call
				number_of_manual_trap_checks_remaining = UserVars.tpick["number_of_times_to_check_for_traps"].to_i
				if (gnomish_bracers) && (bracers_tier == "2")
					gnomish_bracers_trap_check.call
				else
					manually_disarm_trap.call
				end
			end
		end
	}
}

count_boxes_in_disk = proc{
	stow_in_disk = true
	unless disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk|coffin/ }
		echo "Waiting 4 seconds for disk"
		40.times { break if GameObj.loot.any? { |obj| obj.name =~ /#{Char.name} disk|coffin/ }; sleep 0.1 }
			disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk|coffin/ }
		end
	if disk and disk.contents.nil?
		dothistimeout "look in ##{disk.id}", 3, /In the|There is nothing in/
	end
	disk.contents.each{|item|
		if item.type =~ /box/i
			total_number_of_boxes += 1
			$tpick_list_of_box_ids.push(item.id)
		end
	}
}

manually_disarm_trap = proc{
	waitrt?
	if solo_or_other == "worker" && current_box.nil?
		until current_box
			dothistimeout "look on ##{table.id}", 3, /^On the/
			table.contents.each{ |item|
				if item.name =~ /#{checkname}/
					current_box = item
					break
				end
			}
			if current_box.nil?
				table.contents.each{ |item|
					fput "tap ##{item.id}"
					while line = get
						if line =~ /^You probably shouldn\'t do that\./
							break
						elsif line =~ /^You tap/
							current_box = item
							break
						end
					end
					break if current_box
				}
			end
			sleep 1
		end
		echo "Found your box/plinite! Name: #{current_box}, ID: #{current_box.id}, tip: #{offered_tip_amount}, critter name: #{critter_name}, critter level: #{critter_level}"
	end
	if current_box.name =~ /plinite/
		detect_plinite.call
	else
		if second_trap_check
			echo "Attempting to disarm trap."
		else
			echo "Checking for traps."
			need_403 = nil
			need_404 = nil
		end
		if (current_trap_type == "sphere") || (current_trap_type == "Sphere trap found, need to use lockpick to disarm.")
			3.times{
				waitrt?
				unless GameObj.right_hand.id == $vaalin_lockpick_id || GameObj.left_hand.id == $vaalin_lockpick_id
					fput "get ##{$vaalin_lockpick_id}"
					sleep 0.2
				end
			}
			if GameObj.right_hand.id != $vaalin_lockpick_id && GameObj.left_hand.id != $vaalin_lockpick_id
				echo "Couldn't find your #{UserVars.tpick["vaalin"]}."
				exit
			end
		end
		waitrt?
		(tpick_cast_spells (402)) if (use_spell_402)
		(tpick_cast_spells (404)) if (use_spell_404) || (need_404)
		(tpick_cast_spells (506)) if (use_spell_506)
		(tpick_cast_spells (613)) if (use_spell_613)
		(tpick_cast_spells (1006)) if (use_spell_1006)
		trap_difficulty = nil
		trap_cant_be_disarmed = nil
		if solo_or_other != "ground" && solo_or_other != "worker"
			wait_until { GameObj.right_hand.id}
			current_box = GameObj.right_hand
		end
		waitrt?
		sleep 1
		waitrt?
		sleep 0.3
		waitrt?
		sleep 0.1
		waitrt?
		if current_trap_type == "scarab"
			all_scarab_ids = Array.new
			GameObj.loot.each{ |i|
				all_scarab_ids.push(i.id) if i.noun == "scarab"
			}
		end
		#if current_trap_type == "scarab"
		#same_scarab_found = GameObj.loot.find{ |i| i.name =~ /#{scarab_name}/ && i.noun == "scarab" }
		#if same_scarab_found
		#	echo "Another scarab like yours is already on the ground, waiting up to 10 seconds for it to go away."
		#	10.times{
		#		same_scarab_found = GameObj.loot.find{ |i| i.name =~ /#{scarab_name}/ && i.noun == "scarab" }
		#		break if same_scarab_found.nil?
		#		sleep 1
		#	}
		#end
		tpick_say_scarab_found if current_trap_type == "scarab"
		fput "disarm ##{current_box.id}"
		while line = get
			if line =~ /\(.*\-(\d+)\)\./
				trap_difficulty = $1.to_i
				disarm_skill_plus_lore = (disarm_skill + disarm_lore)
				total_trap_skill = (disarm_skill + disarm_lore + UserVars.tpick["trap_roll"].to_i)
				if second_trap_check == nil
					echo "Trap difficulty is: #{trap_difficulty}"
					echo "Your disarm skill is: #{disarm_skill}"
					echo "Your total disarm skill with lore is: #{disarm_skill_plus_lore}"
					echo "Highest trap you are willing to try is: #{total_trap_skill}"
				end
				if trap_difficulty > total_trap_skill
					trap_cant_be_disarmed = true
				elsif use_404_for_trap_difficulty && Spell[404].known?
					if trap_difficulty > use_404_for_trap_difficulty
						if second_trap_check.nil?
							echo "Trap difficulty is higher than your setting in the setup menu for when to use Disarm Enhancement (404), going to use Disarm Enhancement (404)."
						end
						need_404 = "yes"
					end
				elsif trap_difficulty > disarm_skill && Spell[404].known?
					if second_trap_check.nil?
						echo "This trap looks tough, going to use Disarm Enhancement (404)."
					end
					need_404 = "yes"
				elsif trap_difficulty > disarm_skill && !Spell[404].known?
					trap_cant_be_disarmed = true
				end
	#####Is box enruned or mithril?
			elsif line =~ /You carefully begin to examine (.*) for traps\.\.\./
				box_is_enruned_or_mithril = nil
				box_is_enruned_or_mithril = true if $1 =~ /enruned|mithril/
	#####Failed to disarm box
			elsif line =~ /Having discovered a trap on the.*(box|strongbox|chest|trunk|coffer) you begin to carefully attempt to disarm it\.\.\./
				current_trap_type = "Couldn't disarm trap, trying again."
	#####Scarab information#####
			#Manual detection
			elsif line =~ /Peering closely into the lock\, you spy an? [a-zA-Z]+ (.*) scarab wedged into the lock mechanism\./
				scarab_name = $1
				CharSettings['scarab'] += 1
				CharSettings['total_trap_count'] += 1
				current_trap_type = "scarab"
			#Successful manual disarm
			elsif line =~ /You carefully nudge the scarab free of its prison without disturbing the lock too much\.\s+The scarab falls from the lock and onto the ground in front of you\./
				current_trap_type = "Scarab trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /The lock appears to be free of all obstructions\./
				current_trap_type = "Scarab trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /Looking closely at the lock\, you spy.*scarab wedged into the lock mechanism\.\s+The scarab is surrounded by crimson glow\./
				current_trap_type = "Scarab trap has already been disarmed with 408."
				break
	#####Needle information#####
			#Manual detection
			elsif line =~ /Hmmm\, you can see what appears to be a tiny hole next to the lock plate which doesn\'t seem to belong there\.\s+Looking closer you see a gleaming sliver of metal recessed in the hole\./
				current_trap_type = "needle"
				CharSettings['needle'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /Using a bit of putty from your.*\, you manage to block the tiny hole in the lock plate\.|Using a pair of metal grips\, you carefully remove .* from .* and cover the tip with a bit of putty\./
				current_trap_type = "Needle trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /You see a tiny hole next to the lock plate which has been completely plugged\.|You can see what appears to be a tiny hole next to the lock plate which doesn\'t seem to belong there\.  However\, nothing about it seems to indicate cause for alarm\.|You spot a shiny metal needle sticking out of a small hole next to the lockplate with some sort of dark paste on it\./
				current_trap_type = "Needle trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /You can see what appears to be a tiny hole next to the lock plate which doesn\'t belong there\.\s+An occasional glint of red winks at you from within the hole\./
				current_trap_type = "Needle trap has already been disarmed with 408."
				break
	#####Jaws information#####
			#Manual detection
			elsif line =~ /You notice a discolored oval ring around the outside of the .*(box|strongbox|chest|trunk|coffer) which makes you suspicious\.\s+Your suspicions are confirmed when you look inside the keyhole and notice the spring\-loaded jaws pressed flush against the .*(box|strongbox|chest|trunk|coffer) walls\./
				current_trap_type = "jaws"
				CharSettings['jaws'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /Using the pair of metal grips\, you manage to pull out the two pins that hold the upper and lower jaw pieces together\.\s+As the pins are removed\, the jaws suddenly close and warp under the tremendous strain applied by their arming mechanism\.|Using the pair of metal grips\, you manage to pull out the two pins that hold the upper and lower jaw pieces together\.|Using your metal grips\, you carefully remove a pair of small steel jaws from the .*(box|strongbox|chest|trunk|coffer) before piecing the apparatus back together\./
				current_trap_type = "Jaws trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /You notice a discolored oval ring around the outside of the .*(box|strongbox|chest|trunk|coffer) which makes you suspicious\.\s+Your suspicions are confirmed when you look inside the keyhole and notice the spring\-loaded jaws pressed flush against the.*walls\, but the pins that hold the jaws together have been pushed out\.|You notice a discolored oval ring around the outside of the .*\, but further examination gives the impression that some vital part of whatever trap was here has been removed\./
				current_trap_type = "Jaws trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /You see a pair of metal jaws clamped tightly before the lockplate on the.*(box|strongbox|chest|trunk|coffer)\.|The jaws are surrounded with a reddish glow\./
				current_trap_type = "Jaws trap has already been disarmed with 408. Can't pick it."
				break
			#Trap has already been set off
			elsif line =~ /You see a pair of bloody jaws clamped tightly before the lockplate on the/
				current_trap_type = "Jaws trap has already been set off."
				break
	#####Sphere information#####
			#Manual detection
			elsif line =~ /Examining the .*(box|strongbox|chest|trunk|coffer)\, you locate.*sphere held in a metal bracket towards the back of the lock mechanism\..*It appears that were the tumblers to be activated\, the gem would be caught amongst them\./
				current_trap_type = "sphere"
				CharSettings['sphere'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /With utmost care\, you slip your.* into the lock and gently nudge the.*Another moment of prodding\, and you are able to poke the gem free of its metal housing\, whereupon it falls down into the lock mechanism and out of sight\.|With utmost care\, you slip your.* into the lock and gently nudge the.*Tilting the .*(box|strongbox|chest|trunk|coffer) forward\, you knock the gem free of its metal housing and poke it out through the back of the lock\, allowing it to gently roll down the inside of the .*(box|strongbox|chest|trunk|coffer)\'s front wall\./
				current_trap_type = "Sphere trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /A thorough search of the area inside the tumblers reveals what appears to be a metal bracket of some sort\, although it seems to be empty now\./
				current_trap_type = "Sphere trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /The sphere is surrounded by a crimson glow\./
				current_trap_type = "Sphere trap has already been disarmed with 408."
				break
			#Need pick in hand messaging
			elsif line =~ /No matter how you try\, your fingers are just too big to get back there to the gem\.\s+You\'ll need some sort of thin\, rigid implement like a lockpick\./
				current_trap_type = "Sphere trap found, need to use lockpick to disarm."
			#Setting off trap manually
			elsif line =~ /Suddenly\, you hear a sound like shattered crystal and .* light flashes from the lock mechanism\!/
				current_trap_type = "Sphere trap has been set off."
				echo "Sphere trap has been set off! Exiting."
				exit
			#Trap has already been set off
			elsif line =~ /A thorough and careful search of the lock mechanism indicates that the entire .* is MANGLED\. It\'s probably not trapped anymore\./
				current_trap_type = "Sphere trap has already been set off."
				break
	#####Crystal information#####
			#Manual detection
			elsif line =~ /Looking closely into the keyhole of the lock\, you spy.*crystal which seems imbedded in the locking mechanism\.\s+It looks as if opening the lock without the exact key could shatter it\./
				current_trap_type = "crystal"
				CharSettings['crystal'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /With a little ingenuity you manage to grind down parts of the lock mechanism with your metal file\, so it won\'t come in contact with the crystal when you try to open it\./
				current_trap_type = "Crystal trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /Looking closely into the keyhole of the lock\, you spy.*crystal which seems imbedded in the locking mechanism\.\s+It looks as if opening the lock without the exact key could shatter it\, but parts of the mechanism have been ground away to avoid unwanted contact with the crystal\./
				current_trap_type = "Crystal trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /You can see.*crystal imbedded in the locking mechanism\, with a slight reddish glow about it\./
				current_trap_type = "Crystal trap has already been disarmed with 408."
				break
	#####Scales information#####
			#Manual detection
			elsif line =~ /At first glance\, the.*(box|strongbox|chest|trunk|coffer) appears to be covered with hundreds of tiny metal scales\.\s+Closer examination reveals the \"scales\" to be razor sharp at the edges and possessing of a downward\-facing needlelike tip\.\s+However\, you should be able to avoid cutting yourself if you are careful\.|Despite heavy scrutiny\, you can see no way to pry off any of the scales\, nor any particular reason to\.\s+With a modicum of caution\, they should present no danger\.\s+Nothing else about the.*(box|strongbox|chest|trunk|coffer) suggests that it is trapped\./
				current_trap_type = "scales"
				CharSettings['scales'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /You gently slide your.*into the space under the lid and slice through the cord\.\s+That oughta do it\./
				current_trap_type = "Scales trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /Peering in through the crack between the lid and the casing\, you see what appears to be a thin cord dangling from the case\.\s+It looks to have been sliced through\./
				current_trap_type = "Scales trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /A crimson glow seeps between the lid and the casing of the .*(box|strongbox|chest|trunk|coffer)\./
				current_trap_type = "Scales trap has already been disarmed with 408."
				break
			#Need dagger in hand messaging
			elsif line =~ /You figure that if you had a dagger\, you could probably cut the cord\./
				current_trap_type = "Scales trap found, need to use dagger to disarm."
				break
	#####Sulphur information#####
			#Manual detection
			elsif line =~ /Feeling around the inside of the lock\, you notice that the casing is coated with a rough\, grainy substance\.\s+You lean forward and peer between the walls of the casing\.\s+Examining the lock closely\, you notice a small bladder filled with a strange liquid wedged between the tumblers\.\s+With your face this close to the lock\, you pick up the faintest scent of sulphur\./
				current_trap_type = "sulphur"
				CharSettings['sulphur'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /You carefully use the tip of a small metal file to scrape away the rough\, grainy substance which lines the walls of the casing\.\s+After a few moments\, you feel comfortable with the small section you have cleaned\.\s+You take out a thin needle and carefully slide it between the walls of the casing\, taking great care not to touch them\.\s+As the tip of the needle punctures the small bladder\, a strange clear gel oozes forth from the hole\.\s+The gel gives off a strong odor of sulphur\.\s+As the air hits the gel\, it begins to harden and turn to dust\, blowing away in the wind as if it never existed\./
				current_trap_type = "Sulphur trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /Feeling around the inside of the lock\, you notice that the casing is coated with a rough\, grainy substance\.\s+A small section of the casing has been scraped clean of the strange substance\.\s+You lean forward and peer between the walls of the casing\.\s+Examining the lock closely\, you notice a deflated bladder wedged between the tumblers\.\s+There is a small hole in the bladder\, most likely from whatever ruptured it\.\s+The lock emanates a strong scent of sulphur\./
				current_trap_type = "Sulphur trap has already been disarmed."
				break
			#Already disarmed with 408
			#TRAP CANNOT BE DISARMED WITH 408
	#####Cloud information#####
			#Manual detection
			elsif line =~ /Looking closely into the keyhole of the lock\, you spy a small vial of liquid and a tiny hammer device which seems poised to shatter it if the lock is tampered with\./
				current_trap_type = "cloud"
				CharSettings['cloud'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /Using the metal grips from your.*\, you manage to reach in and grasp the post of the metal hammer\, and bend the weak metal out of striking range of the vial\.|Having rendered the hammer harmless\, you carefully remove a green\-tinted vial filled with thick acrid smoke from the .*(box|strongbox|chest|trunk|coffer)\./
				current_trap_type = "Cloud trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /Looking closely into the keyhole of the lock\, you spy a tiny hammer device which has been bent back slightly\.|Looking closely into the keyhole of the lock\, you spy a small vial of liquid and a tiny hammer device which has been bent from striking range of the vial\./
				current_trap_type = "Cloud trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /Looking closely into the keyhole of the lock\, you spy a small vial of liquid and a tiny hammer device which has a red glow about it\./
				current_trap_type = "Cloud trap has already been disarmed with 408."
				break
	#####Acid vial information#####
			#Manual detection
			elsif line =~ /Peering closely into the lock\, you spy a tiny vial placed just past the tumblers of the lock mechanism\.\s+It would appear that any tampering with the lock mechanism would cause the tumblers to crush the vial and release whatever substance is inside\./
				current_trap_type = "acid vial"
				CharSettings['acid_vial'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /You carefully push a small ball of cotton into the lock mechanism\, surrounding and protecting the small vial from anything that may shatter it\.|Using a pair of metal grips\, you carefully remove the padded clear glass vial from the .*(box|strongbox|chest|trunk|coffer)\./
				current_trap_type = "Acid vial trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /Peering closely into the lock\, you spy a tiny vial placed just past the tumblers of the lock mechanism\.\s+A small ball of cotton has been pushed up against the vial\, protecting it from anything that may shatter it\.|Looking closely at the lock\, you spy a small metal housing set just inside the lock mechanism\, but it appears empty\.|Looking closely into the keyhole of the lock\, you spy a small metal housing\, which appears to be empty\./
				current_trap_type = "Acid vial trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /You notice what appears to be a tiny vial placed just past the tumblers of the lock mechanism\.\s+A crimson glow surrounds the vial\.|Looking closely at the lock\, you spy a tiny vial set just inside the lock mechanism\.\s+The vial is surrounded by crimson glow\./
				current_trap_type = "Acid vial trap has already been disarmed with 408."
				break
			#Setting off trap manually
			elsif line =~ /You peer inside the lock and see that the tumblers have all been fused into a lump of useless metal/
				current_trap_type = "Acid vial trap has been set off."
				break
			#Trap has already been set off
			elsif line =~ /You peer inside the lock and see that the tumblers have been fused into a lump of useless metal./
				current_trap_type = "Acid vial trap has already been set off."
				break
	#####Springs information#####
			#Manual detection
			elsif line =~ /After carefully examining the lock\, you move on to the hinges of the .*(box|strongbox|chest|trunk|coffer)\.\s+Just as you were to pass the.*(box|strongbox|chest|trunk|coffer) off as safe\, you notice what appears to be the ends of springs incorporated with the hinges\.\s+Seems rather odd to have.*(box|strongbox|chest|trunk|coffer) designed to spring open when it is unlocked\./
				current_trap_type = "springs"
				CharSettings['springs'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /With a little force applied to the springs\, you manage to pop them inside the.*(box|strongbox|chest|trunk|coffer)\, from within which comes the tinkle of breaking glass\, followed by a strong acrid smell\.|With a little force applied to the springs\, you manage to pop them inside.*(box|strongbox|chest|trunk|coffer)\, where they bounce around for a moment\.\s+You also hear something else rolling around in there\./
				current_trap_type = "Springs trap has been disarmed."
				break
			#Already manually disarmed
			#Same messaging as when no traps found.
			#Already disarmed with 408
			elsif line =~ /You spot a reddish glow about the hinges of the.*(box|strongbox|chest|trunk|coffer)\./
				current_trap_type = "Springs trap has already been disarmed with 408."
				break
	#####Fire vial information#####
			#Manual detection
			elsif line =~ /Looking closely into the keyhole of the lock\, you spy a small vial of fire\-red liquid and a tiny hammer device which seems poised to shatter it if the lock is tampered with\./
				current_trap_type = "fire vial"
				CharSettings['fire_vial'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /Using the metal grips from your.*\, you manage to reach in and grasp the post of the metal hammer\, and bend the weak metal out of striking range of the vial\.|Having rendered the hammer harmless\, you carefully remove a thick glass vial filled with murky red liquid from the.*(box|strongbox|chest|trunk|coffer)\./
				current_trap_type = "Fire vial trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /Looking closely into the keyhole of the lock\, you spy a tiny hammer device which has been bent back slightly\.|Looking closely into the keyhole of the lock\, you spy a small vial of fire\-red liquid and a tiny hammer device which has been bent from striking range of the vial\./
				current_trap_type = "Fire vial trap has already been disarmed."
				break
			#Already disarmed with 408 NEED MESSAGING
			#elsif line =~ //
			#	current_trap_type = "Fire vial trap has already been disarmed with 408."
			#	break
	#####Spores information#####
			#Manual detection
			elsif line =~ /Peering into the.*(box|strongbox|chest|trunk|coffer)\'s lock\, you see a small tube towards the bottom of the tumbler mechanism\.\s+The tube is capped with a thin membrane\, but it seems likely that the tumblers would tear it off while turning\./
				current_trap_type = "spores"
				CharSettings['spores'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /Taking a lump of putty from your.*\, you carefully apply it to the end of the small tube\.\s+That should block whatever it\'s meant to deploy\./
				current_trap_type = "Spores trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /Peering into the.*(box|strongbox|chest|trunk|coffer)\'s lock\, you see a small tube towards the bottom of the tumbler mechanism\.\s+It appears as though the tube has been plugged with something\./
				current_trap_type = "Spores trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /You see a thin tube extending from the lock mechanism down into the.*(box|strongbox|chest|trunk|coffer)\.\s+The end of the tube is surrounded by a crimson glow\.|Peering into the.*(box|strongbox|chest|trunk|coffer)\'s lock\, you see a small tube towards the bottom of the tumbler mechanism\.\s+A crimson glow surrounds the mouth of the tube\./
				current_trap_type = "Spores trap has already been disarmed with 408."
				break
			#Trap has already been set off
			elsif line =~ /Peering into the (box|strongbox|chest|trunk|coffer)\'s lock\, you see a small tube towards the bottom of the tumbler mechanism\.\s+It appears as though the tube used to be covered with a thin membrane\, but it has torn mostly away\, and greyish\-green powder covers the area around it\./
				current_trap_type = "Spores trap has already been set off."
				break
	#####Plate information#####
			#Manual detection
			elsif line =~ /There appears to be a plate over the lock\, sealing it and preventing any access to the tumblers\.|Gonna chew through it/
				current_trap_type = "plate"
				CharSettings['plate'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /You carefully pour the contents of.*onto the .*(box|strongbox|chest|trunk|coffer) where you think the keyhole ought to be\.\s+.*\, the metal plate covering the lock begins to melt away\./
				current_trap_type = "Plate trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /You see a metal plate covering the lock plate\, but it appears to have been melted through\, granting sufficient access to the lock to attempt picking it./
				current_trap_type = "Plate trap has already been disarmed."
				break
			#Already disarmed with 408
			#Trap can't be disarmed with 408
	#####Glyph information#####
			#Manual detection
			elsif line =~ /You notice some spiderweb\-like scratches on the lock plate which seem\, after some bit of scrutiny\, too organized to be just wear and tear \-\- it might be some type of glyph spell\./
				current_trap_type = "glyph"
				CharSettings['glyph'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /Knowing how delicate magical glyphs can be\, you scrape some extra lines into the markings hoping to alter their meaning and defeat the spell they may hold\./
				current_trap_type = "Glyph trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /You notice some spiderweb\-like scratches on the lock plate which seem\, after some bit of scrutiny\, too organized to be just wear and tear \-\- it might be some type of glyph spell\, but some of the markings have been altered\.\s+This may prevent any magical nature they have from manifesting itself\./
				current_trap_type = "Glyph trap has already been disarmed."
				break
			#Already disarmed with 408
			#Trap can't be disarmed with 408
	#####Rods information#####
			#Manual detection
			elsif line =~ /Looking closely into the keyhole\, you notice a pair of small metal rods a hair\'s width from touching each other\.\s+Peering around the inside of the keyhole\, you can see that the lock would push the two rods together should the lock be tampered with\./
				current_trap_type = "rods"
				CharSettings['rods'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /With great care you take a pair of metal grips and bend the sensitive metal rods out of alignment\.\s+It looks as though they cannot be pressed together by the lock mechanism any more\./
				current_trap_type = "Rods trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /Looking closely into the keyhole\, you notice a pair of small metal rods that have been bent in opposite directions of each other\./
				current_trap_type = "Rods trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /Near the lock mechanism\, you notice a pair of small metal rods surrounded by a crimson glow\.|Looking closely into the keyhole\, you notice a pair of small metal rods that have a slight reddish glow about them\./
				current_trap_type = "Rods trap has already been disarmed with 408."
				break
	#####Boomer information#####
			#Manual detection
			elsif line =~ /Carefully\, you feel around the lock and notice the inside chamber is coated with a strange white substance\.\s+From your experience you recognize this as a common.*detonation system for an explosive mixture that was used to treat the .*(box|strongbox|chest|trunk|coffer)\./
				current_trap_type = "boomer"
				CharSettings['boomer'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /Using a bit of putty from your.*\, you cake a thin layer on the lock casing\, hopefully sufficient to prevent sparks when the metal arm strikes it\./
				current_trap_type = "Boomer trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /A thin layer of mud or putty has been dabbed on the connecting point of the striking arm and the white substance to prevent it from igniting the.*(box|strongbox|chest|trunk|coffer) when it is unlocked\./
				current_trap_type = "Boomer trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /A deep red glow surrounds the striking arm of the trap mechanism\.\s+You hope it will keep the arm from making contact with the explosive white substance\./
				current_trap_type = "Boomer trap has already been disarmed with 408."
				break
	#####No trap found#####
			elsif line =~ /You discover no traps\./
				current_trap_type = "No trap found."
				break
	#####Box is already open#####
			elsif line =~ /Um, but it\'s open|There is no lock on that/
				current_trap_type = "Box is already open."
				box_counts_for_math = nil
				break
	#####No putty#####
			elsif line =~ /You figure that if you had some sort of putty/
				echo "No putty to disarm this trap. Exiting."
				exit
	#####Roundtime#####
			elsif line =~ /Roundtime/
				break
			end

		end

		second_trap_check = true
		if (current_trap_type == "No trap found." || current_trap_type == "Scarab trap has already been disarmed." || current_trap_type == "Scarab trap has already been disarmed with 408." || current_trap_type == "Needle trap has been disarmed." || current_trap_type == "Needle trap has already been disarmed." || current_trap_type == "Needle trap has already been disarmed with 408." || current_trap_type == "Jaws trap has been disarmed." || current_trap_type == "Jaws trap has already been disarmed." || current_trap_type == "Sphere trap has been disarmed." || current_trap_type == "Sphere trap has already been disarmed." || current_trap_type == "Sphere trap has already been disarmed with 408." || current_trap_type == "Crystal trap has been disarmed." || current_trap_type == "Crystal trap has already been disarmed." || current_trap_type == "Crystal trap has already been disarmed with 408." || current_trap_type == "Scales trap has been disarmed." || current_trap_type == "Scales trap has already been disarmed." || current_trap_type == "Scales trap has already been disarmed with 408." || current_trap_type == "Sulphur trap has been disarmed." || current_trap_type == "Sulphur trap has already been disarmed." || current_trap_type == "Cloud trap has been disarmed." || current_trap_type == "Cloud trap has already been disarmed." || current_trap_type == "Cloud trap has already been disarmed with 408." || current_trap_type == "Acid vial trap has been disarmed." || current_trap_type == "Acid vial trap has already been disarmed." || current_trap_type == "Acid vial trap has already been disarmed with 408." || current_trap_type == "Springs trap has been disarmed." || current_trap_type == "Springs trap has already been disarmed with 408." || current_trap_type == "Fire vial trap has been disarmed." || current_trap_type == "Fire vial trap has already been disarmed." || current_trap_type == "Fire vial trap has already been disarmed with 408." || current_trap_type == "Spores trap has been disarmed." || current_trap_type == "Spores trap has already been disarmed." || current_trap_type == "Spores trap has already been disarmed with 408." || current_trap_type == "Plate trap has been disarmed." || current_trap_type == "Plate trap has already been disarmed." || current_trap_type == "Glyph trap has been disarmed." || current_trap_type == "Glyph trap has already been disarmed." || current_trap_type == "Rods trap has been disarmed." || current_trap_type == "Rods trap has already been disarmed." || current_trap_type == "Rods trap has already been disarmed with 408." || current_trap_type == "Boomer trap has been disarmed." || current_trap_type == "Boomer trap has already been disarmed." || current_trap_type == "Boomer trap has already been disarmed with 408." || current_trap_type == "Scarab trap has been disarmed." || current_trap_type == "Spores trap has already been set off." || current_trap_type == "Sphere trap has already been set off.")
			echo "#{current_trap_type}"
			(box_counts_for_math = nil) if (current_trap_type =~ /already/)
			number_of_manual_trap_checks_remaining -= 1
			if current_trap_type == "No trap found." && number_of_manual_trap_checks_remaining > 0
				echo "Number of trap checks remaining: #{number_of_manual_trap_checks_remaining}"
				second_trap_check = nil
				manually_disarm_trap.call
			else
				if current_trap_type == "No trap found."
					CharSettings['no_trap'] += 1
					CharSettings['total_trap_count'] += 1
				end
				waitrt?
				if UserVars.tpick["auto_bundle_vials"] == "yes" && (GameObj.right_hand.name =~ /vial/ || GameObj.left_hand.name =~ /vial/)
					check_locksmiths_container.call
					wait_until { vials_remaining }
					start_script "sorter" if start_sorter
					if vials_remaining < 10
						if GameObj.right_hand.name =~ /vial/
							current_vial = GameObj.right_hand.id
						elsif GameObj.left_hand.name =~ /vial/
							current_vial = GameObj.left_hand.id
						end
						fput "stow ##{current_vial}"
						tpick_stow_box(current_box) if (solo_or_other == "solo" || solo_or_other == "other")
						sleep 0.2
						stow_both.call
						wait_until { checkleft == nil }
						wait_until { checkright == nil }
						fput "remove ##{locksmiths_container.id}"
						wait_until { checkright != nil }
						fput "get ##{current_vial}"
						wait_until { checkleft != nil }
						fput "bundle"
						fput "wear ##{locksmiths_container.id}"
						wait_until { checkright == nil }
						if (solo_or_other == "solo" || solo_or_other == "other")
							tpick_get_box(current_box)
							wait_until { checkright }
						end				
					end
				end
				if current_trap_type == "Scarab trap has been disarmed."
					echo "Disarming scarab."
					waitrt?
					(tpick_cast_spells (506)) if (use_spell_506)
					sleep 1
					waitrt?
					scarab_object = GameObj.loot.find{ |i| i.name =~ /#{scarab_name}/ && i.noun == "scarab" && !all_scarab_ids.include?(i.id) }
					fput "disarm ##{scarab_object.id}"
					tpick_say_scarab_safe
					waitrt?
					fput "get ##{scarab_object.id}"
					fput "stow ##{scarab_object.id}"
				end
				stow_left.call
				if (GameObj.right_hand.id != current_box.id) && (solo_or_other == "ground" || solo_or_other == "worker")
					stow_right.call
				end
				if (disarm_only)
					if (bash_open_boxes)
						bash_the_box_open.call
					else
						box_counts_for_math = nil
						nil
					end
				else
					if always_use_wedge
						wedge_lock.call
					else
						measure.call
					end
				end
			end
		elsif current_trap_type == "Couldn't disarm trap, trying again."
			echo "#{current_trap_type}"
			tpick_cast_spells (404)
			manually_disarm_trap.call
		elsif current_trap_type == nil
			echo "Something went wrong on my end, repeating the DISARM command."
			tpick_cast_spells (404)
			manually_disarm_trap.call
		elsif (current_trap_type == "Acid vial trap has been set off." || current_trap_type == "Acid vial trap has already been set off.")
			echo "#{current_trap_type}"
			echo "Lock has been fused."
			if (disarm_only)
				if (bash_open_boxes)
					bash_the_box_open.call
				else
					box_counts_for_math = nil
					nil
				end
			else
				fused_lock_disarm.call
			end
		elsif current_trap_type == "Box is already open."
			echo "#{current_trap_type}"
			if solo_or_other == "solo"
				open_solo.call
			elsif solo_or_other == "other"
				open_others.call
			elsif solo_or_other == "ground"
				nil
			elsif solo_or_other == "worker"
				nil
			end
		elsif current_trap_type == "plate"
			echo "Found a #{current_trap_type} trap."
			if (disarm_only)
				if (bash_open_boxes)
					bash_the_box_open.call
				else
					box_counts_for_math = nil
					nil
				end
			else
				plate.call
			end
		elsif current_trap_type == "Jaws trap has already been disarmed with 408. Can't pick it." || current_trap_type == "Jaws trap has already been set off."
			echo "#{current_trap_type}"
			if (disarm_only)
				if (bash_open_boxes)
					bash_the_box_open.call
				else
					box_counts_for_math = nil
					nil
				end
			else
				fused_lock_disarm.call
			end
		else
			if current_trap_type == "Scales trap found, need to use dagger to disarm." || current_trap_type == "Sphere trap found, need to use lockpick to disarm."
				echo "#{current_trap_type}"
			else
				echo "Found a #{current_trap_type} trap."
			end
			if trap_cant_be_disarmed
				echo "Trap difficulty is too high according to your settings. Can't open box."
				if solo_or_other == "solo"
					where_to_stow_box.call
				elsif solo_or_other == "other"
					tpick_say_cant
					open_others.call
				elsif solo_or_other == "ground"
					cant_open_plated_box_count += 1
				elsif solo_or_other == "worker"
					ask_worker.call
				end
			else
				echo "Attempting to disarm trap." if current_trap_type != "scales" && second_trap_check == nil
				if current_trap_type == "scales"
					echo "Scales trap found, picking lock first then disarming."
					scale_trap_found = true
					measure.call
				elsif current_trap_type == "Scales trap found, need to use dagger to disarm."
					scaledisarm.call
				elsif (current_trap_type == "needle" || current_trap_type == "jaws" || current_trap_type == "crystal" || current_trap_type == "sulphur" || current_trap_type == "cloud" || current_trap_type == "acid vial" || current_trap_type == "springs" || current_trap_type == "fire vial" || current_trap_type == "spores" || current_trap_type == "glyph" || current_trap_type == "rods" || current_trap_type == "boomer" || current_trap_type == "sphere" || current_trap_type == "Sphere trap found, need to use lockpick to disarm." || current_trap_type == "scarab")
					manually_disarm_trap.call
				end
			end
		end
	end
}

open_all_containers = proc{
	open_or_close_containers = Array.new

	temp_container = UserVars.tpick["lockpick_container"].split(",")
	lockpick_container = temp_container[0]
	lockpick_container_close = true if temp_container[1] =~ /close/
	lockpick_container = GameObj.inv.find{ |i| i.name =~ /#{lockpick_container}/ }

	if !open_or_close_containers.include?(lockpick_container.id)
		open_or_close_containers.push(lockpick_container.id)
		fput "open ##{lockpick_container.id}"
	end

	temp_container = UserVars.tpick["broken_lockpick_container"].split(",")
	broken_lockpick_container = temp_container[0]
	broken_lockpick_container_close = true if temp_container[1] =~ /close/
	broken_lockpick_container = GameObj.inv.find{ |i| i.name =~ /#{broken_lockpick_container}/ }
	if !open_or_close_containers.include?(broken_lockpick_container.id)
		open_or_close_containers.push(broken_lockpick_container.id)
		fput "open ##{broken_lockpick_container.id}"
	end

	temp_container = UserVars.tpick["wedge_container"].split(",")
	wedge_container = temp_container[0]
	wedge_container_close = true if temp_container[1] =~ /close/
	wedge_container = GameObj.inv.find{ |i| i.name =~ /#{wedge_container}/ }
	if !open_or_close_containers.include?(wedge_container.id)
		open_or_close_containers.push(wedge_container.id)
		fput "open ##{wedge_container.id}"
	end

	temp_container = UserVars.tpick["calipers_container"].split(",")
	calipers_container = temp_container[0]
	calipers_container_close = true if temp_container[1] =~ /close/
	calipers_container = GameObj.inv.find{ |i| i.name =~ /#{calipers_container}/ }
	if !open_or_close_containers.include?(calipers_container.id)
		open_or_close_containers.push(calipers_container.id)
		fput "open ##{calipers_container.id}"
	end

	temp_container = UserVars.tpick["scale_weapon_container"].split(",")
	scale_weapon_container = temp_container[0]
	scale_weapon_container_close = true if temp_container[1] =~ /close/
	scale_weapon_container = GameObj.inv.find{ |i| i.name =~ /#{scale_weapon_container}/ }
	if !open_or_close_containers.include?(scale_weapon_container.id)
		open_or_close_containers.push(scale_weapon_container.id)
		fput "open ##{scale_weapon_container.id}"
	end

	temp_container = UserVars.tpick["locksmiths_container"].split(",")
	locksmiths_container = temp_container[0]
	locksmiths_container_close = true if temp_container[1] =~ /close/
	locksmiths_container = GameObj.inv.find{ |i| i.name =~ /#{locksmiths_container}/ }
	if !open_or_close_containers.include?(locksmiths_container.id)
		open_or_close_containers.push(locksmiths_container.id)
		fput "open ##{locksmiths_container.id}"
	end
	
	temp_container = UserVars.tpick["gem_container"].split(",")
	gem_container = temp_container[0]
	gem_container_close = true if temp_container[1] =~ /close/
	gem_container = GameObj.inv.find{ |i| i.name =~ /#{gem_container}/ }
	if !open_or_close_containers.include?(gem_container.id)
		open_or_close_containers.push(gem_container.id)
		fput "open ##{gem_container.id}"
	end
}

close_all_containers = proc{
	open_or_close_containers = Array.new
	open_or_close_containers.push(lockpick_container.id) if (lockpick_container_close) && (!open_or_close_containers.include?(lockpick_container.id))
	open_or_close_containers.push(broken_lockpick_container.id) if (broken_lockpick_container_close) && (!open_or_close_containers.include?(broken_lockpick_container.id))
	open_or_close_containers.push(wedge_container.id) if (wedge_container_close) && (!open_or_close_containers.include?(wedge_container.id))
	open_or_close_containers.push(calipers_container.id) if (calipers_container_close) && (!open_or_close_containers.include?(calipers_container.id))
	open_or_close_containers.push(scale_weapon_container.id) if (scale_weapon_container_close) && (!open_or_close_containers.include?(scale_weapon_container.id))
	open_or_close_containers.push(locksmiths_container.id) if (locksmiths_container_close) && (!open_or_close_containers.include?(locksmiths_container.id))
	open_or_close_containers.push(gem_container.id) if (gem_container_close) && (!open_or_close_containers.include?(gem_container.id))
	open_or_close_containers.each{ |i|
		waitrt?
		(fput "close ##{i}") unless i == nil
	}
}

scaledisarm = proc{
	echo "Attempting to disarm scales trap."
	3.times{
		waitrt?
		unless GameObj.right_hand.id == $scale_trap_weapon_id || GameObj.left_hand.id == $scale_trap_weapon_id
			fput "get ##{$scale_trap_weapon_id}"
			sleep 0.2
		end
	}
	if GameObj.right_hand.id != $scale_trap_weapon_id && GameObj.left_hand.id != $scale_trap_weapon_id
		echo "Couldn't find your #{UserVars.tpick["scale_trap_weapon"]}."
		exit
	end
	(tpick_cast_spells (404)) if (need_404 == "yes") || (use_spell_404)
	(tpick_cast_spells (506)) if (use_spell_506)
	(tpick_cast_spells (613)) if (use_spell_613)
	(tpick_cast_spells (1006)) if (use_spell_1006)
	result = dothistimeout "disarm ##{current_box.id}", 3, /slice through the cord/i
	if result =~ /slice through the cord/
		waitrt?
		if scale_weapon_container.nil?
			fput "put ##{$scale_trap_weapon_id} in my #{UserVars.tpick["scale_weapon_container"]}"
		else
			fput "put ##{$scale_trap_weapon_id} in ##{scale_weapon_container.id}"
		end
		if solo_or_other == "solo"
			open_solo.call
		elsif solo_or_other == "other"
			open_others.call
		elsif solo_or_other == "ground"
			sleep 0.1
		elsif solo_or_other == "worker"
			sleep 0.1
		end
	elsif result.nil?
		waitrt?
		if scale_weapon_container.nil?
			fput "put ##{$scale_trap_weapon_id} in my #{UserVars.tpick["scale_weapon_container"]}"
		else
			fput "put ##{$scale_trap_weapon_id} in ##{scale_weapon_container.id}"
		end
		tpick_cast_spells (404)
		scaledisarm.call
	end
}

plate = proc{
	echo "Disarming trap."
	waitrt?
	tpick_cast_spells (506) if use_spell_506
	if always_use_wedge
		wedge_lock.call
	else
		tpick_cast_spells (404) if need_404
		result = dothistimeout "disarm ##{current_box.id}", 3, /the metal plate covering the lock begins to melt away|Gonna chew through it|The darn thing is built too tightly|You still have a good enough picture of the trap in your mind/i
		if result =~ /the metal plate covering the lock begins to melt away/i
			measure.call
		elsif result =~ /Gonna chew through it/i
			if Char.prof == 'Rogue'
				echo "No vials found bundled in your locksmith's pouch, going to try wedging this box open."
				wedge_lock.call
			elsif Char.prof != 'Rogue' and (!Spell[407].known? or (UserVars.tpick["always_use_407"] != "plate" and UserVars.tpick["always_use_407"] != "all"))
				echo "Can't open this plated box."
				if solo_or_other == "solo"
					exit
				elsif solo_or_other == "other"
					tpick_say_cant
					open_others.call
				elsif solo_or_other == "ground"
					(cant_open_plated_box_count += 1;box_opened = nil)
				elsif solo_or_other == "worker"
					nil
				end
			elsif Char.prof != 'Rogue' and Spell[407].known? and UserVars.tpick["always_use_407"] == "plate"
				tpick_get_box(current_box) if solo_or_other == "ground"
				echo "Going to try popping this box."
				cast_407.call
			elsif Char.prof != 'Rogue' and Spell[407].known? and UserVars.tpick["always_use_407"] == "all"
				tpick_get_box(current_box) if solo_or_other == "ground"
				echo "Going to try popping this box."
				cast_407.call
			end
		elsif result =~ /The darn thing is built too tightly|You still have a good enough picture of the trap in your mind/
			plate.call
		elsif result.nil?
			plate.call
		end
	end
}

measure_detection = proc{
	lock = nil
	if Char.prof == 'Rogue'
		echo "Measuring lock."
		3.times{
			waitrt?
			unless GameObj.right_hand.name =~ /calipers/ || GameObj.left_hand.name =~ /calipers/
				fput "get my calipers"
				sleep 0.2
			end
		}
		if GameObj.right_hand.name !~ /calipers/ && GameObj.left_hand.name !~ /calipers/
			echo "Couldn't find your calipers."
			exit
		end
		fput "lmaster measure ##{current_box.id}"
	elsif Char.prof == 'Bard'
		echo "Loresinging to box to find out lock difficulty."
		tpick_get_box(current_box) if solo_or_other == "ground"
		waitrt?
		fput "speak bard"
		finished_it = nil
		if solo_or_other == "worker"
			loresong_stuff = "loresing ::#{checkname} #{current_box.noun} on #{table}:: #{current_box.noun} that looks like a clock;What's the purpose of your lock?"
		else
			loresong_stuff = "loresing #{checkright} that I hold;let your purpose now be told"
		end
		loop{
			break if finished_it
			result = dothistimeout "#{loresong_stuff}", 2, /^You sing/i
			if result =~ /^You sing/
				finished_it = true
			end
		}
	end
	while line = get
		if line =~ /\-(\d+) in thief\-lingo difficulty ranking/
			lock = $1.to_i
			break
		end
		(lock = lock_difficulty[0];break) if line =~ /a primitive lock/i
		(lock = lock_difficulty[1];break) if line =~ /a rudimentary lock/i
		(lock = lock_difficulty[2];break) if line =~ /an extremely easy lock/i
		(lock = lock_difficulty[3];break) if line =~ /a very easy lock/i
		(lock = lock_difficulty[4];break) if line =~ /an easy lock/i
		(lock = lock_difficulty[5];break) if line =~ /a very basic lock/i
		(lock = lock_difficulty[6];break) if line =~ /a fairly easy lock/i
		(lock = lock_difficulty[7];break) if line =~ /a simple lock/i
		(lock = lock_difficulty[8];break) if line =~ /a fairly simple lock/i
		(lock = lock_difficulty[9];break) if line =~ /a fairly plain lock/i
		(lock = lock_difficulty[10];break) if line =~ /a moderately well-crafted lock/i
		(lock = lock_difficulty[11];break) if line =~ /a well-crafted lock/i
		(lock = lock_difficulty[12];break) if line =~ /a tricky lock/i
		(lock = lock_difficulty[13];break) if line =~ /a somewhat difficult lock/i
		(lock = lock_difficulty[14];break) if line =~ /a moderately difficult lock/i
		(lock = lock_difficulty[15];break) if line =~ /a very well-crafted lock/i
		(lock = lock_difficulty[16];break) if line =~ /a difficult lock/i
		(lock = lock_difficulty[17];break) if line =~ /an extremely well-crafted lock/i
		(lock = lock_difficulty[18];break) if line =~ /a very difficult lock/i
		(lock = lock_difficulty[19];break) if line =~ /a fairly complicated lock/i
		(lock = lock_difficulty[20];break) if line =~ /an intricate lock/i
		(lock = lock_difficulty[21];break) if line =~ /an amazingly well-crafted lock/i
		(lock = lock_difficulty[22];break) if line =~ /a very complex lock/i
		(lock = lock_difficulty[23];break) if line =~ /an impressively complicated lock/i
		(lock = lock_difficulty[24];break) if line =~ /an amazingly intricate lock/i
		(lock = lock_difficulty[25];break) if line =~ /an extremely difficult lock/i
		(lock = lock_difficulty[26];break) if line =~ /an extremely complex lock/i
		(lock = lock_difficulty[27];break) if line =~ /a masterfully well-crafted lock/i
		(lock = lock_difficulty[28];break) if line =~ /an amazingly complicated lock/i
		(lock = lock_difficulty[29];break) if line =~ /an astoundingly complex lock/i
		(lock = lock_difficulty[30];break) if line =~ /an incredibly intricate lock/i
		(lock = lock_difficulty[31];break) if line =~ /an absurdly well-crafted lock/i
		(lock = lock_difficulty[32];break) if line =~ /an exceedingly complex lock/i
		(lock = lock_difficulty[33];break) if line =~ /an absurdly difficult lock/i
		(lock = lock_difficulty[34];break) if line =~ /an unbelievably complicated lock/i
		(lock = lock_difficulty[35];break) if line =~ /a masterfully intricate lock/i
		(lock = lock_difficulty[36];break) if line =~ /an absurdly complex lock/i
		(lock = lock_difficulty[37];break) if line =~ /an impossibly complex lock/i
		if line =~ /You place the probe in the lock and grimace as something feels horribly wrong/i #This game line indicates the rogue is trying to measure a box with calipers when the box still has an active trap, since all soul golem boxes are technically trapped (the trap just randomizes the difficulty of the lock) this line will appear on every soul golem box. The solution below is to use a vaalin lockpick on soul golem boxes from the worker and to turn in all other boxes when this message appears. When not picking boxes from the worker the script will still use a vaalin lockpick.
			if critter_name =~ /soul golem/i
				lock = "need vaalin"
				break
			else
				if solo_or_other == "worker"
					ask_worker.call
					break
				else
					lock = "need vaalin"
					break
				end
			end
		end
		(lock = "not locked";break) if line =~ /has already been unlocked/i
		(lock = "can't find trap";break) if line =~ /As you start to place the probe in the lock/
		(lock = "can't measure";break) if line =~ /but your song simply wasn't powerful enough/
	end
	waitrt?
	number_of_times_to_measure += 1
	if lock == "can't measure" && number_of_times_to_measure < 3
		measure_detection.call
	end
}

lock_pick_information = proc{
	if recommended_pick == "copper"
		needed_pick = UserVars.tpick["copper"]
		needed_pick_id = copper_lock_pick_array.first
		recommended_pick_modifier = 1.00
	elsif recommended_pick == "steel"
		needed_pick = UserVars.tpick["steel"]
		needed_pick_id = steel_lock_pick_array.first
		recommended_pick_modifier = 1.10
	elsif recommended_pick == "gold"
		needed_pick = UserVars.tpick["gold"]
		needed_pick_id = gold_lock_pick_array.first
		recommended_pick_modifier = 1.20
	elsif recommended_pick == "silver"
		needed_pick = UserVars.tpick["silver"]
		needed_pick_id = silver_lock_pick_array.first
		recommended_pick_modifier = 1.30
	elsif recommended_pick == "mithril"
		needed_pick = UserVars.tpick["mithril"]
		needed_pick_id = mithril_lock_pick_array.first
		recommended_pick_modifier = 1.45
	elsif recommended_pick == "ora"
		needed_pick = UserVars.tpick["ora"]
		needed_pick_id = ora_lock_pick_array.first
		recommended_pick_modifier = 1.55
	elsif recommended_pick == "glaes"
		needed_pick = UserVars.tpick["glaes"]
		needed_pick_id = glaes_lock_pick_array.first
		recommended_pick_modifier = 1.60
	elsif recommended_pick == "laje"
		needed_pick = UserVars.tpick["laje"]
		needed_pick_id = laje_lock_pick_array.first
		recommended_pick_modifier = 1.75
	elsif recommended_pick == "vultite"
		needed_pick = UserVars.tpick["vultite"]
		needed_pick_id = vultite_lock_pick_array.first
		recommended_pick_modifier = 1.80
	elsif recommended_pick == "rolaren"
		needed_pick = UserVars.tpick["rolaren"]
		needed_pick_id = rolaren_lock_pick_array.first
		recommended_pick_modifier = 1.90
	elsif recommended_pick == "veniom"
		needed_pick = UserVars.tpick["veniom"]
		needed_pick_id = veniom_lock_pick_array.first
		recommended_pick_modifier = 2.20
	elsif recommended_pick == "invar"
		needed_pick = UserVars.tpick["invar"]
		needed_pick_id = invar_lock_pick_array.first
		recommended_pick_modifier = 2.25
	elsif recommended_pick == "alum"
		needed_pick = UserVars.tpick["alum"]
		needed_pick_id = alum_lock_pick_array.first
		recommended_pick_modifier = 2.30
	elsif recommended_pick == "golvern"
		needed_pick = UserVars.tpick["golvern"]
		needed_pick_id = golvern_lock_pick_array.first
		recommended_pick_modifier = 2.35
	elsif recommended_pick == "kelyn"
		needed_pick = UserVars.tpick["kelyn"]
		needed_pick_id = kelyn_lock_pick_array.first
		recommended_pick_modifier = 2.40
	elsif recommended_pick == "vaalin"
		needed_pick = UserVars.tpick["vaalin"]
		needed_pick_id = vaalin_lock_pick_array.first
		recommended_pick_modifier = 2.50
	end
}

measure = proc{
	stuff_to_do.call if solo_or_other == "solo"
	waitrt?
	(tpick_cast_spells (506)) if (use_spell_506)
	i_need_403 = nil
	recommended_pick = nil
	if picks_to_use_based_on_critter_level && solo_or_other == "worker" && found_true_lock_difficulty.nil?
		needed_pick = nil
		if critter_level.nil?
			recommended_pick = "vaalin"
		else
			picks_to_use_based_on_critter_level.each{ |i|
				temp_picks_critter_level = i.split(" ")
				if temp_picks_critter_level[0].to_i >= critter_level
					if temp_picks_critter_level[1] == "copper"
						recommended_pick = "copper"
					elsif temp_picks_critter_level[1] == "steel"
						recommended_pick = "steel"
					elsif temp_picks_critter_level[1] == "gold"
						recommended_pick = "gold"
					elsif temp_picks_critter_level[1] == "silver"
						recommended_pick = "silver"
					elsif temp_picks_critter_level[1] == "mithril"
						recommended_pick = "mithril"
					elsif temp_picks_critter_level[1] == "ora"
						recommended_pick = "ora"
					elsif temp_picks_critter_level[1] == "glaes"
						recommended_pick = "glaes"
					elsif temp_picks_critter_level[1] == "laje"
						recommended_pick = "laje"
					elsif temp_picks_critter_level[1] == "vultite"
						recommended_pick = "vultite"
					elsif temp_picks_critter_level[1] == "rolaren"
						recommended_pick = "rolaren"
					elsif temp_picks_critter_level[1] == "veniom"
						recommended_pick = "veniom"
					elsif temp_picks_critter_level[1] == "invar"
						recommended_pick = "invar"
					elsif temp_picks_critter_level[1] == "alum"
						recommended_pick = "alum"
					elsif temp_picks_critter_level[1] == "golvern"
						recommended_pick = "golvern"
					elsif temp_picks_critter_level[1] == "kelyn"
						recommended_pick = "kelyn"
					elsif temp_picks_critter_level[1] == "vaalin"
						recommended_pick = "vaalin"
					end
					break
				end
			}
		end
		recommended_pick = "vaalin" if recommended_pick.nil?
		lock_pick_information.call
		if critter_level
			echo "Critter level is #{critter_level}, using a #{recommended_pick} lockpick based on your settings."
		else
			echo "Critter level is unknown, using a #{recommended_pick} lockpick."
		end
		pick2.call
	elsif always_use_vaalin && picks_to_use_based_on_critter_level.nil?
		echo "Always use vaalin setting enabled, using a vaalin lockpick."
		recommended_pick = "vaalin"
		lock_pick_information.call
		need_403 = "yes" unless UserVars.tpick["always_use_403"] == "never"
		pick2.call
	elsif (UserVars.tpick["use_vaalin_when_fried"] =~ /yes/i) && ((percentmind >= 100))
		echo "Always use vaalin when fried enabled, using a vaalin lockpick."
		(box_counts_for_math = nil)
		recommended_pick = "vaalin"
		lock_pick_information.call
		need_403 = "yes" unless UserVars.tpick["always_use_403"] == "never"
		pick2.call
	elsif start_with_copper && found_true_lock_difficulty.nil?
		echo "Start with copper option enabled, starting with lockpick in your copper lockpick setting."
		recommended_pick = "copper"
		lock_pick_information.call
		pick2.call	
	elsif UserVars.tpick["always_use_407"] == "all"
		echo "Always use 407 setting enabled, using 407."
		if (scale_trap_found)
			echo "Can't open a scales trap with 407."
			if solo_or_other == "solo"
				where_to_stow_box.call
			elsif solo_or_other == "other"
				tpick_say_cant
				open_others.call
			elsif solo_or_other == "ground"
				cant_open_plated_box_count += 1
				box_opened = nil
			elsif solo_or_other == "worker"
				ask_worker.call
			end
		else
			tpick_get_box(current_box) if solo_or_other == "ground"
			cast_407.call
		end
	else
		waitrt?
		if (found_true_lock_difficulty == nil)
			number_of_times_to_measure = 0
			measure_detection.call
			fput "speak common" if Char.prof == 'Bard'
			if Char.prof == 'Rogue'
				stow_calipers.call
			elsif Char.prof == 'Bard' && solo_or_other == "ground"
				tpick_drop_box(current_box)
			end
		end
		number = 0
		needed_pick = nil
		needed_pick_id = nil
		if lock == "not locked"
			box_counts_for_math = nil
			if solo_or_other == "solo"
				open_solo.call
			elsif solo_or_other == "other"
				open_others.call
			elsif solo_or_other == "ground"
				nil
			elsif solo_or_other == "worker"
				nil
			end
		elsif lock == "can't find trap"
			echo "Doesn't look like you have the skill to detect the trap on this box."
			box_counts_for_math = nil
			if solo_or_other == "solo"
				where_to_stow_box.call
			elsif solo_or_other == "other"
				tpick_say_cant
				open_others.call
			elsif solo_or_other == "ground"
				nil
			elsif solo_or_other == "worker"
				ask_worker.call
			end
		elsif lock == "can't measure"
			echo "You can't determine the lock difficulty."
			box_counts_for_math = nil
			if solo_or_other == "solo"
				where_to_stow_box.call
			elsif solo_or_other == "other"
				tpick_say_cant
				open_others.call
			elsif solo_or_other == "ground"
				nil
			elsif solo_or_other == "worker"
				ask_worker.call
			end
		elsif lock == "need vaalin"
			recommended_pick = "vaalin"
			lock_pick_information.call
			echo "Recommended lock pick: #{recommended_pick} with a modifier of #{recommended_pick_modifier}"
			echo "Recommend 403: No"
			echo "Your calculated lockpicking skill: #{pick_skill}"
			temp_math_number = pick_skill
			quick_maths = (temp_math_number * recommended_pick_modifier).truncate
			echo "Your total picking skill for this attempt is: #{quick_maths}"
			echo "Lock difficulty: #{lock}"
			pick2.call
		else
			total_pick_skill = (pick_skill + pick_lore) * 2.50
			if max_lock_attempt_compared_to_max_skill && lock > (total_pick_skill - max_lock_attempt)
				if (scale_trap_found)
					echo "Lock difficulty: #{lock}, your max picking skill with a vaalin lockpick: #{total_pick_skill}, you won't pick anything higher than #{max_lock_attempt} points below your max skill according to the Max Lock setting in the ;setup menu. This box also has a scales trap so can't be popped or wedged open. Skipping box."
					if solo_or_other == "solo"
						where_to_stow_box.call
					elsif solo_or_other == "other"
						tpick_say_cant
						open_others.call
					elsif solo_or_other == "ground"
						cant_open_plated_box_count += 1
						box_opened = nil
					elsif solo_or_other == "worker"
						ask_worker.call
					end
				else
					echo "Lock difficulty: #{lock}, your max picking skill with a vaalin lockpick: #{total_pick_skill}, you won't pick anything higher than #{max_lock_attempt} points below your max skill according to the Max Lock setting in the ;setup menu so a lockpick won't be used."
						wedge_lock.call
				end
			elsif lock > max_lock_attempt && max_lock_attempt_compared_to_max_skill.nil?
				if (scale_trap_found)
					echo "This lock is higher than the Max Lock setting you entered in the ;setup menu so a lockpick won't be used. This box also has a scales trap so can't be popped or wedged open. Skipping box."
					if solo_or_other == "solo"
						where_to_stow_box.call
					elsif solo_or_other == "other"
						tpick_say_cant
						open_others.call
					elsif solo_or_other == "ground"
						cant_open_plated_box_count += 1
						box_opened = nil
					elsif solo_or_other == "worker"
						ask_worker.call
					end
				else
					echo "This lock is higher than the Max Lock setting you entered in the ;setup menu so a lockpick won't be used."
					wedge_lock.call
				end
			else
				if lock > (total_pick_skill + UserVars.tpick["vaalin_lock_roll"].to_i)
					if (scale_trap_found)
						echo "Can't pick this box based on my calculations (and it has a scales trap.) If you think this is in error increase the Vaalin Lock Roll setting in the setup menu. Skipping box."
						if solo_or_other == "solo"
							where_to_stow_box.call
						elsif solo_or_other == "other"
							tpick_say_cant
							open_others.call
						elsif solo_or_other == "ground"
							cant_open_plated_box_count += 1
							box_opened = nil
						elsif solo_or_other == "worker"
							ask_worker.call
						end
					else
						echo "Can't pick this box based on my calculations. If you think this is in error increase the Vaalin Lock Roll setting in the setup menu."
						wedge_lock.call
					end
				else
					pick_mod.each do |i|
						total_pick_skill = (pick_skill + pick_lore)
						if (total_pick_skill) * 2.50 - lock + UserVars.tpick["lock_roll"].to_i < 100
							needed_pick = UserVars.tpick["vaalin"]
							needed_pick_id = vaalin_lock_pick_array.first
							need_403 = "yes" unless UserVars.tpick["always_use_403"] == "never"
							i_need_403 = true unless UserVars.tpick["always_use_403"] == "never"
							number = 15
							break
						else
							total_pick_skill = (pick_skill) * i
							if total_pick_skill - lock + UserVars.tpick["lock_roll"].to_i < 100
								number += 1
								unless UserVars.tpick["always_use_403"] == "never"
									i_need_403 = true if number > 14
								end
							else
								break
							end
						end
						if use_403_for_lock_difficulty && Spell[403].known? && lock > use_403_for_lock_difficulty
							i_need_403 = true
						end
					end
					if i_need_403
						number = 0
						need_403 = "yes" unless UserVars.tpick["always_use_403"] == "never"
						pick_mod.each do |i|
							total_pick_skill = (pick_skill + pick_lore) * i
							if total_pick_skill - lock + UserVars.tpick["lock_roll"].to_i < 100
								number += 1
							else
								break
							end
						end
					end
					if number == 0
						recommended_pick = "copper"
					elsif number == 1
						recommended_pick = "steel"
					elsif number == 2
						recommended_pick = "gold"
					elsif number == 3
						recommended_pick = "silver"
					elsif number == 4
						recommended_pick = "mithril"
					elsif number == 5
						recommended_pick = "ora"
					elsif number == 6
						recommended_pick = "glaes"
					elsif number == 7
						recommended_pick = "laje"
					elsif number == 8
						recommended_pick = "vultite"
					elsif number == 9
						recommended_pick = "rolaren"
					elsif number == 10
						recommended_pick = "veniom"
					elsif number == 11
						recommended_pick = "invar"
					elsif number == 12
						recommended_pick = "alum"
					elsif number == 13
						recommended_pick = "golvern"
					elsif number == 14
						recommended_pick = "kelyn"
					elsif number > 14
						recommended_pick = "vaalin"
					end
					lock_pick_information.call
					echo "Recommended lock pick: #{recommended_pick} with a modifier of #{recommended_pick_modifier}"
					if need_403 == "yes"
						if use_403_for_lock_difficulty && Spell[403].known? && lock > use_403_for_lock_difficulty
							echo "Lock difficulty is higher than your 403 setting in setup menu, using 403."
						else
							echo "Recommend 403: Yes"
						end
						echo "Your calculated lockpicking skill: #{pick_skill}"
						echo "Your calculated lockpicking lore: #{pick_lore}"
						temp_math_number = pick_skill + pick_lore
					else
						echo "Recommend 403: No"
						echo "Your calculated lockpicking skill: #{pick_skill}"
						temp_math_number = pick_skill
					end
					quick_maths = (temp_math_number * recommended_pick_modifier).truncate
					echo "Your total picking skill for this attempt is: #{quick_maths}"
					echo "Lock difficulty: #{lock}"
					if needed_pick_id.nil?
						echo "All of your #{recommended_pick} lockpicks seem to be broken, trying a higher tier lockpick."
						nextpick.call
					else
						pick2.call
					end
				end
			end
		end
	end
}

find_gnomish_lockpick = proc{
	found_pick = nil
	spin_number = 0
	waitrt?
	fput "turn my #{gnomish_bracers}"
	while line = get
		if line =~ /^You spin your/
			(found_pick = true) if (line =~ /#{needed_pick}/)
			break
		end
	end
	if found_pick == nil
		loop{
			spin_number += 1
			waitrt?
			fput "spin my #{gnomish_bracers}"
			while line = get
				if line =~ /^You spin your/
					(found_pick = true) if (line =~ /#{needed_pick}/)
					break
				end
			end
			break if (found_pick) || (spin_number > 18)
		}
	end
	if (spin_number > 18)
		echo "Couldn't find the lockpick needed to pick this lock in your #{gnomish_bracers}."
		nextpick.call
	else
		pick3.call
	end
}

roll_amount_check = proc{
	waitrt?
	if needed_pick != UserVars.tpick["vaalin"]
		if roll_amount > UserVars.tpick["lock_roll"].to_i
			echo "You rolled: #{roll_amount}, your Lock Roll setting: #{UserVars.tpick["lock_roll"]}. Trying next pick."
			fput "put ##{needed_pick_id} in ##{lockpick_container.id}" unless gnomish_bracers && override_bracers != "override"
			next_task = "nextpick"
		else
			echo "You rolled: #{roll_amount}, your Lock Roll setting: #{UserVars.tpick["lock_roll"]}. Trying same pick again"
			next_task = "pick3"
		end
	elsif needed_pick == UserVars.tpick["vaalin"]
		if roll_amount > UserVars.tpick["vaalin_lock_roll"].to_i
			if need_403.nil?
				echo "You rolled: #{roll_amount}, your Vaalin Lock Roll setting: #{UserVars.tpick["vaalin_lock_roll"]}. Going to use 403 now."
				roll_amount = 99
			else
				echo "You rolled: #{roll_amount}, your Vaalin Lock Roll setting: #{UserVars.tpick["vaalin_lock_roll"]}. You are already using 403. According to your Vaalin Lock Roll setting you should stop trying to use lockpicks."
				roll_amount = 100
			end
			fput "put ##{needed_pick_id} in ##{lockpick_container.id}" unless gnomish_bracers && override_bracers != "override"
			next_task = "nextpick"
		else
			echo "You rolled: #{roll_amount}, your Vaalin Lock Roll setting: #{UserVars.tpick["vaalin_lock_roll"]}. Trying same pick again"
			next_task = "pick3"
		end
	end
}

pick2 = proc{
	waitrt?
	if (gnomish_bracers) && override_bracers != "override"
		find_gnomish_lockpick.call
	else
		3.times{
			waitrt?
			unless GameObj.right_hand.id == needed_pick_id || GameObj.left_hand.id == needed_pick_id
				fput "get ##{needed_pick_id}"
				sleep 0.2
			end
		}
		if GameObj.right_hand.id != needed_pick_id && GameObj.left_hand.id != needed_pick_id
			echo "Couldn't find #{needed_pick}."
			waitrt?
			roll_amount = 100
			nextpick.call
		else
			pick3.call
		end
	end
}

pick3 = proc{
	next_task = nil
	roll_amount = nil
	if (open_plinites) || current_box.name =~ /plinite/
		echo "Attempting to extract plinite."
	else
		echo "Attempting to pick lock."
	end
	waitrt?
	(tpick_cast_spells (506)) if (use_spell_506)
	unless UserVars.tpick["always_use_403"] == "never"
		(tpick_cast_spells (403)) if (need_403 == "yes" || use_spell_403)
	end
	if (open_plinites) || current_box.name =~ /plinite/
		fput "extract ##{current_box.id}"
	elsif gnomish_bracers && override_bracers != "override"
		tpick_get_box(current_box) if solo_or_other == "ground"
		fput "push my #{gnomish_bracers}"
	else
		if UserVars.tpick["trick"] == "random" && Char.prof =~ /Rogue/
			random_trick = [ "spin", "twist", "turn", "twirl", "toss", "bend", "flip" ].sample
			do_trick = "lmas ptrick #{random_trick}"
		end
		wait_until { checkrt == 0 } if checkrt > 0
		fput "#{do_trick} ##{current_box.id}"
	end
	if (open_plinites) || current_box.name =~ /plinite/
		while line = get
			if line =~ /\(d100\=(\d+)\)/
				roll_amount = $1.to_i
				if line =~ /fumbling attempt/
					waitrt?
					next_task = "pick3"
					break
				end
			elsif line =~ /As you do you so\, you push just a little too hard and rupture the core\!/
				waitrt?
				next_task = "next plinite"
				break
			elsif line =~ /you withdraw your lockpick with the feeling that retrieving the core is within your abilities/
				waitrt?
				next_task = "pick3"
				break
			elsif line =~ /with the feeling that your abilities are probably not sufficient to retrieve the core/ || line =~ /You fumble about for a bit before you realize you are using a broken lockpick/
				if (GameObj.right_hand.id != current_box.id) && (solo_or_other == "ground" || solo_or_other == "worker")
					if line =~ /You fumble about for a bit before you realize you are using a broken lockpick/
						3.times{
							waitrt?
							unless GameObj.right_hand.id != needed_pick_id && GameObj.left_hand.id != needed_pick_id
								fput "put ##{needed_pick_id} in ##{broken_lockpick_container.id}"
								sleep 0.2
							end
						}
						if GameObj.right_hand.id == needed_pick_id || GameObj.left_hand.id == needed_pick_id
							echo "Couldn't put lockpick in your #{broken_lockpick_container}."
							sleep 2
							fput "stow ##{needed_pick_id}"
						end
						copper_lock_pick_array.delete(copper_lock_pick_array.first) if needed_pick_id == copper_lock_pick_array.first
						steel_lock_pick_array.delete(steel_lock_pick_array.first) if needed_pick_id == steel_lock_pick_array.first
						gold_lock_pick_array.delete(gold_lock_pick_array.first) if needed_pick_id == gold_lock_pick_array.first
						silver_lock_pick_array.delete(silver_lock_pick_array.first) if needed_pick_id == silver_lock_pick_array.first
						mithril_lock_pick_array.delete(mithril_lock_pick_array.first) if needed_pick_id == mithril_lock_pick_array.first
						ora_lock_pick_array.delete(ora_lock_pick_array.first) if needed_pick_id == ora_lock_pick_array.first
						glaes_lock_pick_array.delete(glaes_lock_pick_array.first) if needed_pick_id == glaes_lock_pick_array.first
						laje_lock_pick_array.delete(laje_lock_pick_array.first) if needed_pick_id == laje_lock_pick_array.first
						vultite_lock_pick_array.delete(vultite_lock_pick_array.first) if needed_pick_id == vultite_lock_pick_array.first
						rolaren_lock_pick_array.delete(rolaren_lock_pick_array.first) if needed_pick_id == rolaren_lock_pick_array.first
						veniom_lock_pick_array.delete(veniom_lock_pick_array.first) if needed_pick_id == veniom_lock_pick_array.first
						invar_lock_pick_array.delete(invar_lock_pick_array.first) if needed_pick_id == invar_lock_pick_array.first
						alum_lock_pick_array.delete(alum_lock_pick_array.first) if needed_pick_id == alum_lock_pick_array.first
						golvern_lock_pick_array.delete(golvern_lock_pick_array.first) if needed_pick_id == golvern_lock_pick_array.first
						kelyn_lock_pick_array.delete(kelyn_lock_pick_array.first) if needed_pick_id == kelyn_lock_pick_array.first
						vaalin_lock_pick_array.delete(vaalin_lock_pick_array.first) if needed_pick_id == vaalin_lock_pick_array.first
					else
						stow_right.call
					end
				end
				stow_left.call
				if needed_pick == UserVars.tpick["vaalin"]
					if solo_or_other == "worker"
						echo "Can't extract this plinite based on my calculations. If you think this is in error increase the Vaalin Lock Roll setting in the setup menu."
						next_task = "next plinite"
					else
						echo "Can't extract this plinite, OPENing it instead. If you think this is in error increase the Vaalin Lock Roll setting in the setup menu."
						waitrt?
						fput "open ##{current_box.id}"
						next_task = "next plinite"
					end
				else
					next_task = "nextpick"
				end
				break
			elsif line =~ /where it can be easily PLUCKed/
				next_task = "open plinite"
				break
			end
		end
	else
		while line = get
			if line =~ /\(d100\=(\d+)\)/
				roll_amount = $1.to_i
				if line =~ /fumbling attempt/
					waitrt?
					next_task = "pick3"
					break
				end
			elsif line =~ /(You struggle with the .*\.  As you do\, you get a sense that the .* has .* \(.* thief\-lingo difficulty ranking\)\.  Then\.\.\.CLICK\!  It opens\!|as the tumblers snap open|It does not appear to be locked|already been unlocked)/
				if line =~ /(It does not appear to be locked|already been unlocked)/
					box_counts_for_math = nil
				end
				calibrate_count += 1
				waitrt?
				fput "put ##{needed_pick_id} in ##{lockpick_container.id}" unless gnomish_bracers && override_bracers != "override"
				if line =~ /You struggle with the .*\.  As you do\, you get a sense that the .* has .* \(.* thief\-lingo difficulty ranking\)\.  Then\.\.\.CLICK\!  It opens\!|as the tumblers snap open/i && calibrate_count >= UserVars.tpick["calibratecount"].to_i
					if can_use_calipers && always_use_vaalin.nil? && start_with_copper.nil?
						calibrate.call unless popping
					end
					calibrate_count = 0
				end
				if scale_trap_found
					scaledisarm.call
				elsif solo_or_other == "solo"
					next_task = "open_solo"
				elsif solo_or_other == "other"
					next_task = "open_other"
				elsif solo_or_other == "ground"
					tpick_drop_box(current_box) if gnomish_bracers && override_bracers != "override"
					next_task = "open_ground"
				elsif solo_or_other == "worker"
					next_task = "worker finished"
				end
				break
			elsif line =~ /You are not able to pick the lock\, and learn little about it\.|bit more luck|within your abilities/i
				roll_amount_check.call
				break
			elsif line =~ /About a \-(\d+) difficulty lock/ || line =~ /As you do\, you get a sense that the .* has .* \(\-(\d+) thief\-lingo difficulty ranking\)/
				if found_true_lock_difficulty.nil?
					lock = $1.to_i
					found_true_lock_difficulty = true
					next_task = "measure again"
				else
					roll_amount_check.call
				end
				break			
			elsif line =~ /(You are not able to pick|You carefully try to work it free but end up bending the tip|You carefully try to work it free\, but it may have been weakened by the stress\.)/i
				waitrt?
				echo "This pick doesn't seem to be cutting it, going to try a different one."
				if line =~ /You carefully try to work it free but end up bending the tip|You carefully try to work it free\, but it may have been weakened by the stress\./
					if UserVars.tpick["auto_repair_bent_lockpicks"] == "yes" && Char.prof =~ /Rogue/
						if solo_or_other != "ground" && solo_or_other != "worker"
							tpick_stow_box(current_box)
							fput "lmas repair my #{checkleft}"
							waitrt?
							sleep 1
							waitrt?
							tpick_get_box(current_box)
						elsif solo_or_other == "ground" || solo_or_other == "worker"
							fput "lmas repair my #{checkright}"
							waitrt?
							sleep 1
							waitrt?
						end
					end
					fput "put ##{needed_pick_id} in ##{lockpick_container.id}" unless gnomish_bracers && override_bracers != "override"
				elsif line =~ /You are not able to pick/ && needed_pick != UserVars.tpick["vaalin"]
					fput "put ##{needed_pick_id} in ##{lockpick_container.id}" unless gnomish_bracers && override_bracers != "override"
				elsif line =~ /You are not able to pick/ && needed_pick == UserVars.tpick["vaalin"]
					if roll_amount > UserVars.tpick["vaalin_lock_roll"].to_i
						fput "put ##{needed_pick_id} in ##{lockpick_container.id}" unless gnomish_bracers && override_bracers != "override"
					end
				end
				if need_403.nil?
					roll_amount = 99
				else
					roll_amount = 100
				end
				next_task = "nextpick"
				break
			elsif line =~ /(You broke your|you realize you are using a broken|You carefully try to work it free but end up snapping off the tip)/i
				echo "#{needed_pick} is broken."
				waitrt?
				copper_lock_pick_array.delete(copper_lock_pick_array.first) if needed_pick_id == copper_lock_pick_array.first
				steel_lock_pick_array.delete(steel_lock_pick_array.first) if needed_pick_id == steel_lock_pick_array.first
				gold_lock_pick_array.delete(gold_lock_pick_array.first) if needed_pick_id == gold_lock_pick_array.first
				silver_lock_pick_array.delete(silver_lock_pick_array.first) if needed_pick_id == silver_lock_pick_array.first
				mithril_lock_pick_array.delete(mithril_lock_pick_array.first) if needed_pick_id == mithril_lock_pick_array.first
				ora_lock_pick_array.delete(ora_lock_pick_array.first) if needed_pick_id == ora_lock_pick_array.first
				glaes_lock_pick_array.delete(glaes_lock_pick_array.first) if needed_pick_id == glaes_lock_pick_array.first
				laje_lock_pick_array.delete(laje_lock_pick_array.first) if needed_pick_id == laje_lock_pick_array.first
				vultite_lock_pick_array.delete(vultite_lock_pick_array.first) if needed_pick_id == vultite_lock_pick_array.first
				rolaren_lock_pick_array.delete(rolaren_lock_pick_array.first) if needed_pick_id == rolaren_lock_pick_array.first
				veniom_lock_pick_array.delete(veniom_lock_pick_array.first) if needed_pick_id == veniom_lock_pick_array.first
				invar_lock_pick_array.delete(invar_lock_pick_array.first) if needed_pick_id == invar_lock_pick_array.first
				alum_lock_pick_array.delete(alum_lock_pick_array.first) if needed_pick_id == alum_lock_pick_array.first
				golvern_lock_pick_array.delete(golvern_lock_pick_array.first) if needed_pick_id == golvern_lock_pick_array.first
				kelyn_lock_pick_array.delete(kelyn_lock_pick_array.first) if needed_pick_id == kelyn_lock_pick_array.first
				vaalin_lock_pick_array.delete(vaalin_lock_pick_array.first) if needed_pick_id == vaalin_lock_pick_array.first
				next_task = "broken lockpick stow"
				break
			elsif line =~ /(You must be holding a lockpick to perform that trick.|You didn't mention what you want to pick the lock with.)/i
				echo "Couldn't find #{needed_pick}."
				waitrt?
				next_task = "nextpick"
				break
			end
		end
	end
	if next_task == "open_solo"
		open_solo.call
	elsif next_task == "open_other"
		open_others.call
	elsif next_task == "worker finished"
		nil
	elsif next_task == "open_ground"
		nil
	elsif next_task == "pick3"
		pick3.call
	elsif next_task == "nextpick"
		nextpick.call
	elsif next_task == "measure again"
		echo "Got a read on this box, going to change to best suited lockpick."
		waitrt?
		fput "put ##{needed_pick_id} in ##{lockpick_container.id}" unless gnomish_bracers && override_bracers != "override"
		measure.call
	elsif next_task == "broken lockpick stow"
		if gnomish_bracers && override_bracers != "override"
			nextpick.call
		else
			broken_lockpick_stow.call
		end
	elsif next_task == "open plinite"
		if solo_or_other == "worker"
			ask_worker.call
		else
			open_current_plinite.call
		end
	elsif next_task == "next plinite"
		stow_both.call
		ask_worker.call if solo_or_other == "worker"
	end
}

broken_lockpick_stow = proc{
	3.times{
		waitrt?
		unless GameObj.right_hand.id != needed_pick_id && GameObj.left_hand.id != needed_pick_id
			fput "put ##{needed_pick_id} in ##{broken_lockpick_container.id}"
			sleep 0.2
		end
	}
	if GameObj.right_hand.id == needed_pick_id || GameObj.left_hand.id == needed_pick_id
		echo "Couldn't put lockpick in your #{broken_lockpick_container}."
		sleep 2
		fput "stow ##{needed_pick_id}"
	end
	roll_amount = 100 if vaalin_lock_pick_array.length < 1
	nextpick.call
}

nextpick = proc{
	before_needed_pick = needed_pick
	before_recommended_pick = recommended_pick
	if recommended_pick == "copper"
		needed_pick = UserVars.tpick["steel"]
		needed_pick_id = steel_lock_pick_array.first
		recommended_pick = "steel"
	elsif recommended_pick == "steel"
		needed_pick = UserVars.tpick["gold"]
		needed_pick_id = gold_lock_pick_array.first
		recommended_pick = "gold"
	elsif recommended_pick == "gold"
		needed_pick = UserVars.tpick["silver"]
		needed_pick_id = silver_lock_pick_array.first
		recommended_pick = "silver"
	elsif recommended_pick == "silver"
		needed_pick = UserVars.tpick["mithril"]
		needed_pick_id = mithril_lock_pick_array.first
		recommended_pick = "mithril"
	elsif recommended_pick == "mithril"
		needed_pick = UserVars.tpick["ora"]
		needed_pick_id = ora_lock_pick_array.first
		recommended_pick = "ora"
	elsif recommended_pick == "ora"
		needed_pick = UserVars.tpick["glaes"]
		needed_pick_id = glaes_lock_pick_array.first
		recommended_pick = "glaes"
	elsif recommended_pick == "glaes"
		needed_pick = UserVars.tpick["laje"]
		needed_pick_id = laje_lock_pick_array.first
		recommended_pick = "laje"
	elsif recommended_pick == "laje"
		needed_pick = UserVars.tpick["vultite"]
		needed_pick_id = vultite_lock_pick_array.first
		recommended_pick = "vultite"
	elsif recommended_pick == "vultite"
		needed_pick = UserVars.tpick["rolaren"]
		needed_pick_id = rolaren_lock_pick_array.first
		recommended_pick = "rolaren"
	elsif recommended_pick == "rolaren"
		needed_pick = UserVars.tpick["veniom"]
		needed_pick_id = veniom_lock_pick_array.first
		recommended_pick = "veniom"
	elsif recommended_pick == "veniom"
		needed_pick = UserVars.tpick["invar"]
		needed_pick_id = invar_lock_pick_array.first
		recommended_pick = "invar"
	elsif recommended_pick == "invar"
		needed_pick = UserVars.tpick["alum"]
		needed_pick_id = alum_lock_pick_array.first
		recommended_pick = "alum"
	elsif recommended_pick == "alum"
		needed_pick = UserVars.tpick["golvern"]
		needed_pick_id = golvern_lock_pick_array.first
		recommended_pick = "golvern"
	elsif recommended_pick == "golvern"
		needed_pick = UserVars.tpick["kelyn"]
		needed_pick_id = kelyn_lock_pick_array.first
		recommended_pick = "kelyn"
	elsif recommended_pick == "kelyn"
		needed_pick = UserVars.tpick["vaalin"]
		needed_pick_id = vaalin_lock_pick_array.first
		recommended_pick = "vaalin"
	elsif recommended_pick == "vaalin" && roll_amount != 100
		need_403 = "yes" unless UserVars.tpick["always_use_403"] == "never"
		needed_pick = UserVars.tpick["vaalin"]
		needed_pick_id = vaalin_lock_pick_array.first
		recommended_pick = "vaalin"
	elsif recommended_pick == "vaalin" && roll_amount == 100
		needed_pick = "wedge"
	end
	if needed_pick_id.nil?
		echo "All of your #{recommended_pick} lockpicks seem to be broken, trying a higher tier lockpick."
		nextpick.call
	elsif before_needed_pick == needed_pick && recommended_pick != "vaalin"
		nextpick.call
	else
		nextpick2.call
	end
}

nextpick2 = proc{
	if needed_pick == "wedge"
		if open_plinites || current_box.name =~ /plinite/
			if solo_or_other == "worker"
				echo "Can't extract this plinite based on my calculations. If you think this is in error increase the Vaalin Lock Roll setting in the setup menu."
				ask_worker.call
			else
				echo "Can't extract this plinite, OPENing it instead. If you think this is in error increase the Vaalin Lock Roll setting in the setup menu."
				waitrt?
				fput "open ##{current_box.id}"
			end
		elsif (scale_trap_found)
			echo "Can't pick this box and it has a scales trap."
			if solo_or_other == "solo"
				where_to_stow_box.call
			elsif solo_or_other == "other"
				tpick_say_cant
				open_others.call
			elsif solo_or_other == "ground"
				cant_open_plated_box_count += 1
				box_opened = nil
			end
		else
			if Char.prof =~ /Rogue/
				echo "Can't pick this lock, going to try to wedge it open."
				wedge_lock.call
			elsif Spell[407].known?
				echo "Can't pick this lock, going to try to pop it open."
				cast_407.call
			else
				if solo_or_other == "other"
					tpick_say_cant
					open_others.call
				elsif solo_or_other == "ground"
					echo "Couldn't open this box."
					box_opened = nil
				elsif solo_or_other == "solo"
					echo "Couldn't open this box."
					where_to_stow_box.call
					stow_both.call
					sleep 0.1
				end
			end
		end
	elsif before_needed_pick == UserVars.tpick["vaalin"]
		echo "Trying to pick with vaalin lockpick again."
		pick2.call
	else
		echo "Couldn't pick lock with #{before_recommended_pick} pick, trying #{recommended_pick} pick."
		pick2.call
	end
}

total_boxes_picked_math = proc{
	if (update_math_information)
		if (box_counts_for_math == nil)
			echo "This box was not added to your total boxes picked nor was the time spent opening it recorded."
		else
			total_picking_time = (Time.now - start_time)
			CharSettings['total_boxes_picked'] += 1
			(CharSettings['total_time_spent_picking_boxes'] += total_picking_time)
		end
		total_boxes_number -= 1
		total_boxes_number = [total_boxes_number, 0].max
	end
	CharSettings['total_time_spent_picking_boxes'] = CharSettings['total_time_spent_picking_boxes'].round(2) unless CharSettings['total_time_spent_picking_boxes'] == 0
	average_picking_time = (CharSettings['total_time_spent_picking_boxes'] / CharSettings['total_boxes_picked']).round(2) unless CharSettings['total_boxes_picked'] == 0
	if CharSettings['total_boxes_picked'] > 0
		respond "\n"
		respond "####################"
		respond "####################"
		respond "Total boxes picked: #{CharSettings['total_boxes_picked']}"
		respond "Total time picking: #{CharSettings['total_time_spent_picking_boxes']} seconds"
		respond "Average time per box: #{average_picking_time} seconds"
		respond "####################"
		respond "####################"
		respond "\n"
	end
	(calculate_time_left = (total_boxes_number * average_picking_time).round(2)) unless CharSettings['total_boxes_picked'] == 0
	respond "\n"
	respond "####################"
	respond "####################"
	respond "Boxes remaining: #{total_boxes_number}"
	(respond "Estimated time remaining: #{calculate_time_left} seconds") unless CharSettings['total_boxes_picked'] == 0
	respond "####################"
	respond "####################"
	respond "\n"
	box_counts_for_math = true
}

open_solo = proc{
	update_math_information = true
	total_boxes_picked_math.call
	waitrt?
	(tpick_cast_spells (506)) if (use_spell_506)	
	total_boxes_picked += 1
	fput "open ##{current_box.id}" unless popping
	lootbox = GameObj.right_hand
	(dothistimeout "look in my #{lootbox}", 10, /In .*? you see|In the .*\:|There is nothing in/) if lootbox.contents.nil?
	waitrt?
	fput "swap"
	lootbox.contents.each{|item|
		current_item = item
		waitrt?
		if (item.name !~ /urglaes fang/) && (item.name !~ /doomstone/)
			gather_stuff.call
		end
		if item.name !~ /coins/i && UserVars.tpick["log"] == "yes"
			record_item_data.call
		end
		waitrt?
		if item.name !~ /coins/i && item.name !~ /urglaes fang/ && item.name !~ /doomstone/
			if UserVars.tpick["auto_bundle_vials"] == "yes" && item.name =~ /vial/ && (GameObj.right_hand.name =~ /vial/ || GameObj.left_hand.name =~ /vial/)
				check_locksmiths_container.call
				wait_until { vials_remaining }
				start_script "sorter" if start_sorter
				if vials_remaining < 10
					if GameObj.right_hand.name =~ /vial/
						current_vial = GameObj.right_hand.id
					elsif GameObj.left_hand.name =~ /vial/
						current_vial = GameObj.left_hand.id
					end
					fput "stow ##{current_vial}"
					tpick_stow_box(current_box)
					sleep 0.2
					stow_both.call
					wait_until { checkleft.nil? }
					wait_until { checkright.nil? }
					fput "remove ##{locksmiths_container.id}"
					wait_until { checkright }
					fput "get ##{current_vial}"
					wait_until { checkleft }
					fput "bundle"
					fput "wear ##{locksmiths_container.id}"
					wait_until { checkright.nil? }
					tpick_get_box(current_box)
					wait_until { checkright }			
				end
			else
				if (item.type =~ /gem/) && (gem_container)
					fput "put #{item} in ##{gem_container.id}"
				else
					fput "stow #{item}"
				end
			end
		end
		waitrt?
	}
	do_relock_boxes.call if relock_boxes
	garbage_check.call
	if box != "none"
		stow_both.call
		sleep 0.1
	else
		stow_both.call
	end
}

garbage_check = proc{
	waitrt?
	if UserVars.tpick["trash_boxes"] == "yes"
		if checkroom =~ /table|booth/i
			tpick_drop_box(current_box) if solo_or_other == "solo"
			fput "clean table"
		elsif GameObj.loot.find { |loot| trash = loot if loot.name =~ trash_container }
			waitrt?
			tpick_get_box(current_box) if solo_or_other == "ground"
			fput "put ##{current_box.id} in #{trash}"
		else
			tpick_drop_box(current_box) if solo_or_other == "solo"
		end
	elsif UserVars.tpick["trash_boxes"] == "save"
		result = dothistimeout "stow ##{current_box.id}", 3, /won\'t fit in|You put/
		if result =~ /won\'t fit in/i
			fput "put ##{current_box.id} in my #{UserVars.lootsack2}"
		elsif result =~ /You put/i
			nil
		elsif result.nil?
			tpick_stow_box(current_box)
		end
	else
		tpick_drop_box(current_box) if solo_or_other == "solo"
	end
	waitrt?
}

record_item_data = proc{
		if GameObj.right_hand.type =~ /gem/i
			gem = Array.new if gem == nil
			(gem.push(GameObj.right_hand.name);gem_number[gem.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /reagent/i
			reagent = Array.new if reagent == nil
			(reagent.push(GameObj.right_hand.name);reagent_number[reagent.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /herb/i
			herb = Array.new if herb == nil
			(herb.push(GameObj.right_hand.name);herb_number[herb.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /food/i
			food = Array.new if food == nil
			(food.push(GameObj.right_hand.name);food_number[food.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /uncommon/i
			uncommon = Array.new if uncommon == nil
			(uncommon.push(GameObj.right_hand.name);uncommon_number[uncommon.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /jewelry/i
			jewelry = Array.new if jewelry == nil
			(jewelry.push(GameObj.right_hand.name);jewelry_number[jewelry.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /junk/i
			junk = Array.new if junk == nil
			(junk.push(GameObj.right_hand.name);junk_number[junk.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /lockpick/i
			lockpick = Array.new if lockpick == nil
			(lockpick.push(GameObj.right_hand.name);lockpick_number[lockpick.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /magic/i
			magic = Array.new if magic == nil
			(magic.push(GameObj.right_hand.name);magic_number[magic.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /scroll/i
			scroll = Array.new if scroll == nil
			(scroll.push(GameObj.right_hand.name);scroll_number[scroll.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /wand/i
			wand = Array.new if wand == nil
			(wand.push(GameObj.right_hand.name);wand_number[wand.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /armor/i
			armor = Array.new if armor == nil
			(armor.push(GameObj.right_hand.name);armor_number[armor.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /weapon/i
			weapon = Array.new if weapon == nil
			(weapon.push(GameObj.right_hand.name);weapon_number[weapon.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /clothing/i
			clothing = Array.new if clothing == nil
			(clothing.push(GameObj.right_hand.name);clothing_number[clothing.index(GameObj.right_hand.name)] += 1)
		else
			other = Array.new if other == nil
			(other.push(GameObj.right_hand.name);other_number[other.index(GameObj.right_hand.name)] += 1)
		end
}

open_others = proc{
	update_math_information = true
	total_boxes_picked_math.call
	waitrt?
	fput "give ##{current_box.id} to #{person}"
	start_others.call
}

before_dying { 
	if ground_loot || solo_or_other == "solo"
		wealth_after.call
		wait_until { silver_after }
		silver_gained = silver_after - silver_before
	end;
	
	DownstreamHook.remove("#{script.name}_check_locksmiths_container")
	DownstreamHook.remove("#{script.name}_check_for_boxes")
	DownstreamHook.remove("#{script.name}_wealth_before")
	DownstreamHook.remove("#{script.name}_wealth_after")

	respond "Total boxes picked: #{total_boxes_picked}" if ground_loot || solo_or_other == "solo"
	respond "Total silvers gained: #{silver_gained}" if ground_loot || solo_or_other == "solo"
	(gem.uniq! if gem != nil;reagent.uniq! if reagent != nil;herb.uniq! if herb != nil;food.uniq! if food != nil;uncommon.uniq! if uncommon != nil;jewelry.uniq! if jewelry != nil;junk.uniq! if junk != nil;lockpick.uniq!if lockpick != nil;magic.uniq! if magic != nil;scroll.uniq! if scroll != nil;wand.uniq! if wand != nil;armor.uniq! if armor != nil;weapon.uniq! if weapon != nil;other.uniq! if other != nil;clothing.uniq if clothing != nil) if ground_loot || solo_or_other == "solo"
	(respond "\nGems:\n";gem.each{|item|respond "#{item} x#{gem_number[gem.index(item)]}"}) if gem != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nReagents:\n";reagent.each{|item|respond "#{item} x#{reagent_number[reagent.index(item)]}"}) if reagent != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nHerbs:\n";herb.each{|item|respond "#{item} x#{herb_number[herb.index(item)]}"}) if herb != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nFood:\n";food.each{|item|respond "#{item} x#{food_number[food.index(item)]}"}) if food != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nUncommon:\n";uncommon.each{|item|respond "#{item} x#{uncommon_number[uncommon.index(item)]}"}) if uncommon != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nJewelry:\n";jewelry.each{|item|respond "#{item} x#{jewelry_number[jewelry.index(item)]}"}) if jewelry != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nJunk:\n";junk.each{|item|respond "#{item} x#{junk_number[junk.index(item)]}"}) if junk != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nLockpicks:\n";lockpick.each{|item|respond "#{item} x#{lockpick_number[lockpick.index(item)]}"}) if lockpick != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nMagic:\n";magic.each{|item|respond "#{item} x#{magic_number[magic.index(item)]}"}) if magic != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nScrolls:\n";scroll.each{|item|respond "#{item} x#{scroll_number[scroll.index(item)]}"}) if scroll != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nWands:\n";wand.each{|item|respond "#{item} x#{wand_number[wand.index(item)]}"}) if wand != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nArmor:\n";armor.each{|item|respond "#{item} x#{armor_number[armor.index(item)]}"}) if armor != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nWeapons:\n";weapon.each{|item|respond "#{item} x#{weapon_number[weapon.index(item)]}"}) if weapon != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nClothing:\n";clothing.each{|item|respond "#{item} x#{clothing_number[clothing.index(item)]}"}) if clothing != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nOther:\n";other.each{|item|respond "#{item} x#{other_number[other.index(item)]}"}) if other != nil and (ground_loot or solo_or_other == "solo")
	close_all_containers.call
}

gem = nil
reagent = nil
herb = nil
food = nil
uncommon = nil
jewelry = nil
junk = nil
lockpick = nil
magic = nil
scroll = nil
wand = nil
armor = nil
weapon = nil
clothing = nil
other = nil

gem_number = Array.new
reagent_number = Array.new
herb_number = Array.new
food_number = Array.new
uncommon_number = Array.new
jewelry_number = Array.new
junk_number = Array.new
lockpick_number = Array.new
magic_number = Array.new
scroll_number = Array.new
wand_number = Array.new
armor_number = Array.new
weapon_number = Array.new
clothing_number = Array.new
other_number = Array.new

wealth_before = proc {
	action = proc { |server_string|
		if server_string =~ /^\s*Name\:|^\s*Gender\:|^\s*Normal \(Bonus\)|^\s*Strength \(STR\)\:|^\s*Constitution \(CON\)\:|^\s*Dexterity \(DEX\)\:|^\s*Agility \(AGI\)\:|^\s*Discipline \(DIS\)\:|^\s*Aura \(AUR\)\:|^\s*Logic \(LOG\)\:|^\s*Intuition \(INT\)\:|^\s*Wisdom \(WIS\)\:|^\s*Influence \(INF\)\:/
			nil
		elsif server_string =~ /^\s*Mana\:\s+\-?[0-9]+\s+Silver\:\s+([0-9]+)/
			silver_before = $1.to_i
			DownstreamHook.remove("#{script.name}_wealth_before")
			nil
		else
			server_string
		end
	}
		DownstreamHook.add("#{script.name}_wealth_before", action)
		silence_me
		fput "info"
		silence_me
}

wealth_after = proc{
	action = proc { |server_string|
		if server_string =~ /^\s*Name\:|^\s*Gender\:|^\s*Normal \(Bonus\)|^\s*Strength \(STR\)\:|^\s*Constitution \(CON\)\:|^\s*Dexterity \(DEX\)\:|^\s*Agility \(AGI\)\:|^\s*Discipline \(DIS\)\:|^\s*Aura \(AUR\)\:|^\s*Logic \(LOG\)\:|^\s*Intuition \(INT\)\:|^\s*Wisdom \(WIS\)\:|^\s*Influence \(INF\)\:/
			nil
		elsif server_string =~ /^\s*Mana\:\s+\-?[0-9]+\s+Silver\:\s+([0-9]+)/
			silver_after = $1.to_i
			DownstreamHook.remove("#{script.name}_wealth_after")
			nil
		else
			server_string
		end
	}
		DownstreamHook.add("#{script.name}_wealth_after", action)
		silence_me
		put "info"
		silence_me
}

stow_both = proc{
	stow_right.call
	stow_left.call
}

stow_right = proc{
	if checkright
		if (GameObj.right_hand.id == $copper_lockpick_id) || (GameObj.right_hand.id == $steel_lockpick_id) || (GameObj.right_hand.id == $gold_lockpick_id) || (GameObj.right_hand.id == $silver_lockpick_id) || (GameObj.right_hand.id == $mithril_lockpick_id) || (GameObj.right_hand.id == $ora_lockpick_id) || (GameObj.right_hand.id == $glaes_lockpick_id) || (GameObj.right_hand.id == $laje_lockpick_id) || (GameObj.right_hand.id == $vultite_lockpick_id) || (GameObj.right_hand.id == $rolaren_lockpick_id) || (GameObj.right_hand.id == $veniom_lockpick_id) || (GameObj.right_hand.id == $invar_lockpick_id) || (GameObj.right_hand.id == $alum_lockpick_id) || (GameObj.right_hand.id == $golvern_lockpick_id) || (GameObj.right_hand.id == $kelyn_lockpick_id) || (GameObj.right_hand.id == $vaalin_lockpick_id)
			until checkright.nil?
				waitrt?
				fput "put right in ##{lockpick_container.id}"
				sleep 0.2
			end
		elsif GameObj.right_hand.name =~ /wedge/
			until checkright.nil?
				waitrt?
				fput "put right in ##{wedge_container}"
				sleep 0.2
			end
		elsif GameObj.right_hand.name =~ /caliper/
			until checkright.nil?
				waitrt?
				fput "put right in ##{calipers_container.id}"
				sleep 0.2
			end
		elsif GameObj.right_hand.id == $scale_trap_weapon_id
			until checkright.nil?
				waitrt?
				if scale_weapon_container.nil?
					fput "put ##{$scale_trap_weapon_id} in my #{UserVars.tpick["scale_weapon_container"]}"
				else
					fput "put ##{$scale_trap_weapon_id} in ##{scale_weapon_container.id}"
				end
				sleep 0.2
			end
		else
			until checkright.nil?
				waitrt?
				fput "stow right"
				sleep 0.2
			end
		end
	end
}

stow_left = proc{
	if checkleft
		if (GameObj.left_hand.id == $copper_lockpick_id) || (GameObj.left_hand.id == $steel_lockpick_id) || (GameObj.left_hand.id == $gold_lockpick_id) || (GameObj.left_hand.id == $silver_lockpick_id) || (GameObj.left_hand.id == $mithril_lockpick_id) || (GameObj.left_hand.id == $ora_lockpick_id) || (GameObj.left_hand.id == $glaes_lockpick_id) || (GameObj.left_hand.id == $laje_lockpick_id) || (GameObj.left_hand.id == $vultite_lockpick_id) || (GameObj.left_hand.id == $rolaren_lockpick_id) || (GameObj.left_hand.id == $veniom_lockpick_id) || (GameObj.left_hand.id == $invar_lockpick_id) || (GameObj.left_hand.id == $alum_lockpick_id) || (GameObj.left_hand.id == $golvern_lockpick_id) || (GameObj.left_hand.id == $kelyn_lockpick_id) || (GameObj.left_hand.id == $vaalin_lockpick_id)
			until checkleft.nil?
				waitrt?
				fput "put left in ##{lockpick_container.id}"
				sleep 0.2
			end
		elsif GameObj.left_hand.name =~ /wedge/
			until checkleft.nil?
				waitrt?
				fput "put left in ##{wedge_container.id}"
				sleep 0.2
			end
		elsif GameObj.left_hand.name =~ /caliper/
			until checkleft.nil?
				waitrt?
				fput "put left in ##{calipers_container.id}"
				sleep 0.2
			end
		elsif GameObj.left_hand.id == $scale_trap_weapon_id
			until checkleft.nil?
				waitrt?
				if scale_weapon_container.nil?
					fput "put ##{$scale_trap_weapon_id} in my #{UserVars.tpick["scale_weapon_container"]}"
				else
					fput "put ##{$scale_trap_weapon_id} in ##{scale_weapon_container.id}"
				end
				sleep 0.2
			end
		else
			until checkleft.nil?
				waitrt?
				fput "stow left"
				sleep 0.2
			end
		end
	end
}
					
get_wire_order_numbers = proc{
	move 'out' if checkpaths 'out'
	target_room = Room.current.find_nearest(toolbenches_room_number)
	start_script 'go2', [ target_room.to_s ]
	wait_while{ running?('go2') }
	move 'go toolbench'
	fput "read sign"
	while line = get
		if line =~ /\s*(\d+)\..*copper wire\s+(\d+)/
			$tpick_copper_wire = $1
			$tpick_copper_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*brass wire\s+(\d+)/
			$tpick_brass_wire = $1
			$tpick_brass_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*steel wire\s+(\d+)/
			$tpick_steel_wire = $1
			$tpick_steel_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*gold wire\s+(\d+)/
			$tpick_gold_wire = $1
			$tpick_gold_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*silver wire\s+(\d+)/
			$tpick_silver_wire = $1
			$tpick_silver_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*ora wire\s+(\d+)/
			$tpick_ora_wire = $1
			$tpick_ora_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*mithril wire\s+(\d+)/
			$tpick_mithril_wire = $1
			$tpick_mithril_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*laje wire\s+(\d+)/
			$tpick_laje_wire = $1
			$tpick_laje_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*alum wire\s+(\d+)/
			$tpick_alum_wire = $1
			$tpick_alum_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*vultite wire\s+(\d+)/
			$tpick_vultite_wire = $1
			$tpick_vultite_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*rolaren wire\s+(\d+)/
			$tpick_rolaren_wire = $1
			$tpick_rolaren_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*veniom wire\s+(\d+)/
			$tpick_veniom_wire = $1
			$tpick_veniom_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*kelyn wire\s+(\d+)/
			$tpick_kelyn_wire = $1
			$tpick_kelyn_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*invar wire\s+(\d+)/
			$tpick_invar_wire = $1
			$tpick_invar_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*golvern wire\s+(\d+)/
			$tpick_golvern_wire = $1
			$tpick_golvern_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*vaalin wire\s+(\d+)/
			$tpick_vaalin_wire = $1
			$tpick_vaalin_wire_cost = $2
		elsif line =~ /a thin bar of vaalin/
			break
		end
	end
	move 'out' if checkpaths 'out'
}

all_variables_to_check.each{|i|
	if i == "percent" || i =~ /\%/
		tip_is_a_percent = true
		break
	end
}

all_variables_to_check.each{|i|
	if i =~ /\d+/
		tip_being_offered = i.to_i
	end
}

all_variables_to_check.each{|i|
	if i == "drop"
		current_room = Room.current.id
		if worker.nil?
			echo "The \"drop\" command only works at locksmith pools."
			exit
		end
		if tip_being_offered.nil?
			echo "You need to specify how much you are tipping and if you want it to be a percent."
			echo "For example do \";tpick drop 100\" to tip 100 silvers per box, do \";tpick drop 10 percent\" or \";tpick drop 10%\" if you want to tip 10% per box"
			exit
		end
		if tip_is_a_percent && tip_being_offered > 100
			echo "Wise guy, huh? You can't tip more than 100%!"
			exit
		end
		fput "stow right" if checkright
		fput "stow left" if checkleft
		$tpick_boxes_checked = nil
		check_for_command = "inv full"
		check_for_boxes.call
		wait_until { $tpick_boxes_checked }
		total_number_of_boxes = $tpick_list_of_box_ids.length
		count_boxes_in_disk.call
		echo "Total number of boxes: #{total_number_of_boxes}"
		if total_number_of_boxes == 0
			echo "You don't have any boxes!"
			exit
		end
		if tip_is_a_percent
			echo "You are tipping #{tip_being_offered}% for each box."
			sleep 1
			start_script 'go2', [ 'bank', '--disable-confirm' ]
			wait_while{ running?('go2') }
			fput "depo all"
			fput "withdraw #{2000 * total_number_of_boxes} silvers"
			start_script 'go2', [ current_room ]
			wait_while{ running?('go2') }
			$tpick_list_of_box_ids.each{ |box|
				fput "get ##{box}"
				fput "give #{worker} #{tip_being_offered} percent"
				fput "give #{worker} #{tip_being_offered} percent"
			}
		else
			echo "You are tipping #{tip_being_offered} silvers for each box for a total tip needed of #{tip_being_offered * total_number_of_boxes}"
			sleep 1
			start_script 'go2', [ 'bank', '--disable-confirm' ]
			wait_while{ running?('go2') }
			fput "depo all"
			fput "withdraw #{tip_being_offered * total_number_of_boxes} silvers"
			start_script 'go2', [ current_room ]
			wait_while{ running?('go2') }
			$tpick_list_of_box_ids.each{ |box|
				fput "get ##{box}"
				fput "give #{worker} #{tip_being_offered}"
				fput "give #{worker} #{tip_being_offered}"
			}
		end
		exit
	end
}

all_variables_to_check.each{|i|
	if i == "return" || i == "pickup"
		if worker.nil?
			echo "This command only works at locksmith pools."
			exit
		end
		fput "stow right" if checkright
		fput "stow left" if checkleft
		loop{
			fput "ask #{worker} about return"
			while line = get
				if line =~ /We don\'t have any boxes ready for you/
					exit
				elsif line =~ /here\'s your .* back/
					wait_until { checkright }
					picking_up = true
					sleep 0.2
					lootbox = GameObj.right_hand
					fput "open ##{lootbox.id}"
					lootbox.contents.each{|item|
						current_item = item
						waitrt?
						if (item.name !~ /urglaes fang/) && (item.name !~ /doomstone/)
							gather_stuff.call
						end
					}
					fput "stow right" if checkright
					fput "stow left" if checkleft
					break
				end
			end
		}
	exit
	end
}

if (CharSettings['setup_has_been_run'].nil? || CharSettings['setup_has_been_run_again'].nil?|| UserVars.tpick.nil?) && (script.vars[1] != 'setup')
	echo "Setup is required, type ;tpick setup and fill in all settings."
	echo "If you are upgrading to a new version of ;tpick keep in mind all lockpick settings AND container names AND scale trap weapon now require the full name of each lockpick, not including the words 'a' and 'an'."	
	exit
end
if script.vars[1] == 'setup'
	setup.call
	exit
end

if UserVars.tpick["trap_roll"].length <= 0 || UserVars.tpick["lock_roll"].length <= 0 || UserVars.tpick["vaalin_lock_roll"].length <= 0
	echo "One or more of the following settings isn't setup properly: Trap Roll, Lock Roll, Vaalin Lock Roll."
	echo "These settings are found in the \"Options\" tab of the setup menu. Run ;tpick setup, click on the \"Options\" tab, read the instructions on the bottom, and please fill in these values."
	exit
end

if script.vars[1] =~ /stat/
	stats_check.call
	exit
end

if (UserVars.tpick["gnomish_bracer"] != "nil") && (UserVars.tpick["gnomish_bracer"] != nil) && (UserVars.tpick["gnomish_bracer"].length > 1)
	bracers_temp = UserVars.tpick["gnomish_bracer"].split(",")
	bracers_name = bracers_temp[0]
	bracers_tier = bracers_temp[1]
	override_bracers = bracers_temp[2]
	gnomish_bracers = bracers_name
end

open_all_containers.call

until checkright.nil?
	waitrt?
	fput "stow right"
	sleep 0.1
end

until checkleft.nil?
	waitrt?
	fput "stow left"
	sleep 0.1
end

$tpick_boxes_checked = nil
check_for_lockpicks_etc.call
wait_until { $tpick_boxes_checked }
$copper_lockpick_id = copper_lock_pick_array.first
$steel_lockpick_id = steel_lock_pick_array.first
$gold_lockpick_id = gold_lock_pick_array.first
$silver_lockpick_id = silver_lock_pick_array.first
$mithril_lockpick_id = mithril_lock_pick_array.first
$ora_lockpick_id = ora_lock_pick_array.first
$glaes_lockpick_id = glaes_lock_pick_array.first
$laje_lockpick_id = laje_lock_pick_array.first
$vultite_lockpick_id = vultite_lock_pick_array.first
$rolaren_lockpick_id = rolaren_lock_pick_array.first
$veniom_lockpick_id = veniom_lock_pick_array.first
$invar_lockpick_id = invar_lock_pick_array.first
$alum_lockpick_id = alum_lock_pick_array.first
$golvern_lockpick_id = golvern_lock_pick_array.first
$kelyn_lockpick_id = kelyn_lock_pick_array.first
$vaalin_lockpick_id = vaalin_lock_pick_array.first

(echo "Couldn't find your copper lockpick";sleep 2) if $copper_lockpick_id.nil? && UserVars.tpick["copper"] != "nil" && UserVars.tpick["copper"].length > 1
(echo "Couldn't find your steel lockpick";sleep 2) if $steel_lockpick_id.nil? && UserVars.tpick["steel"] != "nil" && UserVars.tpick["steel"].length > 1
(echo "Couldn't find your gold lockpick";sleep 2) if $gold_lockpick_id.nil? && UserVars.tpick["gold"] != "nil" && UserVars.tpick["gold"].length > 1
(echo "Couldn't find your silver lockpick";sleep 2) if $silver_lockpick_id.nil? && UserVars.tpick["silver"] != "nil" && UserVars.tpick["silver"].length > 1
(echo "Couldn't find your mithril lockpick";sleep 2) if $mithril_lockpick_id.nil? && UserVars.tpick["mithril"] != "nil" && UserVars.tpick["mithril"].length > 1
(echo "Couldn't find your ora lockpick";sleep 2) if $ora_lockpick_id.nil? && UserVars.tpick["ora"] != "nil" && UserVars.tpick["ora"].length > 1
(echo "Couldn't find your glaes lockpick";sleep 2) if $glaes_lockpick_id.nil? && UserVars.tpick["glaes"] != "nil" && UserVars.tpick["glaes"].length > 1
(echo "Couldn't find your laje lockpick";sleep 2) if $laje_lockpick_id.nil? && UserVars.tpick["laje"] != "nil" && UserVars.tpick["laje"].length > 1
(echo "Couldn't find your vultite lockpick";sleep 2) if $vultite_lockpick_id.nil? && UserVars.tpick["vultite"] != "nil" && UserVars.tpick["vultite"].length > 1
(echo "Couldn't find your rolaren lockpick";sleep 2) if $rolaren_lockpick_id.nil? && UserVars.tpick["rolaren"] != "nil" && UserVars.tpick["rolaren"].length > 1
(echo "Couldn't find your veniom lockpick";sleep 2) if $veniom_lockpick_id.nil? && UserVars.tpick["veniom"] != "nil" && UserVars.tpick["veniom"].length > 1
(echo "Couldn't find your invar lockpick";sleep 2) if $invar_lockpick_id.nil? && UserVars.tpick["invar"] != "nil" && UserVars.tpick["invar"].length > 1
(echo "Couldn't find your alum lockpick";sleep 2) if $alum_lockpick_id.nil? && UserVars.tpick["alum"] != "nil" && UserVars.tpick["alum"].length > 1
(echo "Couldn't find your golvern lockpick";sleep 2) if $golvern_lockpick_id.nil? && UserVars.tpick["golvern"] != "nil" && UserVars.tpick["golvern"].length > 1
(echo "Couldn't find your kelyn lockpick";sleep 2) if $kelyn_lockpick_id.nil? && UserVars.tpick["kelyn"] != "nil" && UserVars.tpick["kelyn"].length > 1
(echo "Couldn't find your vaalin lockpick";sleep 2) if $vaalin_lockpick_id.nil? && UserVars.tpick["vaalin"] != "nil" && UserVars.tpick["vaalin"].length > 1
(echo "Couldn't find your scale trap weapon";sleep 2) if $scale_trap_weapon_id.nil? && UserVars.tpick["scale_trap_weapon"] != "nil" && UserVars.tpick["scale_trap_weapon"].length > 1

if script.vars[1] =~ /buy/
	check_locksmiths_container.call
	wait_until { putty_remaining }
	wait_until { cotton_remaining }
	start_script "sorter" if start_sorter
	if putty_remaining >= 100 && cotton_remaining >= 100
		echo "You already have 100 each of putty and cotton balls."
		exit
	else
		if Wounds.lhand >= 3 || Wounds.rhand >= 3 || Wounds.larm >= 3 || Wounds.rarm >= 3 || Scars.lhand >= 3 || Scars.rhand >= 3 || Scars.larm >= 3 || Scars.rarm >= 3 
			echo "Your wounds are too great to do this task. You can't have a missing hand or arm to do this."
			exit
		else
			stow_right.call
			stow_left.call
			fill_up_locksmith_container.call
		end
	end
	exit
end

repair_stuff_and_stuff = proc{
	result = dothistimeout "look ##{current_pick_to_check}", 1, /The.*appears to be broken\.|You see nothing unusual\.|I could not find what you were referring to\.|appears to be somewhat damaged/
	if result =~ /The.*appears to be broken\./
		if $tpick_vaalin_wire == nil
			get_wire_order_numbers.call
		end
		if number == 1
			lockpick_type = "vaalin"
			current_wire = $tpick_vaalin_wire
			current_wire_cost = $tpick_vaalin_wire_cost
		elsif number == 2
			lockpick_type = "kelyn"
			current_wire = $tpick_kelyn_wire
			current_wire_cost = $tpick_kelyn_wire_cost
		elsif number == 3
			lockpick_type = "golvern"
			current_wire = $tpick_golvern_wire
			current_wire_cost = $tpick_golvern_wire_cost
		elsif number == 4
			lockpick_type = "alum"
			current_wire = $tpick_alum_wire
			current_wire_cost = $tpick_alum_wire_cost
		elsif number == 5
			lockpick_type = "invar"
			current_wire = $tpick_invar_wire
			current_wire_cost = $tpick_invar_wire_cost
		elsif number == 6
			lockpick_type = "veniom"
			current_wire = $tpick_veniom_wire
			current_wire_cost = $tpick_veniom_wire_cost
		elsif number == 7
			lockpick_type = "rolaren"
			current_wire = $tpick_rolaren_wire
			current_wire_cost = $tpick_rolaren_wire_cost
		elsif number == 8
			lockpick_type = "vultite"
			current_wire = $tpick_vultite_wire
			current_wire_cost = $tpick_vultite_wire_cost
		elsif number == 9
			lockpick_type = "laje"
			current_wire = $tpick_laje_wire
			current_wire_cost = $tpick_laje_wire_cost
		elsif number == 10
			lockpick_type = "ora"
			current_wire = $tpick_ora_wire 
			current_wire_cost = $tpick_ora_wire_cost
		elsif number == 11
			lockpick_type = "mithril"
			current_wire = $tpick_mithril_wire 
			current_wire_cost = $tpick_mithril_wire_cost
		elsif number == 12
			lockpick_type = "silver"
			current_wire = $tpick_silver_wire
			current_wire_cost = $tpick_silver_wire_cost
		elsif number == 13
			lockpick_type = "gold"
			current_wire = $tpick_gold_wire
			current_wire_cost = $tpick_gold_wire_cost
		elsif number == 14
			lockpick_type = "steel"
			current_wire = $tpick_steel_wire
			current_wire_cost = $tpick_steel_wire_cost
		elsif number > 14
			lockpick_type = "copper"
			current_wire = $tpick_copper_wire
			current_wire_cost = $tpick_copper_wire_cost
		end
		fput "get ##{current_pick_to_check}"
		move 'out' if checkpaths 'out'
		start_script 'go2', [ 'bank', '--disable-confirm' ]
		wait_while{ running?('go2') }
		multifput "depo all", "withdraw #{current_wire_cost} silvers"
		target_room = Room.current.find_nearest(toolbenches_room_number)
		start_script 'go2', [ target_room.to_s ]
		wait_while{ running?('go2') }
		move 'go toolbench'
		waitrt?
		fput "order #{current_wire}"
		fput "buy"
		waitrt?
		result = dothistimeout "lmas repair ##{current_pick_to_check}", 2, /cooling rapidly to form a tight bond|but the broken tip refuses to work free/
		if result =~ /cooling rapidly to form a tight bond/
			waitrt?
			fput "put ##{current_pick_to_check} in ##{lockpick_container.id}"
		elsif result =~ /but the broken tip refuses to work free/
			echo "This lockpick cannot be repaired."
			exit
		elsif result.nil?
			echo "Didn't recognize any game lines."
			exit
		end
	elsif result =~ /You see nothing unusual\.|I could not find what you were referring to\.|appears to be somewhat damaged/
		nil
	end
}

if script.vars[1] =~ /repair/ && Char.prof =~ /Rogue/
	stow_right.call
	stow_left.call
	number = 1
	vaalin_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	kelyn_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	golvern_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	alum_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	invar_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	veniom_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	rolaren_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	vultite_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	laje_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	ora_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	mithril_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	silver_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	gold_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	steel_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	number += 1
	copper_lock_pick_array.each { |i|
		current_pick_to_check = i
		repair_stuff_and_stuff.call
	}
	move 'out' if checkroom =~ /workbench/i
	exit
elsif script.vars[1] =~ /repair/ && Char.prof !~ /Rogue/
	echo "Only rogues can repair lockpicks."
	exit
end

if locksmiths_container
	check_locksmiths_container.call
	wait_until { putty_remaining }
	wait_until { cotton_remaining }
	wait_until { vials_remaining }
	echo "Putty remaining: #{putty_remaining}"
	echo "Cotton balls remaining: #{cotton_remaining}"
	echo "Vials of acid remaining: #{vials_remaining}"
	start_script "sorter" if start_sorter
end

if (script.vars[1] == "reset" || script.vars[2] == "reset" || script.vars[3] == "reset" || script.vars[4] == "reset" || script.vars[5] == "reset" || script.vars[6] == "reset" || script.vars[7] == "reset" || script.vars[8] == "reset" || script.vars[9] == "reset" || script.vars[10] == "reset")
	reset_math.call
end

if Char.prof =~ /Rogue/
	can_use_calipers = true
	if (UserVars.tpick["trick"] == "spin" or UserVars.tpick["trick"] == "twist" or UserVars.tpick["trick"] == "turn" or UserVars.tpick["trick"] == "twirl" or UserVars.tpick["trick"] == "toss" or UserVars.tpick["trick"] == "bend" or UserVars.tpick["trick"] == "flip")
		do_trick = "lmas ptrick #{UserVars.tpick["trick"]}"	
	elsif UserVars.tpick["trick"] == "pick"
		do_trick = "pick"
	elsif UserVars.tpick["trick"] == "random"
		nil
	else
		(echo "Wrong value for TRICK in settings. Type ;tpick setup and enter spin, twist, turn, twirl, toss, bend, flip, pick, or random for the TRICK setting.";exit)
	end
else
	can_use_calipers = nil
	UserVars.tpick["calibrate"] = "no"
	do_trick = "pick"
end

stow_right.call
stow_left.call
calibrate_count = 0

if UserVars.tpick["max_lock"] =~ /\d+/ && UserVars.tpick["max_lock"] =~ /\-/
	temp_max_lock = UserVars.tpick["max_lock"].split("-")
	max_lock_attempt = temp_max_lock[1].to_i
	echo "Max lock: #{max_lock_attempt}"
	max_lock_attempt_compared_to_max_skill = true
elsif UserVars.tpick["max_lock"] =~ /\d+/
	max_lock_attempt = UserVars.tpick["max_lock"].to_i
end

if Spell[205].known? && UserVars.tpick["always_use_205"] == "yes"
	use_spell_205 = true
end

if Spell[402].known? && UserVars.tpick["always_use_402"] == "yes"
	use_spell_402 = true
end

if Spell[403].known?
	if UserVars.tpick["always_use_403"] =~ /\,/
		temp_403_variable = UserVars.tpick["always_use_403"].split(",")
		if temp_403_variable[0] =~ /\d+/
			use_403_for_lock_difficulty = temp_403_variable[0].to_i
		elsif temp_403_variable[1] =~ /\d+/
			use_403_for_lock_difficulty = temp_403_variable[1].to_i
		end
		$tpick_use_403_cancel = "cancel" if temp_403_variable[0] =~ /cancel/i || temp_403_variable[1] =~ /cancel/i
	else
		if UserVars.tpick["always_use_403"] =~ /\d+/
			use_403_for_lock_difficulty = UserVars.tpick["always_use_403"].to_i
		elsif UserVars.tpick["always_use_403"] == "yes"
			use_spell_403 = true
		end
	end
end

if Spell[404].known?
	if UserVars.tpick["always_use_404"] =~ /\,/
		temp_404_variable = UserVars.tpick["always_use_404"].split(",")
		if temp_404_variable[0] =~ /\d+/
			use_404_for_trap_difficulty = temp_404_variable[0].to_i
		elsif temp_404_variable[1] =~ /\d+/
			use_404_for_trap_difficulty = temp_404_variable[1].to_i
		end
		$tpick_use_404_cancel = "cancel" if temp_404_variable[0] =~ /cancel/i || temp_404_variable[1] =~ /cancel/i
	else
		if UserVars.tpick["always_use_404"] =~ /\d+/
			use_404_for_trap_difficulty = UserVars.tpick["always_use_404"].to_i
		elsif UserVars.tpick["always_use_404"] == "yes"
			use_spell_404 = true
		end
	end
end

if Spell[506].known? && UserVars.tpick["always_use_506"] == "yes"
	use_spell_506 = true
end

if Spell[613].known? && UserVars.tpick["always_use_613"] == "yes"
	use_spell_613 = true
end

if Spell[704].known? && UserVars.tpick["always_use_704"] == "yes"
	use_spell_704 = true
end

if Spell[1006].known? && UserVars.tpick["always_use_1006"] == "yes"
	use_spell_1006 = true
end

all_variables_to_check.each{|i|
	if i == "loot"
		ground_loot = true
		wealth_before.call
		wait_until { silver_before }
		break
	end
}

minimum_tip_wanted = UserVars.tpick["minimum_tip_wanted"].to_i if UserVars.tpick["minimum_tip_wanted"].length > 0
max_critter_level = UserVars.tpick["max_critter_level"].to_i if UserVars.tpick["max_critter_level"].length > 0

all_variables_to_check.each{|i|
	if i =~ /\d+/ && i !~ /level/i
		minimum_tip_wanted = i.to_i
	end
}

all_variables_to_check.each{|i|
	if i =~ /level(\d+)/i
		max_critter_level = $1.to_i
	end
}

echo "Minimum tip wanted: #{minimum_tip_wanted}" if minimum_tip_wanted > 0
echo "Max level wanted: #{max_critter_level}" if max_critter_level != 1000

all_variables_to_check.each{|i|
	if i =~ /plin/
		open_plinites = true
		break
	end
}

all_variables_to_check.each{|i|
	if i == "v"
		always_use_vaalin = true
		break
	end
}

all_variables_to_check.each{|i|
	if i == "wedge"
		always_use_wedge = true
		break
	end
}

all_variables_to_check.each{|i|
	if i == "c"
		start_with_copper = true
		break
	end
}

always_use_vaalin = true if UserVars.tpick["calibrate"] =~ /never/i && start_with_copper.nil?

if (always_use_vaalin) && (start_with_copper)
	start_with_copper = nil
end

if (Char.prof !~ /Rogue|Bard/) && (start_with_copper == nil)
	always_use_vaalin = true
end

if UserVars.tpick["picks_to_use_based_on_critter_level"].length > 0 && always_use_vaalin
	picks_to_use_based_on_critter_level = UserVars.tpick["picks_to_use_based_on_critter_level"].split(",")
	picks_information_text = "Your picks to use based on critter level settings: "
	number = 0
	picks_to_use_based_on_critter_level.each{ |i|
		temp_picks_critter_level = i.split(" ")
		if number == 0
			picks_information_text += "Levels #{number}-#{temp_picks_critter_level[0]}: #{temp_picks_critter_level[1]}. "
		else
			picks_information_text += "Levels #{number + 1}-#{temp_picks_critter_level[0]}: #{temp_picks_critter_level[1]}. "
		end
		number = temp_picks_critter_level[0].to_i
	}
	picks_information_text += "All higher levels: vaalin"
end
	
all_variables_to_check.each{|i|
	if i == "bash"
		if open_plinites
			echo "Bash feature cannot be used when opening plinites."
			exit
		end
		bash_open_boxes = true
		break
	end
}

if (bash_open_boxes) && (Char.prof != "Warrior")
	echo "Only warriors can bash boxes."
	exit
end

all_variables_to_check.each{|i|
	if i == "disarm"
		if open_plinites
			echo "Disarm feature cannot be used when opening plinites."
			exit
		end
		disarm_only = true
		break
	end
}

all_variables_to_check.each{|i|
	if i == "relock"
		if open_plinites
			echo "Relock feature cannot be used when opening plinites."
			exit
		end
		relock_boxes = true
		break
	end
}

if (relock_boxes) && (bash_open_boxes)
	echo "\"relock\" and \"bash\" cannot both be used together."
	exit
end

all_variables_to_check.each{|i|
	if i == "pop"
		if open_plinites
			echo "Popping feature cannot be used when opening plinites."
			exit
		end
		popping = true
		break
	end
}

if popping && !Spell[416].known?
	echo "This feature requires the knowledge of Piercing Gaze (416)."
	exit
end

if popping && (UserVars.tpick["always_use_704"].nil? || UserVars.tpick["number_of_416_casts"].nil? || UserVars.tpick["only_disarm_safe"].nil? || UserVars.tpick["always_use_704"].empty? || UserVars.tpick["number_of_416_casts"].empty? || UserVars.tpick["only_disarm_safe"].empty?)
	echo "This feature requires all settings in the Popping tab in setup to be filled out before using."
	exit
end

(cast_205.call) if (use_spell_205) && (Spell[205].known?)

if (script.vars[1] == "ground" || script.vars[2] == "ground" || script.vars[3] == "ground" || script.vars[4] == "ground" || script.vars[5] == "ground" || script.vars[6] == "ground" || script.vars[7] == "ground" || script.vars[8] == "ground" || script.vars[9] == "ground" || script.vars[10] == "ground" || bash_open_boxes)
	if open_plinites
		echo "Ground feature cannot be used when opening plinites."
		exit
	end
	solo_or_other = "ground"
	calibrate.call if (UserVars.tpick["calibrate"] == "yes") && (always_use_vaalin == nil) && (popping == nil) && (can_use_calipers) && (start_with_copper == nil)
	start_ground.call
elsif (script.vars[1] == "other" || script.vars[2] == "other" || script.vars[3] == "other" || script.vars[4] == "other" || script.vars[5] == "other" || script.vars[6] == "other" || script.vars[7] == "other" || script.vars[8] == "other" || script.vars[9] == "other" || script.vars[10] == "other")
	if open_plinites
		echo "Other feature cannot be used when opening plinites."
		exit
	end
	if popping
		echo "Popping feature does not work when popping other people's boxes."
		exit
	end
	if (disarm_only) && (bash_open_boxes == nil)
		echo "Disarm only feature only works for ground picking."
		exit
	end
	solo_or_other = "other"
	fput "say #{UserVars.tpick["ready"]}" if UserVars.tpick["ready"] != "nil"
	start_others.call
elsif (script.vars[1] == "worker" || script.vars[2] == "worker" || script.vars[3] == "worker" || script.vars[4] == "worker" || script.vars[5] == "worker" || script.vars[6] == "worker" || script.vars[7] == "worker" || script.vars[8] == "worker" || script.vars[9] == "worker" || script.vars[10] == "worker")
	if open_plinites
		echo "Worker feature cannot be used when opening plinites."
		exit
	end
	if popping
		echo "Popping feature does not work when popping other people's boxes."
		exit
	end
	if (disarm_only) && (bash_open_boxes == nil)
		echo "Disarm only feature only works for ground picking."
		exit
	end
	solo_or_other = "worker"
	calibrate.call if (UserVars.tpick["calibrate"] == "yes") && (always_use_vaalin == nil) && (popping == nil) && (can_use_calipers) && (start_with_copper == nil)
	echo "#{picks_information_text}" if picks_to_use_based_on_critter_level
	start_worker.call
else
	if (disarm_only) && (bash_open_boxes == nil)
		echo "Disarm only feature only works for ground picking."
		exit
	end
	solo_or_other = "solo"
	wealth_before.call
	wait_until { silver_before }
	$tpick_boxes_checked = nil
	check_for_command = "inv full"
	check_for_boxes.call
	wait_until { $tpick_boxes_checked }
	if popping
		pop_start.call
	elsif open_plinites
		start_plinites.call
	else
		calibrate.call if (UserVars.tpick["calibrate"] == "yes") && (always_use_vaalin == nil) && (popping == nil) && (can_use_calipers) && (start_with_copper == nil)
		start_solo.call
	end
end