=begin
  asclearn.lic

  Learn all the ascension skills! You better have a lot of EXP!
  
  ;asclearn                                  - try to level all ascension skills from first in last to last
  ;asclearn <mnemonic>                       - will only learn the given mnemonic for an ascension skill
  ;asclearn <resist|stat|skill|regen|other>  - will attempt to learn all known skills in category
  ;asclearn levelup                          - will level you up first to 90,000,000 normal experience, then do full ascension skill training

   original author: Tysong
        maintainer: elanthia-online
              game: Gemstone
              tags: ascension, test
           version: 1.1.0

  Leveling Up EXEC:
  ;e silence_me; loop { Lich::Util.quiet_command_xml("level up", /<dialogData id='expr'\>/); sleep(0.1); break if Stats.exp > 90000000 }

  Changelog:
   v1.1.0 (2025-10-01)
     bake in levelup as a command option
   v1.0.0 (2022-04-14)
     initial release

=end

silence_me

script_args = Script.current.vars[1]

if script_args =~ /levelup/
  if Stats.level < 20
  
    (20 - Stats.level).times do
      Lich::Util.quiet_command_xml("level up", /<dialogData id='expr'\>/)
      sleep(0.1)
      break if Stats.level >= 19
    end

    sleep(5)
    fput('info')
    fput('levelup')


    if Stats.level == 19
      fput("skills confirm")
      fput("skills confirm")
    end
  end

  loop do
    Lich::Util.quiet_command_xml("level up", /<dialogData id='expr'\>/)
    sleep(0.1)
    break if Stats.exp > 90_000_000
  end
  script_args = nil
end


results = Lich::Util.quiet_command_xml("asc list", /the following Ascension Abilities are available/)
asc_skills = Hash.new

results.each { |line|
    if /(?<mnemonic>[\w]+)<\/d\>\s+(?<ranks_current>[\d]+)\/(?<ranks_max>[\d]+)(?:.*)(?<subcategory>Resist|Stat|Skill|Other|Regen)/ =~ line
        asc_skills[mnemonic] = {
            :ranks_current => ranks_current.to_i,
            :ranks_max => ranks_max.to_i,
            :subcategory => subcategory.downcase
        }
    end
}

if script_args =~ /^(?:resist|stat|skill|other|regen)$/i
    asc_skills.each { |skill|
        next if skill[1][:subcategory] != variable[1].downcase
        (skill[1][:ranks_max] - skill[1][:ranks_current]).times { 
            result = dothistimeout "asc learn #{skill[0]}", 3, /You do not have enough points available\.|You have chosen to learn rank/
            if result =~ /You do not have enough points available\./
                exit
            end
            fput "asc learn confirm" 
        }
    }
elsif !script_args.nil?
    asc_skills.each { |skill|
        next if skill[0] != script_args.downcase
        (skill[1][:ranks_max] - skill[1][:ranks_current]).times { 
            result = dothistimeout "asc learn #{skill[0]}", 3, /You do not have enough points available\.|You have chosen to learn rank/
            if result =~ /You do not have enough points available\./
                exit
            end
            fput "asc learn confirm" 
        }
    }
else
    asc_skills.each { |skill|
        (skill[1][:ranks_max] - skill[1][:ranks_current]).times { 
            result = dothistimeout "asc learn #{skill[0]}", 3, /You do not have enough points available\.|You have chosen to learn rank/
            if result =~ /You do not have enough points available\./
                exit
            end
            fput "asc learn confirm" 
        }
    }
end