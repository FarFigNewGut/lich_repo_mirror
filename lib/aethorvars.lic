=begin
	this script is stored variables, 
	it was created using gib's library and a bunch of other random global variables that need stored for later use.
	
=end
#Skin weapon = false unless you're skinning stuff, otherwise, it is the NOUN of your skinning weapon.
skinweapon = false
gemsack = false
firstsack = false
secondsack = false
thirdsack = false
#Sheaths are currently unsupported, however they're there in order to simplify expansion in the future.
sheath = false
sheath2 = false
#This is where non-gem gemshop items will go.
jewelsack = false
wandsack = false
scrollsack = false
magicsack = false
alchsack = false
fursack = false
boxsack = false
junksack = false
#This is for locksmiths, mainly, for sorting their lockpicks and other related items into a single container.
locksack = false

##### THE FOLLOWING WILL GATHER YOUR CONTAINER INFORMATION FOR USE BY THE SCRIPT #####
silence_me
contid = []
done = false
action = proc{ |grab_this|
	if grab_this =~ /You are wearing/i
		$contid = grab_this.scan(/a exist\=\"([\d]+)[^\.|,]/).flatten
		grab_this
	elsif grab_this =~ /\<prompt time\=/
		done = true
		grab_this
	end
}
DownstreamHook.add('inv_cont', action)
status_tags
$_SERVER_.puts "inv cont"
t=Time.now
wait_until {done or t+3<Time.now}
DownstreamHook.remove('inv_cont')
status_tags
$contid = []
$contids.each{|thing|;$contid.push(thing.to_s)}
def hook_error_conts
	status_tags
	fput "inv cont"
	line = matchwait /You are wearing.*?\./
	status_tags
	$contid = []
	contids = []
	contids = line.scan(/a exist\=\"([\d]+)[^\.|,]/)
	contids.each{|thing|;$contid.push(thing.to_s)}
	$looked = false unless $looked
	unless $looked
		$contid.each{|id|
			fput "l in ##{id}"
			x = matchwait /is|the|empty/i
			if x =~ /closed/
				fput "open ##{id}"
				fput "l in ##{id}"
				fput "close ##{id}"
			end
		}
		$looked = true
	end
end
 if $contid.empty?
 	hook_error_conts
 	if $contid.empty?
		echo "WE FOUND NO CONTAINERS, ERROR!  EXITING!"
		exit
	end
end

###### THE FOLLOWING IS MY CUSTOMIZED VARIABLES FOR MY CURRENT CHARACTERS ########

if Char.name =~ /Aethor/
	gemsack = "reliquary"
	firstsack = "cloak"
	secondsack = "pack"
	locksack = "cloak"
	ammosack = 'satchel'
	skinweapon = "knife"
	orbsack = "satchel"
	chrismsack = "bag"
	cutter = "gaint"
	fursack = "satchel"
	$upstance = 'guarded'
	herbsack = "satchel"
	$myitem = ["dull gold coin", "moonstone cube","small statue", "aquamarine wand"]
elsif Char.name =~ /Teclys/
	skinweapon = false
	gemsack = 'satchel'
	firstsack = "longcoat"
	secondsack = "backpack"
	thirdsack = "satchel"
	sheath = false
	sheath2 = false
	jewelsack = "satchel"
	wandsack = "longcoat"
	scrollsack = "satchel"
	magicsack = "backpack"
	alchsack = "longcoat"
	boxsack = "longcoat"
	junksack = "longcoat"
	locksack = false
	herbsack = "satchel"
	fursack = "longcoat"
	$upstance = 'guarded'
	$myitem = ['small statue', 'heavy quartz orb','dull gold coin']
else

	respond "NO HELP, figure it out, or delete me.  Either way."
	respond "The script WILL automatically find and assign lootsacks if you have not specified them.  You might not like what it puts where, but you could have changed the variables yourself."
end
if firstsack then $firstsack = firstsack else $firstsack = GameObj.inv.find{|thing| thing.noun =~ /pack|cloak|coat|mantle|mantlet/ && thing.id.to_s =~ /#{$contid.join('|')}/}.noun end
if secondsack then $secondsack = secondsack else $secondsack = GameObj.inv.find{|thing| thing.noun != $firstsack && thing.noun =~ /pack|cloak|coat|mantle|mantlet/ && thing.id.to_s =~ /#{$contid.join('|')}/}.noun end
if skinweapon then $skinweap = skinweapon elsif $skin_weapon then $skinweap = $skin_weapon end
if gemsack then $gemsack = gemsack else $gemsack = $firstsack end
if jewelsack then $jewelsack = jewelsack else $jewelsack = $firstsack end
if wandsack then $wandsack = wandsack else $wandsack = $firstsack end
if scrollsack then $scrollsack = scrollsack else $scrollsack = $firstsack end
if magicsack then $magicsack = magicsack else $magicsack = $firstsack end
if alchsack then $alchsack = alchsack else $alchsack = $firstsack end
if boxsack then $boxsack = boxsack else $boxsack = $firstsack end
if junksack then $junksack = junksack else $junksack = $firstsack end
if locksack then $locksack = locksack else $locksack = $firstsack end
if herbsack then $herbsack = herbsack else $herbsack = $firstsack end
if fursack then $fursack = fursack else $fursack = $firstsack end
$gs4sacks = [$firstsack, $gemsack, $jewelsack, $wandsack, $scrollsack, $magicsack, $alchsack, $boxsack, $junksack, $locksack, $herbsack, $fursack]
# ********************  JUNK STUFF *****************

	$junknouns ||= ["bark","iron","brick","horseshoe"]
	$junknames ||= ["marble statue", "pair of unlaced boots", "belt pack","crude roa'ter\-toothed necklace", 'ragged sack', 'corroded iron goupillon', "lynx skull", "scratched ring", "crudely forged iron halberd", "deerskin quiver","filthy knapsack","crystal\-tipped staff", "bent anklet", "bent bracelet", "bent coin", "bent ring", "bent earring", "bent medallion",'bent nail', "moldy bone","chipped brick", "cloth", "cookie", "corroded anklet", "corroded bracelet", "corroded coin","corroded earring", "corroded medallion","corroded ring", "cupcake", "dented anklet", "dented bracelet", "dented coin", "dented earring", "dented medallion", "doorknob", "doughnut", "rusty nail","bent nail","tarnished nail","corroded nail","fork", "horseshoe", "piece of iron", "leg$", "muffin", "polished anklet", "polished bracelet", "polished coin", "polished earring", "polished medallion", "rusty anklet", "rusty bracelet", "rusty coin", "rusty earring", "rusty medallion", "scratched anklet", "scratched bracelet", "scratched coin", "scratched earring", "scratched medallion", "shiny anklet", "shiny bracelet", "shiny coin", "shiny earring", "shiny medallion", "spoon", "smooth stone", "steel spring", "tarnished anklet", "tarnished bracelet", "tarnished coin", "tarnished earring", "tarnished medallion", "tart", "dented nail","scratched nail","rusty nail","polished nail","shiny nail", 'invar kaskara' ]
	$dishes ||= ["flagon","bowl","chalice","^cup$", "ewer","flask","goblet","pitcher", "^plate$", "platter", "jug","stein","^tray", "fork","spoon"]
	$foods ||= ["^tea?","pastry","cookie","tart","candy","chocolate","^ale$","special", "doughnut","muffin","beer","rum","special","dragondraught","vodka","water","punch"]

# ******************* WEAPONS, ARMOR, AND MATERIALS ****************

	$gmats ||= ["long.razor.sharp", "perfect", "superior", "well.crafted", "arcane", "alexandrite", "alum",  "bronze", "carmiln", "coraesine", "deringo", "drakar", "drake","eahnor", "eonake", "enruned", "faenor", "faewood", "feras","fireleaf", "glaes", "glowbark", "golvern", "gornar", "hoarbeam", "illthorn", "imflass", "invar", "ipantor", "ironwood", "kakore", "kelyn", "krodera", "laje", "\blor\s", "mein", "mesille", "mithglin", "mithril", "mossbark", "obsidian", "\sora\s", "orase", "razern", "rhimar", "rolaren", "rowan", "ruic", "sephwir", "urglaes", "urnon", "vaalin", "vaalorn", "veil iron", "veniom", "villswood", "vultite", "witchwood", "wyrwood", "yew", "zorchar"]
	#"modwir",
	$topmats = ["long.razor.sharp", "perfect", "superior", "well.crafted", "arcane", "vultite", "eonake", "faewood", "fireleaf", "glowbark", "ilthorn", "ipantor", "^lor$", "orase", "ruic", "sephwir", "villswood", "witchwood", "wyrwood", "eahnor", "golvern", "krodera", "rolaren", "urnon", "vaalorn", "veil iron"]
	$cheapmats = $gmats - $topmats
	$gweaps ||= ["achlais", "adze", "angon", "awl\-pike", "axe", "backsword", "baculus", "badelaire", "balestarius", "breastplate","chain", "ball\-and\-chain", "ball", "balta", "bardiche", "baselard", "battle\-axe", "battlesword", "bidenhander", "bilbo", "bill", "binnol", "bisacuta", "blackjack", "bodkin", "bola", "^bow$", "brandestoc", "braquemar", "broadsword", "bulawa", "bullwhip", "cat\-o'\-nine\-tails", "cateia", "cestus", "chakram", "chereb", "cinquedea", "claidhmore", "claw", "cleaver", "club", "colichemarde", "contus", "craquemarte", "croc", "crook", "crosier", "crossbow", "crowbill", "cudgel", "cutlass", "dagger", "dart", "dhara", "dirk", "discus", "doloire", "dubh", "epee", "espadon", "estoc", "falarica", "falcastra", "falchion", "falx", "fang", "fauchard", "fist\-scythe", "flail", "flamberge", "fleuret", "flyssa", "foil", "fork", "framea", "francisca", "fuscina", "gaesum", "gauche", "gauntlet\-sword", "gladius", "glaive", "godendag", "goliah", "goupillon", "greataxe", "greatsword", "guisarme", "halberd", "half\-moon", "hammer of kai", "hammer", "handaxe", "harpoon", "hatchet", "hippe", "hook\-knife", "hoolurge", "jackblade", "jaculum", "javelin", "jeddart\-axe", "jitte", "kai", "kama", "kaskara", "katana", "katar", "katzbalger", "kheten", "khopesh", "kilij", "knife", "knuckle\-blade", "knuckle\-duster", "korseke", "kozuka", "kris", "lance", "lisan", "longbow", "longsword", "mace", "machera", "machete", "magari\-yari", "mail", "manople", "massuelle", "mattina", "mattock", "maul", "misericord", "^moon$", "nagimaki", "naginata", "^net$", "oncin", "paingrip", "palache", "parazonium", "partisan", "pavade", "pelta", "periperiu", "pernat", "^pick", "pike", "pill", "pilum", "poignard", "pugio", "quadrelle", "quoit", "ranseur", "rapier", "razorpaw", "runestaff", "runka", "sabar", "sabre", "^sai$", "^sap$", "sapara", "sarissa", "scepter", "schiavona", "schlager", "scimitar", "scorpion", "scramasax", "scythe", "seax", "shail", "shillelagh", "sica", "sledgehammer", "spadroon", "sparte", "spatha", "spear", "spetum", "spiculum", "spontoon", "sprinkler", "staff", "^star$", "^stick$", "stiletto", "sudis", "sword", "taavish", "tabar", "tails", "takouba", "tambara", "tanto", "taper", "tetsubo", "tock", "tocke", "tongue", "toporok", "trident", "troll\-claw", "truncheon", "tuck", "verdun", "voulge", "wakizashi", "waraxe", "whip", "whip\-blade", "xiphos", "yataghan", "yierka\-spur", "yoribo", "zinnor", "zweihander"]
	$gweapname ||= ["belaying pin", "green-tinted vial filled with thick acrid smoke","thick glass vial filled with murky red liquid","hazy glass vial", " clear glass vial of light yellow acid", "glass vial"]
	$ggear ||= ["aegis", "arm\-guards", "armor", "aventail", "bracer", "bracers", "brigandine", "buckler", "chain", "chainmail", "coif", "full plate", "full\-plate", "gauntlets", "gorget", "greathelm", "greatshield", "greaves", "guards", "half plate", "half\-plate", "hauberk", "heater", "helm", "jerkin", "kite", "leather", "leathers", "leggings", "leg\-guards", "mail", "mantlet", "parma", "pavis", "ringmail", "robes", "scutum", "shield", "targe", "vambraces"]
	$gshield ||= ["aegis", "buckler","greatshield","mantlet","parma","pavis", "scutum","shield","targe"]

# ****************** GEMS ********************

	$gemnouns ||= ["ora\-bloom", "vultite\-bloom", "sphene", "aetherstone", "agate", "corestone", "amber$", "amethyst", "azurite", "beryl", "blazestar", "bloodjewel", "bloodstone", "bluerock", "caederine", "carbuncle", "chalcedony", "coral", "cordierite", "deathstone", "despanal", "diamond", "diopside", "doomstone", "dreamstone", "^egg$", "emerald", "eostone", "faenor", "faenor\-bloom", "^fang$", "feystone", "firestone", "galena", "garnet", "^gem$", "geode", "glimaerstone", "heliodor", "hyacinth", "jacinth", "jade", "jasper", "lapis", "lazuli", "marble", "mithril\-bloom", "moonstone", "obsidian", "onyx", "opal", "pearl", "peridot", "pyrite", "quartz", "rhimar", "riftshard", "riftstone", "rosespar", "ruby", "sapphire", "spherine", "spinel", "starstone", "^stone$", "sunstone", "thunderstone", "topaz", "tourmaline", "turquoise", "wyrdshard", "zircon"]
	$gemnames ||= ["piece of mica", "piece of polished ivory", "silvery galena", "glaesine crystal", "cinnabar crystal", "shimmertine shard","tigerfang crystal", "quartz crystal", "platinum fang",  "gold fang","tigerfang crystal", "rock crystal", "umber sard"]

# ************* GEMSHOP EXTRAS **************

	$jewelery ||= ["amulet", "statuette", "statue","miniature","figurine","sculpture","headband","pendant","^band$","barrette","baton", "bracelet","bracer","brooch","buckle","circlet","charm","clasp","crown","earcuffs?", "earrings?","medallion","neckchain","necklace","^pin$","^ring$", "sceptre","stickpin","talisman","tiara","torc"]
	$ogems ||= ["sandsilver", "modwir","maoral","marble","nugget", "scarab", "shell", "sphere"] #dust
	$ogemnames ||= ["polished shark tooth", "petrified mammoth tusk", "petrified toadstool", "gold dust","platinum dust", "glaes dust","petrified tiger tooth","petrified maoral" "petrified modwir","petrified haon", "petrified thanot","dark crystal", "gold dust","platinum dust"]

# ************ MAGIC SHIT ************

	$scrolls ||= ["palimpsest", "paper", "papyrus", "parchment","scroll","vellum"]
	$wands ||= ["rod","wand"]
	$wandnames ||= ["aquamarine wand", "bloodwood wand", "blue wand", "bone wand", "coral wand", "crystal wand", "glass wand", "golden wand", "iron wand", "metal wand", "oaken wand", "ruby amulet","silver wand", "thanot wand", "twisted wand"]
	$magicnouns ||= ["granules", "cube","orb","triangle","filings", "ambergris"]
	$magicnames ||= ["scintillating fishscale", "block of salt", "drake","feras","black crystal","white crystal", "blue crystal", "dull gold coin","crystal amulet"]

# *********** ALCHEMY SHIT **************

	$alchnouns ||= ["seed", "earth", "hair",  "water", "core", "globe", "essence", "^fire$", "humor"]
	$alchnames ||= ["ayanad crystal$", "troll tooth","essence dust", "essence shard"]

# ********** BOXES *************

	$boxes ||= ["^box", "chest", "coffer", "strongbox", "trunk"]

# ******** CONTAINERS AND CLOTHES ***********

	$lockable_nouns ||= ["backpack", "case", "casket", "handbag", "haversack", "hip\-satchel", "kit", "knapsack", "pack", "prayerbook", "purse", "quiver", "register", "reliquary", "reticule", "rucksack", "satchel", "sheath", "songbook", "sporran", "tome", "toolkit", "tube"]
	$containers ||= ["cloak", "longcoat", "mantle", "^pouch", "sack", "scabbard","harness"]
	$clothes ||= ["^cape?$", "shoes","armband","vest","tunic","slippers","ribbon", "armband", "frock", "bandana", "bonnet", "belt", "blouse","chemise","hat", "kilt","bodice","boots", "coat", "dress", "gloves", "gloves", "gown", "hood", "jacket", "kerchief", "kirtle", "leggings", "neckerchief","overcoat", "pants", "robes","sash", "scarf", "shawl", "shirt","skirt", "snood", "socks", "tabard", "trousers"]
	$safepicks ||= ['copper lockpick','steel lockpick','silver lockpick']

# *********** OTHER SHIT *******************

	$ignore_list ||= ["sign","arch","barrel","basket","bench","table","chair","bin","receptical","ladder","step","stair","tapestry", "road","trail","path"]
	$gherb_list ||= ["ochre\-colored fungus","acantha leaf", "aloeas stem", "ambrominas leaf", "basal moss", "cactacae spine", "calamia fruit", "ephlox moss", "haphip root", "pothinir grass", "sovyn clove", "torban leaf", "wolifrew lichen", "woth flower"]
	$gherb_teras ||= ["Aged Schooner ale", "Agrak's Amber ale", "Bearded Ladies' ale", "Bloody Krolvin ale", "Captn' Pegleg's ale", "Dacra's Dream ale", "Dark Swampwater ale", "Dead Man's Pale ale", "Dragon's Blood porter", "Gert's Homemade ale", "Golden Goose ale", "Kenar's Dropjaw ale", "Lost Dogwater ale", "Mad Mutt Frothy ale", "Mama Dwarf's ale", "Miner's Muddy ale", "Olak's Ol'style ale", "Orc's Head ale", "Reaper's Red ale", "Semak's Smooth ale", "Volcano Vision ale", "Wort's Winter ale"].downcase
	$gherb_potions ||= ["bolmara potion", "brostheras potion", "bur\-clover potion", "rose\-marrow potion", "talneo potion", "wingstem potion"]
	$gherb_icemule ||= ["Dabbings Family special tart", "Leaftoe's lichen tart", "Ma Leaftoe's spiced torban tart", "earthworm potion", "elk fat gel", "elk horn potion", "flower\-shaped tart", "frog's bone porridge", "iceberry tart", "musk ox tart", "polar bear fat soup", "ram's bladder", "rock lizard potion", "rock ptarmigan feathers", "snowflake elixir", "sparrowhawk pie", "starfish potion", "tundra grass", "walrus blubber"].downcase
	$gherb_tinctures ||= ["tincture of acantha", "tincture of aloeas", "tincture of ambrominas", "tincture of basal", "tincture of bolmara", "tincture of brostheras", "tincture of bur\-clover", "tincture of cactacae", "tincture of calamia", "tincture of ephlox", "tincture of haphip", "tincture of pothinir", "tincture of rose\-marrow", "tincture of sovyn", "tincture of talneo", "tincture of torban", "tincture of wingstem", "tincture of wolifrew", "tincture of woth"]
	$gherb_zul ||= ["chunky black ale", "bubbling brown ale", "thick foggy ale", "crushed cavegrass tea", "roasted ratweed tea", "brown weedroot ale",  "dark frothing ale", "dirty crevice brew", "dirty rat fur potion", "dull crimson ale", "glowing mold tea", "grainy black potion", "green mushroom potion", "grey mushroom potion", "milky white potion", "rusty red ale", "spotted toadstool ale", "stalactite brew", "stalagmite brew", "sticky lichen tea", "stone soot brew"]
	$gherbs ||= ["white flask", $gherb_list, $gherb_teras, $gherb_potions, $gherb_icemule, $gherb_tinctures, $gherb_zul]
	$notes ||= ["note","scrip", "chit"]
	$pelts ||= ['pelt','sail','scalp','paw','tusk','skin','hide','plume','^ear$', 'scraping', '^eye$', 'nose',  '^sail$']
	$peltname ||= ['marmot pelt','ghoul nail','orc scalp','black leopard paw','boar tusk','plains lion skin','brown gak hide','cockatrice plume','striped relnak sail','orc beard', 'rolton ear', 'brown gak hide', 'ogre nose', 'ghoul scraping', 'mist wraith eye', 'skeleton bone', 'ghoul nail','striped relnak sail']

# ************** SPECIAL CASE, PROFESSION SPECIFIC, AND OTHERWISE RANDOM SHIT ********
	$lfmnames ||= ["straightened steel spring","thick glass vial filled with murky red liquid", "green\-tinted vial filled with thick acrid smoke", "clear glass vial of light yellow acid",  "slender steel needle", "pair of small steel jaws"]
	$lfmnoun ||= ["lockpick", "calipers"]
	$keepnouns ||= ["badge", "neckpouch", "toolkit",  "bottle", "^key$", "manifest","bankbook","staff"]
	$keepnames ||= ["oak amulelt", "hammered steel vambraces", "glyph-etched red sunstone torc", "bronze and peridot clasp", "beveled golden topaz ring", "rune-etched gold bracer", "thick rod", "blood red flask", "amethyst inset gold band", "shuttered brass lantern charm", "burnished golden clasp", "starstone studded copper bracelet", "black crystal", "white crystal", "stained rod", "flexible rod", "solid moonstone cube", "dull gold coin", "simple.*?flask", 'scarred blood red toolkit', 'thin rod', 'filigreed pewter bracer', 'slender blackened stiletto', 'blood red stiletto', "heavy quartz orb",  "white flask", "ivory vellum document", "small statue", "white flask", "straightened steel spring", "shadowy grey leather boots", "shuttered steel lantern charm", "Adventurer's Guild badge", "engraved gold band",  "pewter and dragonfire opal crown", "emerald\-set pewter torc", "marquise\-cut blue dreamstone crown", "flame\-cut garnet headband", "tree bark amulet", 'wiregrass anklet', 'wiregrass bracelet']
	if XMLData.game =~ /gsf/i
		echo "SHATTERED, DELETING WHITE AND BLACK CRYSTALS, WHITE FLASKS, AND .... nothing"
		$keepnames.delete("white crystal")
		$keepnames.delete("black crystal")
		$keepnames.delete('white flask')
	end
	if Char.prof == "Sorcerer"
		$infusename ||= ["hammered invar cup"]
		$infusenoun ||= ["^runestone$", "brush","ink"]
	end
	#$mydebug = true if Char.name =~ /Aethor|Teclys|Temerrk|Aethorious\Spinit/

def loot_data
	$infusers = []
	$myjunk = []
	$mypawn = []
	$mygem = []
	$myogem = []
	$myalch = []
	$mymagic = []
	$myspecial = []
	$myherbs = []
	$myscroll = []
	$myboxes = []
	$myrings = []
	$mygear = []
	$mywand = []
	$unknown = []
	$myclothes = []
	$myfur = []
	$sellpicks = []
	$drakenferas = []
	$ammo = []
	$garrows = []
	$gbundles = []

	$contid.each{|id|
#		echo GameObj.inv.find{|shit| shit.id.to_i == id.to_i}.name
		GameObj.inv.find{|cont| cont.id.to_s == id}.contents.each{|item|
			if item.id.to_i <= 100000 then $junk.push(item)
			elsif item.noun =~ /#{$keepnouns.join('|')}/ || item.name =~ /#{$keepnames.join('|')}/ then $myspecial.push(item)
			elsif item.noun == 'ring' && item.name =~ /gold ring/i && item.name !~ /heavily enruned/ then $myrings.push(item)
			elsif item.name =~ /#{$gherbs.join('|')}/ then $myherbs.push(item)
			elsif (item.name =~ /#{$infusename.join('|')}/ || item.noun =~ /#{$infusenoun.join('|')}/) && Char.prof == "Sorcerer" then $infusers.push(item)
			elsif item.noun =~ /#{[$foods, $junknouns].flatten.join('|')}/ || item.name =~ /#{$junknames.join('|')}/ then $myjunk.push(item)
			elsif item.name =~ /(drake|feras) (#{$gweaps.join('|')})/ then $drakenferas.push(item) #unless item.noun =~ /dagger|stiletto/
			elsif item.noun =~ /#{[$gweaps, $ggear].flatten.join('|')}/  && item.name =~ /#{$gmats.join('|')}/ then $myspecial.push(item) unless item.name =~ /drake|feras/;$mypawn.push(item) if item.name =~ /drake|feras/i
#			elsif item.name =~ /#{$gweapname.join('|')}/ then	$myspecial.push(item) if item.name =~ /#{$gmats.join('|')}/;$mypawn.push(item) if item.name =~ /drake|feras/i;$mypawn.push(item) unless $myspecial.include?(item)
			elsif item.noun =~ /#{[$gweaps, $ggear].flatten.join('|')}/ || item.name =~ /#{$gweapname.join('|')}/ then $mygear.push(item)
			elsif item.noun =~ /#{[$gemnouns, $ogems].flatten.join('|')}/ || item.name =~ /#{[$gemnames, $ogemnames].flatten.join('|')}/ then $mygem.push(item)
			elsif item.noun =~ /#{$scrolls.join('|')}/ then $myscroll.push(item)
			elsif item.noun =~ /#{$wands.join('|')}/ || item.name =~ /#{$wandnames.join('|')}/ then $mywand.push(item)
			elsif item.noun =~ /#{$magicnouns.join('|')}/ || item.name =~ /#{$magicnames.join('|')}/ then $mymagic.push(item)
			elsif item.noun =~ /#{[$dishes, $jewelery].flatten.join('|')}/ then $myogem.push(item)
			elsif item.noun =~ /#{$alchnouns.join('|')}/ || item.name =~ /#{$alchnames.join('|')}/ then $myalch.push(item)
			elsif item.noun =~ /#{[$lockable_nouns, $containers].flatten.join('|')}/ then $myclothes.push(item)
			elsif item.noun =~ /#{$clothes.join('|')}/ then $myclothes.push(item)
			elsif item.name =~ /#{$safepicks.join('|')}/ then $sellpicks.push(item)
			elsif item.noun =~ /#{$lfmnoun.join('|')}/ || item.name =~ /#{$lfmnames.join('|')}/ then $myspecial.push(item)
			elsif item.noun =~ /#{$boxes.join('|')}/ then $myboxes.push(item)
			elsif item.noun =~ /#{$pelts.join('|')}/ || item.name =~ /#{$peltname}/ then $myfur.push(item)
			#elsif item.noun =~ /arrow|bolt/i then $ammo.push(item)
			elsif item.noun =~ /arrows|bolts/ then $gbundles.push(item)
			elsif item.noun =~ /arrow|bolt/ then $garrows.push(item)
			else
	#			respond "I don't know what #{item.name} is for so we'll ignore it."
				$unknown.push(item)
			end
		}
	}
	$ammo = [$garrows, $gbundles].flatten
	$omypawn = [ $mygear, $mymagic, $myclothes, $mywand, $drakenferas].flatten
	$omypawn.push($sellpicks) unless Char.prof =~ /Rogue/i
	$mypawn = $omypawn.flatten
	$mysellgems = [$mygem, $myogem].flatten
	$all_my_shit = [$myboxes, $myspecial, $myherbs, $mypawn, $myalch, $myscroll, $myogem, $mygem, $mygear, $myjunk, $myrings, $mywand, $unknown, $myfur, $sellpicks, $drakenferas, $gbundles, $garrows]
	$all_my_shit.push($infusers) if Char.prof == "Sorcerer"
	$allshit = []
	return($all_my_shit.flatten)
end
def ldata2
	$infusers = []
	$myjunk = []
	$mypawn = []
	$mygem = []
	$myogem = []
	$myalch = []
	$mymagic = []
	$myspecial = []
	$myherbs = []
	$myscroll = []
	$myboxes = []
	$myrings = []
	$mygear = []
	$mywand = []
	$unknown = []
	$myclothes = []
	$myfur = []
	$sellpicks = []
	$drakenferas = []
	$ammo = []
	$garrows = []
	$gbundles = []
	gfindall.each{|item|
		if item.id.to_i <= 100000 then $junk.push(item)
		elsif item.noun =~ /#{$keepnouns.join('|')}/ || item.name =~ /#{$keepnames.join('|')}/ then $myspecial.push(item)
		elsif item.noun == 'ring' && item.name =~ /gold ring/i then $myrings.push(item)
		elsif item.name =~ /#{$gherbs.join('|')}/ then $myherbs.push(item)
		elsif (item.name =~ /#{$infusename.join('|')}/ || item.noun =~ /#{$infusenoun.join('|')}/) && Char.prof == "Sorcerer" then $infusers.push(item)
		elsif item.noun =~ /#{[$foods, $junknouns].flatten.join('|')}/ || item.name =~ /#{$junknames.join('|')}/ then $myjunk.push(item)
		elsif item.name =~ /(drake|feras) (#{$gweaps.join('|')})/ then $drakenferas.push(item) #unless item.noun =~ /dagger|stiletto/
		elsif item.noun =~ /#{[$gweaps, $ggear].flatten.join('|')}/  && item.name =~ /#{$gmats.join('|')}/ then $myspecial.push(item) unless item.name =~ /drake|feras/;$mypawn.push(item) if item.name =~ /drake|feras/i
	#			elsif item.name =~ /#{$gweapname.join('|')}/ then	$myspecial.push(item) if item.name =~ /#{$gmats.join('|')}/;$mypawn.push(item) if item.name =~ /drake|feras/i;$mypawn.push(item) unless $myspecial.include?(item)
		elsif item.noun =~ /#{[$gweaps, $ggear].flatten.join('|')}/ || item.name =~ /#{$gweapname.join('|')}/ then $mygear.push(item)
		elsif item.noun =~ /#{[$gemnouns, $ogems].flatten.join('|')}/ || item.name =~ /#{[$gemnames, $ogemnames].flatten.join('|')}/ then $mygem.push(item)
		elsif item.noun =~ /#{$scrolls.join('|')}/ then $myscroll.push(item)
		elsif item.noun =~ /#{$wands.join('|')}/ || item.name =~ /#{$wandnames.join('|')}/ then $mywand.push(item)
		elsif item.noun =~ /#{$magicnouns.join('|')}/ || item.name =~ /#{$magicnames.join('|')}/ then $mymagic.push(item)
		elsif item.noun =~ /#{[$dishes, $jewelery].flatten.join('|')}/ then $myogem.push(item)
		elsif item.noun =~ /#{$alchnouns.join('|')}/ || item.name =~ /#{$alchnames.join('|')}/ then $myalch.push(item)
		elsif item.noun =~ /#{[$lockable_nouns, $containers].flatten.join('|')}/ then $myclothes.push(item)
		elsif item.noun =~ /#{$clothes.join('|')}/ then $myclothes.push(item)
		elsif item.name =~ /#{$safepicks.join('|')}/ then $sellpicks.push(item)
		elsif item.noun =~ /#{$lfmnoun.join('|')}/ || item.name =~ /#{$lfmnames.join('|')}/ then $myspecial.push(item)
		elsif item.noun =~ /#{$boxes.join('|')}/ then $myboxes.push(item)
		elsif item.noun =~ /#{$pelts.join('|')}/ || item.name =~ /#{$peltname}/ then $myfur.push(item)
		#elsif item.noun =~ /arrow|bolt/i then $ammo.push(item)
		elsif item.noun =~ /arrows|bolts/ then $gbundles.push(item)
		elsif item.noun =~ /arrow|bolt/ then $garrows.push(item)
		else
	#			respond "I don't know what #{item.name} is for so we'll ignore it."
			$unknown.push(item)
		end
	}
	$ammo = [$garrows, $gbundles].flatten
	$omypawn = [ $mygear, $mymagic, $myclothes, $mywand, $drakenferas].flatten
	$omypawn.push($sellpicks) unless Char.prof =~ /Rogue/i
	$mypawn = $omypawn.flatten
	$mysellgems = [$mygem, $myogem].flatten
	$all_my_shit = [$myboxes, $myspecial, $myherbs, $mypawn, $myalch, $myscroll, $myogem, $mygem, $mygear, $myjunk, $myrings, $mywand, $unknown, $myfur, $sellpicks, $drakenferas, $gbundles, $garrows]
	$all_my_shit.push($infusers) if Char.prof == "Sorcerer"
	$allshit = []
	return($all_my_shit.flatten)
end
def gsort
	#loot_data
	ldata2
	counter = 0
	$all_my_shit.each{|thing|
		counter += 1
		msg "MYBOXES" if counter == 1 unless thing.empty?
		msg "MYSPECIAL" if counter == 2 unless thing.empty?
		msg "MYHERBS" if counter == 3 unless thing.empty?
		msg "MYPAWN" if counter == 4 unless thing.empty?
		msg "MYALCH" if counter == 5 unless thing.empty?
		msg "MYSCROLL" if counter == 6 unless thing.empty?
		msg "MYOGEM" if counter == 7 unless thing.empty?
		msg "MYGEM" if counter == 8 unless thing.empty?
		msg "MYGEAR" if counter == 9 unless thing.empty?
		msg "MYJUNK" if counter == 10 unless thing.empty?
		msg "MYRINGS" if counter == 11 unless thing.empty?
		msg "MYWAND" if counter == 12 unless thing.empty?
		msg "UNKNOWN" if counter == 13 unless thing.empty?
		msg "MYFUR" if counter == 14 unless thing.empty?
		msg "SELLPICKS" if counter == 15 unless thing.empty?
		msg "DRAKENFERAS" if counter == 16 unless thing.empty?
		msg "GBUNDLES" if (counter == 17) unless thing.empty?
		msg "GARROWS" if (counter == 18) unless thing.empty?
		msg "INFUSERS" if (counter == 19 && Char.prof == "Sorcerer") unless thing.empty?
		array = []
		thing.each{|item| array.push(item.name)}
		respond array.join(', ') unless thing.empty?
	}
	respond ""
	gemshopstuff = []
	pawnshopstuff = []
	boxstuff = []
	$myboxes.each{|box| boxstuff.push(box.name)}
	$mysellgems.each{|thing| gemshopstuff.push(thing.name)}
	$mypawn.each{|thing| pawnshopstuff.push(thing.name)}
	unless gemshopstuff.empty?
		msg "GEMSHOP STUFF:  Variable = $mysellgems"
		respond "#{gemshopstuff.join(', ')}."
	end
	unless pawnshopstuff.empty?
		msg "PAWNSHOP STUFF:  Variable = $mypawn"
		respond "#{pawnshopstuff.join(', ')}."
	end
	unless boxstuff.empty?
		msg "BOXES:  Variable = $myboxes"
		respond "#{boxstuff.join(', ')}."
	end
end
def gloot
#	respond "gloot building loot array"
	$yourdisk = false
	$newloot = []
	$garrows = []
	$diskthese = []
	$phasethese = []
#	allrloot
	GameObj.loot.each{|item|
		if item.id.to_i <= 100000 then respond "item is probably stationary room stuff, #{item.name}, #{item.id}" if $mydebug
		elsif item.name =~ /black ora|massive glaes club/ then respond "#{item.name} found, ignoring"
		elsif item.noun =~ /#{$pelts.join('|')}/ || item.name =~ /#{$peltname.join('|')}/ then $newloot.push([item.id, GameObj.inv.find{|cont| cont.noun == $fursack}.id])
		elsif item.noun =~ /#{$dishes.join('|')}/ && item.name =~ /#{[$gemnouns, $gmats].flatten.join('|')}/ then $newloot.push([item.id, GameObj.inv.find{|cont| cont.noun == $jewelsack}.id])
		elsif item.name =~ /#{$gherbs.flatten.join('|')}/i then	$newloot.push([item.id, GameObj.inv.find{|cont| cont.noun == $herbsack}.id]) unless XMLData.game =~ /GSIV/i || Char.name =~ /Aethor/Teclys/i
		elsif item.noun =~ /#{[$foods, $dishes, $junknouns].flatten.join('|')}/ || item.name =~ /#{$junknames.join('|')}/ then respond "PIECE OF SHIT FOUND, SKIPPING #{item.name}, #{item.id}" if $mydebug
		elsif (item.noun =~ /#{[$gweaps, $ggear].flatten.join('|')}/ || item.name =~ /#{$gweapname.join('|')}/) && item.name =~ /#{$gmats.join('|')}/ then $newloot.push([item.id, GameObj.inv.find{|cont| cont.noun == $junksack}.id])
		elsif item.noun =~ /#{[$ggear, $gweaps].flatten.join('|')}/ || item.name =~ /#{$gweapname.join('|')}/ then $newloot.push([item.id, GameObj.inv.find{|cont| cont.noun =~ /pouch|#{$junksack}/}.id]) if item.noun == 'dart'
		elsif item.noun =~ /#{$gemnouns.join('|')}/ || item.name =~ /#{$gemnames.join('|')}/ then	$newloot.push([item.id, GameObj.inv.find{|cont| cont.noun == $gemsack}.id])
		elsif item.noun =~ /#{[$jewelery, $ogems].flatten.join('|')}/ || item.name =~ /#{$ogemnames.join('|')}/ then $newloot.push([item.id, GameObj.inv.find{|cont| cont.noun == $jewelsack}.id])
		elsif item.noun =~ /#{$scrolls.join('|')}/ then $newloot.push([item.id, GameObj.inv.find{|cont| cont.noun == $scrollsack}.id])
		elsif item.noun =~ /#{$wands.join('|')}/ || item.name =~ /#{$wandnames.join('|')}/ then $newloot.push([item.id, GameObj.inv.find{|cont| cont.noun == $wandsack}.id])
		elsif item.noun =~ /#{$magicnouns.join('|')}/ || item.name =~ /#{$magicnames.join('|')}/ then $newloot.push([item.id, $mysacks[0]])
		elsif item.noun =~ /#{$alchnouns.join('|')}/ || item.name =~ /#{$alchnames.join('|')}/ then $newloot.push([item.id, GameObj.inv.find{|cont| cont.noun == $alchsack}.id])
		elsif item.noun =~ /#{[$lockable_nouns, $containers].flatten.join('|')}/ then $newloot.push([item.id, GameObj.inv.find{|cont| cont.noun == $junksack}.id])
		elsif item.noun =~ /#{$clothes.join('|')}/ then $newloot.push([item.id, GameObj.inv.find{|cont| cont.noun == $junksack}.id])
#			elsif item.name =~ /#{$gherb_list.join('|')}/ then	$newloot.push([item.id, GameObj.inv.find{|cont| cont.noun == $herbsack}.id]) #unless XMLData.game =~ /GSF/i
		elsif item.noun =~ /#{$lfmnoun.join('|')}/ || item.name =~ /#{$lfmnames.join('|')}/ then $newloot.push([item.id, GameObj.inv.find{|cont| cont.noun == $locksack}.id])
		elsif item.noun =~ /arrow|bolt/ then nil
		elsif item.noun =~ /flakes/ && item.name =! /ash flakes/i then fput "tap ##{item.id}"
		elsif item.noun =~ /#{$boxes.join('|')}/ && item.name =~ /enruned|mithril/
#			respond "Magic box,  #{item.name}, under construction" if $mydebug
			$diskthese.push(item.id)
		elsif item.noun =~ /#{$boxes.join('|')}/ && item.name !~ /enruned|mithril/
			if Char.prof =~ /sorcerer/ && Skills.sldemonology >= 7 && mana?(20)
				respond "Non-magic box found, #{checkmana} mana, #{Skills.sldemonology} demon ranks, attempting phase."
				$phasethese.push(item.id)
				echo "UNDER CONSTRUCTION"
			else
				respond "Nonmagic box,  #{item.name}, under construction" if $mydebug
				$diskthese.push(item.id)
			end
		elsif item.name =~ /[A-Z][a-z]+.*(disk|coffin)/
			if item.name =~ /#{Char.name}.*(disk|coffin)/
				$yourdisk = item.id
			else
				$mydisk = item.id if item.name =~ /#{Char.name}.*(disk|coffin)/
			end
		elsif item.name =~ /some silver coins/
			fput "get coin" unless Char.name =~ /Crosby/i || percentencumbrance > 20 || checkroom =~ /warcamp/i
			waitrt?
		else
			respond "I don't know what #{item.name} is for so we'll ignore it."
		end
	}
	ehand unless $diskthese.empty? && $newloot.empty?
	$diskthese.each{|thing|
		if $yourdisk
			fput "_drag ##{thing} ##{$yourdisk}"
			if GameObj.right_hand.id == thing || GameObj.left_hand.id == thing
				disklist = GameObj.loot.find_all{|disk| disk.noun == 'disk' && disk.name !~ /#{Char.name}/}
				disklist.each{|disk|
					fput "_drag ##{thing} ##{disk.id}"
					break unless GameObj.right_hand.id == thing || GameObj.left_hand.id == thing
				}
				if GameObj.right_hand.id == thing || GameObj.left_hand.id == thing
					fput "drop ##{thing}"
					$newloot.push(thing)
				end
			elsif GameObj.loot.find{|box| box.id == thing}
				disklist = GameObj.loot.find_all{|disk| disk.noun == 'disk' && disk.name !~ /#{Char.name}/}
				disklist.each{|disk|
					fput "_drag ##{thing} ##{disk}"

					break unless GameObj.loot.find{|box| box.id == thing}
				}
				echo "BOX MAY BE TOO HEAVY"
				if GameObj.loot.find{|box| box.id == thing}
					$newloot.push(thing)
				elsif GameObj.right_hand.id == thing || GameObj.left_hand.id == thing
					$newloot.push(thing)
					fput "drop ##{thing}"
				end
			end
		else
			$newloot.push(thing)
		end
	}
	$newloot.each{|item, cont|
		gget(item, cont)
		fput "drop ##{item}" if GameObj.right_hand.id == item || GameObj.left_hand.id == item
	}
	fhand
end
def gloot2
#	respond "gloot building loot array"
	$yourdisk = false
	$newloot = []
		GameObj.loot.each{|item|
			if item.id.to_i <= 100000 then respond "item is probably stationary room stuff, #{item.name}, #{item.id}" if $mydebug
			elsif item.name =~ /#{$gherbs.flatten.join('|')}/i then	$newloot.push([item.id, GameObj.inv.find{|cont| cont.noun == $herbsack}.id]) #unless XMLData.game =~ /GSF/i
			elsif item.name =~ /[A-Z][a-z]+.*(disk|coffin)/
				if item.name =~ /#{Char.name}.*(disk|coffin)/
					$yourdisk = item.id
				else
					$mydisk = item.id if item.name =~ /#{Char.name}.*(disk|coffin)/
				end
			elsif item.name =~ /some silver coins/
				#fput "get coin" unless Char.name =~ /Crosby/i || percentencumbrance > 20
				waitrt?
			else
				respond "I don't know what #{item.name} is for so we'll ignore it."
			end
		}
	ehand unless $diskthese.empty? && $newloot.empty?
	$diskthese.each{|thing|
		if $yourdisk
			fput "_drag ##{thing} ##{$yourdisk}"
			if GameObj.right_hand.id == thing || GameObj.left_hand.id == thing
				disklist = GameObj.loot.find_all{|disk| disk.noun == 'disk' && disk.name !~ /#{Char.name}/}
				disklist.each{|disk|
					fput "_drag ##{thing} ##{disk.id}"
					break unless GameObj.right_hand.id == thing || GameObj.left_hand.id == thing
				}
				if GameObj.right_hand.id == thing || GameObj.left_hand.id == thing
					fput "drop ##{thing}"
					$newloot.push(thing)
				end
			elsif GameObj.loot.find{|box| box.id == thing}
				disklist = GameObj.loot.find_all{|disk| disk.noun == 'disk' && disk.name !~ /#{Char.name}/}
				disklist.each{|disk|
					fput "_drag ##{thing} ##{disk}"

					break unless GameObj.loot.find{|box| box.id == thing}
				}
				echo "BOX MAY BE TOO HEAVY"
				if GameObj.loot.find{|box| box.id == thing}
					$newloot.push(thing)
				elsif GameObj.right_hand.id == thing || GameObj.left_hand.id == thing
					$newloot.push(thing)
					fput "drop ##{thing}"
				end
			end
		else
			$newloot.push(thing)
		end
	}
	$newloot.each{|item, cont|
		gget(item, cont)
		fput "drop ##{item}" if GameObj.right_hand.id == item || GameObj.left_hand.id == item
	}
	fhand
end
def ggetORIGINAL(nitem, sack = false)
	ehand
	item = GameObj.loot.find{|this| this.name =~ /#{nitem}/ || this.id.to_i == nitem.to_i}.id || GameObj.right_hand.find{|this| this.name =~ /#{nitem}/ || this.id.to_i == nitem.to_i}.id || GameObj.right_hand.find{|this| this.name =~ /#{nitem}/ || this.id.to_i == nitem.to_i}.id || false
	respond "FUCK ME, NO ITEM" unless item;return unless item
	if sack
		sack = GameObj.inv.find{|this| this.noun =~ /#{sack}/ || this.id.to_i == sack.to_i}.id || nil
	else
		sack = GameObj.inv.find{|cont| cont.noun == $firstsack}.id
	end
	sack = GameObj.inv.find{|cont| cont.noun == $firstsack}.id unless sack
	if sack
		fput "_drag ##{item} ##{sack}"
		x = false
		x = matchtimeout(1, "You put")
		return if x =~ /You put/i
		return unless GameObj.right_hand.id == item || GameObj.left_hand.id == item || GameObj.loot.find{|this| this.id == item}
	end
#	while GameObj.right_hand.id == item || GameObj.left_hand.id == item || GameObj.loot.find{|this| this.id.to_i == item}
		$contid.each{|sac|
			fput "_drag ##{item} ##{sac}" unless sack == sac
			if GameObj.right_hand.id == item || GameObj.left_hand.id == item
					echo "FAILED TO STASH"
					fput "drop ##{item}"
			elsif GameObj.loot.find{|thing| thing.id == item}
				echo "YOU ARE PROBABLY OVERLOADED"
				break
			else
				return
			end
		}
		fput "drop ##{item}" if GameObj.right_hand.id == item || GameObj.left_hand.id == item
		return
#	end

end
def gget(nitem, sack = false)
	ehand
	item = rloot(nitem).id || rhand(nitem).id || lhand(nitem).id || false
	respond "FUCK ME, NO ITEM" unless item;return unless item
	if sack
		sack = ginv(sack).id || false
	else
		sack = ginv($firstsack).id
	end
	sack = ginv($firstsack).id unless sack
	if sack
		x = false
		fput "_drag ##{item} ##{sack}"
		x = matchtimeout(1, "You put", "closed", "won't fit")
		return if x =~ /You put/i
		return unless rhand.id == item || lhand.id == item || rloot(item)
	end
	return if item == 4
#	while rhand.id == item || lhand.id == item || rloot(item)
		$contid.each{|sac|
			next if sack == sac
			x = false
			fput "_drag ##{item} ##{sac}"
			x = matchtimeout(1, "You put", "closed", "won't fit")
			return if x =~ /You put/i
			if rhand.id == item || lhand.id == item
					msg "FAILED TO STASH"
			elsif rloot(item)
				msg "YOU ARE PROBABLY OVERLOADED"
				break
			else
				return
			end
		}
		fput "drop ##{item}" if rhand.id == item || lhand.id == item
		return
#	end
end

def gskin(target)
	skin_weapon = false
	skin_cont = false
	spell_604 if Spells.ranger >= 4 && Char.level >= 4 && mana?(10)
	waitrt?
	if (GameObj.right_hand.noun == $skinweap || GameObj.left_hand.noun == $skinweap) && (GameObj.right_hand.name == "Empty" || GameObj.left_hand.name == "Empty")
		holding = true
		ohand = true
	elsif (GameObj.right_hand.noun == $skinweap || GameObj.left_hand.noun == $skinweap) && !(GameObj.right_hand.name == "Empty" || GameObj.left_hand.name == "Empty")
		holding = true
		ohand = false
	else
		holding = false
		ohand = false
		ohand = true if (GameObj.right_hand.name == "Empty" || GameObj.left_hand.name == "Empty")
	end
	unless holding && !ohand
		ehand
		GameObj.inv.each{|thing|
			skin_weapon = thing.contents.find{|dag| dag.noun =~ /#{$skinweap}/i} || false
			next unless skin_weapon
			put "get ##{skin_weapon.id}"
			wait_until{GameObj.right_hand.noun == $skinweap || GameObj.left_hand.noun == $skinweap}
			skin_cont = thing.id
			break
	        }
	end
	pause_script('stand') if running? 'stand'
	fput "kneel" unless GameObj.npcs.find{|npc| (npc.status == nil || npc.status =~ /fly/i) && npc.id !~ /#{$mynpc.join('|')}/i} || percentencumbrance >= 40
	waitrt?
	mystance = checkstance
	multifput("stance off","skin ##{target} with my #{$skinweap}")
	result = matchwait /botched|skinned|cannot|only/
	fput "stand" until standing?
	waitrt?
	unpause_script('stand') if running? 'stand'
	put "stance #{mystance}" unless percentstance > 20
	unless holding
		fput "_drag ##{skin_weapon.id} ##{skin_cont}"
		#while GameObj.right_hand.id == skin_weapon.id || GameObj.left_hand.id == skin_weapon.id
	end
	if result =~ /skinned/
		skin = result.scan(/yielding.*?(\w+)\./)
		$pelts.push(skin.to_s) unless $pelts.include?(skin.to_s)
		$peltname.push(GameObj.loot.find{|pelt| pelt.noun == skin.to_s}.name) unless $peltname.include?(GameObj.loot.find{|pelt| pelt.noun == skin.to_s}.name)
	end
	echo "END SKINNER"
	fhand unless holding
end
def gsell
	fput "stow right" unless GameObj.right_hand.name == "Empty"
	fput "stow left" unless GameObj.left_hand.name == "Empty"
	if Room.current.id == 4 && checkpaths.include?('out')
		fput "out"
	end
	room = Room.current.id
	mymove 'town'
	return unless GameObj.right_hand.name == "Empty" && GameObj.left_hand.name == "Empty"
#	fput "close my sack" if Char.name == "Geno"
	ldata2
#	fput "open my sack" if Char.name == "Geno"
	fput "get document" if Room.current.id == 3519
	unless $mysellgems.empty? || Char.name =~ /Aethor|Teclys/
		respond "*** SELL GEMS ***"
		mymove "gemshop"
		x = $keepnames.length
		$mysellgems.each{|gem|
			fput "get ##{gem.id}"
			fput "sell ##{gem.id}"
			y = false
			y = matchtimeout(1, "silver for it", "valuable")
			unless y =~ /silver for it/
				$keepnames.push(gem.name) if y =~ /valuable/
				$mypawn.push(gem) unless y =~ /valuable/i
				fput "stow ##{gem.id}"
			end
			stashright if rhand
		}
		if $keepnames.length > x
			respond " NEW KEEPER PUSHED"
			echo "\"#{$keepnames.join("\", \"")}\""
			respond ""
			respond "********************************************"
		end
	end
	unless $mypawn.empty?
		respond "*** SELL PAWNSHOP ***"
		mymove "pawnshop"
		$mypawn.each{|item|
			fput "get ##{item.id}"
			fput "sell ##{item.id}"
			if GameObj.right_hand.id.to_i == item.id.to_i || GameObj.left_hand.id.to_i == item.id.to_i
				$myjunk.push(item) unless $myjunk.noun =~ /#{[$gweaps, $ggear].flatten.join ('|')}/
				fput "stow ##{item.id}"
			end
			stashright if rhand
		}
	end
	unless $myalch.empty?
		respond "*** SELL ALCHEMY ***"
		mymove "consignment"
		$myalch.each{|item|
			multifput "get ##{item.id}"
			fput "sell ##{item.id}"
			if GameObj.right_hand.id.to_i == item.id.to_i || GameObj.left_hand.id.to_i == item.id.to_i
				$myjunk.push(item)
				fput "stow ##{item.id}"
			end
			stashright if rhand
		}
	end
	unless $myrings.empty?
		respond "*** TRADE RINGS ***"
		mymove "chronomage"
		$myrings.each{|item|
			multifput "get ##{item.id}"
			sleep 1
#			fput "give ##{item.id} to #{checknpcs[-1]}"
			fput "give ##{item.id} to ##{GameObj.npcs.find{|npc| npc.id.to_i > 1}.id}"
			if GameObj.right_hand.id.to_i == item.id.to_i || GameObj.left_hand.id.to_i == item.id.to_i
				$myjunk.push(item)
				fput "stow ##{item.id}"
			end
		}
	end
	####### FURRIER #######
	unless $myfur.empty?
		respond "*** SELL FURS ***"
		mymove "furrier"
		$myfur.each{|id|
			fput "get ##{id.id}"
			fput "sell ##{id.id}"
		}
		stashright if rhand
	end
	mymove "bank"
	fput "depo all"
	fput "with 10 silver"
	fput "stow right"
##### JUNK BELOW #####
	if GameObj.right_hand.noun == 'document'
		drop_junk
	else
		echo "FINISH"
		mymove room
		echo $myjunk.join(", ")
	end
end
def drop_junk
	echo "drop_junk pausing table_picker" if Char.name =~ /baswab/i
#	pause_script('table_picker')
	echo "DROP JUNK"
#	mymove 3544
	fput "stow docu"
#	$myjunk.each{|thing|
#		fput "_drag ##{thing.id} ##{GameObj.loot.find{|bar| bar.noun =~ /barrel|bin|trash|basket|receptical/}.id}"
#	}
	unless checkroom =~ /table/i
		mymove 10388
		2.times{fput "go basw table"} if Char.name =~ /geno/i
		2.times{fput "go geno table"} if Char.name =~ /baswab/i
		if Char.name =~ /Crosby/i
			2.times{fput 'go geno table'}
			2.times{fput 'go baswab table'} unless checkroom =~ /table/i
			fput "go table" unless checkroom =~ /table/i
		end
		fput "go table"
		drop_these $myjunk
		drop_these $myherbs
		fput "gather ac lea"
		fput "stow my leaf"
		fput "gather stem"
		fput "stow stem"
		wait_until("...waiting for partner"){GameObj.pcs.find{|pc| pc.noun =~ /geno|baswab/i}} unless Char.name =~ /crosby/i
		gsort
		$all_my_shit.flatten.each{|orb| multifput("get ##{orb.id}","drop ##{orb.id}") if orb.name =~ /heavy quartz orb/} if Char.name =~ /Crosby/i
	end
	if GameObj.pcs.find{|pc| pc.noun =~ /Baswab|Geno/i} && (checkpcs.length == 1 || Char.name == "Crosby")
		drop_these $myboxes
		sleep 3
		 GameObj.loot.each{|disk|
			fput "turn ##{disk.id}" if disk.noun =~ /disk|coffin/ && disk.name =~ /#{Char.name}/
		}
	end
	mymove 'town' if Char.name =~ /crosby/i
#	echo "drop_junk unpausing table_picker" if Char.name =~ /baswab/i
#	unpause_script('table_picker')
end
def drop_these(array)
	#ldata2
	array.each{|thing|
		fput "_drag ##{thing.id} drop"
	}
end
def read_scroll
	ldata2
	$myscroll.each{|scroll|
		fput "read ##{scroll.id}"
		respond ";send sellme to sell the scroll, or ;send next to show next scroll."
		respond "sellme option will drop scroll, you are #{Char.name}" if Char.name == 'Teclys' && gpcs('Aethor')
		sleep 0.5
		x = false
		x = matchtimeout(60, /next|sellme/)
		if x =~ /sellme/
			if Char.name == 'Aethor' && gpcs('Teclys')
				fput "_drag ##{scroll.id} drop"
			else
				multifput("get ##{scroll.id}", "sell ##{scroll.id}")
			end
		end
	}
end
def find_heirloom
	ldata2
	ginv.each{|container|
		container.contents.each{|thing|
			clear
			x = false
			fput "l ##{thing.id}" unless [$myscroll, $mygem, $myherbs].flatten.include?(thing)
			x = matchtimeout(1, "is crafted of thin metal|is difficult to tell|crafting mark|currently set|is surrounded|Engraved.*?are the initials|You see nothing unusual|moment to focus|small statue is formed|appears to be broken|affixed with a red wax seal|appears to be something written")
			if x =~ /initials/i
				fput "get ##{thing.id}"
				break
			end
		}
	}
end
def get_box
	wait_while{running? 'empty'}
	if gfind($boxes.join("|"))
		fput "_drag ##{gfind($boxes.join('|')).id} right"
	else
		return false
	end
end
def sell_these(sellme)
	echo sellme.type
	if sellme.type == Array
		sellme.each{|thing|
			stashright
			t = Time.now
			fput "get ##{thing.id}"
			wait_until{rhand || Time.now > t + 3}
			next unless rhand
			fput "sell ##{thing.id}"
			x = false
			x = matchtimeout(1, "hands you|You offer to sell")
			next if x =~ /hands you/i
			stashright if rhand
		}
	elsif sellme.type == String
		gfindall(sellme).each{|thing|
			stashright
			t = Time.now
			fput "get ##{thing.id}"
			wait_until{rhand || Time.now > t + 3}
			fput "sell ##{thing.id}"
			x = false
			x = matchtimeout(1, "hands you|You offer to sell")
			next if x =~ /hands you/i
			stashright if rhand
		}
	else
		msg "WHAT ARE YOU TRYING TO SELL?"
		return
	end
end
$mynpc ||= ["empty"]
$escorts ||= ["child", "traveller", "scribe", "merchant", "dignitary", "official", "magistrate"]
$saferooms ||= [228, 188, 288, 3519, 13920, 12486, 410, 156, 1932, 1844, 10861]
$stun_attack_person ||= $my_group
$my_group ||= ["Aethor", "Teclys","Aethorious","Temerrk"]
$hair_trigger ||= ["springs from hiding and delivers a blow", "makes a faint wheezing sound", "swings", "thrusts", "fires", "hurls", "throws", "channels", "gestures\sat\sa", "sings with renewed vigor", "skillfully weaves another verse into h(is|er) harmony, directing the sound of h(is|er) voice at", "feints to"]
$prof_list ||= ["Warrior","Rogue","Paladin","Bard","Ranger","Wizard","Sorcerer","Cleric","Empath"]
$race_list ||= ["Human", "Giantman", "HalfElf", "Sylvankind", "Dark Elf", "Elf", "Dwarf", "Halfling", "Forest Gnome", "Burghal Gnome", "Half-Krolvin", "Erithian", "Aelotoi"]
$flyers ||= ["wasp", "griffin", "raptor"]
$undead_list ||= ["wraith", "ghoul", "skeletal", "barghest", "wyrd", "shadow", "magru", "vourkha", "baesrukha", "phantasma", "skeleton", "zombie", "phantom", "ghost", "shade", "revenant", "apparition", "mummy", "spectral","spirit", "bone", "dirge", "werebear", "darkwoode", "spectre", "specter", "wight", "vereri", "rotting", "nonomino", "carceris", "lich", "corpse", "night", "vruul", "dybbuk", "waern", "banshee", "seeker", "eidolon", "naisirc", "shrickhen", "darken", "seraceris", "n'ecare", "vaespilon", "ethereal"]
$perceptive ||= ["griffin","raptor","guard", "scout",  "triton defender","triton executioner","triton magus","triton sentry"]
$non_corp ||= ["eidolon", "wraith","shadow","shade","phantasma","ghost","revenant","apparition","spectral","spectre","specter","spirit","banshee","shrickhen","darken","ethereal", "wyrd"]
$skin_critters ||= ["agresh bear", "albino tomb spider", "arch wight", "arctic manticore", "ash hag", "banded rattlesnake", "banded rattlesnake", "big ugly kobold", "bighorn sheep", "black bear", "black boar", "black forest viper", "black leopard", "black rolton", "black wild dog", "bobcat", "bog wight", "bone golem", "brindle wild hound", "brown boar", "brown gak", "burgee", "caribou", "carrion worm", "cave gnome", "cave lizard", "cave nipper", "cave troll", "centaur", "cobra", "colossus vulture", "cougar", "coyote", "crazed zombie", "crested basilisk", "crocodile", "cyclops", "dark orc", "dark panther", "dark shambler", "death dirge", "dreadnought raptor", "elder ghoul master", "fanged goblin", "fanged rodent", "fanged viper", "fenghai", "fire ant", "fire cat", "fire giant", "fire ogre", "fire rat", "fire salamander", "fog beetle", "forest trali", "forest trali shaman", "forest troll", "ghoul master", "giant albino scorpion", "giant ant", "giant marmot", "giant rat", "giant veaba", "goblin", "great boar", "great brown bear", "great stag", "great weasel", "greater burrow orc", "greater faeroth", "greater ghoul", "greater kappa", "greater moor wight", "greater orc", "greater spider", "greenwing hornet", "grey orc", "grifflet", "hill troll", "horned vor'taz", "hunter troll", "ice troll", "jungle troll", "kiramon defender", "kiramon worker", "kobold", "kobold shephard", "krynch", "large ogre", "lesser burrow orc", "lesser faeroth", "lesser ghoul", "lesser griffin", "lesser minotaur", "lesser mummy", "lesser orc", "lesser red orc", "mammoth arachnid", "manticore", "massive black boar", "massive troll king", "mastodonic leopard", "mist wraith", "mongrel hobgoblin", "mongrel kobold", "mongrel wolfhound", "mountain goat", "mountain lion", "mountain troll", "Neartofar orc", "Neartofar troll", "night hound", "ogre warrior", "pale crab", "panther", "plains lion", "plains ogre", "plains orc chieftain", "plains orc scout", "plains orc shaman", "plains orc warrior", "plumed cockatrice", "pra'eda", "puma", "rabid squirrel", "red bear", "relnak", "ridgeback boar", "roa'ter", "rolton", "sea nymph", "shelfae chieftain", "shelfae soldier", "shoot", "skeleton", "snow crone", "snow leopard", "snow madrinol", "specter", "spotted gak", "spotted leaper", "spotted lynx", "storm giant", "storm griffin", "striped gak", "striped relnak", "striped warcat", "tawny brindlecat", "thrak", "three\-toed tegu", "thunder troll", "tomb wight", "tree viper", "triton dissembler", "triton magus", "triton radical", "tundra giant", "tusked ursian", "undertaker bat", "urgh", "velnalin", "vesperti", "waern", "war griffin", "war troll", "warthog", "wasp", "water moccasin", "werebear", "whiptail", "wild dog", "wind witch", "wolverine", "wood wight", "wraith", "young grass snake", "zombie"]
$avoid ||= ["nest","skayl","greater water elemental","whirlpool", "official"]
$grimswarm ||= ["Grimswarm"]
$grimnouns ||= ["cleric", "acolyte", " initiate",  "empath", " scourge", " healer", " paladin", " zealot", " crusader", " wrathbringer", " destroyer", " blackguard", " ranger", " hunter", " huntmaster", " huntmistress", " raider", " skirmisher", " pillager", " archer", " sniper", " scout", " sorcerer", " sorceress", " dissembler", " witch", " warlock", " warrior", "  marauder", " fighter", " barbarian", " soldier", " champion", " veteran", " wizard", " mage", " adept", " elementalist", " warmage", "archmage"]
$thugs ||= ["outlaw","highwayman", "robber", "bandit", "thief", "mugger", "thug", "rogue", "brigand", "marauder"]
$priority1 ||= ["fire giant", "mammoth arachnid", "tegurish sentry", "hisskra shaman", "roa'ter wormling", "arch wight","grey orc","dark orc","raider orc","arch wight","spectre","thyril","leaper","triton sentry", "war griffin"]
$priority2 ||= ["lava troll", "ash hag", "jungle troll chieftain", "lesser wood sprite", "hisskra chieftain", "Grutik shaman","dark shambler","great boar","dark shambler","wolfshade","grass snake","relnak","triton magus", "triton dissembler","ithzir seer","ithzir initiate"]
$priority3 ||= ["fire ogre", "jungle troll", "martial eagle", "giant hawk\-owl", "water wyrd","hisskra warrior", "Grutik savage", "ghoul master","triton radical","triton combatant","triton executioner","triton defender", "ithzir adept", "ithzir herald"]
$priority4 ||= ["fog beetle", "ghost wolf", "siren", "^water elemental","ithzir janissary"]
$priority5 ||= ["ithzir scout"]
$noloot ||= ["skayl"]
$corrupt ||= ["eidolon", "ranger", "wizard","sorcere","cleric","mage","acolyte","wrathbringer","dissembler","witch","warlock", "stone troll", "stone giant", "jungle troll chieftain", "shadowy spectre","arch wight","tree spirit","Grutik shaman", "shaman", "spectral woodsman", "ash hag", "forest trali", "forest trali shaman", "vor'taz", 'animated slush']
$critterprep ||= ['hisses an evil incantation']
$grunts ||= ["grunts in agreement", "grunts, amused.", "grunts angrily, glaring and snorting", "grunts in annoyance, rolling his eyes", "grunts shyly, averting his eyes", "grunts in ennui", "grunts in farewell", "grunts, rolls his eyes, and sticks out his tongue", "grunts and motions for a drink", "grunts and hiccups, weaving slightly", "grunts and sneers at the same time in obvious distaste", "grunts, obviously terrified", "grunts and snarls at the same time, looking mighty fierce", "grunts as his stomach rumbles", "grunts in obvious annoyance", "grunts with a sparkle in his eye", "grunts gleefully, rubbing his hands together", "grunts, the gleam of silver in his eye", "grunts grimly, looking resigned to his fate", "grunts, grinning", "grunts in greeting", "grunts urgently, calling for assistance!", "grunts as his belly rumbles", 'grunts non-committally and shrugs his shoulders', "grunts menacingly", "grunts possessively, glaring at the same time", "grunts and shakes his head", "grunts in pain", "grunts sadly, a small tear forming in the corner of his eye", "grunts sleepily", "grunts, grinning like a fool", "grunts his thanks", "grunts tiredly", "grunts loudly in annoyance and impatience", "grunts and nods", "grunts, a quizzical look on his face", "grunts in satisfaction", "grunts skeptically, raising his bushy eyebrows", "grunts pensively, deep in thought"]
$goodspells ||= []
$badspells ||= [412, 413, 501, 504, 201, 210, 212, 214, 216, 703, 706, 713, 715, 716, 607, 1117, 1120, 311, 316, 1001, 1005, 1015, 1016]
def gspells
	spells = XMLData.active_spells.keys
	badspells = spells.find_all{|spell| spell =~ /#{$badspells.join('|')}/} || false
	return(badspells) if badspells.length > 0
	return(false)
end
def gwound
	return(true) if [Wounds.head, Wounds.neck, Wounds.torso, Wounds.limbs, Wounds.nerves, Scars.head, Scars.neck, Scars.torso, Scars.limbs, Scars.nerves].max > 1 or (percenthealth < 65)
	return(false)
end
if [Skills.edgedweapons, Skills.bluntweapons, Skills.thrownweapons, Skills.twohandedweapons, Skills.rangedweapons, Skills.brawling, Skills.polearmweapons].max >= Char.level
	$priority2.push("greater construct") unless $priority2.include?('greater construct')
else
	$priority5.push("greater construct") unless $priority5.include?('greater construct')
end
def wait_rt
	wait_while { checkrt > 0 || checkcastrt > 0 }
	sleep 0.5
end
def wcrt
	wait_while{checkcastrt > 0}
	sleep 0.5
end
def wrt
	wait_while{checkrt > 0}
	sleep 0.5
end
def agidex
	return(Stats.agi[1] + Stats.dex[1])
end
def btime
	if Spell[9003].active?
		return((Spell[9003].timeleft * 60).ceil)
	else
		return(0)
	end
end
def sigils
	fput "stance def" if Char.prof =~ /Wizard/ && !Spell[506].active?
	Spell[1107].cast if Spell[9699].active? && Spell[1107].known? && mana?(7)
	unless Char.name =~ /Aethor|Teclys/
		Spell[9719].cast if percentmana >= 20 && !Spell[9710].active? && Spell[9719].known? && Spell[9719].affordable? && Spell[9719].timeleft < 2
	end
	unless Char.name == "Aethor,Teclys"
		Spell[9715].cast if percentmana >= 20 && !Spell[9715].active? && Spell[9715].known? && !Spell[9705].active? && Spell[9715].affordable?
	end
	Spell[9707].cast if Spell[9707].affordable? && !Spell[9707].active? && Spell[9707].known?
	Spell[9708].cast if Spell[9708].affordable? && !Spell[9708].active? && Spell[9708].known?
	unless Char.name =~ /Aethor|Teclys/
		Spell[9710].cast if Spell[9710].affordable? && Spell[9710].timeleft < 2 && Spell[9710].known? && !Spell[9719].active? && !Spell[9719].affordable?
	else
		Spell[9710].cast if Spell[9710].affordable? && Spell[9710].timeleft < 2 && Spell[9710].known? && !Spell[9719].active?
	end
	Spell[9711].cast if Spell[9711].affordable? && !Spell[9711].active? && Spell[9711].known?
	Spell[9713].cast if Spell[9713].affordable? && !Spell[9713].active? && Spell[9713].known?
	Spell[9714].cast if Spell[9714].affordable? && !Spell[9714].active? && Spell[9714].known?
	Spell[9705].cast if Spell[9705].affordable? && !Spell[9705].active? && Spell[9705].known? && !Spell[9715].active?
	if Char.name =~ /Aethor|Teclys/i
		Spell[9704].cast if Spell[9704].affordable? && !Spell[9704].active? && Spell[9704].known?
	end
	Spell[506].cast if Spell[506].known? && Spell[506].affordable? && !Spell[506].active?
end
def gohome(room = 'town')
	while checkroom =~ /warcamp/i
		waitrt?
		if Room.current.id.to_i == 16342
			fput "go path"
			next
		end
		start_script("step2", ['16342'])
		wait_while{running? 'step2'}
	end
	mymove room
end
def mymove(room = false)
	return if Room.current.id == room.to_i
	fput "out" if checkroom =~ /table/i && Room.current.id == 4
	if room
		if hiding?
			start_script("go2",['typeahead=0', room, '_disable_confirm_'])
			wait_while{running?("go2")}
		else
			start_script("go2",[room, '_disable_confirm_'])
			wait_while{running?("go2")}
		end
	else

	end
end
def runme(script, wait_for = true)
	if script.type == String
#		echo "RUN #{script} with no command line variables."
		start_script(script)
		wait_while{running?(script)} if wait_for
	elsif script.type == Array
		scriptname = script.delete_at(0)
		vars = []
		vars.push(script.delete_at(0)) until script.empty?
		echo "Run #{scriptname} with the following command line variables: #{vars.join(', ')}"
		case vars.length
		when 10
			vars.each{|a, b, c, d, e, f, g, h, i, j| start_script(scriptname, [a, b, c, d, e, f, g, h, i, j])}
		when 9
			vars.each{|a, b, c, d, e, f, g, h, i| start_script(scriptname, [a, b, c, d, e, f, g, h, i])}
		when 8
			vars.each{|a, b, c, d, e, f, g, h| start_script(scriptname, [a, b, c, d, e, f, g, h])}
		when 7
			vars.each{|a, b, c, d, e, f, g| start_script(scriptname, [a, b, c, d, e, f, g])}
		when 6
			vars.each{|a, b, c, d, e, f| start_script(scriptname, [a, b, c, d, e, f])}
		when 5
			vars.each{|a, b, c, d, e| start_script(scriptname, [a, b, c, d, e])}
		when 4
			vars.each{|a, b, c, d| start_script(scriptname, [a, b, c, d])}
		when 3
			vars.each{|a, b, c| start_script(scriptname, [a, b, c])}
		when 2
			vars.each{|a, b| start_script(scriptname, [a, b])}
		when 1
			vars.each{|a| start_script(scriptname, [a])}
		else
			echo "BETA TEST, MORE THAN 9 COMMAND LINE VARIABLES"
			echo "Starting script
			start_script(scriptname, ["#{vars.join(' ')]}")
		end
		wait_while("Waiting for #{scriptname} to terminate"){running?(scriptname)} if wait_for
	end
end
def checkcmans(skill = false)
	done = false
	skills = []
	DownstreamHook.remove("cmans")
	before_dying{DownstreamHook.remove("cmans")}
	action = proc{|server_string|
		case server_string
		when /know absolutely nothing|your Combat Maneuver training|Skill name|output class/
			nil
		when /prompt time/
			done = true
			nil
		when /Available Combat Maneuver Training Points\: (\d+)/
#			respond("You have #{$1} CM TPs to spend.")
			nil
		when /Unlearning Combat Maneuver Training Points\: (\d+)/
#			respond("You are unlearning #{$1} CM points.")
			nil
		when /Estimated time until next point conversion\: (.*)$/
#			respond("Next CM TP unlearned in #{$1}.")
			nil
			#Total Points converted during your current 30-day unlearning cycle: 6
			#Number of days remaining in your current 30-day unlearning cycle: 29 days
		when /Total Points converted during your current 30\-day unlearning cycle\: (\d+)/
#			respond("You have converted #{$1} CM TPs this cycle.")
			nil
		when /Number of days remaining in your current 30\-day unlearning cycle\: (\d+) days/
#			respond("You have #{$1} days remaining this cycle.")
			nil
		else
			line = server_string #.split(" ")
			if line =~ /(.*?)\s+(\w+)\s+(\d)/
				skills.push([$1, $2, $3.to_i])
				nil
			else
				server_string
			end
		end
	}
	DownstreamHook.add("cmans", action)
	status_tags
	$_SERVER_.puts "cman info"
	t=Time.now
	wait_until {done or t+3<Time.now}
	DownstreamHook.remove('cmans')
	status_tags
	unless skill
		return(skills) unless skills.empty?
		return(false)
	else
		if skills.find{|this| this.include?(skill)}
			if skills.find_all{|this| this.include?(skill)}.length > 1
				return(skills.find_all{|this| this.include?(skill)})
			else
				return(skills.find{|this| this.include?(skill)})
			end
		else
#			return(skills) unless skills.empty?
			return(false)
		end
	end
end
def showcmans
	x = []
	y = checkcmans
	return(false) unless y
	y.each{|a, b, c| x.push([c, b])}
	z = []
	x.each{|a, b|
		if a > 1
			z.push("#{a} ranks of #{b}")
		else
			z.push("#{a} rank of #{b}")
		end
	}
	joinup = z.join(', ')
	wholemessage = "#{Char.name} has #{joinup}."
	msg(wholemessage)
	return()
end
def wander(badrooms = [11265, 11358, 4793, 4882, 559, 9723, 11624, 3474, 2533, 3242, 3125, 2570, 2532, 14711, 7873, 1209, 1217, 7893, 8357, 8326, 8318,  1997, 1996, 10835, 12712, 12678, 558, 9722, 9828, 14660, 14661, 14662, 6026, 6027, 5823, 5994, 2004])
	if Room.current.id == 4
		walk
		return
	end
	broom = badrooms
	badrooms = []
	broom.each{|room| badrooms.push(room.to_s)}
	$wander_last_room ||= nil
	room = Room.current
	options = Room.current.wayto.keys - badrooms
	next_room_options = room.wayto.keys - badrooms
	if next_room_options.length > 1
		next_room_options.delete_if { |option| option == $wander_last_room }
	end
	next_room = next_room_options[rand(next_room_options.length)]
	way = room.wayto[next_room]
	if way.class == String
		move(way)
	else
		way.call
	end
	$wander_last_room = room.id.to_s
end
def gtarget(target = nil)
	waitrt?
#	waitcastrt? unless checkspell 515
	if target
		$id = false
		if GameObj.npcs.find{|npc| npc.id.to_i == target.id.to_i && npc.status =~ /dead/ && !$noloot.include?(npc.noun)}
			return(gsearch(target))
		end
		$target = 	GameObj.npcs.find{|npc| npc.name =~ /#{target}/ && npc.id.to_s !~ /#{$mynpc.join('|')}/} || GameObj.npcs.find{|npc|  npc.id.to_i == target.to_i && npc.id.to_s !~ /#{$mynpc.join('|')}/} || GameObj.pcs.find{|pc| pc.noun =~ /#{target}/i} || GameObj.pcs.find{|pc| pc.id.to_i == target.to_i} || false
		return(gtarget) unless $target
		$id = $target.id
		put "target ##{$id}"
		target_line = matchwait("You can't target","You do not have a target.","not find a valid target\.","are now targeting","You are currently targeting","current target has become invalid")
		if target_line =~ /You can't target/ && $target.status !~ /dead/i
			fput "loot ##{$id}" unless $target.noun =~ /#{$noloot.join('|')}/
			echo "#{$target.name} pushed into your safe targets."
			$mynpc.push($id) unless $mynpc.include?($id)
			$mynpc.delete("empty") if $mynpc.length > 1 && $mynpc.include?("empty")
			$target = false
			$id = false
			gtarget
			return
		elsif target_line =~ /not find a valid target|do not have a target|has become invalid/
			$target = false
			$id = false
			msg("specific target fail, 261")
			gtarget
			return
		else
			return
		end
	else
		$firsthit = false
		ntarget = false
		$mynpc.delete("empty") if $mynpc.length > 1 && $mynpc.include?("empty")
		$cleanup = true if Char.name =~ /Cleanupguy/i
		return(grimtarget) if GameObj.npcs.find{|npc| npc.name =~ /Grimswarm/}
		unless $cleanup
		ntarget =
				GameObj.npcs.find{|npc| npc.status !~ /dead/i && npc.id.to_i > 99999 && !$mynpc.include?(npc.id) && npc.status == nil && npc.name =~ /#{$thugs.join('|')}/i && npc.name !~ /#{$avoid.join('|')}/} ||
				GameObj.npcs.find{|npc| npc.status !~ /dead/i && npc.id.to_i > 99999 && !$mynpc.include?(npc.id) && npc.status == nil && npc.name =~ /#{$priority1.join('|')}/i && npc.name !~ /#{$avoid.join('|')}/} ||
				GameObj.npcs.find{|npc| npc.status !~ /dead/i && npc.id.to_i > 99999 && !$mynpc.include?(npc.id) && npc.status != nil && npc.name =~ /#{$thugs.join('|')}/i && npc.name !~ /#{$avoid.join('|')}/} ||
				GameObj.npcs.find{|npc| npc.status !~ /dead/i && npc.id.to_i > 99999 && !$mynpc.include?(npc.id) && npc.status != nil && npc.name =~ /#{$priority1.join('|')}/i && npc.name !~ /#{$avoid.join('|')}/} ||
				GameObj.npcs.find{|npc| npc.status !~ /dead/i && npc.id.to_i > 99999 && !$mynpc.include?(npc.id) && npc.status == nil && npc.name =~ /#{$priority2.join('|')}/i && npc.name !~ /#{$avoid.join('|')}/} ||
				GameObj.npcs.find{|npc| npc.status !~ /dead/i && npc.id.to_i > 99999 && !$mynpc.include?(npc.id) && npc.status == nil && npc.name =~ /#{$priority3.join('|')}/i && npc.name !~ /#{$avoid.join('|')}/} ||
				GameObj.npcs.find{|npc| npc.status !~ /dead/i && npc.id.to_i > 99999 && !$mynpc.include?(npc.id) && npc.status != nil && npc.name =~ /#{$priority2.join('|')}/i && npc.name !~ /#{$avoid.join('|')}/} ||
				GameObj.npcs.find{|npc| npc.status !~ /dead/i && npc.id.to_i > 99999 && !$mynpc.include?(npc.id) && npc.status == nil && npc.name =~ /#{$priority4.join('|')}/i && npc.name !~ /#{$avoid.join('|')}/} ||
				GameObj.npcs.find{|npc| npc.status !~ /dead/i && npc.id.to_i > 99999 && !$mynpc.include?(npc.id) && npc.status != nil && npc.name =~ /#{$priority3.join('|')}/i && npc.name !~ /#{$avoid.join('|')}/} ||
				GameObj.npcs.find{|npc| npc.status !~ /dead/i && npc.id.to_i > 99999 && !$mynpc.include?(npc.id) && npc.status == nil && npc.name =~ /#{$priority5.join('|')}/i && npc.name !~ /#{$avoid.join('|')}/} ||
				GameObj.npcs.find{|npc| npc.status !~ /dead/i && npc.id.to_i > 99999 && !$mynpc.include?(npc.id) && npc.status != nil && npc.name =~ /#{$priority4.join('|')}/i && npc.name !~ /#{$avoid.join('|')}/} ||
				GameObj.npcs.find{|npc| npc.status !~ /dead/i && npc.id.to_i > 99999 && !$mynpc.include?(npc.id) && npc.status != nil && npc.name =~ /#{$priority5.join('|')}/i && npc.name !~ /#{$avoid.join('|')}/} ||
				GameObj.npcs.find{|npc| npc.id.to_i > 99999 && npc.status == nil && npc.id.to_s !~ /#{$mynpc.join('|')}/i  &&npc.name !~ /#{$avoid.join('|')}/} ||
				GameObj.npcs.find{|npc| npc.id.to_i > 99999 && npc.status !~ /dead/ && npc.id.to_s !~ /#{$mynpc.join('|')}/i && npc.name !~ /#{$avoid.join('|')}/} ||
				GameObj.npcs.find{|npc| npc.status =~ /dead/ && npc.noun !~ /#{$noloot.join('|')}/} ||
				false
		else
		ntarget =
				GameObj.npcs.find{|npc| npc.status !~ /dead/i && npc.id.to_i > 99999 && !$mynpc.include?(npc.id) && npc.status != nil && npc.name =~ /#{$thugs.join('|')}/i && npc.name !~ /#{$avoid.join('|')}/} ||
				GameObj.npcs.find{|npc| npc.status !~ /dead/i && npc.id.to_i > 99999 && !$mynpc.include?(npc.id) &&  npc.status != nil && npc.name =~ /#{$priority1.join('|')}/i && npc.name !~ /#{$avoid.join('|')}/} ||
				GameObj.npcs.find{|npc| npc.status !~ /dead/i && npc.id.to_i > 99999 && !$mynpc.include?(npc.id) && npc.status == nil && npc.name =~ /#{$thugs.join('|')}/i && npc.name !~ /#{$avoid.join('|')}/} ||
				GameObj.npcs.find{|npc| npc.status !~ /dead/i && npc.id.to_i > 99999 && !$mynpc.include?(npc.id) && npc.status == nil && npc.name =~ /#{$priority1.join('|')}/i && npc.name !~ /#{$avoid.join('|')}/} ||
				GameObj.npcs.find{|npc| npc.status !~ /dead/i && npc.id.to_i > 99999 && !$mynpc.include?(npc.id) && npc.status != nil && npc.name =~ /#{$priority2.join('|')}/i && npc.name !~ /#{$avoid.join('|')}/} ||
				GameObj.npcs.find{|npc| npc.status !~ /dead/i && npc.id.to_i > 99999 && !$mynpc.include?(npc.id) && npc.status != nil && npc.name =~ /#{$priority3.join('|')}/i && npc.name !~ /#{$avoid.join('|')}/} ||
				GameObj.npcs.find{|npc| npc.status !~ /dead/i && npc.id.to_i > 99999 && !$mynpc.include?(npc.id) && npc.status == nil && npc.name =~ /#{$priority2.join('|')}/i && npc.name !~ /#{$avoid.join('|')}/} ||
				GameObj.npcs.find{|npc| npc.status !~ /dead/i && npc.id.to_i > 99999 && !$mynpc.include?(npc.id) && npc.status != nil && npc.name =~ /#{$priority4.join('|')}/i && npc.name !~ /#{$avoid.join('|')}/} ||
				GameObj.npcs.find{|npc| npc.status !~ /dead/i && npc.id.to_i > 99999 && !$mynpc.include?(npc.id) && npc.status == nil && npc.name =~ /#{$priority3.join('|')}/i && npc.name !~ /#{$avoid.join('|')}/} ||
				GameObj.npcs.find{|npc| npc.status !~ /dead/i && npc.id.to_i > 99999 && !$mynpc.include?(npc.id) && npc.status != nil && npc.name =~ /#{$priority5.join('|')}/i && npc.name !~ /#{$avoid.join('|')}/} ||
				GameObj.npcs.find{|npc| npc.status !~ /dead/i && npc.id.to_i > 99999 && !$mynpc.include?(npc.id) && npc.status == nil && npc.name =~ /#{$priority4.join('|')}/i && npc.name !~ /#{$avoid.join('|')}/} ||
				GameObj.npcs.find{|npc| npc.status !~ /dead/i && npc.id.to_i > 99999 && !$mynpc.include?(npc.id) && npc.status == nil && npc.name =~ /#{$priority5.join('|')}/i && npc.name !~ /#{$avoid.join('|')}/} ||
				GameObj.npcs.find{|npc| npc.id.to_i > 99999 && npc.status != nil && npc.status !~ /dead/i  && npc.id.to_s !~ /#{$mynpc.join('|')}/i && npc.name !~ /#{$avoid.join('|')}/ } ||
				GameObj.npcs.find{|npc| npc.id.to_i > 99999 && npc.status !~ /dead/ && npc.id.to_s !~ /#{$mynpc.join('|')}/i && npc.name !~ /#{$avoid.join('|')}/} ||
				GameObj.npcs.find{|npc| npc.status =~ /dead/} ||
				false
		end
		if ntarget.status =~ /dead/i && !$mynpc.include?(ntarget.id)
			gsearch(ntarget.id)
		elsif ntarget
			$target = ntarget
			$id = ntarget.id.to_i
			gtarget($id)
		else
			$target = false
			$id = false
		end
	end
end
def grimtarget
	gnpcs.each{|npc|
		gsearch(npc.id) if npc.status =~ /dead/i
	}
	#echo "******* GRIMTARGET ******* "
	if $cleanup
		target =	GameObj.npcs.find{|npc| npc.name =~ /Grimswarm/ && npc.status !~ /dead/ && npc.status == nil && npc.noun =~ /^guard|warchief|shaman/} ||
			GameObj.npcs.find{|npc| npc.name =~ /Grimswarm/ && npc.status !~ /dead/ && npc.status != nil && npc.noun =~ /^guard|warchief|shaman/} ||
			GameObj.npcs.find{|npc| npc.name =~ /Grimswarm/ && npc.status !~ /dead/ && npc.status != nil && npc.noun =~ /bodyguard|elementalist|witch|sorcer|healer|empath|ranger|wizard|mage|cleric|warlock|scourge|warlock|dissembler/} ||
			GameObj.npcs.find{|npc| npc.name =~ /Grimswarm/ && npc.status !~ /dead/ && npc.status != nil && npc.noun =~ /initiate|scout|archer|sniper|skirmisher|marauder|huntmistress|zealot/} ||
			GameObj.npcs.find{|npc| npc.name =~ /Grimswarm/ && npc.status !~ /dead/ && npc.status != nil && npc.noun =~ /pillager|warrior|fighter|soldier|barbarian|hunter|raider|destroyer/} ||
			GameObj.npcs.find{|npc| npc.name =~ /Grimswarm/ && npc.status !~ /dead/ && npc.status == nil && npc.noun =~ /bodyguard|elementalist|witch|sorcer|healer|empath|ranger|wizard|mage|cleric|warlock|scourge|warlock|dissembler/} ||
			GameObj.npcs.find{|npc| npc.name =~ /Grimswarm/ && npc.status !~ /dead/ && npc.status == nil && npc.noun =~ /initiate|scout|archer|sniper|skirmisher|marauder|huntmistress|zealot/} ||
			GameObj.npcs.find{|npc| npc.name =~ /Grimswarm/ && npc.status !~ /dead/ && npc.status == nil && npc.noun =~ /pillager|warrior|fighter|soldier|hunter|raider|barbarian/} ||
			GameObj.npcs.find{|npc| npc.name =~ /Grimswarm/ && npc.status !~ /dead/ && npc.status != nil} ||
			GameObj.npcs.find{|npc| npc.name =~ /Grimswarm/ && npc.status == nil} ||
			GameObj.npcs.find{|npc| npc.name =~ /Grimswarm/ && npc.status !~ /dead/i} ||
			GameObj.npcs.find{|npc| npc.name =~ /Grimswarm/} ||
		false
	else
		target =	GameObj.npcs.find{|npc| npc.name =~ /Grimswarm/ && npc.status !~ /dead/ && npc.status == nil && npc.noun =~ /warchief|^guard|shaman/} ||
			GameObj.npcs.find{|npc| npc.name =~ /Grimswarm/ && npc.status !~ /dead/ && npc.status == nil && npc.noun =~ /bodyguard|elementalist|witch|sorcer|healer|empath|ranger|wizard|mage|cleric|warlock|scourge|warlock|dissembler/} ||
			GameObj.npcs.find{|npc| npc.name =~ /Grimswarm/ && npc.status !~ /dead/ && npc.status == nil && npc.noun =~ /initiate|scout|archer|sniper|skirmisher|marauder|huntmistress|zealot/} ||
			GameObj.npcs.find{|npc| npc.name =~ /Grimswarm/ && npc.status !~ /dead/ && npc.status == nil && npc.noun =~ /pillager|warrior|fighter|soldier|barbarian|hunter|raider|destroyer/} ||
			GameObj.npcs.find{|npc| npc.name =~ /Grimswarm/ && npc.status !~ /dead/ && npc.status != nil && npc.noun =~ /^guard|warchief|shaman/} ||
			GameObj.npcs.find{|npc| npc.name =~ /Grimswarm/ && npc.status !~ /dead/ && npc.status != nil && npc.noun =~ /bodyguard|elementalist|witch|sorcer|healer|empath|ranger|wizard|mage|cleric|warlock|scourge|warlock|dissembler/} ||
			GameObj.npcs.find{|npc| npc.name =~ /Grimswarm/ && npc.status !~ /dead/ && npc.status != nil && npc.noun =~ /initiate|scout|archer|sniper|skirmisher|marauder|huntmistress|zealot/} ||
			GameObj.npcs.find{|npc| npc.name =~ /Grimswarm/ && npc.status !~ /dead/ && npc.status != nil && npc.noun =~ /pillager|warrior|fighter|soldier|hunter|raider|barbarian/} ||
			GameObj.npcs.find{|npc| npc.name =~ /Grimswarm/ && npc.status !~ /dead/ && npc.status != nil} ||
			GameObj.npcs.find{|npc| npc.name =~ /Grimswarm/ && npc.status == nil} ||
			GameObj.npcs.find{|npc| npc.name =~ /Grimswarm/ && npc.status !~ /dead/i} ||
			GameObj.npcs.find{|npc| npc.name =~ /Grimswarm/} ||
		false
	end
	return(gtarget) if target.id == 4 || target.id == 0
#	echo "****** #{target.name}, #{target.id}, #{target.status}" unless target.status == nil
#	echo "****** #{target.name}, #{target.id}, STANDING" if target.status == nil
	return(gsearch(target.id)) if target.status =~ /dead/i
	return(gtarget(target.id)) if target
	return(gtarget)
end
#########
def gsearch(critter = false, force = false)
	target = false
	if critter && force
		target = GameObj.npcs.find{|npc| npc.id.to_i == critter.to_i || npc.noun =~ /#{critter}/ || npc.name =~ /#{critter}/}
	elsif critter
		target = GameObj.npcs.find{|npc| npc.status =~ /dead/ && (npc.id.to_i == critter.to_i || npc.noun =~ /#{critter}/ || npc.name =~ /#{critter}/)}
	else
		target = GameObj.npcs.find{|npc| npc.status =~ /dead/i}
	end
	return(gtarget) unless target || force
	unless force
		gskin(target.id) if target.name =~ /#{$skin_critters.join('|')}/ && $skinweap
		fhand
	end
	x = false
	unless $noloot.include?(target.noun)
#	unless $mynpc.include?(target.id)
		waitrt?
		fput 'stance def' unless percentstance >= 80
		fput "loot ##{target.id}"
		x = matchtimeout(1, "search|alive|bad idea")
		if x =~ /You must be a member of ([A-Z][a-z])+'s group to search/
			2.times{fput "hold #{$1}";sleep 1}
			return(gsearch(critter, force))
		end
		unless x =~ /alive|search/
			$mynpc.push(target.id) unless $mynpc.include?(target.id)
		end
	else
		newtarget = gnpcs($id).noun
		msg("You are set to not search #{newtarget}")
		$mynpc.push($id) if $id && !$mynpc.include?($id) && $noloot.include?(gnpcs($id).noun)
#		$id = false
#		$target = false
	end
	return(gtarget)
end
def hands_empty
	return(true) if GameObj.right_hand.name == 'Empty' && GameObj.left_hand.name == 'Empty'
	return(false)
end
def clear_hands
	until hands_empty
		if GameObj.right_hand.name != "Empty"
			if GameObj.right_hand.noun =~ /#{$gweaps.join('|')}/
				fput "store weapon"
			else
				$contid.each{|cont|
					fput "_drag ##{GameObj.right_hand.id} ##{cont}"
					break if GameObj.right_hand.name == 'Empty'
				}
			end
		end
		if GameObj.left_hand.name != 'Empty'
			if GameObj.left_hand.noun =~ /#{$gshield.join('|')}/
				fput "store shield"
			elsif GameObj.left_hand.noun =~ /#{$gweaps.join('|')}/
				fput "store weapon"
			else
				$contid.each{|cont|
					fput "_drag ##{GameObj.left_hand.id} ##{cont}"
					break if GameObj.left_hand.name == 'Empty'
				}
			end
		end
	end
end
def ehand
	if GameObj.right_hand.name == "Empty" || GameObj.left_hand.name == "Empty"
		$hands = false unless $hands
	elsif GameObj.right_hand.noun =~ /staff|runestaff|scepter|crook|crosier/
		fput "_drag ##{$hands[0]} ##{$contid[0]}"
		$hands = false
	elsif GameObj.left_hand.noun =~ /targe|aegis|scutum|parma|heater|shield|pavis|mantlet|greatshield|buckler/i
		if GameObj.right_hand.name =~ /sonic/ || Char.prof =~ /bard/i
			$hands = [GameObj.left_hand.id, "left"]
			fput "store shield"
		elsif ((Skills.dodging + [Skills.edgedweapons, Skills.bluntweapons, Skills.thrownweapons, Skills.twohandedweapons, Skills.brawling, Skills.polearmweapons].max) / 3) > Skills.shielduse
			$hands = [GameObj.left_hand.id, "left"]
			fput "store shield"
		else
			$hands = [GameObj.right_hand.id, "right"]
			fput "_drag ##{$hands[0]} ##{GameObj.inv.find{|thing| thing.noun == $firstsack}.id}"
		end
	elsif GameObj.left_hand.noun =~ /(cross)?bow|arbalest|yumi/i
		$hands = [GameObj.right_hand.id, "right"]
		fput "_drag ##{$hands[0]} ##{GameObj.inv.find{|thing| thing.noun == $firstsack}.id}"
	else
		$hands = [GameObj.left_hand.id, "left"]
		fput "_drag ##{$hands[0]} ##{GameObj.inv.find{|thing| thing.noun == $firstsack}.id}"
	end
end
def fhand
	fput "stow #{$hands[1]}" if $hands && (!GameObj.right_hand.name =~ /empty/i && !GameObj.left_hand.name =~ /empty/i)
	fput "_drag ##{$hands[0]} #{$hands[1]}" if $hands
	$hands = false
end
###################
### ATTACK METHODS ###
def stance
	wait_rt
	if $cmastery
		fput "cman cmast #{$cmastery}" if percentstance > $cmastery
	elsif $upstance
		until checkstance($upstance)
			put "stance #{$upstance}"
			matchtimeout(1, 'You are now')
		end
	else
		until percentstance < 20
			put "stance off"
			matchtimeout(1, 'You are now')
		end
	end
end
def useitem(myitems)
	myitems.each{|item|
		next if item =~ /small statue/ && Spell[1712].active?
		next if item =~ /heavy quartz orb/ && Spell[1711].active?
		next if item =~ /white crystal/ && Spell[509].active?
		next if item =~ /dull gold coin/ && Spell[1701].active?
		next if item =~ /solid moonstone cube/ && Spell[9002].active?
		myitem = false
		if rloot(item)
			myitem = rloot(item).id
			wait_rt
			multifput("get ##{myitem}","rub ##{myitem}","drop ##{myitem}") if myitem
		elsif gfind(item)
			myitem = gfind(item).id
			wait_rt
			multifput("get ##{myitem}","rub ##{myitem}","stow ##{myitem}") if myitem
		end
	}
end
#		myitem = $all_my_shit.flatten.find{|thing| thing.name =~ /#{item}/}.id if $all_my_shit.flatten.find{|thing| thing.name =~ /#{item}/}
def wrack_check
	status_tags
	evil_pcs = checkpcs
	result = dothistimeout 'sign of recognition', 5, /^You (?:touch|scratch|rub|tap|point to) your (?:right|left) (?:eyebrow|nostril|earlobe|shoulder|cheek) with your (?:right|left) (?:pinky|forefinger|thumb|index finger)\.$/
	unless result.nil?
		while (line = get) and (line !~ /<prompt/)
			if line =~ /<a.*?>([A-Z][a-z]+)<\/a> acknowledges your sign/
				evil_pcs.delete($1)
			end
		end
	end
	status_tags
	if evil_pcs.nil? or evil_pcs.empty?
		sign_of_wracking.cast if checkspirit(6)
	else
		fput 'release' unless checkprep == 'None'
		echo 'waiting for mana...'
	end
end
def wags
	runme("qspellup")	# if Char.name == 'Teclys'
	GameObj.pcs.find_all{|per| per.noun =~ /#{$my_group.join('|')}/}.each{|person|
		respond "Aethor logic and the help of the waggle script will spell up #{person.name}"
		start_script("waggle",[person.noun])
		wait_while{running? 'waggle'}
	}
	respond "Time for your own spells"
	runme("waggle") unless running? 'kspells'
end
def gwrack
	status_tags
	evil_pcs = checkpcs
	result = dothistimeout 'sign of recognition', 5, /^You (?:touch|scratch|rub|tap|point to) your (?:right|left) (?:eyebrow|nostril|earlobe|shoulder|cheek) with your (?:right|left) (?:pinky|forefinger|thumb|index finger)\.$/
	unless result.nil?
		while (line = get) and (line !~ /<prompt/)
			if line =~ /<a.*?>([A-Z][a-z]+)<\/a> acknowledges your sign/
				evil_pcs.delete($1)
			end
		end
	end
	status_tags
	if evil_pcs.nil? or evil_pcs.empty?
		fput "sign of wracking" if checkspirit(6)
	else
		room = Room.current.id
		fput "group lead crosby" unless group?
		while checkpcs
			walk
			waitrt?
		end
		fput "sign of wracking" if checkspirit(6)
		mymove(room)
		if gpcs("Crosby")
			fput "join crosby"
		else
			runme(['go2name','Crosby'])
		end
	end
#	fput "send #{checkmana} crosby"
end
def dispel_result
	result = false
	result = matchtimeout(3, /elemental aura around|blinks and looks around in confusion|bolt of energy leaps|hazy film coats/)
	if result =~ /elemental aura around/
		return(true)
	elsif result =~ /hazy film coats/
		return(true)
	elsif result =~ /blinks and looks around in confusion/i
		return(true)
	elsif result =~ /bolt of energy leaps/i
		$dispelled ||= []
		$dispelled.push($id)
		return(false)
	else
		return(false)
	end
end
def attack(target = false)
	nextline = false
	if target
		if target.to_i == 0
			gtarget(target)
			attack($id)
		else
			stance
			fput "attack"
#			fput "attack ##{$id}"
			nextline = matchtimeout(1,"already dead","What were you referring to","You swing","You can't reach","no valid target","Just as you move to","\.\.\.wait")
			if nextline =~ /already dead/i then gsearch($id)
			elsif nextline =~ /Just as you|You can't reach/
				nostick = GameObj.npcs.find{|npc| npc.id.to_i != $id.to_i}.id || false
				gtarget(nostick) if nostick
				gtarget unless nostick
			else
				gsearch if GameObj.npcs.find{|npc| npc.id == $id && npc.status =~ /dead/i}
			end
		end
	else
		gtarget unless $id
		stance
		fput "attack" if $id
		#attack($id) if $id
	end
end
def gbush(target = false, aim = "left eye")
	if target.to_i == 0
		$id = gnpcs(target).id || false
		return unless $id
		target = $id
		gbush($id, aim) if $id
	elsif target.to_i > 0 || target.to_i < 0
	else
		gtarget
		gbush($id, aim) if $id
		return
	end
	stance
	clear
	fput "ambush ##{target} #{aim}"
	nextline = matchtimeout(1,"already dead","What were you referring to","You swing","You can't reach","no valid target","aim that high", "Just as you move to","\.\.\.wait", "already missing","Roundtime", "does not have")
	if nextline =~ /You swing/i then wait_rt
	elsif nextline =~ /can't reach/i
#		echo "HURL, work on this"
		echo "OUT OF RANGE, FLYER"
		sleep 1
	elsif nextline =~ /already missing|does not have/
		if aim =~ /left eye/ then aim = "right eye"
		elsif aim =~ /right eye/ then aim = "neck"
		elsif aim =~ /neck/ then aim = "head"
		elsif aim =~ /head/ then aim = "right arm"
		elsif aim =~ /right arm/ then aim = "left arm"
		elsif aim =~ /left arm/ then aim = "back"
		elsif aim =~ /back/ then aim = "chest"
		elsif aim =~ /chest/ then aim = "abdomen"
		elsif aim =~ /abdomen/ then aim = "left leg"
		elsif aim =~ /left leg/ then aim = "right leg"
		elsif aim =~ /right leg/ then aim = "left eye"
		else
			aim = "left eye"
		end
		ambush($id, aim)
	elsif nextline =~ /aim that high/
		aim = ["left leg", "right leg"]
		ambush($id, aim[rand aim.length])
	end
end
def gwound
	return(true) if [Wounds.head, Wounds.neck, Wounds.torso, Wounds.limbs, Wounds.nerves, Scars.head, Scars.neck, Scars.torso, Scars.limbs, Scars.nerves].max > 1 or (percenthealth < 65)
	return(false)
end
def anywound
	return(true) if [Wounds.head, Wounds.neck, Wounds.torso, Wounds.limbs, Wounds.nerves].max >= 1
	return(false)
end
def anyscar
	return(true) if [Scars.head, Scars.neck, Scars.torso, Scars.limbs, Scars.nerves].max >= 1
	return(false)
end
def trigger
	x = matchwait /(#{$my_group.join('|')}) (#{$hair_trigger.join("|")})/
	return(x)
end
def conditions
	return(true) if (rloot('web') && rloot('web').name !~ /burn|flame|fire/) || rloot('cloud') || rloot('swarm') || rloot('vine')
	return(false)
end
def dispel_conditions
#	spell_906(rloot('web').id) if rloot("web") && rloot("web").name !~ /burn|flame|fire/ && Spell[906].affordable? && Spell[906].known?
#	multifput("stance guard", "prep 111", "cast ##{rloot('web').id}") if rloot("web") && rloot("web").name !~ /burn|flame|fire/ && Spell[111].affordable? && Spell[111].known?
#	spell_111(rloot('web').id)
	spell_417(rloot('web').id) if rloot("^web$") && rloot("^web$").name !~ /burn|flame|fire/ && Spell[417].affordable? && Spell[417].known?
	spell_119(rloot('web').id) if rloot("^web$") && rloot("^web$").name !~ /burn|flame|fire/ && Spell[119].affordable? && Spell[119].known?
	spell_505(rloot('cloud').id) if rloot('cloud') && Spell[505].affordable? && Spell[505].known?
	spell_417(rloot('cloud').id) if rloot('cloud') && Spell[417].affordable? && Spell[417].known?
	spell_119(rloot('cloud').id) if rloot('cloud') && Spell[119].affordable? && Spell[417].known?
	spell_912 if rloot('swarm') && !$tremmors && Spell[912].affordable? && $shroudlevel <= 50 && Spell[912].known?
	spell_912 if rloot('vortex') && !$tremmors && Spell[912].affordable? && $shroudlevel <= 50 && Spell[912].known?
	spell_417(rloot('vortex').id) if rloot('vortex') && Spell[417].affordable? && Spell[417].known?
	unless gpcs("Wutaki")
		spell_417(rloot('vine').id) if rloot("^vine$") && Spell[417].affordable? && Spell[417].known?
		spell_119(rloot('vine').id) if rloot("^vine$") && Spell[119].affordable? && Spell[119].known?
	end
	spell_119(rloot('vortex').id) if rloot('vortex') && Spell[119].affordable? && Spell[119].known?
end
def cookbread(y = 0)
	if GameObj.pcs.find{|pc| pc.noun =~ /Aethor/i}
		fput "whisper ##{GameObj.pcs.find{|pc| pc.noun =~ /Aethor/i}.id} cook will ya cook bread for me"
		x = false
		x = matchtimeout(21, "(Aethor|Teclys) drops|(waybread|flatbread|cake|dumpling) appears in the air, then falls to the ground")
		if x
			if lhand
				myhand = lhand.id
				stashleft
			else
				myhand = false
			end
			fput "_drag ##{GameObj.loot.find{|thing| thing.noun =~ /waybread|flatbread|cake|biscuit|bread|dumpling/i}.id} left"
			sleep 1
			while lhand
				fput "gobb ##{lhand.id}"
			end
			fput "_drag ##{myhand} left" if myhand
		else
			y += 1
			return(cookbread(y)) if y < 3
			respond "no bread found"
		end

	end
end
$corrupted = [] unless $corrupted
def corrupt
	wait_rt
	start_script("corrupt") unless running? 'corrupt'
	unless $corrupted.empty?
		$corrupted.each{|npc|
			$corrupted.delete(npc) unless GameObj.npcs.find{|this| this.id == npc }
		}
	end
	if GameObj.npcs.find_all{|npc| npc.name =~ /#{$corrupt.join('|')}/}.length >= 3 || (gnpcs($avoid.join('|')) && gnpcs($avoid.join('|')).name !~ /dybbuk|waern|Citadel herald/i)
		respond "too many casters to be effective, or bad critters"
#		gloot
#		respond "GET THE FUCK OUT"
	else
		GameObj.npcs.find_all{|npc| npc.name =~ /#{$corrupt.join('|')}/ }.each{|cor|
			#&& npc.id.to_s !~ /#{$corrupted.join('|')}/
			if $corrupted.include?(cor.id)
				next
			else
				spell_703f(cor.id) unless cor.status =~ /dead|stun|web|bind|immob|sympa|paraly/i
				$corrupted.push(cor.id) if $fcorr
				wait_rt
			end
		}
	end
end
def intown
	done = false
	action = proc{ |lines|
		if lines =~ /no justice other than your own/
			$intown = false
			done = true;
			nil
		elsif lines =~ /surroundings are calm enough/
			$intown = true
			done = true
			nil
		elsif lines =~ /there is enough chaos that the constable/
			$intown = false
			done = true
			nil
		else
			lines
		end
	}
	DownstreamHook.add('justice', action)
	$_SERVER_.puts "<c>justice status\n"
	t=Time.now
	wait_until {done or t+3<Time.now}
	DownstreamHook.remove('justice')
	return($intown)
end
def bard_squelch(set_on = true)
	if set_on
		DownstreamHook.remove("bardsquelch")
		action = proc{|server_string|
			case server_string
			when /begins a musical chant|sings a melody, directing the sound|sings something in Guildspeak|seems to respond to the magic|tune, adding a new element to|skillfully weaves another verse into|When the song ends, you notice|voice focuses on the/
				nil
			else
				server_string
			end
		}
		DownstreamHook.add("bardsquelch", action)
	else
		DownstreamHook.remove("bardsquelch")
	end
end
bard_squelch
### NOT MY CODE ###
def isNumeric(s)
	begin
	Float(s)
	rescue
		false
		# not numeric
	else
		true
		# numeric
	end
end
def multiLineGet(exec_cmd,timeout,ignore_exp=Regexp.new('zzzzzz'),asArray=false)
	## Get's all game lines during timeout period and returns a single
	##   string with all game lines (useful for regex compares)
	## timeout is integer in seconds
	## ignore_string should be a regular expression. NOT a string.
	## example...
	## multiLineGet("look",2,/\[LNet]/) - would ignore lnet channel chat)
	##
	## If you'd rather just get the whole array, set 4th parameter to true
	started_at = Time.now
	stop_at = Time.now + timeout
	waitrt?  # wait for rt
	waitcastrt?
	mlg_lines = Array.new
	$_SERVER_.write("#{$cmd_prefix}#{exec_cmd}\n")
	while Time.now < stop_at
		tmp_line = get
		if tmp_line !~ ignore_exp then mlg_lines.push(tmp_line) end
	end
	if asArray then return mlg_lines end
	return mlg_lines.join(sep=" ")
end
def msg(text)
	### METHOD PROVIDED BY Casis, thank you.
	stringArray = Array.new
	stringArray = (text.gsub(/[\n]+/, "o=\_=zz")).split(/o=\_=zz/)
	if $fake_stormfront
		preface_text = "\034GSL\r\n "
		end_text = "\034GSM\r\n "
	else
		preface_text = "<pushBold\/>"
		end_text = "<popBold\/>"
	end
	stringArray.each { |line|
		puts "#{preface_text}#{line.gsub('\n','')}#{end_text}"
	}
end
def vanish
	base = 25
	if hiding?
	else
		if Spell[9603].active? && checkrt > 0
			base += (checkrt / 2)
			cost = [base, 75].min
			put "cman vanish" if stamina?(cost)
		elsif checkrt > 0
			base += checkrt
			cost = [base, 75].min
			fput "cman vanish" if stamina?(cost)
		else
			fput "cman vanish" if stamina?(base)
		end
	end
	waitrt?
	fput "hide" unless hiding?
end
def close_all
	$contid.each{|thing|;fput "close ##{thing}"}
end
def open_all
	$contid.each{|thing|;fput "open ##{thing}"}
end
def logged_in
	time = Time.now - $login_time
	hours = (time / 3600).floor
	minutes = ((time - hours * 3600) / 60).floor
	seconds = (time - (( hours * 3600) + (minutes * 60))).floor
	if seconds == 60
		seconds = 0
		minutes += 1
	end
	if minutes >= 60
		hours += 1
		minutes -= 60
	end
	if seconds == 1 then secword = 'second' else secword = 'seconds' end
	if minutes == 1 then minword = 'minute' else minword = 'minutes' end
	if hours == 1 then hourword = 'hour' else hourword = 'hours' end
	if hours > 0
		if seconds > 0 && minutes > 0
			line = "You have been logged in for #{hours} #{hourword} #{minutes} #{minword} #{seconds} #{secword}."
		elsif seconds > 0
			line = "You have been logged in for #{hours} #{hourword} #{seconds} #{secword}."
		elsif minutes > 0
			line = "You have been logged in for #{hours} #{hourword} #{minutes} #{minword}."
		else
		end
	elsif minutes > 0
		if seconds > 0
			line = "You have been logged in for #{minutes} #{minword} #{seconds} #{secword}."
		else
			line = "You have been logged in for #{minutes} #{minword}."
		end
	else
		line = "You have been logged in for #{seconds} #{secword}."
	end
	msg line
	return([hours, minutes, seconds])
end
$container ||= []
contruns = 0
until !$container.empty?
	unless $contid.empty?
		$container = $contid
		$i_have_run = true
		next
	end
	wait_while("ROUNDTIME"){checkrt > 0}
	break if contruns > 9
	done = false
	action = proc{ |grab_this|
		if grab_this.strip.length == 0
			nil
			next
		end
		if grab_this =~ /You are wearing/i
			$container = grab_this.scan(/a exist\=\"([\d]+)[^\.|,]/).flatten
			nil
		elsif grab_this =~ /\<prompt time\=/
			done = true
			nil
		else
			grab_this
		end
	}
	DownstreamHook.remove('inv_cont')
	waitrt?
	DownstreamHook.add('inv_cont', action)
	status_tags
	$_SERVER_.puts "inv cont"
	t=Time.now
	wait_until {done or t+3<Time.now}
	DownstreamHook.remove('inv_cont')
	status_tags
	contruns += 1
end
conta = proc{ |newstring|
	if newstring.strip.length == 0
		nil
		next
	end
	case newstring
	when /you see|nothing/
		nil
	else
		newstring
	end
}
$i_have_run ||= false
unless $i_have_run
	$i_have_run = true
	DownstreamHook.add('checkconts', conta)
	respond ""
	respond " *** LOADING GameObj DATA ***"
	respond ""
	$container.each{|cont|;$_SERVER_.puts "look in ##{cont}";matchtimeout(1, "you see|nothing")}
	respond "*********************"
	respond ""
	respond "*** XML DATA LOADED ***"
	respond ""
	DownstreamHook.remove('checkconts')
end
def gconts(what = nil)
	return(GameObj.inv.find_all{|stuff| $container.include?(stuff.id.to_s)}) unless what
	if what.to_i != 0
		return(nil) unless GameObj.inv.find{|stuff| $container.include?(stuff.id.to_s)}
		newcont = GameObj.inv.find{|stuff| $container.include?(stuff.id.to_s) && stuff.id == what}
	elsif what =~ /\s/
		newcont = GameObj.inv.find{|stuff| $container.include?(stuff.id.to_s) && stuff.name =~ /#{what}/}
	else
		newcont = GameObj.inv.find{|stuff| $container.include?(stuff.id.to_s) && stuff.noun =~ /#{what}/i}
	end
	return(newcont)
end
def rhand(what = nil)
	return nil if GameObj.right_hand.name =~ /Empty/
	if what.to_i != 0
		return nil unless GameObj.right_hand.id.to_i == what.to_i
	elsif what =~ /\s/
		return(nil) unless GameObj.right_hand.name =~ /#{what}/i
	elsif what =~ /\w+/i
		return nil unless GameObj.right_hand.noun =~ /#{what}/i
	end
	return(GameObj.right_hand)
end
def lhand(what = nil)
	return nil if GameObj.left_hand.name =~ /Empty/
	if what.to_i != 0
		return nil unless GameObj.left_hand.id.to_i == what.to_i
	elsif what =~ /\s/
		return(nil) unless GameObj.left_hand.name =~ /#{what}/i
	elsif what =~ /\w+/i
		return nil unless GameObj.left_hand.noun =~ /#{what}/i
	end
	return(GameObj.left_hand)
end
def stashright
	return unless rhand
	$container.each{|cont|
		break unless rhand
		next if $no_shit_here.include?(ginv(cont).noun)
		fput "_drag ##{rhand.id} ##{cont}"
		matchtimeout(1, "compartments|put|fit|cannot attach")
	}
	fput "_drag ##{rhand.id} wear" if rhand
	return unless rhand
	respond "YOU ARE HAVING RIGHT HAND ISSUES"
	wait_while("WAITING FOR EMPTY RIGHT HAND."){rhand}
end
$no_shit_here = ['keyring', 'scabbard', 'sheath', 'quiver', 'bandolier', 'toolkit']
def stashleft
	return unless lhand
	fput "_drag ##{lhand.id} wear" if lhand('keyring')
	$container.each{|cont|
		break unless lhand
		next if $no_shit_here.include?(ginv(cont).noun)
		fput "_drag ##{lhand.id} ##{cont}"
		matchtimeout(1, "compartments|put|fit|cannot attach")
	}
	fput "_drag ##{lhand.id} wear" if lhand
	return unless lhand
	respond "YOU ARE HAVING RIGHT HAND ISSUES"
	wait_while("WAITING FOR EMPTY LEFT HAND."){lhand}
end
def ginv(what = nil)
	if what.to_i != 0
		return nil unless GameObj.inv.find{|shit| shit.id.to_i == what.to_i}
		return(GameObj.inv.find{|shit| shit.id.to_i == what.to_i}) if GameObj.inv.find{|shit| shit.id.to_i == what.to_i}
	elsif what =~ /\s/
		return(GameObj.inv.find{|shit| shit.name =~ /#{what}/i}) if GameObj.inv.find{|shit| shit.name =~ /#{what}/i}
		return(nil) unless GameObj.inv.find{|shit| shit.name =~ /#{what}/i}
	elsif what =~ /\w+/i
		return(GameObj.inv.find{|shit| shit.noun =~ /#{what}/i}) if GameObj.inv.find{|shit| shit.noun =~ /#{what}/i}
		return nil unless GameObj.inv.find{|shit| shit.noun =~ /#{what}/i}
	end
	return(GameObj.inv)
end
def mystuff(what = nil)
	allstuff = []
	if what.to_i != 0
		gconts.each{|thing| thing.contents.each{|item| allstuff.push(item) if item.id.to_i == what.to_i}}
	elsif what =~ /\s/
		gconts.each{|thing| thing.contents.each{|item| allstuff.push(item) if item.name =~ /#{what}/i}}
	elsif what =~ /\w+/i
		gconts.each{|thing| thing.contents.each{|item| allstuff.push(item) if item.noun =~ /#{what}/i}}
	else
		gconts.each{|thing| thing.contents.each{|item| allstuff.push(item)}}
	end
	allstuff.push(rhand) if rhand
	allstuff.push(lhand) if lhand
	return(allstuff)
end
def gfind(what, cont = nil)
	if cont
		if what.to_i != 0
			x = ginv(cont).contents.find{|thing| thing.id.to_i == what.to_i} || nil
		elsif what =~ /\s/
			x = ginv(cont).contents.find{|thing| thing.name =~ /#{what}/i} || nil
		elsif what =~ /\w+/i
			x = ginv(cont).contents.find{|thing| thing.noun =~ /#{what}/i} || nil
		end
	else
		if what.to_i != 0
			x = mystuff.find{|thing| thing.id.to_i == what.to_i} || ginv.find{|thing| thing.id.to_i == what.to_i} || nil
		elsif what =~ /\s/
			x = mystuff.find{|thing| thing.name =~ /#{what}/i} || ginv.find{|thing| thing.name =~ /#{what}/i} || nil
		elsif what =~ /\w+/i
			x = mystuff.find{|thing| thing.noun =~ /#{what}/i} || ginv.find{|thing| thing.noun =~ /#{what}/i} || nil
		end
	end
	return(x)
end
def gfindall(what = false, cont = false)
	return(mystuff) unless what
	if cont
		unless ginv(cont)
			return false
		end
		if what.to_i != 0
			x = ginv(cont).contents.find_all{|thing| thing.id.to_i == what.to_i} || nil
		elsif what =~ /\s/
			x = ginv(cont).contents.find_all{|thing| thing.name =~ /#{what}/i} || nil
		elsif what =~ /\w+/i
			x = ginv(cont).contents.find_all{|thing| thing.noun =~ /#{what}/i} || nil
		end
	else
		if what.to_i != 0
			x = mystuff.find_all{|thing| thing.id.to_i == what.to_i} || nil
		elsif what =~ /\s/
			x = mystuff.find_all{|thing| thing.name =~ /#{what}/i} || nil
		elsif what =~ /\w+/i
			x = mystuff.find_all{|thing| thing.noun =~ /#{what}/i} || nil
		end
	end
	return(x)
end
def allrloot(what = nil)
	return nil if GameObj.loot == nil
	if what.type == Array
		temp_array = []
		what.each{|thing|
			if thing.to_i != 0
				temp_array.push(GameObj.loot.find{|item| item.id.to_i == what.to_i})
			elsif thing =~ /\s/
				GameObj.loot.find_all{|shit| shit.name =~ /#{thing}/}.each{|item| temp_array.push(item)}
			elsif thing =~ /\w+/i
				GameObj.loot.find_all{|shit| shit.noun =~ /#{thing}/}.each{|item| temp_array.push(item)}
			end
		}
		return(temp_array)
	elsif what.to_i != 0
		return([]) unless GameObj.loot.find_all{|shit| shit.id.to_i == what.to_i}
		return(GameObj.loot.find_all{|shit| shit.id.to_i == what.to_i}) if GameObj.loot.find_all{|shit| shit.id.to_i == what.to_i}
	elsif what.type == String
		if what =~ /\s/
			return([]) unless GameObj.loot.find_all{|shit| shit.name =~ /#{what}/i}
			return(GameObj.loot.find_all{|shit| shit.name =~ /#{what}/i}) if GameObj.loot.find_all{|shit| shit.name =~ /#{what}/i}
		elsif what =~ /\w+/i
			return([]) unless GameObj.loot.find_all{|shit| shit.noun =~ /#{what}/i}
			return(GameObj.loot.find_all{|shit| shit.noun =~ /#{what}/i}) if GameObj.loot.find_all{|shit| shit.noun =~ /#{what}/i}
		end
	end
	return(GameObj.loot)
end
def rloot(what = nil)
	return nil if GameObj.loot == nil
	if what.to_i != 0
		return nil unless GameObj.loot.find{|shit| shit.id.to_i == what.to_i}
		return(GameObj.loot.find{|shit| shit.id.to_i == what.to_i}) if GameObj.loot.find{|shit| shit.id.to_i == what.to_i}
	elsif what =~ /\s/
		return(nil) unless GameObj.loot.find{|shit| shit.name =~ /#{what}/i}
		return(GameObj.loot.find{|shit| shit.name =~ /#{what}/i}) if GameObj.loot.find{|shit| shit.name =~ /#{what}/i}
	elsif what =~ /\w+/i
		return nil unless GameObj.loot.find{|shit| shit.noun =~ /#{what}/i}
		return(GameObj.loot.find{|shit| shit.noun =~ /#{what}/i}) if GameObj.loot.find{|shit| shit.noun =~ /#{what}/i}
	end
	return(GameObj.loot)
end
def rdesc(what = nil)
	return nil if GameObj.room_desc == nil
	if what.to_i != 0
		return nil unless GameObj.room_desc.find{|shit| shit.id.to_i == what.to_i}
		return(GameObj.room_desc.find{|shit| shit.id.to_i == what.to_i}) if GameObj.room_desc.find{|shit| shit.id.to_i == what.to_i}
	elsif what =~ /\s/
		return(nil) unless GameObj.room_desc.find{|shit| shit.name =~ /#{what}/i}
		return(GameObj.room_desc.find{|shit| shit.name =~ /#{what}/i}) if GameObj.room_desc.find{|shit| shit.name =~ /#{what}/i}
	elsif what =~ /\w+/i
		return nil unless GameObj.room_desc.find{|shit| shit.noun =~ /#{what}/i}
		return(GameObj.room_desc.find{|shit| shit.noun =~ /#{what}/i}) if GameObj.room_desc.find{|shit| shit.noun =~ /#{what}/i}
	end
	return(GameObj.room_desc)
end
def gpcs(what = nil)
	return nil if GameObj.pcs == nil
	if what.to_i != 0
		return nil unless GameObj.pcs.find{|pc| pc.id.to_i == what.to_i}
		return(GameObj.pcs.find{|pc| pc.id.to_i == what.to_i}) if GameObj.pcs.find{|pc| pc.id.to_i == what.to_i}
	elsif what =~ /\s/
		return(nil) unless GameObj.pcs.find{|pc| pc.name =~ /#{what}/i}
		return(GameObj.pcs.find{|pc| pc.name =~ /#{what}/i})
	elsif what =~ /\w+/i
		return(nil) unless GameObj.pcs.find{|pc| pc.noun =~ /#{what}/i}
		return(GameObj.pcs.find{|pc| pc.noun =~ /#{what}/i})
	else
		return(GameObj.pcs)
	end
end

def gnpcs(what = nil)
	return nil if GameObj.npcs == nil
	if what.to_i != 0
		return nil unless GameObj.npcs.find{|npc| npc.id.to_i == what.to_i}
		return(GameObj.npcs.find{|npc| npc.id.to_i == what.to_i}) if GameObj.npcs.find{|npc| npc.id.to_i == what.to_i}
	elsif what =~ /\s/
		return(nil) unless GameObj.npcs.find{|npc| npc.name =~ /#{what}/i}
		return(GameObj.npcs.find{|npc| npc.name =~ /#{what}/i})
	elsif what =~ /\w+/i
		return(nil) unless GameObj.npcs.find{|npc| npc.noun =~ /#{what}/i}
		return(GameObj.npcs.find{|npc| npc.noun =~ /#{what}/i})
	else
		return(GameObj.npcs)
	end
end
def gexp(lookfor = false)
	array = []
	done = false
	$lumnis = false
	action = proc{ |lines|
		#echo "*** #{lines}"
		if lines =~ /Level/i
			lines =~ /Level.*?(\d+)/
			$glevel = $1
			lines =~ /Deeds.*?(\d+)/
			$gdeeds = $1
			lines;nil
		elsif lines =~ /Experience/
			lines =~ /Experience.*?(\d+)/
			$gexper = $1
			lines =~ /Death's Sting.\s+(\w+)/
			$gsting = $1
			lines;nil
		elsif lines =~ /Recent Death/
			lines =~ /Exp. (?:until|to) next.*?\s+(\d+)/
			$untilnext = $1
			lines =~ /Recent Deaths.\s+(\d)/
			$recentdeath = $1
			lines;nil
		elsif lines =~ /Fame/
			lines =~ /Mental TPs.\s+(\d+)/
			$mtps = $1
			lines =~ /Fame.\s+(\d+)/
			$gfame = $1
			lines;nil
		elsif lines =~ /Mana/
			lines =~ /Physical TPs.\s+(\d+)/
			$ptps = $1
			lines =~ /Mana.\s+(\d+)\/(\d+).*?max/
			$curmana = $1
			$maxmana = $2
			lines;nil
		elsif lines =~ /converted/
			lines =~ /(\d+) (Phy|Mnt) converted to (Phy|Mnt)/
			a = $1
			b = $2
			c = $3
			$conversion = [a, b, c]
			lines;nil
		elsif lines =~ /mind|rest/
			$gmind = lines;nil
		elsif lines =~ /strange sense of serenity/
			$lumnis = true
			lines;nil
		elsif lines =~ /\<prompt time\=/
			lines
			done = true;nil
		else
			lines;nil
		end
	}
	DownstreamHook.add('exper', action)
	status_tags
	$_SERVER_.puts "exp"
	t=Time.now
	wait_until {done or t+3<Time.now}
	DownstreamHook.remove('exper')
	status_tags
	array = [$glevel, $gdeeds, $gexper, $gsting, $untilnext, $recentdeath, $mtps, $gfame, $ptps, $curmana, $maxmana, $conversion, $gmind, $lumnis]
	if lookfor =~ /level/i
		return($glevel)
	elsif lookfor =~ /deed/
		return($gdeeds)
	elsif lookfor =~ /expe?r?i?e?n?c?e?/
		return($gexper)
	elsif lookfor =~ /sting/
		return($gsting)
	elsif lookfor =~ /next/
		return($untilnext)
	elsif lookfor =~ /death/
		return($recentdeath)
	elsif lookfor =~ /mtp/i
		return($mtps)
	elsif lookfor =~ /fame/
		return($gfame)
	elsif lookfor =~ /ptp/i
		return($ptps)
	elsif lookfor =~ /mana/i
		return($curmana)
	elsif lookfor =~ /max/
		return($maxmana)
	elsif lookfor =~ /conver?t?s?/
		return($conversion)
	elsif lookfor =~ /mind/
		return($gmind)
	elsif lookfor =~ /gift/
		return($lumnis)
	else
		if $lumnis
			respond "Level #{array[0]}, Experience #{array[2]}, #{array[4]} exp until level #{array[0].to_i + 1}, and you are on Gift of Lumnis."
		else
			respond "Level #{array[0]}, Experience #{array[2]}, #{array[4]} exp until level #{array[0].to_i + 1}."
		end
		if array[3] =~ /None/i then sting = 'no' else sting = array[3].downcase end
		if array[5].to_i == 1
			respond "You have #{sting} death's sting and you have had #{array[5]} recent death."
		else
			respond "You have #{sting} death's sting and you have had #{array[5]} recent deaths."
		end
		respond "You have #{array[6]} MTPs and  #{array[8]} PTPs."
		respond "you have #{array[9]} out of #{array[10]} max mana"
		if $conversion.length == 3
			respond "You are converting #{array[11][0]} #{array[11][1]} to #{array[11][2]}"
		else
			respond "YOU DO NOT APPEAR TO BE CONVERTING TPS"
		end
		respond array[12]
		return(array)
	end
end
$spellup_array = []
start_echo = true
def wait_rt
	wait_while { checkrt > 0 or checkcastrt > 0 }
	sleep 0.7
end
def scroll(spell, sack, target = false)
	fput "_drag ##{GameObj.right_hand.id} ##{$mysacks[0].id}" if checkright
	fput "_drag ##{GameObj.left_hand.id} ##{$mysacks[0].id}" if checkleft
	fput "rummage in my #{sack} spell #{spell}"
	if checkright
		multifput("invoke #{spell}", "cast #{target}","put ##{GameObj.right_hand.id} in my #{sack}") if target
		multifput("invoke #{spell}", "cast", "put ##{GameObj.right_hand.id} in my #{sack}") unless target
	else
		$mysacks.each{|cont|
			fput "rummage in my #{cont} spell #{spell}"
			if checkright
				multifput("invoke #{spell}", "cast #{target}","put ##{GameObj.right_hand.id} in my #{cont}") if target
				multifput("invoke #{spell}", "cast", "put ##{GameObj.right_hand.id} in my #{cont}") unless target
				break
			else
			end
		}
	end
end
def gcast(spell, target = false, empbase = false)
	unless empbase
		if	[Wounds.head, Scars.head, Wounds.nsys, Scars.nsys].max >= 2
			respond "head or nerves issue, returning"
			return
		elsif [Wounds.rarm, Wounds.larm, Wounds.rhand, Wounds.lhand, Scars.rarm, Scars.larm, Scars.rhand, Scars.lhand].max == 3
			respond "Severed arm issue, returning"
			return
		elsif ( [Wounds.rarm, Wounds.rhand, Scars.rarm, Scars.rhand].max >= 2 && ([Wounds.larm, Wounds.lhand].max >= 1 || [Scars.larm, Scars.lhand].max >= 2) ) || ( [Wounds.larm, Wounds.lhand, Scars.larm, Scars.lhand].max >= 2 && ([Wounds.rarm, Wounds.rhand].max >= 1 || [Scars.rarm, Scars.rhand].max >= 2) )
			respond "both arms injured and preventing casting, returning."
			return
		end
	end

	waitrt?
	waitcastrt? unless checkspell(515)
	if target
		if target.to_i == 0
			multifput("prep #{spell}","cast #{target}") if prepped? =~ /none/i
			fput "cast #{target}" unless prepped? =~ /none/i
		elsif target.to_i > 0 || target.to_i < 0
			multifput("prep #{spell}","cast ##{target}") if prepped? =~ /none/i
			fput "cast ##{target}" unless prepped? =~ /none/i
		end
	else
		multifput("prep #{spell}","cast") if prepped? =~ /none/i
		fput "cast" unless prepped? =~ /none/i
	end
end
def gcant(spell, target = false, empbase = false)
	if empbase
	else
		if	[Wounds.head, Scars.head, Wounds.nsys, Scars.nsys].max >= 2
			respond "head or nerves issue, returning"
			return
		elsif [Wounds.rarm, Wounds.larm, Wounds.rhand, Wounds.lhand, Scars.rarm, Scars.larm, Scars.rhand, Scars.lhand].max == 3
			respond "Severed arm issue, returning"
			return
		elsif ( [Wounds.rarm, Wounds.rhand, Scars.rarm, Scars.rhand].max >= 2 && ([Wounds.larm, Wounds.lhand].max >= 1 || [Scars.larm, Scars.lhand].max >= 2) ) || ( [Wounds.larm, Wounds.lhand, Scars.larm, Scars.lhand].max >= 2 && ([Wounds.rarm, Wounds.rhand].max >= 1 || [Scars.rarm, Scars.rhand].max >= 2) )
			respond "both arms injured and prevent casting, returning."
			return
		end
	end
	waitrt?
	waitcastrt? unless checkspell(515)
	if target
		if target.to_i == 0
			multifput("prep #{spell}","cast #{target}") if prepped? =~ /none/i
			fput "cast #{target}" unless prepped? =~ /none/i
		elsif target.to_i > 0 || target.to_i < 0
			multifput("prep #{spell}","cast ##{target}") if prepped? =~ /none/i
			fput "cast ##{target}" unless prepped? =~ /none/i
		end
	else
		fput("incant #{spell}")
	end
end
def bolt(spell, target = false, empbase = false)
	if empbase
	else
		if	[Wounds.head, Scars.head, Wounds.nsys, Scars.nsys].max >= 2
			respond "head or nerves issue, returning"
			return
		elsif [Wounds.rarm, Wounds.larm, Wounds.rhand, Wounds.lhand, Scars.rarm, Scars.larm, Scars.rhand, Scars.lhand].max == 3
			respond "Severed arm issue, returning"
			return
		elsif ( [Wounds.rarm, Wounds.rhand, Scars.rarm, Scars.rhand].max >= 2 && ([Wounds.larm, Wounds.lhand].max >= 1 || [Scars.larm, Scars.lhand].max >= 2) ) || ( [Wounds.larm, Wounds.lhand, Scars.larm, Scars.lhand].max >= 2 && ([Wounds.rarm, Wounds.rhand].max >= 1 || [Scars.rarm, Scars.rhand].max >= 2) )
			respond "both arms injured and prevent casting, returning."
			return
		end
	end
	waitrt?
	waitcastrt? unless checkspell(515)
	if target
		if target.to_i == 0
			multifput("prep #{spell}","stance off","cast #{target}","stance guard") if prepped? =~ /none/i
			multifput("stance off","cast #{target}","stance guard") unless prepped? =~ /none/i
		elsif target.to_i > 0 || target.to_i < 0
			multifput("prep #{spell}","stance off","cast ##{target}","stance guard") if prepped? =~ /none/i
			multifput("stance off","cast ##{target}","stance gua") unless prepped? =~ /none/i
		end
	else
		multifput("stance off","incant #{spell}","stance guard")
	end
end
def channel(spell, target = false, empbase = false)
	if empbase
	else
		if	[Wounds.head, Scars.head, Wounds.nsys, Scars.nsys].max >= 2
			respond "head or nerves issue, returning"
			return
		elsif [Wounds.rarm, Wounds.larm, Wounds.rhand, Wounds.lhand, Scars.rarm, Scars.larm, Scars.rhand, Scars.lhand].max == 3
			respond "Severed arm issue, returning"
			return
		elsif ( [Wounds.rarm, Wounds.rhand, Scars.rarm, Scars.rhand].max >= 2 && ([Wounds.larm, Wounds.lhand].max >= 1 || [Scars.larm, Scars.lhand].max >= 2) ) || ( [Wounds.larm, Wounds.lhand, Scars.larm, Scars.lhand].max >= 2 && ([Wounds.rarm, Wounds.rhand].max >= 1 || [Scars.rarm, Scars.rhand].max >= 2) )
			respond "both arms injured and prevent casting, returning."
			return
		end
	end
	waitrt?
	waitcastrt? unless checkspell(515)
	fput "release" unless prepped? =~ /None|#{Spell[spell].name}/
	if target
		if target.to_i == 0
#			multifput("prep #{spell}","stance adv","channel #{target}")
			multifput("prep #{spell}", "channel #{target}")
			wait_rt;fput "stance guard"
		elsif target.to_i > 0 || target.to_i < 0
#			multifput("prep #{spell}","stance adv","channel ##{target}")
			multifput("prep #{spell}","channel ##{target}")
			wait_rt;fput "stance guard"
		end
	else
#		multifput("stance off","prep #{spell}","channel target")
		multifput("prep #{spell}","channel target")
		wait_rt;fput "stance guard"
	end
end
def renew(spell, target = false)
	wait_rt
	#if [Wounds.head, Scars.head, Wounds.nerves, Scars.nerves].max >= 2 || ([Wounds.rightHand, Wounds.rightArm, Scars.rightHand, Scars.rightArm].max >= 2 && [Wounds.leftHand, Wounds.leftArm, Scars.leftHand, Scars.leftArm].max >= 1) || ([Wounds.rightHand, Wounds.rightArm, Scars.rightHand, Scars.rightArm].max >= 1 && [Wounds.leftHand, Wounds.leftArm, Scars.leftHand, Scars.leftArm].max >= 2) || [Wounds.rightArm, Wounds.leftArm, Wounds.rightHand, Wounds.leftHand, Scars.rightArm, Scars.leftArm, Scars.rightHand, Scars.leftHand].max == 3
	#	respond "YOU ARE TOO INJURED"
	#	respond "RETURNING"
	#	return
	#end
	if target
		fput "renew #{spell} #{target}" if target.to_i == 0
		fput "renew #{spell} ##{target}" if target.to_i != 0
		result = matchtimeout(1,  /you are not singing|sing with renewed|Renew what/)
		if result =~ /not singing|what/
			if checkmana >= 70
				sing(spell)
			elsif checkmana >= 50 && Spellsong.timeleft  > 1.3
				sing(spell)
			else
				echo "Song not running, #{(Spellsong.timeleft * 60).to_i} seconds left for renewal"
			end
		elsif result =~ /renewed/
		end
	else
		fput "renew #{spell}"
		result = matchtimeout(3,  /you are not singing|sing with renewed|Renew what|do not currently have a target/)
		if result =~ /not singing|what/
			if checkmana >= 70
				sing(spell)
			elsif checkmana >= 50 && Spellsong.timeleft  > 1.3
				sing(spell)
			else
				echo "Song not running, #{(Spellsong.timeleft * 60).to_i} seconds left for renewal"
			end
		elsif result =~ /renewed/
			return
		elsif result =~ /do not currently have a/
			put "release"
			return
		end
	end
end
def sing(spell, target = false)
	wait_rt
	if	[Wounds.head, Scars.head, Wounds.nsys, Scars.nsys].max >= 2
		respond "head or nerves issue, returning"
		return
	elsif [Wounds.rarm, Wounds.larm, Wounds.rhand, Wounds.lhand, Scars.rarm, Scars.larm, Scars.rhand, Scars.lhand].max == 3
		respond "Severed arm issue, returning"
		return
	elsif ( [Wounds.rarm, Wounds.rhand, Scars.rarm, Scars.rhand].max >= 2 && ([Wounds.larm, Wounds.lhand].max >= 1 || [Scars.larm, Scars.lhand].max >= 2) ) || ( [Wounds.larm, Wounds.lhand, Scars.larm, Scars.lhand].max >= 2 && ([Wounds.rarm, Wounds.rhand].max >= 1 || [Scars.rarm, Scars.rhand].max >= 2) )
		respond "both arms injured and prevent casting, returning."
		return
	end
	if target
		if target.to_i == 0
			multifput("prep #{spell}","sing #{target}")
			result = matchwait("Spell Hindrance for", "Sing Roundtime", "do not currently have a target")
			sing(spell, target) if result =~ /Spell Hindrance/
		elsif target.to_i > 0 || target.to_i < 0
			multifput("prep #{spell}","sing ##{target}")
			result = matchwait("Spell Hindrance for", "Sing Roundtime", "do not currently have a target")
			sing(spell, target) if result =~ /Spell Hindrance/
		end
	else
		fput "incant #{spell}"
		result = matchwait("Spell Hindrance for", "Sing Roundtime", "do not currently have a target")
		sing(spell) if result =~ /Spell Hindrance/
	end
end
def force(spell = false, target = false)
	x = false
	y = 0
	until x =~ /Warding failed/i || y >= 3
		break unless spell
		break unless gnpcs(target) || gpcs(target)
		if gnpcs(target)
			gcast(spell, target) unless gnpcs(target).status =~ /dead/i
		elsif gpcs(target)
			gcast(spell, target) unless gpcs(target).status =~ /dead/i
		end
		x = matchtimeout(3, "Warding failed!", "Cast Roundtime", "Sing Roundtime", "Warded off", "vanishes into nothingness with a hollow laugh", "Spell Hindrance for", "it suddenly vanishes from view")
		return if x =~ /nothingness/i
		redo if x =~ /Spell Hindrance for/i
		y += 1
		wait_rt
	end
end
$myspelldef = []
if Spells.minorspiritual >= 1 and Char.level >= 1
	(250 / eval(Spell[101].duration)).ceil.times{$spellup_array.push(101)}
	$myspelldef.push(101)
	def spell_101(target = false)
		fput "release" unless prepped? =~ /None|Spirit Warding I/i
		unless checkmana > (eval(Spell[101].cost))
			respond "TOO LOW TO CAST"
			return
		end
		gcant(101, target)
	end
end
if Spells.minorspiritual >= 2 and Char.level >= 2
	$myspelldef.push(102)
	def spell_102(target = false)
		fput "release" unless prepped? =~ /None|Spirit Barrier/i
		unless checkmana > (eval Spell[102].cost)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(102, target)
	end
end
if Spells.minorspiritual >= 3 and Char.level >= 3
	$myspelldef.push(103)
	$spellup_array.push(103)
	def spell_103(target = false)
		fput "release" unless prepped? =~ /None|Spirit Defense/i
		until checkmana > (eval Spell[103].cost)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(103, target)
	end
end
if Spells.minorspiritual >= 4 and Char.level >= 4
	$myspelldef.push(104)
#	(250 / eval(Spell[104].duration)).ceil.times{$spellup_array.push(104)}
	def spell_104(target = false)
		fput "release" unless prepped? =~ /None|Disease Resist/i
		unless checkmana > (eval Spell[104].cost)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(104, target)
	end
end
if Spells.minorspiritual >= 5 and Char.level >= 5
	$myspelldef.push(105)
#	(250 / eval(Spell[105].duration)).ceil.times{$spellup_array.push(105)}
	def spell_105(target = false)
		fput "release" unless prepped? =~ /None|Poison Resist/i
		unless checkmana > (eval Spell[105].cost)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(105, target)
	end
end
if Spells.minorspiritual >= 6 and Char.level >= 6
	$myspelldef.push(106)
	def spell_106(target = false)
		fput "release" unless prepped? =~ /None|Spirit Fog/i
		unless checkmana > 6
			respond "TOO LOW TO CAST"
			return
		end
		gcast(106)
	end
end
if Spells.minorspiritual >= 7 and Char.level >= 7
	$myspelldef.push(107)
	(250 / eval(Spell[107].duration)).ceil.times{$spellup_array.push(107)}
	def spell_107(target = false)
		fput "release" unless prepped? =~ /None|Spirit Warding II/i
		unless checkmana > (eval Spell[107].cost)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(107, target)
	end
end
if Spells.minorspiritual >= 8 && Char.level >= 8
	$myspelldef.push(108)
	def spell_108(target)
		fput "release" unless(checkprep =~ /None|Stun Relief/i)
		unless mana?(8)
			respond "TOO LOW TO CAST"
			return
		end
		gcast(108, target)
	end
end
if Spells.minorspiritual >= 9 and Char.level >= 9
	$myspelldef.push(109)
	def spell_109
		fput("release") unless(checkprep =~ /None|Dispel Invisibility/i)
		unless mana?(9)
			respond "TOO LOW TO CAST"
			return
		end
		gcast(109)
	end
end
if Spells.minorspiritual >= 10 and Char.level >= 10
	$myspelldef.push(110)
	def spell_110(target = false)
		fput("release") unless(checkprep =~ /None|Unbalance/i)
		unless mana?(10)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(110, target) if target
	end
end
#if Skills.spellaiming >= Char.level
	if Spells.minorspiritual >= 11 and Char.level >= 11
		$myspelldef.push(111)
		def spell_111(target = false)
			fput("release") unless(checkprep =~ /None|Fire Spirit/i)
			unless mana?(11)
			respond "TOO LOW TO CAST"
			return
		end
			bolt(111, target = false)
		end
	end
#end
if Spells.minorspiritual >= 12 and Char.level >= 12
	$myspelldef.push(112)
#	(250 / eval(Spell[112].duration)).ceil.times{$spellup_array.push(112)}
	def spell_112(target = false)
		fput "release" unless prepped? =~ /None|Water Walking/i
		unless checkmana > (eval Spell[112].cost)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(112, target)
	end
end
if Spells.minorspiritual >= 13 and Char.level >= 13
	$myspelldef.push(113)
	def spell_113(target = false)
		fput "release" unless prepped? =~ /None|Undisease/i
		unless mana?(13)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(113, target)
	end
end
if Spells.minorspiritual >= 14 and Char.level >= 14
	$myspelldef.push(114)
	def spell_114(target = false)
		fput "release" unless prepped? =~ /None|Unpoison/i
		unless mana?(14)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(114, target)
	end
end
if Spells.minorspiritual >= 15 and Char.level >= 15
	$myspelldef.push(115)
#	$spellup_array.push(115)
	def spell_115(target = false)
		fput "release" unless prepped? =~ /None/
		unless mana?(14)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(115, target)
	end
end
if Spells.minorspiritual >= 16 and Char.level >= 16
	$myspelldef.push(116)
	def spell_116(target)
		fput "release" unless prepped? =~ /None|Locate Person/i
		unless mana?(16)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(116, target)
	end
end
if Spells.minorspiritual >= 117 and Char.level >= 17
	$myspelldef.push(117)
	def spell_117(target = false)
		fput("release") unless(checkprep =~ /None|Spirit Strike/i)
		unless mana?(17)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(117, target)
	end
end
if Spells.minorspiritual >= 18 and Char.level >= 18
	$myspelldef.push(118)
	def spell_118(target = false)
		fput("release") unless(checkprep =~ /None|Web/i)
		unless mana?(18)
			respond "TOO LOW TO CAST"
			return
		end
		### special note, using this with no target will yield an area web, with a target with cast at your target (CS targeted version.)
		gcast(118, target)
	end
	if Skills.spellaiming >= Char.level && Skills.slsummoning >= 20
		$myspelldef.push("118_bolt")
		def spell_118_bolt(target = false)
			fput("release") unless(checkprep =~ /None|Web/i)
			unless mana?(9)
			respond "TOO LOW TO CAST"
			return
		end
			bolt(118, target)
		end
	end
end
if Spells.minorspiritual >= 19 and Char.level >= 19
	$myspelldef.push(119)
	def spell_119(target = false)
		fput("release") unless(checkprep =~ /None|Spirit Dispel/i)
		unless mana?(19)
			respond "TOO LOW TO CAST"
			return
		end
		gcast(119, target)
	end
end
if Spells.minorspiritual >= 20 and Char.level >= 20
	$myspelldef.push(120)
	def spell_120(target = false)
		fput "release" unless prepped? =~ /None|Lesser Shroud/i
		unless checkmana > (eval Spell[120].cost)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(120, target)
	end
end
if Spells.minorspiritual >= 25 and Char.level >= 25
	$myspelldef.push(125)
	def spell_125(target = false)
		fput("release") unless(checkprep =~ /None|Call Lightning/i)
		unless mana?(25)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(125, target)
		#### potential issues.
	end
end
if Spells.minorspiritual >= 30 and Char.level >= 30
	$myspelldef.push(130)
	def spell_130
		fput("release") unless(checkprep =~ /None|Spirit Guide/i)
		unless mana?(30)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(130)
	end
end
if Spells.minorspiritual >= 35 and Char.level >= 35
	$myspelldef.push(135)
	def spell_135
		fput("release") unless(checkprep =~ /None|Searing Light/i)
		unless mana?(35)
			respond "TOO LOW TO CAST"
			return
		end
		wait_rt unless checkspell(515)
		gcast(135)
	end
end
if Spells.minorspiritual >= 40 and Char.level >= 40
	$myspelldef.push(140)
	def spell_140
		fput("release") unless(checkprep =~ /None|#{Spell[140].name}/i)
		unless mana?(40)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(140)
	end
end
if Spells.majorspiritual >= 1 and Char.level >= 1
	$myspelldef.push(201)
	def spell_201(target = false)
		fput("release") unless(checkprep =~ /None|Calm/i)
		unless mana?(1)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(201, target)
	end
end
if Spells.majorspiritual >= 2 and Char.level >= 2
	$myspelldef.push(202)
	$spellup_array.push(202)
	def spell_202(target = false)
		fput "release" unless prepped? =~ /None|Spirit Shield/i
		unless checkmana > (eval Spell[202].cost)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(202, target)
	end
end
if Spells.majorspiritual >= 3 and Char.level >= 3
	$myspelldef.push(203)
	def spell_203
		fput "release" unless prepped? =~ /None|Manna/i
		unless mana?(3)
			respond "TOO LOW TO CAST"
			return
		end
		case Char.name
		when /Aethor/i
			wait_rt
			put "prep 203"
			put "summon biscuit"
		when /Aethor/
			wait_rt
			put "prep 203"
			put "summon bread"
		else
			gcast(203)
		end
	end
end
if Spells.majorspiritual >= 4 and Char.level >= 4
	$myspelldef.push(204)
#	$spellup_array.push(204)
	def spell_204(target = false)
		fput "release" unless prepped? =~ /None|Unpresence/i
		unless checkmana > (eval Spell[204].cost)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(204, target)
	end
end
if Spells.majorspiritual >= 5 and Char.level >= 5
	$myspelldef.push(205)
	def spell_205
		fput "release" unless prepped? =~ /None|Light/i
		unless mana?(5)
			respond "TOO LOW TO CAST"
			return
		end
		gcast(205)
	end
end
if Spells.majorspiritual >= 6 and Char.level >= 6
	$myspelldef.push(206)
	def spell_206
		fput "release" unless prepped? =~ /None|Darkness/i
		unless mana?(6)
			respond "TOO LOW TO CAST"
			return
		end
		gcast(206)
	end
end
if Spells.majorspiritual >= 7 and Char.level >= 7
	$myspelldef.push(207)
#	$spellup_array.push(207)
	def spell_207(target = false)
		fput "release" unless prepped? =~ /None|Purify Air/i
		unless checkmana > (eval Spell[207].cost)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(207, target)
	end
end
if Spells.majorspiritual >= 8 and Char.level >= 8
	$myspelldef.push(208)
	def spell_208(target = false)
		fput("release") unless(checkprep =~ /None|Living Spell/i)
		unless mana?(8)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(208, target)
	end
end
if Spells.majorspiritual >= 9 and Char.level >= 9
	$myspelldef.push(209)
	def spell_209(target = false)
		fput "release" unless checkprep =~ /None|Untrammel/i
		unless mana?(9)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(209, target)
	end
end
if Spells.majorspiritual >= 10 and Char.level >= 10
	$myspelldef.push(210)
	def spell_210(target = false)
		fput("release") unless(checkprep =~ /None|Silence/i)
		unless mana?(10)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(210, target)
	end
end
if Spells.majorspiritual >= 11 and Char.level >= 11
	$myspelldef.push(211)
	def spell_211(target = false)
		fput "release" unless prepped? =~ /None|Bravery/i
		unless checkmana > (eval Spell[211].cost)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(211, target)
	end
end
if Spells.majorspiritual >= 12 and Char.level >= 12
	$myspelldef.push(212)
	def spell_212(target)
		fput("release") unless(checkprep =~ /None|Interference/i)
		unless mana?(12)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(212, target)
	end
end
if Spells.majorspiritual >= 15 and Char.level >= 15
	$myspelldef.push(213)
	def spell_213
		fput "release" unless prepped? =~ /None|Minor Sanctuary/i
		unless mana?(13)
			respond "TOO LOW TO CAST"
			return
		end
		gcast(213)
	end
end
if Spells.majorspiritual >= 14 and Char.level >= 14
	$myspelldef.push(214)
	def spell_214(target = false)
		fput("release") unless(checkprep =~ /None|Bind/i)
		unless mana?(14)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(214, target)
	end
end
if Spells.majorspiritual >= 15 and Char.level >= 15
	$myspelldef.push(215)
	def spell_215(target = false)
		fput "release" unless prepped? =~ /None|Heroism/i
		unless checkmana > (eval Spell[215].cost)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(215, target)
	end
end
if Spells.majorspiritual >= 16 and Char.level >= 16
	$myspelldef.push(216)
	def spell_216(target = false)
		fput("release") unless(checkprep =~ /None|Frenzy/i)
		unless mana?(16)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(216, target)
	end
end
if Spells.majorspiritual >= 17 and Char.level >= 17
	$myspelldef.push(217)
	def spell_217
		fput("release") unless(checkprep =~ /None|Mass Interference/i)
		unless mana?(17)
			respond "TOO LOW TO CAST"
			return
		end
		gcast(217)
	end
end
if Spells.majorspiritual >= 18 and Char.level >= 18
	$myspelldef.push(218)
	def spell_218
		unless checkmana > (eval Spell[218].cost)
			respond "TOO LOW TO CAST"
			return
		end
		fput "release" unless prepped? =~ /None|Spirit Servant/i
		wait_rt
		fput "incant 218"
		x = matchwait("begins to take corporeal form before your eyes")
		y = x.scan(/An? (.+?) begins/)
		GameObj.npcs.find{|fam|
			$mynpc.push(fam.id) if fam.name =~ /#{y}/
		}
#		echo $mynpc
	end
end
if Spells.majorspiritual >= 19 and Char.level >= 19
	$myspelldef.push(219)
	def spell_219(target = false)
		fput "release" unless prepped? =~ /None|Spell Shield/i
		unless checkmana > (eval Spell[219].cost)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(219, target)
	end
end
if Spells.majorspiritual >= 20 and Char.level >= 20
	$myspelldef.push(220)
	def spell_220
		fput "release" unless prepped? =~ /None|Major Sanctuary/i
		unless checkmana >= 20
			respond "TOO LOW TO CAST"
			return
		end
		gcant(220)
	end
end
if Spells.majorspiritual >= 25 and Char.level >= 25
	$myspelldef.push(225)
	def spell_225(target)
		fput "release" unless prepped? =~ /None|Transference/i
		unless mana?(25)
			respond "TOO LOW TO CAST"
			return
		end
		gcast(225, target)

	end
end
if Spells.majorspiritual >= 30 and Char.level >= 30
	$myspelldef.push(230)
	def spell_230(target = false)
		fput("release") unless(checkprep =~ /None|Spiritual Abolition/i)
		unless mana?(30)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(230, target)
	end
end
if Spells.majorspiritual >= 40 and Char.level >= 40
	$myspelldef.push(240)
	def spell_240(target = false)
		fput "release" unless prepped? =~ /None|Spirit Slayer/i
		unless checkmana > (eval Spell[240].cost)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(240)
	end
end
if Spells.cleric >= 1 and Char.level >= 1
	$myspelldef.push(301)
	def spell_301(target = false)
		fput("release") unless(checkprep =~ /None|Prayer of Holding/)
		unless mana?(Char.level / 7.0)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(301, target)
	end
end
if Spells.cleric >= 2 and Char.level >= 2
	$myspelldef.push(302)
	def spell_302(target = false)
		fput("release") unless(checkprep =~ /None|Smite|Bane/i)
		unless mana?(4)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(302, target)
	end
end
if Spells.cleric >= 3 and Char.level >= 3
	$myspelldef.push(303)
#	$spellup_array.push(303)
	def spell_303(target = false)
		fput "release" unless prepped? =~ /None|Prayer of Protection/i
		unless checkmana > (eval Spell[303].cost)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(303, target)
	end
end
if Spells.cleric >= 4 and Char.level >= 4
	$myspelldef.push(304)
	def spell_304(target)
		fput "release" unless prepped? =~ /None|Holy Blade/i
		unless mana?(4)
			respond "TOO LOW TO CAST"
			return
		end
		gcast(304, target)
	end
end
if Spells.cleric >= 5 and Char.level >= 5
	$myspelldef.push(305)
	def spell_305(target = GameObj.pcs.find{|pc| pc.status =~ /dead/i}.id)
		fput "release" unless prepped? =~ /Preservation|None/i
		unless mana?(5)
			respond "TOO LOW TO CAST"
			return
		end
		gcast(305, target)
	end
end
if Skills.spellaiming >= Char.level
	if Spells.cleric >= 6 and Char.level >= 6
		$myspelldef.push(306)
		def spell_306(target = false)
			fput("release") unless(checkprep =~ /None|Holy Bolt/i)
			unless mana?(6)
			respond "TOO LOW TO CAST"
			return
		end
			bolt(306, target)
		end
	end
end
if Spells.cleric >= 7 and Char.level >= 7
	$myspelldef.push(307)
	def spell_307(target = false)
		fput "release" unless prepped? =~ /None|Benediction/i
		unless checkmana > (eval Spell[307].cost)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(307, target)
	end
end
if Spells.cleric >= 8 and Char.level >= 8
	$myspelldef.push(308)
	def spell_308(target = GameObj.pcs.find{|pc| pc.status =~ /dead/i}.id)
		fput "release" unless prepped? =~ /None|Well of Life/i
		unless mana?(8)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(308, target)
	end
end
if Spells.cleric >= 9 and Char.level >= 9
	$myspelldef.push(309)
	def spell_309(target)
		fput "release" unless prepped? =~ /None|Neutralize Curse/i
		unless mana?(9)
			respond "TOO LOW TO CAST"
			return
		end
		gcast(309, target)
	end
end
if Spells.cleric >= 10 and Char.level >= 10
	$myspelldef.push(310)
	def spell_310(target = false)
		fput "release" unless prepped? =~ /None|Warding Sphere/i
		unless checkmana > (eval Spell[310].cost)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(310, target)
	end
end
if Spells.cleric >= 11 and Char.level >= 11
	$myspelldef.push(311)
	def spell_311(target = false)
		fput("release") unless(checkprep =~ /None|Blind/i)
		unless mana?(11)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(311, target)
	end
end
if Spells.cleric >= 12 and Char.level >= 12
	$myspelldef.push(312)
	def spell_312(target = false)
		fput("release") unless(checkprep =~ /None|Fervent Reproach/i)
		wait_rt;fput "prep 312";wait_rt;fput "incant 312";sleep 0.15
	end
end
if Spells.cleric >= 13 and Char.level >= 13
	$myspelldef.push(313)
	def spell_313(target = false)
		fput "release" unless prepped? =~ /None|Prayer/i
		unless checkmana > (eval Spell[313].cost)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(313, target)
	end
end
if Spells.cleric >= 14 and Char.level >= 14
	$myspelldef.push(314)
	def spell_314(target = false)
		fput("release") unless(checkprep =~ /None|Interdiction/i)
		unless mana?(14)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(314, target)
	end
end
if Spells.cleric >= 15 and Char.level >= 15
	$myspelldef.push(315)
	def spell_315(target)
		fput "release" unless prepped? =~ /None|Remove Curse/i
		unless mana?(15)
			respond "TOO LOW TO CAST"
			return
		end
		gcast(315, target)
	end
end
if Spells.cleric >= 16 and Char.level >= 16
	$myspelldef.push(316)
	def spell_316(target = false)
		fput("release") unless(checkprep =~ /None|Censure/i)
		unless mana?(16)
			respond "TOO LOW TO CAST"
			return
		end
		gcast(316)
	end
end
if Spells.cleric >= 17 and Char.level >= 17
	$myspelldef.push(317)
	def spell_317(target = false)
		fput("release") unless(checkprep =~ /None|Divine Fury/i)
		unless mana?(17)
			respond "TOO LOW TO CAST"
			return
		end
		gcant(317, target)
	end
end
if Spells.cleric >= 18 and Char.level >= 18
	$myspelldef.push(318)
	def spell_318(target = GameObj.pcs.find{|pc| pc.status =~ /dead/i}.id)
		fput("release") unless prepped? =~ /Raise Dead|None/i
		if Spells.cleric < 25
			unless mana?(18)
				respond "TOO LOW TO CAST"
				return
			end
		elsif Spells.cleric < 40
			unless mana?(25)
				respond "TOO LOW TO CAST"
				return
			end
		else
			unless mana?(40)
			respond "TOO LOW TO CAST"
			return
		end
		end
		gcant(318, target)
	end
end
if Spells.cleric >= 19 and Char.level >= 19
	$myspelldef.push(319)
	def spell_319(target = false)
		fput("release") unless(checkprep =~ /None|Divine Wrath/i)
		unless mana?(19)
			respond "TOO LOW TO CAST"
			return
		end
		gcast(319)
	end
end
if Spells.cleric >= 20 and Char.level >= 20
	$myspelldef.push(320)
	def spell_320(target = false)
		fput "release" unless prepped? =~ /none/i
		unless mana?(20)
			respond "TOO LOW TO CAST"
			return
		end
		echo "YOU DIPSHIT, THREE TWENTY IS NOT IMPLEMENTED"
	end
end
if Spells.cleric >= 25 and Char.level >= 25
	$myspelldef.push(325)
	def spell_325(target = GameObj.right_hand.id)
		if Char.slblessings >= 10 && Char.slreligion >= 30
			echo "TIER 5 AVAILABLE"
		elsif Char.slblessings >= 10 && Char.slreligion >= 25 && Char.slsummoning >= 15
			echo "TIER 4 AVAILABLE"
		elsif Char.slblessings >= 5 && Char.slreligion >= 20 && Char.slsummoning >= 10
			echo "TIER 3 AVAILABLE"
		elsif Char.slblessings >= 5 && Char.slreligion >= 15 && Char.slsummoning >= 5
			echo "TIER 2 AVAILABLE"
		elsif Char.slblessings >= 5 && Char.slreligion >= 10
			echo "TIER 1 AVAILABLE"
		end
		echo "NO CLUE WHAT TO DO WITH THIS SPELL"
	end
end
if Spells.cleric >= 50 and Char.level >= 50
	$myspelldef.push(350)
	def spell_350
		wait_rt
		fput "regenerate" if dead? and mana?(50)
	end
	def regenerate
		wait_rt
		fput "regenerate" if dead? and mana?(50)
	end
end
if Spells.minorelemental >= 1 and Char.level >= 1
	$myspelldef.push(401)
	(250 / eval(Spell[401].duration)).ceil.times{$spellup_array.push(401)} unless Char.prof =~ /wizard/i
	def spell_401(target = false)
		fput "release" unless prepped? =~ /None|#{Spell[401].name}/
		wait_until{checkmana > (eval Spell[401].cost)}
		gcant(401,target)
	end
end
if Spells.minorelemental >= 2 and Char.level >= 2
	$myspelldef.push(402)
	def spell_402
		fput "release" unless prepped? =~ /None|Presence/
		wait_until{checkmana > (eval Spell[402].cost)}
		gcant(402)
	end
end
if Spells.minorelemental >= 3 and Char.level >= 3
	$myspelldef.push(403)
	def spell_403(target = false)
		fput "release" unless prepped? =~ /None|Lock Pick Enhancement/
		wait_until{checkmana > (eval Spell[403].cost)}
		gcant(403, target)
	end
end
if Spells.minorelemental >= 4 and Char.level >= 4
	$myspelldef.push(404)
	def spell_404(target = false)
		fput "release" unless prepped? =~ /None|Disarm Enhancement/
		wait_until{checkmana > (eval Spell[404].cost)}
		gcant(404, target)
	end
end
if Spells.minorelemental >= 5 and Char.level >= 5
	$myspelldef.push(405)
	def spell_405(target = false)
		fput "release" unless prepped? =~ /None|Elemental Detection/
		wait_until{mana? > 5}
		gcant(405, target)
	end
end
if Spells.minorelemental >= 6 and Char.level >= 6
	$myspelldef.push(406)
	(250 / eval(Spell[406].duration)).ceil.times{$spellup_array.push(406)} unless Char.prof =~ /wizard/i
	def spell_406(target = false)
		fput "release" unless prepped? =~ /None|#{Spell[406].name}/
		wait_until{checkmana > (eval Spell[406].cost)}
		gcant(406, target)
	end
end
if Spells.minorelemental >= 7 and Char.level >= 7
	$myspelldef.push(407)
	def spell_407(target = false)
		fput "release" unless prepped? =~ /None|Unlock/i
		wait_until{mana?(7)}
		gcant(407, target)
	end
end
if Spells.minorelemental >= 8 and Char.level >= 8
	$myspelldef.push(408)
	def spell_408(target = false)
		fput "release" unless prepped? =~ /Disarm|None/i
		wait_until{mana?(8)}
		gcant(408, target)
	end
end
if Spells.minorelemental >= 9 and Char.level >= 9
	$myspelldef.push(409)
	def spell_409(target = false)
		fput("release") unless prepped? =~ /None|Elemental Blast/i
		wait_until{mana?(9)}
		gcant(409, target)
	end
end
if Spells.minorelemental >= 10 and Char.level >= 10
	$myspelldef.push(410)
	def spell_410(target = false)
		fput("release") unless prepped? =~ /None|Elemental Wave/i
		wait_until{mana?(10)}
		gcast(410)
	end
end
if Spells.minorelemental >= 11 and Char.level >= 11
	$myspelldef.push(411)
	def spell_411(target)
		fput "release" unless prepped? =~ /None|Elemental Blade/i
		wait_until{mana?(11)}
		gcant(411, target)
	end
end
if Spells.minorelemental >= 12 and Char.level >= 12
	$myspelldef.push(412)
	def spell_412(target = false)
		fput("release") unless prepped? =~ /None|Weapon Deflection/i
		wait_until{mana?(12)}
		gcant(412, target)
	end
end
if Spells.minorelemental >= 13 and Char.level >= 13
	$myspelldef.push(413)
	def spell_413(target = false)
		fput("release") unless prepped? =~ /None|Elemental Saturation/i
		wait_until{mana?(13)}
		gcant(413, target)
	end
end
if Spells.minorelemental >= 14 and Char.level >= 14
	$myspelldef.push(414)
#	(250 / eval(Spell[414].duration)).ceil.times{$spellup_array.push(414)} unless Char.prof =~ /wizard/i
	def spell_414(target = false)
		fput "release" unless prepped? =~ /None|Elemental Defense III/i
		wait_until{mana?(14)}
		gcant(414, target)
	end
end
if Spells.minorelemental >= 15 and Char.level >= 15
	$myspelldef.push(415)
	def spell_415(target = false)
		fput("release") unless prepped? =~ /None|Elemental Strike/i
		wait_until{mana?(15)}
		gcant(415, target)
	end
end
if Spells.minorelemental >= 16 and Char.level >= 16
	$myspelldef.push(416)
	def spell_416(target = false)
		if target
			fput "release" unless prepped? =~ /None|Piercing Gaze/i
			wait_until{mana?(16)}
			gcast(416, target)
		else
			echo "416 requires a target"
		end
	end
end
if Spells.minorelemental >= 17 and Char.level >= 17
	$myspelldef.push(417)
	def spell_417(target = false)
		fput("release") unless prepped? =~ /None|Elemental Dispel/i
		unless mana?(20)
			return
		end
		wait_until{mana?(17)}
		gcant(417, target)
	end
end
if Spells.minorelemental >= 18 and Char.level >= 18
	def spell_418(target = false)
		echo "SPELL 418 IS NOT DEFINED FOR SAFETY REASONS"
	end
end
if Spells.minorelemental >= 19 and Char.level >= 19
	$myspelldef.push(419)
	def spell_419(target = false)
		fput "release" unless prepped? =~ /None|Mass Elemental Defense/i
		wait_until{checkmana > 19}
		gcant(419, target)
	end
end
if Spells.minorelemental >= 20 and Char.level >= 20
	def spell_420(target = false)
		echo "SPELL 420 IS NOT DEFINED, CHECK BACK FOR UPDATES"
	end
end
if Spells.minorelemental >= 25 and Char.level >= 25
	$myspelldef.push(425)
	def spell_425
		fput "release" unless prepped? =~ /None|Elemental Targeting/i
		wait_until{checkmana > (eval Spell[425].cost)}
		gcant(425)
	end
end
if Spells.minorelemental >= 30 and Char.level >= 30
	$myspelldef.push(430)
	def spell_430
		fput "release" unless prepped? =~ /None|Elemental Barrier/i
		wait_until{mana?(30)}
		gcant(430)
	end
end
if Spells.minorelemental >= 35 and Char.level >= 35
	$myspelldef.push(435)
	def spell_435(target = false)
		#don't ask me to do this, do it yourself, I refuse to give you this spell in 1 line, and the template is set
		fput("release") unless prepped? =~ /None|Major Elemental Wave/i
		echo "DEFAULTING TO EWAVE, spell_410"
		spell_410
	end
end
if Spells.majorelemental >= 1 and Char.level >= 1
	$myspelldef.push(501)
	def spell_501(target = false)
		fput("release") unless prepped? =~ /None|Sleep/i
		wait_until{mana?(Char.level / 7)}
		gcant(501, target)
	end
end
if Spells.majorelemental >= 3 and Char.level >= 3
	$myspelldef.push(503)
	(250 / eval(Spell[503].duration)).ceil.times{$spellup_array.push(503)}
	def spell_503(target = false)
		fput "release" unless prepped? =~ /None|Thurfel's Ward/i
		wait_until{checkmana > (eval Spell[503].cost)}
		gcant(503, target)
	end
end
if Spells.majorelemental >= 4 and Char.level >= 4
	$myspelldef.push(504)
	def spell_504(target = false)
		fput("release") unless prepped? =~ /None|Slow/i
		wait_until{mana?(4)}
		gcant(504, target)
	end
end
if Spells.majorelemental >= 5 and Char.level >= 5
	$myspelldef.push(505)
	if Skills.elair >= 20
		$myspelldef.push("505_bolt")
		def spell_505_bolt(target = false)
			fput("release") unless(checkprep =~ /None|Hand of Tonis/i)
			wait_until{mana?(5)}
			bolt(505, target)
		end
	end
	def spell_505(target = false)
		fput("release") unless(checkprep =~ /None|Hand of Tonis/i)
		wait_until{mana?(5)}
		gcant(505, target)
	end
end
if Spells.majorelemental >= 6 and Char.level >= 6
	$myspelldef.push(506)
	def spell_506(target = false)
		fput "release" unless prepped? =~ /None|Haste/i
		wait_until{mana?(6)}
		unless target
			return if Spell[506].active?
		end
		gcant(506, target)
	end
end
if Spells.majorelemental >= 7 and Char.level >= 7
	$myspelldef.push(507)
	def spell_507(target = false)
		fput "release" unless prepped? =~ /None|Elemental Deflection/i
		wait_until{checkmana > (eval Spell[507].cost)}
		gcant(507)
	end
end
if Spells.majorelemental >= 8 and Char.level >= 8
	$myspelldef.push(508)
	def spell_508(target = false)
		fput "release" unless prepped? =~ /None|Elemental Bias/i
		wait_until{checkmana > (eval Spell[508].cost)}
		gcant(508)
	end
end
if Spells.majorelemental >= 9 and Char.level >= 9
	$myspelldef.push(509)
	(250 / eval(Spell[509].duration)).ceil.times{$spellup_array.push(509)}
	def spell_509(target = false)
		fput "release" unless prepped? =~ /None|Strength/i
		wait_until{checkmana > (eval Spell[509].cost)}
		gcant(509, target)
	end
end
if Spells.majorelemental >= 10 and Char.level >= 10
	$myspelldef.push(510)
	def spell_510(target = false)
		fput("release") unless prepped? =~ /None|Hurl Boulder/i
		wait_until{mana?(10)}
		bolt(510, target)
	end
end
if Spells.majorelemental >= 11 && Char.level >= 11
	$myspelldef.push(511)
	def spell_511(target = Char.name)
		fput "release" unless prepped? =~ /None|Floating Disk/i
		wait_until{mana?(11)}
		gcast(511, target)
	end
## DISK ENTIRE ROOM ##
	def disk_room
		GameObj.pcs.each{|pc|
			spell_511(pc.id) unless GameObj.loot.find{|disk| disk.name =~ /#{pc.noun}/}
		}
		spell_511 unless GameObj.loot.find{|disk| disk.name =~ /#{Char.name}/}
		fput "release" unless prepped? =~ /none/i
	end
end
if Spells.majorelemental >= 12 and Char.level >= 12
	$myspelldef.push(512)
	def spell_512(target = false)
		fput("release") unless prepped? =~ /None|Ice Patch/i
		wait_until{mana?(12)}
		if Skills.elwater < 10
			$watercount = 1
		elsif Skills.elwater < 20
			$watercount = 2
		elsif Skills.elwater < 31
			$watercount = 3
		elsif Skills.elwater < 43
			$watercount = 4
		elsif Skills.elwater < 56
			$watercount = 5
		elsif Skills.elwater < 70
			$watercount = 6
		elsif Skills.elwater < 85
			$watercount = 7
		elsif Skills.elwater < 101
			$watercount = 8
		elsif Skills.elwater < 118
			$watercount = 9
		elsif Skills.elwater < 136
			$watercount = 10
		elsif Skills.elwater < 155
			$watercount = 11
		elsif Skills.elwater < 175
			$watercount = 12
		elsif Skills.elwater < 196
			$watercount = 13
		else
			$watercount = 0
		end
		if $watercount == 0
			gcant(512, target)
		elsif $watercount < 4
			gcant(512, target)
			$watercount.times{spell_903(target)}
		elsif $watercount >= 4
			gcant(512, target)
			spell_515 unless checkspell(515)
			$watercount.times{spell_903(target)}
		end
	end
end
if Spells.majorelemental >= 13 and Char.level >= 13
	$myspelldef.push(513)
	def spell_513(target = false)
		fput "release" unless prepped? =~ /None|Elemental Focus/i
		wait_until{checkmana > (eval Spell[513].cost)}
		gcant(513)
	end
end
if Spells.majorelemental >= 14 and Char.level >= 14
	$myspelldef.push(514)
	def spell_514(target = false)
		fput "release" unless prepped? =~ /None|Stone Fist/i
		wait_until{mana?(14)}
		gcant(514, target)
		#wait_rt
		#wave, 2 mana
		#push, 2 mana, BREAK
		#throw, 3 mana, BREAK
		#slap, 4 mana, BREAK
		#clench, 6 mana
		#pound, 8 mana
	end
end
if Spells.majorelemental >= 15 and Char.level >= 15
	$myspelldef.push(515)
	def spell_515(target = false)
		fput "release" unless prepped? =~ /Rapid Fire|None/i
		wait_until{mana?(15)}
		gcant(515, target)
	end
end
if Spells.majorelemental >= 16 and Char.level >= 16
	$myspelldef.push(516)
	def spell_516(target)
		fput "release" unless prepped? =~ /None|Mana Leech/i
		if mana? >= 16
		elsif mana? >= 1
			gcant(516, ($id))
			return
		else
			respond "YOU HAVE LOW MANA"
			return(false)
		end
		wait_until("You are below 8 mana"){mana?(8)}
		gcant(516, target)
	end
end
#SPELL 517 (Charge Item) intentionally skipped
if Spells.majorelemental >= 18 and Char.level >= 18
	$myspelldef.push(518)
	def spell_518(target = false)
		fput "release" unless prepped? =~ /None|Cone of Lightning/i
		wait_until{mana?(18)}
		bolt(518, target)
	end
end
if Spells.majorelemental >= 19 and Char.level >= 19
	$myspelldef.push(519)
	def spell_519(target = false)
		fput "release" unless prepped? =~ /None|Immolation/i
		wait_until{mana?(19)}
		gcant(519, target)
	end
end
if Spells.majorelemental >= 20 and Char.level >= 20
	$myspelldef.push(520)
	def spell_520
		fput "release" unless prepped? =~ /None|Stone Skin/i
		wait_until{checkmana > (eval Spell[520].cost)}
		gcant(520)
	end
end
if Spells.majorelemental >= 25 and Char.level >= 25
	def spell_525(target = false)
	echo "Yea, I thought better about putting this into a method"
	end
end
if Spells.majorelemental >= 30 and Char.level >= 30
	$myspelldef.push(530)
	def spell_530(target = false)
		fput "release" unless prepped? =~ /None|Elemental Disjunction/i
		wait_until{mana?(30)}
		gcant(530, target)
	end
end
if Spells.majorelemental >= 40 && Char.level >= 40
	$myspelldef.push(540)
	def spell_540
		fput "release" unless prepped? =~ /None|#{Spell[540].name}/i
		wait_until{mana?(3)}
		gcant(540)
	end
end
if Spells.ranger >= 1 && Char.level >= 1
	$myspelldef.push(601)
	def spell_601
		fput "release" unless prepped? =~ /None|#{Spell[601].name}/i
		wait_until{checkmana > (eval Spell[601].cost)}
		gcant(601)
	end
end
if Spells.ranger >= 2 && Char.level >= 2
	$myspelldef.push(602)
	def spell_602(target = false)
		fput "release" unless prepped? =~ /None|#{Spell[602].name}/i
		wait_until{checkmana > (eval Spell[602].cost)}
		gcant(602, target)
	end
end
if Spells.ranger >= 3 && Char.level >= 3
	$myspelldef.push(603)
	def spell_603
		fput "release" unless prepped? =~ /None|#{Spell[603].name}/i
		wait_until{mana?(3)}
		gcant(603)
	end
end
if Spells.ranger >= 4 && Char.level >= 4
	$myspelldef.push(604)
	def spell_604
		fput "release" unless prepped? =~ /None|#{Spell[604].name}/i
		wait_until{mana?(4)}
		gcant(604)
	end
end
if Spells.ranger >= 5 && Char.level >= 5
	$myspelldef.push(605)
	def spell_605(target = false)
		fput "release" unless prepped? =~ /None|#{Spell[605].name}/i
		wait_until{mana?(5)}
		gcant(605, target)
	end
end
if Spells.ranger >= 6 && Char.level >= 6
	$myspelldef.push(606)
	def spell_606
		fput "release" unless prepped? =~ /None|#{Spell[606].name}/i
		wait_until{mana?(6)}
		gcant(606)
	end
end
if Spells.ranger >= 7 && Char.level >= 7
	$myspelldef.push(607)
	def spell_607(target)
		fput "release" unless prepped? =~ /None|Sounds/
		wait_until{mana?(7)}
		gcant(607, target)
	end
end
if Spells.ranger >= 8 && Char.level >= 8
	$myspelldef.push(608)
	def spell_608
		fput "release" unless prepped? =~ /None|Camouflage/
		wait_until{mana?(8)}
		gcant(608)
	end
end
if Spells.ranger >= 9 && Char.level >= 9
	$myspelldef.push(609)
	def spell_609
		fput "release" unless prepped? =~ /None|Sun Burst/
		wait_until{mana?(9)}
		gcant(609)
	end
end
if Spells.ranger >= 10 && Char.level >= 10
	$myspelldef.push(610)
	def spell_610(target = false)
		fput "release" unless prepped? =~ /None|Tangleweed/
		wait_until{mana?(10)}
		gcant(610, target)
	end
end
if Spells.ranger >= 11 && Char.level >= 11
	$myspelldef.push(611)
	def spell_611
		fput "release" unless prepped? =~ /None|Mass Colors/
		wait_until{mana?(11)}
		gcant(611, target)
	end
end
if Spells.ranger >= 12 && Char.level >= 12
	$myspelldef.push(612)
	def spell_612
		fput "release" unless prepped? =~ /None|Breeze/
		wait_until{mana?(12)}
		gcast(612, target)
	end
end
if Spells.ranger >= 13 && Char.level >= 13
	$myspelldef.push(613)
	def spell_613
		fput "release" unless prepped? =~ /None|#{Spell[613].name}/i
		wait_until{mana?(13)}
		gcant(613)
	end
end
if Spells.ranger >= 14 && Char.level >= 14
	$myspelldef.push(614)
	def spell_614(target)
		fput "release" unless prepped? =~ /None|Imbue/
		wait_until{mana?(14)}
		gcant(614, target)
	end
end
if Spells.ranger >= 15 && Char.level >= 15
	$myspelldef.push(615)
	def spell_615(target)
		fput "release" unless prepped? =~ /None|Call Swarm/
		wait_until{mana?(15)}
		gcant(615, target)
	end
end
if Spells.ranger >= 16 && Char.level >= 16
	$myspelldef.push(616)
	def spell_616(target)
		wait_until{mana?(16)}
		fput "release" unless prepped? =~ /None|Spike Thorn/
		gcant(616, target)
	end
end
if Spells.ranger >= 17 && Char.level >= 17
	$myspelldef.push(617)
	def spell_617
		fput "release" unless prepped? =~ /None|#{Spell[617].name}/i
		wait_until{mana?(17)}
		gcant(617)
	end
end
if Spells.ranger >= 18 && Char.level >= 18
	$myspelldef.push(618)
	(250 / eval(Spell[618].duration)).ceil.times{$spellup_array.push(618)}
	def spell_618(target = false)
		fput "release" unless prepped? =~ /None|#{Spell[618].name}/i
		wait_until{mana?(eval(Spell[618].cost))}
		gcant(618, target)
	end
end
if Spells.ranger >= 19 && Char.level >= 19
	$myspelldef.push(619)
	def spell_619
		fput "release" unless prepped? =~ /None|Mass Calm/
		wait_until{mana?(19)}
		gcast(619)
	end
end
if Spells.ranger >= 25 && Char.level >= 25
	$myspelldef.push(625)
	def spell_625
		fput "release" unless prepped? =~ /Nature's Touch|None/
		wait_until{mana?(25)}
		gcast(625)
	end
end
if Spells.ranger >= 35 && Char.level >= 35
	$myspelldef.push(635)
	def spell_635
		fput "release" unless prepped? =~ /Nature's Fury|None/
		wait_until{mana?(35)}
		gcant(635)
	end
end
if Spells.ranger >= 40 && Char.level >= 40
	$myspelldef.push(640)
	def spell_640
		fput "release" unless prepped? =~ /None|Wall of Thorns/
		wait_until{mana?(40)}
		gcant(640)
	end
end
if Spells.sorcerer >= 1 and Char.level >= 1
	$myspelldef.push(701)
	def spell_701(target = false)
		fput "release" unless prepped? =~ /None|Blood Burst/i
		wait_until{mana?(1)}
		gcant(701, target)
	end
end
if Spells.sorcerer >= 2 and Char.level >= 2
	$myspelldef.push(702)
	def spell_702(target = false)
		fput("release") unless prepped? =~ /none|Mana Disruption/i
		unless mana?(2)
			respond "NOT ENOUGH MANA"
			return
		end
		gcant(702, target)
	end
end
if Spells.sorcerer >= 3 and Char.level >= 3
	$myspelldef.push(703)
	def spell_703(target = false)
		fput "release" unless prepped? =~ /None|Corrupt Essence/i
		wait_until{mana?(3)}
		gcant(703, target)
	end
	def spell_703f(target = false)
		$fcorr = false
		fput "release" unless prepped? =~ /None|Corrupt Essence/i
		return unless mana?(3)
		wait_until{checkmana(3)}
		return if gwound
		return if $corrupted.include?(target) || gnpcs(target).status =~ /stun|web|bind|immob|sympath|paraly|sleep/
		gcant(703, target)
		x = false
		x = matchtimeout(2, "blood red haze surrounding|suddenly surrounded by a blood red haze|blood red haze eddies and swirls|fumble|Spell Hindrance for")
		if x =~ /suddenly surrounded by a blood red haze|blood red haze surrounding/i
			$fcorr = true
			return
		elsif x =~ /Spell Hindrance for|Nothing happens|wait|blood red haze eddies and swirls/i
			return(spell_703f(target))
		end
	end
end
if Spells.sorcerer >= 4 and Char.level >= 4
	$myspelldef.push(704)
	def spell_704(target = false)
		$phased = false
		fput("release") unless(checkprep =~ /None|Phase/i)
		wait_until{checkmana(4)}
		gcant(704, target)
		phased = matchwait("Cast at what", "vanishes into nothingness with a hollow laugh", "Spell Hindrance for","becomes momentarily insubstantial and appears lighter\.","resists the effects of your magic!","becomes momentarily insubstantial but quickly returns to normal\.","Nothing happens\.", "ward")
		if phased =~ /becomes momentarily insubstantial and appears lighter\./
			$phased = true
		elsif phased =~ /Spell Hindrance for|Nothing happens/
			spell_704(target)
		else
		end
	end
end
if Spells.sorcerer >= 5 and Char.level >= 5
	$myspelldef.push(705)
	def spell_705(target = false)
		fput("release") unless prepped? =~ /none|Disintegrate/i
		wait_until{mana?(5)}
		gcant(705, target)
	end
end
if Spells.sorcerer >= 6 and Char.level >= 6
	$myspelldef.push(706)
	def spell_706(target = false)
		fput "release" unless prepped? =~ /None|Mind Jolt/i
		wait_until{mana?(6)}
		gcant(706, target)
	end
end
#707, eye spy, intentionally missing
if Spells.sorcerer >= 8 and Char.level >= 8
	$myspelldef.push(708)
	def spell_708(target = false)
		fput "release" unless prepped? =~ /None|Limb Disruption/i
		wait_until{mana?(8)}
		gcant(708, target)
	end
end
if Spells.sorcerer >= 9 and Char.level >= 9
	$myspelldef.push(709)
	def spell_709
		fput("release") unless prepped? =~ /None|Quake/i
		wait_until{mana?(9)}
		gcast(709)
	end
end
if Spells.sorcerer >= 10 and Char.level >= 10
	$myspelldef.push(710)
	def spell_710(target = false)
		fput("release") unless prepped? =~ /None|Maelstrom/i
		wait_until{mana?(10)}
		gcast(710, target)
	end
end
if Spells.sorcerer >= 11 and Char.level >= 11
	$myspelldef.push(711)
	def spell_711(target = false)
		fput("release") unless prepped? =~ /None|Pain/i
		wait_until{mana?(11)}
		gcant(711, target)
	end
end
if Spells.sorcerer >= 12 and Char.level >= 12
	$myspelldef.push(712)
	def spell_712(spell = 705)
		fput "release" unless prepped? =~ /None|Cloak of Shadows/i
		wait_until{checkmana > (eval Spell[712].cost)}
		gcant(712)
		fput "chant retribution #{spell}"
	end
end
if Spells.sorcerer >= 13 and Char.level >= 13
	$myspelldef.push(713)
	def spell_713(target = false)
		fput("release") unless prepped? =~ /None|Nightmare/i
		wait_until{mana?(13)}
		gcant(713, target)
	end
end
### SCROLL INFUSION (714) EXCLUDED INTENTIONALLY
if Spells.sorcerer >= 15 and Char.level >= 15
	$myspelldef.push(715)
	def spell_715(target = false)
		fput("release") unless prepped? =~ /None|Curse/i
		wait_until{mana?(15)}
		fput "stance guard"
		gcant(715, target)
	end
end
if Spells.sorcerer >= 16 and Char.level >= 16
	$myspelldef.push(716)
	def spell_716(target = false)
		fput("release") unless prepped? =~ /None|Disease/i
		wait_until{mana?(16)}
		gcant(716, target)
	end
end
if Spells.sorcerer >= 17 and Char.level >= 17
	$myspelldef.push(717)
	def spell_717(target = false)
		fput("release") unless prepped? =~ /None|Evil Eye/i
		wait_until{mana?(17)}
		gcant(717, target)
	end
end
if Spells.sorcerer >= 18 and Char.level >= 18
	$myspelldef.push(718)
	def spell_718(target = false)
		fput("release") unless prepped? =~ /None|Torment/i
		wait_until{mana?(18)}
		gcant(718, target)
	end
end
if Spells.sorcerer >= 19 and Char.level >= 19
	$myspelldef.push(719)
	def spell_719(target = false)
		fput("release") unless prepped? =~ /None|Dark Catalyst/i
		wait_until{mana?(19)}
		gcant(719, target)
	end
end
if Spells.sorcerer >= 20 and Char.level >= 20
	$myspelldef.push(720)
	def spell_720(target = false)
		fput("release") unless prepped? =~ /None|Implosion/i
		wait_until{mana?(20)}
		gcast(720, target)
	end
end
if Spells.wizard >= 1 and Char.level >= 1
	$myspelldef.push(901)
	def spell_901(target = false)
		fput("release") unless(checkprep =~ /None|Minor Shock/i)
		wait_until{mana?(1)}
		bolt(901, target)
	end
end
if Spells.wizard >= 2 and Char.level >= 2
	$myspelldef.push(902)
	def spell_902(target)
		fput "release" unless prepped? =~ /None|Minor elemental edge/i
		wait_until{mana?(2)}
		gcast(902, target)
	end
end
if Spells.wizard >= 3 and Char.level >= 3
	$myspelldef.push(903)
	def spell_903(target = false)
		fput("release") unless(checkprep =~ /None|Minor Water/i)
		wait_until{mana?(3)}
		bolt(903, target)
	end
end
if Spells.wizard >= 4 and Char.level >= 4
	$myspelldef.push(904)
	def spell_904(target = false)
		fput("release") unless(checkprep =~ /None|Minor Acid/i)
		wait_until{mana?(4)}
		bolt(904, target)
	end
end
if Spells.wizard >= 5 and Char.level >= 5
	$myspelldef.push(905)
	def spell_905
		fput "release" unless prepped? =~ /None|Prismatic Guard/i
		wait_until{checkmana > (eval Spell[905].cost)}
		gcant(905)
	end
end
if Spells.wizard >= 6 and Char.level >= 6
	$myspelldef.push(906)
	def spell_906(target = false)
		fput("release") unless(checkprep =~ /None|Minor Fire/i)
		wait_until{mana?(6)}
		bolt(906, target)
	end
end
if Spells.wizard >= 7 and Char.level >= 7
	$myspelldef.push(907)
	def spell_907(target = false)
		fput("release") unless(checkprep =~ /None|Major Cold/i)
		wait_until{mana?(7)}
		bolt(907, target)
	end
end
if Spells.wizard >= 8 and Char.level >= 8
	$myspelldef.push(908)
	def spell_908(target = false)
		fput("release") unless(checkprep =~ /None|Major Fire/i)
		wait_until{mana?(8)}
		bolt(908, target)
	end
end
if Spells.wizard >= 9 and Char.level >= 9
	$myspelldef.push(909)
	def spell_909
		fput("release") unless prepped? =~ /None|Tremors/i
		wait_until{mana?(9)}
		gcast(909)
		$tremmors = true
	end
end
if Spells.wizard >= 10 and Char.level >= 10
	$myspelldef.push(910)
	def spell_910(target = false)
		fput("release") unless(checkprep =~ /None|Major Shock/i)
		wait_until{mana?(10)}
		bolt(910, target)
	end
end
if Spells.wizard >= 11 and Char.level >= 11
	$myspelldef.push(911)
	def spell_911(target = false)
		fput "release" unless prepped? =~ /None|Mass Blur/i
		wait_until{checkmana > (eval Spell[911].cost)}
		gcant(911, target)
	end
end
if Spells.wizard >= 12 and Char.level >= 12
	$myspelldef.push(912)
	def spell_912(target = false)
		fput("release") unless(checkprep =~ /None|Call Wind/i)
		wait_until{mana?(12)}
		gcast(912, target)
	end
end
if Spells.wizard >= 13 and Char.level >= 13
	$myspelldef.push(913)
	def spell_913
		fput "release" unless prepped? =~ /None|Melgorehn's Aura/i
		wait_until{checkmana > (eval Spell[913].cost)}
		gcant(913)
	end
end
if Spells.wizard >= 14 and Char.level >= 14
	$myspelldef.push(914)
	def spell_914(target = false)
		fput("release") unless prepped? =~ /None|Sandstorm/i
		wait_until{mana?(14)}
		gcant(914, target)
	end
end
if Spells.wizard >= 15 and Char.level >= 15
	$myspelldef.push(915)
	def spell_915(target = false)
		fput("release") unless prepped? =~ /None|Weapon Fire/i
		wait_until{mana?(15)}
		gcant(915, target)
	end
end
if Spells.wizard >= 16 and Char.level >= 16
	$myspelldef.push(916)
	def spell_916
		fput "release" unless prepped? =~ /None|Invisibility/i
		wait_until{checkmana > (eval Spell[916].cost)}
		gcant(916)
	end
	def keep_916
		wait_while{Spell[916].active?}
		sleep 3
		if GameObj.pcs.find{|pc| pc.noun !~ /#{$my_group.join('|')}/}
			spell_916
		else
			wait_until("INVISIBILITY DROPPED, Waiting for a reason to cast it."){GameObj.pcs.find{|pc| pc.noun !~ /#{$my_group.join('|')}/} || GameObj.loot.find{|disk| disk.noun =~ /coffin|disk/ && disk.name !~ /#{$my_group.join('|')}/}}
			spell_916
		end

		return keep_916
	end
end
if Spells.wizard >= 17 and Char.level >= 17
	$myspelldef.push(917)
	def spell_917(target = false)
		fput("release") unless prepped? =~ /None|Boil Earth/i
		wait_until{mana?(17)}
		gcant(917, target)
	end
end
if Spells.wizard >= 19 and Char.level >= 19
	$myspelldef.push(919)
	def spell_919
		fput "release" unless prepped? =~ /None|Wizard's Shield/i
		wait_until{checkmana > (eval Spell[919].cost)}
		gcant(919)
	end
end
if Spells.wizard >= 20 and Char.level >= 20
	$myspelldef.push(920)
	echo "I haven't accounted for the familiar ID# in this method as I have for spirit servant, perhaps the next update"
	def spell_920
		fput "release" unless prepped? =~ /None|Call Familiar/i
		wait_until{checkmana > 20}
		gcast(920)
	end
end
if Spells.bard >= 1 and Char.level >= 1
	$myspelldef.push(1001)
	def spell_1001(target = false)
		fput "release" unless prepped? =~ /Holding Song|None/i
		wait_until{mana?(1)}
		renew(1001, target)
	end
end
if Spells.bard >= 2 and Char.level >= 2
	$myspelldef.push(1002)
	def spell_1002(target = false)
		fput "release" unless prepped? =~ /None|Vibration Chant/i
		wait_until{mana?(2)}
		sing(1002, target)
	end
end
if Spells.bard >= 3 and Char.level >= 3
	$myspelldef.push(1003)
	def spell_1003
		fput "release" unless prepped? =~ /None/i
		wait_until{checkmana > (eval Spell[1003].cost)}
		sing(1003)
	end
end
if Spells.bard >= 4 and Char.level >= 4
	$myspelldef.push(1004)
	def spell_1004(target = GameObj.right_hand.id)
		fput "release" unless prepped? =~ /Purification Song|None/
		wait_until{mana?(4)}
		sing(1004, target)
	end
end
if Spells.bard >= 5 and Char.level >= 5
	$myspelldef.push(1005)
	def spell_1005(target = false)
		fput "release" unless prepped? =~ /None|Lullabye/i
		wait_until{mana?(5)}
		sing(1005, target)
	end
end
if Spells.bard >= 6 and Char.level >= 6
	$myspelldef.push(1006)
	def spell_1006
		fput "release" unless prepped? =~ /None|Song of Luck/i
		wait_until{checkmana > (eval Spell[1006].cost)}
		sing(1006)
	end
end
if Spells.bard >= 7 and Char.level >= 7
	$myspelldef.push(1007)
	def spell_1007
		fput "release" unless prepped? =~ /None|Kai's Triumph Song/i
		wait_until{checkmana > (eval Spell[1007].cost)}
		sing(1007)
	end
end
if Spells.bard >= 8 and Char.level >= 8
	$myspelldef.push(1008)
	def spell_1008(target = false)
		fput "release" unless prepped? =~ /None|Stunning Shout/i
		wait_until{mana?(8)}
		sing(1008, target)
	end
end
if Spells.bard >= 9 and Char.level >= 9
	$myspelldef.push(1009)
	def spell_1009(target = "mantlet")
		fput "release" unless prepped? =~ /None|#{Spell[1009].name}/
		wait_until{checkmana > (eval(Spell[1009].cost))}
		fput "stow left" unless GameObj.left_hand.noun =~ /shield|buckler|targe|parma|aegis|scutum|greatshield|mantlet|pavis/ || GameObj.left_hand.name == 'Empty'
		sing(1009, target)
	end
end
if Spells.bard >= 10 and Char.level >= 10
	$myspelldef.push(1010)
	def spell_1010
		fput "release" unless prepped? =~ /None|Song of Valor/i
		wait_until{checkmana > (eval Spell[1010].cost)}
		sing(1010)
	end
end
if Spells.bard >= 11 and Char.level >= 11
	$myspelldef.push(1011)
	def spell_1011
		fput "release" unless prepped? =~ /None|Song of Peace/i
		wait_until{checkmana > (eval Spell[1011].cost)}
		sing(1011)
	end
end
if Spells.bard >= 12 and Char.level >= 12
	$myspelldef.push(1012)
	def spell_1012(target = "short")
		fput "release" unless prepped? =~ /None|Sonic Weapon Song/i
		wait_until{mana?(12)}
		sing(1012, target)
	end
end
if Spells.bard >= 13 and Char.level >= 13
	$myspelldef.push(1013)
	def spell_1013(target = false)
		fput "release" unless prepped? =~ /None|Song of Unravelling/i
		wait_until{mana?(13)}
		renew(1013, target)
	end
end
if Spells.bard >= 14 and Char.level >= 14
	$myspelldef.push(1014)
	def spell_1014(target = 12)
		fput "release" unless prepped? =~ /None|Sonic Armor/i
		wait_until{mana?(14)}
		sing(1014, target)
	end
end
if Spells.bard >= 15 and Char.level >= 15
	$myspelldef.push(1015)
	def spell_1015(target = false)
		fput "release" unless prepped? =~ /None|Song of Depression/i
		wait_until{mana?(15)}
		renew(1015, target)
	end
end
if Spells.bard >= 16 and Char.level >= 16
	$myspelldef.push(1016)
	def spell_1016(target = false)
		fput "release" unless prepped? =~ /None|Song of Rage/i
		wait_until{mana?(16)}
		renew(1016, target)
	end
end
if Spells.bard >= 17 and Char.level >= 17
	$myspelldef.push(1017)
	def spell_1017
		fput "release" unless prepped? =~ /None|Song of Noise/i
		wait_until{checkmana > (eval Spell[1017].cost)}
		renew(1017)
	end
end
if Spells.bard >= 18 and Char.level >= 18
	$myspelldef.push(1018)
	def spell_1018
		fput "release" unless prepped? =~ /None|Song of Power/i
		wait_until{checkmana > (eval Spell[1018].cost)}
		fput "stop 1018" if running?(1018)
		sing(1018)
	end
end
if Spells.bard >= 19 and Char.level >= 19
	$myspelldef.push(1019)
	def spell_1019
		fput "release" unless prepped? =~ /None|Song of Mirrors/i
		wait_until{checkmana > (eval Spell[1019].cost)}
		sing(1019)
	end
end
if Spells.bard >= 25 and Char.level >= 25
	$myspelldef.push(1025)
	def spell_1025(target = false)
		fput "release" unless prepped? =~ /None/i
		wait_until{checkmana(25)}
		sing(1025, target)
	end
end
if Spells.bard >= 30 and Char.level >= 30
	$myspelldef.push(1030)
	def spell_1030(target = false)
		fput "release" unless prepped? =~ /None|Sonic Disruption/i
		wait_until{mana?(30)}
		if Skills.mlmanipulation >= 15
			sing(1030, target)
		else
			renew(1030, target)
		end
	end
end
if Spells.bard >= 35 and Char.level >= 35
	$myspelldef.push(1035)
	def spell_1035
		fput "release" unless prepped? =~ /None|Song of Tonis/i
		wait_until{mana?(35)}
		sing(1035)
	end
end
if Spells.empath >= 1 and Char.level >= 1
	$myspelldef.push(1101)
	def spell_1101(target = false)
		fput("release") unless(checkprep =~ /None|Heal/i)
		wait_until{mana?(1)}
		gcant(1101, target, true)
	end
end
if Spells.empath >= 6 and Char.level >= 6
	$myspelldef.push(1106)
	def spell_1106(target = false)
		fput("release") unless(checkprep =~ /None|Bone Shatter/i)
		wait_until{mana?(6)}
		gcant(1106, target, true)
	end
end
if Spells.empath >= 7 and Char.level >= 7
	$myspelldef.push(1107)
	def spell_1107(target = false)
		fput("release") unless(checkprep =~ /None|Adrenal Surge/i)
		wait_until{mana?(7)}
		gcant(1107, target, true)
	end
end
if Spells.empath >= 8 and Char.level >= 8
	$myspelldef.push(1108)
	def spell_1108(target = false)
		fput("release") unless(checkprep =~ /None|Empathy/i)
		wait_until{mana?(8)}
		gcant(1108, target, true)
	end
end
if Spells.empath >= 9 and Char.level >= 9
	$myspelldef.push(1109)
	def spell_1109
		fput "release" unless prepped? =~ /None|Empathic Focus/i
		wait_until{checkmana > (eval Spell[1109].cost)}
		gcant(1109, false, true)
	end
end
if Skills.spellaiming >= Char.level
	if Spells.empath >= 10 and Char.level >= 10
		$myspelldef.push(1110)
		def spell_1110(target = false)
			fput("release") unless(checkprep =~ /None|Empathic Assault/i)
			wait_until{mana?(10)}
			bolt(1110, target, true)
		end
	end
end
if Spells.empath >= 15 and Char.level >= 15
	$myspelldef.push(1115)
	def spell_1115(target = false)
		fput("release") unless(checkprep =~ /None|Wither/i)
		wait_until{mana?(15)}
		gcant(1115, target, true)
	end
end
if Spells.empath >= 16 and Char.level >= 16
	$myspelldef.push(1116)
	def spell_1116(target)
		fput "release" unless prepped? =~ /None|Cry For Help/i
		wait_until{mana?(16)}
		gcant(1116, target, true)
	end
end
if Spells.empath >= 17 and Char.level >= 17
	$myspelldef.push(1117)
	def spell_1117(target = false)
		fput("release") unless(checkprep =~ /None|Empathic Link/i)
		wait_until{mana?(17)}
		gcant(1117, target, true)
	end
end
if Spells.empath >= 19 and Char.level >= 19
	$myspelldef.push(1119)
	def spell_1119
		fput "release" unless prepped? =~ /None|Strength of Will/i
		wait_until{checkmana > (eval Spell[1119].cost)}
		gcant(1119, false, true)
	end
end
if Spells.empath >= 20 and Char.level >= 20
	$myspelldef.push(1120)
	def spell_1120
		fput("release") unless(checkprep =~ /None|Sympathy/i)
		wait_until{mana?(20)}
		gcast(1120, false, true)
	end
end
if Spells.empath >= 25 and Char.level >= 25
	$myspelldef.push(1125)
	def spell_1125
		fput "release" unless prepped? =~ /None|Troll's Blood/i
		wait_until{checkmana > (eval Spell[1125].cost)}
		gcant(1125, false, true)
	end
end
if Spells.empath >= 30 and Char.level >= 30
	$myspelldef.push(1130)
	def spell_1130
		fput "release" unless prepped? =~ /None|Intensity/i
		wait_until{checkmana > (eval Spell[1130].cost)}
		gcant(1130, false, true)
	end
end
if Spells.empath >= 50 and Char.level >= 50
	$myspelldef.push(1150)
	def spell_1150
		fput("release") unless(checkprep =~ /None|Regeneration/i)
		if mana?(1)
			wait_rt;fput("regenerate");sleep 0.15
		end
	end
end
#################### FUCKING PALADINS ######################
####### BY POPULAR DEMAND, YES, PALADINS !! ###############

if Spells.paladin >= 1 && Char.level >= 1
	$myspelldef.push(1601)
	def spell_1601(target = false)
		fput "release" unless checkprep =~ /None|#{Spell[1601].name}/
		wait_until{mana?(eval(Spell[1601].cost))}
		gcant(1601, target)
	end
end
if Spells.paladin >= 2 && Char.level >= 2
	$myspelldef.push(1602)
	def spell_1602(target = false)
		fput "release" unless checkprep =~ /None|Pious Trial/
		wait_until{mana?(2)}
		gcant(1602, target)
	end
end
if Spells.paladin >= 3 && Char.level >= 3
	$myspelldef.push(1603)
	def spell_1603(target = false)
		fput "release" unless checkprep =~ /None|#{Spell[1603].name}/
		wait_until{mana?(3)}
		gcant(1603, target)
	end
end
if Spells.paladin >= 4 && Char.level >= 4
	$myspelldef.push(1604)
	def spell_1604(target)
		fput "release" unless checkprep =~ /None|Purify/
		wait_until{mana?(4)}
		gcant(1604, target)
	end
end
if Spells.paladin >= 5 && Char.level >= 5
	$myspelldef.push(1605)
	def spell_1605(target = false)
		fput "release" unless checkprep =~ /None|#{Spell[1605].name}/
		wait_until{mana?(eval(Spell[1605].cost))}
		gcant(1605, target)
	end
end
if Spells.paladin >= 6 && Char.level >= 6
	$myspelldef.push(1606)
	def spell_1606
	#selfcast
		fput "release" unless checkprep =~ /None|#{Spell[1606].name}/
		wait_until{mana?(eval(Spell[1606].cost))}
		gcant(1606)
	end
end
if Spells.paladin >= 7 && Char.level >= 7
	$myspelldef.push(1607)
	def spell_1607
	#selfcast
		fput "release" unless checkprep =~ /None|#{Spell[1603].name}/
		wait_until{mana?(20)}
		gcant(1607)
	end
end
if Spells.paladin >= 8 && Char.level >= 8
	$myspelldef.push(1608)
	def spell_1608(target)
#		Utility, like bless/purify
		fput "release" unless checkprep =~ /None|Guiding Light/
		wait_until{mana?(8)}
		gcant(1608, target)
	end
end
if Spells.paladin >= 9 && Char.level >= 9
	$myspelldef.push(1609)
	def spell_1609(target = false)
		#must stop 1617
		fput "stop 1617" if checkspell(1617)
		fput "release" unless checkprep =~ /None|#{Spell[1609].name}/
		wait_until{mana?(9)}
		gcant(1609, target)
	end
end
if Spells.paladin >= 10 && Char.level >= 10
	$myspelldef.push(1610)
	def spell_1610
		fput "release" unless checkprep =~ /None|#{Spell[1610].name}/
		wait_until{mana?(eval(Spell[1610].cost))}
		gcant(1610)
	end
end
if Spells.paladin >= 11 && Char.level >= 11
	$myspelldef.push(1611)
	def spell_1611
		fput "release" unless checkprep =~ /None|#{Spell[1611].name}/
		wait_until{mana?(eval(Spell[1611].cost))}
		gcant(1611)
	end
end
if Spells.paladin >= 12 && Char.level >= 12
	$myspelldef.push(1612)
	def spell_1612
		fput "release" unless checkprep =~ /None|#{Spell[1612].name}/
		wait_until{mana?(12)}
		gcant(1612)
	end
end
if Spells.paladin >= 13 && Char.level >= 13
	$myspelldef.push(1613)
	def spell_1613
		fput "release" unless checkprep =~ /None|#{Spell[1613].name}/
		wait_until{mana?(13)}
		gcant(1613)
	end
end
if Spells.paladin >= 14 && Char.level >= 14
	$myspelldef.push(1614)
	def spell_1614
		### AREA EFFECT SPELL, LIKE, 1015
		fput "release" unless checkprep =~ /None|Aura of the Arkati/
		wait_until{mana?(14)}
		gcast(1614)
	end
end
if Spells.paladin >= 15 && Char.level >= 15
	$myspelldef.push(1615)
	def spell_1615(target)
		#angry spell, should not have a "open cast" of this
		fput "release" unless checkprep =~ /None|Divine Strike/
		wait_until{mana?(15)}
		gcant(1615, target)
	end
end
if Spells.paladin >= 16 && Char.level >= 16
	$myspelldef.push(1616)
	def spell_1616
		#selfcast
		fput "release" unless checkprep =~ /None|#{Spell[1616].name}/
		wait_until{mana?(16)}
		gcant(1616)
	end
end
if Spells.paladin >= 17 && Char.level >= 17
	$myspelldef.push(1617)
	def spell_1617(target = false)
		fput "release" unless checkprep =~ /None|#{Spell[1617].name}/
		wait_until{mana?(17)}
		gcant(1617, target)
	end
end
if Spells.paladin >= 18 && Char.level >= 18
	$myspelldef.push(1618)
	def spell_1618(target = false)
		fput "release" unless checkprep =~ /None|#{Spell[1618].name}/
		wait_until{mana?(18)}
		gcant(1618, target)
	end
end
if Spells.paladin >= 19 && Char.level >= 19
	$myspelldef.push(1619)
	def spell_1619(target = false)
		fput "release" unless checkprep =~ /None|#{Spell[1619].name}/
		wait_until{mana?(19)}
		gcant(1619, target)
	end
end
if Spells.paladin >= 30 && Char.level >= 30
	$myspelldef.push(1630)
	def spell_1630
		fput "release" unless checkprep =~ /None|#{Spell[1630].name}/
		#open AE spell
		wait_until{mana?(30)}
		gcast(1630)
	end
end
if Spells.paladin >= 35 && Char.level >= 35
	$myspelldef.push(1635)
	def spell_1635()
		wait_until{mana?(35)}
		waitrt?
		fput "beseech"
	end
end
### I HAVE MY STARTUP SCRIPTS DAISY CHAINED, IGNORE GENERAL METHODS...
sleep 0.5

#####################################
## Below are some little snippets I've saved over time.
#######################################

def spellup(target = Char.name)
	spellcost = 0
	$spellup_array.each{|spell|
		spellcost += (eval Spell[spell].cost)
	}
	if mana?(spellcost)
		pause_scripts("kspells", "kblood","knewhealbot","signs2","unstun")
		$spellup_array.each{|spell|
			wait_rt
			multifput("prep #{spell}","cast #{target}")
			wait_rt
		}
		unpause_scripts("kspells", "kblood","knewhealbot","signs2","unstun")
	else
		echo "TOO LOW ON MANA"
	end
end
start_echo = false if Char.name =~ /#{$my_group.join('|')}/i
if start_echo && !$first_def_run
respond "***********************************************************"
respond "gibs_spell_defs.lic has loaded the following spell methods:"
respond "***********************************************************"
respond ""
respond "spell_#{$myspelldef.join(', spell_')}"
end

=begin
#elsif (spell = Spell[506]) and !spell.active? and spell.known? and spell.affordable? and ([Wounds.head, Scars.head].max < 2) and ([Wounds.nsys, Scars.nsys].max < 2) and ([Wounds.leftArm, Wounds.leftHand, Wounds.rightArm, Wounds.rightHand, Scars.leftArm, Scars.leftHand, Scars.rightArm, Scars.rightHand].max < 3) and ( ([Wounds.leftArm, Wounds.leftHand, Scars.leftArm, Scars.leftHand].max < 2) or ([Wounds.rightArm, Wounds.rightHand, Scars.leftArm, Scars.leftHand].max < 2) )
=end

$first_def_run = true
#		unless ( [Wounds.head, Scars.head].max < 2) and ([Wounds.nsys, Scars.nsys].max < 2) and ([Wounds.leftArm, Wounds.leftHand, Wounds.rightArm, Wounds.rightHand, Scars.leftArm, Scars.leftHand, Scars.rightArm, Scars.rightHand].max < 3) and ( ([Wounds.leftArm, Wounds.leftHand, Scars.leftArm, Scars.leftHand].max < 2) or ([Wounds.rightArm, Wounds.rightHand, Scars.leftArm, Scars.leftHand].max < 2))
