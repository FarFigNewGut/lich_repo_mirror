=begin
author: Daedeus

=====Recall Enhancives=====

;recall-enhancives
;recall-enhancives verbose    - don't squelch anything

This script will RECALL all of the enhancive items that you are current wearing.
It will create a tabular report of each item and what its benefits are.
It will report the SUM of these benefits in the last row.

version: 1   date: 1/8/2026

=end

# Initialize arrays to store our findings
items_to_recall = []
totals = Hash.new(0)

verbose = variable[0] =~ /verb/

if !verbose
  silence_me
  hook_proc = proc { |s|
  if s =~ /<prompt/
      s
    else
      nil
    end
  }
  DownstreamHook.add('recall_squelch', hook_proc)
  before_dying { DownstreamHook.remove('recall_squelch') }
end

# Start the inventory check
# We use a loop to capture the output of the command
# The command 'inventory enhancive list' lists items.
# We are looking for lines with "(X/Y charges)" as per the comments.

echo "Scanning inventory for loresung enhancive items..."
fput "inventory enhancive list"

while line = get
  # Check for the end of the list or prompt
  if line =~ /For more information|<prompt/
    break
  end

  # Parse lines that contain charge information
  # Example: "  a beryl-inset mithril stickpin (6/16 charges)"
  if line =~ /^\s+(.*?)\s+\((\d+\/\d+) charges\)/
    raw_name = $1
    charges = $2
    name = raw_name.sub(/^(?:a pair of|an|a|)\s+/i, '')
    # Store the name and charge info for later processing
    items_to_recall << { :name => name, :charges => charges }
  end
end

# Prepare a list of game objects to match against (worn items and held items)
# We need to match the names from the list to actual GameObj IDs to use the 'recall' command effectively
inventory_objects = [GameObj.inv, GameObj.right_hand, GameObj.left_hand].compact.flatten


# List to store the final processed data
processed_items = []

# Loop through the items we found in the list and RECALL each of them
items_to_recall.each do |item_info|
  # Find the matching GameObj
  # We look for an object in our inventory that matches the name and hasn't been processed yet
  obj = inventory_objects.find { |o| o.name == item_info[:name] && !processed_items.any? { |p| p[:id] == o.id } }

  if obj
    # Data structure for this item
    item_data = {
      :id => obj.id,
      :name => obj.name,
      :charges => item_info[:charges],
      :crumbly => false,
      :bonuses => []
    }

    # Issue the recall command
    fput "recall ##{obj.id}"

    # Parse the recall output
    # We need to capture lines until we hit a prompt
    while line = get
      break if line =~ /permanently unlocked loresong/

      # Parse bonuses, e.g., "It provides a boost of 4 to Spell Aiming Bonus."
      if line =~ /provides a (?:boost|bonus) of (\d+) to (?:the )?(.*?)\./
        bonus = $1.to_i
        stat = $2.strip
        item_data[:bonuses] << "+#{bonus} #{stat}"
        totals[stat] += bonus
      end

      # Check for crumbly status
      if line =~ /crumble into dust/
        item_data[:crumbly] = true
      end
    end

    processed_items << item_data
    sleep 0.1
  else
    echo "Could not find object for: #{item_info[:name]}"
  end
end

if !verbose
  DownstreamHook.remove('recall_squelch')
end

# Output the Tabular Report
output = "\n"
output += "=" * 40 + "\n"
output += " ENHANCIVE ITEM REPORT\n"
output += "=" * 40 + "\n"

processed_items.each do |item|
  crumbly_str = item[:crumbly] ? " (CRUMBLY)" : ""
  output += "#{item[:name]} (#{item[:charges]})#{crumbly_str}\n"
  if item[:bonuses].empty?
    output += "   None detected\n"
  else
    item[:bonuses].each do |bonus|
      output += "   #{bonus}\n"
    end
  end
  output += "-" * 40 + "\n"
end

# Output the Sum of Benefits
output += "\n"
output += "=" * 40 + "\n"
output += " TOTAL BONUSES\n"
output += "=" * 40 + "\n"
totals.sort.each do |stat, value|
  output += " %-30s : +%d\n" % [stat, value]
end
output += "=" * 40

echo output
