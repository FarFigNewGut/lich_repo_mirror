require 'yaml'
=begin
This script tracks and analyzes damage output and flare performance, with a primary focus on newly introduced lore flares. It monitors both direct damage hits and various types of flares, calculating real-time statistics like DPS (damage per second), average damage, high scores, and flare rates (expressed as both a percentage and "1 flare per X swings"). The script displays this data in the familiar window, providing easy-to-read output with consistent formatting.

The script is especially useful for solo players using melee or ranged weapons, as it reliably tracks flare activity and performance in those situations. While it works well for standard weapon attacks, it may have difficulty tracking damage from spells due to the variety of messaging formats. The script has not yet been tested with unarmed combat (UAC). By offering detailed flare statistics, the script helps players optimize their gear and strategy by understanding the frequency and impact of different flares.

Must have Familiar Window open to see output.
Dispel CatB        | DMG: 70.0 | AVG: 36.6 | Flare/Attack: 1 per 3.5    | Chance of Flare: (28.6%)
Battle Standard F  | DMG: 10.0 | AVG: 12.3 | Flare/Attack: 1 per 10.91  | Chance of Flare: ( 9.2%)
FA 1706            | DMG: 5.0  | AVG: 16.7 | Flare/Attack: 1 per 15.32  | Chance of Flare: ( 6.5%)

Script created with Chat GPT.

1.0.0 (2024-08-26)
    - Initial release of the damage tracking script.
    - Added support for tracking multiple flare types, including newly introduced lore flares.
    - Implemented real-time DPS tracking, high score, average damage, and flare rate calculation.
    - Displays detailed statistics in the familiar window.
    - Automatically saves damage data and high scores between sessions.

1.1.0 (2024-08-26)
    - Improved spacing and alignment for output in the familiar window.
    - Adjusted flare type names to ensure consistent alignment.
    - Increased the field width for "Flare Rate" to prevent truncation.
    - Credit to Tysong for fixing the familiar window spacing output.

1.2.0 (2024-08-27)
    - Improved presentation of data analysis with simplified explanations.

1.3.0 (2024-08-28)
	- New flares added for tracking: Acid_CatB, Air_CatB, Animal_ScriptF, Briar_ScriptF, Cold_CatB, Cold_GEF, Disintegration_CatB, Disruption_CatB, Fire_CatB, Grapple_CatB, Guilding_Light_2ndF, Impact_CatB, Knockout_ScriptF, Low_Steel_M, Low_Steel_DoT, Magma_CatB, Plasma_CatB, Sonic_F, Sonic_2ndF, Steam_CatB, Steam_GEF, Unbalance_CatB, Valence_ScriptF, Vethinye_M, Water_CatB, Xazkruvrixis_M

=end
# Define a file path to store the damage data and high scores
data_dir = "#{$data_dir}#{XMLData.game}/#{Char.name}/"
damage_file_path = "#{data_dir}damage_data.yaml"
high_scores_file_path = "#{data_dir}high_scores.yaml"

# Create directories if they do not exist
Dir.mkdir("#{$data_dir}#{XMLData.game}") unless Dir.exist?("#{$data_dir}#{XMLData.game}")
Dir.mkdir(data_dir) unless Dir.exist?(data_dir)

# Define all flare types with their initial empty values
initial_damage_data = {
  Acid_CatB: [],
  Air_CatB: [],
  Air_LF: [],
  Air_DoT: [],
  Air_GEF: [],
  Animal_ScriptF: [],
  Briar_F: [],
  Cold_CatB: [],
  Cold_GEF: [],
  Disintegration_CatB: [],
  Dispel_CatB: [],
  Disruption_CatB: [],
  Earth_LF: [],
  Earth_DoT: [],
  Earth_GEF: [],
  Fire_CatB: [],
  Fire_LF: [],
  Fire_DoT: [],
  Fire_GEF: [],
  Grapple_CatB: [],
  Guiding_Light_2ndF: [],
  Ice_GEF: [],
  Impact_CatB: [],
  Knockout_ScriptF: [],
  Lightning_GEF: [],
  Lightning_CatB: [],
  Low_Steel_M: [],
  Low_Steel_DoT: [],
  Magma_CatB: [],
  Necromancy_LF: [],
  Necromancy_DoT: [],
  Plasma_CatB: [],
  Religion_LF: [],
  Religion_DoT: [],
  Sonic_F: [],
  Sonic_2ndF: [],
  Steam_CatB: [],
  Steam_GEF: [],
  Summoning_LF: [],
  Summoning_DoT: [],
  Telepathy_LF: [],
  Telepathy_DoT: [],
  Unbalance_CatB: [],
  Vacuum_CatB: [],
  Valence_ScriptF: [],
  Vethinye_M: [],
  Void_GEF: [],
  Water_CatB: [],
  Water_LF: [],
  Water_DoT: [],
  Xazkruvrixis_M: [],
  FA_1706: [],
  Battle_Standard_F: [],
  direct_damage: []
}


initial_high_scores = {
  Acid_CatB: 0,
  Air_CatB: 0,
  Air_LF: 0,
  Air_DoT: 0,
  Air_GEF: 0,
  Animal_ScriptF: 0,
  Briar_F: 0,
  Cold_CatB: 0,
  Cold_GEF: 0,
  Disintegration_CatB: 0,
  Dispel_CatB: 0,
  Disruption_CatB: 0,
  Earth_LF: 0,
  Earth_DoT: 0,
  Earth_GEF: 0,
  Fire_CatB: 0,
  Fire_LF: 0,
  Fire_DoT: 0,
  Fire_GEF: 0,
  Grapple_CatB: 0,
  Guiding_Light_2ndF: 0,
  Ice_GEF: 0,
  Impact_CatB: 0,
  Knockout_ScriptF: 0,
  Lightning_GEF: 0,
  Lightning_CatB: 0,
  Low_Steel_M: 0,
  Low_Steel_DoT: 0,
  Magma_CatB: 0,
  Necromancy_LF: 0,
  Necromancy_DoT: 0,
  Plasma_CatB: 0,
  Religion_LF: 0,
  Religion_DoT: 0,
  Sonic_F: 0,
  Sonic_2ndF: 0,
  Steam_CatB: 0,
  Steam_GEF: 0,
  Summoning_LF: 0,
  Summoning_DoT: 0,
  Telepathy_LF: 0,
  Telepathy_DoT: 0,
  Unbalance_CatB: 0,
  Vacuum_CatB: 0,
  Valence_ScriptF: 0,
  Vethinye_M: 0,
  Void_GEF: 0,
  Water_CatB: 0,
  Water_LF: 0,
  Water_DoT: 0,
  Xazkruvrixis_M: 0,
  FA_1706: 0,
  Battle_Standard_F: 0,
  direct_damage: 0
}


# Load damage data and ensure all keys exist
damage_data = if File.exist?(damage_file_path)
                YAML.load_file(damage_file_path)
              else
                initial_damage_data
              end

damage_data = initial_damage_data.merge(damage_data) # Add missing keys if any

# Load high scores and ensure all keys exist
high_scores = if File.exist?(high_scores_file_path)
                YAML.load_file(high_scores_file_path)
              else
                initial_high_scores
              end

high_scores = initial_high_scores.merge(high_scores) # Add missing keys if any

# Variables to track DPS
@dps_timer_active = false
@dps_start_time = nil
@last_damage_time = nil
@total_damage = 0
@reset_timer_after_seconds = 30

# Method to calculate the DPS
def calculate_dps(total_damage, start_time, last_damage_time)
  # Ensure that start_time and last_damage_time are properly set and elapsed_time is valid
  return 0 unless start_time && last_damage_time

  elapsed_time = last_damage_time - start_time
  elapsed_time > 0 ? (total_damage / elapsed_time).round(2) : 0
end

# Method to add damage, ensuring only numeric values are added
def add_damage(damage)
  # Only add to total_damage if the value is numeric
  if damage.is_a?(Numeric)
    @total_damage += damage

    # Activate the DPS timer if it's not already active
    unless @dps_timer_active
      @dps_start_time = Time.now
      @dps_timer_active = true
    end
    # Update the last damage time
    @last_damage_time = Time.now
  end
end

# Method to reset the DPS timer and related variables
def reset_dps
  echo_to_familiar_window("DPS timer reset due to inactivity.")
  @dps_timer_active = false
  @total_damage = 0
  @dps_start_time = nil
  @last_damage_time = nil
end

# Method to reset DPS if no damage is detected within a set time
def reset_dps_if_inactive
  if @dps_timer_active && @last_damage_time && (Time.now - @last_damage_time) > @reset_timer_after_seconds
    reset_dps
  end
end


# Method to calculate the average of the damage values
def calculate_average(damage_values)
  numeric_values = damage_values.select { |value| value.is_a?(Numeric) }
  return 0 if numeric_values.empty?
  
  numeric_values.sum / numeric_values.size.to_f
end

# Method to calculate the appearance rate of a flare type compared to direct damage
def calculate_appearance_rate(flare_hits, direct_damage_hits)
  return 0 if direct_damage_hits == 0
  
  ((flare_hits.to_f / direct_damage_hits) * 100).round(2)
end

# Method to calculate the flare rate as 1 flare per X swings
def calculate_flare_rate(flare_hits, direct_damage_hits)
  return "N/A" if flare_hits == 0
  
  "1 per #{(direct_damage_hits / flare_hits.to_f).round(2)}"
end

# Method to calculate median damage
def calculate_median(damage_values)
  numeric_values = damage_values.select { |value| value.is_a?(Numeric) }
  return 0 if numeric_values.empty?

  sorted = numeric_values.sort
  len = sorted.length
  (sorted[(len - 1) / 2] + sorted[len / 2]) / 2.0
end

# Method to calculate standard deviation
def calculate_standard_deviation(damage_values)
  numeric_values = damage_values.select { |value| value.is_a?(Numeric) }
  return 0 if numeric_values.empty?

  mean = calculate_average(numeric_values)
  variance = numeric_values.sum { |value| (value - mean) ** 2 } / numeric_values.size.to_f
  Math.sqrt(variance).round(2)
end


# Method to calculate damage distribution in defined ranges
def calculate_damage_distribution(damage_values)
  # Filter numeric values
  numeric_values = damage_values.select { |value| value.is_a?(Numeric) }

  ranges = {
    "0 - 9" => 0,
    "10 - 19" => 0,
    "20 - 29" => 0,
    "30 - 39" => 0,
    "40 - 49" => 0,
    "50 - 59" => 0,
    "60 - 69" => 0,
    "70 - 79" => 0,
    "80 - 89" => 0,
    "90 - 99" => 0,
    "100+" => 0
  }

  numeric_values.each do |damage|
    case damage
    when 0..9 then ranges["0 - 9"] += 1
    when 10..19 then ranges["10 - 19"] += 1
    when 20..29 then ranges["20 - 29"] += 1
    when 30..39 then ranges["30 - 39"] += 1
    when 40..49 then ranges["40 - 49"] += 1
    when 50..59 then ranges["50 - 59"] += 1
    when 60..69 then ranges["60 - 69"] += 1
    when 70..79 then ranges["70 - 79"] += 1
    when 80..89 then ranges["80 - 89"] += 1
    when 90..99 then ranges["90 - 99"] += 1
    else ranges["100+"] += 1
    end
  end

  ranges
end

# Method to calculate the observed flare rate and compare to the standard rate
def calculate_flare_comparison(total_flare_count, total_swing_count, standard_flare_rate)
  # Handle edge cases
  return {
    observed_flare_rate: "N/A",
    improvement_percentage_flare_rate: 0,
    improvement_percentage_probability: 0,
    cumulative_flare_chance: 0
  } if total_flare_count == 0 || total_swing_count == 0

  observed_flare_rate = (total_swing_count.to_f / total_flare_count).round(2)
  standard_probability = 1.0 / standard_flare_rate
  observed_probability = 1.0 / observed_flare_rate

  improvement_percentage_flare_rate = ((standard_flare_rate - observed_flare_rate) / standard_flare_rate * 100).round(2)
  improvement_percentage_probability = ((observed_probability - standard_probability) / standard_probability * 100).round(2)
  cumulative_flare_chance = (1 - (1 - observed_probability) ** total_swing_count) * 100

  {
    observed_flare_rate: "1 per #{observed_flare_rate}",
    improvement_percentage_flare_rate: improvement_percentage_flare_rate,
    improvement_percentage_probability: improvement_percentage_probability,
    cumulative_flare_chance: cumulative_flare_chance.round(2)
  }
end

# Method to display statistics with updated comparison logic
def display_flare_statistics_with_comparison(flare_type, damage_values, high_score, total_flare_count, total_swing_count, standard_flare_rate)
  # Filter numeric values for calculations
  numeric_values = damage_values.select { |value| value.is_a?(Numeric) }
  return if numeric_values.empty? # Skip if there are no numeric damage values

  comparison = calculate_flare_comparison(total_flare_count, total_swing_count, standard_flare_rate)

  puts "#{flare_type.to_s.gsub('_', ' ')} Flare Statistics:"
  puts "Average Damage: #{calculate_average(numeric_values).round(2)}"
  puts "Median Damage: #{calculate_median(numeric_values)}"
  puts "Standard Deviation: #{calculate_standard_deviation(numeric_values)}"
  puts "Damage Distribution:"
  calculate_damage_distribution(numeric_values).each do |range, count|
    puts "#{range}: #{count} hits"
  end
  puts "Total Hits: #{numeric_values.size} hits"
  puts "Highest Recorded: #{high_score}"
  puts "Flare Rate: #{comparison[:observed_flare_rate]}"
  puts "Flare Probability%: #{(total_flare_count.to_f / total_swing_count * 100).round(2)}%"
  # Uncomment if cumulative flare chance is needed
  # puts "Cumulative Flare Chance: #{comparison[:cumulative_flare_chance]}% over #{total_swing_count} swings"
  puts "Comparison to Standard Melee Flare Rate of 1 Flare Per 5 Swings or 20%:"
  puts "- How many swings do I need on average before I get a flare?"
  puts "- #{comparison[:observed_flare_rate]} swings, which is #{comparison[:improvement_percentage_flare_rate]}% better than the standard (1 per #{standard_flare_rate} swings)"
  puts "- How much more likely am I to see a flare on each individual swing?"
  puts "- #{comparison[:improvement_percentage_probability]}% more likely"
  puts "" # Add a line break for readability
end


# Display individual statistics on script load
def display_flare_statistics(damage_data, high_scores, standard_flare_rate)
flare_types = %i[
  Acid_CatB
  Air_CatB Air_LF Air_DoT Air_GEF
  Animal_ScriptF
  Briar_F
  Cold_CatB Cold_GEF
  Disintegration_CatB
  Dispel_CatB
  Disruption_CatB
  Earth_LF Earth_DoT Earth_GEF
  Fire_CatB Fire_LF Fire_DoT Fire_GEF
  Grapple_CatB
  Guiding_Light_2ndF
  Ice_GEF
  Impact_CatB
  Knockout_ScriptF
  Lightning_GEF Lightning_CatB
  Low_Steel_M Low_Steel_DoT
  Magma_CatB
  Necromancy_LF Necromancy_DoT
  Plasma_CatB
  Religion_LF Religion_DoT
  Sonic_F Sonic_2ndF
  Steam_CatB Steam_GEF
  Summoning_LF Summoning_DoT
  Telepathy_LF Telepathy_DoT
  Unbalance_CatB
  Vacuum_CatB
  Valence_ScriptF
  Vethinye_M
  Void_GEF
  Water_CatB Water_LF Water_DoT
  Xazkruvrixis_M
  FA_1706
  Battle_Standard_F
  direct_damage
]

  total_swing_count = damage_data[:direct_damage].size

  flare_types.each do |flare_type|
    display_flare_statistics_with_comparison(
      flare_type,
      damage_data[flare_type],
      high_scores[flare_type],
      damage_data[flare_type].size,
      total_swing_count,
      standard_flare_rate
    )
  end
end

# Method to save the damage values to a file
def save_damage_data(damage_data, file_path)
  File.open(file_path, "w") { |file| file.write(damage_data.to_yaml) }
end

# Method to save high scores to a file
def save_high_scores(high_scores, file_path)
  File.open(file_path, "w") { |file| file.write(high_scores.to_yaml) }
end

# Method to send output to the familiar window
def echo_to_familiar_window(message)
  if $frontend =~ /stormfront|profanity/i
    fam_window_begin = "<pushStream id=\"familiar\" ifClosedStyle=\"watching\"/><output class=\"mono\"/>\n"
    fam_window_end = "\n<output class=\"\"/><popStream/>\r\n"
  else
    fam_window_begin = "\034GSe\r\n"
    fam_window_end = "\034GSf\r\n"
  end
  _respond("#{fam_window_begin}#{message}#{fam_window_end}")
end

# Method to display the DPS, high score, average, flare percentage, and flare rate in the familiar window with uniform spacing
def display_flare_data(flare_type, damage, high_score, avg, dps, flare_hits, direct_damage_hits)
  appearance_rate = calculate_appearance_rate(flare_hits, direct_damage_hits)
  flare_rate = calculate_flare_rate(flare_hits, direct_damage_hits)
  return if flare_type == :direct_damage

  # Determine the maximum lengths for each field to dynamically adjust spacing
  max_flare_type_length = 18 # Set this to a value that works well with your display
  flare_type_display = flare_type.to_s.gsub('_', ' ').ljust(max_flare_type_length)

  # Handle the display for death flares
  if damage == "DEATH"
    # Format the output for death flares, excluding numerical fields that don't apply
    message = format(
      "%-#{max_flare_type_length}s | DMG: %-6s | AVG: %-6s| Flare/Attack: %-12s | Chance of Flare: (%4.1f%%)",
      flare_type_display,
      "DEATH",
      "N/A",           # Average is not applicable for death flares
      flare_rate,
      appearance_rate
    )
  else
  # Format the output to ensure consistent spacing
  message = format(
  #DPS: %-4.1f
    "%-#{max_flare_type_length}s | DMG: %-4.1f | AVG: %-4.1f | Flare/Attack: %-12s | Chance of Flare: (%4.1f%%)",
    #dps,
    flare_type_display,
    damage,
    avg,
    flare_rate,
    appearance_rate,

  )
  end
  echo_to_familiar_window(message)
end

# Loop to monitor game lines
begin
  # Display statistics on script start
  display_flare_statistics(damage_data, high_scores, 5) # Standard melee flare rate: 1 per 5 swings
  
  while true
    line = get

    # Reset DPS if inactive for 30 seconds
    reset_dps_if_inactive

    # Define flare patterns and corresponding types
    flare_patterns = {
	  Acid_CatB: /\*\* Your .* releases a spray of acid! \*\*/,
	  Air_CatB: /\*\* Your .* unleashes a blast of air! \*\*/,
      Air_LF: /A fierce whirlwind erupts around .* encircling .* in a suffocating cyclone/,
      Air_DoT: /The cyclone whirls around .* anew/,
      Air_GEF: /\*\* A howling gale of steaming air rushes from .*/,
	  Animal_ScriptF: /slender tendrils rising up to coalesce into the ethereal form/,
	  Briar_ScriptF: /Vines of vicious briars whip out from your/,
	  Cold_CatB: /\*\* Your .* glows intensely with a cold blue light! \*\*/,
	  Cold_GEF: /\*\* A vortex of razor-sharp ice gusts from .* and coalesces around a .*! \*\*/,
	  Disintegration_CatB: /\*\* Your .* releases a shimmering beam of disintegration! \*\*/,
	  Dispel_CatB: /\*\* Your .* glows brightly for a moment, consuming the magical energies around .*!/,
	  Disruption_CatB: /\*\* Your .* releases a quivering wave of disruption! \*\*/,
      Earth_LF: /Chunks of earth violently orbit .* pelting .* with heavy debris/,
      Earth_DoT: /The ground trembles violently, pelting .* again/,
      Earth_GEF: /\*\* A violent explosion of frenetic energy rumbles from .*/,
	  Fire_CatB: /\*\* Your .* flares with a burst of flame! \*\*/,
      Fire_LF: /A blazing inferno erupts around .* scorching everything in its wake/,
      Fire_DoT: /The inferno blazing around .* ignites anew/,
      Fire_GEF: /\*\* Burning orbs of pure flame burst from .*/,
	  Grapple_CatB: /\*\* Your .* releases a twisted tendril of force! \*\*/,
	  Guiding_Light_2ndF: /Your .* sprays with a burst of plasma energy!/,
      Ice_GEF: /\*\* A vortex of razor-sharp ice gusts from .*/,
	  Impact_CatB: /\*\* Your .* releases a blast of vibrating energy! \*\*/,
	  Knockout_ScriptF: /cracks the .* on the back of the head|Your .* thumps the .* in the head|then reverse direction and crack/,
      Lightning_GEF: /\*\* A vicious torrent of crackling lightning surges from .*/,
      Lightning_CatB: /\*\* Your .* emits a searing bolt of lightning! \*\*/,
	  Low_Steel_M: /Your .* unleashes a blast of psychic energy/,
	  Low_Steel_DoT: /convulses in horrified agony/,
	  Magma_CatB: /\*\* Your .* expels a glob of molten magma! \*\*/,
      Necromancy_LF: /\*\* A sickly green aura radiates from/,
      Necromancy_DoT: /Small pieces of flesh rot off a/,
	  Plasma_CatB: /\*\* Your .* pulses with a burst of plasma energy! \*\*/,
      Religion_LF: /Divine flames kindle around .* leaping forth to engulf/,
      Religion_DoT: /The sacred inferno surrounding .* ignites anew/,
	  Sonic_F: /Your .* unleashes a blast of sonic energy at/,
	  Sonic_2ndF: /With a loud snap, a blast of energy bursts from your .*/,
	  Steam_CatB: /\*\* Your .* erupts with a plume of steam! \*\*/,
	  Steam_GEF: /\*\* A howling gale of steaming air rushes from/,
      Summoning_LF: /A radiant mist surrounds .* unfurling into a whip of plasma/,
      Summoning_DoT: /The whip of plasma continues to wreathe/,
      Telepathy_LF: /Rippling and half-seen, strands of psychic power unravel from the/,
      Telepathy_DoT: /Locked in mental durance, .* is assailed by some unseen attack!/,
	  Unbalance_CatB: /\*\* Your .* unleashes an invisible burst of force! \*\*/,
      Vacuum_CatB: /folds inward and draws its surroundings closer!/,
	  Valence_ScriptF: /A coil of spectral .* energy bursts out of thin air|A coil of ghostly .* energy bursts out of thin air|A coil of eerie .* energy bursts out of thin air|A coil of celestial .* energy bursts out of thin air/,
	  Vethinye_M: /As a resonating song emanates from your .*, it entwines you in night blue wisps of ephemera/,
      Void_GEF: /\*\* A nebulous dome of violet energy discharges from .*/,
	  Water_CatB: /\*\* Your .* shoots a blast of water! \*\*/,
      Water_LF: /A watery deluge erupts violently around .* crushing/,
      Water_DoT: /The water surrounding .* churns anew/,
	  Xazkruvrixis_M: /The life drains visibly away from .*, as/,
      FA_1706: /The flaming aura surrounding you lashes out at .*!/,
      Battle_Standard_F: /With a sonorous knell, .* overtakes|With a deafening crack of thunder, .* spears .*|Cruel, glittering flames .* erupt around .*|Brazen and implacable, .* crashes down upon .*|Threads of glistening silk .* wind around .*/,
      direct_damage: /\.\.\. and hit for (\d+) points of damage!/
    }

    flare_patterns.each do |flare_type, pattern|
      if line =~ pattern
        if flare_type == :direct_damage
          # Handle direct damage tracking
          damage = line.match(/\.\.\. and hit for (\d+) points of damage!/)[1].to_i
          damage_data[flare_type] << damage
          @total_damage += damage

          # Update high score if necessary
          high_scores[flare_type] = damage if damage > high_scores[flare_type]

          if @dps_timer_active
            @last_damage_time = Time.now
          else
            # Start the DPS timer on the first damage instance
            @dps_start_time = Time.now
            @last_damage_time = Time.now
            @dps_timer_active = true
          end

          # Display DPS, high score, average, and flare rate in the familiar window
          dps = calculate_dps(@total_damage, @dps_start_time, @last_damage_time)
          avg = calculate_average(damage_data[flare_type])
          flare_hits = damage_data[flare_type].size
          direct_damage_hits = damage_data[:direct_damage].size
          display_flare_data(flare_type, damage, high_scores[flare_type], avg, dps, flare_hits, direct_damage_hits)

          save_damage_data(damage_data, damage_file_path)
          save_high_scores(high_scores, high_scores_file_path)

        elsif flare_type == :Dispel_CatB || flare_type == :FA_1706 || flare_type.to_s.include?('Animal')
          # Handle flares where the damage occurs on the third line
          get # Skip the second line
          damage_line = get
          if damage_line =~ /\.\.\. (\d+) points? of damage!/
            damage = damage_line.match(/\.\.\. (\d+) points? of damage!/)[1].to_i
            damage_data[flare_type] << damage
            @total_damage += damage

            # Update high score if necessary
            high_scores[flare_type] = damage if damage > high_scores[flare_type]

            if @dps_timer_active
              @last_damage_time = Time.now
            else
              @dps_start_time = Time.now
              @last_damage_time = Time.now
              @dps_timer_active = true
            end

            # Display DPS, high score, average, and flare rate in the familiar window
            dps = calculate_dps(@total_damage, @dps_start_time, @last_damage_time)
            avg = calculate_average(damage_data[flare_type])
            flare_hits = damage_data[flare_type].size
            direct_damage_hits = damage_data[:direct_damage].size
            display_flare_data(flare_type, damage, high_scores[flare_type], avg, dps, flare_hits, direct_damage_hits)

            save_damage_data(damage_data, damage_file_path)
            save_high_scores(high_scores, high_scores_file_path)
          end

        elsif flare_type.to_s.include?('DoT') || flare_type.to_s.include?('GEF') || flare_type == :Knockout_ScriptF
          # Handle two-line flares (DoT or GEF Lightning)
          damage_line_1 = get
          if damage_line_1 =~ /\.\.\. (\d+) points? of damage!/
            damage_1 = damage_line_1.match(/\.\.\. (\d+) points? of damage!/)[1].to_i
            damage_line_2 = get
            damage_line_2 = get if damage_line_2 !~ /\.\.\. (\d+) points? of damage!/
            if damage_line_2 =~ /\.\.\. (\d+) points? of damage!/
              damage_2 = damage_line_2.match(/\.\.\. (\d+) points? of damage!/)[1].to_i
              total_flare_damage = damage_1 + damage_2
              damage_data[flare_type] << total_flare_damage
              @total_damage += total_flare_damage

              # Update high score if necessary
              high_scores[flare_type] = total_flare_damage if total_flare_damage > high_scores[flare_type]

              if @dps_timer_active
                @last_damage_time = Time.now
              else
                @dps_start_time = Time.now
                @last_damage_time = Time.now
                @dps_timer_active = true
              end

              # Display DPS, high score, average, and flare rate in the familiar window
              dps = calculate_dps(@total_damage, @dps_start_time, @last_damage_time)
              avg = calculate_average(damage_data[flare_type])
              flare_hits = damage_data[flare_type].size
              direct_damage_hits = damage_data[:direct_damage].size
              display_flare_data(flare_type, total_flare_damage, high_scores[flare_type], avg, dps, flare_hits, direct_damage_hits)

              save_damage_data(damage_data, damage_file_path)
              save_high_scores(high_scores, high_scores_file_path)
            end
          end
elsif flare_type == :Xazkruvrixis_M
  # Handle death flare tracking
  damage_data[flare_type] << "DEATH"
  @total_deaths ||= 0
  @total_deaths += 1

  if @dps_timer_active
    @last_damage_time = Time.now
  else
    @dps_start_time = Time.now
    @last_damage_time = Time.now
    @dps_timer_active = true
  end

  # Calculate flare rate and display data
  flare_hits = damage_data[flare_type].size
  dps = calculate_dps(@total_damage, @dps_start_time, @last_damage_time)
  avg = "N/A"  # Average is not applicable for death flares
  direct_damage_hits = damage_data[:direct_damage].size
  display_flare_data(flare_type, "DEATH", "N/A", avg, dps, flare_hits, direct_damage_hits)

  save_damage_data(damage_data, damage_file_path)
  save_high_scores(high_scores, high_scores_file_path)
        else
          # Handle single-line flares
          damage_line = get
          if damage_line =~ /\.\.\. (\d+) points? of damage!/
            damage = damage_line.match(/\.\.\. (\d+) points? of damage!/)[1].to_i
            damage_data[flare_type] << damage
            @total_damage += damage

            # Update high score if necessary
            high_scores[flare_type] = damage if damage > high_scores[flare_type]

            if @dps_timer_active
              @last_damage_time = Time.now
            else
              @dps_start_time = Time.now
              @last_damage_time = Time.now
              @dps_timer_active = true
            end

            # Display DPS, high score, average, and flare rate in the familiar window
            dps = calculate_dps(@total_damage, @dps_start_time, @last_damage_time)
            avg = calculate_average(damage_data[flare_type])
            flare_hits = damage_data[flare_type].size
            direct_damage_hits = damage_data[:direct_damage].size
            display_flare_data(flare_type, damage, high_scores[flare_type], avg, dps, flare_hits, direct_damage_hits)

            save_damage_data(damage_data, damage_file_path)
            save_high_scores(high_scores, high_scores_file_path)
          end
        end
        break # Stop checking further patterns once a match is found
      end
    end
  end
rescue Interrupt
  save_damage_data(damage_data, damage_file_path)
  save_high_scores(high_scores, high_scores_file_path)
  echo_to_familiar_window("Flare damage data and high scores saved. Exiting script.")
end
