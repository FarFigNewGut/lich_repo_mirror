=begin
  *** THIS IS AN ALPHA RELEASE ***

  ;eboost
  
  This script provides a rough api for working with `boost info`

  If you manually activate a boost you need to resync using the Boost.info api

  API:
    ;boost will register the api and run a single `boost info` command and parse the output

  Boost[:loot_major].remaining # => returns an int of the amount of `boost loot major` commands remaining
  Boost.use(:loot_major) # => uses a boost
  Boost.known # => returns an Array of all known boosts

  author: Ondreian
  tags: foraging, herbs
  version: 0.0.1-rc.0
    
=end


module Boost
  @known ||= []
  
  def self.dr?
    XMLData.game.start_with? "DR"
  end
  
  module Patterns
    module Dragonrealms
      BoostParser = %r[^\s+(?<remaining>\d+)\s+<d>(?<cmd>[\w\s]+)<\/d>\.+(?<name>.*)$]
      MenuStart = %r[Your Login Rewards information:]
      #MenuEnd   = %r[<output class=""/>]
    end

    module Gemstone
      BoostParser = %r[^<d cmd='(?<cmd>[\w\s]+)'>(?<name>[\w\s]+)<\/d>:\s+(?<remaining>\d+)$]
      MenuStart   = %r[your Login Rewards information is as follows:]
      #MenuEnd     = %r[<prompt time=]
    end

    def self.fetch(name)
      return Dragonrealms.const_get(name) if Boost.dr?
      return Gemstone.const_get(name)
    end
  end


  def self.to_method(api, cmd, name, remaining)
    method_name = cmd[6..-1].gsub(/\s+/, "_").to_sym
    #respond "%s -> %s" % [cmd, remaining]
    @known << method_name
    boost = OpenStruct.new(cmd: cmd, name: name, remaining: remaining.to_i)
    api[method_name] = boost
    boost.instance_eval do
      def use
        return if self.remaining.eql?(0)
        # todo: encode success/fail messages
        fput self.cmd
        self.remaining = self.remaining - 1
      end
    end
    boost
  end

  def self.reorder(one,two,three)
    # swap the position in DR
    [two, three, one] if Boost.dr?
    [one, two, three]
  end
  
  def self.info()
    @known.clear
    @state = Lich::Util.quiet_command_xml("boost info", 
      Patterns.fetch(:MenuStart))
      .join("\n")
      .scan(Patterns.fetch(:BoostParser))
      .each_with_object(OpenStruct.new) {|match, api| self.to_method(api, *self.reorder(*match))}
    
    _respond "<b>parsed %s boost types</b>" % @known.size
    return @state
  end

  def self.known
    @known
  end

  def self.[](kind)
    kind = kind.to_sym
    fail "unknown boost %s" % kind unless @known.include?(kind)
    @state.send(kind)
  end

  def self.use(kind)
    boost = self[kind]
    boost.use
  end

  def self.main()
    self.info if Script.current.vars.include?("--flush")
    @state ||= self.info
  end

  self.main()
end