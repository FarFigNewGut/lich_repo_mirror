#Memo v1.01
# --- MEMORY STORAGE SYSTEM ---
#Type ;Memo Help for more information
# ============================================================
#                  MEMO SCRIPT HELP
# ============================================================
#
# This script allows you to store, recall, and manage short memos.
#
# COMMANDS:
#  1. **;memo**  
#     - Opens an interactive menu where you can store, recall, or delete memories.  
#     - You will use `;send` commands to interact with the menu.  
#     - In many cases (see below) you can interact directly without using the menu. 
#
#  2. **;memo (keyword)**  
#     - Directly recalls a stored memory for the given keyword.  
#     - Example: `;memo taco` → Displays the stored entry for 'taco'.  
#
#  3. **;memo store (keyword) (text)**  
#     - Allows you to store a memory without opening the menu.  
#     - Example: `;memo store taco Tacos are great!` → Saves the entry instantly.  
#
#  4. **;memo search (word)**  
#     - Searches all stored memories for a word, regardless of keyword.  
#     - Example: `;memo search druid` → Finds all entries that mention 'druid'.  
#
# NOTES:  
#  - If a keyword does not exist, the script will display \"No memory found\" and return to the menu.  
#  - If no arguments are provided (`;memo`), the script will open the interactive menu.  

require 'yaml'

DATA_FILE = File.join(SCRIPT_DIR, 'memory.yml')

# Function to store information
def memo_store_memory(key, value)
  data = File.exist?(DATA_FILE) ? YAML.load_file(DATA_FILE) : {}
  data[key] ||= []
  data[key] << value unless data[key].include?(value) # Avoid duplicates
  File.open(DATA_FILE, 'w') { |f| f.write(data.to_yaml) }
  respond "Stored memory for '#{key}'."
end

# Function to recall information
def memo_recall_memory(key)
  data = File.exist?(DATA_FILE) ? YAML.load_file(DATA_FILE) : {}
    if data[key]
    Gtk.queue { UserVars.memo_character = key.downcase }  # Send name to imagination.lic
    respond "Memory for '#{key}':"
    data[key].each_with_index { |entry, index| respond "#{index + 1}. #{entry}" }
    exit
  else
    respond "No memory found for '#{key}'."
  end
end

# Function to forget a specific memory entry or all entries
def memo_forget_memory_menu(key)
  data = File.exist?(DATA_FILE) ? YAML.load_file(DATA_FILE) : {}

  if data[key]
    respond "Memory entries for '#{key}':"
    data[key].each_with_index { |entry, index| respond "#{index + 1}. #{entry}" }
    respond "Type ;send 3 (number) to delete an entry, or ;send 3 999 to delete all."

    entry_num = nil
    until entry_num && entry_num > 0 && entry_num <= data[key].size
      entry_num = get.strip.to_i rescue nil
    end

    if entry_num == 999
      respond "Are you sure you want to delete ALL entries for '#{key}'? Type ;send yes to confirm."
      confirm = get.strip.downcase
      if confirm == "yes"
        data.delete(key)
        File.open(DATA_FILE, 'w') { |f| f.write(data.to_yaml) }
        respond "All entries for '#{key}' have been deleted."
      else
        respond "Deletion canceled."
      end
    else
      removed_entry = data[key].delete_at(entry_num - 1)
      File.open(DATA_FILE, 'w') { |f| f.write(data.to_yaml) }
      respond "Forgot memory: '#{removed_entry}' from '#{key}'."
    end
  else
    respond "No memory found for '#{key}'."
  end
end

# Function to list all stored keywords
def memo_list_keywords
  data = File.exist?(DATA_FILE) ? YAML.load_file(DATA_FILE) : {}
  if data.empty?
    respond "No stored memories found."
  else
    respond "Stored memory keywords: " + data.keys.join(", ")
  end
end

# Function to search all memory entries for a word
def memo_search_entries(word)
  data = File.exist?(DATA_FILE) ? YAML.load_file(DATA_FILE) : {}
  matches = []

  data.each do |key, entries|
    entries.each do |entry|
      if entry.downcase.include?(word.downcase)
        matches << "Found in '#{key}': #{entry}"
      end
    end
  end

  if matches.empty?
    respond "No entries found containing '#{word}'."
  else
    respond "Search results:"
    matches.each { |match| respond match }
  end
end

# --- MAIN EXECUTION: Handle Direct Keyword Input ---
if variable[1] && variable[1].downcase =~ /help/
  echo "
# ============================================================
#                  MEMO SCRIPT HELP
# ============================================================

# This script allows you to store, recall, and manage short memos.

# COMMANDS:
#  1. **;memo**  
#     - Opens an interactive menu where you can store, recall, or delete memories.  
#     - You will use `;send` commands to interact with the menu.  

#  2. **;memo (keyword)**  
#     - Directly recalls a stored memory for the given keyword.  
#     - Example: `;memo taco` → Displays the stored entry for 'taco'.  

#  3. **;memo store (keyword) (text)**  
#     - Allows you to store a memory without opening the menu.  
#     - Example: `;memo store taco Tacos are great!` → Saves the entry instantly.  

#  4. **;memo search (word)**  
#     - Searches all stored memories for a word, regardless of keyword.  
#     - Example: `;memo search druid` → Finds all entries that mention 'druid'.  

# NOTES:  
#  - If a keyword does not exist, the script will display \"No memory found\" and return to the menu.  
#  - If no arguments are provided (`;memo`), the script will open the interactive menu.  

"
  exit
end

if variable[1] && variable[1].downcase == "store"
  if variable[2] && variable[3]
    key = variable[2].downcase
    value = variable[3..-1].join(" ")
    memo_store_memory(key, value)
    exit
  else
    respond "Invalid format. Use: ;memo store (keyword) (text)"
    exit
  end
end

if variable[1] && variable[1].downcase == "search"
  if variable[2]
    memo_search_entries(variable[2])
    exit
  else
    respond "Invalid format. Use: ;memo search (word)"
    exit
  end
end

if variable[1]  # If any argument is provided, assume it's a keyword and attempt to recall it
  memo_recall_memory(variable[1].downcase)
  exit
end

# --- INTERACTIVE MENU ---
respond "
=======================================
What would you like to do?
    1. Store a memory - please ;send 1 (keyword) (text)
    2. Recall a memory - please ;send 2 (keyword)
    3. Forget a memory - please ;send 3 (keyword)
    4. List all stored keywords - please ;send 4
    5. Search all entries - please ;send 5 (word)
======================================="
respond

# Wait for a valid `;send` command
line = nil
line = get until line.strip =~ /^[1-5] \S+.*|^[4-5]$/
command = line.strip

if command.match(/^1\s+(\S+)\s+(.+)$/)
  key, value = command.match(/^1\s+(\S+)\s+(.+)$/).captures
  memo_store_memory(key.downcase, value.strip)

elsif command =~ /^2\s+(.+)$/
  memo_recall_memory(command.match(/^2\s+(.+)$/)[1].downcase)

elsif command =~ /^3 (\S+)$/
  memo_forget_memory_menu(command.match(/^3 (\S+)$/)[1].downcase)

elsif command.strip == "4"
  memo_list_keywords

elsif command =~ /^5 (\S+)$/
  memo_search_entries(command.match(/^5 (\S+)$/)[1].downcase)

else
  respond "Invalid selection. Exiting memory system."
end
