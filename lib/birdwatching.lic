=begin

This script created with the help of Chat GPT.

This script is intended to be a field guide of sorts for bird watchers using the new Jeepers Creepers bird watching items.
https://gswiki.play.net/Jeepers_Creepers

The script runs in the background and will record data per uID for any birds or feathers you find by "peering my spyglass".

COMMANDS
;send search
>;send search vul met
--- sent: search vul met
[birdwatching: Search results for 'vul met':
Bird: 'a bronze-beaked metallic black vulture' found in UIDs: [8083020], [8083028], [8083029], [8083361]]

;send Explore
This will attempt to search the area around you that is lacking entries in the database.  It will move to the closest uID without entries and peer 30 times.  It will then move on to the next closest uid and repeat.

=end

require 'yaml'

DATA_DIR = "#{$data_dir}#{XMLData.game}/"
BIRD_DATA_PATH = "#{DATA_DIR}birds_and_feathers.yaml"

# Ensure the data directory exists
Dir.mkdir("#{$data_dir}#{XMLData.game}") unless Dir.exist?("#{$data_dir}#{XMLData.game}")
Dir.mkdir(DATA_DIR) unless Dir.exist?(DATA_DIR)

# Load existing bird and feather data or initialize a new hash
def load_bird_data
  if File.exist?(BIRD_DATA_PATH)
    YAML.load_file(BIRD_DATA_PATH) || { 'birds' => {}, 'feathers' => {}, 'completed_rooms' => [] }
  else
    { 'birds' => {}, 'feathers' => {}, 'completed_rooms' => [] }
  end
end

require 'yaml'

# Custom array class that forces flow style when dumping to YAML
class FlowStyleArray < Array
  def encode_with(coder)
    coder.style = Psych::Nodes::Sequence::FLOW
    coder.represent_seq(nil, self)
  end
end

# Helper method to recursively transform arrays
def deep_transform_arrays(obj, &block)
  case obj
  when Hash
    obj.each_with_object({}) do |(k, v), h|
      h[k] = deep_transform_arrays(v, &block)
    end
  when Array
    yield(obj.map { |e| deep_transform_arrays(e, &block) })
  else
    obj
  end
end

# Save bird and feather data to YAML with arrays in flow style
def save_bird_data(data)
  # Transform the data to use FlowStyleArray for arrays
  data = deep_transform_arrays(data) { |array| FlowStyleArray.new(array) }

  # Sort the 'birds' and 'feathers' hashes by their keys
  data['birds'] = data['birds'].sort.to_h
  data['feathers'] = data['feathers'].sort.to_h

  File.open(BIRD_DATA_PATH, 'w') do |file|
    file.write(data.to_yaml(line_width: -1))
  end
end

# Record a new bird or feather sighting
def record_sighting(type, name)
  data = load_bird_data
  uid = Room.current.uid.to_s  # Convert UID to string
  data[type][name] ||= []
  unless data[type][name].include?(uid)
    data[type][name] << uid
    data[type][name].uniq!  # Ensure no duplicate UIDs
    save_bird_data(data)
    echo("New #{type} recorded: '#{name}' in UID: #{uid}.")
  end
end

# Mark a room as completed after 30 peers
def mark_room_completed
  data = load_bird_data
  uid = Room.current.uid.to_s
  unless data['completed_rooms'].include?(uid)
    data['completed_rooms'] << uid
    save_bird_data(data)
    echo("Room #{uid} marked as completed.")
  end
end

# Function to handle spyglass peering output
def handle_spyglass_output(line)
  if line =~ /you notice an? (.+?) in this area/i
    bird_name = $1.strip
    record_sighting('birds', bird_name)
  end
  if line =~ /you notice an? (.+? feather) hiding in the environment/i
    feather_name = $1.strip
    record_sighting('feathers', feather_name)
  end
end

# Search the stored data for birds or feathers, supporting multi-word searches
def search_data(query)
  data = load_bird_data
  search_terms = query.downcase.split  # Split the query into individual words
  results = []

  # Search birds
  data['birds'].each do |bird, uids|
    if search_terms.all? { |term| bird.downcase.include?(term) }
      results << "Bird: '#{bird}' found in UIDs: [#{uids.join(', ')}]"
    end
  end

  # Search feathers
  data['feathers'].each do |feather, uids|
    if search_terms.all? { |term| feather.downcase.include?(term) }
      results << "Feather: '#{feather}' found in UIDs: [#{uids.join(', ')}]"
    end
  end

  if results.empty?
    echo("No results found for '#{query}'.")
  else
    echo("Search results for '#{query}':\n" + results.join("\n"))
  end
end

require 'timeout'

# Explore new areas and record data using map navigation
def explore_and_record(location = nil)
  location ||= Room.current.location  # Use current location if none specified
  anchor = Room.current.id
  bird_data = load_bird_data

  # Retrieve all room IDs in the specified location
  room_ids = Map.list.select { |room| room.location.eql?(location) }.map(&:id)

  # Remove rooms that have already been explored or marked as completed
  room_ids.reject! do |id|
    uid = Room[id].uid.to_s
    bird_data['completed_rooms'].include?(uid) ||
      bird_data['birds'].any? { |_, uids| uids.include?(uid) } ||
      bird_data['feathers'].any? { |_, uids| uids.include?(uid) }
  end

  if room_ids.empty?
    echo("No unexplored rooms found in the location: #{location}.")
    return
  end

  echo("Exploring rooms in #{location}...")

  # Loop until all unexplored rooms are covered or stopped manually
  until room_ids.empty?
    # Find the closest unexplored room
    closest_room = Room.current.find_nearest(room_ids)
    if closest_room.nil?
      echo("Cannot find a path to the remaining unexplored rooms.")
      break
    end

    # Navigate to the closest room
    room_ids.delete(closest_room)
    Script.run("go2", closest_room.to_s)

    sightings_recorded = false

    # Peer through the spyglass 30 times to record sightings
    30.times do
      waitrt?  # Wait for the roundtime to end before executing the next command
      fput "stow all" if GameObj.right_hand.noun !~ /(?:spyglass)/
      fput "get my spyglass" if GameObj.right_hand.noun !~ /(?:spyglass)/
      fput('peer my spyglass')
      sleep 0.15  # Slight delay between actions to avoid being too fast

      # Collect multiple lines of output with a timeout to avoid hanging
      output_lines = []
      begin
        Timeout.timeout(0.15) do  # Adjust timeout as needed
          while (line = get.strip)
            break if line.empty?
            output_lines << line
            break if output_lines.size >= 5  # Limit to max 5 lines
          end
        end
      rescue Timeout::Error
        # Timeout reached, continue with what we have in output_lines
      end

      # Process each line of output for both birds and feathers
      output_lines.each do |line|
        if line =~ /you notice an? (.+?) in this area/i
          bird_name = $1.strip
          record_sighting('birds', bird_name)
          sightings_recorded = true
        end
        if line =~ /you notice an? (.+? feather) hiding in the environment/i
          feather_name = $1.strip
          record_sighting('feathers', feather_name)
          sightings_recorded = true
        end
      end
    end

    # Mark room as completed if sightings were recorded
    mark_room_completed if sightings_recorded
  end

  # Return to the starting point
  Script.run("go2", anchor.to_s)
  echo("Exploration completed.")
end


# Main monitoring loop for game output
def game_monitor
  while true
    line = get.strip

	# Handle spyglass output
	handle_spyglass_output(line)

    # Handle search command
    if line =~ /^search\s+(.+)/i
      search_query = $1
      search_data(search_query)
    elsif line =~ /^explore/i
      explore_and_record
    end

    sleep 0.1  # Avoid overloading
  end
rescue => e
  echo("Error in game monitor: #{e.message}")
end

# Start the game monitor
game_monitor
