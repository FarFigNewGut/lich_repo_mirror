=begin
  warlogin.lic
  Temporarily forces Warlock3 launch by editing entry.dat, launches lich.rbw, then restores entry.dat after a delay.

  Usage:
    ;warlogin <character name>
    ;warlogin <character name> <restore_delay_seconds>

  Notes:
    - Defaults realm to prime if not set.
    - Restoration is done by a detached helper process (reliable).
=end

WARLOCK_LAUNCH = 'warlock --host localhost --port %port% --key %key%'
DEFAULT_RESTORE_DELAY = 8

def die(msg)
  echo msg
  exit
end

def realm_to_game_code(realm)
  case realm
  when 'platinum'  then 'GSX'
  when 'shattered' then 'GSF'
  when 'test'      then 'GST'
  else                  'GS3' # prime default
  end
end

# ---- args ----
if script.vars[1].nil? || script.vars[1].to_s =~ /^help$/i
  echo "Usage:"
  echo "  ;warlogin <character name>"
  echo "  ;warlogin <character name> <restore_delay_seconds>"
  echo
  echo "Forces Warlock3 launch with:"
  echo "  #{WARLOCK_LAUNCH}"
  exit
end

char_name = script.vars[1].to_s.capitalize
delay = (script.vars[2] && script.vars[2].to_s =~ /^\d+$/) ? script.vars[2].to_i : DEFAULT_RESTORE_DELAY
delay = DEFAULT_RESTORE_DELAY if delay < 1

# ---- realm default prime ----
realm = (CharSettings['realm'] || 'prime').to_s.downcase
game_code = realm_to_game_code(realm)

# ---- load entry.dat ----
entry_path = File.join(DATA_DIR, "entry.dat")
die "Error: missing entry.dat in #{DATA_DIR}" unless File.exist?(entry_path)

entry_data = File.open(entry_path, 'r') do |file|
  begin
    Marshal.load(file.read.unpack('m').first)
  rescue
    []
  end
end

# ---- find target entry ----
idx = entry_data.index { |d| d.is_a?(Hash) && d[:char_name] == char_name && d[:game_code] == game_code }
die "Error: No saved entry found for #{char_name} in realm #{realm} (#{game_code})." unless idx

original = entry_data[idx].dup

# ---- apply temporary change ----
entry_data[idx][:custom_launch] = WARLOCK_LAUNCH
# Optional:
# entry_data[idx][:custom_launch_dir] = "C:\\Path\\To\\Warlock3"

File.open(entry_path, 'w') { |file| file.write([Marshal.dump(entry_data)].pack('m')) }

# ---- build rubyw path ----
rubyw = RbConfig::CONFIG['bindir'] + '/' +
        (RbConfig::CONFIG['RUBYW_INSTALL_NAME'].empty? ? RbConfig::CONFIG['RUBY_INSTALL_NAME'] : RbConfig::CONFIG['RUBYW_INSTALL_NAME']) +
        RbConfig::CONFIG['EXEEXT']
die "Error: failed to find rubyw.exe" unless File.exist?(rubyw)

# ---- spawn lich.rbw (same style as elogin) ----
instance =
  case realm
  when "shattered" then "--gemstone --shattered"
  when "platinum"  then "--gemstone --platinum"
  when "test"      then "--gemstone --test"
  else                  "--gemstone"
  end

spawn_string = "\"#{rubyw}\" \"#{File.join(LICH_DIR, 'lich.rbw')}\" #{instance} --login #{char_name}"
echo spawn_string

begin
  Process.spawn(spawn_string)
rescue => e
  # If launch fails, restore immediately
  entry_data[idx] = original
  File.open(entry_path, 'w') { |file| file.write([Marshal.dump(entry_data)].pack('m')) }
  die "Error launching lich.rbw: #{e.class}: #{e.message}"
end

# ---- write restore helper + state ----
stamp = Time.now.to_i
state_path  = File.join(DATA_DIR, "warlogin_restore_#{stamp}.bin")
helper_path = File.join(DATA_DIR, "warlogin_restore_#{stamp}.rb")

# Store enough info to restore exactly the original entry
restore_state = {
  entry_path: entry_path,
  char_name: char_name,
  game_code: game_code,
  original: original,
  delay: delay
}
File.open(state_path, 'wb') { |f| f.write(Marshal.dump(restore_state)) }

File.open(helper_path, 'w') do |f|
  f.write <<~RUBY
    # warlogin restore helper (auto-generated)
    state_path = ARGV[0]

    begin
      state = Marshal.load(File.binread(state_path))
      entry_path = state[:entry_path]
      char_name  = state[:char_name]
      game_code  = state[:game_code]
      original   = state[:original]
      delay      = state[:delay].to_i

      sleep(delay)

      entry_data =
        if File.exist?(entry_path)
          File.open(entry_path, 'r') do |file|
            begin
              Marshal.load(file.read.unpack('m').first)
            rescue
              []
            end
          end
        else
          []
        end

      idx = entry_data.index { |d| d.is_a?(Hash) && d[:char_name] == char_name && d[:game_code] == game_code }
      if idx
        entry_data[idx] = original
        File.open(entry_path, 'w') { |file| file.write([Marshal.dump(entry_data)].pack('m')) }
      end
    rescue
      # ignore
    ensure
      begin
        File.delete(state_path) if File.exist?(state_path)
      rescue
      end
      begin
        File.delete(__FILE__) if File.exist?(__FILE__)
      rescue
      end
    end
  RUBY
end

# ---- spawn helper detached so it survives this script ending ----
Process.spawn("\"#{rubyw}\" \"#{helper_path}\" \"#{state_path}\"")

exit
