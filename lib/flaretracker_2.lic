require 'yaml'

# Define constants for the script directory and flare patterns file
SCRIPTS_DIR = "#{$script_dir}"  # Lich's script directory
FLARE_PATTERNS_FILENAME = "flare_patterns.rb"
FLARE_PATTERNS_PATH = File.join(SCRIPTS_DIR, FLARE_PATTERNS_FILENAME)

# Function to notify player to download the file if missing
def notify_player_to_download_flare_patterns
  unless File.exist?(FLARE_PATTERNS_PATH)
    message = "#{FLARE_PATTERNS_FILENAME} is missing. Please download it using the command: \n\n" \
              "  ;repo download #{FLARE_PATTERNS_FILENAME}\n\n" \
              "in your game console to ensure the script functions correctly."
    echo(message)
    exit
  end
end

# Ensure flare_patterns.rb is present before proceeding
notify_player_to_download_flare_patterns

# Use require with the full path to ensure correct loading
require FLARE_PATTERNS_PATH  # Load the flare patterns after ensuring the file exists

=begin
	This script tracks and analyzes damage output and flare performance. It monitors and calculates real-time statistics like damage, average damage, and flare rate. The script displays this data in the familiar window, providing easy-to-read output with consistent formatting. 

	***The script only tracks standard flare messaging, if you have custom flare messaging the script will not track custom flares unless you edit it to track your custom flare messaging.***

	Must have Familiar Window open to see output.  Below is an example of output:
	Dispel Flare                   | DMG: 0       | HS: 50      | AVG: 13.33   | RATE: 16.3%
	Dispel Flare                   | DMG: 5       | HS: 50      | AVG: 12.81   | RATE: 17.2%
	Blink                          | DMG: 0       | HS: 0       | AVG: 0.00    | RATE:  5.3%
	Ensorcell AS CS                | DMG: 0       | HS: 0       | AVG: 0.00    | RATE: 12.6%
	Somnis                         | DMG: 0       | HS: 0       | AVG: 0.00    | RATE: 11.5%
	Telepathy LoreFlare            | DMG: 10      | HS: 25      | AVG: 11.34   | RATE: 33.0%
	Telepathy LoreFlare            | DMG: 5       | HS: 25      | AVG: 11.15   | RATE: 33.7%
	Blink                          | DMG: 0       | HS: 0       | AVG: 0.00    | RATE:  6.1%
	Telepathy LoreFlareDoT         | DMG: 81      | HS: 87      | AVG: 78.33   | RATE:  6.0%
	Dispel Flare                   | DMG: 30      | HS: 50      | AVG: 13.82   | RATE: 16.8%
	Ensorcell AS CS                | DMG: 0       | HS: 0       | AVG: 0.00    | RATE: 12.8%
	Telepathy LoreFlare            | DMG: 5       | HS: 25      | AVG: 10.97   | RATE: 33.0%
	Blink                          | DMG: 0       | HS: 0       | AVG: 0.00    | RATE:  6.7%

	Glossary:
	DMG:  The most recent damage the flare type inflicted.
	HS:   The highest damage in your record that the flare type has ever inflicted.
	AVG:  The average damage that the flare type has inflicted based on your records.
	RATE: The rate at which the flare type appears based on YOUR attack routine and records.
	***RATE is not respresentative of each flare types flare rate as intended by the GM that implemented it.  There's how something was designed and implemented and then how something actually works in actual combat due to your profession, training, gear, etc.***

	Script created with Chat GPT.

	1.0.0 (2024-09-7)
		- Initial release of the damage tracking script.
		- 88 different flares tracked.
		- Implemented real-time damage tracking, high score, average damage, and flare rate.
		- Displays statistics in the familiar window.
		- Automatically saves damage data and high scores between sessions.
=end

# Define file paths to store the damage data and high scores
data_dir = "#{$data_dir}#{XMLData.game}/#{Char.name}/"
damage_file_path = "#{data_dir}damage_data.yaml"
high_scores_file_path = "#{data_dir}high_scores.yaml"

# Create directories if they do not exist
Dir.mkdir("#{$data_dir}#{XMLData.game}") unless Dir.exist?("#{$data_dir}#{XMLData.game}")
Dir.mkdir(data_dir) unless Dir.exist?(data_dir)

# Initialize damage data and high scores
initial_damage_data = Hash.new { |hash, key| hash[key] = [] }
initial_high_scores = Hash.new(0)

# Load existing data or initialize new data
damage_data = File.exist?(damage_file_path) ? YAML.load_file(damage_file_path) || initial_damage_data : initial_damage_data
damage_data = initial_damage_data.merge(damage_data)  # Add missing keys if any

high_scores = File.exist?(high_scores_file_path) ? YAML.load_file(high_scores_file_path) || initial_high_scores : initial_high_scores
high_scores = initial_high_scores.merge(high_scores)  # Add missing keys if any

# Method to save the damage values to a file
def save_damage_data(damage_data, file_path)
  File.open(file_path, "w") { |file| file.write(damage_data.to_yaml) }
end

# Method to save the high scores to a file
def save_high_scores(high_scores, file_path)
  # Ensure high scores are saved as integers
  high_scores = high_scores.transform_values { |score| score.to_i }
  File.open(file_path, "w") { |file| file.write(high_scores.to_yaml) }
end

# Method to calculate the average of the damage values, ignoring zeros and nil values
def calculate_average(damage_values)
  # Select only numeric values greater than zero
  numeric_values = damage_values.select { |value| value.is_a?(Numeric) && value > 0 }
  return 0 if numeric_values.empty?
  # Calculate the average
  numeric_values.sum / numeric_values.size.to_f
end

# Method to calculate the appearance rate of each flare type compared to all flare types
def calculate_appearance_rate(flare_hits, total_flare_hits)
  return 0 if total_flare_hits == 0
  ((flare_hits.to_f / total_flare_hits) * 100).round(2)
end

# Method to send output to the familiar window
def echo_to_familiar_window(message)
  if $frontend =~ /stormfront|profanity/i
    fam_window_begin = "<pushStream id=\"familiar\" ifClosedStyle=\"watching\"/><output class=\"mono\"/>\n"
    fam_window_end = "\n<output class=\"\"/><popStream/>\r\n"
  else
    fam_window_begin = "\034GSe\r\n"
    fam_window_end = "\034GSf\r\n"
  end
  _respond("#{fam_window_begin}#{message}#{fam_window_end}")
end

# Method to display flare data in the familiar window with uniform spacing
def display_flare_data(flare_type, total_flare_damage, high_score, avg_damage, appearance_rate)
  max_flare_type_length = 30 # Set this to a value that works well with your display
  flare_type_display = flare_type.to_s.gsub('_', ' ').ljust(max_flare_type_length)

  # Ensure numeric values and format average damage to two decimal places
  total_flare_damage = total_flare_damage.to_i
  avg_damage = avg_damage.is_a?(Numeric) ? format('%.2f', avg_damage) : '0'
  high_score = high_score.to_i

  message = format(
    "%-#{max_flare_type_length}s | DMG: %-7d | HS: %-7d | AVG: %-7s | RATE: %4.1f%%",
    flare_type_display,
    total_flare_damage,
    high_score,
    avg_damage,
    appearance_rate
  )
  echo_to_familiar_window(message)
end

# Main loop to monitor game lines for flares
begin
  while true
    line = get

    # Check each pattern to see if the line matches any flare pattern
    FLARE_PATTERNS.each do |flare_type, pattern|
      if line =~ pattern
        
        if [:Xazkruvrixis, :Somnis, :SigilStaff, :Sigil_of_Binding, :Rusalkan, :Lathonian, :Ghezyte, :ForestArmor_WindGust, :ForestArmor_LeafSwirl, :ForestArmor_MudSling, :ForestArmor_WoodlandEmpathy, :Ethereal_Armor, :Dramatic_Drapery_Wondorous, :Dramatic_Drapery_Masquerade, :Bubble, :Blink, :Adamantine, :Ensorcell_Health, :Ensorcell_Mana, :Ensorcell_Spirit, :Ensorcell_Stamina, :Ensorcell_AS_CS, :Animalistic_Totem, :Bestial_Totem, :Shifting_Totem, :Feral_Totem, :Acuity_CatB].include?(flare_type)
          # Handle flares that don't do damage
          damage_data[flare_type] << nil  # Log occurrence without damage
          
          # Calculate and display statistics
          total_flare_hits = damage_data.values.flatten.size
          appearance_rate = calculate_appearance_rate(damage_data[flare_type].size, total_flare_hits)

          # Display data with zeros for DMG and AVG, and fetch high score
          display_flare_data(flare_type, 0, 0, 0, appearance_rate) 

          # Save updated data
          save_damage_data(damage_data, damage_file_path)
          save_high_scores(high_scores, high_scores_file_path)

        elsif flare_type.to_s.include?('DoT') || flare_type.to_s.include?('GEF') || flare_type.to_s.include?('Firewheel') || flare_type.to_s.include?('Greater_Rhimar')
          # Handle two-line flares (DoT, GEF, Firewheel)
          damage_line_1 = get
          if damage_line_1 =~ /\.\.\. (\d+) points? of damage!/
            damage_1 = damage_line_1.match(/\.\.\. (\d+) points? of damage!/)[1].to_i
            damage_line_2 = get
            damage_line_2 = get if damage_line_2 !~ /\.\.\. (\d+) points? of damage!/
            if damage_line_2 =~ /\.\.\. (\d+) points? of damage!/
              damage_2 = damage_line_2.match(/\.\.\. (\d+) points? of damage!/)[1].to_i
              total_flare_damage = damage_1 + damage_2
              
              # Track the flare occurrence
              damage_data[flare_type] << total_flare_damage

              # Update high score if necessary
              high_scores[flare_type] = total_flare_damage if total_flare_damage > high_scores[flare_type]

              # Calculate and display statistics
              total_flare_hits = damage_data.values.flatten.size
              avg_damage = calculate_average(damage_data[flare_type])
              appearance_rate = calculate_appearance_rate(damage_data[flare_type].size, total_flare_hits)

              # Display data with high score included
              display_flare_data(flare_type, total_flare_damage, high_scores[flare_type], avg_damage, appearance_rate)

              # Save updated data
              save_damage_data(damage_data, damage_file_path)
              save_high_scores(high_scores, high_scores_file_path)
            end
          end

        else
          # Handle flares where damage can occur on the second, third, or fourth line
          total_flare_damage = 0
          flare_counted = false

          # Loop through lines to find damage, count flare even if no damage is found
          loop do
            damage_line = get
            # Check if the line contains damage
            if damage_line =~ /\.\.\. (\d+) points? of damage!/
              total_flare_damage = damage_line.match(/\.\.\. (\d+) points? of damage!/)[1].to_i
              flare_counted = true
              break
            elsif damage_line =~ /You feel (\d+) mana surge into you!/
              total_flare_damage = damage_line.match(/You feel (\d+) mana surge into you!/)[1].to_i
              flare_counted = true
              break
            # Check for a condition that indicates the flare should be counted but has no damage
            elsif damage_line =~ /is unaffected|A hazy film coats|A murky veil surrounds|thorny barrier surrounding .* blocks|blinks and looks around in confusion for a moment|in time to deflect the elements harmlessly away from/
              flare_counted = true
              break
            end
          end

          if flare_counted
            # Track the flare occurrence
            damage_data[flare_type] << total_flare_damage

            # Update high score if necessary
            high_scores[flare_type] = total_flare_damage if total_flare_damage > high_scores[flare_type]

            # Calculate and display statistics
            total_flare_hits = damage_data.values.flatten.size
            avg_damage = calculate_average(damage_data[flare_type])
            appearance_rate = calculate_appearance_rate(damage_data[flare_type].size, total_flare_hits)

            # Display data with high score included
            display_flare_data(flare_type, total_flare_damage, high_scores[flare_type], avg_damage, appearance_rate)

            # Save updated data
            save_damage_data(damage_data, damage_file_path)
            save_high_scores(high_scores, high_scores_file_path)
          end
        end
        
        break # Stop checking further patterns once a match is found
      end
    end
  end
rescue Interrupt
  # Save data on script exit
  save_damage_data(damage_data, damage_file_path)
  save_high_scores(high_scores, high_scores_file_path)
  echo_to_familiar_window("Flare damage data and high scores saved. Exiting script.")
end
