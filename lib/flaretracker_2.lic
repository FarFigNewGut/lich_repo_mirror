hide_me
=begin

	This script tracks and analyzes a variety of flares, scripts, spells, and the lore benefits of spells that have a percentage chance to activate. It monitors and calculates real-time statistics like damage, average damage, and flare rate. The script displays this data in the familiar window, providing easy-to-read output with consistent formatting. 

	***The script only tracks standard flare messaging and custom flare messaging available from "A Fatal Afflares".  If you have customized your flares with messaging that required QC, you can update the flare_patterns.rb file to track your customized flare messaging.***

	Must have Familiar Window open to see output.  Below is an example of output:
	Rusalkan                     | DMG:   0 | HS:   0 | AVG:   0 | RATE:   4.4% | 1 per 10.6 ATTACKS
	ManaArmor ManaShield         | DMG:   0 | HS:   0 | AVG:   0 | RATE:   0.9% | 1 per 74.0 ATTACKS
	FA 1706                      | DMG:  10 | HS:  35 | AVG:  17 | RATE:  11.8% | 1 per  3.8 ATTACKS
	Telepathy LoreFlare          | DMG:  10 | HS:  30 | AVG:  12 | RATE:  26.8% | 1 per  1.7 ATTACKS
	Somnis                       | DMG:   0 | HS:   0 | AVG:   0 | RATE:  10.8% | 1 per  4.1 ATTACKS
	Dispel Flare                 | DMG:  40 | HS:  70 | AVG:  35 | RATE:  13.7% | 1 per  3.3 ATTACKS
	Rusalkan                     | DMG:   0 | HS:   0 | AVG:   0 | RATE:   4.7% | 1 per 10.1 ATTACKS

	Glossary:
	DMG:  The most recent damage the flare type inflicted.
	HS:   The highest damage in your record that the flare type has ever inflicted.
	AVG:  The average damage that the flare type has inflicted based on your records.
	RATE: The rate at which the flare type appears based on YOUR attack routine and records.
	
	'RATE' shows how often each flare type appears specifically for you in combat. Essentially, it indicates the frequency of each specific flare type when a flare occurs. For example, if 'Dispel Flare' has a rate of 18.3%, then 18.3% of the time when a flare happens, it will be a Dispel Flare. Another example, if you were a brand new player using only a basic drake falchion, 'Fire Flares' would show a rate of 100% for you, as it would be the only flare type you can generate.  Keep in mind that the fewer flares you have, the more skewed the data can be due to a smaller sample size.
	
	'FLARES per ATTACKS' is intended to provide a data point that is easy to understand by the player similar to how common flares are typically stated as flaring 1 time per 5 attacks for melee weapons and flaring 1 time per 8 attacks for runestaffs.  The biggest issue is whether this script successfully captures every attack where a flare type could occur and captures every time a flare type does occur.  The answer is more than likely, no it does not.
	
	Both of these statistics are personalized to your playstyle and varies based on factors like your profession, training, gear, and the total number of flare types you can generate. It reflects the frequency of each flare within your own combat actions, rather than a universal game-wide statistic. Have fun with the data but don't use it to start arguements.

	Script created with Chat GPT.

	1.0.0 (2024-09-07)
		- Initial release of the damage tracking script.
		- 88 different flares tracked.
		- Implemented real-time damage tracking, high score, average damage, and flare rate.
		- Displays statistics in the familiar window.
		- Automatically saves damage data and high scores between sessions.
	1.1.0 (2024-09-08)
		- Added flares per attack calculation back into output.
	1.2.0 (2024-09-10)
		- Added logic to update the high score only if the new damage value does not exceed the mean plus double the standard deviation (threshold = avg_damage + 2 * std_deviation).
		- Major re-work of mainloop to utilize timeout.
	1.3.0
		- Addition of active commands.
	1.4.0
		- Flare combo tracking added and will save your highest flare record and display in the familiar window upon starting and stopping the script.
		- Support for Killer Instinct announcer combo wav.files.  DM for .wav files.
		=========================!!! 5 FLARE SOLID COMBO !!! =========================
		1. Somnis                   | DMG:   0 | HS:   0 | AVG:   0 | RATE:   0.0% | 1 per  N/A ATTACKS
		2. Dispel Disruption        | DMG:   0 | HS:   0 | AVG:   0 | RATE:   0.0% | 1 per  N/A ATTACKS
		3. Dispel FluxCrit          | DMG:   0 | HS:   0 | AVG:   0 | RATE:   0.0% | 1 per  N/A ATTACKS
		4. Dispel FluxCrit          | DMG:   0 | HS:   0 | AVG:   0 | RATE:   0.0% | 1 per  N/A ATTACKS
		5. LuckTalisman Offensive   | DMG:   0 | HS:   0 | AVG:   0 | RATE:   0.0% | 1 per  N/A ATTACKS
		
	Active Commands (To be used while script is running):
		- ;send reset data (Erases combined_data.yaml which is where all your statistical data is stored.)
		- ;send main (Switch output to main window. Preference saved between sessions.)
		- ;send familiar (Switch output to familiar window. Preference saved between sessions.)
		- ;send stats all (Will listed all stats for all flare types)
		- ;send stats FLARE TYPE (Will list stats for the specific flare type or closest match)
		  EXAMPLE:
			>;send stats tele
			  --- sent: stats tele
			  Telepathy LoreFlare         | Total: 94   | Rate: 100.0% | 2.0         ATTACKS ]
			>;send stats rusal
			  --- sent: stats rusal
			  Rusalkan                    | Total:    5 | Rate: 100.0% |        37.6 ATTACKS ]

	Keep up to date on Discord and provide feedback.	
	https://discord.com/channels/226045346399256576/1282432287589400616

tags: tracking, item scripts, flares, data, abilities

=end

# Main loop to monitor game lines for flares
require 'yaml'
require 'win32/sound'
include Win32

# Define constants for the script directory and flare patterns file
SCRIPTS_DIR = "#{$script_dir}"  # Lich's script directory
FLARE_PATTERNS_FILENAME = "flare_patterns.rb"
FLARE_PATTERNS_PATH = File.join(SCRIPTS_DIR, FLARE_PATTERNS_FILENAME)

# Function to notify player to download the file if missing
def notify_player_to_download_flare_patterns
  unless File.exist?(FLARE_PATTERNS_PATH)
    message = "\n\n\n" \
              "************************************************************\n" \
              "*                                                          *\n" \
              "*   #{FLARE_PATTERNS_FILENAME} is missing.                *\n" \
              "*                                                          *\n" \
              "*   Please download it using the command:                 *\n" \
              "*                                                          *\n" \
              "*     ;repo download #{FLARE_PATTERNS_FILENAME}           *\n" \
              "*                                                          *\n" \
              "*   in your game console to ensure the script functions   *\n" \
              "*   correctly.                                            *\n" \
              "*                                                          *\n" \
              "************************************************************\n" \
              "\n\n\n"
    echo(message)
    exit
  end
end

# Ensure flare_patterns.rb is present before proceeding
notify_player_to_download_flare_patterns

# Use require with the full path to ensure correct loading
load FLARE_PATTERNS_PATH  # Load the flare patterns after ensuring the file exists

# Define file path to store the combined data
data_dir = "#{$data_dir}#{XMLData.game}/#{Char.name}/"
combined_data_file_path = "#{data_dir}flaredata.yaml"

# Create directories if they do not exist
Dir.mkdir("#{$data_dir}#{XMLData.game}") unless Dir.exist?("#{$data_dir}#{XMLData.game}")
Dir.mkdir(data_dir) unless Dir.exist?(data_dir)

# Initialize combined data structure
initial_combined_data = {
  'damage_data' => Hash.new { |hash, key| hash[key] = [] },
  'high_scores' => Hash.new(0),
  'total_attacks' => 0,
  'highest_combo' => { 'flare_count' => 0, 'label' => 'NONE' },  # Add this field to track the highest combo
  'user_preferences' => {
    'echo_window' => 'main',   # Default to 'main' if no preference is set
    'sounds_enabled' => true   # New preference to enable/disable sounds
  }
}

# Load existing combined data or initialize new data
combined_data = if File.exist?(combined_data_file_path)
                  YAML.load_file(combined_data_file_path) || initial_combined_data
                else
                  initial_combined_data
                end

damage_data = combined_data['damage_data']
high_scores = combined_data['high_scores']
total_attacks = combined_data['total_attacks']
echo_window = combined_data['user_preferences']['echo_window'] || 'main'  # Load echo preference
# Display the highest flare combo on startup
highest_combo = combined_data['highest_combo']
echo_to_familiar_window("\n" + "="*37 + "HIGHEST COMBO RECORD" + "="*37 + "\n" + " "*37 + "#{highest_combo['flare_count']} FLARE #{highest_combo['label']} COMBO" + "\n")

# Method to save the combined data to a file and ensure it is saved correctly
def save_combined_data(combined_data, file_path)
  begin
    File.open(file_path, "w") { |file| file.write(combined_data.to_yaml) }
    echo("Preferences successfully saved to #{file_path}.")  # Confirm successful save
  rescue StandardError => e
    echo("Failed to save preferences: #{e.message}")  # Handle any errors
  end
end

# Method to reset combined data to its initial state and save it
def reset_combined_data(file_path, initial_data)
  combined_data = initial_data.dup # Reset to initial state
  save_combined_data(combined_data, file_path) # Save the reset data
  combined_data # Return the reset data
end

# Method to calculate the average of the damage values, ignoring zeros and nil values
def calculate_average(damage_values)
  numeric_values = damage_values.select { |value| value.is_a?(Numeric) && value > 0 }
  return 0 if numeric_values.empty?
  numeric_values.sum / numeric_values.size.to_f
end

# Method to calculate the median of the damage values
def calculate_median(damage_values)
  numeric_values = damage_values.select { |value| value.is_a?(Numeric) && value > 0 }
  return 0 if numeric_values.empty?
  sorted = numeric_values.sort
  len = sorted.length
  (sorted[(len - 1) / 2] + sorted[len / 2]) / 2.0
end

# Method to calculate the standard deviation of the damage values
def calculate_standard_deviation(damage_values)
  numeric_values = damage_values.select { |value| value.is_a?(Numeric) && value > 0 }
  return 0 if numeric_values.empty?

  mean = calculate_average(numeric_values)
  variance = numeric_values.sum { |value| (value - mean) ** 2 } / numeric_values.size.to_f
  Math.sqrt(variance).round(2)
end

# Method to calculate damage distribution in defined ranges
def calculate_damage_distribution(damage_values)
  numeric_values = damage_values.select { |value| value.is_a?(Numeric) }

  ranges = {
    "0 - 9" => 0,
    "10 - 19" => 0,
    "20 - 29" => 0,
    "30 - 39" => 0,
    "40 - 49" => 0,
    "50 - 59" => 0,
    "60 - 69" => 0,
    "70 - 79" => 0,
    "80 - 89" => 0,
    "90 - 99" => 0,
    "100+" => 0
  }

  numeric_values.each do |value|
    case value
    when 0..9 then ranges["0 - 9"] += 1
    when 10..19 then ranges["10 - 19"] += 1
    when 20..29 then ranges["20 - 29"] += 1
    when 30..39 then ranges["30 - 39"] += 1
    when 40..49 then ranges["40 - 49"] += 1
    when 50..59 then ranges["50 - 59"] += 1
    when 60..69 then ranges["60 - 69"] += 1
    when 70..79 then ranges["70 - 79"] += 1
    when 80..89 then ranges["80 - 89"] += 1
    when 90..99 then ranges["90 - 99"] += 1
    else ranges["100+"] += 1
    end
  end

  ranges.reject { |_, count| count.zero? } # Skip ranges with no values
end

# Method to calculate the appearance rate of each flare type compared to all flare types
def calculate_appearance_rate(flare_hits, total_flare_hits)
  return 0 if total_flare_hits == 0
  ((flare_hits.to_f / total_flare_hits) * 100).round(2)
end

# Method to calculate flares per attack for each specific flare type
def calculate_flares_per_attack(flare_hits, total_attacks)
  # Returns "N/A" if there are no flare hits to avoid division by zero
  return "N/A" if flare_hits == 0 || total_attacks == 0
  # Calculate the flares per attack as occurrences of the specific flare type per total attacks
  "#{(total_attacks / flare_hits.to_f).round(1)}"
end

# Initialize the echo window to familiar by default
$echo_to_familiar_window = true

# Method to toggle between echoing to the familiar window or the main window
def toggle_echo_window(window, combined_data, file_path)
  if window == 'main'
    $echo_to_familiar_window = false  # Set to echo in main window
    combined_data['user_preferences']['echo_window'] = 'main'
    save_combined_data(combined_data, file_path)  # Force save the updated preference
    echo("Echo window set to main.")  # Echo in main window
  elsif window == 'familiar'
    $echo_to_familiar_window = true  # Set to echo in familiar window
    combined_data['user_preferences']['echo_window'] = 'familiar'
    save_combined_data(combined_data, file_path)  # Force save the updated preference
    echo_to_familiar_window("Echo window set to familiar.")  # Echo in familiar window
  else
    echo("Unknown echo window: #{window}. Please specify 'main' or 'familiar'.")
  end
end

# Method to send output to the correct window based on the current setting
def echo_flare(message)
  if $echo_to_familiar_window
    echo_to_familiar_window(message)
  else
    echo(message)
  end
end

# Method to send output specifically to the familiar window
def echo_to_familiar_window(message)
  if $frontend =~ /stormfront|profanity/i
    fam_window_begin = "<pushStream id=\"familiar\" ifClosedStyle=\"watching\"/><output class=\"mono\"/>\n"
    fam_window_end = "\n<output class=\"\"/><popStream/>\r\n"
  else
    fam_window_begin = "\034GSe\r\n"
    fam_window_end = "\034GSf\r\n"
  end
  _respond("#{fam_window_begin}#{message}#{fam_window_end}")
end

# Method to display flare data, adding a number for each flare in the combo
def display_flare_data(flare_type, total_flare_damage, high_score, avg_damage, appearance_rate, flares_per_attack, combo_position = nil)
  max_flare_type_length = 27 # Set this to a value that works well with your display

  # Add the combo position number (e.g., 1, 2, 3) if it's part of a combo
  if combo_position
    flare_type_display = "#{combo_position}. #{flare_type.to_s.gsub('_', ' ')}"
  else
    flare_type_display = flare_type.to_s.gsub('_', ' ')
  end
  flare_type_display = flare_type_display.ljust(max_flare_type_length)

  # Ensure all values are initialized and not nil
  total_flare_damage ||= 0
  high_score ||= 0
  avg_damage ||= 0.0
  appearance_rate ||= 0.0
  flares_per_attack ||= "N/A"  # Use "N/A" if flares_per_attack is nil or not available

  # Display the formatted flare data, ensuring numeric values are valid
  message = format(
    "%-#{max_flare_type_length}s | DMG: %3d | HS: %3d | AVG: %3s | RATE: %5.1f%% | 1 per %4s ATTACKS",
    flare_type_display,
    total_flare_damage,
    high_score,
    format('%.0f', avg_damage),  # Ensure avg_damage is a formatted number
    appearance_rate,
    flares_per_attack  # Flares per attack can be "N/A" or a number
  )

  # Output the message to the appropriate window
  echo_flare(message)
end

def display_statistics(damage_data, high_scores, total_attacks, show_explanatory_text = true)
  total_flare_hits = damage_data.values.flatten.size  # Calculate the total number of all flares

  # Separate flares into non-damaging and damaging, then sort each group alphabetically
  non_damaging_data = damage_data.select { |flare_type, _| NODMGFLARE_PATTERNS.include?(flare_type) }.sort.to_h
  damaging_data = damage_data.reject { |flare_type, _| NODMGFLARE_PATTERNS.include?(flare_type) }.sort.to_h

  # Display non-damaging flares first
  non_damaging_data.each do |flare_type, values|
    total_flares = values.size
    appearance_rate = calculate_appearance_rate(total_flares, total_flare_hits)
    max_flare_type_length = 27 # Set this to a value that works well with your display
    flare_type_display = flare_type.to_s.gsub('_', ' ').ljust(max_flare_type_length)
    flares_per_attack = calculate_flares_per_attack(total_flares, total_attacks) # Calculate for each flare type

    # Display for non-damaging flares
    message = format(
      "\n %-#{max_flare_type_length}s | Total: %4d | Rate: %4.1f%% | %11s ATTACKS ",
      flare_type_display,
      total_flares,
      appearance_rate,
      flares_per_attack
    )
    echo(message)
  end

  # Display damaging flares
  damaging_data.each do |flare_type, values|
    next if values.empty?

    # Calculate statistics
    avg_damage = calculate_average(values)
    median_damage = calculate_median(values)
    std_deviation = calculate_standard_deviation(values)
    distribution = calculate_damage_distribution(values)
    high_score = high_scores[flare_type]
    total_flares = values.size
    appearance_rate = calculate_appearance_rate(total_flares, total_flare_hits)
    flares_per_attack = calculate_flares_per_attack(total_flares, total_attacks) # Calculate for each flare type

    # Skip display if all values are zero
    next if high_score == 0 && avg_damage == 0 && median_damage == 0 && std_deviation == 0

    max_flare_type_length = 27 # Set this to a value that works well with your display
    flare_type_display = flare_type.to_s.gsub('_', ' ').ljust(max_flare_type_length)

    # Display for non-damaging flares
    message = format(
      "\n %-#{max_flare_type_length}s | Total: %-4d | Rate: %4.1f%% | %-11s ATTACKS ",
      flare_type_display,
      total_flares,
      appearance_rate,
      flares_per_attack
    )
    echo(message)
    # Display the results with separators for damaging flares
    echo("  High Score: #{high_score}")
    echo("  Average Damage: #{format('%.2f', avg_damage)}")
    echo("  Median Damage: #{format('%.2f', median_damage)}")
    echo("  Standard Deviation: #{format('%.2f', std_deviation)}")
    unless distribution.empty?
      echo("  Damage Distribution:")
      distribution.each do |range, count|
        echo("  #{range}: #{count}")
      end
    end
  end
  echo("\nTotal Attacks: #{total_attacks}\nEnd of flare type statistical output.")

  # Only show explanatory text if flag is true
  if show_explanatory_text
    echo("\n\nNote: 'RATE' shows how often each flare type appears specifically for you in combat. Essentially, it indicates the frequency of each specific flare type when a flare occurs. For example, if 'Dispel Flare' has a rate of 18.3%, then 18.3% of the time when a flare happens, it will be a Dispel Flare. Another example, if you were a brand new player using only a basic drake falchion, 'Fire Flares' would show a rate of 100% for you, as it would be the only flare type you can generate.  Keep in mind that the fewer flares you have, the more skewed the data can be due to a smaller sample size. 

    'FLARES per ATTACKS' is intended to provide a data point that is easy to understand by the player similar to how common flares are typically stated as flaring 1 time per 5 attacks for melee weapons and flaring 1 time per 8 attacks for runestaffs.  The biggest issue is whether this script successfully captures every attack where a flare type could occur and captures every time a flare type does occur.  The answer is more than likely, no it does not.

    Both of these statistics are personalized to your playstyle and vary based on factors like your profession, training, gear, and the total number of flare types you can generate. It reflects the frequency of each flare within your own combat actions, rather than a universal game-wide statistic. Have fun with the data but don't use it to start arguments.")
  end
end

# Method to find the closest match for a given partial input in the YAML keys
def find_closest_flare_type(partial_input, damage_data)
  # Normalize the input: replace spaces with underscores and convert to lowercase
  normalized_input = partial_input.downcase.gsub(' ', '_')

  # Find all potential matches
  matches = damage_data.keys.select do |key|
    key.to_s.downcase.include?(normalized_input)
  end

  # If we have exact matches or partial matches, return the closest one
  matches.min_by { |match| match.to_s.downcase.index(normalized_input) }
end

# Method to display statistics for all or specific flare types
def display_stats(command, damage_data, high_scores, total_attacks)
  if command.strip == 'stats all'
    display_statistics(damage_data, high_scores, total_attacks, true)
  elsif command.strip =~ /^stats\s+(.+)$/i
    partial_flare_type = $1.strip
    # Try to find the closest matching flare type
    closest_match = find_closest_flare_type(partial_flare_type, damage_data)

    if closest_match
      # If a closest match is found, display statistics for that flare type
      display_statistics({ closest_match => damage_data[closest_match] }, { closest_match => high_scores[closest_match] }, total_attacks, false)
    else
      echo("No matching flare type found for '#{partial_flare_type}'.")
    end
  else
    echo("Unknown command: #{command}")
  end
end

# Call display_statistics to show the data
display_statistics(damage_data, high_scores, total_attacks)

compiled_nodmg_patterns = NODMGFLARE_PATTERNS.map { |flare_type, pattern| [flare_type, Regexp.new(pattern)] }.to_h
compiled_dmg_patterns = DMGFLARE_PATTERNS.map { |flare_type, pattern| [flare_type, Regexp.new(pattern)] }.to_h
compiled_attack_patterns = ATTACK_PATTERNS.map { |flare_type, pattern| [flare_type, Regexp.new(pattern)] }.to_h

save_interval = 10  # Save every 10 events
event_counter = 0

# Function to ensure combined data is updated correctly
def update_combined_data(combined_data, damage_data, high_scores, total_attacks, highest_combo)
  combined_data['damage_data'] = damage_data
  combined_data['high_scores'] = high_scores
  combined_data['total_attacks'] = total_attacks
  combined_data['highest_combo'] = highest_combo  # Include highest_combo in the update
end

# Add variables to track flares between "Roundtime"
flare_count_between_roundtime = 0

# Define the groups for flare counts and their labels
flare_labels = {
    2 => "DOUBLE",
    3 => "TRIPLE",
    4 => "SUPER",
    5 => "HYPER",
    6 => "BRUTAL",
    7 => "MASTER",
    8 => "AWESOME",
    9 => "BLASTER",
    10 => "MONSTER",
    11 => "KING",
    12 => "KILLER",
    13 => "KILLER",
    14 => "KILLER",
    15 => "KILLER",
    16 => "KILLER",
    17 => "KILLER",
    18 => "KILLER",
    19 => "KILLER",
    20 => "ULTRA",
}

# Method to toggle sounds on and off
def toggle_sounds(combined_data, file_path)
  sounds_enabled = combined_data['user_preferences']['sounds_enabled']
  
  if sounds_enabled
    combined_data['user_preferences']['sounds_enabled'] = false
    echo_to_familiar_window("Sounds have been disabled.")
  else
    combined_data['user_preferences']['sounds_enabled'] = true
    echo_to_familiar_window("Sounds have been enabled.")
  end
  
  # Save the updated preferences
  save_combined_data(combined_data, file_path)
end

# Function to display the label for the flare count and play the corresponding sound
def display_flare_label(flare_count, combined_data, combined_data_file_path)
  # Define the paths to each sound file for different combo counts
wav_files = {
  2 => "C:\\Lich5\\kicombowavs\\ki_doublecombo.wav",
  3 => "C:\\Lich5\\kicombowavs\\ki_triplecombo.wav",
  4 => "C:\\Lich5\\kicombowavs\\ki_supercombo.wav",
  5 => "C:\\Lich5\\kicombowavs\\ki_hypercombo.wav",
  6 => "C:\\Lich5\\kicombowavs\\ki_brutalcombo.wav",
  7 => "C:\\Lich5\\kicombowavs\\ki_mastercombo.wav",
  8 => "C:\\Lich5\\kicombowavs\\ki_awesomecombo.wav",
  9 => "C:\\Lich5\\kicombowavs\\ki_blastercombo.wav",
  10 => "C:\\Lich5\\kicombowavs\\ki_monstercombo.wav",
  11 => "C:\\Lich5\\kicombowavs\\ki_kingcombo.wav",
  12 => "C:\\Lich5\\kicombowavs\\ki_killercombo.wav",
  13 => "C:\\Lich5\\kicombowavs\\ki_killercombo.wav",
  14 => "C:\\Lich5\\kicombowavs\\ki_killercombo.wav",
  15 => "C:\\Lich5\\kicombowavs\\ki_killercombo.wav",
  16 => "C:\\Lich5\\kicombowavs\\ki_killercombo.wav",
  17 => "C:\\Lich5\\kicombowavs\\ki_killercombo.wav",
  18 => "C:\\Lich5\\kicombowavs\\ki_killercombo.wav",
  19 => "C:\\Lich5\\kicombowavs\\ki_killercombo.wav",
  20 => "C:\\Lich5\\kicombowavs\\ki_ultracombo.wav"
}

  flare_labels = {
    2 => "DOUBLE",
    3 => "TRIPLE",
    4 => "SUPER",
    5 => "HYPER",
    6 => "BRUTAL",
    7 => "MASTER",
    8 => "AWESOME",
    9 => "BLASTER",
    10 => "MONSTER",
    11 => "KING",
    12 => "KILLER",
    13 => "KILLER",
    14 => "KILLER",
    15 => "KILLER",
    16 => "KILLER",
    17 => "KILLER",
    18 => "KILLER",
    19 => "KILLER",
    20 => "ULTRA"
  }
  
  label = flare_labels[flare_count]
  wav_file = wav_files[flare_count]

  if label
    echo_to_familiar_window("="*25 + "!!! #{flare_count} FLARE #{label} COMBO !!! " + "="*25)

    # Check if sounds are enabled before playing the corresponding WAV file
    if combined_data.dig('user_preferences', 'sounds_enabled') && wav_file && File.exist?(wav_file)
      Win32::Sound.play(wav_file)
    end
	
    # Ensure the highest combo is initialized to a safe value if nil
    highest_combo_count = combined_data.dig('highest_combo', 'flare_count') || 0

    # Only update and save if the new flare count is greater than the previous highest
    if flare_count > highest_combo_count
      combined_data['highest_combo'] = { 'flare_count' => flare_count, 'label' => flare_labels[flare_count] }
      echo_to_familiar_window("New highest combo: #{flare_count} FLARE #{flare_labels[flare_count]} COMBO!")

      # Save the updated data immediately
      save_combined_data(combined_data, combined_data_file_path)
    end
  end
end

# Track flare events
flare_events = []

# Adjust the time window for flare combos (e.g., 1 second)
flare_combo_time_window = 0.10

# Function to check if a flare is part of a combo
def is_flare_combo?(flare_events, current_time, time_window)
  recent_flares = flare_events.select { |event| current_time - event[:time] <= time_window }
  recent_flares.size > 1  # If more than 1 flare occurred within the time window, it's a combo
end

begin
  while true
    line = get
    case line.strip
    when 'main', 'familiar'
      toggle_echo_window(line, combined_data, combined_data_file_path)
	when 'sounds'  # Command to toggle sounds
      toggle_sounds(combined_data, combined_data_file_path)
    when /^stats all$/, /^stats\s+\S+$/i
      display_stats(line, damage_data, high_scores, total_attacks)
    when /^reset data$/i
      # Reset the data in real-time
      combined_data = reset_combined_data(combined_data_file_path, initial_combined_data)
      damage_data = combined_data['damage_data']
      high_scores = combined_data['high_scores']
      total_attacks = combined_data['total_attacks']
	  highest_combo = combined_data['highest_combo']
      echo("Combined data has been reset.")
    end

    # Handle attack patterns
    compiled_attack_patterns.each do |attack_type, pattern|
      if line =~ pattern
        total_attacks += 1
        event_counter += 1
        break # Stop checking once an attack pattern is found
      end
    end

    # Detect "Roundtime" and process the flare events
    if line =~ /Roundtime/i
      current_time = Time.now
      
      # Count the number of valid recent flares within the time window
      recent_flares = flare_events.select { |event| current_time - event[:time] <= flare_combo_time_window }
      flare_count = recent_flares.size

	# If multiple flares occurred, it's a combo
	if flare_count > 1
	  display_flare_label(flare_count, combined_data, combined_data_file_path) # Pass combined_data and file_path here
	end

      # Display each flare's data, numbering the flares if it's part of a combo
      recent_flares.each_with_index do |event, index|
        combo_position = flare_count > 1 ? (index + 1) : nil  # Number the flares if it's a combo
        display_flare_data(event[:type], event[:damage], event[:high_score], event[:avg_damage], event[:appearance_rate], event[:flares_per_attack], combo_position)
      end

      # Clear the flare events after processing
      flare_events.clear
      next
    end

    # Combine all three pattern hashes into one
    patterns = compiled_nodmg_patterns.merge(compiled_dmg_patterns).merge(compiled_attack_patterns)

    patterns.each do |flare_type, pattern|
      if line =~ pattern
        # Skip attack patterns
        next if compiled_attack_patterns.key?(flare_type)

        is_dot_flare = flare_type.to_s.include?('DoT')
        is_faura1706_flare = flare_type.to_s.include?('FAura1706')

        # Record the flare event with its timestamp and whether it's a DoT, FAura1706, or occurred while muckled
        flare_events << { type: flare_type, time: Time.now, dot: is_dot_flare, faura1706: is_faura1706_flare, muckled: muckled? }

        # Initialize damage data if not already present
        damage_data[flare_type] ||= []

        # Track the specific flare occurrence
        flare_hits = damage_data[flare_type].size

        # Calculate flares per attack correctly for each specific flare type in real-time
        flares_per_attack = calculate_flares_per_attack(flare_hits, total_attacks)

        # Determine if the current pattern is damaging or non-damaging
        is_damaging_pattern = compiled_dmg_patterns.key?(flare_type)
        is_nodmg_pattern = compiled_nodmg_patterns.key?(flare_type)

        # For non-damaging patterns, set combo_position to nil
        combo_position = nil

        # Handle non-damaging patterns immediately
        if is_nodmg_pattern && !Effects::Buffs.active?("Symbol of Dreams")
          damage_data[flare_type] << nil
          total_flare_hits = damage_data.values.flatten.size
          appearance_rate = calculate_appearance_rate(damage_data[flare_type].size, total_flare_hits)
          display_flare_data(flare_type, 0, 0, 0, appearance_rate, flares_per_attack, combo_position)
          break # Stop processing further to handle new patterns immediately
        end

        # Initialize damage_lines to capture damage information
        damage_lines = []

        # Handle two-line damage patterns first
        if is_damaging_pattern && (flare_type.to_s.include?('DoT') || flare_type.to_s.include?('GEF') || flare_type.to_s.include?('Firewheel') || flare_type.to_s.include?('Greater_Rhimar'))
          # Capture up to 2 lines of damage
          begin
            Timeout.timeout(0.03) do
              damage_count = 0
              5.times do  # Check up to 5 lines for a damage match
                damage_line = get

                # First priority: Check for new patterns to break immediately
                is_new_pattern = patterns.any? { |_, pat| damage_line =~ pat }
                if is_new_pattern
                  line = damage_line # Set the line to the new pattern line detected
                  break # Restart pattern matching with the new line
                end

                # Capture damage lines if no new pattern is detected
                if damage_line =~ /(\d+) points? of damage!/
                  damage_lines << damage_line.match(/(\d+) points? of damage!/)[1].to_i
                  damage_count += 1
                elsif damage_line =~ /AS\: .* vs DS\: .* with AvD|Roundtime|CS\: .* vs TD\: .* \+ CvA|is unaffected|with little effect|no effect|thorny barrier surrounding .* blocks|blinks and looks around in confusion for a moment|manages to dodge the licking flames|unharmed by the|scoffs at the/i
                  break # Handle specific no-damage or unrelated lines
                end
              end
            end
          rescue Timeout::Error
            # Timeout reached, stop capturing lines
          end

        # Handle one-line damage patterns second
        elsif is_damaging_pattern
          # Capture up to 1 line of damage, searching up to 3 lines for potential damage
          begin
            Timeout.timeout(0.015) do
              damage_count = 0
              3.times do  # Check up to 3 lines for a damage match
                damage_line = get

                # First priority: Check for new patterns to break immediately
                is_new_pattern = patterns.any? { |_, pat| damage_line =~ pat }
                if is_new_pattern
                  line = damage_line # Set the line to the new pattern line detected
                  break # Restart pattern matching with the new line
                end

                # Capture a single damage line
                if damage_line =~ /(\d+) points? of damage!/
                  damage_lines << damage_line.match(/(\d+) points? of damage!/)[1].to_i
                  damage_count += 1
                  break if damage_count >= 1 # Only capture up to 1 line for one-line patterns
                elsif damage_line =~ /AS\: .* vs DS\: .* with AvD|Roundtime|CS\: .* vs TD\: .* \+ CvA|is unaffected|with little effect|no effect|thorny barrier surrounding .* blocks|blinks and looks around in confusion for a moment|manages to dodge the licking flames|unharmed by the|scoffs at the/i
                  break # Handle specific no-damage or unrelated lines
                elsif damage_line =~ /You feel (\d+) mana surge into you|You gain (\d+) mana/i
                  damage_lines << damage_line.match(/You feel (\d+) mana surge into you|You gain (\d+) mana/i)[1].to_i
                  break
                end
              end
            end
          rescue Timeout::Error
            # Timeout reached, stop capturing lines
          end
        end

        # Log and display statistics for damaging patterns
        if damage_lines.any?
          total_flare_damage = damage_lines.sum
          damage_data[flare_type] << total_flare_damage

          if damage_data[flare_type].any? { |v| v.is_a?(Numeric) }
            avg_damage = calculate_average(damage_data[flare_type])
            std_deviation = calculate_standard_deviation(damage_data[flare_type])
            threshold = avg_damage + 4 * std_deviation
            high_scores[flare_type] = [total_flare_damage, high_scores[flare_type]].compact.max if total_flare_damage <= threshold
          else
            avg_damage = 0
            std_deviation = 0
          end

          # Display the damage data
          total_flare_hits = damage_data.values.flatten.size
          appearance_rate = calculate_appearance_rate(damage_data[flare_type].size, total_flare_hits)
          display_flare_data(flare_type, total_flare_damage, high_scores[flare_type], avg_damage, appearance_rate, flares_per_attack, combo_position)
        else
          damage_data[flare_type] << nil
          display_flare_data(flare_type, 0, 0, 0, calculate_appearance_rate(damage_data[flare_type].size, damage_data.values.flatten.size), flares_per_attack, combo_position)
        end

        event_counter += 1

        # Save data at intervals
        if event_counter >= save_interval
          update_combined_data(combined_data, damage_data, high_scores, total_attacks, highest_combo)
          save_combined_data(combined_data, combined_data_file_path)
          event_counter = 0
        end

        break # Stop checking further patterns
      end
    end

  end
rescue Interrupt
  # Update combined data before saving on script exit
  update_combined_data(combined_data, damage_data, high_scores, total_attacks, highest_combo)
  save_combined_data(combined_data, combined_data_file_path)
  echo_to_familiar_window("Flare damage data, high scores, and attack counts saved. Exiting script.")
end