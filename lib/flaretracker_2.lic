
=begin
	This script tracks and analyzes damage output and flare performance. It monitors and calculates real-time statistics like damage, average damage, and flare rate. The script displays this data in the familiar window, providing easy-to-read output with consistent formatting. 

	***The script only tracks standard flare messaging, if you have custom flare messaging the script will not track custom flares unless you edit the FLARE_PATTERNS.rb file to track your custom flare messaging.***

	Must have Familiar Window open to see output.  Below is an example of output:
	Rusalkan                     | DMG:   0 | HS:   0 | AVG:   0 | RATE:   4.4% | 1 per 10.6 ATTACKS
	ManaArmor ManaShield         | DMG:   0 | HS:   0 | AVG:   0 | RATE:   0.9% | 1 per 74.0 ATTACKS
	FA 1706                      | DMG:  10 | HS:  35 | AVG:  17 | RATE:  11.8% | 1 per  3.8 ATTACKS
	Telepathy LoreFlare          | DMG:  10 | HS:  30 | AVG:  12 | RATE:  26.8% | 1 per  1.7 ATTACKS
	Somnis                       | DMG:   0 | HS:   0 | AVG:   0 | RATE:  10.8% | 1 per  4.1 ATTACKS
	Dispel Flare                 | DMG:  40 | HS:  70 | AVG:  35 | RATE:  13.7% | 1 per  3.3 ATTACKS
	Rusalkan                     | DMG:   0 | HS:   0 | AVG:   0 | RATE:   4.7% | 1 per 10.1 ATTACKS

	Glossary:
	DMG:  The most recent damage the flare type inflicted.
	HS:   The highest damage in your record that the flare type has ever inflicted.
	AVG:  The average damage that the flare type has inflicted based on your records.
	RATE: The rate at which the flare type appears based on YOUR attack routine and records.
	***RATE is not respresentative of each flare types flare rate as intended by the GM that implemented it. This rate is unique to your playstyle and can vary significantly based on factors like profession, training, gear, and other variables. It reflects the frequency of each flare based on your individual combat actions, rather than a fixed game-wide statistic.***

	Script created with Chat GPT.

	1.0.0 (2024-09-07)
		- Initial release of the damage tracking script.
		- 88 different flares tracked.
		- Implemented real-time damage tracking, high score, average damage, and flare rate.
		- Displays statistics in the familiar window.
		- Automatically saves damage data and high scores between sessions.
	1.1.0 (2024-09-08)
		- Added flares per attack calculation back into output.
=end

require 'yaml'

# Define constants for the script directory and flare patterns file
SCRIPTS_DIR = "#{$script_dir}"  # Lich's script directory
FLARE_PATTERNS_FILENAME = "flare_patterns.rb"
FLARE_PATTERNS_PATH = File.join(SCRIPTS_DIR, FLARE_PATTERNS_FILENAME)

# Function to notify player to download the file if missing
def notify_player_to_download_flare_patterns
  unless File.exist?(FLARE_PATTERNS_PATH)
    message = "\n\n\n" \
              "************************************************************\n" \
              "*                                                          *\n" \
              "*   #{FLARE_PATTERNS_FILENAME} is missing.                *\n" \
              "*                                                          *\n" \
              "*   Please download it using the command:                 *\n" \
              "*                                                          *\n" \
              "*     ;repo download #{FLARE_PATTERNS_FILENAME}           *\n" \
              "*                                                          *\n" \
              "*   in your game console to ensure the script functions   *\n" \
              "*   correctly.                                            *\n" \
              "*                                                          *\n" \
              "************************************************************\n" \
              "\n\n\n"
    echo(message)
    exit
  end
end
# Ensure flare_patterns.rb is present before proceeding
notify_player_to_download_flare_patterns

# Use require with the full path to ensure correct loading
load FLARE_PATTERNS_PATH  # Load the flare patterns after ensuring the file exists

# Define file paths to store the damage data, high scores, and attack counts
data_dir = "#{$data_dir}#{XMLData.game}/#{Char.name}/"
damage_file_path = "#{data_dir}damage_data.yaml"
high_scores_file_path = "#{data_dir}high_scores.yaml"
attack_count_file_path = "#{data_dir}attack_count.yaml"

# Create directories if they do not exist
Dir.mkdir("#{$data_dir}#{XMLData.game}") unless Dir.exist?("#{$data_dir}#{XMLData.game}")
Dir.mkdir(data_dir) unless Dir.exist?(data_dir)

# Initialize damage data, high scores, and attack counts
initial_damage_data = Hash.new { |hash, key| hash[key] = [] }
initial_high_scores = Hash.new(0)
initial_attack_count = 0

# Load existing data or initialize new data
damage_data = File.exist?(damage_file_path) ? YAML.load_file(damage_file_path) || initial_damage_data : initial_damage_data
damage_data = initial_damage_data.merge(damage_data)  # Add missing keys if any

high_scores = File.exist?(high_scores_file_path) ? YAML.load_file(high_scores_file_path) || initial_high_scores : initial_high_scores
high_scores = initial_high_scores.merge(high_scores)  # Add missing keys if any

total_attacks = File.exist?(attack_count_file_path) ? YAML.load_file(attack_count_file_path) || initial_attack_count : initial_attack_count

# Method to save the damage values to a file
def save_damage_data(damage_data, file_path)
  File.open(file_path, "w") { |file| file.write(damage_data.to_yaml) }
end

# Method to save the high scores to a file
def save_high_scores(high_scores, file_path)
  # Ensure high scores are saved as integers
  high_scores = high_scores.transform_values { |score| score.to_i }
  File.open(file_path, "w") { |file| file.write(high_scores.to_yaml) }
end

# Method to save the attack count to a file
def save_attack_count(total_attacks, file_path)
  File.open(file_path, "w") { |file| file.write(total_attacks.to_yaml) }
end

# Method to calculate the average of the damage values, ignoring zeros and nil values
def calculate_average(damage_values)
  numeric_values = damage_values.select { |value| value.is_a?(Numeric) && value > 0 }
  return 0 if numeric_values.empty?
  numeric_values.sum / numeric_values.size.to_f
end

# Method to calculate the median of the damage values
def calculate_median(damage_values)
  numeric_values = damage_values.select { |value| value.is_a?(Numeric) && value > 0 }
  return 0 if numeric_values.empty?
  sorted = numeric_values.sort
  len = sorted.length
  (sorted[(len - 1) / 2] + sorted[len / 2]) / 2.0
end

# Method to calculate the standard deviation of the damage values
def calculate_standard_deviation(damage_values)
  numeric_values = damage_values.select { |value| value.is_a?(Numeric) && value > 0 }
  return 0 if numeric_values.empty?

  mean = calculate_average(numeric_values)
  variance = numeric_values.sum { |value| (value - mean) ** 2 } / numeric_values.size.to_f
  Math.sqrt(variance).round(2)
end

# Method to calculate damage distribution in defined ranges
def calculate_damage_distribution(damage_values)
  numeric_values = damage_values.select { |value| value.is_a?(Numeric) }

  ranges = {
    "0 - 9" => 0,
    "10 - 19" => 0,
    "20 - 29" => 0,
    "30 - 39" => 0,
    "40 - 49" => 0,
    "50 - 59" => 0,
    "60 - 69" => 0,
    "70 - 79" => 0,
    "80 - 89" => 0,
    "90 - 99" => 0,
    "100+" => 0
  }

  numeric_values.each do |value|
    case value
    when 0..9 then ranges["0 - 9"] += 1
    when 10..19 then ranges["10 - 19"] += 1
    when 20..29 then ranges["20 - 29"] += 1
    when 30..39 then ranges["30 - 39"] += 1
    when 40..49 then ranges["40 - 49"] += 1
    when 50..59 then ranges["50 - 59"] += 1
    when 60..69 then ranges["60 - 69"] += 1
    when 70..79 then ranges["70 - 79"] += 1
    when 80..89 then ranges["80 - 89"] += 1
    when 90..99 then ranges["90 - 99"] += 1
    else ranges["100+"] += 1
    end
  end

  ranges.reject { |_, count| count.zero? } # Skip ranges with no values
end

# Method to calculate the appearance rate of each flare type compared to all flare types
def calculate_appearance_rate(flare_hits, total_flare_hits)
  return 0 if total_flare_hits == 0
  ((flare_hits.to_f / total_flare_hits) * 100).round(2)
end

# Method to calculate flares per attack for each specific flare type
def calculate_flares_per_attack(flare_hits, total_attacks)
  # Returns "N/A" if there are no flare hits to avoid division by zero
  return "N/A" if flare_hits == 0 || total_attacks == 0
  # Calculate the flares per attack as occurrences of the specific flare type per total attacks
  "#{(total_attacks / flare_hits.to_f).round(1)}"
end

# Method to send output to the familiar window
def echo_to_familiar_window(message)
  if $frontend =~ /stormfront|profanity/i
    fam_window_begin = "<pushStream id=\"familiar\" ifClosedStyle=\"watching\"/><output class=\"mono\"/>\n"
    fam_window_end = "\n<output class=\"\"/><popStream/>\r\n"
  else
    fam_window_begin = "\034GSe\r\n"
    fam_window_end = "\034GSf\r\n"
  end
  _respond("#{fam_window_begin}#{message}#{fam_window_end}")
end

# Updated display_flare_data function to format flares_per_attack using %.1f
def display_flare_data(flare_type, total_flare_damage, high_score, avg_damage, appearance_rate, flares_per_attack)
  max_flare_type_length = 28 # Set this to a value that works well with your display
  flare_type_display = flare_type.to_s.gsub('_', ' ').ljust(max_flare_type_length)

  # Ensure numeric values and format average damage and flares per attack
  total_flare_damage = total_flare_damage.to_i
  avg_damage = avg_damage.is_a?(Numeric) ? format('%.0f', avg_damage) : '0'
  high_score = high_score.to_i

  # Format message using %.1f for Flares/Atk to ensure one decimal place
  message = format(
    "%-#{max_flare_type_length}s | DMG: %3d | HS: %3d | AVG: %3s | RATE: %5.1f%% | 1 per %4s ATTACKS",
    flare_type_display,
    total_flare_damage,
    high_score,
    avg_damage,
    appearance_rate,
    flares_per_attack  # Use %.1f in format to display one decimal place
  )
  echo_to_familiar_window(message)
end

def display_statistics(damage_data, high_scores, total_attacks)
  total_flare_hits = damage_data.values.flatten.size  # Calculate the total number of all flares

  # Separate flares into non-damaging and damaging, then sort each group alphabetically
  non_damaging_data = damage_data.select { |flare_type, _| NODMGFLARE_PATTERNS.include?(flare_type) }.sort.to_h
  damaging_data = damage_data.reject { |flare_type, _| NODMGFLARE_PATTERNS.include?(flare_type) }.sort.to_h

  # Display non-damaging flares first
  non_damaging_data.each do |flare_type, values|
    total_flares = values.size
    appearance_rate = calculate_appearance_rate(total_flares, total_flare_hits)
    max_flare_type_length = 28 # Set this to a value that works well with your display
    flare_type_display = flare_type.to_s.gsub('_', ' ').ljust(max_flare_type_length)
    flares_per_attack = calculate_flares_per_attack(total_flares, total_attacks) # Calculate for each flare type

    # Display for non-damaging flares
    message = format(
      "\n %-#{max_flare_type_length}s | Total: %4d | Rate: %4.1f%% | %11s ATTACKS ",
      flare_type_display,
      total_flares,
      appearance_rate,
      flares_per_attack
    )
    echo(message)
  end

  # Display damaging flares
  damaging_data.each do |flare_type, values|
    next if values.empty?

    # Calculate statistics
    avg_damage = calculate_average(values)
    median_damage = calculate_median(values)
    std_deviation = calculate_standard_deviation(values)
    distribution = calculate_damage_distribution(values)
    high_score = high_scores[flare_type]
    total_flares = values.size
    appearance_rate = calculate_appearance_rate(total_flares, total_flare_hits)
    flares_per_attack = calculate_flares_per_attack(total_flares, total_attacks) # Calculate for each flare type

    # Skip display if all values are zero
    next if high_score == 0 && avg_damage == 0 && median_damage == 0 && std_deviation == 0

    max_flare_type_length = 30 # Set this to a value that works well with your display
    flare_type_display = flare_type.to_s.gsub('_', ' ').ljust(max_flare_type_length)

    # Display for non-damaging flares
    message = format(
      "\n %-#{max_flare_type_length}s | Total: %-4d | Rate: %4.1f%% | %-11s ATTACKS ",
      flare_type_display,
      total_flares,
      appearance_rate,
      flares_per_attack
    )
    echo(message)
    #Display the results with separators for damaging flares
    echo("  High Score: #{high_score}")
    echo("  Average Damage: #{format('%.2f', avg_damage)}")
    echo("  Median Damage: #{format('%.2f', median_damage)}")
    echo("  Standard Deviation: #{format('%.2f', std_deviation)}")
    unless distribution.empty?
      echo("  Damage Distribution:")
      distribution.each do |range, count|
        echo("  #{range}: #{count}")
      end
    end
  end
  echo("\n\nEnd of flare type statistical output.\n\nTotal Attacks: #{total_attacks}")

  
  # Add explanation about RATE
  echo("\n\nNote: 'RATE' shows how often each flare type appears specifically for you in combat. Essentially, it indicates the frequency of each specific flare type when a flare occurs. For example, if 'Dispel Flare' has a rate of 18.3%, then 18.3% of the time when a flare happens, it will be a Dispel Flare. Another example, if you were a brand new player using only a basic drake falchion, 'Fire Flares' would show a rate of 100% for you, as it would be the only flare type you can generate.

Keep in mind that the fewer flares you have, the more skewed the data can be due to a smaller sample size. This rate is personalized to your playstyle and varies based on factors like your profession, training, gear, and the total number of flare types you can generate. It reflects the frequency of each flare within your own combat actions, rather than a universal game-wide statistic.")
end

# Call display_statistics to show the data
display_statistics(damage_data, high_scores, total_attacks)

# Main loop to monitor game lines for flares
begin
  while true
    line = get

    # Handle non-damaging flare patterns
    NODMGFLARE_PATTERNS.each do |flare_type, pattern|
      if line =~ pattern
        # Track the specific flare occurrence
        flare_hits = damage_data[flare_type].size

        # Calculate flares per attack correctly for each specific flare type in real-time
        flares_per_attack = calculate_flares_per_attack(flare_hits, total_attacks)

        # Handle non-damaging flares
        damage_data[flare_type] << nil  # Log occurrence without damage

        # Calculate and display statistics
        total_flare_hits = damage_data.values.flatten.size
        appearance_rate = calculate_appearance_rate(damage_data[flare_type].size, total_flare_hits)

        # Display data with zeros for DMG and AVG, and fetch high score
        display_flare_data(flare_type, 0, 0, 0, appearance_rate, flares_per_attack)

        # Save updated data
        save_damage_data(damage_data, damage_file_path)
        save_high_scores(high_scores, high_scores_file_path)

        break # Stop checking further patterns once a match is found
      end
    end

    # Handle damaging flare patterns
    DMGFLARE_PATTERNS.each do |flare_type, pattern|
      if line =~ pattern
        # Track the specific flare occurrence
        flare_hits = damage_data[flare_type].size

        # Calculate flares per attack correctly for each specific flare type in real-time
        flares_per_attack = calculate_flares_per_attack(flare_hits, total_attacks)

        if flare_type.to_s.include?('DoT') || flare_type.to_s.include?('GEF') || flare_type.to_s.include?('Firewheel') || flare_type.to_s.include?('Greater_Rhimar')
          # Handle two-line flares (DoT, GEF, Firewheel)
          damage_line_1 = get
          if damage_line_1 =~ /\.\.\. (\d+) points? of damage!/
            damage_1 = damage_line_1.match(/\.\.\. (\d+) points? of damage!/)[1].to_i
            damage_line_2 = get
            damage_line_2 = get if damage_line_2 !~ /\.\.\. (\d+) points? of damage!/
            if damage_line_2 =~ /\.\.\. (\d+) points? of damage!/
              damage_2 = damage_line_2.match(/\.\.\. (\d+) points? of damage!/)[1].to_i
              total_flare_damage = damage_1 + damage_2

              # Track the flare occurrence
              damage_data[flare_type] << total_flare_damage

              # Update high score if necessary
              high_scores[flare_type] = total_flare_damage if total_flare_damage > high_scores[flare_type]

              # Calculate and display statistics
              total_flare_hits = damage_data.values.flatten.size
              avg_damage = calculate_average(damage_data[flare_type])
              appearance_rate = calculate_appearance_rate(damage_data[flare_type].size, total_flare_hits)

              # Display data with high score included
              display_flare_data(flare_type, total_flare_damage, high_scores[flare_type], avg_damage, appearance_rate, flares_per_attack)

              # Save updated data
              save_damage_data(damage_data, damage_file_path)
              save_high_scores(high_scores, high_scores_file_path)
            end
          end

        else
          # Handle flares where damage can occur on the second, third, or fourth line
          total_flare_damage = 0
          flare_counted = false

          # Loop through lines to find damage, count flare even if no damage is found
          loop do
            damage_line = get
            # Check if the line contains damage
            if damage_line =~ /\.\.\. (\d+) points? of damage!/
              total_flare_damage = damage_line.match(/\.\.\. (\d+) points? of damage!/)[1].to_i
              flare_counted = true
              break
            elsif damage_line =~ /You feel (\d+) mana surge into you/i
              total_flare_damage = damage_line.match(/You feel (\d+) mana surge into you/i)[1].to_i
              flare_counted = true
              break
            # Check for a condition that indicates the flare should be counted but has no damage
            elsif damage_line =~ /is unaffected|A hazy film coats|A murky veil surrounds|thorny barrier surrounding .* blocks|blinks and looks around in confusion for a moment|in time to deflect the elements harmlessly away from/
              flare_counted = true
              break
            end
          end

          if flare_counted
            # Track the flare occurrence
            damage_data[flare_type] << total_flare_damage

            # Update high score if necessary
            high_scores[flare_type] = total_flare_damage if total_flare_damage > high_scores[flare_type]

            # Calculate and display statistics
            total_flare_hits = damage_data.values.flatten.size
            avg_damage = calculate_average(damage_data[flare_type])
            appearance_rate = calculate_appearance_rate(damage_data[flare_type].size, total_flare_hits)

            # Display data with high score included
            display_flare_data(flare_type, total_flare_damage, high_scores[flare_type], avg_damage, appearance_rate, flares_per_attack)

            # Save updated data
            save_damage_data(damage_data, damage_file_path)
            save_high_scores(high_scores, high_scores_file_path)
          end
        end

        break # Stop checking further patterns once a match is found
      end
    end

    # Track attack patterns
    if line =~ ATTACK_PATTERNS[:Attack]
      total_attacks += 1
      save_attack_count(total_attacks, attack_count_file_path) # Save the total attacks count
    end
  end
rescue Interrupt
  # Save data on script exit
  save_damage_data(damage_data, damage_file_path)
  save_high_scores(high_scores, high_scores_file_path)
  save_attack_count(total_attacks, attack_count_file_path) # Save the total attacks count
  echo_to_familiar_window("Flare damage data, high scores, and attack counts saved. Exiting script.")
end

