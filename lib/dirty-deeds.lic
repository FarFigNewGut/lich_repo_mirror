=begin
	
	This script can get deeds in the following towns:
	
	Landing - will use gems for deeds
	Icemule Trace - will use wands and lockpicks for deeds
	River's Rest - will use River's Rest gems for deeds
	
	The script also has a deed calculator built in.

	You like deeds right? Of course you do! Everyone does! But who likes to do all of the guess work of how many gems and which gems you need to drop in order to get a deed? No one!
	
	This script takes all of the guess work out of getting you those deeds! It will appraise all items to get their values, then it uses the Landing deed formula to calculate the lowest total value of items to use in order to get a deed.
	
	Just start up the script, fill out the settings, and watch'er go!

	########################################################
	Ways to contact me:
	In game: Dreaven
	Player's Corner: Tgo01
	Discord: Dreaven#6436
	Email: LordDreaven@gmail.com
	If you like my scripts feel free to send me a tip via Paypal at: LordDreaven@gmail.com
	########################################################
	
	Author: Dreaven
	Version: 14
	tags: deeds, deed, Landing, Icemule, River's Rest

=end

#For dwarf-cut rubies: I found their value when used as a deed gem to be more than 60,673 and less than 61,800 silvers.

class DirtyDeedsMain
	def self.update_version_history
		label = @info["Labels"]["Version Text"]
		label.wrap = true
		label.xalign = 0
		label.yalign = 0
		label.markup = <<~MARKUP
			<span font_family="monospace">
			Version 14:
			  New feature and setting:
			    There is an option to have script buy dwarf-cut rubies
			    "Auto Multiplier" uses 10x for rubies and it seems accurate
				
			Version 13:
			  ;dirty-deeds has had a complete make over!
			  -A GUI has been added
			  -Script now uses the correct Landing formula
			  -Option to use silver if doing so costs less than using items
			  -A stats page that keeps track of all sorts of fun stats
			  -Old code has been cleaned up
			  -Appraised item values are saved until you log off
			  -Deed calculator
			  -Easier to setup the settings
			  -More detailed information about each item used for a deed
			  -More accurate calculations to use as little value as possible
			    Fewer than 18 items the script is very, very accurate
			    18+ items the script is still accurate, just not as accurate
			</span>
		MARKUP
	end
	
	@info = {}
	@stats = {}
	hashes = [ "Grids", "Labels", "Buttons", "Menus", "Spin Buttons", "Calculator Spin Buttons", "Checkboxes", "Entries" ]
	hashes.each{ |name| @info[name] = {} }
	@info["Instructions Array"]				= []
	@save_file								= "Dirty Deeds Settings.json"
	@stats_save_file						= "Dirty Deeds Stats.json"
	@saved_settings							= {}
	@character_settings						= nil
	@info["Landing Bank Room"]				= "400" #There is another bank close to where you buy dwarf rubies. I want script to always use this bank.
	@info["All Save Items"]					= []
	@info["Auto Multiplier Lower Multi"]	= 4.0
	@info["Auto Multiplier Higher Multi"]	= 10.0
	@info["Dwarf Ruby Order"]				= 14
	@info["Dwarf Ruby Room"]				= "9269"
	@info["Dwarf Ruby Cost"] 				= 4500
	@info["Dwarf Ruby Original Value"]		= 6000
	@item_data ||= {} #This saves item data beween sessions so the same item doesn't need to be appraised over and over again.
	
	@all_riverrest_gems = "amethyst clam shell|angulate wentletrap shell|beige clam shell|black helmet shell|black-spined conch shell|blue-banded coquina shell|bright noble pectin shell|blue periwinkle shell|candystick tellin shell|checkered chiton shell|crown conch shell|crown-of-Charl shell|dark brown triton shell|dovesnail shell|egg cowrie shell|emperor's crown shell|empress's crown shell|fluted limpet shell|giant paper nautilus shell|golden cowrie shell|golden triton shell|polished hornsnail shell|piece of iridescent mother-of-pearl|king helmet shell|iridescent tempest shell|large chipped clam shell|large moonsnail shell|lavender nassa shell|leopard cowrie shell|lynx cowrie shell|marlin spike shell|multi-colored snail shell|opaque spiral shell|pearl nautilus shell|pink-banded coquina shell|pink clam shell|polished batwing chiton shell|polished black tegula shell|polished green abalone shell|polished red abalone shell|polished silver abalone shell|purple-cap cowrie shell|queen helmet shell|red helmet shell|ruby-lined nassa shell|sea urchin shell|silvery clam shell|snake-head cowrie shell|snow cowrie shell|Solhaven Bay scallop shell|sparkling silvery conch shell|speckled conch shell|spiny siren's-comb shell|spiral turret shell|split-back pink conch shell|striated abalone shell|sundial shell|three-lined nassa shell|tiger cowrie shell|tiger-striped nautilus shell|translucent golden spiral shell|yellow-banded coquina shell|yellow helmet shell|white clam shell|white gryphon's wing shell|Kezmonian honey beryl|Selanthan bloodjewel|uncut star-of-Tamzyrr diamond|dwarf-cut sapphire"
	
	@all_icemule_items = "oaken wand|polished bloodwood wand|twisted wand|smooth bone wand|clear glass wand|pale thanot wand|iron wand|silver wand|aquamarine wand|golden wand|metal wand|green coral wand|smooth amber wand|slender blue wand|crystal wand|lockpick"
	
	@info["All Towns"] = [ "Landing", "Icemule", "River's Rest" ]
	
	save_text = "Click this button to save your current settings, including your 'Keep' settings. These will be loaded the next time you start the script."
	keep_text_info = "\n\nYou must click the 'Save' button to save any changes you make."
	@tooltips = {
		"Buy Dwarf Rubies" => "Check this box if you don't want to use your own gems and instead want to buy dwarf-cut rubies for deeds.\n\nThrough my own testing I have found a #{@info["Auto Multiplier Higher Multi"]}x multiplier works well with dwarf-cut rubies.\n\nNOTE: the 'Use Silver' setting DOES NOT work with this setting.\n\nNOTE: This setting only works in the Landing.",
		"Confirm Checkbox" => "Check this box to see a list of items which will be used for each deed attempt.\n\nYou will then have the option to Confirm the list and try for a deed, or Decline the list and don't use any of those items in deed attempts.",
		"Auto Multiplier" => "Items are worth more than their appraised value when using them for a deed, but the exact multiplier is unknown.\n\nThrough my own testing it seems items with an appraised value of less than 1000 silvers have a #{@info["Auto Multiplier Lower Multi"]}x multiplier and items with a value greater than 1000 have a #{@info["Auto Multiplier Higher Multi"]}x multiplier.\n\nCheck this box to automatically use these multipliers for each item. This means the 'Item Multiplier' setting will be completely ignored.\n\nUncheck this box to instead use the value in the 'Item Multiplier' setting for all items.\n\nThis setting gives dwarf-cut rubies a #{@info["Auto Multiplier Higher Multi"]}x multiplier.\n\nNOTE: This setting only works in the Landing. For any town outside of Landing the 'Item Multiplier' will always be used, regardless of this setting.",
		"Use Silver Checkbox" => "If this is checked when attempting to get a deed:\n\nIn Landing: If using silvers would cost less than the combined value of all items, the script will ask if you would rather skip using the items and instead run to the bank to get silvers and use silvers to get a deed.\n\nIn towns other than Landing: The script will tell you if using silvers is less than the combined value of all items, but it won't use silvers automatically. It will just give you the option to use the current items or skip them.",
		"Town List" => "Select the town you want to get a deed in.",
		"Container List" => "Select the container where all of the items you want to use to get deeds are inside of.",
		"Item Multiplier" => "The Landing deed formula in silvers is known.\n\nWhat is known about using items is items are worth more than their value when getting deeds, but the exact multipler is not known.\n\nYou can choose what multipler to assign to items here.\n\nIf you're having trouble getting deeds try setting this value lower.",
		"Deeds Wanted" => "Enter how many deeds you want to get here.",
		"Normal Experience" => "Enter how much NORMAL experience (NOT including Ascension Experience) you want to calculate for here.",
		"Starting Deeds" => "Enter the number of starting deeds you want to calculate for here.",
		"Ending Deeds" => "Enter the number of ending deeds you want to calculate for here.",
		"Calculator Multiplier" => "Enter the item value multiplier you want to calculate for here.",
		"Save" => save_text,
		"Keep Save" => save_text,
		"Defaults" => "Click this button to set all settings back to their original defaults.",
		"Get Deeds" => "Click this button to get some deeds!",
		"Stop" => "Click this button to stop the script from doing what it is doing as soon as possible.",
		"Confirm" => "Click this button to confirm you want to use the current list of items to attempt to get a deed.",
		"Decline" => "Click this button to decline the current list of items and move on to the next set of items.",
		"Use Silver" => "Click this button to grant permission to use silver when prompted.",
		"Keep Add" => "Enter the full or partial name of an item you want to keep then click the button to add it to the list of items you don't want to use for a deed.#{keep_text_info}",
		"Keep Remove" => "Enter the name of an item you want to remove from the list of items to keep then click the button to remove it from the list.#{keep_text_info}",
		"Keep Remove All" => "Click this button to remove all items from the list of items to keep.#{keep_text_info}",
	}
	
	Thread.new{
		loop{
			wait_until{ @info["Get Deeds"] }
			@info["Buttons"]["Stop"].sensitive = true
			hashes = [ @info["Buttons"], @info["Menus"], @info["Spin Buttons"], @info["Calculator Spin Buttons"], @info["Checkboxes"], @info["Entries"] ]
			hashes.each{ |hash| hash.each{ |widget_name, widget| widget.sensitive = false if widget_name != "Stop" } }
			@info["Auto Multiplier"]		= nil if @info["Current Town"] != "Landing" #This setting only works in Landing.
			@info["Buy Dwarf Rubies"]		= nil if @info["Current Town"] != "Landing" #This setting only works in Landing.
			@info["Use Silver"]				= nil if @info["Buy Dwarf Rubies"] #"Use Silver" setting doesn't work with the "Buy Dwarf Rubies" setting.
			@info["Total Original Value"]	= 0
			@info["Total Appraised Value"]	= 0
			@info["Total Multiplied Value"]	= 0
			@info["Lost Appraised Value"]	= 0 #The total appraised value of items used in failed deed attempts.
			@info["Total Silver Used"]		= 0
			@info["Total Silver Saved"]		= 0 #Silver saved by using silver instead of items.
			@info["Lost Silver"]			= 0 #Silver lost in failed deed attempts. This should always be 0 since the deed formula is accurate when using silver.
			Thread.new{
				get_item_values if @info["STOP"].nil?
				get_a_deed if @info["STOP"].nil? && @info["All Item Stats"].any?
				GLib::Idle.add do
					hashes.each{ |hash| hash.each{ |widget_name, widget| widget.sensitive = true if widget_name !~ /^(Confirm|Decline|Stop|Use Silver)$/ } }
					@info["Buttons"]["Stop"].sensitive = false
					false
				end
			}
			@info["Get Deeds"] = nil
			sleep 1
		}
	}
	
	def self.save_settings
		File.open("#{@save_file}.lock", File::RDWR | File::CREAT){ |lock_file|
			begin
				lock_file.flock(File::LOCK_EX)
				
				settings = {}
				@info["Menus"].each{ |name, _| settings[name] = @info["Menus"][name].active_text }
				@info["Spin Buttons"].each{ |name, _|
					if @info["Spin Buttons"][name].is_a?(Integer)
						settings[name] = @info["Spin Buttons"][name].value.to_i
					else
						settings[name] = @info["Spin Buttons"][name].value.round(1)
					end
				}
				
				@info["Checkboxes"].each{ |name, _|
					if @info["Checkboxes"][name].active?
						settings[name] = "Yes"
					else
						settings[name] = "No"
					end
				}

				@saved_settings[Char.name] = settings
				@saved_settings["Keep Settings"] = @info["All Save Items"]
				File.open(@save_file, 'w'){ |file| file.write(JSON.pretty_generate(@saved_settings)) }
				respond ";dirty-deeds settings saved."
			ensure
				lock_file.flock(File::LOCK_UN)
			end
		}
	end
	
	def self.load_settings
		File.open("#{@save_file}.lock", File::RDWR | File::CREAT){ |lock_file|
			begin
				lock_file.flock(File::LOCK_SH)
				if File.exist?(@save_file)
					@saved_settings = JSON.parse(File.read(@save_file))
					@character_settings		= @saved_settings[Char.name]
					@info["All Save Items"]	= @saved_settings["Keep Settings"] if @saved_settings["Keep Settings"]
					respond ";dirty-deeds settings loaded."
				end
			ensure
				lock_file.flock(File::LOCK_UN)
			end
		}
	end
	
	def self.save_stats
		File.open("#{@stats_save_file}.lock", File::RDWR | File::CREAT){ |lock_file|
			begin
				lock_file.flock(File::LOCK_EX)
				if (@stats[Char.name]["Deeds Gained With Items"] > 0) || (@stats[Char.name]["Deeds Gained With Silver"] > 0) || (@stats[Char.name]["Deeds Gained With Dwarf Rubies"]) #Only save data if the character has gained at least 1 deed.
					File.open(@stats_save_file, 'w'){ |file| file.write(JSON.pretty_generate(@stats)) }
					respond ";dirty-deeds stats saved."
				end
			ensure
				lock_file.flock(File::LOCK_UN)
			end
		}
	end
	
	def self.load_stats
		File.open("#{@stats_save_file}.lock", File::RDWR | File::CREAT){ |lock_file|
			begin
				lock_file.flock(File::LOCK_SH)
				if File.exist?(@stats_save_file)
					@stats = JSON.parse(File.read(@stats_save_file))
					respond ";dirty-deeds stats loaded."
				end
			ensure
				lock_file.flock(File::LOCK_UN)
			end
		}
		@stats[Char.name] ||= {}
		stat_names = [ "Lost Silver", "Lost Appraised Value", "Total Silver Used", "Total Silver Saved", "Total Original Value", "Total Appraised Value", "Deeds Gained With Items", "Deeds Gained With Silver", "Total Needed", "Silvers Spent On Dwarf Rubies", "Deeds Gained With Dwarf Rubies", "Silvers Lost With Dwarf Rubies", "Dwarf Ruby Deed Fails", "Silver Deed Fails", "Item Deed Fails" ]
		stat_names.each{ |name| @stats[Char.name][name] ||= 0 }
	end
	
	def self.set_default_settings
		@info["Menus"].each{ |_, menu| menu.active = 0 }
		@info["Spin Buttons"]["Item Multiplier"].value = 3.0
		@info["Spin Buttons"]["Deeds Wanted"].value = 10
		@info["Checkboxes"].each{ |_, check_box| check_box.active = false }
	end
	
	#Since the deed formula uses what the character's level would be in GS3, this section calculates the character's GS3 level based on their NORMAL experience. The formula does NOT count ascension experience.
	def self.get_gs_3_level(experience)
		level = 0
		remaining = experience

		level_tiers = [
			[50_000, 10_000],
			[100_000, 20_000],
			[150_000, 30_000],
			[200_000, 40_000]
		]

		level_tiers.each do |tier_size, step|
			break if remaining <= 0
			used = [remaining, tier_size].min
			level += used / step
			remaining -= used
		end

		if remaining > 0
			level += remaining / 50_000
		end

		level
	end

	#Calculate total trade bonus and get necessary variables based on the town getting deeds in.
	def self.trade_bonus_and_town_information
		#Calculate base trading bonus before any race/town bonus.
		if Skills.to_bonus(Skills.trading) == 0
			bonus = 0
		else
			trading_calc = (Skills.to_bonus(Skills.trading) + Stats.enhanced_inf[1]) / 12
			bonus = [trading_calc, 0].max
		end
		@info["Trading Bonus"] = [bonus, 28].min #Trading cap via Trading and Influece is capped at 28%.
		#

		if @info["Current Town"] == "Landing"
			@info["Trading Bonus"] += 5 if Char.race =~ /Giant|Halfling|Half\-Elf|Dark Elf|Forest Gnome/i
			@info["Deed Room"] = "4045"
			@info["Appraise Shop"] = "1776"
		elsif @info["Current Town"] == "Icemule"
			@info["Trading Bonus"] += 5 if Char.race =~ /Halfling|Krolvin|Sylvan/i
			@info["Deed Room"] = "23547"
			@info["Appraise Shop"] = "2464"
		elsif @info["Current Town"] == "River's Rest"
			@info["Trading Bonus"] += 5 if Char.race =~ /Human|Krolvin/i
			@info["Deed Room"] = "10854"
			@info["Appraise Shop"] = "10935"
		end
	end
	
	#Go to the deed room.
	def self.go_to_deed_room
		Script.kill("go2") if running? "go2"
		until Room.current.id.to_s == @info["Deed Room"]
			move 'out' if Room.current.id.nil?
			Script.run("go2", @info["Deed Room"])
			break if Room.current.id.to_s == @info["Deed Room"]
			respond "Someone might be in the deed room at the moment. Trying again."
		end
		fput "close door" if @info["Current Town"] == "Icemule"
	end

	#Set variable with list of all worn container names and their ID values.
	def self.set_worn_containers(containers)
		@info["Worn Containers"] = {}
		list ||= %r{<a exist=(?:'|")(?<id>.*?)(?:'|") noun=(?:'|")(?<noun>.*?)(?:'|")>(?<name>.*?)</a>}
		containers.each { |container| container.scan(list).each { |id, noun, name| @info["Worn Containers"][name] = id } }
	end
	
	def self.must_kneel
		until kneeling?
			waitrt?
			fput "kneel"
			sleep 0.2
		end
	end
	
	def self.must_stand
		until standing?
			waitrt?
			fput "stand"
			sleep 0.1
		end
	end
	
	def self.perform_deed_actions(hash)
		if @info["Current Town"] == "Landing"
			go_to_deed_room
			2.times{ fput "hit chime with mallet" }
			must_kneel
			if @info["Permission Granted"] == "Use Silver"
				fput "drop #{@info["Silvers Needed For Deed"]} silver"
			else
				hash.each{ |item_id, _|
					fput "get ##{item_id}"
					fput "drop ##{item_id}"
				}
			end
			fput "hit chime with mallet"
			Script.kill("go2") if running? "go2"
			Script.run("go2", "4044")
		elsif @info["Current Town"] == "Icemule"
			fput "pull chain"
			fput "open drawer"
			hash.each{ |item_id, _|
				fput "get ##{item_id}"
				fput "put ##{item_id} in drawer"
			}
			fput "close drawer"
			fput "open door"
			fput "close door"
		elsif @info["Current Town"] == "River's Rest"
			must_stand
			must_kneel
			waitrt?
			2.times{ fput "look in pool" }
			waitrt?
			fput "touch pool"
			hash.each{ |item_id, _|
				fput "get ##{item_id}"
				fput "put ##{item_id} in pool"
			}
			fput "touch pool"
			while line = get
				if line =~ /He smiles sadly at you/
					break
				elsif line =~ /You are welcome to my garden/
					until checkright.nil?
						waitrt?
						fput "stow right" if checkright
						sleep 0.1
					end
					fput "touch flower"
					fput "get seed"
					fput "plant seed"
					must_stand
					move 'out'
					break
				end
			end
		end
	end
	
	def self.get_landing_bank_balance
		balance = 0
		Script.kill("go2") if running? "go2"
		Script.run("go2", @info["Landing Bank Room"])
		fput "deposit all"
		fput "check balance"
		while line = get
			if line =~ /Your balance is currently at (.*) silver/
				balance = $1.delete(",").to_i
				break
			elsif line =~ /you don't seem to have an open account here./
				balance = 0
				break
			end
		end
		balance
	end
	
	def self.update_running_totals
		deeds 						= @info["Deeds Gained"]
		if deeds > 0
			total_original			= @info["Total Original Value"]
			total_appraised			= @info["Total Appraised Value"]
			total_multiplied		= @info["Total Multiplied Value"]
			average_original_deed	= total_original / deeds
			average_appraised_deed	= total_appraised / deeds
			average_multiplied_deed	= total_multiplied / deeds
			silver_used 			= @info["Total Silver Used"]
			silver_saved 			= @info["Total Silver Saved"]
			appraised_lost 			= @info["Lost Appraised Value"]
			silver_lost				= @info["Lost Silver"]
			@info["Instructions Array"] << "Total Deeds Gained:     #{deeds}"
			if silver_used > 0
				@info["Instructions Array"] << "Total Silver Used:      #{add_commas(silver_used)}"
				@info["Instructions Array"] << "Total Silver Saved:     #{add_commas(silver_used)} (saved by using silver instead of items)"
			end
			@info["Instructions Array"] << "Total Original Value:   #{add_commas(total_original)} (average per deed: #{add_commas(average_original_deed)})"
			@info["Instructions Array"] << "Total Appraised Value:  #{add_commas(total_appraised)} (average per deed: #{add_commas(average_appraised_deed)})"
			@info["Instructions Array"] << "Total Multiplied Value: #{add_commas(total_multiplied)} (average per deed: #{add_commas(average_multiplied_deed)})"
			@info["Instructions Array"] << "Appraised Value Lost:   #{add_commas(appraised_lost)} (lost to failed deed attempts)" if appraised_lost > 0
			@info["Instructions Array"] << "Silver Lost:            #{add_commas(silver_lost)} (lost to failed deed attempts)" if silver_lost > 0
		end
	end
	
	def self.days_months_years(total_days)
		years		= total_days / 365
		days_left	= total_days % 365

		months		= days_left / 30
		days		= days_left % 30

		[years, months, days]
	end

	def self.plural_or_not(text, number)
		number == 1 ? text : "#{text}s"
	end
	
	#Update stats.
	def self.update_all_stats
		label = @info["Labels"]["Stats Text"]
		stats = @stats[Char.name]
		if (stats["Deeds Gained With Items"] == 0) && (stats["Deeds Gained With Silver"] == 0) && (stats["Deeds Gained With Dwarf Rubies"] == 0)
			label.text = "Get a deed to start tracking stats."
		else
			start_date				= stats["Start Date"]
			start_date				= Time.parse(stats["Start Date"]) if stats["Start Date"].is_a?(String)
			total_days				= (((Time.now - start_date) / 86_400).to_i) + 1
			years, months, days	 	= days_months_years(total_days)
			year_text				= plural_or_not("Year", years)
			month_text				= plural_or_not("Month", months)
			day_text				= plural_or_not("Day", days)
			
			item_deeds				= stats["Deeds Gained With Items"]
			silver_deeds			= stats["Deeds Gained With Silver"]
			dwarf_deeds				= stats["Deeds Gained With Dwarf Rubies"]
			total_deeds				= item_deeds + silver_deeds + dwarf_deeds
			
			item_fails				= stats["Item Deed Fails"]
			silver_fails			= stats["Silver Deed Fails"]
			dwarf_fails				= stats["Dwarf Ruby Deed Fails"]
			total_fails				= item_fails + silver_fails + dwarf_fails
			
			item_total_attempts		= item_deeds + item_fails
			silver_total_attempts	= silver_deeds + silver_fails
			dwarf_total_attempts	= dwarf_deeds + dwarf_fails
			total_attempts			= item_total_attempts + silver_total_attempts + dwarf_total_attempts
			
			success_rates = {
				"Item Success Rate"		=> "N/A",
				"Silver Success Rate"	=> "N/A",
				"Dwarf Success Rate"	=> "N/A",
				"Total Success Rate"	=> "N/A",
			}
				
			success_rates["Item Success Rate"]		= ((item_deeds.to_f / item_total_attempts) * 100).round(2)		if item_deeds > 0
			success_rates["Silver Success Rate"]	= ((silver_deeds.to_f / silver_total_attempts) * 100).round(2)	if silver_deeds > 0
			success_rates["Dwarf Success Rate"]		= ((dwarf_deeds.to_f / dwarf_total_attempts) * 100).round(2)	if dwarf_deeds > 0
			success_rates["Total Success Rate"]		= ((total_deeds.to_f / total_attempts) * 100).round(2)			if total_deeds > 0
			
			success_rates.each{ |key, value|
				if !value.is_a?(String)
					success_rates[key] = 100 if value == 100.0
					success_rates[key] = "#{success_rates[key]}%"
				end
			}

			original_value			= stats["Total Original Value"]
			appraised_value			= stats["Total Appraised Value"]
			silver_saved			= stats["Total Silver Saved"]
			value_lost				= stats["Lost Appraised Value"]
			silver_used				= stats["Total Silver Used"]
			silver_lost				= stats["Lost Silver"]
			total_needed			= stats["Total Needed"]
			dwarf_silver_spent		= stats["Silvers Spent On Dwarf Rubies"]
			dwarf_silver_lost		= stats["Silvers Lost With Dwarf Rubies"]
			
			avg_app_value_deed		= "N/A"
			app_val_per_day			= "N/A"
			avg_app_value_deed		= add_commas((appraised_value / item_deeds)) if appraised_value > 0
			app_val_per_day			= add_commas((appraised_value / total_days)) if appraised_value > 0
			
			avg_silver_deed			= "N/A"
			silver_per_day			= "N/A"
			avg_silver_deed			= add_commas((silver_used / silver_deeds)) if silver_used > 0
			silver_per_day			= add_commas((silver_used / total_days)) if silver_used > 0
			
			avg_dwarf_deed			= "N/A"
			dwarf_per_day			= "N/A"
			avg_dwarf_deed			= add_commas((dwarf_silver_spent / dwarf_deeds)) if dwarf_silver_spent > 0
			dwarf_per_day			= add_commas((dwarf_silver_spent / total_days)) if dwarf_silver_spent > 0

			label.markup = <<~MARKUP
				<span font_family="monospace">
				Total Deeds Gained:                 #{add_commas(total_deeds)}
				Total Failed Attempts:              #{add_commas(total_fails)}
				Total Attempts:                     #{add_commas(total_attempts)}
				Total Deed Success Rate:            #{success_rates["Total Success Rate"]}
				Total Needed For All Deeds:         #{add_commas(total_needed)}
				Average Needed Per Deed:            #{add_commas(total_needed / total_deeds)}
				-------------------------------------------------------------------------
				ALL DATE STATS
				Date Started Using ;dirty-deeds:    #{start_date.month}/#{start_date.day}/#{start_date.year}
				You Have Been Using Script for:     #{years} #{year_text}/#{months} #{month_text}/#{days} #{day_text}
				Average Deeds Gained Per Day:       #{add_commas((total_deeds / total_days.to_f).round(2))}
				Appraised Value Used Per Day:       #{app_val_per_day}
				Silver Used Per Day:                #{silver_per_day}
				Dwarf Rubies Value Spent Per Day:   #{dwarf_per_day}
				-------------------------------------------------------------------------
				STATS OF ALL ITEMS USED FOR DEEDS
				Deeds Gained:                       #{add_commas(item_deeds)}
				Deed Failed Attempts:               #{add_commas(item_fails)}
				Total Attempts:                     #{add_commas(item_total_attempts)}
				Success Rate:                       #{success_rates["Item Success Rate"]}
				Original Value Of All Items Used:   #{add_commas(original_value)}
				Appraised Value Of All Items Used:  #{add_commas(appraised_value)}
				Total Silver Saved:                 #{add_commas(silver_saved)}
				Total Appraised Value Lost:         #{add_commas(value_lost)}
				Average Appraised Value Per Deed:   #{avg_app_value_deed}
				-------------------------------------------------------------------------
				STATS OF ALL SILVER USED FOR DEEDS
				Deeds Gained:                       #{add_commas(silver_deeds)}
				Deed Failed Attempts:               #{add_commas(silver_fails)}
				Total Attempts:                     #{add_commas(silver_total_attempts)}
				Success Rate:                       #{success_rates["Silver Success Rate"]}
				Total Silver Used:                  #{add_commas(silver_used)}
				Total Silver Lost:                  #{add_commas(silver_lost)}
				Average Silver Per Deed:            #{avg_silver_deed}
				-------------------------------------------------------------------------
				STATS FOR DWARF RUBIES USED FOR DEEDS
				Deeds Gained:                       #{add_commas(dwarf_deeds)}
				Deed Failed Attempts:               #{add_commas(dwarf_fails)}
				Total Attempts:                     #{add_commas(dwarf_total_attempts)}
				Success Rate:                       #{success_rates["Dwarf Success Rate"]}
				Silvers Spent On Dwarf Rubies:      #{add_commas(dwarf_silver_spent)}
				Silvers Lost On Failed Attempts:    #{add_commas(dwarf_silver_lost)}
				Average Silver Per Deed:            #{avg_dwarf_deed}
				-------------------------------------------------------------------------
				</span>
			MARKUP
		end
	end
	
	#Get the deeds.
	def self.get_a_deed
		get_deed_cost
		go_to_deed_room if @info["Current Town"] == "Icemule" || @info["Current Town"] == "River's Rest" #Landing isn't listed here because in Landing you need to leave and move to the deed room for each deed attempt so this move is later in the code, whereas in Icemule and River's Rest you can stay there for all deed attempts.
		@info["Deeds Gained"] = 0
		loop{
			update_all_stats
			if @info["Deeds Gained"] >= @info["Deeds Wanted"]
				word_1 = @info["Deeds Wanted"] == 1 ? "deed" : "deeds"
				word_2 = @info["Deeds Wanted"] == 1 ? "got it" : "got'em"
				update_running_totals
				@info["Instructions Array"] << "You wanted #{@info["Deeds Wanted"]} #{word_1} and you #{word_2}!"
				update_instructions
				break
			elsif @info["STOP"]
				@info["Instructions Array"] << "You clicked the 'Stop' button, so I stopped."
				update_running_totals
				update_instructions
				break
			end
			items = {}
			enough_for_deed = nil #Becomes true if the script found enough items to get a deed.
			hash = @info["All Item Stats"]
			if hash.count <= 18
				#The below calculations will use the lowest value of items needed to get a deed, however the more items there are to go through the longer it takes to do all of the calculations. At 18 items this should be nearly instant, it starts to get noticeably slower after 18.
				@info["Instructions Array"] << "18 or fewer items: Using the best method to calculate the lowest value of items needed to get a deed."
				new_hash	= hash.to_a
				best_total	= Float::INFINITY

				#Find the best combo of items that is as close as possible to the value needed to get a deed.
				#Store all selected items in the items hash.
				(1..new_hash.length).each{ |size|
					new_hash.combination(size){ |combo|
						total = combo.sum{ |_, data| data["Multiplied Value"] }

						next if total < @info["Silvers Needed For Deed"]

						if total < best_total
							enough_for_deed = true
							best_total	= total
							items		= combo
						end
					}
				}
				items = items.to_h
			else
				@info["Instructions Array"] << "More than 18 items: Calculations to use the lowest value of items needed won't necessarily be perfect, but will be close."
				hash = hash.sort_by { |_, item_stats| item_stats["Multiplied Value"] }

				total = 0
				
				#Get the value of 1 item at a time, starting with the lowset value, until the combined values are equal to or greater than the amount needed for a deed.
				#Store all selected items in the items hash.
				hash.each{ |item_id, item_stats|
					if total >= @info["Silvers Needed For Deed"]
						enough_for_deed = true
						break
					end
					items[item_id] = @info["All Item Stats"][item_id].dup
					total += item_stats["Multiplied Value"]
				}
				#

				#Go through all of the items to see if any items can be removed and the total will still be equal to greater than the amount needed for a deed.
				if enough_for_deed
					items = items.sort_by{ |_, stats| stats["Multiplied Value"] }.to_h
					items.dup.each{ |item_id, item_stats|
						new_total = total - item_stats["Multiplied Value"]
						next if new_total < @info["Silvers Needed For Deed"]

						items.delete(item_id)
						total = new_total
					}
				end
				#
			end
			
			if enough_for_deed
				total_original_value	= 0
				total_appraise_value	= 0
				total_multiplied_value	= 0
				items.each{ |item_id, item_stats|
					total_original_value	+= item_stats["Original Value"]
					total_appraise_value	+= item_stats["Appraised Value"]
					total_multiplied_value	+= item_stats["Multiplied Value"]
				}

				show_items_table(items)
				needed					= @info["Silvers Needed For Deed"]
				original_overage		= total_original_value - (needed / @info["Item Multiplier"]).ceil
				appraise_overage		= total_appraise_value - (needed / @info["Item Multiplier"]).ceil
				multiplied_overage		= total_multiplied_value - needed
				saved_by_using_items	= needed - total_appraise_value #How much silver was saved using items instead of selling the items for silvers then using silvers for a deed.
				
				respond "Total Needed For Deed:   #{add_commas(needed)}"
				respond "Total Saved Using Items: #{add_commas(saved_by_using_items)}"
				#The overage values aren't accurate if using the "Auto Multiplier" setting because that setting uses 2 different multipliers, so if the setting is used don't show the overage information.
				if @info["Auto Multiplier"]
					respond "Total Original Value:    #{add_commas(total_original_value)}"
					respond "Total Appraised Value:   #{add_commas(total_appraise_value)}"
					respond "Total Multiplied Value:  #{add_commas(total_multiplied_value)}"
				else
					respond "Total Original Value:    #{add_commas(total_original_value)} (#{add_commas(original_overage)} more than needed)"
					respond "Total Appraised Value:   #{add_commas(total_appraise_value)} (#{add_commas(appraise_overage)} more than needed)"
					respond "Total Multiplied Value:  #{add_commas(total_multiplied_value)} (#{add_commas(multiplied_overage)} more than needed)"
				end
				respond

				#Check if the "Use Silver" variable is true and if using silvers would cost less than the appraised value of all selected items.
				use_silver = nil
				use_silver = true if (@info["Use Silver"]) && (needed < total_appraise_value)

				@info["Permission Granted"] = nil
				if (@info["Confirm Required"]) || (use_silver)
					@info["Buttons"]["Confirm"].sensitive = true
					@info["Buttons"]["Decline"].sensitive = true
					if use_silver
						@info["Buttons"]["Use Silver"].sensitive = true
						@info["Instructions Array"] << "Using silvers would cost less than the total appraised value of items selected for this deed attempt."
						@info["Instructions Array"] << "Click 'Use Silver' to run to the bank and use silver for this deed attempt." if @info["Current Town"] == "Landing"
					end
					@info["Instructions Array"] << "Look at the game screen for a list of items which will be used for this deed attempt."
					@info["Instructions Array"] << "Click 'Confirm' to use these items for a deed."
					@info["Instructions Array"] << "Click 'Decline' to not use these items and move on to the next batch of items."
					@info["Instructions Array"] << "Click 'Stop' to not use these items and immediately stop any deed attempts."
					update_instructions
					wait_until{ @info["Permission Granted"] }
					@info["Buttons"]["Confirm"].sensitive = false
					@info["Buttons"]["Decline"].sensitive = false
					@info["Buttons"]["Use Silver"].sensitive = false
				else
					@info["Permission Granted"] = "Yes"
				end

				if @info["Permission Granted"] == "Yes" || @info["Permission Granted"] == "Use Silver"
					permission = @info["Permission Granted"]
					get_the_deed = true
					
					if permission == "Use Silver"
						balance = get_landing_bank_balance
						if balance >= needed
							fput "withdraw #{needed} silver"
						else
							get_the_deed = nil
						end
						Script.run("go2", "goback")
					end
					
					if get_the_deed
						before_deeds = @info["Current Deeds"].dup
						perform_deed_actions(items)
						get_deed_cost
						
						@stats[Char.name]["Silvers Spent On Dwarf Rubies"]			+= (items.count * @info["Dwarf Ruby Cost"]) if @info["Buy Dwarf Rubies"]
						
						if before_deeds == @info["Current Deeds"]
							if permission == "Use Silver"
								@info["Lost Silver"]								+= needed
								@stats[Char.name]["Lost Silver"]					+= needed
								@stats[Char.name]["Silver Deed Fails"]				+= 1
							elsif @info["Buy Dwarf Rubies"]
								@stats[Char.name]["Silvers Lost With Dwarf Rubies"]	+= (items.count * @info["Dwarf Ruby Cost"])
								@stats[Char.name]["Dwarf Ruby Deed Fails"]			+= 1
							else
								@info["Lost Appraised Value"]						+= total_appraise_value
								@stats[Char.name]["Lost Appraised Value"]			+= total_appraise_value
								@stats[Char.name]["Item Deed Fails"]				+= 1
							end
							
							@info["Instructions Array"] << "You did not receive a deed after that attempt."
							@info["Instructions Array"] << "While the Landing deed formula is known in SILVER, there is no data showing this same formula is used in Icemule or River's Rest."
							@info["Instructions Array"] << "There is data showing items are worth more than their original value, there is no data showing exactly how much more."
							@info["Instructions Array"] << "Try decreasing the Item Multiplier and see if that works to get a deed."
							update_instructions
							break
						else
							if permission == "Use Silver"
								@info["Total Silver Used"]							+= needed
								@stats[Char.name]["Total Silver Used"]				+= needed
								@stats[Char.name]["Deeds Gained With Silver"]		+= 1
							elsif @info["Buy Dwarf Rubies"]
								@stats[Char.name]["Deeds Gained With Dwarf Rubies"]	+= 1
							else
								@info["Total Original Value"]						+= total_original_value
								@stats[Char.name]["Total Original Value"]			+= total_original_value
								@info["Total Appraised Value"]						+= total_appraise_value
								@stats[Char.name]["Total Appraised Value"]			+= total_appraise_value
								@info["Total Multiplied Value"]						+= total_multiplied_value
								@info["Total Silver Saved"]							+= (needed - total_appraise_value)
								@stats[Char.name]["Total Silver Saved"]				+= (needed - total_appraise_value)
								@stats[Char.name]["Deeds Gained With Items"]		+= 1
							end
							@info["All Item Stats"].delete_if{ |key, _| items.key?(key.to_s) || items.key?(key.to_sym) } if permission != "Use Silver" #This deletes all items used in deed attempt from list of items available. It only removes items if user didn't use silvers for deed.
							@stats[Char.name]["Total Needed"]						+= needed
							
							@info["Instructions Array"] << "Deed gained! You're up to #{@info["Current Deeds"]} deeds now!"
							@info["Deeds Gained"]									+= 1
							@stats[Char.name]["Start Date"]							||= Time.now
							
							if (@info["Confirm Required"]) || (use_silver)
								#Do nothing.
							else
								update_instructions
							end
						end
					else
						#Variable get_the_deed will only be nil if they are doing "Use Silver" and don't have enough silver in the bank.
						@info["Instructions Array"] << "You don't have enough silver in your bank to get a deed using silver."
						@info["Instructions Array"] << "Be sure you have silver in your bank when using the 'Use Silver' option."
						update_running_totals
						update_instructions
						break
					end
				elsif @info["Permission Granted"] == "No"
					@info["All Item Stats"].delete_if{ |key, _| items.key?(key.to_s) || items.key?(key.to_sym) } #This deletes all items used in deed attempt from list of items available. It is listed here to ensure the current batch of items are removed if the user clicked "Decline"
				end
			else
				@info["Instructions Array"] << "NOT ENOUGH FOR A DEED!"
				update_running_totals
				update_instructions
				break
			end
		}
		update_all_stats
		fput "open door" if @info["Current Town"] == "Icemule"
		Script.kill("go2") if running? "go2"
		Script.run("go2", @info["Appraise Shop"])
	end
	
	#Shows all items and stats in a table.
	def self.show_items_table(hash)
		respond
		#Find the longest item name, and determine the length of the "Original Value", "Appraised Value", and "Multiplied Value" headers.
		longest_name		= hash.values.map{ |item_stats| item_stats["Item Name"].to_s.length }.max
		original_header		= "Original Value".length
		appraised_header	= "Appraised Value".length
		multiplied_header	= "Multiplied Value".length

		total_width = 11 + longest_name + original_header + appraised_header + multiplied_header
		divider = "-" * total_width
		if @info["Auto Multiplier"]
			respond "All items which will be used and their original (no trading bonus), appraised (trading bonus), and multiplied values based on the 'Auto Multiplier' settings."
		else
			respond "All items which will be used and their original (no trading bonus), appraised (trading bonus), and multiplied values based on your 'Item Multiplier' setting (#{@info["Item Multiplier"]}x)"
		end

		respond divider
		respond "#{ "|Name".ljust(longest_name) }  | " \
				"#{ "Original Value".rjust(original_header) } | " \
				"#{ "Appraised Value".rjust(appraised_header) } | " \
				"#{ "Multiplied Value|".rjust(multiplied_header) }"
		hash = hash.sort_by { |_, item_stats| item_stats["Original Value"] }
		respond divider
		hash.each{ |_, item_stats|
			respond "#{ "|#{item_stats["Item Name"].ljust(longest_name)}" } | " \
					"#{ add_commas(item_stats["Original Value"]).to_s.rjust(original_header) } | " \
					"#{ add_commas(item_stats["Appraised Value"]).to_s.rjust(appraised_header) } | " \
					"#{ add_commas(item_stats["Multiplied Value"]).to_s.rjust(multiplied_header) }|"
		}
		respond divider
		respond
	end
	
	#Get the values of all items.
	def self.get_item_values
		waitrt?
		fput "open ##{@info["Item Container"].id}"
		fput "look in ##{@info["Item Container"].id}"
		sleep 1
		#Count each item which can be used for a deed in the currently selected town.
		total_usable_items = 0
		appraised_items_count = 0
		dwarf_rubies_owned = 0
		@info["Item Container"].contents.each{ |item|
			if @info["Buy Dwarf Rubies"] && item.name == "dwarf-cut ruby"
				dwarf_rubies_owned += 1
			else
				if	(
						(@info["Current Town"] == "Landing" && item.type == "gem") ||
						(@info["Current Town"] == "Icemule" && item.name =~ /#{@all_icemule_items}/) ||
						(@info["Current Town"] == "River's Rest" && item.name =~ /#{@all_riverrest_gems}/)
					)
					total_usable_items += 1
				end
			end
		}
		
		if @info["Buy Dwarf Rubies"]
			get_deed_cost
			starting_deeds		= @info["Current Deeds"]
			deeds_wanted		= @info["Deeds Wanted"]
			multiplier			= @info["Item Multiplier"]
			gs3_level			= @info["GS 3 Level"]
			
			begin_deeds 		= starting_deeds.dup
			dwarf_rubies_needed	= 0
			if @info["Auto Multiplier"]
				multi = @info["Auto Multiplier Higher Multi"].dup
			else
				multi = @info["Item Multiplier"].dup
			end
			deeds_wanted.times{
				silvers_needed			= landing_deed_formula(begin_deeds, gs3_level)
				dwarf_rubies_needed 	+= (silvers_needed / (@info["Dwarf Ruby Original Value"] * multi)).ceil
				begin_deeds				+= 1
			}
			net_rubies_needed = dwarf_rubies_needed - dwarf_rubies_owned
			total_silvers_needed = @info["Dwarf Ruby Cost"] * net_rubies_needed
			deed_text = plural_or_not("deed", deeds_wanted)
			@info["Buttons"]["Confirm"].sensitive = true
			@info["Buttons"]["Decline"].sensitive = true
			@info["Instructions Array"] << "You need a total of #{dwarf_rubies_needed} dwarf-cut rubies to get #{deeds_wanted} #{deed_text}.\nYou currently have #{dwarf_rubies_owned} dwarf-cut rubies."
			@info["Permission Granted"] = nil
			if net_rubies_needed == 0
				@info["Instructions Array"] << "You already have enough dwarf-cut rubies!"
				@info["Instructions Array"] << "Click 'Confirm' to proceed."
				@info["Instructions Array"] << "Click 'Decline' or 'Stop' to stop this process now."
				update_instructions
				wait_until{ @info["Permission Granted"] }
				@info["Buttons"]["Confirm"].sensitive = false
				@info["Buttons"]["Decline"].sensitive = false
				if @info["Permission Granted"] == "No"
					@info["Instructions Array"] << "You have chosen not to get any deeds."
					update_instructions
					@info["STOP"] = true
				end
			else
				@info["Instructions Array"] << "You need to buy #{net_rubies_needed} dwarf-cut rubies, which would cost #{add_commas(total_silvers_needed)} silver."
				@info["Instructions Array"] << "Click 'Confirm' if this cost is acceptable."
				@info["Instructions Array"] << "Click 'Decline' or 'Stop' to stop this process now."
				update_instructions
				wait_until{ @info["Permission Granted"] }
				@info["Buttons"]["Confirm"].sensitive = false
				@info["Buttons"]["Decline"].sensitive = false
				if @info["Permission Granted"] == "Yes"
					balance = get_landing_bank_balance
					if balance >= total_silvers_needed
						if net_rubies_needed == 1
							text = "ruby"
						else
							text = "rubies"
						end
						@info["Instructions Array"] << "Buying #{net_rubies_needed} dwarf-cut #{text}."
						update_instructions
						fput "put my #{checkright} in ##{@info["Item Container"].id}" if checkright
						fput "put my #{checkleft} in ##{@info["Item Container"].id}"  if checkleft
						fput "withdraw #{total_silvers_needed} note"
						Script.kill("go2") if running? "go2"
						Script.run("go2", @info["Dwarf Ruby Room"])
						rubies_bought = 0
						net_rubies_needed.times{
							break if @info["STOP"]
							fput "order #{@info["Dwarf Ruby Order"]}"
							fput "buy"
							fput "put my ruby in ##{@info["Item Container"].id}"
							rubies_bought += 1
						}
						if @info["STOP"].nil?
							Script.kill("go2") if running? "go2"
							Script.run("go2", @info["Landing Bank Room"])
							fput "deposit all"
						end
					else
						@info["Instructions Array"] << "You do not have enough silvers to buy this many dwarf-cut rubies."
						update_instructions
						@info["STOP"] = true
					end
				elsif @info["Permission Granted"] == "No"
					@info["Instructions Array"] << "You have chosen not to buy the dwarf-cut rubies."
					update_instructions
					@info["STOP"] = true
				end
			end
		else
			@info["Instructions Array"] << "Getting values of all items which can be used for a deed that are inside of your #{@info["Item Container"]}."
			@info["Instructions Array"] << "Total items: #{total_usable_items}"
			update_instructions
			
			Script.kill("go2") if running? "go2"
			Script.run("go2", @info["Appraise Shop"])
			regex = Regexp.union(@info["All Save Items"])
		end
		
		@info["All Item Stats"] = Hash.new
		hash = @info["All Item Stats"]
		empty_hands
		
		#Go through each item in the Item Container and find items that can be used in the selected town.
		@info["Item Container"].contents.each{ |item|
			break if @info["STOP"]

			#If the item was already appraised before then its data is saved in the @item_data hash.
			#If the item ID is found in the @item_data hash then grab the Appraised Value from that hash, otherwise get the item and have the NPC appraise it.
			@info["Appraised Value"] = nil
			if @info["Buy Dwarf Rubies"] && item.name == "dwarf-cut ruby"
				@info["Appraised Value"] = ((((@info["Dwarf Ruby Original Value"].to_f * (100 + @info["Trading Bonus"])) / 100).truncate)).truncate
			else
				if	(
						((@info["Current Town"] == "Landing") && (item.type == "gem") && (@info["Buy Dwarf Rubies"].nil?)) ||
						((@info["Current Town"] == "Icemule") && (item.name =~ /#{@all_icemule_items}/)) ||
						((@info["Current Town"] == "River's Rest") && (item.name =~ /#{@all_riverrest_gems}/))
					)

					if regex !~ item.name
						if @item_data.key?(item.id)
							@info["Appraised Value"] = @item_data[item.id]["Appraised Value"]
						else
							until checkright
								waitrt?
								fput "get ##{item.id}"
								sleep 0.3
							end
								
							fput "appraise ##{item.id}"
							while line = get
								if	(
										line =~ /I'll give you (.*) silvers? for it if you want to sell\./ ||
										line =~ /I'll give you (.*) silver coins? for it\./ ||
										line =~ /I already quoted (.*) silvers?\./
									)
									@info["Appraised Value"] = $1.delete(",").to_i
									break
								elsif line =~ /I only deal in gems and jewelry|I've no use for that\./
									@info["Appraised Value"] = 0
									break
								end
							end
						end
					end
				end
			end
			
			#If the item has an appraised value then save the stats for the item.
			if @info["Appraised Value"] && @info["Appraised Value"] > 0
				if @info["Buy Dwarf Rubies"]
					@info["Original Value"] = @info["Dwarf Ruby Original Value"].dup
				else
					#None of this is necessary if using dwarf rubies.
					appraised_items_count += 1
					items_remaining_count = total_usable_items - appraised_items_count
					@info["Instructions Array"] << "Getting values of all items which can be used for a deed that are inside of your #{@info["Item Container"]}."
					@info["Instructions Array"] << "Total items:                     #{total_usable_items}"
					@info["Instructions Array"] << "Items remaining to be appraised: #{items_remaining_count}"
					update_instructions
					@info["Original Value"] = ((((@info["Appraised Value"].to_f / (100 + @info["Trading Bonus"])) * 100).truncate)).truncate
				end

				hash[item.id] = {}
				hash[item.id]["Item Name"] = item.name
				hash[item.id]["Item ID"] = item.id
				hash[item.id]["Original Value"] = @info["Original Value"]   #Original Value is value before trading bonus.
				hash[item.id]["Appraised Value"] = @info["Appraised Value"] #Appraised Value is value with trading bonus.

				if @info["Auto Multiplier"]
					if @info["Original Value"] < 1000
						multi = @info["Auto Multiplier Lower Multi"].dup
					else
						multi = @info["Auto Multiplier Higher Multi"].dup
					end
				else
					multi = @info["Item Multiplier"].dup
				end
				hash[item.id]["Multiplied Value"] = (@info["Original Value"]  * multi).truncate #Multipled Value is Original Value times Item Multiplier
			end
			
			until checkright.nil?
				waitrt?
				fput "put ##{item.id} in ##{@info["Item Container"].id}"
				sleep 0.3
			end
		}
		
		if @info["STOP"].nil?
			@item_data = hash.dup #Replace @item_data with the hash data after the container has been checked so it only tracks the most recently seen items in the container.
			if hash.count == 0
				@info["Instructions Array"] << "There are no items in your #{@info["Item Container"]} that can be used for a deed in #{@info["Current Town"]}."
				update_instructions
			else
				show_items_table(hash)
			end
		end
		@info["Instructions Array"] << "Getting you those deeds!"
		update_instructions
	end
	
	def self.update_stats_for_deed
		@info["Labels"]["Main Window Info Label"].text = "Trading Bonus: #{@info["Trading Bonus"]}%\nGS3 Level: #{@info["GS 3 Level"]}\nCurrent Deeds: #{@info["Current Deeds"]}\nSilvers Needed For Deed: #{add_commas(@info["Silvers Needed For Deed"])}"
	end
	
	def self.update_instructions
		text = @info["Instructions Array"].join("\n\n")
		longest_name = @info["Instructions Array"].map(&:length).max

		divider = "-" * longest_name
		respond
		respond divider
		respond text
		respond divider
		respond
		
		label = @info["Labels"]["Main Window Instructions Label"]
		label.wrap = true
		label.xalign = 0.0
		label.justify = :left
		label.lines = -1
		label.markup = "<span font_family=\"monospace\">#{text}</span>"
		@info["Instructions Array"] = []
	end
	
	#Add commas to displayed numbers, so 1000 becomes 1,000, etc.
	def self.add_commas(number)
		number.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse
	end
	
	#This is the Landing deed formula. As of now it is the formula used for all towns.
	def self.landing_deed_formula(deeds, gs3_level)
		((deeds * deeds) * 20) + (gs3_level * 100) + 101
	end
	
	#Calculate deed cost
	def self.get_deed_cost
		fput "experience"
		while line = get
			break if line =~ /Long-Term Exp:/
		end
		@info["GS 3 Level"] = get_gs_3_level(Experience.exp) #Set the character's GS3 level.
		@info["Current Deeds"] = Experience.deeds
		@info["Silvers Needed For Deed"] = landing_deed_formula(@info["Current Deeds"], @info["GS 3 Level"])
		update_stats_for_deed
	end
	
	#The Confirm button is only needed if the Confirm checkbox is checked, so this hides/shows the Confirm button depending on the state of the Confirm checkbox.
	#Same for "Use Silver" checkbox and button.
	def self.confirm_silver_checkbox_status
		if (
				@info["Checkboxes"]["Confirm Checkbox"].active? ||
				@info["Checkboxes"]["Use Silver Checkbox"].active? ||
				(@info["Checkboxes"]["Buy Dwarf Rubies"].active?) && (@info["Current Town"] == "Landing")
			)
			@info["Buttons"]["Confirm"].show
			@info["Buttons"]["Decline"].show
		else
			@info["Buttons"]["Confirm"].hide
			@info["Buttons"]["Decline"].hide
		end
		
		if @info["Checkboxes"]["Confirm Checkbox"].active?
			@info["Confirm Required"] = true
		else
			@info["Confirm Required"] = nil
		end
		
		if @info["Checkboxes"]["Use Silver Checkbox"].active?
			@info["Use Silver"] = true
			@info["Buttons"]["Use Silver"].show
		else
			@info["Use Silver"] = nil
			@info["Buttons"]["Use Silver"].hide
		end
		
		#The following check is also required to make sure these buttons are hidden in case the loaded town at startup isn't Landing.
		if @info["Current Town"] == "Landing"
			@info["Buttons"]["Use Silver"].show unless !@info["Checkboxes"]["Use Silver Checkbox"].active?
			@info["Checkboxes"]["Buy Dwarf Rubies"].show
			@info["Checkboxes"]["Auto Multiplier"].show
		else
			@info["Buttons"]["Use Silver"].hide
			@info["Checkboxes"]["Buy Dwarf Rubies"].hide
			@info["Checkboxes"]["Auto Multiplier"].hide
		end
		
		@info["Buttons"]["Use Silver"].hide if @info["Checkboxes"]["Buy Dwarf Rubies"].active?
	end
	
	def self.auto_multiplier_status
		if @info["Checkboxes"]["Auto Multiplier"].active?
			@info["Auto Multiplier"] = true
		else
			@info["Auto Multiplier"] = nil
		end
	end
	
	def self.dwarf_ruby_status
		if @info["Checkboxes"]["Buy Dwarf Rubies"].active?
			@info["Buy Dwarf Rubies"] = true
		else
			@info["Buy Dwarf Rubies"] = nil
		end
	end
	
	#Does the math for the Deed Calculator.
	def self.calculate_deed_costs
		label				= @info["Labels"]["Calculator Text"]
		exp					= @info["Calculator Spin Buttons"]["Normal Experience"].value.to_i
		starting_deeds		= @info["Calculator Spin Buttons"]["Starting Deeds"].value.to_i
		ending_deeds		= @info["Calculator Spin Buttons"]["Ending Deeds"].value.to_i
		multiplier			= @info["Calculator Spin Buttons"]["Calculator Multiplier"].value.round(1)
		deeds_wanted		= ending_deeds - starting_deeds
		gs3_level			= get_gs_3_level(exp)
		
		begin_deeds 		= starting_deeds.dup
		total_silvers 		= 0
		deeds_wanted.times{
			silvers_needed	= landing_deed_formula(begin_deeds, gs3_level)
			total_silvers 	+= silvers_needed
			begin_deeds		+= 1
		}
		avg_silver_cost		= (total_silvers / deeds_wanted).ceil
		item_value_needed 	= (total_silvers / multiplier).ceil
		avg_item_cost		= (item_value_needed / deeds_wanted).ceil

		label.set_xalign(0.0)
		label.use_markup = true
		label.markup = <<~MARKUP
			<span font_family="monospace">
			Normal Experience:  #{add_commas(exp)}
			GS3 Level:          #{add_commas(gs3_level)}
			Deeds Wanted:       #{deeds_wanted}
			Silvers Needed:     #{add_commas(total_silvers)} (Average per deed: #{add_commas(avg_silver_cost)})
			Item Value Needed:  #{add_commas(item_value_needed)} (Average per deed: #{add_commas(avg_item_cost)})
			</span>
		MARKUP
	end
	
	def self.change_keep_settings(name)
		text = @info["Entries"][name].text.strip
		@info["Entries"][name].text = ""
		if text.length > 0
			label = @info["Labels"]["Keep List"]
			array = @info["All Save Items"]
			if name == "Keep Add"
				array.push(text) unless array.include?(text)
			else
				array.delete(text)
			end
			array.sort!
			label.text = array.join(", ")
		end
	end

	#Create the GTK window.
	def self.create_main_window
		@main_window = Gtk::Window.new(:toplevel)
		@main_window.name = "main_window"
		@main_window.set_keep_above(true)
		@main_window.set_border_width(10)
		@main_window.resize(500, 600)
		@main_window.set_position(Gtk::WindowPosition::CENTER)
		
		#Create notebook.
		@info["Main Notebook"] = Gtk::Notebook.new
		@info["Main Notebook"].set_hexpand(true)
		@info["Main Notebook"].set_vexpand(true)
		
		pages = [ "Get Deeds", "Keep", "Deed Calculator", "Stats", "Version History" ]
		pages.each{ |page|
			label = Gtk::Label.new(page)
			@info["Grids"][page] = Gtk::Grid.new
			@info["Main Notebook"].append_page(@info["Grids"][page], label)
		}
				
		#Create grids.
		grid_names = [ "Main Window Parent", "Main Window Info Grid", "Main Window Checkboxes", "Main Window Menus", "Main Window Spin Buttons", "Main Window Buttons", "Main Window Instructions Grid" ]
		row = 0
		grid_names.each{ |name|
			row += 1
			@info["Grids"][name] = Gtk::Grid.new
			@info["Grids"]["Get Deeds"].attach(@info["Grids"][name], 0, row, 1, 1) if name != "Main Window Parent"
		}
		
		@info["Grids"]["Main Window Parent"].attach(@info["Main Notebook"], 0, 0, 1, 1)
		@main_window.add(@info["Grids"]["Main Window Parent"])
		
		#Create labels.
		labels = [ "Main Window Info Label", "Main Window Instructions Label" ]
		labels.each{ |label| @info["Labels"][label] = Gtk::Label.new("") }
		
		#Create menus.
		#Town menu.
		@info["Menus"]["Town List"] = Gtk::ComboBoxText.new
		menu = @info["Menus"]["Town List"]
		@info["All Towns"].each{ |item|	menu.append(item, item) }

		menu.signal_connect("changed"){
			@info["Current Town"] = @info["Menus"]["Town List"].active_text #This can't use the menu variable or else it will get overwriten the next time I use the menu variable.
			if @info["Current Town"] == "Landing"
				@info["Buttons"]["Use Silver"].show if @info["Use Silver"]
				@info["Checkboxes"]["Buy Dwarf Rubies"].show
				@info["Checkboxes"]["Auto Multiplier"].show
				if @info["Checkboxes"]["Buy Dwarf Rubies"].active?
					@info["Buttons"]["Confirm"].show
					@info["Buttons"]["Decline"].show
				end
				@info["Buttons"]["Use Silver"].hide if @info["Checkboxes"]["Buy Dwarf Rubies"].active?
			else
				@info["Buttons"]["Use Silver"].hide
				@info["Checkboxes"]["Buy Dwarf Rubies"].hide
				@info["Checkboxes"]["Auto Multiplier"].hide
				@info["Buttons"]["Confirm"].hide unless @info["Checkboxes"]["Confirm Checkbox"].active? || @info["Checkboxes"]["Use Silver Checkbox"].active?
				@info["Buttons"]["Decline"].hide unless @info["Checkboxes"]["Confirm Checkbox"].active? || @info["Checkboxes"]["Use Silver Checkbox"].active?
			end
			trade_bonus_and_town_information
			update_stats_for_deed
		}
		menu.active = 0

		#Container menu.
		@info["Menus"]["Container List"] = Gtk::ComboBoxText.new
		menu = @info["Menus"]["Container List"]
		@info["Worn Containers"].each{ |item,_| menu.append(item, item) }

		menu.signal_connect("changed"){
			container = @info["Menus"]["Container List"].active_text #This can't use the menu variable or else it will get overriden the next time I use the menu variable.
			@info["Item Container"] = GameObj.inv.find{ |item| item.name == container }
		}
		#Set each menu option to the saved setting, otherwise set option to the first on the list.
		@info["Menus"].each{ |menu_name, menu|
			if @character_settings[menu_name]
				menu.active_id = @character_settings[menu_name]
			else
				menu.active = 0
			end
			menu.active = 0 if menu.active_text.nil? #Set option to the first on the list if the character isn't wearing their saved container.
		}
		
		#Create spin buttons.
		#Get Deeds Tab.
		column = -1
		row = -1
		all_spinbuttons = [ "Item Multiplier", "Deeds Wanted" ]
		all_spinbuttons.each{ |name|
			#Get the starting value from the loaded settings, if there are loaded settings.
			sv = nil
			sv = @character_settings[name] if @character_settings[name]
			if name == "Item Multiplier"
				sv = 3.0 if sv.nil?
				adjustment = Gtk::Adjustment.new(
					sv,		#Initial value
					0.1,	#Minimum value
					50.0,	#Maximum value
					0.1,	#Increment via arrow clicks
					0.5,	#Increment via Page Up/Page Down
					0.0		#Page size - Doesn't need to be changed
				)
				@info["Spin Buttons"][name] = Gtk::SpinButton.new(adjustment, 1.0, 1)
				spin_button = @info["Spin Buttons"][name]
				@info[name] = spin_button.value.round(1)
				spin_button.signal_connect("value-changed"){ @info[name] = spin_button.value.round(1) }
			elsif name == "Deeds Wanted"
				sv = 10 if sv.nil?
				adjustment = Gtk::Adjustment.new(
					sv,		#Initial value
					1,		#Minimum value
					100,	#Maximum value
					1,		#Increment via arrow clicks
					5,		#Increment via Page Up/Page Down
					0.0		#Page size - Doesn't need to be changed
				)
				@info["Spin Buttons"][name] = Gtk::SpinButton.new(adjustment, 1, 1)
				spin_button = @info["Spin Buttons"][name]
				spin_button.digits = 0
				@info[name] = spin_button.value.to_i
				spin_button.signal_connect("value-changed"){ @info[name] = spin_button.value.to_i }
			end
			if column > 0
				label = Gtk::Label.new("     #{name}:     ")
			else
				label = Gtk::Label.new("#{name}:     ")
			end
			@info["Grids"]["Main Window Spin Buttons"].attach(label, 		column += 1, row += 1, 1, 1)
			@info["Grids"]["Main Window Spin Buttons"].attach(spin_button,	column += 1, row, 1, 1)
			row = -1
		}
		
		#Deed Calculator Tab.
		@info["Grids"]["Deed Buttons"]		= Gtk::Grid.new
		@info["Grids"]["Deed Text"]			= Gtk::Grid.new
		@info["Grids"]["Deed Calculator"].attach(@info["Grids"]["Deed Buttons"],	0, 0, 1, 1)
		@info["Grids"]["Deed Calculator"].attach(@info["Grids"]["Deed Text"],		0, 1, 1, 1)
		
		row = -1
		all_spinbuttons = [ "Normal Experience", "Starting Deeds", "Ending Deeds", "Calculator Multiplier" ]
		all_spinbuttons.each{ |name|
			#These limits are set so Starting Deeds can never be higher than Ending Deeds, and Ending Deeds can never be lower than Starting Deeds.
			#This way the script won't try to calculate negative deeds.
			if name == "Starting Deeds"
				adjustment = Gtk::Adjustment.new(
					Experience.deeds,		#Initial value
					0,						#Minimum value
					199,					#Maximum value
					1,						#Increment via arrow clicks
					5,						#Increment via Page Up/Page Down
					0.0						#Page size - Doesn't need to be changed
				)
			elsif name == "Ending Deeds"
				adjustment = Gtk::Adjustment.new(
					Experience.deeds + 1,	#Initial value
					1,						#Minimum value
					200,					#Maximum value
					1,						#Increment via arrow clicks
					5,						#Increment via Page Up/Page Down
					0.0						#Page size - Doesn't need to be changed
				)
			elsif name == "Normal Experience"
				adjustment = Gtk::Adjustment.new(
					Experience.exp,			#Initial value
					0,						#Minimum value
					500_000_000,			#Maximum value
					5_000,					#Increment via arrow clicks
					50_000,					#Increment via Page Up/Page Down
					0.0						#Page size - Doesn't need to be changed
				)
			elsif name == "Calculator Multiplier"
				adjustment = Gtk::Adjustment.new(
					3.0,	#Initial value
					0.1,	#Minimum value
					50.0,	#Maximum value
					0.1,	#Increment via arrow clicks
					0.5,	#Increment via Page Up/Page Down
					0.0		#Page size - Doesn't need to be changed
				)
			end
			if name == "Calculator Multiplier"
				label = Gtk::Label.new("Multiplier:     ")
				@info["Calculator Spin Buttons"][name] = Gtk::SpinButton.new(adjustment, 1.0, 1)
				spin_button = @info["Calculator Spin Buttons"][name]
				@info[name] = spin_button.value.round(1)
			else
				label = Gtk::Label.new("#{name}:     ")
				@info["Calculator Spin Buttons"][name] = Gtk::SpinButton.new(adjustment, 1, 1)
				spin_button = @info["Calculator Spin Buttons"][name]
				spin_button.digits = 0
				@info[name] = spin_button.value.to_i
			end
			
			row += 1
			@info["Grids"]["Deed Buttons"].attach(label, 		0, row, 1, 1)
			@info["Grids"]["Deed Buttons"].attach(spin_button,	1, row, 1, 1)
		}
		
		@info["Calculator Spin Buttons"]["Starting Deeds"].signal_connect("value-changed"){
			starting_value = @info["Calculator Spin Buttons"]["Starting Deeds"].value
			@info["Calculator Spin Buttons"]["Ending Deeds"].value = starting_value += 1 #This ensures Ending Deeds is always higher than Starting deeds to avoid the script trying to calculate negative deeds.
			calculate_deed_costs
		}
		
		@info["Calculator Spin Buttons"]["Ending Deeds"].signal_connect("value-changed"){
			starting_value = @info["Calculator Spin Buttons"]["Starting Deeds"].value
			ending_value   = @info["Calculator Spin Buttons"]["Ending Deeds"].value
			@info["Calculator Spin Buttons"]["Ending Deeds"].value = starting_value += 1 if ending_value <= starting_value #This ensures Ending Deeds is always higher than Starting deeds to avoid the script trying to calculate negative deeds.
			calculate_deed_costs
		}

		@info["Calculator Spin Buttons"]["Normal Experience"].signal_connect("value-changed"){ calculate_deed_costs }
		
		@info["Calculator Spin Buttons"]["Calculator Multiplier"].signal_connect("value-changed"){ calculate_deed_costs }

		@info["Labels"]["Calculator Text"] = Gtk::Label.new("")
		calculate_deed_costs
		@info["Grids"]["Deed Text"].attach(@info["Labels"]["Calculator Text"], 0, 0, 1, 1)
		
		#Stats Tab.
		@info["Labels"]["Stats Text"] = Gtk::Label.new("")
		@info["Labels"]["Stats Text"].set_selectable(true)
		scroll_window = Gtk::ScrolledWindow.new
		scroll_window.set_policy(:automatic, :automatic)
		scroll_window.hexpand = true
		scroll_window.vexpand = true
		scroll_window.add(@info["Labels"]["Stats Text"])
		@info["Grids"]["Stats"].attach(scroll_window, 0, 0, 1, 1)
		
		#Version History Tab.
		@info["Labels"]["Version Text"] = Gtk::Label.new("")
		@info["Labels"]["Version Text"].set_selectable(true)
		scroll_window = Gtk::ScrolledWindow.new
		scroll_window.set_policy(:automatic, :automatic)
		scroll_window.hexpand = true
		scroll_window.vexpand = true
		scroll_window.add(@info["Labels"]["Version Text"])
		@info["Grids"]["Version History"].attach(scroll_window, 0, 0, 1, 1)
		update_version_history
		
		#Keep tab.
		@info["Grids"]["Keep Main"] = Gtk::Grid.new
		scroll_window = Gtk::ScrolledWindow.new
		scroll_window.set_policy(:automatic, :automatic)
		scroll_window.hexpand = true
		scroll_window.vexpand = true
		scroll_window.add(@info["Grids"]["Keep Main"])
		@info["Grids"]["Keep"].attach(scroll_window, 0, 0, 1, 1)
		
		names = [ "Keep Instructions", "Keep Entries", "Keep List" ]
		row = 0
		names.each{ |name|
			@info["Grids"][name] = Gtk::Grid.new
			@info["Grids"]["Keep Main"].attach(@info["Grids"][name], 0, row, 1, 1)
			row += 1
		}
		
		@info["Labels"]["Keep Instructions"] = Gtk::Label.new("IMPORTANT: Never enter the leading 'a', or 'an', or 'some' part of an item's name.\n\nThis is a universal setting for all of your characters.\n\nEnter the name of an item you want to keep in the 'Add' entry and click the 'Add' button and the script won't use that item when getting a deed.\n\nYou can either enter the full name of an item or just a partial name.\n\nFor example you can enter 'large yellow diamond' to keep all large yellow diamonds, or you can just enter 'diamond' to keep all diamonds.\n\nTo remove an item enter the name in the 'Remove' entry then click the 'Remove' button. Check the list below for all items you have already added.\n\nClick the 'Save' button to save any changes you have made.")
		label = @info["Labels"]["Keep Instructions"]
		label.wrap = true
		@info["Grids"]["Keep Instructions"].attach(label, 0, 0, 1, 1)
		
		names = [ "Keep Add", "Keep Remove" ]
		row = 0
		names.each{ |name|
			@info["Entries"][name] = Gtk::Entry.new
			
			@info["Entries"][name].signal_connect("changed"){
				entry = @info["Entries"][name]
				text = entry.text
				characters = text.gsub(/[^A-Za-z ]/, "") #Makes sure only characters and spaces are allowed in the entry.
				if text != characters
					entry.text = characters
					entry.position = characters.length
				end
			}

			@info["Buttons"][name] = Gtk::Button.new(:label => name.sub("Keep ", ""))
			@info["Grids"]["Keep Entries"].attach(@info["Entries"][name], 0, row, 1, 1)
			@info["Grids"]["Keep Entries"].attach(@info["Buttons"][name], 1, row, 1, 1)			
			row += 1
		}
		
		@info["Buttons"]["Keep Save"] = Gtk::Button.new(:label => "Save")
		@info["Buttons"]["Keep Remove All"] = Gtk::Button.new(:label => "Remove All")
		@info["Grids"]["Keep Entries"].attach(@info["Buttons"]["Keep Save"], 2, 0, 1, 1)
		@info["Grids"]["Keep Entries"].attach(@info["Buttons"]["Keep Remove All"], 2, 1, 1, 1)
		@info["Buttons"]["Keep Save"].signal_connect("clicked"){ save_settings }
		@info["Buttons"]["Keep Add"].signal_connect("clicked"){ change_keep_settings("Keep Add") }
		@info["Buttons"]["Keep Remove"].signal_connect("clicked"){ change_keep_settings("Keep Remove") }
		@info["Buttons"]["Keep Remove All"].signal_connect("clicked"){
			@info["Entries"]["Keep Remove"].text = ""
			@info["All Save Items"] = []
			@info["Labels"]["Keep List"].text = ""
		}

		@info["Labels"]["Keep List"] = Gtk::Label.new("")
		@info["Labels"]["Keep List"].set_selectable(true)
		@info["Labels"]["Keep List"].wrap = true
		@info["Grids"]["Keep List"].attach(@info["Labels"]["Keep List"], 0, 0, 1, 1)
		array = @info["All Save Items"]
		if array.count > 0
			array.sort!
			@info["Labels"]["Keep List"].text = array.join(", ")
		end

		#Create buttons.
		buttons = [ "Save", "Defaults", "Get Deeds", "Stop", "Confirm", "Decline", "Use Silver" ]
		buttons.each{ |button_name| @info["Buttons"][button_name] = Gtk::Button.new(:label => button_name) }
		@info["Buttons"]["Stop"].sensitive = false
		
		#Click this button to save the current settings.
		@info["Buttons"]["Save"].signal_connect("clicked"){ save_settings }
		
		#Click this button to change all settings to their defaults.
		@info["Buttons"]["Defaults"].signal_connect("clicked"){ set_default_settings }
		
		#Clicking this button will begin the process of appraising items and getting the number of deeds required. After this button is clicked
		#Until the process is finished: no settings can be changed and only the "Stop" button can be clicked.
		#The "Confirm", "Decline", and "Use Silver" buttons can also be clicked when permission is requested.
		#the only setting/button that can be clicked is the "Stop" button until the process is finished or the "Stop" button has been clicked.
		@info["Buttons"]["Get Deeds"].signal_connect("clicked"){
			@info["STOP"] = nil
			@info["Get Deeds"] = true
		}
		
		#Clicking this button will stop whatever actions the script is performing as soon as possible.
		@info["Buttons"]["Stop"].signal_connect("clicked"){
			@info["Permission Granted"] = "No"
			@info["STOP"] = true
		}
		
		#Clicking this button grants permission to use the listed items whenever confirmation is required from the user.
		@info["Buttons"]["Confirm"].signal_connect("clicked"){ @info["Permission Granted"] = "Yes" }
		@info["Buttons"]["Confirm"].sensitive = false
		
		#Clicking this button declines permission to use the listed items whenever confirmation is required from the user.
		@info["Buttons"]["Decline"].signal_connect("clicked"){ @info["Permission Granted"] = "No" }
		@info["Buttons"]["Decline"].sensitive = false
		
		#Clicking this button grants permission to use silvers when doing so would cost less than the value of the selected items.
		@info["Buttons"]["Use Silver"].signal_connect("clicked"){ @info["Permission Granted"] = "Use Silver" }
		@info["Buttons"]["Use Silver"].sensitive = false
		
		#Create checkboxes.
		check_boxes = [ "Confirm Checkbox", "Use Silver Checkbox", "Auto Multiplier", "Buy Dwarf Rubies" ]
		check_boxes.each{ |box_name|
			if box_name == "Confirm Checkbox"
				@info["Checkboxes"][box_name] = Gtk::CheckButton.new("Confirm")
			elsif box_name == "Use Silver Checkbox"
				@info["Checkboxes"][box_name] = Gtk::CheckButton.new("Use Silver")
			else
				@info["Checkboxes"][box_name] = Gtk::CheckButton.new(box_name)
			end
			@info["Checkboxes"][box_name].active = true if @character_settings[box_name] == "Yes"
		}

		@info["Checkboxes"]["Confirm Checkbox"].signal_connect("toggled"){ confirm_silver_checkbox_status }
		@info["Checkboxes"]["Use Silver Checkbox"].signal_connect("toggled"){ confirm_silver_checkbox_status }
		@info["Checkboxes"]["Buy Dwarf Rubies"].signal_connect("toggled"){
			dwarf_ruby_status
			confirm_silver_checkbox_status
		}
		@info["Checkboxes"]["Auto Multiplier"].signal_connect("toggled"){ auto_multiplier_status }
		
		#Attatch widgets to grids.
		@info["Grids"]["Main Window Info Grid"].attach(@info["Labels"]["Main Window Info Label"],	0, 0, 1, 1)
		
		@info["Grids"]["Main Window Checkboxes"].attach(@info["Checkboxes"]["Confirm Checkbox"],	0, 0, 1, 1)
		@info["Grids"]["Main Window Checkboxes"].attach(@info["Checkboxes"]["Use Silver Checkbox"],	1, 0, 1, 1)
		@info["Grids"]["Main Window Checkboxes"].attach(@info["Checkboxes"]["Auto Multiplier"],		2, 0, 1, 1)
		@info["Grids"]["Main Window Checkboxes"].attach(@info["Checkboxes"]["Buy Dwarf Rubies"],	3, 0, 1, 1)

		@info["Grids"]["Main Window Menus"].attach(@info["Menus"]["Town List"],			0, 0, 1, 1)
		@info["Grids"]["Main Window Menus"].attach(@info["Menus"]["Container List"],	0, 1, 1, 1)

		@info["Grids"]["Main Window Buttons"].attach(@info["Buttons"]["Save"],			0, 0, 1, 1)
		@info["Grids"]["Main Window Buttons"].attach(@info["Buttons"]["Defaults"],		1, 0, 1, 1)
		@info["Grids"]["Main Window Buttons"].attach(@info["Buttons"]["Get Deeds"],		0, 1, 1, 1)
		@info["Grids"]["Main Window Buttons"].attach(@info["Buttons"]["Stop"],			1, 1, 1, 1)
		@info["Grids"]["Main Window Buttons"].attach(@info["Buttons"]["Confirm"],		0, 2, 1, 1)
		@info["Grids"]["Main Window Buttons"].attach(@info["Buttons"]["Decline"],		1, 2, 1, 1)
		@info["Grids"]["Main Window Buttons"].attach(@info["Buttons"]["Use Silver"],	2, 2, 1, 1)
		
		@info["Grids"]["Main Window Instructions Grid"].attach(@info["Labels"]["Main Window Instructions Label"], 0, 0, 1, 1)
		
		#When the button to close the window is clicked it closes the window, sets @main_window to nil, quits the Gtk.main, and stops the script ;dirty-deeds
		@main_window.signal_connect("destroy"){
			@main_window.close
			@main_window = nil
			save_stats
			Gtk.main_quit
			Script.kill("dirty-deeds")
		}
		
		#Create header for GTK window.
		header = Gtk::HeaderBar.new
		header.set_name("main_header")
		header.show_close_button = true
		header_box = Gtk::Box.new(:vertical, 0)
		label_1 = Gtk::Label.new("Dirty Deeds")
		label_2 = Gtk::Label.new(Char.name)
		label_1.halign = :center
		label_2.halign = :center
		header_box.pack_start(label_1, expand: false, fill: false, padding: 0)
		header_box.pack_start(label_2, expand: false, fill: false, padding: 0)
		header_box.show_all
		header.set_custom_title(header_box)
		@main_window.titlebar = header
		
		@main_window.show_all
		update_all_stats
		confirm_silver_checkbox_status #This line has to be below @main_window.show_all or else the "Confirm" box will always be shown.
		dwarf_ruby_status
		auto_multiplier_status
		@info.each{ |data,value| value.each{ |widget_name,widget| widget.set_tooltip_text(@tooltips[widget_name]) if widget.is_a?(Gtk::Widget) && !widget.is_a?(Gtk::Notebook) && !widget.is_a?(Gtk::Grid) } if value.is_a?(Hash) }
		
		@info["Instructions Array"] << "Items are worth more than their value when used to get a deed, but the exact multiplier is unknown. Use the 'Item Multiplier' to set how much you want to value items when trying for a deed."
		@info["Instructions Array"] << "Through my own testing: gems in the Landing seem to have a #{@info["Auto Multiplier Lower Multi"]}x multiplier if the gem value is less than 1000, and a #{@info["Auto Multiplier Higher Multi"]}x multiplier for items with values of 1000+. Dwarf-cut rubies also seem to have a #{@info["Auto Multiplier Higher Multi"]}x multiplier. The 'Auto Multiplier' setting uses these values."
		@info["Instructions Array"] << "Icemule multiplier seems to be anywhere from 3x-17x."
		@info["Instructions Array"] << "Experiment with different multipliers to find a good multiplier that gives you the most value for your items while still getting a deed."
		@info["Instructions Array"] << "If you fail to get a deed: try lowering the 'Item Multiplier'."
		update_instructions
	end
	
	before_dying{ @main_window.close if @main_window } #This closes the @main_window if the script is stopped.
end

#Get list of all worn containers.
containers = Lich::Util.quiet_command_xml("inv containers", /You are wearing|You are holding/)
DirtyDeedsMain.set_worn_containers(containers)
#

DirtyDeedsMain.load_settings
DirtyDeedsMain.load_stats

Gtk.queue {
	DirtyDeedsMain.create_main_window
	Gtk.main
}

#The below are all variables that the old version of ;dirty-deeds used. These variables are no longer needed so this code is just here to nil out all unnecessary values.
#The below code can be deleted and it won't affect anything in the script.
UserVars.dirty_deeds = nil
CharSettings['deed_attempt_stats_for_landing'] = nil
CharSettings['minimum_value_needed_for_deed_in_landing'] = nil
CharSettings['deed_attempt_stats_for_icemule'] = nil
CharSettings['minimum_value_needed_for_deed_in_icemule'] = nil
CharSettings['deed_attempt_stats_for_riverrest'] = nil
CharSettings['minimum_value_needed_for_deed_in_riverrest'] = nil
CharSettings['gems_to_ignore'] = nil
#####

sleep #This keeps the script running while the window is open. This prevents starting the script again while the window is already open.