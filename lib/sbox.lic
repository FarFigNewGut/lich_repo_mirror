# frozen_string_literal: true

# quiet
# SBox by SpiffyJr

#  author: SpiffyJr
#    name: SBox
#    tags: locksmith rogue

# changelog:
#     2020.04.16 - Initial code.

# SBox module for SpiffyBox
# Note: this entire module functions on the premise that downstream xml is enabled and normal downstream is disabled
module SBox
  # A trap
  class Trap
    @@traps = [
      {
        type: :acid_vial,
        detect: /crush the vial and release whatever substance/,
        success: /You carefully push a small ball of cotton/,
        inert: Regexp.union(
          /lock mechanism, but it appears empty/,
          /A small ball of cotton has been pushed/
        ),
        component: 'vial'
      },
      {
        type: :boomer,
        detect: /Carefully, you feel around the lock and notice the inside chamber/,
        success: /Using a bit of putty from your/,
        inert: /A thin layer of mud or putty has been dabbed/
      },
      {
        type: :contest,
        detect: /Looking inside, you see what appears to be a little flag rolled around a thin rod\./,
        success: /Reaching inside the hole with the tip of your lockpick,/,
        inert: /The flag has been pushed to one side, preventing its exit from the hole./
      },
      {
        type: :dark_crystal,
        detect: /It looks as if opening the lock without the exact key could shatter it./,
        success: /With a little ingenuity you manage to grind down parts/,
        inert: /parts of the mechanism have been ground away/,
        component: 'crystal'
      },
      {
        type: :gas_cloud,
        detect: /small vial of liquid/,
        success: /Using the metal grips/,
        inert: /tiny hammer device which has been bent/,
        component: 'vial'
      },
      {
        type: :fire_vial,
        detect: /small vial of fire-red liquid/,
        success: /Using the metal grips/,
        inert: /tiny hammer device which has been bent/,
        component: 'vial'
      },
      {
        type: :glyph,
        detect: /You notice some spiderweb-like scratches on the lock plate which seem/,
        success: /Knowing how delicate magical glyphs can be, you scrape/,
        inert: /This may prevent any magical nature they have from manifesting itself\./
      },
      {
        type: :jaws,
        detect: /You notice a discolored oval ring around the outside/,
        success: /Using the pair of metal grips, you manage to pull/,
        inert: /but the pins that hold the jaws together have been pushed out\./,
        component: 'jaws'
      },
      {
        type: :needle,
        detect: /Hmmm, you can see what appears to be a tiny/,
        success: Regexp.union(
          /Using a bit of putty/,
          /Using a pair of metal grips, you carefully remove a/
        ),
        inert: Regexp.union(
          /You see a tiny hole next to the lock plate which has been completely plugged\./,
          /However, nothing about it seems to indicate cause for alarm\./
        ),
        component: 'needle'
      },
      {
        type: :plated,
        detect: /There appears to be a plate over the lock/,
        success: /carefully pour the contents/,
        inert: /granting sufficient access to the lock/
      },
      {
        type: :rods,
        detect: /Looking closely into the keyhole, you notice a pair of small metal rods/,
        success: /With great care you take a pair of metal grips and bend the sensitive/,
        inert: /that have been bent in opposite directions of each other/
      },
      {
        type: :scales,
        tools: [:knife],
        detect: /Closer examination reveals the "scales" to be razor/,
        success: /slice through the cord\.  That oughta do it\./,
        inert: /you see what appears to be a thin cord dangling from the case/
      },
      {
        type: :scarab,
        detect: /Peering closely into the lock, you spy a/,
        success: /You carefully nudge the scarab free of its/,
        inert: /The lock appears to be free of all obstructions/
      },
      {
        type: :sphere,
        tools: [:lockpick],
        detect: /held in a metal bracket towards the back of the lock mechanism/,
        success: /With utmost care, you slip your/,
        inert: /A thorough search of the area inside the tumblers reveals/,
        component: 'sphere'
      },
      {
        type: :spores,
        detect: /lock, you see a small tube towards the bottom of the tumbler mechanism/,
        success: /Taking a lump of putty/,
        inert: /It appears as though the tube has been plugged with something/
      },
      {
        type: :springs,
        detect: /you notice what appears to be the ends of springs incorporated with the hinges/,
        success: /With a little force applied to the springs/,
        inert: /You discover no traps\./
      },
      {
        type: :sulphur,
        detect: /Feeling around the inside of the lock, you notice that/,
        success: /You carefully use the tip of a small metal file to scrape away the rough/,
        inert: /you notice a deflated bladder wedged between the tumblers/
      }
    ]

    def self.from_detect(box)
      raise ArgumentError, 'Expected Box' unless box.instance_of?(Box)

      res = dothistimeout("detect ##{box.id}", 5, /You carefully begin to examine (?:an? )?/)
      raise ScriptError, 'Unable to find detect line' if res.nil?

      trap = nil

      while (line = get)
        break if line =~ /You discover no traps|Roundtime/
        break if line =~ /<prompt/

        if (data = @@traps.find { |t| line =~ t[:detect] || line =~ t[:disarmed] })
          trap = Trap.new(data)
          trap.disarmed = true if line =~ data[:disarmed]
        end

        next unless trap && line =~ /It looks like an? (.*) trap \((?:about )?-(\d+)\)/

        trap.difficulty = Regexp.last_match(2).to_i
      end

      trap
    end

    attr_accessor :difficulty, :mod
    attr_reader :component, :inert, :success, :tools, :type
    attr_writer :disarmed, :impossible

    def initialize(data)
      @component = data[:component]
      @difficulty = -1
      @impossible = false
      @inert = data[:inert]
      @mod = 0
      @success = data[:success]
      @tools = data[:tools]
      @type = data[:type]
    end

    def roll_required(lore: false)
      res = SBox.disarm_skill({ lore: lore }) - 100 - effective_difficulty
      res = (-1 * res) + 1
      res = 1 if res.negative?

      res
    end

    def effective_difficulty
      @difficulty - @mod
    end

    def disarmed?
      @disarmed
    end

    def impossible?
      @impossible
    end
  end

  # Box wraps GameObj for boxes
  class Box
    attr_accessor :difficulty, :level, :mod, :trap
    attr_writer :detected, :impossible, :unlocked

    def initialize(obj)
      raise ArgumentError, 'Expected GameObj' unless obj.instance_of?(GameObj)

      # GameObj
      @obj = obj

      # Box Properties
      @detected = false
      @difficulty = -1
      @disarmed = false
      @mod = 0
      @unlocked = false
    end

    def method_missing(method, *args, &block)
      if @obj.respond_to?(method)
        @obj.public_send(method, *args, &block)
      else
        super
      end
    end

    def respond_to_missing?
      true
    end

    def effective_difficulty
      @difficulty - @mod
    end

    def detected?
      @detected
    end

    def impossible?
      @impossible
    end

    def measured?
      @difficulty != -1
    end

    def unlocked?
      @unlocked
    end

    def trapped?
      !@trap.nil?
    end
  end

  # Data that's stored as a global because Lich pretty much requires that
  # Settings are transferred on start and cached here as well.
  # This allows different modes to use different settings.
  class Data
    attr_accessor :box, :calibrate_count, :extract, :guild_rank, :lockpicks, :mode, :menu, :settings, :tools
    attr_writer :wedges

    def initialize
      @calibrate_count = 0
      @extract = false
      @guild_rank = 0
      @lockpicks = []
      @menu = []
      @settings = {}
      @tools = {}
      @wedges = []
    end

    def pristine_lockpicks
      @lockpicks.find_all { |lockpick| !lockpick.damaged? && !lockpick.broken? }
    end

    def tool(type)
      @tools[type]
    end

    def wedges
      @wedges.reject! { |obj| obj.status == 'gone' || obj.id.nil? }
      @wedges
    end

    def wedge(quality = nil)
      return wedges.first if quality.nil?

      quality_index = SBox.wedge_index(quality)
      wedges.find { |wedge| SBox.wedge_index(wedge.name) >= quality_index }
    end
  end

  # Tool wraps GameObj for locksmith tools (vials, calipers, knife, etc.)
  class Tool
    attr_accessor :in, :obj

    def initialize(obj, parent)
      @in = parent
      @obj = obj
    end

    def method_missing(method, *args, &block)
      if @obj.respond_to?(method)
        @obj.public_send(method, *args, &block)
      else
        super
      end
    end

    def respond_to_missing?
      true
    end

    def link
      "<a exist=\"#{id}\" noun=\"#{noun}\">#{name}</a>"
    end

    def get
      return if [GameObj.left_hand.id, GameObj.right_hand.id].include?(id)

      waitrt?

      cmd = @in.nil? ? "remove ##{id}" : "get ##{id} from ##{@in.id}"
      res = dothistimeout(cmd, 5, /You remove|You slide/)
      raise ScriptError, "Failed to get #{name}" unless res

      wait_until { [GameObj.left_hand.id, GameObj.right_hand.id].include?(id) }

      self
    end

    def store
      return unless [GameObj.left_hand.id, GameObj.right_hand.id].include?(id)

      waitrt?
      cmd = @in.nil? ? "wear ##{id}" : "_drag ##{id} ##{@in.id}"
      res = dothistimeout(cmd, 5, /You put|You place|You attach|You slide/)
      raise ScriptError, "Failed to store #{name}" unless res

      wait_while { [GameObj.left_hand.id, GameObj.right_hand.id].include?(id) }

      self
    end
  end

  # GnomishBracer has some special handling for Gnomish Mech Bracers
  class GnomishBracer < Tool
    attr_accessor :obj
    attr_reader :index, :lockpicks

    def initialize(obj)
      @index = 0
      @lockpicks = []

      super(obj, nil)
    end

    def add(lockpick)
      raise ArgumentError, 'Expected Lockpick' unless lockpick.instance_of?(Lockpick)

      @lockpicks.push(lockpick)
    end

    def spin(identifier)
      identifier = identifier.id if identifier.instance_of?(Lockpick)
      identifier = identifier.gsub(/^#/, '')

      index = @lockpicks.find_index { |lp| lp.id =~ /#{identifier}/ || lp.name =~ /#{identifier}/ }

      # Already in the proper place. Nothing to do.
      return if index.zero?

      # Bracers work from bottom up
      index = lockpicks.length - index

      # Pop from end and push to beginning to keep our cache proper
      index.times do
        @lockpicks.unshift(@lockpicks.pop)
      end

      res = dothistimeout("spin #{index} ##{@obj.id}", 3, /From its interior/)
      raise ScriptError, 'Invalid mech bracer spin response' if res.nil?
    end
  end

  # Lockpick wraps GameObj for lockpicks
  class Lockpick < SBox::Tool
    attr_accessor :ranks
    attr_writer :broken, :damaged

    @@data = [
      { type: :brass, mod: 1.0, ranks: 0 },
      { type: :copper, mod: 1.0, ranks: 0 },
      { type: :steel, mod: 1.10, ranks: 1 },
      { type: :ivory, mod: 1.20, ranks: 1 },
      { type: :gold, mod: 1.20, ranks: 3 },
      { type: :silver, mod: 1.30, ranks: 3 },
      { type: :mithril, mod: 1.45, ranks: 5 },
      { type: :ora, mod: 1.55, ranks: 5 },
      { type: :glaes, mod: 1.60, ranks: 8 },
      { type: :laje, mod: 1.75, ranks: 12 },
      { type: :vultite, mod: 1.80, ranks: 20 },
      { type: :rolaren, mod: 1.90, ranks: 20 },
      { type: :veniom, mod: 2.20, ranks: 25 },
      { type: :invar, mod: 2.25, ranks: 35 },
      { type: :alum, mod: 2.30, ranks: 16 },
      { type: :golvern, mod: 2.35, ranks: 40 },
      { type: :kelyn, mod: 2.40, ranks: 25 },
      { type: :vaalin, mod: 2.50, ranks: 50 }
    ]

    def initialize(obj, parent, inspect: false)
      super(obj, parent)

      @broken = false
      @damaged = false

      init_data(inspect)
    end

    def lore_required?(difficulty)
      difficulty > max({ lore: false })
    end

    def roll_required(difficulty, lore: false)
      return nil unless difficulty

      res = max({ lore: lore }) - 100 - difficulty
      res = (-1 * res) + 1
      res = 1 if res.negative?

      res
    end

    def mod
      multiplier = (Skills.pickinglocks.to_f / ranks)
      multiplier = 1 if multiplier > 1
      multiplier < 1 ? ((@_mod * multiplier) - 0.05) : @_mod
    end

    def max(lore: false)
      (SBox.pick_skill({ lore: lore }) * mod).floor
    end

    def material
      data = @@data.find { |d| name =~ /\b#{d[:type]}\b/ }
      raise ScriptError, "Failed to find material for #{name}" unless data

      data[:type]
    end

    def damaged?
      @damaged
    end

    def broken?
      @broken
    end

    def status
      return :broken if broken?
      return :damaged if damaged?

      :perfect
    end

    private

    def init_data(inspect)
      data = @@data.find { |d| name =~ /\b#{d[:type]}\b/ }
      raise ScriptError, 'Unable to determine lockpick data' unless data

      @_mod = data[:mod]
      @ranks = data[:ranks]

      return unless inspect

      res = dothistimeout(
        "look at ##{id}",
        5,
        /You quickly examine|appears to be broken|somewhat damaged|You see nothing unusual/
      )
      raise ScriptError, 'Unable to determine lockpick status' unless res

      @damaged = true if res =~ /damaged/i
      @broken = true if res =~ /broken/i
    end
  end

  def self.link(obj)
    "<a exist=\"#{obj.id}\" noun=\"#{obj.noun}\">#{obj.name}</a>"
  end

  def self.preset(msg)
    _respond("<preset id='speech'>[#{@script.name}: #{msg}]</preset>")
  end

  def self.meta(key)
    tag = Room.current.tags.find { |t| t =~ /#{"meta:#{key}"}/ }
    return Regexp.last_match(1) if tag =~ /^#{"meta:#{key}"}:(.*)$/

    nil
  end

  def self.go2_toolbench
    unless checkroom =~ /toolbench/i
      move(XMLData.room_exits.sample) unless Room.current.id
      Script.run('go2', 'rogue guild workshop')
      move('go toolbench')
      sleep(1)
    end
    raise ScriptError, 'Failed to find rogue guild toolbench' unless checkroom =~ /toolbench|workbench/i
  end

  def self.find_box(input = nil)
    @data.box = nil if @data.box.status == 'gone' || @data.box.unlocked?
    return @data.box if @data.box

    box = nil

    if GameObj.right_hand.name =~ /(?:box|chest|coffer|strongbox|trunk)$/
      box = GameObj.right_hand
    elsif GameObj.left_hand.name =~ /(?:box|chest|coffer|strongbox|trunk)$/
      box = GameObj.left_hand
    elsif input.instance_of?(Array)
      box = input.find { |b| b.name =~ /(?:box|chest|coffer|strongbox|trunk)$/ }
    elsif input.instance_of?(GameObj)
      box = input
    end

    @data.box = Box.new(box) unless box.nil?
  end

  def self.deposit
    room = Room.current
    Script.run('go2', 'bank')
    dothistimeout('deposit all', 5, /You deposit/)
    Script.run('go2', room.id.to_s)
  end

  def self.tough_lock
    ranks = Skills.pickinglocks
    baseline = ((Char.level + 1) * 2)

    if ranks >= baseline
      mod = ((60 * ranks) / baseline)
    else
      mod = ((30 * ranks) / baseline)
    end

    actual = ((baseline - ranks) * mod)
    effective = (ranks + (actual / 100))

    if effective >= 40
      effective = (100 + effective)
    elsif effective >= 30
      effective = (120 + ((effective - 30) * 2))
    elsif effective >= 20
      effective = (90 + ((effective - 20) * 3))
    elsif effective >= 10
      effective = (50 + ((effective - 10) * 4))
    elsif effective >= 0
      effective = (effective * 5)
    end
    effective = 35 if effective < 35

    # Add in stat bonus
    base_tough = effective + Stats.enhanced_dex[1]

    if ranks >= 50
      max_tough = (base_tough + ((base_tough * 150) / 100))
    elsif ranks >= 25
      max_tough = (base_tough + ((base_tough * 120) / 100))
    elsif ranks >= 20
      max_tough = (base_tough + ((base_tough * 90) / 100))
    else
      max_tough = (base_tough + ((base_tough * 60) / 100))
    end

    {
      base: base_tough,
      max: max_tough
    }
  end

  def self.choose_lockpick(
    difficulty:,
    lockpicks: @data.pristine_lockpicks,
    ranks: @data.settings[:ranks],
    roll: @data.settings[:pick_roll]
  )
    need_to_lore = false
    pick_to_use = nil

    if @data.mode == :contest
      pick_to_use = lockpicks.max_by(&:mod)
      need_to_lore = true
    elsif @data.settings[:tough_pick_reps]
      best_pick = lockpicks.max_by(&:mod)
      max = (tough_lock[:base] * best_pick.mod).floor
      check = ((max - 200) + (((@data.guild_rank / 2) * 3).floor / 2).floor)
      check = ((max * 3) / 4).floor if check < ((max * 3) / 4).floor
      preset("Tough guild reps are enabled. Need > #{check} to qualify.")

      if difficulty > check
        pick_to_use = best_pick
        need_to_lore = true
      end
    elsif @data.settings[:audience_reps]
      best_pick = lockpicks.max_by(&:mod)
      max = (tough_lock[:base] * best_pick.mod).floor
      check = ((max - 300) + (((@data.guild_rank / 2) * 3).floor / 2).floor)
      check = ((max * 5) / 8).floor if check < ((max * 5) / 8).floor
      preset("Audience guild reps are enabled. Need > #{check} to qualify.")

      if difficulty > check
        pick_to_use = best_pick
        need_to_lore = true
      end
    end

    lockpicks = lockpicks.clone
    lockpicks.sort! { |a, b| a.mod - b.mod}

    usable_lockpicks = lockpicks.find_all do |lockpick|
      Skills.pickinglocks >= lockpick.ranks && ranks <= lockpick.ranks
    end

    if pick_to_use.nil?
      pick_to_use = usable_lockpicks.find do |lockpick|
        lockpick.roll_required(difficulty, { lore: false }) <= roll
      end
    end

    if pick_to_use.nil? && (@data.guild_rank.positive? || Spell[403].known?)
      pick_to_use = usable_lockpicks.find do |lockpick|
        lockpick.roll_required(difficulty, { lore: true }) <= roll
      end

      # Found one with lore required. Need to put it up.
      need_to_lore = true unless pick_to_use.nil?
    end

    if need_to_lore
      start_pick_lore
    else
      stop_pick_lore
    end

    pick_to_use
  end

  def self.detect(box = find_box)
    raise ArgumentError, 'Expected Box' unless box.instance_of?(Box)

    if !box.detected? && (bracer = @data.tool(:bracer)) && @data.mode != :contest && @data.settings[:bracer_detect]
      res = dothistimeout("rub ##{bracer.id}", 3, /A moment later/)
      raise ScriptError, 'Invalid rub bracer response' if res.nil?

      if res =~ /bright green light/
        box.detected = true
        box.trap = nil
      end

      waitrt?
    end

    return if box.detected?

    box.trap = Trap.from_detect(box)
    box.detected = true
  end

  def self.disarm(
    box: find_box,
    roll: @data.settings[:disarm_roll]
  )
    raise ArgumentError, 'Expected Box' unless box.instance_of?(Box)

    detect(box) unless box.detected?

    return if box.detected? && !box.trapped?
    return if box.trap.disarmed?
    return if box.trap.type == :scales && !box.unlocked?

    if box.trap.type == :plated
      res = dothistimeout("look in ##{@data.tool(:toolkit).id}", 3, /Peering into the/)
      raise ScriptError, 'Failed to find toolkit contents' if res.nil?

      if res !~ /(\d+) vials? of liquid/ && !@data.settings[:wedge]
        preset("Trap is plated and can't be disarmed: marking as impossible")
        box.trap.impossible = true
      end
    end

    roll_required_lore = box.trap.roll_required({ lore: true })
    if roll_required_lore > roll
      preset('Trap is too difficult to disarm: marking as impossible')
      box.trap.impossible = true
      return
    end

    roll_required = box.trap.roll_required({ lore: false })
    if roll_required > roll || @data.mode == :contest
      roll_required = roll_required_lore
      start_disarm_lore
    else
      stop_disarm_lore
    end

    box.trap.tools.each do |tool|
      @data.tool(tool).get
    end

    loop do
      waitrt?

      preset(
        format(
          '%<box>s (%<box_trap>s - %<box_mod>s = %<box_eff_trap>s): requires %<roll>s or higher',
          {
            box: box.name,
            box_mod: box.mod,
            box_eff_trap: box.trap.effective_difficulty,
            box_trap: box.trap.difficulty,
            roll: roll_required
          }
        )
      )

      if Char.prof == 'Rogue' && @data.guild_rank >= 39 && box.trap.component
        need_to_extract = @data.settings[:extract].include?(box.trap.component)

        unless need_to_extract == @data.extract
          if need_to_extract
            fput('lmas disarm on')
          else
            fput('lmas disarm off')
          end
        end
      end

      res = dothistimeout(
        "disarm ##{box.id}",
        5,
        Regexp.union(
          box.trap.inert,
          box.trap.success,
          /You still have a good/,
          /BOOM/
        )
      )
      raise ScriptError, 'Unknown disarm result' unless res

      if reget.reverse.find do |line|
           line =~ /You are not able to disarm the trap but you get a sense that/
         end && reget.reverse.find do |line|
                  line =~ /^You .* attempt \(d100=(\d+)\)./
                end
        # Bonus for spotting is ((roll - 76) / 5 ) + 1) with a max of 50
        roll = Regexp.last_match(1).to_i
        box.trap.mod += ((roll - 76) / 5).floor + 1
      end

      next if res =~ /You still have a good/

      box.trap.disarmed = true

      waitrt?

      break
    end

    box.trap.tools.each do |tool|
      @data.tool(tool).store
    end

    waitrt?

    # We try to put vials in the toolkit and everything else gets stowed.
    if box.trap.component == 'vial'
      if [GameObj.right_hand.noun, GameObj.left_hand.noun].include?('vial')
        kit = @data.tool(:toolkit)
        kit.get

        dothistimeout('swap', 3, /You swap/) if GameObj.left_hand.id == kit.obj.id

        res = dothistimeout('bundle', 3, /has no more room for vials|You transfer|You add/)
        raise ScriptError, 'Unknown bundle response' if res.nil?

        fput('stow left') if res =~ /has no more room/

        kit.store
      end
    elsif box.trap.component
      fput('stow right') if GameObj.right_hand.noun =~ /#{box.trap.component}/
      fput('stow left') if GameObj.left_hand.noun =~ /#{box.trap.component}/
    end

    if box.trap.type == :scarab
      scarab = GameObj.loot[0]
      raise ScriptError, 'Failed to find your scarab' unless scarab

      waitrt?

      res = dothistimeout("disarm ##{scarab.id}", 5, /Knowing how delicate/)
      raise ScriptError, 'Unknown scarab disarm result' unless res

      dothistimeout("loot ##{scarab.id}", 5, /You pick up/)
    end

    waitrt?
  end

  def self.calibrate
    return unless Char.prof == 'Rogue' && @data.guild_rank >= 10

    calipers = @data.tool(:calipers)

    unless calipers
      preset('You have no calipers available.  Skipping calibration phase.')
      return
    end

    calipers.get

    res = nil
    until res =~ /You should leave them alone|You're good, but you're not that good|They practically glow with calibration!/
      match = Regexp.union(
        /You're good/,
        /You begin attuning/,
        /You make some/,
        /It is beyond/,
        /You should leave them alone/,
        /You're good, but you're not that good/,
        /They practically glow with calibration!/
      )
      res = dothistimeout("lmas calibrate ##{calipers.id}", 5, match)
      raise ScriptError, 'Unknown calibrate response' unless res

      waitrt?
    end

    calipers.store

    # Calibrated, reset counter.
    @data.calibrate_count = 0
  end

  def self.measure(box = find_box)
    raise ArgumentError, 'Expected Box' unless box.instance_of?(Box)

    disarm(box: box)

    # By default, we'll use a max lock for the box difficulty.
    box.difficulty = pick_skill({ lore: true }) - @data.settings[:pick_roll] - 1

    return if @data.settings[:wedge] && @data.settings[:wedge_always]
    return if box.trapped? && box.trap.type == :plated
    return unless @data.settings[:measure]
    return unless Char.prof == 'Rogue' && @data.guild_rank >= 6

    calipers = @data.tool(:calipers)

    unless calipers
      preset('You have no calipers available. Skipping measure phase.')
      return
    end

    unless box.measured?
      calipers.get

      res = dothistimeout("lmas measure ##{box.id}", 5, /Roundtime|already been unlocked/)
      raise ScriptError, 'Unknown measure result' unless res

      if res =~ /already been unlocked/
        @data.tool(:calipers).store
        box.unlocked = true
        return
      end

      res = waitfor('Measuring carefully,')
      if res =~ /Measuring carefully, it looks to be an? .* lock \(-(\d+) in thief-lingo difficulty ranking\)\./
        box.difficulty = Regexp.last_match(1).to_i
        if box&.trap&.type == :scales
          preset('Scales was detected: bumping lock difficulty by 50 for safety.')
          box.difficulty += 50
        end
      end
    end

    waitrt?
    @data.tool(:calipers).store
    @data.calibrate_count += 1
  end

  def self.pick(box = find_box)
    raise ArgumentError, 'Expected Box' unless box.instance_of?(Box)

    measure(box) unless box.measured?

    # If it's unlocked, or locked and a scales we have nothing to do.
    return if box.unlocked? && (!box.trapped? || box.trap.type != :scales)

    # Impossible and we can't wedge, nothing to do.
    return if box.impossible? && !@data.settings[:wedge]

    # Should we wedge it?
    if @data.settings[:wedge]
      should_wedge = box.impossible? && (!box.trapped? || box.trap.disarmed?)
      should_wedge ||= box.trapped? && !box.trap.disarmed? && box.trap.type == :plated
      should_wedge ||= @data.settings[:wedge_always]

      # Certain levels we can get reps for wedging
      if @data.settings[:tough_wedge_reps]
        should_wedge ||= box.difficulty >= tough_lock[:max]

        if Char.level < 25
          should_wedge ||= (@data.box.level + 10) >= Char.level
        elsif Char.level < 50
          should_wedge ||= (@data.box.level + 15) >= Char.level
        elsif Char.level < 75
          should_wedge ||= (@data.box.level + 20) >= Char.level
        else
          should_wedge ||= (@data.box.level + 25) >= Char.level
        end
      end

      should_wedge &&= !box.trapped? || box.trap.type != :scales

      return wedge(box) if should_wedge
    end

    # Lockpick for the attempt
    command = nil
    lockpick = nil
    need_lore = false
    roll_required = 0

    refresh_lockpick = proc do
      lockpick&.store
      if (lockpick = choose_lockpick(difficulty: box.effective_difficulty)).nil?
        preset('Box is too difficult to pick: marking as impossible')
        box.impossible = true
      else
        if box.effective_difficulty
          need_lore = lockpick.lore_required?(box.effective_difficulty)
          roll_required = lockpick.roll_required(box.effective_difficulty, { lore: need_lore })
        end

        # Bracer exists. Just need to spin it.
        if lockpick.in.instance_of?(GnomishBracer) && !@data.settings[:audience_reps] && @data.mode != :contest
          lockpick.in.spin(lockpick.id)
          command = "push ##{lockpick.in.id}"
        else
          lockpick.get
          command = @data.settings[:command].gsub('$B', "##{box.id}").gsub('$L', "##{lockpick.id}")
        end
      end
    end

    refresh_lockpick.call

    # Repeat pick process until we get a success or failure
    loop do
      if box.trap.impossible?
        preset("Trap (#{box.trap.effective_difficulty}) is impossible with current settings and equipment")
        return
      end

      if box.impossible?
        preset("Lock (#{box.box.effective_difficulty}) is impossible with current settings and equipment")

        # If it's scaled we sure as shit won't be wedging it
        return if box.unlocked? && (!box.trapped? || box.trap.type != :scales)

        if @data.settings[:wedge]
          preset('Wedging is enabled: attempting to wedge it')
          sleep(3)
          return wedge(box)
        end

        return
      end

      waitrt?

      preset(
        format(
          '%<p>s (%<p_max>d) vs %<b>s (%<b_lock>s - %<b_mod>s = %<b_eff_lock>s): requires %<r>s or higher',
          {
            p: lockpick.link,
            p_max: lockpick.max({ lore: need_lore }),
            b: box.name,
            b_eff_lock: box.effective_difficulty,
            b_lock: box.difficulty,
            b_mod: box.mod,
            r: roll_required
          }
        )
      )

      match = Regexp.union(
        /It does not appear/,
        /d100/,
        /you are using a broken lockpick/,
        /is broken as the arm/,
        /is already unlocked or open/
      )
      res = dothistimeout(command, 5, match)
      raise ScriptError, 'Invalid pick response' unless res

      case res
      when /It does not appear|is already unlocked or open/
        box.unlocked = true
        break
      when /\(d100=(\d+)\)/
        rolled = Regexp.last_match(1).to_i
      when /broken/
        lockpick.broken = true
        refresh_lockpick.call
        next
      end

      difficulty = box.effective_difficulty
      roll_required = lockpick.roll_required(difficulty, { lore: need_lore })

      # Check each line from the result and make updates as neccessary
      loop do
        break if box.unlocked?
        break if (line = get) =~ /Roundtime/

        # Increase difficulty if we got a read and didn't roll high enough
        if roll_required && rolled >= roll_required
          case line
          when /but you get a feeling that it is within your abilities/ # This occurs on endrolls > 60 and < 100
            preset("Boosting lock difficulty by 15. Got a read on #{rolled}.")
            box.difficulty += 15
          when /little about it/
            preset("Boosting lock difficulty by 25. Failed to read on #{rolled}.")
            box.difficulty += 25
          end
        elsif line =~ /but it may have been weakened by the stress/
          preset("Boosting lock difficulty by 35. Weakened on #{rolled}.")
          box.difficulty += 35
        end

        lockpick.broken = true if line =~ /Crud!  You broke/
        lockpick.damaged = true if line =~ /but end up bending the tip/

        if line =~ /About a -(\d+) difficulty lock \(in thief-lingo\)/
          box.difficulty = Regexp.last_match(1).to_i
          box.mod += 5
          box.mod = 200 if box.mod > 200
        end

        box.unlocked = true if line =~ /Then...CLICK!/
      end

      waitrt?

      # All done
      break if box.unlocked?
      # If the lockpick status and box difficulty stay the same we just continue on
      next if difficulty == box.effective_difficulty && !lockpick.damaged? && !lockpick.broken?

      refresh_lockpick.call
    end

    lockpick.store

    calibrate if @data.calibrate_count >= @data.settings[:calibrate_count]

    # Scales check
    return unless box.trapped? && box.trap.type == :scales

    preset('Scales detected and box is unlocked, disarming now.')
    disarm(box: box)
  end

  def self.wedge(box = find_box)
    raise ArgumentError, 'Expected Box' unless box.instance_of?(Box)

    get_wedge = proc do
      tool = @data.wedges.find { |w| w.id && (w.id == GameObj.right_hand.id || w.id == GameObj.left_hand.id) }
      tool ||= @data.wedge.get
      next tool if tool

      room = Room.current
      make_wedges
      Script.run('go2', room.id.to_s)
      raise ScriptError, 'Failed to return to room' if Room.current.id != room.id

      get_wedge.call
    end

    disarm(box: box)

    loop do
      tool = get_wedge.call

      waitrt?
      res = dothistimeout("lmas wedge ##{box.id}", 5, /You insert the tip|Wedge what\?/i)
      raise ScriptError, 'Unknown wedge result' unless res

      if res =~ /Wedge what\?/
        tool.store
        break
      end

      res = waitfor('suddenly splits away', 'Roundtime')
      raise ScriptError, "Unknown wedge success result: #{res}" unless res

      # Update the wedge object
      tool.obj = GameObj.right_hand

      # Success?
      next unless res =~ /suddenly splits away/

      tool.store unless tool.obj.id.nil?
      box.impossible = false
      box.unlocked = true
      break
    end

    waitrt?
  end

  def self.scan
    _respond
    _respond('<b>Scanning inventory for items.  This will be a bit spammy.</b>')
    _respond
    sleep(0.250)

    @data.extract = false
    @data.guild_rank = 0
    @data.lockpicks = []
    @data.tools = {}
    @data.wedges = []

    # Get guild rank if available
    if Char.prof == 'Rogue'
      res = dothistimeout(
        'gld',
        3,
        Regexp.union(
          /You have (\d+) ranks? in the Lock Mastery skill\./,
          /You are a Master of Lock Mastery\./,
          /You have no guild affiliation\./
        )
      )
      raise ScriptError, 'Unable to determine guild ranks' if res.nil?

      case res
      when /You have (\d+) ranks/
        @data.guild_rank = Regexp.last_match(1).to_i
      when /You are a Master/
        @data.guild_rank = 63
      else
        @data.guild_rank = 0
      end

      # Check for trap extraction
      if @data.guild_rank >= 39
        res = dothistimeout('lmas disarm', 3, /you're not trying|to turn off/)
        if res =~ /to turn off/
          @data.extract = true
        else
          @data.extract = false
        end
      end
    end

    res = dothistimeout('inv containers', 5, /You are wearing/)

    # Scan each container for contents that are important to us.
    # This includes things like: lockpicks, calipers, toolkit, etc.
    res.scan(%r{<a exist="([^"]+)" noun="([^"]+)">([^<]+)</a>}).each do |match|
      res = dothistimeout("look in ##{match[0]}", 5, /In the|Peering into|There is nothing|Within the \w+ casings/)
      raise ScriptError, 'Unknown look scan result' if res.nil?
      raise ScriptError, "No GameObj found for ##{match[0]}" if (obj = GameObj[match[0]]).nil?

      # Special handling for Gnomish Mech Bracer
      if res =~ /Within the .* you see/
        bracer = GnomishBracer.new(obj)
        @data.tools[:bracer] = bracer

        # Custom scan to load up the lockpicks in the bracer
        res.gsub(/Within the .* you see/, '').scan(%r{<a exist="([^"]+)" noun="([^"]+)">([^<]+)</a>}).each do |match2|
          lockpick = Lockpick.new(GameObj.new(match2[0], match2[1], match2[2]), bracer, { inspect: true })

          @data.lockpicks.push(lockpick)

          # Adds the lockpick to the bracer so we can intelligently swap lockpicks
          bracer.add(lockpick)
        end
      end

      # Lockpicks (for picking)
      obj.contents.find_all { |l| l.name =~ /lockpick$/i }.each do |lockpick|
        @data.lockpicks.push(Lockpick.new(lockpick, obj, { inspect: true }))
      end

      # Knife (for scales)
      if (knife = obj.contents.find { |l| l.name =~ /knife|dagger/i })
        @data.tools[:knife] = Tool.new(knife, obj)
      end

      # Toolkit (for components)
      if (toolkit = obj.contents.find { |l| l.name =~ /tool\s?kit/i })
        @data.tools[:toolkit] = Tool.new(toolkit, obj)
      end

      @data.tools[:toolkit] = Tool.new(obj, nil) if obj.name =~ /tool\s?kit$/i

      # Rogue only tools below
      next unless Char.prof == 'Rogue'

      # Wedges (for wedging, duh)
      obj.contents.find_all { |l| l.noun == 'wedge' }.each do |wedge|
        @data.wedges.push(Tool.new(wedge, obj))
      end

      # Calipers (for measuring)
      if (calipers = obj.contents.find { |l| l.noun == 'calipers' })
        @data.tools[:calipers] = Tool.new(calipers, obj)
      end
    end

    # Get the first lockpick for spheres disarming
    @data.tools[:lockpick] = Tool.new(@data.lockpicks[0].obj, @data.lockpicks[0].in) if @data.lockpicks.length.positive?
  end

  def self.status
    _respond("<output class='mono'/>")
    if (bracer = @data.tool(:bracer))
      _respond(
        format(
          '  <b>Bracer:</b> %<link>s (in %<container>s)',
          {
            link: bracer.link,
            container: bracer.in ? link(bracer.in) : 'worn'
          }
        )
      )
    end

    if (calipers = @data.tool(:calipers))
      _respond(
        format(
          '<b>Calipers:</b> %<link>s (in %<container>s)',
          {
            link: calipers.link,
            container: link(calipers.in)
          }
        )
      )
    end

    if (knife = @data.tool(:knife))
      _respond(
        format(
          '   <b>Knife:</b> %<link>s (in %<container>s)',
          {
            link: knife.link,
            container: link(knife.in)
          }
        )
      )
    end

    if (lockpick = @data.tool(:lockpick))
      _respond(
        format(
          '<b>Lockpick:</b> %<link>s (in %<container>s)',
          {
            link: lockpick.link,
            container: link(lockpick.in)
          }
        )
      )
    end

    if (toolkit = @data.tool(:toolkit))
      _respond(
        format(
          ' <b>Toolkit:</b> %<link>s (in %<container>s)',
          {
            link: toolkit.link,
            container: toolkit.in ? link(toolkit.in) : 'worn'
          }
        )
      )
    end

    _respond
    _respond('<b>Settings:</b>')

    @data.settings.sort.each do |key, value|
      _respond("  #{key}: #{value}")
    end

    if @data.wedges.length.positive?
      _respond
      _respond('<b>Wedges:</b>')

      @data.wedges.each do |obj|
        _respond("  #{obj.link} (in #{link(obj.in)})")
      end
    end

    _respond
    _respond('<b>Lockpicks</b>:')
    _respond('  -----------------------------------------------------------------------')
    _respond('  | ranks | mod  | status  | max       | name')
    _respond('  -----------------------------------------------------------------------')

    @data.lockpicks.sort { |a, b| a.mod - b.mod }.each do |l|
      data = {
        ranks: l.ranks,
        max_lore: l.max({ lore: true }),
        max: l.max({ lore: false }),
        mod: l.mod,
        status: l.status,
        link: l.link
      }
      _respond(format('  | %<ranks>-5s | %<mod>-2.2f | %<status>-7s | %<max>d/%<max_lore>d   | %<link>s', data))
    end

    _respond
    _respond(format(
               '<b>Disarming</b>: %<max>d/%<max_lore>d',
               {
                 max: disarm_skill,
                 max_lore: disarm_skill({ lore: true })
               }
             ))

    _respond
    _respond("<output class=''/>")
  end

  def self.pool
    Script.run('go2', 'locksmith pool') unless Room.current.tags.include?('locksmith pool')

    if (npc = GameObj.npcs.find { |n| n.name == meta('boxpool:npc') }).nil?
      raise ScriptError, 'Failed to find locksmith NPC'
    end

    if (table = (GameObj.room_desc.to_a + GameObj.loot.to_a).find { |n| n.name == meta('boxpool:table') }).nil?
      raise ScriptError, 'Failed to find locksmith table'
    end

    refresh_box = proc do |level|
      unless table.contents
        res = dothistimeout("look on ##{table.id}", 5, /There is nothing|On the/)
        raise ScriptError, 'Unknown table look response' unless res
      end
      find_box(table.contents.find { |box| box.name =~ /#{Char.name}/ })

      @data.box.level = level unless level.nil?
    end

    @data.mode = :pool

    unless @data.settings[:debug]
      scan
      status

      preset('Starting pool run in 3 seconds')
      sleep(3)
    end

    loop do
      # Encumbrance check
      if percentencumbrance > 80
        deposit

        if percentencumbrance > 80
          preset('Failed to reduce encumbrance: exiting.')
          exit
        end
      end

      # Get the box we're working on (if it exists)
      refresh_box.call(nil)

      # No box, get a new one
      unless @data.box
        level = 0
        job_regex = /offering a tip|haven't quite|rest your mind|enough boxes|have any jobs/

        loop do
          res = dothistimeout("ask ##{npc.id} for job", 5, job_regex)
          raise ScriptError, 'Unknown worker response' unless res

          case res
          when /You haven't quite/
            preset('You are currently penalized: waiting 30 seconds')
            sleep(30)
          when /rest your mind/
            preset('Your mind is too full: waiting for it to clear some')
            wait_while { percentmind >= 100 }
          when /enough boxes/
            preset('Rate limited: waiting 30 seconds')
            sleep(30)
          when /have any jobs/
            preset('No jobs left: waiting 15 seconds')
            sleep(15)
          else
            level = Regexp.last_match(1).to_i if res =~ /\(level (\d+)\)/
            break
          end
        end

        refresh_box.call(level)
      end

      pick

      if @data.box.impossible? || @data.box.trap.impossible?
        if @data.box.trap.impossible?
          preset('Trap is impossible: returning it, you have 10 seconds to ;kill me.')
        else
          preset('Lock is impossible: returning it, you have 10 seconds to ;kill me.')
        end
        sleep(10)
        res = dothistimeout("ask ##{npc.id} for check", 5, /If you want to give up/)
        raise ScriptError, 'Unknown worker response' unless res
      end

      next unless @data.box.unlocked? || @data.box.impossible? || @data.box.trap.impossible?

      worker_regex = /That's some quality|You weren't able|Too tough for ya|You aren't working/
      res = dothistimeout("ask ##{npc.id} for check", 5, worker_regex)
      raise ScriptError, 'Unknown worker response' unless res

      # Reset the box for next round
      @data.box = nil
    end
  end

  def self.contest
    raise ScriptError, 'Must be in a training room to use the contest feature' unless checkarea =~ /dark corner/i
    raise ScriptError, 'Failed to find footpad' unless (npc = GameObj.npcs.first)

    if GameObj.loot.empty?
      res = dothistimeout("nod at ##{npc.id}", 5, /Prepare to be/)
      raise ScriptError, 'Failed to find nod response' unless res
    end

    unless (table = GameObj.loot.find { |l| l.noun == 'table' })
      raise ScriptError, 'Failed to find table'
    end

    unless table.contents
      res = dothistimeout("look on ##{table.id}", 5, /On the/)
      raise ScriptError, 'Failed to look at table contents' unless res
    end

    unless (scorecard = GameObj.loot.find { |l| l.noun == 'scorecard' })
      raise ScriptError, 'Failed to find scorecard'
    end

    unless (lockpicks = table.contents.find_all { |obj| obj.name =~ /lockpick/i })
      raise ScriptError, 'Failed to find lockpicks'
    end

    # Only require a d1 for contest to make it faster
    @data.settings[:calibrate_count] = 999
    # Measuring is a waste of time in contest mode
    @data.settings[:measure] = false
    # Rolls will never be out of range
    @data.settings[:disarm_roll] = 999
    @data.settings[:pick_roll] = 999
    @data.settings[:wedge] = false

    # Set the mode
    @data.mode = :contest

    # Setup the lockpicks by overriding our own
    @data.lockpicks = lockpicks.collect { |l| Lockpick.new(l, table, { inspect: false }) }

    status

    boxes = table.contents.find_all { |box| box.noun == 'box' }

    next_box = proc do
      next if @data.box && !@data.box.unlocked? && @data.box.status != 'gone'

      loop do
        break if boxes.empty?

        box = boxes.shift
        res = dothistimeout("open ##{box.id}", 5, /You open|That is already|to be locked|What were you/)
        next unless res =~ /locked/

        find_box(box)
        break
      end
    end

    loop do
      break unless checkarea =~ /dark corner/i

      next_box.call

      # If we're out of boxes and our current box doesn't exist or is unlocked, we're done.
      break if boxes.empty? && (@data.box.nil? || @data.box.unlocked?)

      # Who is winning, anyway?
      res = dothistimeout("look at ##{scorecard.id}", 5, /Current scores/)
      raise ScriptError, 'Failed to read scorecard' unless res

      # Do some work!
      pick
    end

    # If we got our asses handed we may not be in the room anymore
    return unless checkarea =~ /dark corner/i

    # We finished - wait for line telling us how we did before exiting
    waitforre(/\[You have|escorts/) if boxes.empty?
  end

  def self.withdraw(amount)
    res = dothistimeout('wealth quiet', 5, /You have \d+|You have no silver coins/)
    raise ScriptError, 'Failed to find silver count' unless res

    return if res =~ (/You have ([\d,]+) coins with you/) && (Regexp.last_match(1).gsub(',', '').to_i >= amount)

    while (room = Room.current).nil?
      move(XMLData.room_exits.sample)
      sleep(1)
    end
    Script.run('go2', 'bank')
    fput('deposit all')
    res = dothistimeout("withdraw #{amount} silvers", 5, /The teller/)
    raise ScriptError, 'Unknown withdraw response' unless res

    Script.run('go2', room.id.to_s)
  end

  def self.wedge_index(name)
    %w[brittle thin warped solid strong superior].find_index do |strength|
      name =~ /#{strength}/
    end
  end

  def self.make_wedges(count = @data.settings[:wedge_amount])
    load_menu
    clear_hands

    withdraw(count * 300)

    go2_toolbench
    left = count

    loop do
      break if left.zero?

      buy(@data.menu.find { |m| m[:name] == 'an uncarved wooden block' })

      loop do
        waitrt?
        res = dothistimeout('carve my block', 5, /nowhere near done|keep it up/i)
        raise ScriptError, 'Unknown block carve response' unless res

        break if res =~ /keep it up/i
      end

      loop do
        waitrt?
        res = dothistimeout('carve my wedge', 5, /some more|little more|finish carving/)
        raise ScriptError, 'Unknown wedge carve response' unless res

        break if res =~ /finish carving/
      end

      waitrt?
      res = dothistimeout('rub my wedge', 5, /Grabbing a small/)
      raise ScriptError, 'Unknown wedge rub response' unless res

      expected_quality = wedge_index(@data.settings[:wedge_quality])
      wedge_quality = wedge_index(GameObj.right_hand.name)

      waitrt?
      if wedge_quality >= expected_quality
        preset("Crafted \"#{GameObj.right_hand.name}\" meets \"#{@data.settings[:wedge_quality]}\" requirement")
        t = Tool.new(GameObj.right_hand, @lootsack)
        t.store

        @data.wedges.push(t)
        left -= 1
      else
        preset("Crafted \"#{GameObj.right_hand.name}\" does not meet \"#{@data.settings[:wedge_quality]}\" requirement")
        fput "drop ##{GameObj.right_hand.id}"
      end
    end

    scan

    waitrt?
    fput 'out'
  end

  def self.buy(menu)
    go2_toolbench
    raise ScriptError, 'Invalid menu item' unless menu[:number] && menu[:price]

    res = dothistimeout("order #{menu[:number]}", 5, /You can BUY/)
    raise ScriptError, 'Unknown order response' unless res

    res = dothistimeout('buy', 5, /hands you|have enough/)
    raise ScriptError, 'Unknown buy response' unless res

    return unless res =~ /have enough/

    withdraw(menu[:price])
    move(XMLData.room_exits.sample)
    buy(menu)
  end

  def self.load_menu
    return unless @data.menu.empty?

    go2_toolbench

    res = dothistimeout('read sign', 5, /ITEMS FOR SALE/)
    raise ScriptError, 'Failed to read sign' unless res

    @data.menu = []

    while (line = get)
      break if line =~ /------------------------------------------------------------/
      next unless line =~ /(\d+)\.\) (.*)\s+(\d+)/

      @data.menu.push({
        number: Regexp.last_match(1).to_i,
        name: Regexp.last_match(2).strip,
        price: Regexp.last_match(3).to_i
      })
    end
  end

  def self.repair
    scan
    load_menu

    to_repair = @data.lockpicks.find_all { |l| l.broken? || l.damaged? }

    if to_repair.empty?
      preset('You have no damaged or broken lockpicks to repair.')
      return
    end

    total = 0
    to_repair.each do |lockpick|
      item = @data.menu.find { |m| m[:name] =~ /#{lockpick.material}/ }
      raise ScriptError, "Failed to find menu item for #{lockpick.material}" unless item

      total += item[:price] if lockpick.broken?
    end

    withdraw(total)
    go2_toolbench

    to_repair.each do |lockpick|
      if lockpick.broken?
        menu = @data.menu.find { |m| m[:name] =~ /#{lockpick.material}/ }
        raise ScriptError, "Failed to find menu item for #{lockpick.material}" unless menu

        buy(menu)
      end

      lockpick.get
      match = Regexp.union(
        /cooling rapidly to form/,
        /but the broken tip refuses/,
        /proper curvature to the tip/
      )
      res = dothistimeout("lmas repair ##{lockpick.id}", 5, match)
      raise ScriptError, 'Failed to find repair result' unless res

      waitrt?
      lockpick.store
    end
  end

  def self.refill
    clear_hands
    scan

    putty = 0
    cotton = 0
    vials = 0

    withdraw(1000)
    Script.run('go2', 'locksmith')

    # Sol Haven doesn't have the locksmith tag in the order room
    Script.run('go2', '5725') if Room.current.id == 5724

    toolkit = @data.tool(:toolkit).get

    count = proc do
      res = dothistimeout("look in ##{toolkit.id}", 5, /Peering into/)
      raise ScriptError, 'Failed to look in toolkit' unless res

      putty = Regexp.last_match(1).to_i if res =~ /putty with about (\d+) pinch/
      putty = 1 if res =~ /a pinch of squishy white putty/
      cotton = Regexp.last_match(1).to_i if res =~ /(\d+) little balls of cotton/
      vials = Regexp.last_match(1).to_i if res =~ /(\d+) vials? of liquid/
    end

    order_number = nil

    res = dothistimeout('order', 5, /Catalog/)
    raise ScriptError, 'Failed to find sales menu' unless res

    while (line = get)
      order_number = Regexp.last_match(1).to_i if line =~ /\d+.*\s{2}(\d+).*tool\s?kit/
      order_number = Regexp.last_match(1).to_i if line =~ /(\d+).*tool\s?kit/ && order_number.nil?

      break if order_number
      break if line =~ /You can APPRAISE/
    end

    raise ScriptError, 'Failed to find toolkit order number' unless order_number

    2.times do
      count.call
      break if putty >= 100 && cotton >= 100

      dothis("order #{order_number}", /You ask about/)
      dothis('buy', /hands you/)
      dothis("open ##{GameObj.left_hand.id}", /You open/)
      dothis('bundle', /You transfer/)
      dothis("drop ##{GameObj.left_hand.id}", /You drop/)
    end

    toolkit.store
  end

  def self.cli(vars, settings)
    # This allows partial matches the same way Gemstone works.
    # e.g., ;sbox dete would match ;sbox detect
    command = '^calibrate^clear^contest^detect^disarm^list^load^makewedges^measure^pick^pool'
    command += '^menu^refill^repair^scan^set^status'

    # No match - show help message
    unless (index = (command =~ /\^#{vars[1]}/))
      help
      exit
    end

    # Got a match, strip the command down to the parts in between the ^
    start = index + 1
    stop = command.index('^', index + 1) - 1
    command = command[start..stop]

    case command
    when 'calibrate'
      calibrate
    when 'contest'
      contest
    when 'detect'
      detect
    when 'disarm'
      disarm
    when 'load'
      preset('Loaded')
    when 'makewedges'
      make_wedges(vars[2] ? vars[2].to_i : @data.settings[:wedge_amount])
    when 'measure'
      measure
    when 'pick'
      pick
    when 'pool'
      pool
    when 'menu'
      menu
    when 'repair'
      repair
    when 'refill'
      refill
    when 'scan'
      scan
      status
    when 'set'
      if vars[2].nil?
        echo('You must specify a key: ;sbox set <key> <value>')
        exit
      end

      key = vars[2].to_sym
      unless defined?(settings[key])
        echo("Setting \"#{key}\" not found")
        exit
      end

      value = vars[3..-1].join(' ').strip
      if value.empty?
        echo('You must specify a value: ;sbox set <key> <value>')
        exit
      end

      # Array
      value = value.split(',').collect(&:strip) if settings[key].instance_of?(Array)

      if key == :extract
        available = [
          'dark crystal',
          'jaws',
          'needle',
          'vial'
        ]

        value.each do |v|
          next if available.include?(v)

          echo("#{v} is not a valid component. Your options are:")
          available.each do |av|
            echo("  - #{av}")
          end
          exit
        end
      end

      # Integers
      value = value.to_i if settings[key].instance_of?(Integer)

      # Booleans
      if [FalseClass, TrueClass].include?(settings[key].class)
        value = value.downcase
        value = value =~ /true|1|on/i ? true : false
      end

      settings[key] = value
      echo("\"#{key}\" is now set to \"#{settings[key]}\"")
    when 'status'
      status
    end
  end

  def self.disarm_skill(lore: false)
    skill = Stats.enhanced_dex[1] + Skills.to_bonus(Skills.disarmingtraps)
    return skill unless lore

    bonus404 = SBox.disarm_bonus404
    bonus_focus = SBox.disarm_bonus_focus

    bonus = (bonus404 > bonus_focus ? bonus404 : bonus_focus)
    bonus = skill if bonus > skill

    skill + bonus
  end

  def self.disarm_bonus404
    skill = pick_skill({ lore: false })

    # lore = level/2 + picking skill/10 + dex + spells/4
    bonus = (Char.level / 2).floor +
      (skill / 10).floor +
      Stats.enhanced_dex[1] +
      (Spells.minorelemental / 4).floor

    # cap lore at picking skill
    bonus = skill if bonus > skill

    # half lore if they don't know the spell
    bonus /= 2 unless Spell[403].known?

    # we'll assume they want to use lmaster focus if they're a rogue and don't know 403
    bonus = 0 if Char.prof == 'Rogue' && !Spell[403].known?

    bonus
  end

  def self.disarm_bonus_focus
    return 0 unless Char.prof == 'Rogue'

    skill = disarm_skill({ lore: false })

    # Bonus = 2 * LM ranks
    bonus = 2 * @data.guild_rank

    # Capped at picking skill
    bonus = skill if bonus > skill

    bonus + (Stats.enhanced_dex[1] / 2)
  end

  def self.start_disarm_lore
    return if !Spell[404].known? && @data.guild_rank.zero?

    if @data.guild_rank.positive?
      return if Effects::Buffs.active?('Focused')

      waitrt?
      dothistimeout('lmaster focus', 3, /You focus intently on your/)
      waitrt?
      return
    end

    waitrt?
    waitcastrt?
    wait_until { checkmana(3) }
    Spell[404].cast
    waitcastrt?
  end

  def self.stop_disarm_lore
    waitrt?
    waitcastrt?

    fput('stop lmaster focus') if Effects::Buffs.active?('Focused')
    fput('stop 404') if Spell[404].active?
  end

  def self.pick_skill(lore: false)
    skill = Stats.enhanced_dex[1] + Skills.to_bonus(Skills.pickinglocks)
    return skill unless lore

    bonus403 = SBox.pick_bonus403
    bonus_focus = SBox.pick_bonus_focus

    skill + (bonus403 > bonus_focus ? bonus403 : bonus_focus)
  end

  def self.pick_bonus403
    skill = Skills.to_bonus(Skills.pickinglocks)

    # lore = level/2 + picking skill/10 + dex + spells/4
    bonus = (Char.level / 2).floor +
      (skill / 10).floor +
      Stats.enhanced_dex[1] +
      (Spells.minorelemental / 4).floor

    # cap lore at picking skill
    bonus = skill if bonus > skill

    # half lore if they don't know the spell
    bonus /= 2 unless Spell[403].known?

    # we'll assume they want to use lmaster focus if they're a rogue and don't know 403
    bonus = 0 if Char.prof == 'Rogue' && !Spell[403].known?

    bonus
  end

  def self.pick_bonus_focus
    return 0 unless Char.prof == 'Rogue'

    skill = Skills.to_bonus(Skills.pickinglocks)

    # Bonus = 2 * LM ranks
    bonus = 2 * @data.guild_rank

    # Capped at picking skill
    bonus = skill if bonus > skill

    bonus + (Stats.enhanced_dex[1] / 2)
  end

  def self.start_pick_lore
    return if !Spell[403].known? && @data.guild_rank.zero?

    if @data.guild_rank.positive?
      return if Effects::Buffs.active?('Focused')

      waitrt?
      dothistimeout('lmaster focus', 3, /You focus intently on your/)
      waitrt?
      return
    end

    waitrt?
    waitcastrt?
    wait_until { checkmana(3) }
    Spell[403].cast
    waitcastrt?
  end

  def self.stop_pick_lore
    waitrt?
    waitcastrt?

    fput('stop lmaster focus') if Effects::Buffs.active?('Focused')
    fput('stop 403') if Spell[403].active?
  end

  def self.clear_hands
    waitrt?

    [GameObj.left_hand, GameObj.right_hand].each do |obj|
      next unless obj.id

      if (tool = @data.tools.find { |_k, v| v.id == obj.id })
        tool[1].store
      elsif (lockpick = @data.lockpicks.find { |l| l.id == obj.id })
        lockpick.store
      elsif (wedge = @data.wedges.find { |l| l.id == obj.id })
        wedge.store
      else
        fput("stow ##{obj.id}")
      end
    end
  end

  def self.run(script, settings)
    $sbox_data ||= Data.new

    sack = UserVars.lootsack
    if (@lootsack = GameObj.inv.find { |i| i.noun =~ /\b#{sack}\b/i || i.name =~ /#{sack}/i }).nil?
      raise ArgumentError, 'Setting up Lootsack is required'
    end

    @data = $sbox_data
    @data.mode = nil
    @script = script

    # Initialize default settings
    @data.settings = settings.to_hash.clone

    # Update settings using global if present
    if $sbox_settings
      preset("Settings override exists: #{$sbox_settings.inspect}")
      $sbox_settings.each { |key, value| @data.settings[key] = value }
      $sbox_settings = nil
    end

    # Anytime we exit put everything back where it goes
    before_dying { clear_hands }

    cli(script.vars, settings)
  end
end

default_settings = {
  # Enabling debug mode assumes you know what you're doing and removes some checks
  debug: false,
  # If true, and a Gnomish Mech Bracer is available, it will use the RUB verb to detect the presence of traps
  bracer_detect: false,
  # Number of times to measure before calibration
  calibrate_count: 5,
  # Command used to pick locks
  command: 'pick $B with $L',
  # Components to turn disarm extraction on for. Rogue Lock Mastery, rank 39 or higher only.
  extract: ['dark crystal', 'vial'],
  # Roll required for disarming. Rolls higher than this value will mark a box as impossible.
  disarm_roll: 75,
  # Measure the lock first (forced to false if not a Rogue)
  measure: true,
  # Roll required before attempting to use a lockpick. Higher value means more EXP but less chance of success.
  pick_roll: 50,
  # Minimum ranks required before a pick is selcted. Useful for Lock Mastery.
  ranks: 0,
  # Will relock boxes after they've been picked
  relock: false,
  # Should we attempt wedging (forced to false if not a Rogue)
  wedge: false,
  # Wedge every single box
  wedge_always: false,
  # Number of wedges to craft per attempt
  wedge_amount: 5,
  # Crafted wedge quality required before it's kept
  wedge_quality: 'warped',
  #
  #
  # Attempt to complete guild reps. Requires ;sguild companion script. This should not be set automatically.
  audience_reps: false,
  tough_pick_reps: false,
  tough_wedge_reps: false
}

default_settings.each do |k, v|
  cls = CharSettings[k].class
  next if [TrueClass, FalseClass].include?(cls) && [TrueClass, FalseClass].include?(v.class)
  next if cls == v.class

  CharSettings[k] = v
end

CharSettings.to_hash.delete_if { |setting, _| default_settings[setting].nil? }

# Some stuff only a rogue is cool enough to do
unless Char.prof == 'Rogue'
  CharSettings[:extract] = false
  CharSettings[:relock] = false
  CharSettings[:wedge] = false
end

script.want_downstream = false
script.want_downstream_xml = true

SBox.run(script, CharSettings)
