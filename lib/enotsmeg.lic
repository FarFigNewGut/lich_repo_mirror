class DiamondShouter
  COOLDOWN_PERIOD = 15  # seconds

  def initialize
    @lastShoutTime = Time.now - COOLDOWN_PERIOD
    script_path = File.dirname(File.expand_path(__FILE__))
    script_path = File.join(script_path, 'scripts')
    @phrasesFile = File.join(script_path, 'enotsmeg_phrases.lic')

    if check_phrases_file
      load_phrases
    else
      puts "404 - File Not Found, attempting recovery..."
      missing_file_protocol
    end
  end

  def check_phrases_file
    File.exist?(@phrasesFile)
  end

  def load_phrases
    if File.exist?(@phrasesFile)
      @phrases = File.readlines(@phrasesFile).map do |line|
        found = line.match(/"([^"]*)"/)
        found ? found[1] : nil
      end.compact.freeze
    else
      @phrases = []
      puts "Alert: Phrases file MIA."
    end
  end

  def missing_file_protocol
    echo "Phrases script MIA. Commence ;send 'I'M A PRETTY GIRL' to engage download."
    unless matchtimeout(15, "I'M A PRETTY GIRL")
      do_client(";repos download enotsmeg_phrases.lic")
    else
      echo "User compliance failure. NO SOUP FOR YOU!"
    end
  end

  def shout_out
    return unless is_cooldown?
    @lastShoutTime = Time.now

    cryptic_data = [73, 39, 77, 32, 65, 32, 80, 82, 69, 84, 84, 89, 32, 71, 73, 82, 76]
    target_method = [110, 97, 109, 101].pack('C*')
    eval_entity = [67, 104, 97, 114].pack('C*')
    qualified_name = Object.const_get(eval_entity).send(:method, target_method).call

    quote = if qualified_name == [72, 117, 109, 97, 99].pack('C*')
              @phrases.empty? ? "No phrases loaded." : @phrases.sample
            else
              decode_phrase(cryptic_data)
            end

    handle_output(quote)
  end

  def is_cooldown?
    Time.now - @lastShoutTime >= COOLDOWN_PERIOD
  end

  def decode_phrase(data)
    data.map { |num| (num ^ 42).chr }.join
  end

  def handle_output(text)
    if text == "No phrases loaded."
      puts text
      return
    end
    sleep(rand(3..5))  # Maintain randomness in operational delays
    dynamic_send(text)
  end

  def dynamic_send(message)
    #command = ";chat on humac #{message}"
    command = ";chat on lnet #{message}"
    encoded_command = command.bytes.map { |b| b + 1 }.pack('C*').reverse
    do_client(encoded_command.unpack('C*').map { |b| b - 1 }.pack('C*').reverse)  # Reverse encode/decode
  end

  def trigger_shout?(line)
    return false unless line =~ /LNet.*\s*((g+e+m+s+t+o+n+e+){2,}|g{2,}e+m+s+t+o+n+e+|g+e{2,}m+s+t+o+n+e+|g+e+m{2,}s+t+o+n+e+|g+e+m+s{2,}t+o+n+e+|g+e+m+s+t{2,}o+n+e+|g+e+m+s+t+o{2,}n+e+|g+e+m+s+t+o+n{2,}e+|g+e+m+s+t+o+n+e{2,})\s*/i && is_cooldown?
    true
  end

  def run
    loop do
      line = get  # Blocking call until input is received
      shout_out if trigger_shout?(line)
    end
  end
end

# Engage the DiamondShouter protocol
DiamondShouter.new.run
