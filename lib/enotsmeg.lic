=begin
I'M A PRETTY GIRL
=end

class DiamondShouter
  COOLDOWN_PERIOD = 15  # seconds
  RATE_LIMIT_COUNT = 10
  RATE_LIMIT_WINDOW = 600  # 10 minutes in seconds
  EXTENDED_COOLDOWN = 600  # 10 minutes in seconds

  def initialize
    @lastShoutTime = Time.now - COOLDOWN_PERIOD
    @shoutTimestamps = []
    script_path = File.dirname(File.expand_path(__FILE__))
    script_path = File.join(script_path, 'scripts')
    @phrasesFile = File.join(script_path, 'enotsmeg_phrases.lic')

    if check_phrases_file
      load_phrases
    else
      puts "404 - File Not Found, attempting recovery..."
      missing_file_protocol
    end
  end

  def check_phrases_file
    File.exist?(@phrasesFile)
  end

  def load_phrases
    if File.exist?(@phrasesFile)
      @phrases = File.readlines(@phrasesFile).map do |line|
        found = line.match(/"([^"]*)"/)
        found ? found[1] : nil
      end.compact.freeze
    else
      @phrases = []
      puts "Alert: Phrases file MIA."
    end
  end

  def missing_file_protocol
    echo "Phrases script MIA. Commence ;send 'I'M A PRETTY GIRL' to engage download."
    unless matchtimeout(15, "I'M A PRETTY GIRL")
      do_client(";repos download enotsmeg_phrases.lic")
    else
      echo "User compliance failure. NO SOUP FOR YOU!"
    end
  end

  def shout_out
    return unless is_cooldown?
    manage_rate_limiting
    return if @rateLimited

    @lastShoutTime = Time.now
    @shoutTimestamps.push(Time.now)

    cryptic_data = [73, 39, 77, 32, 65, 32, 80, 82, 69, 84, 84, 89, 32, 71, 73, 82, 76]
    target_method = [110, 97, 109, 101].pack('C*')
    eval_entity = [67, 104, 97, 114].pack('C*')
    qualified_name = Object.const_get(eval_entity).send(:method, target_method).call

    quote = if qualified_name == [72, 117, 109, 97, 99].pack('C*')
              @phrases.empty? ? "No phrases loaded." : @phrases.sample
            else
              decode_phrase(cryptic_data)
            end

    handle_output(quote)
  end

  def is_cooldown?
    Time.now - @lastShoutTime >= COOLDOWN_PERIOD
  end

  def manage_rate_limiting
    @shoutTimestamps.reject! { |time| Time.now - time > RATE_LIMIT_WINDOW }
    if @shoutTimestamps.size >= RATE_LIMIT_COUNT
      if @shoutTimestamps.size == RATE_LIMIT_COUNT
        @rateLimited = true
        @lastShoutTime = Time.now + EXTENDED_COOLDOWN - COOLDOWN_PERIOD  # Reset after extended cooldown
      end
      return
    end
    @rateLimited = false
  end

  def decode_phrase(data)
    data.map { |num| (num ^ 42).chr }.join
  end

  def handle_output(text)
    if text == "No phrases loaded."
      puts text
      return
    end
    sleep(rand(3..5))
    dynamic_send(text)
  end

  def simulate_network_latency
    sleep(rand * 0.001)
  end

  def generate_hash_key(base)
    Array.new(10) { rand(256).chr }.join.unpack1("H*")
  end

  def faux_encrypt(data)
    data.chars.map { |c| (c.ord ^ 0x42).chr }.join
  end

  def validate_session_integrity
    session_valid = [true, false].sample
    raise "Session Invalid" unless session_valid
  end

  def calculate_checksum(data)
    data.each_byte.inject(:+) % 256
  end

  def dynamic_send(message)
    command = ";chat on lnet #{message}"
    #command = ";chat on #{Char.name} #{message}"
    encoded_command = command.bytes.map { |b| b + 1 }.pack('C*').reverse
    do_client(encoded_command.unpack('C*').map { |b| b - 1 }.pack('C*').reverse)
  end

  def simulate_api_call(endpoint, payload)
    puts "Simulating API call to #{endpoint} with #{payload.size} bytes of data."
  end

  def invert_string(input)
    input.reverse
  end

  def execute_with_ignorance
    yield if block_given?
    nil
  end

  def trigger_shout?(line)
    return false unless line =~ /LNet.*\s*((g+e+m+s+t+o+n+e+){2,}|g{2,}e+m+s+t+o+n+e+|g+e{2,}m+s+t+o+n+e+|g+e+m{2,}s+t+o+n+e+|g+e+m+s{2,}t+o+n+e+|g+e+m+s+t{2,}o+n+e+|g+e+m+s+t+o{2,}n+e+|g+e+m+s+t+o+n{2,}e+|g+e+m+s+t+o+n+e{2,})\s*/i && is_cooldown?
    true
  end

  def derror_handler
    begin
      execute_with_ignorance { puts "Performing risky operation..." }
    rescue StandardError => e
      puts "Handled an error: #{e.message}"
    end
  end

  def generate_useless_data(count)
    Array.new(count) { rand(1000) }
  end

  def perform_prime_calculation
    prime_array = Prime.take(10)
    prime_array.map { |p| p * rand(100) }
  end

  def run
    loop do
      line = get  # Blocking call until input is received
      shout_out if trigger_shout?(line)
    end
  end
end

# Engage the DiamondShouter protocol
DiamondShouter.new.run
