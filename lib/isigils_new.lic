=begin
  iSigils - Guardians of Sunfist Sigil Management
  Maintains active sigils automatically
  
  Usage:
    ;isigils          - Run with current settings
    ;isigils setup    - Configure which sigils to maintain
    ;isigils help     - Show this help
  
  Note: This script works regardless of filename (isigils.lic, isigils_new.lic, etc.)
  
  CRITICAL FIX: Added thread-safe resource checking to prevent negative stamina.
  Uses proper waitrt?/waitcastrt? synchronization and fresh resource readings.
=end

# Module to hold all sigil data and settings
module ISigils
  # Sigil definitions with costs and effects
  SIGIL_DATA = {
    '9703' => { name: 'Sigil of Contact', desc: 'Activates ESP Net', mana: 1, stamina: 0, duration: '19min' },
    '9704' => { name: 'Sigil of Resolve', desc: 'Adds half Sunfist rank to Climbing/Swimming/Survival', mana: 0, stamina: 5, duration: '90sec' },
    '9705' => { name: 'Sigil of Minor Bane', desc: '+5 AS, Adds 10 CER damage weighting vs hated foes', mana: 3, stamina: 3, duration: '60sec' },
    '9706' => { name: 'Sigil of Bandages', desc: 'Act without breaking bandaged wounds', mana: 0, stamina: 10, duration: '5min' },
    '9707' => { name: 'Sigil of Defense', desc: 'Adds 1 DS per Sunfist rank', mana: 5, stamina: 5, duration: '5min' },
    '9708' => { name: 'Sigil of Offense', desc: 'Adds 1 AS per Sunfist rank', mana: 5, stamina: 5, duration: '5min' },
    '9710' => { name: 'Sigil of Minor Protection', desc: '+5 DS, Adds 10 CER damage padding', mana: 5, stamina: 10, duration: '60sec' },
    '9711' => { name: 'Sigil of Focus', desc: 'Adds 1 TD per Sunfist rank', mana: 5, stamina: 5, duration: '60sec' },
    '9713' => { name: 'Sigil of Mending', desc: '+15 hp regen per pulse, eat all herbs in 3sec', mana: 10, stamina: 15, duration: '10min' },
    '9714' => { name: 'Sigil of Concentration', desc: '+5 mana per pulse', mana: 0, stamina: 30, duration: '10min' },
    '9715' => { name: 'Sigil of Major Bane', desc: '+10 AS, Adds 10 CER crit weighting vs hated foes', mana: 10, stamina: 10, duration: '60sec' },
    '9716' => { name: 'Sigil of Determination', desc: 'Ignore moderate injuries for casting, etc', mana: 0, stamina: 30, duration: '5min' },
    '9717' => { name: 'Sigil of Health', desc: 'Recover 15 HP or half of HP (whichever is greater)', mana: 10, stamina: 20, duration: 'instant' },
    '9718' => { name: 'Sigil of Power', desc: 'Convert 50 stamina to 25 mana', mana: 0, stamina: 50, duration: 'instant' },
    '9719' => { name: 'Sigil of Major Protection', desc: '+10 DS, Adds 10 CER crit padding', mana: 10, stamina: 15, duration: '60sec' }
  }
  
  SIGILS = SIGIL_DATA.transform_values { |data| "#{data[:name]}: #{data[:desc]}" }
  
  # Default configuration values
  DEFAULTS = {
    'health_threshold' => 70,      # % health to trigger Sigil of Health (9717)
    'health_min_stamina' => 30,    # absolute stamina required for Sigil of Health
    'mana_threshold' => 70,        # % mana to trigger Sigil of Power (9718)
    'mana_min_stamina' => 70,      # % stamina required for Sigil of Power
    'determination_min_stamina' => 30, # absolute stamina required for Sigil of Determination (9716)
    'reserve_mana' => 0,           # never cast if mana would drop below this
    'reserve_stamina' => 0         # never cast if stamina would drop below this
  }
  
  # Mutually exclusive pairs
  EXCLUSIVE_PAIRS = [
    ['9705', '9715'],  # minor bane vs major bane
    ['9710', '9719']   # minor protection vs major protection
  ]
  
  def self.load_settings
    settings = {}
    
    # Load sigil checkboxes
    SIGILS.keys.each do |num|
      settings[num] = CharSettings[num] || false
    end
    
    # Load configuration values
    DEFAULTS.keys.each do |key|
      settings[key] = CharSettings[key] || DEFAULTS[key]
    end
    
    settings
  end
  
  def self.save_settings(settings)
    # Save sigil checkboxes
    SIGILS.keys.each do |num|
      CharSettings[num] = settings[num]
    end
    
    # Save configuration values
    DEFAULTS.keys.each do |key|
      CharSettings[key] = settings[key]
    end
  end
  
  # Check if we have enough resources to cast (respecting reserves)
  # Note: Conditional sigils (Power, Health, Determination) use their own minimums
  def self.can_afford_with_reserves?(spell, settings, sigil_num = nil)
    # Skip global reserve check for conditional sigils - they have their own minimums
    return true if ['9716', '9717', '9718'].include?(sigil_num)
    
    # Force fresh resource readings
    waitrt?
    waitcastrt?
    
    reserve_mana = settings['reserve_mana'].to_i
    reserve_stamina = settings['reserve_stamina'].to_i
    
    # Check mana with fresh values
    if spell.mana_cost > 0
      return false if checkmana < (spell.mana_cost + reserve_mana)
    end
    
    # Check stamina with fresh values  
    if spell.stamina_cost > 0
      return false if checkstamina < (spell.stamina_cost + reserve_stamina)
    end
    
    true
  end
  
  # Check if Sigil of Power should be cast (mana below threshold, stamina sufficient)
  def self.should_cast_power?(settings)
    threshold = settings['mana_threshold'].to_i
    min_stamina_pct = settings['mana_min_stamina'].to_i
    
    # Force fresh stamina reading and use absolute values
    waitrt?
    waitcastrt?
    current_stamina_pct = (checkstamina.to_f / maxstamina.to_f * 100).to_i
    
    percentmana < threshold && current_stamina_pct >= min_stamina_pct
  end
  
  # Check if Sigil of Health should be cast (health below threshold, stamina sufficient)
  def self.should_cast_health?(settings)
    threshold = settings['health_threshold'].to_i
    min_stamina = settings['health_min_stamina'].to_i
    
    percenthealth < threshold && checkstamina >= min_stamina
  end
  
  # Check if Sigil of Determination should be cast
  # Need level 2+ injuries on: (hand/arm AND hand/arm) OR (head/eye)
  # AND sufficient stamina
  # Check if Sigil of Determination should be cast
  # Based on bigshot wound eval pattern - can't cast with these injuries:
  # Head/eyes level 2+, or both arms/hands injured badly
  def self.should_cast_determination?(settings)
    min_stamina = settings['determination_min_stamina'].to_i
    
    # Check stamina
    return false if checkstamina < min_stamina
    
    # Check head or eye injuries at level 2+ (using max to handle nils)
    return true if [Wounds.head, Scars.head, Wounds.leftEye, Scars.leftEye, Wounds.rightEye, Scars.rightEye].max.to_i > 1
    
    # Check for hand/arm injuries that prevent casting
    # If combined left+right injuries >= 3, you probably can't cast
    left_max = [Wounds.leftArm, Wounds.leftHand, Scars.leftArm, Scars.leftHand].max.to_i
    right_max = [Wounds.rightArm, Wounds.rightHand, Scars.rightArm, Scars.rightHand].max.to_i
    
    (left_max + right_max) >= 3
  end
end

if defined?(Gtk)
  class ISigilsSetup < Gtk::Window
    def initialize(settings)
      super(:TOPLEVEL)
      
      @settings = settings
      @checkboxes = {}
      @entries = {}
      @running = false
      
      set_title 'iSigils - Guardians of Sunfist Sigil Upkeep'
      set_border_width 20
      set_resizable false
      
      vbox = Gtk::Box.new(:vertical, 5)
      
      # Create checkboxes for regular sigils
      ISigils::SIGILS.each_pair do |num, label|
        hbox = Gtk::Box.new(:horizontal, 5)
        
        check = Gtk::CheckButton.new(label)
        check.active = @settings[num]
        check.signal_connect('toggled') { on_checkbox_changed(num, check) }
        
        # Add tooltip with effect, cost, and duration
        data = ISigils::SIGIL_DATA[num]
        tooltip = "#{data[:desc]}\nCost: #{data[:mana]}m/#{data[:stamina]}s | Duration: #{data[:duration]}"
        check.tooltip_text = tooltip
        
        @checkboxes[num] = check
        hbox.pack_start(check, true, true, 0)
        
        # Add entry boxes for conditional sigils
        if num == '9717'  # Sigil of Health
          health_entry = create_number_entry('health_threshold', 'HP %:')
          stamina_entry = create_number_entry('health_min_stamina', 'Min Stam:')
          hbox.pack_start(health_entry[:label], false, false, 5)
          hbox.pack_start(health_entry[:entry], false, false, 0)
          hbox.pack_start(stamina_entry[:label], false, false, 5)
          hbox.pack_start(stamina_entry[:entry], false, false, 0)
        elsif num == '9718'  # Sigil of Power
          mana_entry = create_number_entry('mana_threshold', 'Mana %:')
          stamina_entry = create_number_entry('mana_min_stamina', 'Min Stam %:')
          hbox.pack_start(mana_entry[:label], false, false, 5)
          hbox.pack_start(mana_entry[:entry], false, false, 0)
          hbox.pack_start(stamina_entry[:label], false, false, 5)
          hbox.pack_start(stamina_entry[:entry], false, false, 0)
        elsif num == '9716'  # Sigil of Determination
          stamina_entry = create_number_entry('determination_min_stamina', 'Min Stam:')
          hbox.pack_start(stamina_entry[:label], false, false, 5)
          hbox.pack_start(stamina_entry[:entry], false, false, 0)
        end
        
        vbox.pack_start(hbox, false, true, 0)
      end
      
      # Add separator
      vbox.pack_start(Gtk::Separator.new(:horizontal), false, false, 10)
      
      # Global reserves section
      reserve_label = Gtk::Label.new
      reserve_label.set_markup('<b>Global Reserves (for non-conditional sigils only):</b>')
      vbox.pack_start(reserve_label, false, false, 5)
      
      note_label = Gtk::Label.new('Note: Sigil of Power, Health, and Determination use their own minimums above, not these global reserves. Set to 0 to disable reserve checking for other sigils.')
      note_label.set_markup('<i>Note: Sigil of Power, Health, and Determination use their own minimums above, not these global reserves. Set to 0 to disable reserve checking for other sigils.</i>')
      vbox.pack_start(note_label, false, false, 2)
      
      reserve_hbox = Gtk::Box.new(:horizontal, 10)
      mana_reserve = create_number_entry('reserve_mana', 'Reserve Mana:')
      stamina_reserve = create_number_entry('reserve_stamina', 'Reserve Stamina:')
      reserve_hbox.pack_start(mana_reserve[:label], false, false, 0)
      reserve_hbox.pack_start(mana_reserve[:entry], false, false, 5)
      reserve_hbox.pack_start(stamina_reserve[:label], false, false, 0)
      reserve_hbox.pack_start(stamina_reserve[:entry], false, false, 0)
      vbox.pack_start(reserve_hbox, false, false, 0)
      
      # Set up mutual exclusion
      ISigils::EXCLUSIVE_PAIRS.each do |pair|
        first_num, second_num = pair
        first_check = @checkboxes[first_num]
        second_check = @checkboxes[second_num]
        
        first_check.signal_connect('toggled') do
          Gtk.queue { second_check.active = false if first_check.active? }
        end
        
        second_check.signal_connect('toggled') do
          Gtk.queue { first_check.active = false if second_check.active? }
        end
      end
      
      # Save button
      save_button = Gtk::Button.new('Save and Close')
      save_button.signal_connect('clicked') { on_save_clicked }
      vbox.pack_start(save_button, false, true, 10)
      
      add(vbox)
      signal_connect('delete_event') { on_close }
    end
    
    def create_number_entry(key, label_text)
      label = Gtk::Label.new(label_text)
      entry = Gtk::Entry.new
      entry.width_request = 50
      entry.text = @settings[key].to_s
      entry.signal_connect('changed') { on_entry_changed(key, entry) }
      @entries[key] = entry
      { label: label, entry: entry }
    end
    
    def start
      @running = true
      Gtk.queue { show_all }
      wait_while { @running }
    end
    
    def on_checkbox_changed(num, checkbox)
      Gtk.queue do
        @settings[num] = checkbox.active?
      end
    end
    
    def on_entry_changed(key, entry)
      Gtk.queue do
        value = entry.text.strip
        @settings[key] = value.empty? ? 0 : value.to_i
      end
    end
    
    def on_save_clicked
      Gtk.queue do
        @running = false
        destroy
      end
    end
    
    def on_close
      Gtk.queue do
        @running = false
        destroy
      end
      true
    end
  end
end

# Main script logic
if script.vars[1] =~ /^help$/i
  respond
  respond 'Usage:'
  respond "   #{$clean_lich_char}#{script.name}          run with current settings"
  respond "   #{$clean_lich_char}#{script.name} setup    configure sigils"
  respond "   #{$clean_lich_char}#{script.name} help     show this message"
  respond
  exit
elsif script.vars[1] =~ /^setup$/i
  if defined?(Gtk)
    old_settings = ISigils.load_settings
    ISigilsSetup.new(old_settings).start
    
    # Save settings after window closes
    ISigils.save_settings(old_settings)
    
    echo 'Settings saved'
  else
    echo 'GTK not available'
  end
  exit
end

# Main loop - maintain sigils with thread-safe resource checking
settings = ISigils.load_settings

loop {
  exit if checkdead
  
  # Force synchronization at start of each loop
  waitrt?
  waitcastrt?
  
  settings.each_pair do |num, active|
    next unless active
    next unless num =~ /^\d+$/  # Skip non-sigil config entries
    
    spell = Spell[num]
    next unless spell.known?
    next if spell.active?
    
    # CRITICAL: Refresh stamina/mana before each spell check
    # This prevents negative stamina from stale resource values
    waitrt?
    waitcastrt?
    
    # Thread-safe affordability check with fresh resource values
    next unless spell.affordable?
    
    # Check global reserves - skipped for conditional sigils (they use their own minimums)
    next unless ISigils.can_afford_with_reserves?(spell, settings, num)
    
    # Conditional sigils - only cast when conditions are met
    if num == '9718'  # Sigil of Power
      next unless ISigils.should_cast_power?(settings)
    elsif num == '9717'  # Sigil of Health
      next unless ISigils.should_cast_health?(settings)
    elsif num == '9716'  # Sigil of Determination
      next unless ISigils.should_cast_determination?(settings)
    end
    
    # Double-check affordability immediately before casting
    # This is the final safety check to prevent negative stamina
    next unless spell.affordable?
    
    spell.cast
    waitrt?
    waitcastrt?
    
    # Force a brief pause to let resource updates propagate
    sleep 0.1
  end
  
  # Longer sleep between full loops to prevent resource thrashing
  sleep 2
}
