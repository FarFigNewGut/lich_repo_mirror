=begin
  n-setting teleport logic

  autogenerates a set of ruby files to patch the mapdb for jump points associated with an n-setting teleporter
  these files exist at `data/teleporter/`

  examples:
    urglaes band -> data/teleporter/urglaes-band.rb
  
  The relevant patch is loaded based on if the teleporter is found in your GameObj.inv or not

  -- Adding Custom Patches --

  It's good practice for your n-settings to be aligned where possible across all of your characters
  then it makes it much easier to maintain and use custom user extensions.

  To add a custom user extension create a `data/teleporter/user.rb` file and add your extensions there
  using the Ruby API

  -- Variables --

  ;vars set teleporter=<full description>

  -- CLI --

  ;teleport               reload everything
  ;teleport <n>           teleport to a given position
  ;teleport --uninstall   uninstall all Teleport patches from the in-memory MapDB
  ;teleport --flush       rebuild the patch scripts in data/teleporter/ for this item

   author: Ondreian
  version: v1.2.0
  changelog:
    v1.0.0 
      - feat: first stable release
    v1.1.0
      - feat: detect non-unique anchor points for better debugging
    v1.2.0 
      - feat: add Teleport.uni(*ids)
          makes it much easier to define one-way jump points in user extensions
      - feat: add Teleport::Callbacks.define_method :timeto do |from, to|; <whatever>; end
          which allows the user to over ride timeto calculation (turn off for their scripts for instance)
    v1.2.1
      - fix: do not call Kernel::exit during Map.reload
    v1.2.2
        fix: fix Outcome scoping issue
=end

require "fileutils"

module Teleport

  def self.debug?
    Script.current.vars.include?("--debug") or Script.current.name.start_with?("exec")
  end

  module Outcomes
    Err = Regexp.union(
      %r[is trying to reach out for something that is much too far away.],
      %r[Something about your surroundings seems to be overpowering the abilities],
      %r[and you get a strong inclination to take a look around.])
    Ok = %r[In the next heartbeat, you feel yourself launch into the air]
  end

  class Entry
    attr_reader :position, :room, :zone
    def initialize(position, room)
      @position = position
      @room     = room
      @zone     = Teleport.zone_for_room(@room)
    end

    def to_s
      "%s | zone=%s | %s - %s" % [@position.to_s.rjust(2), self.zone, @room.id.to_s.rjust(6), @room.title.first]
    end

    def inspect
      self.to_s
    end
  end

  class Callbacks
    def timeto(from, to)
      return 3
    end
  end
  
  Anchors = []
  class Anchor < Entry
    def initialize(position, room_id)
      super(position, Room[room_id])
      Anchors << self
    end
  end

  module Parser
    Pattern = /(?<position>\d+)\s(?<title>.*)$/

    def self.find_room_by_title(position, title)
      candidates = Map.list.select {|r| r.title.include? "[%s]" % title}
      return candidates[0] if candidates.size == 1
      return nil if candidates.empty?
      _respond "<b>error: non-unique anchor point detected for %s in position %s</b>" % [title, position]
      _respond "\tThere are %s rooms that match this title" % [candidates.size]
      _respond "\tit is a good idea to pick something more unique"
      return candidates.first
    end

    def self.parse(menu)
      menu.scan(Pattern).map {|position, title|
        room = self.find_room_by_title(position, title)
        if room.nil?
          _respond "<b>error: could not find Room(%s)</b>" % title
          return nil
        end
        Teleport::Entry.new(position.to_i, room)
      }.compact
    end

    def self.apply(obj)
      begin
        Script.current.want_downstream_xml = true
        menu = []
        outcome = dothistimeout("tap #%s" % obj.id, 1, Pattern) or fail "could not parse teleporter menu"
        menu << outcome
        while line=get
          return self.parse(menu.select.with_index{|_,i| (i+1) % 2 == 0}.join("\n")) if line =~ /<prompt/
          menu << line
        end
      ensure
        Script.current.want_downstream_xml = false
      end
    end
  end

  module Cache
    def self.file
      File.join(DATA_DIR, "teleporter", Teleport.description.gsub("\s", "-") + ".rb")
    end

    def self.save(contents)

      FileUtils.mkdir_p File.join(DATA_DIR, "teleporter")
      File.write self.file, <<~PatchScript
      ## THIS FILE IS AUTOGENERATED, DO NOT ADD CUSTOM EXTENSIONS HERE
      ## add them to ./user.rb to have them persist across rebuilds
      #{contents}
      PatchScript
      return file
    end

    def self.load!
      Kernel::load self.file
    end

    def self.remove!
      File.delete(self.file) if self.exist?
    end

    def self.user_extensions
      File.join(DATA_DIR, "teleporter", "user.rb")
    end

    def self.exist?
      File.exist? self.file
    end
  end

  def self.zone_for_room(room)
    case room.location.downcase
    when /ta'faendryl/
      return :otf
    else
      # default to closest town's zone
      self.zone_from_location Room[room.find_nearest_by_tag("town")].location.downcase
    end
  end

  def self.zone_from_location(location)
    case location.downcase
    when /solhaven|landing|icemule/
      :west
    when /ta'(i|v)/
      :east
    when /kraken's fall/
      :kraken_fall
    when /hinterwilds/
      :hinterwilds
    else
      :other
    end
  end

  def self.description
    Vars["teleporter"]
  end

  def self.teleporter()
    30.times {
      item = GameObj.inv.find {|worn| worn.name.eql?(self.description)}
      return item if item
      sleep 0.1
    }
  end

  def self.exists?
    not self.teleporter.nil?
  end

  def self.link(from:, to:, position:)
    from = Map[from.to_i]
    to   = Map[to.to_i]
    return if from.id == to.id
    fail %[could not find from(#{from})] if from.nil?
    fail %[could not find to(#{to})]     if to.nil?
    to_id    = to.id.to_s
    respond("link> %s | %s >> %s" % [position.to_s.rjust(2), from.title.first.rjust(40), to.title.first]) if Teleport.debug?
    from.timeto[to_id] = StringProc.new "Teleport.timeto(from: #{from.id}, to: #{to.id})"
    from.wayto[to_id]  = StringProc.new "Teleport.teleport(%s)" % position
  end

  def self.timeto(from:, to:)
    wait_while {GameObj.inv.nil? or GameObj.inv.empty?}
    return nil unless Teleport.exists?
    return Callbacks.new.timeto(from, to)
  end

  def self.teleport(position)
    fput "twist #%s to %s" % [self.teleporter.id, position]
    case dothistimeout "rub #%s" % self.teleporter.id, 3, Regexp.union(Outcomes::Ok, Outcomes::Err)
    when Outcomes::Ok
      :ok
    when Outcomes::Err
      fail "cannot teleport from this location"
    end
  end

  def self.build_teleport_zones(entries)
    west = []
    east = []
    others = []
    kraken_fall = []
    hinterwilds = []
    entries.each {|entry|
      case entry.zone
      when :west
        west << entry
      when :east
        east <<  entry
      when :kraken_fall
        kraken_fall << entry
      when :hinterwilds
        hinterwilds << entry
      else
        others << entry
      end
    }

    return OpenStruct.new(
      west: west.combination(2),
      east: east.combination(2),
      kraken_fall: kraken_fall.combination(2),
      hinterwilds: hinterwilds.combination(2),
      others: others.combination(2),
    )
  end

  def self.uninstall
    Map.list.each {|r|
      r.wayto.delete_if {|k, w| w.is_a?(StringProc) && w._dump.start_with?("Teleport")}
      r.timeto.delete_if {|k, w| w.is_a?(StringProc) && w._dump.start_with?("Teleport")}
    }
  end

  def self.load_user_extensions!
    return :noop unless File.exist? Cache.user_extensions
    _respond "<b>loaded custom user extensions from %s</b>" % Cache.user_extensions
    load Cache.user_extensions
  end

  def self.build_patch_script(menu, zones)
    menu.map {|entry|
      <<~Ruby
        Teleport::Anchor.new(#{entry.position}, #{entry.room.id}) # #{entry.room.title.first}
      Ruby
    }.join("") + %i(west east kraken_fall).map {|zone|
        zones.send(zone).map {|left, right|
          <<~Ruby
          Teleport.link(
            from: #{left.room.id}, # #{left.room.title.first}
            to: #{right.room.id}, # #{right.room.title.first}
            position: #{right.position},
          )
          
          Teleport.link(
            from: #{right.room.id}, # #{right.room.title.first}
            to: #{left.room.id}, # #{left.room.title.first}
            position: #{left.position},
          )
          Ruby
        }
      }.flatten.join("")
  end

  def self.load_mapdb_patch(flush: false)
    if not Cache.exist? or Script.current.vars.include?("--flush") or flush
      _respond "<b>building mapdb patch script for %s</b>" % Teleport.teleporter.name
      Cache.remove!
      menu = Parser.apply(Teleport.teleporter)
      zones = Teleport.build_teleport_zones(menu)
      script = Teleport.build_patch_script(menu, zones)
      Cache.save(script)
      _respond "<b>built patch script at %s</b>" % Cache.file
    end
    # load from fresh built cache
    Cache.load!
    _respond "<b>loaded patch script from %s</b>" % Cache.file
    self.load_user_extensions!
  end

  def self.uni(*ids)
    ids.each {|id|
      next unless Room[id]
      from = Entry.new(nil, Room[id])
      Teleport::Anchors.each { |anchor|
        if anchor.zone.eql?(from.zone)
          Teleport.link(
            from: from.room.id,
            to: anchor.room.id,
            position: anchor.position
          )
        end
      }
    }
    :ok
  end

  def self.main()
    exit if self.description.nil?
    wait_while("waiting on inventory to load") {GameObj.inv.empty?}
    self.exists? or fail "#{self.description} not found in inventory"
    return Teleport.teleport(Script.current.vars.first) if (1..20).include?(Script.current.vars.first.to_i)
    return Teleport.uninstall if Script.current.vars.include?("--uninstall")
    return Teleport.load_mapdb_patch(flush: true) if Script.current.vars.include?("--build")
    Teleport.load_mapdb_patch
  end

  module Test
    if Script.current.vars.include?("--test")
      Teleport.load_mapdb_patch(flush: true)
      exit
    end
  end
end

# Polyfill patches into Map api
class Map
  @api ||= OpenStruct.new(
    load: Map.method(:load),
    reload: Map.method(:reload),
  )

  def self.flush(*args)
    @api.load.call(*args)
  end

  def self.load(*args)
    @api.load.call(*args)
    Teleport.load_mapdb_patch
  end

  def self.reload(*args)
    @api.reload.call(*args)
    Teleport.load_mapdb_patch
  end
end

Teleport.main()