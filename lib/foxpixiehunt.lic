#silence_me

=begin
                           Rumor Woods Fox and Pixie Hunting Script (1.0)
	
    ---------------------------------------------------------------------------------------------------
    ;FOXPIXIEHUNT             Raikhen Farming Mode (focuses only on getting medium
    ;FOXPIXIEHUNT FARM        reward animals or flowers (~125 raikhen; weasels, ferrets,
                              minks, ermines; sweetspire, arnica, cattail, azalea))

    ;FOXPIXIEHUNT FOX         Fox/Pixie Hunting Mode (fox/pixie hunting that eventually
    ;FOXPIXIEHUNT PIXIE       gives up and goes after a medium reward animal or flower)

    ;FOXPIXIEHUNT MANUAL      Manual Mode (doesn't do anything beyond having a timer
                              while in the grounds and automated sack emptying)

    ;FOXPIXIEHUNT HELP        this information
	
	
    ;K FOXPIXIEHUNT           kills this script (a good time to do this is when you empty the sack)
    ---------------------------------------------------------------------------------------------------
	
    * foxpixiehunt will auto determine whether to observe (perception) or track (survival).

    * To set the Fox/Pixie Hunting Mode timeout (in seconds) use -> ;e echo UserVars.FoxPixieHuntTimeout = NUMBER

    * If you want the most raikhen, as fast as possible, use farm mode (;foxpixiehunt).
	
    * If you don't mind taking longer, and trying to find the fox/pixie, use hunting mode (;foxpixiehunt fox (or pixie)).
	
    * If you want to use your own tactics, or to explore, use manual mode (;foxpixiehunt manual).

    * Current fox/pixie hunting movement logic is based on fox.lic which is passable, but flawed.
      This will eventually be replaced with a better process.  Stay tuned!
	
    * https://gswiki.play.net/Fox_Hunt for information on the Fox Hunt.
	
    * https://gswiki.play.net/Pixie_Hunt for information on the Pixie Hunt.
	
    * Based on fox.lic by Ryjex, fox2020.lic by Obelin, foxy.lic by Selema.
	
    * Design input from Obelin and Selema.  Thank you!
	
    * This script is foxfox and pixiepixie combined into one.

    * asrialx@gmail.com / Asrial (Arianiss)#1203 on Discord


	
    author: Arianiss
    version: 1.0 (2022-06-10)
    game: GS
    tags: fox, pixie, Rumor Woods, raikhen
	
    changelog:

       1.0 (2022-06-10)
           - initial release
=end

# make a faster FoxHunt that doesn't observe/track the entire time

# make movement not backtrack (randomly selected pre defined routes in an array)

# add list of things to check (room ids) on subsequent runs

# add protection against "path" not being detected as an exit

# find a way to keep track of "no sign" rooms (switch script to using line = get)

# multi threading (no sign rooms in fox hunt and manual mode, standing in cave entrance/exit in manual mode)

# average raikhen tracker (make a variable that the user can reset)

# average complete timer

# use CharSettings (per character, per script) instead of UserVars (per character)
# CharSettings[:timeout] = number

# make a way to detect a newer version

# Fox Hunt Entrance: 8211332 / 25932 (treeline)
# Fox Hunt Just Inside: 8208601
# Fox Hunt Exit: 8208699 (out)

# Pixie Hunt Entrance: 8208746 / 29706 (steps)
# Pixie Hunt Just Inside: 8208501
# Pixie Hunt Exit: 8208599 (out)

if ((XMLData.room_id != 8211332) && (XMLData.room_id != 8208746) && (script.vars[1].downcase != "help"))
	respond
	respond "Please start the script at either the Fox Hunt entrance (;go2 25932) or the Pixie Hunt entrance (;go2 29706)."
	respond
	exit
else
	fox = (XMLData.room_id == 8211332) ? true : false
end

if Vars.lootsack.nil?
	respond
	respond "Set your lootsack variable first."
	respond
	respond ";vars set lootsack = CONTAINER-NOUN"
	respond
	exit
end

script.vars[1] = (script.vars[1] == nil) ? "farm" : script.vars[1].downcase

case script.vars[1]
	when "fox", "pixie"
		respond
		fox ? (respond "Fox Hunting Mode") : (respond "Pixie Hunting Mode")
		respond
		if UserVars.FoxPixieHuntTimeout == nil
			respond "Your fox/pixie hunt timeout has not been set (65 seconds is the recommended default)."
			respond
			respond ";e echo UserVars.FoxPixieHuntTimeout = NUMBER "
			respond
			exit
		else
			respond "Your fox/pixie hunt timeout is currently #{UserVars.FoxPixieHuntTimeout} seconds."
			respond
		end
	when "farm"
		respond
		respond "Raikhen Farming Mode"
		respond
	when "manual"
		respond
		respond "Manual Mode"
		respond
	when "help"
	
	# tabs get ignored by SF (though they're still there)
	
		respond "
                           Rumor Woods Fox and Pixie Hunting Script (1.0)
	
    ---------------------------------------------------------------------------------------------------
    ;FOXPIXIEHUNT             Raikhen Farming Mode (focuses only on getting medium
    ;FOXPIXIEHUNT FARM        reward animals or flowers (~125 raikhen; weasels, ferrets,
                              minks, ermines; sweetspire, arnica, cattail, azalea))

    ;FOXPIXIEHUNT FOX         Fox/Pixie Hunting Mode (fox/pixie hunting that eventually
    ;FOXPIXIEHUNT PIXIE       gives up and goes after a medium reward animal or flower)

    ;FOXPIXIEHUNT MANUAL      Manual Mode (doesn't do anything beyond having a timer
                              while in the grounds and automated sack emptying)

    ;FOXPIXIEHUNT HELP        this information
	
	
    ;K FOXPIXIEHUNT           kills this script (a good time to do this is when you empty the sack)
    ---------------------------------------------------------------------------------------------------
	
    * foxpixiehunt will auto determine whether to observe (perception) or track (survival).

    * To set the Fox/Pixie Hunting Mode timeout (in seconds) use -> ;e echo UserVars.FoxPixieHuntTimeout = NUMBER

    * If you want the most raikhen, as fast as possible, use farm mode (;foxpixiehunt).
	
    * If you don't mind taking longer, and trying to find the fox/pixie, use hunting mode (;foxpixiehunt fox (or pixie)).
	
    * If you want to use your own tactics, or to explore, use manual mode (;foxpixiehunt manual).

    * Current fox/pixie hunting movement logic is based on fox.lic which is passable, but flawed.
      This will eventually be replaced with a better process.  Stay tuned!
	
    * https://gswiki.play.net/Fox_Hunt for information on the Fox Hunt.
	
    * https://gswiki.play.net/Pixie_Hunt for information on the Pixie Hunt.
	
    * Based on fox.lic by Ryjex, fox2020.lic by Obelin, foxy.lic by Selema.
	
    * Design input from Obelin and Selema.  Thank you!
	
    * This script is foxfox and pixiepixie combined into one.

    * asrialx@gmail.com / Asrial (Arianiss)#1203 on Discord


	
    author: Arianiss
    version: 1.0 (2022-06-10)
    game: GS
    tags: fox, pixie, Rumor Woods, raikhen
	
    changelog:

       1.0 (2022-06-10)
           - initial release
		"
		exit
	when "motivation"
		respond
		respond "It doesn't matter what the trapper or elder says, you ARE great at this!"
		respond
		respond "Good luck in there!"
		respond
		exit
	when "debug"
		exit
	else
		respond
		respond "Invalid Option (help, fox, pixie, farm, manual, motivation)"
		respond
		exit
end

#FoxHuntArray = [8208601, 8208602, 8208603, 8208604, 8208605, 8208606, 8208607, 8208608, 8208609, 8208610, 8208611, 8208612, 8208613, 8208614, 8208615, 8208616, 8208617, 8208618, 8208619, 8208620, 8208621, 8208622, 8208623, 8208624, 8208625, 8208626, 8208627, 8208628, 8208629, 8208630, 8208631, 8208632, 8208633, 8208634, 8208635, 8208636, 8208637, 8208638, 8208639, 8208640]

#PixieHuntArray = [8208501, 8208502, 8208503, 8208504, 8208505, 8208506, 8208507, 8208508, 8208509, 8208510, 8208511, 8208512, 8208513, 8208514, 8208515, 8208516, 8208517, 8208518, 8208519, 8208520, 8208521, 8208522, 8208523, 8208524, 8208525, 8208526, 8208527, 8208528, 8208529, 8208530, 8208531, 8208532, 8208533, 8208534, 8208535, 8208536]

announce_increment = 10 # the number of seconds to wait between time announcements

observe = (Skills.perception >= Skills.survival) ? true : false

#no_fox_rooms = []

#def FoxHunt(observe, no_fox_rooms)

def FoxHunt(observe)
#	if no_fox_rooms.include? Room.current.id
#		respond
#		respond "You've already determined there are no signs of a fox here."
#		respond
#		result = nil
#	else
		if observe
			result = dothistimeout "observe", 5, /many signs of a (?:fox|pixie) in this area|A fox trots|loping off|A pixie slips through|slipping away/ if ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599)) # the fox/pixie will never move out of a "many signs" room
		else
			result = dothistimeout "track", 5, /many signs of a (?:fox|pixie) in this area|A fox trots|loping off|A pixie slips through|slipping away/ if ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599)) # the fox/pixie will never move out of a "many signs" room
		end
#	end

	waitrt?
	
	if result =~ /many signs of a (?:fox|pixie) in this area/
		while ((sleep 1) && (XMLData.room_id != 8208699) && (XMLData.room_id != 8208599))
			fput "search"
		end
		return false
#	elsif result =~ /no signs of a fox in this area/
#		no_fox_rooms.push(Room.current.id)
#		respond "here"
#		dothistimeout "", 5, /find many signs of a fox in this area|A fox trots|loping off/
	elsif ((XMLData.room_id != 8208699) && (result =~ /A fox trots/))
		dir = result.sub("A fox trots ","")
		dir = dir.sub("!","")
		respond
		respond "The fox was spotted heading " + dir + "!"
		respond
		fput dir if XMLData.room_id != 8208699
		return true
	elsif ((XMLData.room_id != 8208699) && (result =~ /loping off/))
		case XMLData.room_id
			when 8208607 # A fox went through a felled log, loping off!
				respond
				respond "The fox was spotted heading through the log!"
				respond
				fput "go log" if XMLData.room_id != 8208699
				return true
			when 8208611 # path
				respond
				respond "fox -> path -- please message me the messaging for the fox going down the path"
				respond
				fput "go path" if XMLData.room_id != 8208699
				return true			
			when 8208632 # A fox climbed down a massive rock formation, loping off!
				respond
				respond "The fox was spotted climbing down the rock formation!"
				respond
				fput "climb rock" if XMLData.room_id != 8208699
				return true					
			when 8208625 # cave
				respond
				respond "fox -> cave -- please message me the messaging for the fox going into the cave"
				respond
				fput "go cave" if XMLData.room_id != 8208699
				until (standing?)
					multifput "stance offensive", "stand", "stance defensive"
				end			
				return true		
			when 8208630 # mouth
				respond
				respond "fox -> mouth -- please message me the messaging for the fox leaving the cave"
				respond
				fput "go mouth" if XMLData.room_id != 8208699
				until (standing?)
					multifput "stance offensive", "stand", "stance defensive"
				end
				return true
			#when ??? # A pixie went across a partially rotted wooden plank, slipping away!
			
			#when ??? # A pixie went across a pair of stepping stones, slipping away!
			else
				return false if XMLData.room_id == 8208699
		end
	end
	
	return false if ((XMLData.room_id == 8208699) || (XMLData.room_id == 8208599))
	newroom = XMLData.room_exits.sample
	fput newroom if ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599))
	return true
end

def RaikhenFarm(observe)
	if observe
		result = dothistimeout "observe", 5, /many signs of a (?:fox|pixie) in this area|no signs of a (?:fox|pixie) in this area/ if ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599)) # the fox/pixie will never move out of a "many signs" room
	else
		result = dothistimeout "track", 5, /many signs of a (?:fox|pixie) in this area|no signs of a (?:fox|pixie) in this area/ if ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599)) # the fox/pixie will never move out of a "many signs" room
	end

	waitrt?
	
	if result =~ /many signs of a (?:fox|pixie) in this area|no signs of a (?:fox|pixie) in this area/
		while ((sleep 1) && (XMLData.room_id != 8208699) && (XMLData.room_id != 8208599))
			fput "search"
		end
		return false
	end

	return false if ((XMLData.room_id == 8208699) || (XMLData.room_id == 8208599))
	newroom = XMLData.room_exits.sample
	fput newroom if ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599))
	return true
end

loop do
	#result = dothistimeout "get marker", 2, /You remove a|You already have that/
	dothistimeout "get marker", 2, /You remove a|You already have that/ # this is to slow the script down so you don't roll straight into the if check; may need to add custom container actions; can be tricked with lag greater than 2 seconds

	#if result !~ /You remove a|You already have that/
		if ((checkright != "marker") && (checkleft != "marker"))
			respond
			respond "You're out of markers or your hands are full."
			respond
			exit
		end
	#end
	
	if script.vars[1] == "manual"
		respond
		fox ? (respond "When ready GO TREELINE to start the hunt.") : (respond "When ready GO STEPS to start the hunt.")
		respond
	else
		fox ? (fput "go treeline") : (fput "go steps")
	end
		
	wait until ((XMLData.room_id == 8208601) || (XMLData.room_id == 8208501))

	!Vars.inv.nil? ? (fput "put my marker in my #{Vars.inv}") : (fput "put my marker in my #{Vars.lootsack}")	

	case script.vars[1]
		when "fox", "pixie"
			start_time = Time.now
		
			announce = start_time + announce_increment # this is to prevent a "0 seconds have elapsed" message			
		
			loop do
				if Time.now.to_i >= announce.to_i
					respond
					respond (Time.now.to_i - start_time.to_i).to_s + " seconds have elapsed."
					respond
					announce += announce_increment
				end

				if (Time.now.to_i - start_time.to_i) <= UserVars.FoxPixieHuntTimeout
					#continue = FoxHunt(observe, no_fox_rooms) if Room.current.id != 28111
					continue = FoxHunt(observe)
				else
					continue = RaikhenFarm(observe)
				end
			
				continue ? next : break
			end
		when "farm"
			while ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599) && RaikhenFarm(observe))
			end
		when "manual"
			start_time = Time.now
		
			announce = start_time + announce_increment # this is to prevent a "0 seconds have elapsed" message

			while ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599))
				if Time.now.to_i >= announce.to_i
					respond
					respond (Time.now.to_i - start_time.to_i).to_s + " seconds have elapsed."
					respond
					fput "whisper Aethyra #{(Time.now.to_i - start_time.to_i).to_s} seconds have elapsed my love." if GameObj.pcs.any? { |pc| pc.noun =~ /^Aethyra$/ }
					announce += announce_increment
				end
				sleep 0.5
			end			
		else
			respond
			respond "Shouldn't Get Here"
			respond
			exit
	end
	
	waitrt?

	if ((GameObj.right_hand.name != "gunny sack") && (GameObj.left_hand.name != "gunny sack") && (GameObj.right_hand.name != "flyrsilk sack") && (GameObj.left_hand.name != "flyrsilk sack")) # GameObj (gunny/flyrsilk sack) vs checkleft (sack)
		multifput "store all", "stow all"
		
		GameObj.loot.each { |item| fput "get ##{item.id}" if ((item.name =~ /gunny sack|flyrsilk sack/)) } # GameObj.hand.name returns "flyrsilk sack" while GameObj.loot.name returns "colorful flyrsilk sack" and so that's why the regex match instead of a regular string match

		sleep 1

		if ((GameObj.right_hand.name != "gunny sack") && (GameObj.left_hand.name != "gunny sack") && (GameObj.right_hand.name != "flyrsilk sack") && (GameObj.left_hand.name != "flyrsilk sack"))
			respond
			if fox
				respond "YOUR GUNNY SACK IS ON THE GROUND!"
				respond
				respond "THERE MIGHT BE A BUGLE IN THERE!"
			else
				respond "YOUR FLYRSILK SACK IS ON THE GROUND!"
				respond
				respond "THERE MIGHT BE A MORNING GLORY IN THERE!"
			end
			respond
			respond 'DO THIS -> ;e GameObj.loot.each { |item| fput "get ##{item.id}" if ((item.name =~ /gunny sack|flyrsilk sack/)) } '
			respond
			respond "..and then please tell me what went wrong.."
			respond
			exit
		end
	end

	dothis "open my sack", /You open a nondescript gunny sack.|You open a colorful flyrsilk sack./
	fput "look in my sack"
	result = dothis "empty my sack in my #{Vars.lootsack}", /^You try to empty the contents of your sack into your \D+, and everything falls in quite nicely.$|You try to empty the contents of your sack into your \D+, but nothing will fit.|leaving the rest/ # the ^ and $ on the success string is to protect against anything malicious because that result leads to throwing away the sack
	
	if result =~ /everything falls in quite nicely/
		sleep 2
		waitrt?

		while ((GameObj.right_hand.name =~ /gunny sack|flyrsilk sack/) || (GameObj.left_hand.name =~ /gunny sack|flyrsilk sack/))
			fput "throw my sack"
			sleep 0.5
		end
	else
		respond
		respond "CONTAINER FULL, TIME TO EMPTY!"
		respond "CONTAINER FULL, TIME TO EMPTY!"
		respond "CONTAINER FULL, TIME TO EMPTY!"
		respond
		exit
	end

	fput "out"
	wait until ((XMLData.room_id == 8211332) || (XMLData.room_id == 8208746))
end