#silence_me

=begin
                           Rumor Woods Fox and Pixie Hunting Script (2.1)
	
    ---------------------------------------------------------------------------------------------------
    ;FOXPIXIEHUNT             Raikhen Farming Mode (focuses only on getting medium
    ;FOXPIXIEHUNT FARM        reward animals or flowers (~125 raikhen; weasels, ferrets,
                              minks, ermines; sweetspire, arnica, cattail, azalea))

    ;FOXPIXIEHUNT FOX         Fox/Pixie Hunting Mode (fox/pixie hunting that eventually
    ;FOXPIXIEHUNT PIXIE       gives up and goes after a medium reward animal or flower)

    ;FOXPIXIEHUNT MANUAL      Manual Mode (doesn't do anything beyond having a timer
                              while in the grounds and automated sack emptying)

    ;FOXPIXIEHUNT HELP        this information
	
	
    ;K FOXPIXIEHUNT           kills this script (a good time to do this is when you empty the sack)
    ---------------------------------------------------------------------------------------------------
	
    * foxpixiehunt will auto determine whether to observe (perception) or track (survival).

    * To set the Fox/Pixie Hunting Mode timeout (in seconds) use -> ;e echo UserVars.FoxPixieHuntTimeout = NUMBER

    * If you want the most raikhen, as fast as possible, use farm mode (;foxpixiehunt).
	
    * If you don't mind taking longer, and trying to find the fox/pixie, use hunting mode (;foxpixiehunt fox (or pixie)).
	
    * If you want to use your own tactics, or to explore, use manual mode (;foxpixiehunt manual).

    * Current fox/pixie hunting movement logic is based on fox.lic which is passable, but flawed.
      This will eventually be replaced with a better process.  Stay tuned!

    * Fox/Pixie Hunting Mode will start you at a random location (chosen from several preset locations) to help spread people out.
	
    * https://gswiki.play.net/Fox_Hunt for information on the Fox Hunt.
	
    * https://gswiki.play.net/Pixie_Hunt for information on the Pixie Hunt.
	
    * Based on fox.lic by Ryjex, fox2020.lic by Obelin, foxy.lic by Selema.
	
    * Design input from Obelin and Selema.  Thank you!
	
    * This script is foxfox and pixiepixie combined into one.

    * asrialx@gmail.com / Asrial (Arianiss)#1203 on Discord


	
    author: Arianiss
    version: 2.1 (2022-06-13)
    game: GS
    tags: fox, pixie, Rumor Woods, raikhen
	
    changelog:

       2.1 (2022-06-13)
           - added fox/pixie tracking (farm mode will chase if the opportunity
             presents itself, but the focus is still on 125ish rewards)
       2.0 (2022-06-12)
           - added random starting locations, to spread people out, in hunt mode
           - added 'no signs' tracking during hunt mode (this will prevent
             re-observing/tracking rooms that have already been identified as not
             having the fox in them)
       1.0 (2022-06-10)
           - initial release
=end

# make a faster FoxHunt that doesn't observe/track the entire time

# make movement not backtrack (randomly selected pre defined routes in an array)

# add list of things to check (room ids) on subsequent runs

# add protection against "path" not being detected as an exit

# find a way to keep track of "no sign" rooms (switch script to using line = get) -- this is done maybe

# multi threading (no sign rooms in fox hunt and manual mode, standing in cave entrance/exit in manual mode)

# average raikhen tracker (make a variable that the user can reset)

# average complete timer

# add notes option

# make help default / add a menu to start (otherwise people only use farm mode without knowing there's other modes)

# add ability to keep track of "no signs" rooms in manual mode

# add a way to turn off random starting locations (can give 1-2 extra observe/track commands)

# add explanation of what the script does and better explanation of the modes

# use CharSettings (per character, per script) instead of UserVars (per character)
# CharSettings[:timeout] = number

# make a way to detect a newer version

# Fox Hunt Entrance: 8211332 / 25932 (treeline)
# Fox Hunt Just Inside: 8208601
# Fox Hunt Exit: 8208699 (out)

# Pixie Hunt Entrance: 8208746 / 29706 (steps)
# Pixie Hunt Just Inside: 8208501
# Pixie Hunt Exit: 8208599 (out)

# number of observe/track commands for a 90 second run is 17-19; 19 is the max

# the fox/pixie will never move out of a "many signs" room

if ((XMLData.room_id != 8211332) && (XMLData.room_id != 8208746) && (script.vars[1].downcase != "help"))
	respond
	respond "Please start the script at either the Fox Hunt entrance (;go2 25932) or the Pixie Hunt entrance (;go2 29706)."
	respond
	exit
else
	@fox = (XMLData.room_id == 8211332) ? true : false
end

if Vars.lootsack.nil?
	respond
	respond "Set your lootsack variable first."
	respond
	respond ";vars set lootsack = CONTAINER-NOUN"
	respond
	exit
end

script.vars[1] = (script.vars[1] == nil) ? "farm" : script.vars[1].downcase

case script.vars[1]
	when "fox", "pixie"
		respond
		@fox ? (respond "Fox Hunting Mode") : (respond "Pixie Hunting Mode")
		respond
		if UserVars.FoxPixieHuntTimeout == nil
			respond "Your fox/pixie hunt timeout has not been set (65 seconds is the recommended default)."
			respond
			respond ";e echo UserVars.FoxPixieHuntTimeout = NUMBER "
			respond
			exit
		else
			respond "Your fox/pixie hunt timeout is currently #{UserVars.FoxPixieHuntTimeout} seconds."
			respond
		end
	when "farm"
		respond
		respond "Raikhen Farming Mode"
		respond
	when "manual"
		respond
		respond "Manual Mode"
		respond
	when "help"
	
	# tabs get ignored by SF (though they're still there)
	
		respond "
                           Rumor Woods Fox and Pixie Hunting Script (2.0)
	
    ---------------------------------------------------------------------------------------------------
    ;FOXPIXIEHUNT             Raikhen Farming Mode (focuses only on getting medium
    ;FOXPIXIEHUNT FARM        reward animals or flowers (~125 raikhen; weasels, ferrets,
                              minks, ermines; sweetspire, arnica, cattail, azalea))

    ;FOXPIXIEHUNT FOX         Fox/Pixie Hunting Mode (fox/pixie hunting that eventually
    ;FOXPIXIEHUNT PIXIE       gives up and goes after a medium reward animal or flower)

    ;FOXPIXIEHUNT MANUAL      Manual Mode (doesn't do anything beyond having a timer
                              while in the grounds and automated sack emptying)

    ;FOXPIXIEHUNT HELP        this information
	
	
    ;K FOXPIXIEHUNT           kills this script (a good time to do this is when you empty the sack)
    ---------------------------------------------------------------------------------------------------
	
    * foxpixiehunt will auto determine whether to observe (perception) or track (survival).

    * To set the Fox/Pixie Hunting Mode timeout (in seconds) use -> ;e echo UserVars.FoxPixieHuntTimeout = NUMBER

    * If you want the most raikhen, as fast as possible, use farm mode (;foxpixiehunt).
	
    * If you don't mind taking longer, and trying to find the fox/pixie, use hunting mode (;foxpixiehunt fox (or pixie)).
	
    * If you want to use your own tactics, or to explore, use manual mode (;foxpixiehunt manual).

    * Current fox/pixie hunting movement logic is based on fox.lic which is passable, but flawed.
      This will eventually be replaced with a better process.  Stay tuned!

    * Fox/Pixie Hunting Mode will start you at a random location (chosen from several preset locations) to help spread people out.
	
    * https://gswiki.play.net/Fox_Hunt for information on the Fox Hunt.
	
    * https://gswiki.play.net/Pixie_Hunt for information on the Pixie Hunt.
	
    * Based on fox.lic by Ryjex, fox2020.lic by Obelin, foxy.lic by Selema.
	
    * Design input from Obelin and Selema.  Thank you!
	
    * This script is foxfox and pixiepixie combined into one.

    * asrialx@gmail.com / Asrial (Arianiss)#1203 on Discord


	
    author: Arianiss
    version: 2.0 (2022-06-12)
    game: GS
    tags: fox, pixie, Rumor Woods, raikhen
	
    changelog:

       2.0 (2022-06-12)
           - added random starting locations, to spread people out, in hunt mode
           - added 'no signs' tracking during hunt mode (this will prevent
             re-observing/tracking rooms that have already been identified as not
             having the fox in them)
       1.0 (2022-06-10)
           - initial release
		"
		exit
	when "motivation"
		respond
		respond "It doesn't matter what the trapper or elder says, you ARE great at this!"
		respond
		respond "Good luck in there, you can do it!"
		respond
		exit
	when "debug"
		exit
	else
		respond
		respond "Invalid Option (help, fox, pixie, farm, manual, motivation)"
		respond
		exit
end

announce_increment = 10 # the number of seconds to wait between time announcements

if script.vars[1] != "manual"
	@results_list = Regexp.union(
		/many signs of a (?:fox|pixie)/,
		/no signs of a (?:fox|pixie)/,
		/paw prints of a small animal/,
		/incredibly tiny footprints/,
		
		#/A fox trots/,
		#/loping off/,
		#/A pixie slips through/,
		#/slipping away/,
	)

	FoxHuntRoomArray = [8208601, 8208602, 8208603, 8208604, 8208605, 8208606, 8208607, 8208608, 8208609, 8208610, 8208611, 8208612, 8208613, 8208614, 8208615, 8208616, 8208617, 8208618, 8208619, 8208620, 8208621, 8208622, 8208623, 8208624, 8208625, 8208626, 8208627, 8208628, 8208629, 8208630, 8208631, 8208632, 8208633, 8208634, 8208635, 8208636, 8208637, 8208638, 8208639, 8208640]

	FoxHuntStartingRoomArray = [28142, 28113, 28128, 28135, 28115, 28138, 28118]

	PixieHuntRoomArray = [8208501, 8208502, 8208503, 8208504, 8208505, 8208506, 8208507, 8208508, 8208509, 8208510, 8208511, 8208512, 8208513, 8208514, 8208515, 8208516, 8208517, 8208518, 8208519, 8208520, 8208521, 8208522, 8208523, 8208524, 8208525, 8208526, 8208527, 8208528, 8208529, 8208530, 8208531, 8208532, 8208533, 8208534, 8208535, 8208536]

	PixieHuntStartingRoomArray = [31148, 31158, 31157, 31165, 31170, 31160, 31155]

	observe = (Skills.perception >= Skills.survival) ? true : false

	@direction = nil

	queue = Queue.new

	downstream_action = proc { |server_string|
		queue << server_string
		server_string
	}

	DownstreamHook.add("#{script.name}", downstream_action)

	before_dying {
		DownstreamHook.remove("#{script.name}")
	}

	def FoxHunt(observe, checkedRoomsArray)
		result = nil
	
		if observe
			result = dothistimeout "observe", 5, @results_list if ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599) && (!checkedRoomsArray.include?(XMLData.room_id)))
		else
			result = dothistimeout "track", 5, @results_list if ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599) && (!checkedRoomsArray.include?(XMLData.room_id)))
		end

		sleep 1 if ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599) && (!checkedRoomsArray.include?(XMLData.room_id)))
		waitrt?
		
		case result
			when /many signs of a (?:fox|pixie) in this area/
				while ((sleep 1) && (XMLData.room_id != 8208699) && (XMLData.room_id != 8208599))
					fput "search"
				end
				return false
			when /no signs of a (?:fox|pixie)/
				checkedRoomsArray.push(XMLData.room_id) # this adds the room to the "don't check" list and continues on to move into a new room
				
				if @direction != nil
					fput @direction if ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599))
					@direction = nil
					return true
				end				
			when /paw prints of a small animal/, /incredibly tiny footprints/
				if @direction != nil
					checkedRoomsArray.push(XMLData.room_id) # the fox/pixie will never move from the "many signs" room and so having seen the fox/pixie move means this isn't that room
					fput @direction if ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599))
					@direction = nil
					return true
				end

				return true # this causes the loop to skip moving and come back around to observe/track again
			else
				if ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599))
					respond
					@fox ? (respond "This area has been checked and the fox is not here.") : (respond "This area has been checked and the pixie is not here.")
					respond
				end
					
				if @direction != nil
					fput @direction if ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599))
					@direction = nil
					return true
				end
		end

		return false if ((XMLData.room_id == 8208699) || (XMLData.room_id == 8208599))
		newroom = XMLData.room_exits.sample
		fput newroom if ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599))
		return true
	end

	def RaikhenFarm(observe, checkedRoomsArray)
		result = nil
		
		if observe
			result = dothistimeout "observe", 5, /many signs of a (?:fox|pixie) in this area|no signs of a (?:fox|pixie) in this area/ if ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599) && (!checkedRoomsArray.include?(XMLData.room_id)))
		else
			result = dothistimeout "track", 5, /many signs of a (?:fox|pixie) in this area|no signs of a (?:fox|pixie) in this area/ if ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599) && (!checkedRoomsArray.include?(XMLData.room_id)))
		end

		sleep 1 if ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599) && (!checkedRoomsArray.include?(XMLData.room_id)))
		waitrt?
		
		if result =~ /many signs of a (?:fox|pixie) in this area|no signs of a (?:fox|pixie) in this area/
			while ((sleep 1) && (XMLData.room_id != 8208699) && (XMLData.room_id != 8208599))
				fput "search"
			end
			return false
		end
		
		if ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599) && (checkedRoomsArray.include?(XMLData.room_id)))
			respond
			@fox ? (respond "This area has been checked and the fox is not here.") : (respond "This area has been checked and the pixie is not here.")
			respond
		end		
		
		if @direction != nil
			checkedRoomsArray.push(XMLData.room_id) # the fox/pixie will never move from the "many signs" room and so having seen the fox/pixie move means this isn't that room
			fput @direction if ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599))
			@direction = nil
			return true
		end		

		return false if ((XMLData.room_id == 8208699) || (XMLData.room_id == 8208599))
		newroom = XMLData.room_exits.sample
		fput newroom if ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599))
		return true
	end
end

loop do
	#result = dothistimeout "get marker", 2, /You remove a|You already have that/
	dothistimeout "get marker", 2, /You remove a|You already have that/ # this is to slow the script down so you don't roll straight into the if check; may need to add custom container actions; can be tricked with lag greater than 2 seconds

	#if result !~ /You remove a|You already have that/
		if ((checkright != "marker") && (checkleft != "marker"))
			respond
			respond "You're out of markers or your hands are full."
			respond
			exit
		end
	#end
	
	if script.vars[1] == "manual"
		respond
		@fox ? (respond "When ready GO TREELINE to start the hunt.") : (respond "When ready GO STEPS to start the hunt.")
		respond
	else
		@fox ? (fput "go treeline") : (fput "go steps")
	end
		
	wait until ((XMLData.room_id == 8208601) || (XMLData.room_id == 8208501))
	
	!Vars.inv.nil? ? (fput "put my marker in my #{Vars.inv}") : (fput "put my marker in my #{Vars.lootsack}")	

	case script.vars[1]
		when "fox", "pixie"
			start_time = Time.now
		
			announce = start_time + announce_increment # this is to prevent a "0 seconds have elapsed" message

			starting_room = @fox ? FoxHuntStartingRoomArray.sample : PixieHuntStartingRoomArray.sample
			start_script("go2", ["#{starting_room}"])
			wait_while {running?("go2")}
			
			checkedRoomsArray = Array.new
			
			Thread.new {
				loop {
					return if ((XMLData.room_id == 8208699) || (XMLData.room_id == 8208599))

					string = queue.pop

					if ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599) && (string =~ /A fox trots (\w+)!|A pixie slips through the foliage, heading (\w+)!/))
						fox_direction = $1
						pixie_direction = $2
						
						@direction = @fox ? fox_direction : pixie_direction
						
						respond
						@fox ? (respond "The fox was spotted heading " + fox_direction + "!") : (respond "The pixie was spotted heading " + pixie_direction + "!")
						respond
end	
=begin					
					elsif ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599) && (string =~ /loping off|slipping away/))
						case XMLData.room_id
							when 8208607 # A fox went through a felled log, loping off!
								respond
								respond "The fox was spotted heading through the log!"
								respond
								fput "go log" if ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599))
								return true
							when 8208611 # path
								respond
								respond "fox -> path -- please message me the messaging for the fox going down the path"
								respond
								fput "go path" if ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599))
								return true			
							when 8208632 # A fox climbed down a massive rock formation, loping off!
								respond
								respond "The fox was spotted climbing down the rock formation!"
								respond
								fput "climb rock" if ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599))
								return true					
							when 8208625 # cave
								respond
								respond "fox -> cave -- please message me the messaging for the fox going into the cave"
								respond
								fput "go cave" if ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599))
								until (standing?)
									multifput "stance offensive", "stand", "stance defensive"
								end			
								return true		
							when 8208630 # mouth
								respond
								respond "fox -> mouth -- please message me the messaging for the fox leaving the cave"
								respond
								fput "go mouth" if ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599))
								until (standing?)
									multifput "stance offensive", "stand", "stance defensive"
								end
								return true
							when 8208515, 8205816 # plank
								respond
								respond "The pixie was spotted going across the wooden plank!"
								respond
								fput "go plank" if ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599))
							when 8208517, 8208516 # stones
								respond
								respond "The pixie was spotted going across the stepping stones!"
								respond
								fput "go stones" if ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599))
							else
								respond
								respond "Shouldn't Get Here"
								respond
								exit
						end
					end
=end
				}
			}
		
			loop do
				if Time.now.to_i >= announce.to_i
					respond
					respond (Time.now.to_i - start_time.to_i).to_s + " seconds have elapsed."
					respond
					announce += announce_increment
				end

				if (Time.now.to_i - start_time.to_i) <= UserVars.FoxPixieHuntTimeout
					continue = FoxHunt(observe, checkedRoomsArray)
				else
					continue = RaikhenFarm(observe, checkedRoomsArray)
				end
			
				continue ? next : break
			end
		when "farm"
			checkedRoomsArray = Array.new
			
			Thread.new {
				loop {
					if ((XMLData.room_id == 8208699) || (XMLData.room_id == 8208599))
						DownstreamHook.remove("#{script.name}")
						return
					end

					string = queue.pop

					if ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599) && (string =~ /A fox trots (\w+)!|A pixie slips through the foliage, heading (\w+)!/))
						fox_direction = $1
						pixie_direction = $2
						
						@direction = @fox ? fox_direction : pixie_direction
						
						respond
						@fox ? (respond "The fox was spotted heading " + fox_direction + "!") : (respond "The pixie was spotted heading " + pixie_direction + "!")
						respond
end
				}
			}		
		
			while ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599) && RaikhenFarm(observe, checkedRoomsArray))
			end
		when "manual"
			start_time = Time.now
		
			announce = start_time + announce_increment # this is to prevent a "0 seconds have elapsed" message

			while ((XMLData.room_id != 8208699) && (XMLData.room_id != 8208599))
				if Time.now.to_i >= announce.to_i
					respond
					respond (Time.now.to_i - start_time.to_i).to_s + " seconds have elapsed."
					respond
					fput "whisper Aethyra #{(Time.now.to_i - start_time.to_i).to_s} seconds have elapsed my love." if GameObj.pcs.any? { |pc| pc.noun =~ /^Aethyra$/ }
					announce += announce_increment
				end
				sleep 0.5
			end			
		else
			respond
			respond "Shouldn't Get Here"
			respond
			exit
	end

	if ((script.vars[1] == "fox") || (script.vars[1] == "pixie"))
		respond
		respond "#{checkedRoomsArray.length()} areas were checked this hunt."
		respond
	end
	
	sleep 1
	waitrt?

	if ((GameObj.right_hand.name != "gunny sack") && (GameObj.left_hand.name != "gunny sack") && (GameObj.right_hand.name != "flyrsilk sack") && (GameObj.left_hand.name != "flyrsilk sack")) # GameObj (gunny/flyrsilk sack) vs checkleft (sack)
		multifput "store all", "stow all"
		
		GameObj.loot.each { |item| fput "get ##{item.id}" if ((item.name =~ /gunny sack|flyrsilk sack/)) } # GameObj.hand.name returns "flyrsilk sack" while GameObj.loot.name returns "colorful flyrsilk sack" and so that's why the regex match instead of a regular string match

		sleep 1

		if ((GameObj.right_hand.name != "gunny sack") && (GameObj.left_hand.name != "gunny sack") && (GameObj.right_hand.name != "flyrsilk sack") && (GameObj.left_hand.name != "flyrsilk sack"))
			respond
			if @fox
				respond "YOUR GUNNY SACK IS ON THE GROUND!"
				respond
				respond "THERE MIGHT BE A BUGLE IN THERE!"
			else
				respond "YOUR FLYRSILK SACK IS ON THE GROUND!"
				respond
				respond "THERE MIGHT BE A MORNING GLORY IN THERE!"
			end
			respond
			respond 'DO THIS -> ;e GameObj.loot.each { |item| fput "get ##{item.id}" if ((item.name =~ /gunny sack|flyrsilk sack/)) } '
			respond
			respond "..and then please tell me what went wrong.."
			respond
			exit
		end
	end

	dothis "open my sack", /You open a nondescript gunny sack.|You open a colorful flyrsilk sack./
	fput "look in my sack"
	result = dothis "empty my sack in my #{Vars.lootsack}", /^You try to empty the contents of your sack into your \D+, and everything falls in quite nicely.$|You try to empty the contents of your sack into your \D+, but nothing will fit.|leaving the rest/ # the ^ and $ on the success string is to protect against anything malicious because that result leads to throwing away the sack
	
	if result =~ /everything falls in quite nicely/
		sleep 2
		waitrt?

		while ((GameObj.right_hand.name =~ /gunny sack|flyrsilk sack/) || (GameObj.left_hand.name =~ /gunny sack|flyrsilk sack/))
			fput "throw my sack"
			sleep 0.5
		end
	else
		respond
		respond "CONTAINER FULL, TIME TO EMPTY!"
		respond "CONTAINER FULL, TIME TO EMPTY!"
		respond "CONTAINER FULL, TIME TO EMPTY!"
		respond
		exit
	end

	fput "out"
	wait until ((XMLData.room_id == 8211332) || (XMLData.room_id == 8208746))
end