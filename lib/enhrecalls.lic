=begin
 enhrecalls.lic
 Watch bard recalls, build JSON for your site, and write on demand.

 Usage:
   ;enhrecalls
   Find the file at Lich5/enhancives_from_recalls.json
=end

require 'json'
require 'time'

# ---------- tiny helpers ----------
def echo_i(msg)
  echo "[enhrecalls] #{msg}"
end

def now_iso
  Time.now.utc.iso8601
end

def norm_text(s)
  s.to_s.encode('UTF-8', invalid: :replace, undef: :replace).gsub("\r\n", "\n")
end

def norm_word(s)
  s.downcase.gsub(/[^a-z0-9]+/, ' ').strip
end

def parse_kv(args)
  raw = args.to_s
  toks = raw.scan(/"([^"]*)"|'([^']*)'|(\S+)/).map { |a, b, c| (a || b || c).to_s }
  h = {}
  toks.each do |t|
    if t =~ /\A(\w+)=(.+)\z/ then h[$1] = $2
    else
      h['cmd'] ||= t
    end
  end
  h
end

def safe_path(p)
  return "enhancives_from_recalls.json" if p.nil? || p.empty?
  unq = p.gsub(/\A['"]|['"]\z/, '')
  return unq if File.exist?(File.dirname(unq)) rescue false
  alt = unq.tr('\\', '/')
  File.exist?(File.dirname(alt)) ? alt : unq
end

def sig(base, kind) "#{base}.#{kind}.signal" end

# ---------- chunk boundaries ----------
START_RE = /
  \AAs\ you\ recall(?:\ (?:the\ bard's|Hypate's))?\ song,\ you\ feel\ a\ faint\ resonating\ vibration\ from\ the\ .+?
  in\ your\ (?:left\ |right\ )?hand,\ and\ you\ learn\ something\ about\ it\.\.\.
/ix
END_RE = /\AIt\ has\ a\ (?:permanent(?:ly)?|temporar(?:y|ily))\ unlocked\ loresong/i

# ---------- parsing ----------
def extract_name(chunk)
  (chunk[/from the (.*?) in your (?:left |right )?hand/i, 1] || "Unknown item").strip
end

def permanence_from(chunk)
  return "Crumbly"   if chunk =~ /will\s+(?:crumbl\w*|disintegrat\w*)\s+.*last\s+enhancive\s+charge/i
  return "Permanent" if chunk =~ /will\s+persist\s+.*last\s+enhancive\s+charge/i
  "Unknown"
end

def collect_notes(chunk)
  chunk.split("\n").map(&:strip).select { |l|
    next false if l.empty?
    next false if l.start_with?("As you recall")
    next false if l =~ /It is an enhancive item:/i
    next false if l =~ /It provides (?:a )?(?:boost|bonus) of/i
    next false if l =~ /This enhancement may not be used/i
    next false if l =~ /unlocked loresong/i
    l.start_with?("It")
  }.uniq.join(" ")
end

def parse_targets(chunk)
  targets = []
  chunk.each_line do |raw|
    line = raw.strip
    next if line.empty?
    if (m = line.match(/It provides (?:a )?(?:boost|bonus) of\s+([+-]?\d+)\s+to\s+(.*?)[\.\(]/i))
      amt = m[1].to_i
      rest = m[2].strip
      type, target = nil, rest.dup
      %w[Bonus Ranks Base Recovery].each do |t|
        if rest.end_with?(" #{t}")
          type = t
          target = rest.sub(/\s+#{t}\z/, '')
          break
        end
      end
      if type.nil?
        case rest
        when "Max Mana", "Max Stamina", "Stamina Recovery", "Mana Recovery", "Health Recovery"
          type = "Recovery"; target = rest
        else
          type = "Bonus"
        end
      end
      targets << { "target" => target, "type" => type, "amount" => amt }
    end
  end
  targets
end

# ---------- slot inference (phrase-first; your precedence) ----------
# Slot precedence (first match wins). Put Hair before Head, Ear before Finger.
SLOT_ORDER = [
  "Weapon", "Shield",
  "Ears", "Ear", "Finger",
  "Hair", "Head",
  "Neck", "Wrist", "Hands",
  "Feet", "Ankle", "Pants",
  "Leggings", "Legs", "Arm",
  "Waist", "Belt", "Armor",
  "Undershirt", "Shoulder", "Back", "Cloak",
  "Socks", "Pin"
]

# Packed wearable nouns (pipe-separated, preserves multi-word phrases)
SLOT_PACKED = {
  "Head"       => "aemikvai|atika|atiki|bandana|barrette|bascinet|basinet|basrenne|bonnet|bow|burgonet|cabasset|cap|capotain|carcanet|caul|chaperon|chaplet|circlet|coif|cowl|crespine|crown|diadem|earmuffs|elothrai|face-veil|fascinator|ferrigem|ferroniere|geldaralad|goggles|greathelm|hairbands|haircombs|hairjewels|hairpins|hairsticks|hat|headband|headdress|headpiece|headscarf|headwrap|helm|hennin|hood|kerchief|mantilla|mask|plume|shawl|snood|tiara|tricorn|tricorne|veil|warhelm|wimple",
  "Ear"        => "earbob|earcuff|earring|ear-stud|ear stud|earrings|hoops",
  "Ears"       => "earrings|hoops",
  "Neck"       => "amulet|beads|bowtie|brooch|choker|collar|cord|lavaliere|locket|medallion|neckchain|necklace|pendant|periapt|talisman|thong|torc|gorget|aventail",
  "Back"       => "bag|duffel bag|backpack|backsack|back sheath|back-basket|carryall|haversack|harness|knapsack|pack|rucksack",
  "Shoulder"   => "bag|baldric|bandolier|basket|carryall|case|handbag|harness|kit|pack|purse|quiver|reticule|sack|satchel|scabbard|sheath|shoulderbag|sling|tote",
  "Cloak"      => "beluque|burnoose|caban|cape|capelet|cassock|chasuble|cloak|coat|coatee|dolman|duster|frock|gaberdine|greatcloak|half-cape|jacket|kimono|leine|longcoat|longcloak|manteau|mantle|overcoat|parka|paletot|pelisse|pelisson|raincoat|robe|robes|shawl|shroud|shrug|stole|surcoat|surcote|toqua|vestment|wrap",
  "Front"      => "bandolier",
  "Undershirt" => "arming doublet|blouse|chemise|gambeson|gipon|kirtle|pourpoint|sark|shift|shirt|tunic|underdress|undergown|undershirt|undertunic|underrobe",
  "Arm"        => "armband|arm greaves|arm guards|armlet|vambrace",
  "Wrist"      => "bangle|bangles|bracelet|bracer|bracers|cuff|guards|manacle|vambrace|wristband|wrist-band|wristchain|wristcuff|wristlet|wrist pouch",
  "Hands"      => "gauntlet|gauntlets|gloves|handwraps|hand-harness|handflower",
  "Finger"     => "band|finger-armor|pinky ring|ring|rings|talon|thumb ring",
  "Waist"      => "belt|chain|chatelaine|cincher|cincture|corsage|corset|girdle|hip-scarf|sash|scarf|waistchain|waist-cincher",
  "Belt"       => "bag|buckle|case|clutch|gem bag|gem pouch|gem satchel|handbag|hip-kit|hip-satchel|kit|poke|pouch|purse|reliquary|reticule|sack|satchel|scabbard|sheath|tote|tube",
  "Leggings"   => "leggings",
  "Pants"      => "breeches|breeks|hosen|kilt|pants|petticoat|petticoats|skirt|tights|trews|trousers|underskirts|wrap-skirt",
  "Legs"       => "greaves|leg greaves|leg-greaves|leg guards|leg-guards|leg wraps|shin guards|tassets|thigh band|thigh-band|thigh quiver|thigh-quiver",
  "Ankle"      => "anklet|cuff|ankle-cuff|sheath|ankle-sheath",
  "Socks"      => "socks|stockings",
  "Feet"       => "ankle-boots|boots|brouges|buskins|chopines|clogs|flats|footflower|footwraps|half-boots|knee-boots|poulaines|sabatons|sandals|shoes|slippers|snowshoes|thigh-boots|yatane",
  "Hair"       => "barrette|hairbands|haircombs|hairjewels|hairpins|hairsticks",
  "Pin"        => "pin|brooch|badge|clasp|stickpin",
  "Shield"     => "shield|aegis|buckler|targe|pavis|pavise|kite-shield|tower-shield|scutum"
}
WEAPON_PACKED = <<~WPN
  spear|sword|dagger|axe|handaxe|longsword|broadsword|short sword|scimitar|falchion|rapier|estoc|kukri|
  mace|morning star|war hammer|maul|flail|whip|bullwhip|cat o' nine tails|
  poleaxe|pole axe|halberd|glaive|guisarme|naginata|ranseur|partisan|spetum|awl-pike|
  lance|pike|trident|harpoon|
  bow|longbow|short bow|composite bow|crossbow|hand crossbow|arbalest|
  staff|runestaff|quarterstaff|warstaff|
  chakram|bola|bolas|throwing axe|throwing disc|dart
WPN
ARMOR_PACKED = <<~ARM
  leather|leathers|leather armor|leather breastplate|cuirbouilli|cuirbouilli leather|studded leather|brigandine|brigandine armor|
  lamellar armor|scale|scalemail|coat-of-plates|jack-of-plates|
  chain|chainmail|ringmail|mail|haubergeon|jazerant|hauberk|augmented chain|
  plate|plate armor|breastplate|metal breastplate|platemail|half plate|full plate|field plate|plate-and-mail|plate and mail
ARM

NOUNS_BY_SLOT = {}
SLOT_PACKED.each { |slot, packed| NOUNS_BY_SLOT[slot] = packed.split('|').map(&:strip).reject(&:empty?) }
NOUNS_BY_SLOT["Weapon"] = (NOUNS_BY_SLOT["Weapon"] || []) + WEAPON_PACKED.split('|').map(&:strip).reject(&:empty?)
NOUNS_BY_SLOT["Armor"]  = (NOUNS_BY_SLOT["Armor"]  || []) + ARMOR_PACKED.split('|').map(&:strip).reject(&:empty?)

SLOT_SINGLES = Hash.new { |h, k| h[k] = {} }
SLOT_PHRASES = Hash.new { |h, k| h[k] = [] }
NOUNS_BY_SLOT.each do |slot, nouns|
  nouns.each do |n|
    norm = norm_word(n)
    if norm.include?(' ')
      SLOT_PHRASES[slot] << norm
    else
      SLOT_SINGLES[slot][norm] = true
      SLOT_SINGLES[slot]["#{norm}s"] = true unless norm.end_with?('s')
    end
  end
end

def infer_location(name)
  hay = " #{norm_word(name)} "
  tokens = hay.split
  SLOT_ORDER.each do |slot|
    ph = SLOT_PHRASES[slot]
    return slot if ph.any? { |p| hay.include?(" #{p} ") }
    sg = SLOT_SINGLES[slot]
    return slot if tokens.any? { |t| sg.key?(t) }
  end
  "Misc"
end

# ---------- memory & writer ----------
class RecallMem
  attr_reader :items, :out

  def initialize(out_path)
    @items = []
    @seen  = Set.new
    @out   = out_path
    @next_id = 1
  end

  def add_chunk(chunk)
    chunk = norm_text(chunk)
    name = extract_name(chunk)
    targets = parse_targets(chunk)
    return if targets.empty?
    item = {
      "id"         => @next_id,
      "name"       => name,
      "location"   => infer_location(name),
      "permanence" => permanence_from(chunk),
      "notes"      => collect_notes(chunk),
      "targets"    => targets,
      "dateAdded"  => now_iso
    }
    fp = fingerprint(item)
    return if @seen.include?(fp)
    @seen.add(fp)
    @items << item
    @next_id += 1
  end

  def fingerprint(item)
    t = item["targets"].map { |h| [h["target"], h["type"], h["amount"]] }.sort_by(&:to_s)
    [item["name"].downcase.strip, item["location"], item["permanence"], t].to_s
  end

  def write!
    File.open(@out, "w:utf-8") { |f| f.write(JSON.pretty_generate({ "items" => @items })) }
    echo_i "Wrote #{@items.size} items to #{@out}"
  end
end

# ---------- command routing ----------
args = parse_kv(Script.current.vars[0])
cmd  = (args['cmd'] || 'watch').downcase
outp = safe_path(args['out'] || "enhancives_from_recalls.json")

if cmd == 'save' || cmd == 'stop'
  File.open(sig(outp, cmd), "w") { |f| f.puts now_iso }
  echo_i "Signal #{cmd.upcase} -> #{outp}"
  exit
end

# watcher mode
mem = RecallMem.new(outp)
save_sig = sig(outp, 'save')
stop_sig = sig(outp, 'stop')
echo_i "Watching recalls... output: #{outp}"

parsing = false
chunk_lines = []

begin
  while (line = get)
    l = line.to_s.rstrip

    # chunk start?
    if !parsing && l =~ START_RE
      parsing = true
      chunk_lines = [l]
      next
    end

    # chunk body?
    if parsing
      chunk_lines << l
      if l =~ END_RE
        parsing = false
        mem.add_chunk(chunk_lines.join("\n"))
        chunk_lines.clear
      end
    end

    # handle signals (fires when a new line is seen)
    if File.exist?(save_sig)
      mem.write!
      File.delete(save_sig) rescue nil
    end
    if File.exist?(stop_sig)
      mem.write!
      File.delete(stop_sig) rescue nil
      break
    end
  end
rescue => e
  echo_i "Error: #{e}"
ensure
  # final write on controlled exit
  mem.write!
end
