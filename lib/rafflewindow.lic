=begin
  This script creates a dedicated window to track raffles and adjust the time to the players correct time zone.

author: Phocosoen, ChatGPT
tags: wrayth, frontend, mod, window, raffle, raffles, track
  
=end

require 'tzinfo'
require 'time'

hide_me

no_kill_all
setpriority(-1)

# --- Time conversion helper ---
def parse_et_to_local(time_string)
  TZInfo::DataSource.set(:ruby)
  eastern = TZInfo::Timezone.get('America/New_York')  # Eastern Time
  local   = TZInfo::Timezone.get('America/Chicago')   # Central Time
  et_time = eastern.local_to_utc(Time.parse(time_string))
  local.utc_to_local(et_time)
rescue
  # If parsing fails, return a far-future time so it's not mistakenly discarded.
  Time.now + 999_999
end

# --- Time difference helper ---
def time_diff_in_words(future_time)
  diff = future_time - Time.now
  return nil if diff <= 0

  total_seconds = diff.to_i
  days = total_seconds / 86_400
  total_seconds %= 86_400
  hours = total_seconds / 3_600
  total_seconds %= 3_600
  mins = total_seconds / 60

  # Build a simple string (e.g., "1d 2h 15m" or "43m").
  parts = []
  parts << "#{days}d" if days > 0
  parts << "#{hours}h" if hours > 0
  parts << "#{mins}m" if mins > 0

  # If it's under 1 minute, show <1m
  parts << "<1m" if parts.empty?

  parts.join(" ")
end

# --- Global Variables ---
@raffle_lines = []    # Captured lines from the raffle list output
@current_raffle = nil # Temporary storage for a raffle block being parsed
@raffles = []         # Array of parsed raffle objects
$capture_until = nil  # Timestamp until which we capture lines

# --- Parsing Helpers ---
def finalize_current_raffle
  if @current_raffle && @current_raffle[:id]
    @raffles << @current_raffle
    @current_raffle = nil
  end
end

def parse_raffle_lines
  @raffles = []
  @current_raffle = nil
  @raffle_lines.each do |line|
    case line
    when /Raffle \#(.+) for \"(.+)\"\, Cost\: ([\d,]+) silver/
      finalize_current_raffle
      @current_raffle = {
        id: $1,
        item: $2,
        cost: $3.gsub(",", ""),
        online: false,
        purchased: false,
        winner: nil,
        draw_time: nil,
        object: "",
        location: ""
      }
    when /Location: (.+) at \[(.+)\]/
      if @current_raffle
        @current_raffle[:object] = $1
        @current_raffle[:location] = $2
      end
    when /Draws at: (.+) \(in .+\)/, /Drew at: (.+) \(.+\)/
      @current_raffle[:draw_time] = parse_et_to_local($1) if @current_raffle
    when /Characters (must|had to) be online in order to win/
      @current_raffle[:online] = true if @current_raffle
    when /You have purchased a ticket/
      @current_raffle[:purchased] = true if @current_raffle
    when /\*\*\* You are the (.+) winner of this raffle! \*\*\*/
      @current_raffle[:winner] = $1 if @current_raffle
    end
  end
  finalize_current_raffle
end

def format_raffle_info
  # 1) Filter out raffles where the draw time has already passed.
  @raffles.reject! do |raffle|
    raffle[:draw_time] && (raffle[:draw_time] < Time.now)
  end

  # Header line
  output = "An asterisk ( * ) denotes a ticket has been purchased for this raffle.\n\n"

  # 2) Build formatted output for each raffle.
  @raffles.each do |raffle|
    raffle_output = ""
	
raffle_output += "Raffle ##{raffle[:id]} for \"#{raffle[:item]}\"\n"
raffle_output += "#{raffle[:cost]} silver\n"

#    raffle_output += "#{raffle[:object]}\n"
#	raffle_output += "#{raffle[:location]}\n"
    if raffle[:draw_time]
      time_string = raffle[:draw_time].strftime('%a %b %e %I:%M:%S %p %Z')
      diff_string = time_diff_in_words(raffle[:draw_time])
      if diff_string
        raffle_output += "#{time_string} (#{diff_string})\n"
      else
        raffle_output += "  Draw time has passed.\n"
      end
    end
    raffle_output += "#{raffle[:online] ? 'Must be logged in.' : 'Can be logged out.'}\n"
#    raffle_output += "#{raffle[:purchased] ? 'Ticket Purchased' : 'Not Entered'}\n"

#    raffle_output += "#{raffle[:winner] ? "*** You are the #{raffle[:winner]} winner of this raffle! ***" : ""}\n"
    raffle_output += "\n"

    # If a ticket has been purchased for this raffle, prefix every line with a "*"
if raffle[:purchased]
  raffle_output = raffle_output.lines.map do |line|
    line.strip.empty? ? line : "*#{line}"
  end.join
end

    output += raffle_output
  end
  output
end

# --- Wrayth Window Output Helper ---
def Raffle_Window(message)
  puts "<clearStream id=\"rafflewindow\"/>" +
       "<pushStream id=\"rafflewindow\"/>" +
       "<style fontFamily='monospace'/>" +
       "<pushStream id=\"rafflewindow\"/>#{message}<popStream/>"
end

# --- Create the Raffle Window ---
puts "<closeDialog id='rafflewindow'/><streamWindow id='rafflewindow' title='Raffles' location='left' resident='true' dynamic='true'></streamWindow>"

# --- before_dying Hook ---
before_dying {
  Raffle_Window("Raffle script is not running :(")
}

# --- Main Loop ---
while (line = get)
  # Start capturing when the user types "raffles are currently active"
  if line =~ /raffles are currently active/i
    @raffle_lines = []           # Reset captured lines
    $capture_until = Time.now + 1  # Capture for 1 seconds
    Raffle_Window("Capturing raffle list...\n")
	next
  end

  # Capture raffle-related lines during the capture period
if $capture_until && Time.now <= $capture_until
  if line =~ /^Raffle \#/ ||
     line =~ /^\s*Location/ ||
     line =~ /^\s*Draws/ ||
     line =~ /^\s*Players/ ||
     line =~ /^\s*Characters/ ||
     line =~ /^\s*You have purchased a ticket to this raffle/
    @raffle_lines << line
  end


  # Once the capture period is over and lines have been captured, process them
  elsif $capture_until && Time.now > $capture_until && !@raffle_lines.empty?
    parse_raffle_lines
    formatted = format_raffle_info
    Raffle_Window(formatted)
    $capture_until = nil
  end
end

