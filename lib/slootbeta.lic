# frozen_string_literal: true

#  author: SpiffyJr
#    name: SLoot
#    tags: loot

# changelog:
#     2020.10.29 - Adding a slight delay to check for loot before exiting.
#     2020.09.25 - comma update for checking silvers and added blunt skinning
#     2020.08.26 - bug fix with left/right hand swap
#     2020.08.20 - fixed some ready list logic
#     2020.07.22 - bug fix for regex with only 1 gem of a bounty left
#     2020.07.20 - fix a bug with checkbox toggles in GUI
#     2020.06.25 - regex fix for ready list with long description items
#     2020.06.18 - bug fix with looting while holding an item in both hands
#     2020.06.09 - reload after using GUI
#     2020.06.02 - some gem hoarding fixes
#     2020.05.30 - added Sigil of Resolve
#     2020.05.28 - loot category updates
#     2020.05.27 - linting and phase support
#     2020.05.26 - removed all ammo references due to archery updates
#     2020.04.08 - s/puts/_respond
#     2020.04.03 - hoarding updates
#     2020.04.02 - hoarding updates
#     2020.03.24 - fixed percent for locksmith pool
#     2020.03.23 - slootbeta.ui is finished (Gtk3 only). Fixed some _drag issues.
#     2020.03.21 - Disk looting updates.
#     2020.03.20 - Fixed @@keep_values error.
#     2020.03.18 - Some bug fixes.
#     2020.03.15 - Start of GUI update. Adding pool support for all towns.
#     2020.03.11 - Significant looting updates.
#                  Will use LOOT ROOM if able, otherwise individual looting.
#                  Looting boxes will now exclude items properly.
#                  Disk improvements.
#                  Moar hoarding fixes.
#     2020.03.09 - Fixed selling gems that aren't hoarded to local gemshop for bounties.
#     2020.03.05 - Hoarding fix from @FarFigNewGut. Added hoard get # <gem name>.
#     2020.03.04 - FWI improvements.
#     2020.03.03 - Bug fixes. Added version checking. Beginning of a beautiful friendship.

version = '2020.09.25'

if (GameSetting[:sloot_version] != version) || !File.exist?("#{$script_dir}/slootbeta.ui")
  $sloot = nil
  GameSetting[:sloot_version] = version

  echo '-- new version detected; updating UI'
  echo "-- you have 5 seconds to #{$lich_char}kill me"
  sleep(5)
  Script.run('repository', 'download slootbeta.ui')
  echo '-- update complete; restart me'
  exit
end

if $sloot.nil? || script.vars[1] == 'load' || CharSetting[:debug]
  # Setup class
  class SLootSetup < Gtk::Builder
    # Setup categories. Each category has metadata for display as well as a list of settings.
    # Ordering in the Dialog is done based on the order of the :settings hash.
    @@categories = {
      hoard: {
        settings: {
          hoard_enable: { default: false },
          hoard_lockers: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = Room[text].id
                iter[1] = Room[text].title.first
                iter[2] = Room[text].location
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(Room[selected.get_value(0)].id)
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)
              next if Room[text].nil?

              setting.push(Room[text].id)
              setting.uniq!.sort!
            end
          }
        }
      },
      loot: {
        settings: {
          loot_types: {
            default: %w[
              alchemy
              box
              collectible
              gem
              herb
              jewelry
              lockpick
              magic
              reagent
              scroll
              skin
              valuable
              uncommon
              wand
            ]
          },
          loot_exclude: {
            default: ['black ora'],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
          loot_phase: { default: false },
          loot_defensive: { default: false },
          loot_gem_super_secret: { default: '' }
        }
      },
      sell: {
        settings: {
          sell_loot_types: {
            default: %w[
              alchemy
              box
              collectible
              gem
              herb
              jewelry
              lockpick
              magic
              reagent
              scroll
              skin
              valuable
              uncommon
              wand
            ]
          },
          sell_exclude: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
          sell_keep_scrolls: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = Spell[text].num
                iter[1] = Spell[text].name
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(Spell[selected.get_value(0)].num)
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)
              next if Spell[text].nil?

              setting.push(Spell[text].num)
              setting.uniq!.sort!
            end
          },
          sell_appraise_types: { default: %w[magic uncommon valuable] },
          sell_appraise_gemshop: { default: 15_000 },
          sell_appraise_pawnshop: { default: 35_000 },
          sell_collectibles: { default: true },
          sell_locksmith: { default: true },
          sell_locksmith_pool: { default: true },
          sell_locksmith_pool_tip: { default: 25 },
          sell_locksmith_pool_tip_percent: { default: true },
          sell_share_silvers: { default: false },
          sell_fwi: { default: false },
          sell_keep_silver: { default: 0 }
        }
      },
      skin: {
        settings: {
          skin_enable: { default: false },
          skin_kneel: { default: true },
          skin_resolve: { default: true },
          skin_sheath: { default: '' },
          skin_weapon: { default: '' },
          skin_weapon_blunt: { default: '' }
        }
      },
      internal: {
        settings: {
          silence: { default: false },
          debug: { default: false },
          hoard: { default: {} },
          stats: { default: { skin: { attempts: 0, failures: 0 } } },
          unskinnable: { default: [] }
        }
      }
    }

    def self.get_category(key)
      @@categories.each { |category, data| return category unless data[:settings][key].nil? }
      nil
    end

    def self.get_setting(key)
      cat = SLootSetup.get_category(key)
      return nil if cat.nil?

      @@categories[cat][:settings].each { |setting, data| return data if setting == key }
      nil
    end

    def initialize(script, settings)
      super()

      @script = script
      @settings = settings

      # set default values if they don't exist
      @@categories.each do |_, data|
        data[:settings].each { |key, value| @settings[key] = value[:default] if @settings[key].nil? }
      end

      # remove settings that doesn't exist
      @settings.delete_if { |key, _| next SLootSetup.get_category(key).nil? }

      # only sorcerers can phase
      @settings[:loot_phase] = false unless Char.prof == 'Sorcerer'

      # GoS only for Sigil of Resolve
      @settings[:skin_resolve] = false unless Society.status == 'Guardians of Sunfist' && Society.rank >= 4

      # use a GTK Builder to setup all the basics of the window then expand on that base
      return unless defined?(Gtk) && Gtk::Version::MAJOR == 3

      Gtk.queue do
        add_from_file("#{$script_dir}/slootbeta.ui")
        load_settings

        self['main'].keep_above = true

        # connect signals after settings are loaded to a bunch of handlers don't trigger
        connect_signals { |handler| method(handler) }
      end
    end

    # This is connected to automatically during load_settings and syncs data back to CharSettings.
    def on_update(obj)
      Gtk.queue do
        key = obj.builder_name.to_sym
        setting = SLootSetup.get_setting(key)
        return if setting.nil?

        if obj.class == Gtk::CheckButton
          @settings[key] = obj.active?
        elsif obj.class == Gtk::Entry
          @settings[key] = obj.text.strip
        elsif obj.class == Gtk::SpinButton
          # update from text entry
          obj.update

          # force int, we don't use floats anywhere
          @settings[key] = obj.adjustment.value.to_i
        end
      end
    end

    def on_close_clicked
      self['main'].destroy
    end

    def on_destroy
      Gtk.queue { @running = false }
    end

    # iterate all objects and for any that match a setting name directly we set the default
    def load_settings
      Gtk.queue do
        # load up the generic settings which are just matching by name of the widget
        objects.each do |obj|
          next unless obj.methods.include?(:builder_name)

          key = obj.builder_name.to_sym
          next if (setting = SLootSetup.get_setting(key)).nil?

          # set the default value
          if obj.class == Gtk::CheckButton
            obj.active = @settings[key]
            obj.signal_connect('toggled') { on_update(obj) }
          elsif obj.class == Gtk::Entry
            obj.text = @settings[key].strip
            obj.signal_connect('changed') { on_update(obj) }
          elsif obj.class == Gtk::SpinButton
            obj.value = @settings[key]
            obj.adjustment.value = @settings[key]
            obj.signal_connect('changed') { on_update(obj) }
          elsif obj.class == Gtk::TreeView
            if (store = self["#{key}_store"]).nil?
              respond "** failed to find store for treeview #{key}"
              next
            elsif setting[:load].nil?
              respond "** no :load defined #{key}"
              next
            end

            setting[:load].call(store, @settings[key])

            # setup the signals
            if (add = self["#{key}_add"]).nil?
              respond "** failed to find add for treeview #{key}"
              next
            elsif (delete = self["#{key}_delete"]).nil?
              respond "** failed to find delete for treeview #{key}"
              next
            elsif (entry = self["#{key}_entry"]).nil?
              respond "** failed to find entry for treeview #{key}"
              next
            end

            add.signal_connect('clicked') do
              if setting[:set].nil?
                respond "** no :set defined for #{key}"
                next
              elsif entry.text.empty?
                next
              end
              setting[:set].call(store, entry.text, @settings[key])
              setting[:load].call(store, @settings[key])
            end

            delete.signal_connect('clicked') do
              if setting[:delete].nil?
                respond "** no :delete defined for #{key}"
                next
              elsif (selected = obj.selection.selected).nil?
                next
              end
              setting[:delete].call(store, selected, @settings[key])
              setting[:load].call(store, @settings[key])
            end
          end
        end

        # checkboxes for array storage with id's <setting>:<value>
        # this is primarily used by the loot types
        objects.each do |obj|
          next unless obj.methods.include?(:builder_name)
          next unless obj.builder_name =~ /^([^:]+):(.*)$/i
          next unless obj.class == Gtk::CheckButton

          key = Regexp.last_match(1).to_sym
          value = Regexp.last_match(2).to_s
          next if SLootSetup.get_setting(key).nil?

          obj.active = @settings[key].include?(value)

          # add in hook
          obj.signal_connect('toggled') do
            @settings[key].delete(value)
            if obj.active?
              @settings[key].push(value)
              @settings[key].uniq!.sort!
            end
          end
        end
      end
    end

    def start
      @running = true

      Gtk.queue { self['main'].show_all }

      wait_while { @running }
    end

    def list(cat_to_list)
      indent_size = 2
      print_array =
        proc do |key, value, indent|
          _respond("#{' ' * indent_size * indent.to_i}#{key}:")
          value.each { |entry| _respond("#{' ' * indent_size * (indent.to_i + 1)}#{value.index(entry) + 1}. #{entry}") }
        end

      print_value = proc { |key, value, indent| _respond("#{' ' * indent_size * indent.to_i}#{key}: #{value}") }

      categories = cat_to_list == 'all' ? %w[hoard loot sell skin] : [cat_to_list]

      categories.each do |opt|
        _respond("#{monsterbold_start}= #{opt.capitalize} =#{monsterbold_end}")
        @@categories[opt.to_sym][:settings].each do |id, _|
          value = @settings[id]
          value.class == Array ? print_array.call(id, value, 1) : print_value.call(id, value, 1)
        end
      end
    end

    def update_setting(key, value)
      setting = SLootSetup.get_setting(key)
      if setting.nil?
        echo "** setting \"#{key}\" does not exist"
        exit
      end

      action = nil

      if value =~ /^([+-])(.*)$/
        action = Regexp.last_match(1)
        value = Regexp.last_match(2).strip.downcase
      end

      if value == 'reset'
        @settings.delete(key)
        echo "-- reset #{key}"
      elsif @settings[key].class == Array
        if value =~ /\d/ && @settings[key][value.to_i]
          @settings[key].delete_at(value.to_i)
        else
          @settings[key].delete(value)
        end

        if action == '-'
          echo "-- \"#{value}\" removed from \"#{key}\""
        else
          @settings[key].push(value)
          echo "-- \"#{value}\" added to \"#{key}\""
        end

        echo "-- \"#{key}\" is now \"#{@settings[key].join(', ')}\""
      else
        if @settings[key].class == FalseClass || @settings[key].class == TrueClass
          value = value =~ /^true|1|yes|on/ ? true : false
        elsif @settings[key].class == Integer
          value = value.to_i
        end

        echo "-- set \"#{key}\" to \"#{value}\""
        @settings[key] = value
      end
    end
  end

  # The main looter class
  class SLoot
    attr_accessor :version, :settings

    @@ready_list = {}
    @@sacks = {}
    @@skinweapons = { normal: nil, blunt: nil }
    @@skinsheath = nil

    def self.sacks
      @@sacks
    end

    def initialize(settings)
      @settings = settings

      @disk = nil
      @disk_full = false

      @prev_room = nil
      @sacks_to_close = []
      @sell_ignore = []
      @stowed = []
      @withdrawn_silver = 0

      waitrt?
      res = dothistimeout('ready list', 3, /Your current settings are/)
      error('failed to check READY list; restart me') if res !~ /Your current settings/

      res = dothistimeout('stow list', 3, /You have the following/)
      error('failed to check STOW list; restart me') if res !~ /You have the following/

      # rubocop:disable Layout/LineLength
      stow_match = %r{(shield|weapon|secondary weapon|ranged weapon): <d cmd="[^"]+">[^<]+<a exist="\d+" noun="[^"]+">([^<]+)<\/a>(?: [^<]+)?<\/d>}
      # rubocop:enable Layout/LineLength
      $_SERVERBUFFER_.reverse[0..50].each do |line|
        if line =~ stow_match
          @@ready_list[Regexp.last_match(1).to_s] = Regexp.last_match(2).to_s
          nil
        elsif line =~ /<a exist="([^"]+)" noun="[^"]+">[^(]+\(([a-z]+)\)/
          @@sacks[Regexp.last_match(2)] = GameObj.inv.find { |i| i.id == Regexp.last_match(1) }
          @@sacks.delete(Regexp.last_match(2)) unless @@sacks[Regexp.last_match(2)]
        end
      end

      lootsack = find_sack('default')
      error('set default stow container before using this script') if lootsack.nil?

      info('checking for existence of disk')
      15.times do
        break if (@disk = GameObj.loot.find { |l| l.name =~ /#{Char.name} disk$/ })

        sleep(0.1)
      end

      @disk ? info('disk found') : info('no disk found')

      debug("ready list: #{@@ready_list.inspect}")
      debug("sacks: #{@@sacks.inspect}")
    end

    def debug(msg)
      echo ">> #{msg}" if @settings[:debug]
    end

    def info(msg)
      echo "-- #{msg}"
    end

    def error(msg)
      echo "** #{msg}"
      exit
    end

    def check_silver
      silvers = nil
      action = proc do |server_string|
        if server_string =~ /Silver:\s+([,0-9]+)/
          silvers = Regexp.last_match(1).delete(',').to_i
          DownstreamHook.remove('sloot_check_silvers')
        end

        nil
      end

      DownstreamHook.add('sloot_check_silvers', action)
      $_SERVER_.puts "#{$cmd_prefix}info\n"
      wait_until { silvers }
      silvers
    end

    def cleanup
      fill_hands
      @sacks_to_close.each { |sack| dothistimeout("close #{sack}", 2, /^You close|^That is already closed;\./) }
      @sacks_to_close = []
      @withdrawn_silver = 0
    end

    def fill_hands
      return if @stowed.length.zero?

      @stowed.each do |item|
        id = item[0]
        hand = item[1]

        if id == 'secondary weapon'
          fput('ready 2weapon')
        elsif id == 'shield'
          fput('ready shield')
        elsif id == 'ranged weapon'
          fput('ready ranged')
        elsif id == 'weapon'
          fput('ready weapon')
        else
          drag(id, hand)
        end
      end
      @stowed = []
    end

    def empty_hands
      if GameObj.right_hand.id
        @stowed.push([GameObj.right_hand.id, 'right'])
        drag('right', 'default')
      end

      return unless GameObj.left_hand.id

      @stowed.push([GameObj.left_hand.id, 'left'])
      drag('left', 'default')
    end

    def change_stance(stance)
      return if Spell['Zealot'].active? || Spell['Frenzy'].active? || dead?
      return if checkstance(stance.strip)
      return if stance == 'defensive' && checkstance('guarded')

      while (cur_stance = checkstance) != stance
        res = dothistimeout("stance #{stance}", 2, /You are now|Roundtime|Wait|wait|Your rage causes you/)
        if res =~ /Roundtime: (\d+)|wait (\d+)/i
          sleep((Regexp.last_match(1) || Regexp.last_match(2)).strip.to_f - 1)
        elsif res =~ /Your rage causes you/
          Spell['Frenzy'].putup
          Spell['Frenzy'].timeleft = 30
        elsif cur_stance == 'guarded' && stance == 'defensive'
          break
        end
      end
    end

    def empty_hand(preferred_hand = 'right')
      return if GameObj.left_hand.id.nil? || GameObj.right_hand.id.nil?

      preferred_hand = 'right' if preferred_hand != 'left' && preferred_hand != 'right'

      case preferred_hand
      when 'left'
        if @@ready_list['secondary weapon'] =~ /#{GameObj.left_hand.name}/i
          @stowed.push(['secondary weapon', preferred_hand])
          fput('store 2weapon')
        elsif @@ready_list['shield'] =~ /#{GameObj.left_hand.name}/i
          @stowed.push(['shield', preferred_hand])
          fput('store shield')
        elsif @@ready_list['ranged weapon'] =~ /#{GameObj.left_hand.name}/i
          @stowed.push(['ranged weapon', preferred_hand])
          fput('store ranged')
        end
      else
        if @@ready_list['weapon'] =~ /#{GameObj.right_hand.name}/i
          @stowed.push(['weapon', preferred_hand])
          fput('store weapon')
        end
      end

      return if GameObj.left_hand.id.nil? || GameObj.right_hand.id.nil?

      to_stow = preferred_hand == 'left' ? GameObj.left_hand : GameObj.right_hand
      drag(to_stow, 'default') if to_stow.id
    end

    def find_skin_weapon(type)
      case type
      when :normal
        weapon_name = @settings[:skin_weapon]
      when :blunt
        weapon_name = @settings[:skin_weapon_blunt]
      end

      return nil if weapon_name == ''
      return @@skinweapons[type] if @@skinweapons[type]

      unless @@skinsheath
        if @settings[:skin_sheath] != ''
          @@skinsheath = GameObj.inv.find do |i|
            i.name =~ /\b#{@settings[:skin_sheath]}\b/ || i.noun =~ /\b#{@settings[:skin_sheath]}\b/
          end
        end

        @@skinsheath ||= find_sack('default')
      end

      unless @@skinsheath.contents
        fput("look in ##{@@skinsheath.id}")
        sleep(1) unless @@skinsheath.contents
      end

      items = @@skinsheath.contents.clone
      items.push(GameObj.right_hand)
      items.push(GameObj.left_hand)

      weapon = items.find do |c|
        next if c.nil? || c.id.nil?

        c.name =~ /#{weapon_name}/i || c.noun =~ /\b#{weapon_name}\b/i
      end

      unless weapon
        info("failed to find skinner: #{weapon_name} in #{@@skinsheath}")
        return nil
      end

      @@skinweapons[type] = weapon
      @@skinweapons[type]
    end

    def find_sack(type)
      return @@sacks[type] if @@sacks[type]

      type = 'default' unless @@sacks[type]

      dothistimeout("look in ##{@@sacks[type].id}", 3, /^In the/) unless @@sacks[type].contents

      @@sacks[type]
    end

    def drag(from, to)
      input_to_id = proc do |input|
        next input if %w[drop wear].include?(input)
        next "##{input.id}" if input.class == GameObj

        case input
        when 'hand'
          empty_hand
          next GameObj.right_hand.id.nil? ? 'right' : 'left'
        when 'right'
          next "##{GameObj.right_hand.id}" if GameObj.right_hand.id
          next nil if from == 'right'

          next input
        when 'left'
          next "##{GameObj.left_hand.id}" if GameObj.left_hand.id
          next nil if from == 'left'

          next input
        end

        if input.class == String
          next "##{input.to_i}" unless input.to_i.zero?

          sack = find_sack(input)

          if sack.nil?
            info("failed to find sack for #{input}")
            sack = find_sack('default')
          end

          next "##{sack.id}"
        end

        error("invalid param #{input.inspect} passed to drag")
      end

      debug("dragging #{from.inspect} to #{to.inspect}")

      to_id = input_to_id.call(to)
      from_id = input_to_id.call(from)

      if to_id.nil? || from_id.nil?
        info("there was an issue dragging #{to_id} to #{from_id}")
        return
      end

      debug("#{from_id.inspect} to #{to_id.inspect}")

      fput("_drag #{from_id} #{to_id}")

      lines = reget.reverse[0..5]

      # was it closed?
      if lines.any? { |l| l =~ /It's closed/i }
        @sacks_to_close.push(to_id)
        fput("open #{to_id}")
        drag(from, to)
      elsif lines.any? { |l| l =~ /^There appears to be an/i }
        info('possibly an item you want to keep')
        info('sleeping for 10 seconds: ;kill the script to hold onto it')
        sleep(10)
        drag(from, to)
      end
    end

    def stow_it(obj, parent = nil)
      empty_hand

      if obj.type == 'box'
        return drag(phase_box(obj), obj.type) unless @disk && !@disk_full

        # disk is available
        wait_for_disk

        # disk didn't make it; abort
        if @disk.status =~ /gone/
          drag(phase_box(obj), 'box')
          return
        end

        # try the disk now
        drag(obj, @disk)

        # welp, it's full, stow in normal container instead
        if reget.reverse[0..25].any? { |l| l =~ /is full|won't fit in the/i }
          @disk_full = true
          drag(phase_box(obj), 'box')
        end

        return
      end

      # we know some types don't work with LOOT (and you can't loot if it has a parent)
      if parent || obj.type !~ /box|gem|herb|skin|wand|scroll|potion|reagent|trinket|lockpick|treasure|forageable|magic/
        return drag(obj, obj.type)
      end

      # use built-in loot command
      loot_match = /^You pick up|does not appear to be|There is no loot|You search through/
      res = dothistimeout("loot ##{obj.id}", 3, loot_match)
      # failed, stow in default container
      return drag(obj, obj.type) if res =~ /does not appear to be/

      # still in hand for some reason (probably won't fit)
      return unless [GameObj.right_hand.id, GameObj.left_hand.id].include?(obj.id)

      info("item won't fit in your container")
      info('sleeping for 3 seconds; kill me if you want to keep it')
      sleep(3)
      drag(obj, 'drop')
    end

    def loot_objs(objs, parent = nil)
      # noop, I guess
      return if objs.empty? || objs.nil?

      # general rejections we will never loot and the in-game LOOT command will ignore
      objs = objs.reject { |obj| obj.name =~ /\bsevered\b/i || obj.type.nil? || obj.id.to_i.negative? }

      return if objs.empty?

      # special logic for boxes (then we reject them since they're handled)
      objs = objs.reject do |obj|
        next false unless obj.type == 'box'

        stow_it(obj)
        next true
      end

      # check for any exclusions, cursed gems, etc.
      # if none exist, we can safely use LOOT ROOM and save some time
      objs_to_loot = objs.reject do |obj|
        obj.type !~ /#{@settings[:loot_types].join('|')}/i ||
        (@settings[:loot_exclude].length.positive? && obj.name =~ /#{@settings[:loot_exclude].join('|')}/)
      end

      # nothing to do?
      return if objs_to_loot.empty?

      empty_hand

      # check for LOOT ROOM/OBJECT support (LOOT ROOM skips weapons and armor)
      if objs_to_loot.length == objs.reject { |obj| obj.type =~ /weapon|armor/i }.length
        if parent.nil?
          dothistimeout('loot room', 3, /With a discerning eye|There is no loot/)
        else
          dothistimeout("loot ##{parent.id}", 3, /You search/)
        end
        return
      end

      # Super Secret Gem Pouch support
      if @settings[:loot_gem_super_secret].length.positive? && objs_to_loot.any? { |obj| obj.type =~ /gem/ }
        if dothistimeout "gather #{@settings[:loot_gem_super_secret]}", 5, /^You gather|^You pick up/i
          objs_to_loot = objs_to_loot.reject { |obj| obj.type =~ /gem/i }
        end

        return if objs_to_loot.empty?
      end

      # anything leftover (probably rare)
      objs_to_loot.each { |obj| stow_it(obj, parent) }
    end

    def find_dead
      objs = []

      15.times do
        objs = GameObj.npcs.find_all { |npc| npc.type !~ /passive|escort/ && npc.status == 'dead' }
        break if objs.length.positive?

        sleep(0.10)
      end

      objs
    end

    def search(npcs)
      npcs = npcs.to_a

      return if npcs.empty?

      npcs.each do |npc|
        change_stance('defensive') if GameObj.targets.any? && @settings[:loot_defensive]

        fput("loot ##{npc.id}")
        30.times do
          break unless GameObj.npcs.any? { |n| n.id == npc.id }

          sleep(0.10)
        end
      end

      # if the setting is on always end in defensive
      change_stance('defensive') if @settings[:loot_defensive]
    end

    def skin(gameobjs)
      return unless @settings[:skin_enable]

      gameobjs = gameobjs.to_a.reject do |npc|
        @settings[:unskinnable].index(npc.name) > -1 || npc.type =~ /bandit/ || npc.name =~ /Grimswarm/ ||
          npc.name =~ /^(?:ethereal|ghostly|unwordly)/
      end

      blunt_targets = /krynch/

      # normal npcs can use the regular skinner
      normal_npcs = gameobjs.reject { |npc| npc.name =~ blunt_targets }

      # blunt npcs need a blunt skinner
      blunt_npcs = gameobjs.find_all { |npc| npc.name =~ blunt_targets }

      # seems we didn't find any targets
      return if (normal_npcs + blunt_npcs).empty?

      skin_npcs = proc do |npcs, type|
        next if npcs.empty? || npcs.nil?

        skinner = find_skin_weapon(type)
        has_skinner = skinner.nil? || [GameObj.right_hand.id, GameObj.left_hand.id].include?(skinner.id)

        drag(skinner, 'hand') unless has_skinner

        if GameObj.targets.empty?
          while @settings[:skin_kneel] && !kneeling?
            dothistimeout('kneel', 3, /^You kneel down\.$|^You move to|^You are already kneeling\.$/)
          end
        end

        if @settings[:skin_resolve] && Spell['Sigil of Resolve'].affordable? && !Spell['Sigil of Resolve'].active?
          Spell['Sigil of Resolve'].cast
        end

        npcs.each do |npc|
          # rubocop:disable Layout/LineLength
          skin_match = /skinned|botched|already been|cannot skin|must be a member|can only skin|You are unable to break through|You break through the crust of the|You crack open a portion/
          break_match = /^(?:You break through the crust of the .+ and withdraw |You crack open a portion of the .+ and uncover )(.+)!/
          # rubocop:enable Layout/LineLength

          res = dothistimeout("skin ##{npc.id}#{skinner ? " #{skinner.id == GameObj.left_hand.id ? 'left' : 'right'}" : ''}", 2, skin_match)
          if res =~ /^You cannot skin/
            @settings[:unskinnable].push(npc.name)
          elsif res =~ break_match
            drag(Regexp.last_match(1).split.last, 'gem')
          else
            @settings[:stats][:skin][:attempts] = @settings[:stats][:skin][:attempts] + 1
          end

          @settings[:stats][:skin][:failures] = @settings[:stats][:skin][:failures] + 1 if res =~ /^You botched/i
        end

        drag(skinner, @@skinsheath) unless has_skinner
      end

      skin_npcs.call(normal_npcs, :normal)
      skin_npcs.call(blunt_npcs, :blunt)

      until standing?
        stance = checkstance
        change_stance('offensive') if GameObj.targets.empty?
        dothistimeout('stand', 3, /You stand|You quickly roll/)
        change_stance(stance) if checkstance != stance
      end
    end

    def stow_notes
      drag(GameObj.right_hand, 'default') if GameObj.right_hand.noun =~ /^(?:note|scrip|chit)$/
      drag(GameObj.left_hand, 'default') if GameObj.left_hand.noun =~ /^(?:note|scrip|chit)$/
    end

    def go2(place)
      fput('unhide') if hidden?

      # if we're going to a place we do it based on the sell_fwi settings

      if place.class == String && @settings[:sell_fwi]
        fwi_place = Room.list.find { |room| room.tags.include?(place) && fwi?(room) }

        place = fwi_place.id if fwi_place
      end

      return if Room.current.id == place || Room.current.tags.include?(place)

      if Room.current.id.nil?
        if @settings[:debug]
          info("unknown room location: hope you know what you're doing")
        else
          error('unknown room location')
        end
      end
      Script.run('go2', "#{place} --disable-confirm", { quiet: true })
    end

    def withdraw_silver(amount)
      return if amount <= 0

      go2('bank')

      # TODO: handle not enough silver case
      fput("withdraw #{amount} silvers")
      @withdrawn_silver += amount
    end

    def loot_box(box)
      trash_match = /^(?:crate|barrel|wastebarrel|wastebasket|casket|coffer)$/
      unless (trash = (GameObj.room_desc.to_a + GameObj.loot.to_a).find { |obj| obj.noun =~ trash_match })
        info('failed to find a trash container')
      end

      res = dothistimeout("open ##{box.id}", 3, /open|locked/)
      return stow_it(box) if res =~ /locked/

      if box.contents.nil?
        dothistimeout("look in ##{box.id}", 3, /^In the/)
        30.times do
          break unless box.contents.nil?

          sleep(0.10)
        end
      end

      if box.contents.nil?
        info("failed to see contents of #{box.name}")
        return
      end

      res = dothistimeout("get coins from ##{box.id}", 3, /^You gather the remaining|^Get what\?/)
      info('unknown get coin result') if res !~ /^You gather the remaining/

      waitrt?

      loot_objs(box.contents, box) if box.contents.length.positive?

      if trash.nil?
        drag(box, 'drop')
      else
        fput("put ##{box.id} in ##{trash.id}")
        sleep(0.25)
        if [GameObj.right_hand.id, GameObj.left_hand.id].include?(box.id)
          fput("put ##{box.id} in ##{trash.id}")
          sleep(0.25)
        end
      end

      drag(box, 'drop') if [GameObj.right_hand.id, GameObj.left_hand.id].include?(box.id)
    end

    def phase_box(box)
      return box unless @settings[:loot_phase] && Spell[704].known? && box.name !~ /enruned|mithril/i

      drag(box, 'hand') unless [GameObj.left_hand.id, GameObj.right_hand.id].include?(box.id)
      waitcastrt?

      dothistimeout('prep 704', 3, /Your spell is ready/)
      phase_match = /appears lighter|somewhat insubstantial|flickers in and out|resists the effects/
      res = dothistimeout("cast ##{box.id}", 3, phase_match)

      # once phased they get a new id so refresh the object
      return box unless res =~ /appears lighter/

      GameObj.left_hand.type =~ /box/i ? GameObj.left_hand : GameObj.right_hand
    end

    def unphase_box(box)
      return box unless box.type == 'box' && box.name =~ /shifting/i

      res = dothistimeout("drop ##{box.id}", 3, /flickers in and out of existence/)
      return box unless res =~ /flickers in and out of existence/

      GameObj.left_hand.type =~ /box/i ? GameObj.left_hand : GameObj.right_hand
    end

    def open_box(box, activator)
      drag(box, 'hand')
      box = unphase_box(box)

      res = dothistimeout(activator, 3, /Gimme (\d+) silvers/)
      info('unknown locksmith response') unless res

      res = dothistimeout('pay', 3, /accepts|have enough/)
      if res =~ /have enough/
        drag(box, 'default')
        withdraw_silver(8000 - check_silver)
        go2('locksmith')

        return open_box(box, activator)
      end

      loot_box(box)
    end

    def wait_for_disk
      return unless @disk

      if @disk.status =~ /gone/ || !GameObj.loot.find { |l| l.name =~ /#{Char.name} disk$/ }
        info('waiting for your disk to arrive')
        50.times do
          break if (@disk = GameObj.loot.find { |l| l.name =~ /#{Char.name} disk$/ })

          sleep(0.1)
        end
      end

      return unless @disk && @disk.status !~ /gone/ && @disk.contents.nil?

      res = dothistimeout "look in ##{@disk.id}", 3, /^In the|^There is nothing|^That is closed/
      return unless res =~ /^That is closed/

      fput("open ##{@disk.id}")
      fput("look in ##{@disk.id}")
    end

    def get_meta(key)
      key = "meta:#{key}"
      tag = Room.current.tags.find { |t| t =~ /#{key}/ }
      return Regexp.last_match(1).to_s if tag =~ /^#{key}:(.*)$/

      nil
    end

    def sell_locksmith_pool(boxes)
      # if we're here, assume we emptied out the disk some
      @disk_full = false

      withdraw_silver(8000 - check_silver) if boxes.length.positive?

      go2('locksmith pool')

      meta = get_meta('boxpool:npc')
      worker = GameObj.npcs.find { |npc| npc.name == meta }
      if worker.nil?
        info('failed to find the locksmith pool NPC')
        info('update your map db; ;repository download-mapdb')
        info('if the error persists then report this to SpiffyJr')
        return
      end

      table = (GameObj.room_desc.to_a + GameObj.loot.to_a).find { |t| t.name == get_meta('boxpool:table') }
      if table.nil?
        info('failed to find the locksmith pool table')
        info('update your map db; ;repository download-mapdb')
        info('if the error persists then report this to SpiffyJr')
      end

      empty_hands

      give_box = proc do |box|
        box = unphase_box(box)

        percent = ''
        percent = ' PERCENT' if @settings[:sell_locksmith_pool_tip_percent]
        fput("give ##{worker.id} #{@settings[:sell_locksmith_pool_tip]}#{percent}")
        match = /You don't have that much|takes your/
        res = dothistimeout("give ##{worker.id} #{@settings[:sell_locksmith_pool_tip]}#{percent}", 3, match)
        if res =~ /You don't have that much/
          withdraw_silver(8000 - check_silver)
          go2('locksmith pool')
          give_box.call(box)
        end
      end

      wait_for_disk

      boxes.each do |box|
        drag(box, 'hand')
        give_box.call(box)
        sleep(0.250)
        drag(box, 'box') if [GameObj.right_hand.id, GameObj.left_hand.id].include?(box.id)
      end

      # retrieve (and loot) any boxes in the pool
      loop do
        match = /We don't have any boxes ready for you|We don't seem to have that box|Alright, here's your/
        res = dothistimeout("ask ##{worker.id} for return", 3, match)
        # no more boxes left
        break if res !~ /Alright, here's your/

        box = nil
        if GameObj.right_hand.type =~ /box/
          box = GameObj.right_hand
        elsif GameObj.left_hand.type =~ /box/
          box = GameObj.left_hand
        else
          error('failed to find the box you were supposed to get; report this to SpiffyJr')
        end

        loot_box(box)

        sleep(0.250)
      end
    end

    def sell_locksmith(boxes)
      # if we're here, assume we emptied out the disk some
      @disk_full = false

      boxes = boxes.select { |box| box.type =~ /box/i }

      return if boxes.empty?

      silver = check_silver
      need_silver = 8000 - silver

      withdraw_silver(need_silver) if silver < 8000

      go2('locksmith')
      wait_for_disk

      if (table = (GameObj.room_desc.to_a + GameObj.loot.to_a).find { |obj| obj.noun =~ /^(?:table|counter)$/ })
        dothistimeout("look on ##{table.id}", 3, /^On the/) if table.contents.nil?

        if table.contents.nil?
          error('failed to find table contents')
        else
          activator = nil
          if table.contents.any? { |obj| obj.noun == 'bell' }
            activator = 'ring bell'
          elsif table.contents.any? { |obj| obj.noun == 'keys' }
            activator = 'pull keys'
          elsif table.contents.any? { |obj| obj.noun == 'chime' } || GameObj.loot.any? { |obj| obj.noun == 'chime' }
            activator = 'ring chime'
          end

          if activator
            empty_hands
            boxes.each { |box| open_box(box, activator) }

            drag(GameObj.right_hand, 'drop') if GameObj.right_hand.type =~ /box/

            drag(GameObj.left_hand, 'drop') if GameObj.left_hand.type =~ /box/
          else
            error('failed to find a bell, keys, or chime on the table')
          end
        end
      else
        error('failed to find a table')
      end
    end

    def closest_locker
      error('hoarding is enabled but no lockers are set') if @settings[:hoard_lockers].empty?

      Room.current.find_nearest(@settings[:hoard_lockers])
    end

    def locker
      locker = (GameObj.loot.to_a + GameObj.room_desc.to_a).find { |obj| obj.noun =~ /^(?:chest|locker)$/i }

      error('failed to find jar storage') unless locker

      if locker.contents.nil?
        dothistimeout("look in ##{locker.id}", 3, /^In the|^There is nothing/)
        30.times do
          break unless locker.contents.nil?

          sleep(0.10)
        end
      end

      error('failed to get locker contents') if locker.contents.nil?

      locker
    end

    def go2_locker
      return if XMLData.room_title =~ /locker booth/i

      go2(closest_locker)

      if (way_in = (GameObj.loot.to_a + GameObj.room_desc.to_a).find { |obj| obj.noun =~ /^(?:opening|curtain)$/ })
        current = Room.current.id
        move "go #{way_in.noun}"
        # You'll have to wait, Kimsy is presently using that locker booth.
        wait_while { current == Room.current.id }
      else
        error('failed to find locker entrance')
      end
    end

    def leave_locker
      return if XMLData.room_title !~ /locker booth/i

      if (way_out = (GameObj.loot.to_a + GameObj.room_desc.to_a).find { |obj| obj.noun =~ /^(?:opening|curtain)$/ })
        current = Room.current.id
        move "go #{way_out.noun}"
        wait_while { current == Room.current.id }
      else
        error('failed to find locker entrance')
      end
    end

    def open_locker
      fput('open locker')
      sleep(1)
    end

    def close_locker
      fput('close locker')
      sleep(1)
    end

    def hoard_normalize_gem(gem_name)
      gem_name.gsub(
        # strip out containing and some prefixes
        /^containing |large |medium |small |tiny |some |pieces? of |shard of /,
        ''
      ).gsub(/ies$/, 'y').gsub(/xes$/, 'x').gsub(/zes$/, 'z').gsub(/es$/, 'e').gsub(/s$/, '') # remove pluarl
    end

    def hoard_index
      go2_locker
      open_locker

      empty_count = 0
      jars = []

      locker.contents.find_all { |obj| obj.noun =~ /^(?:jar|bottle|beaker)$/i }.each do |jar|
        if jar.after_name.nil?
          empty_count += 1
        else
          res = dothistimeout("look in ##{jar.id} from ##{locker.id}", 3, /^Inside .*? you see [0-9]+ portion/)
          if res =~ /^Inside .*? you see ([0-9]+) portion/
            jars.push({
              count: Regexp.last_match(1).to_i,
              gem: hoard_normalize_gem(jar.after_name),
              full: res.include?('It is full')
            })
          end
        end
      end

      @settings[:hoard] = {} unless @settings[:hoard]
      @settings[:hoard][closest_locker] = { empty: empty_count, jars: jars }

      close_locker
    end

    def hoard_get(gem, count)
      room_id = closest_locker
      hoard_index unless @settings[:hoard][room_id]

      locker_data = @settings[:hoard][closest_locker]
      jar_data = locker_data[:jars].find { |jar| jar[:gem] == gem }

      if !jar_data || jar_data[:count] < count
        info("tried to get #{count} #{gem} but you didn't have enough")
        return
      end

      go2_locker
      open_locker

      jar = locker.contents.find do |obj|
        obj.noun =~ /^(?:jar|bottle|beaker)$/i && gem == hoard_normalize_gem(obj.after_name)
      end

      if jar
        fput("get ##{jar.id} from ##{locker.id}")

        count.times do
          fput("shake ##{jar.id}")
          jar_data[:count] -= 1
          jar_data[:full] = false
          fput('stow left gem')
        end

        fput("put ##{jar.id} in locker")
      end

      # if we emptied the jar clean up some data
      if jar_data[:count].zero?
        locker_data[:empty] += 1
        locker_data[:jars].delete_if { |j| j[:gem] == jar_data[:gem] }
      end

      close_locker
      leave_locker
    end

    def hoard_store
      room_id = closest_locker
      hoard_index unless @settings[:hoard][room_id]

      lootsack = find_sack('gem')
      data = @settings[:hoard][room_id]

      jars_available = data[:jars].find_all do |jar|
        lootsack.contents.any? { |obj| obj.type =~ /gem/ && jar[:gem] == hoard_normalize_gem(obj.name) }
      end

      gems_to_store = lootsack.contents.find_all do |obj|
        obj.type =~ /gem/ && jars_available.none? { |jar| jar[:gem] == hoard_normalize_gem(obj.name) }
      end
      gems_to_store = gems_to_store.collect { |gem| hoard_normalize_gem(gem.name) }.uniq

      jars_to_fill = jars_available.delete_if { |jar| jar[:full] }

      return if jars_to_fill.empty? && (gems_to_store.empty? || data[:count].zero?)

      go2_locker
      open_locker

      # proc to handle dragging gem
      drag_gem = proc do |gem, jar, jar_data|
        drag_match = /^You (?:add|put)|is full|does not appear to be a suitable container for/
        res = dothistimeout("_drag ##{gem.id} ##{jar.id}", 3, drag_match)
        if res =~ /^You put/
          jar_data[:count] += 1
        elsif res =~ /^You add .* filling it/
          jar_data[:count] += 1
          jar_data[:full] = true
          next
        elsif res =~ /^You add/
          jar_data[:count] += 1
        elsif res =~ /is full/
          jar_data[:full] = true
          drag(gem, 'default')
          next
        elsif res =~ /does not appear to be a suitable container for/
          drag(gem, 'default')
          next
        end
      end

      jars_to_fill.each do |jar_data|
        jar = locker.contents.find do |obj|
          obj.noun =~ /^(?:jar|bottle|beaker)$/i && jar_data[:gem] == hoard_normalize_gem(obj.after_name)
        end
        error("failed to find jar for #{jar_data[:gem]} - this shouldn't happen") unless jar

        fput("get ##{jar.id} from ##{locker.id}")

        # stash each of the matching gems until full
        gems = lootsack.contents.find_all { |obj| obj.type =~ /gem/ && jar_data[:gem] == hoard_normalize_gem(obj.name) }
        gems.each do |gem|
          drag_gem.call(gem, jar, jar_data)
          break if jar_data[:full]
        end

        fput("put ##{jar.id} in locker")
      end

      # store new gems if we have some empty containers
      if data[:empty].positive?
        gems_to_store.each do |gem_name|
          jar = locker.contents.find { |obj| obj.noun =~ /^(?:jar|bottle|beaker)$/i && obj.after_name.nil? }

          # this shouldn't happen
          error("failed to find empty jar for #{gem_name}") unless jar

          fput("get ##{jar.id} from ##{locker.id}")

          jar_data = { gem: gem_name, count: 0 }

          # stash each of the matching gems until full
          gems = lootsack.contents.find_all { |obj| obj.type =~ /gem/ && gem_name == hoard_normalize_gem(obj.name) }
          gems.each { |gem| drag_gem.call(gem, jar, jar_data) }

          data[:empty] -= 1
          data[:jars].push(jar_data)

          fput("put ##{jar.id} in locker")
        end
      end

      close_locker
      leave_locker
    end

    def find_boxes
      wait_for_disk
      boxes = find_sack('box').contents.find_all { |i| i.type =~ /box/ }
      boxes += @disk.contents.to_a.find_all { |obj| obj.type =~ /box/ } if @disk

      boxes
    end

    def sell_collectibles
      lootsack = find_sack('default')
      cols = lootsack.contents.find_all { |l| l.type =~ /collectible/ }

      return if cols.empty?

      go2('collectibles')

      cols.each do |c|
        drag(c, 'hand')
        dothistimeout "deposit ##{c.id}", 3, /You hand your/
      end
    end

    def fwi?(room)
      (room.location =~ /Four Winds|Mist Harbor|Western Harbor/)
    end

    def sell_bounty
      # rubocop:disable Layout/LineLength
      skin_match = /You have been tasked to retrieve (\d+) (.*) of at least \w+ quality for (?:the )?\w+ (?:in|on|near) (?:(.*) (?:under|near|between) )?(?:the Company Store in )?([^.]+)\.  You can SKIN them off the corpse of an? (.*) or purchase/
      gem_match = /The gem dealer in ([^,]+), [^,]+, has received orders from multiple customers requesting (?:an?|some) ([^.]+)\.  You have been tasked to retrieve (\d+)/
      # rubocop:enable Layout/LineLength

      if bounty? =~ skin_match
        skin = Regexp.last_match(2)
        realm = Regexp.last_match(3).nil? ? Regexp.last_match(4) : Regexp.last_match(3)

        furrier = Room.list.find { |r| r.tags.include?('furrier') && r.location =~ /#{realm}/i }
        error('failed to find the furrier to turn into; send this to SpiffyJr') unless furrier

        loot = find_sack('skin').contents.find_all { |l| l.sellable == 'furrier' && skin =~ /#{l.name}/ }
        unless loot.empty?
          go2(furrier)
          loot.each do |l|
            drag(l, 'hand')
            fput("sell ##{l.id}")
          end
        end
      elsif bounty? =~ gem_match
        realm = Regexp.last_match(1)
        gem = hoard_normalize_gem(Regexp.last_match(2))
        gems_needed = Regexp.last_match(3).to_i
        gems_needed -= find_sack('gem').contents.to_a.find_all { |l| gem == hoard_normalize_gem(l.name) }.length

        gemshop = Room.list.find { |r| r.tags.include?('gemshop') && r.location =~ /#{realm}/i }
        error('failed to find the gemshop to turn into; send this to SpiffyJr') unless gemshop

        gems_on_hand = find_sack('gem').contents.to_a.find_all { |l| gem == hoard_normalize_gem(l.name) }

        # failed to find FWI locker, use closest instead

        # raid stockpile if we need to
        if gems_on_hand.length < gems_needed && @settings[:hoard_enable]
          has_fwi_locker = false
          if @settings[:sell_fwi]
            @settings[:hoard_lockers].each do |locker|
              room = Room[locker]
              next unless room.id != 0 && fwi?(room)

              go2(room.id)
              has_fwi_locker = true
              break
            end
          end

          go2(gemshop) unless has_fwi_locker

          jar_data = @settings[:hoard][closest_locker][:jars].find { |jar| jar[:gem] == gem }

          hoard_get(gem, gems_needed) if gems_needed.positive? && jar_data && jar_data[:count] >= gems_needed
        end

        gems_on_hand = find_sack('gem').contents.to_a.find_all { |l| gem == hoard_normalize_gem(l.name) }
        if gems_on_hand.length >= 0
          go2(gemshop)
          gems_on_hand.each do |l|
            drag(l, 'hand')
            fput("sell ##{l.id}")
          end
        end
      end
    end

    def sell
      boxes = find_boxes

      fput('unhide') if hidden?

      empty_hands

      # check for bounties
      sell_bounty

      starting_silver = check_silver

      if @settings[:sell_locksmith_pool] && boxes.length.positive?
        sell_locksmith_pool(boxes)

        # refresh the boxes
        boxes = find_boxes
      end

      sell_locksmith(boxes) if @settings[:sell_locksmith] && boxes.length.positive?

      sell_collectibles if @settings[:sell_collectibles]

      hoard_store if @settings[:hoard_enable]

      lootsack = find_sack('default')
      get_loot = proc do |location|
        lootsack.contents.find_all { |obj| obj.sellable =~ /^#{location}/i }.reject do |obj|
          @sell_ignore.index(obj.id) ||
            (@settings[:sell_exclude].length.positive? && obj.name =~ /#{@settings[:sell_exclude].join('|')}/) ||
            @settings[:sell_loot_types].none? { |loot_type| obj.type =~ /#{loot_type}/ }
        end
      end

      # do the primary selling at each place
      %w[furrier gemshop consignment pawnshop].each do |location|
        loot = get_loot.call(location)

        next if loot.empty?

        go2(location)

        if location =~ /furrier|gemshop/
          drag(lootsack, 'hand') if [checkleft, checkright].index(lootsack.noun).nil?

          dothistimeout("sell ##{lootsack.id}", 3, /inspects the contents carefully/)

          drag(lootsack, 'wear') unless [checkleft, checkright].index(lootsack.noun).nil?

          stow_notes

          loot = get_loot.call(location)

          next if loot.empty?
        end

        # sanitycheck
        drag(lootsack, 'wear') unless [checkleft, checkright].index(lootsack.noun).nil?

        # individual items time (appraisals)
        loot.each do |obj|
          if obj.type =~ /scroll/ && @settings[:sell_keep_scrolls].length.positive?
            res = dothistimeout "read ##{obj.id}", 3, /^On the/
            if res.nil?
              @sell_ignore.push(obj.id)
              next
            end

            spell_list = []
            $_SERVERBUFFER_.reverse[0..25].each do |line|
              if line =~ /noun="([0-9]+)"/
                spell_list.push(Regexp.last_match(1).to_s)
              elsif line =~ /On the <a exist=\"[^"]+\"/
                break
              end
            end

            if (@settings[:sell_keep_scrolls] & spell_list).length.positive?
              @sell_ignore.push(obj.id)
              next
            end
          end

          drag(obj, 'hand')

          if obj.type =~ /#{@settings[:sell_appraise_types].join('|')}/
            # rubocop:disable Layout/LineLength
            appraise_match = /[,0-9,]+ (?:silver|Not my line, really|for it if you want to sell|for this if you'd like)|I'm not buying anything this valuable today|not quite my field|only deal in gems and jewelry|There is nothing of value to me|Trying to pull a fast one on old Hortemeyer, are you\?|Can't say I'm interested|That's basically worthless here|no use for that/
            denied = /Not my line, really|not quite my field|only deal in gems and jewelry|There is nothing of value to me|Trying to pull a fast one on old Hortemeyer, are you\?|no use for that/
            accepted = /([,0-9,]+) (?:silver|for it if you want to sell|for this if you'd like)/
            # rubocop:enable Layout/LineLength

            res = dothistimeout("appraise ##{obj.id}", 3, appraise_match)

            value = 99_999_999
            if location == 'gemshop'
              value = @settings[:sell_appraise_gemshop]
            elsif location == 'pawnshop'
              value = @settings[:sell_appraise_pawnshop]
            else
              info("appraise setting not available for #{location}; report this to SpiffyJr")
            end

            matched = Regexp.last_match(1).delete(',').to_i

            if res.nil? || (res =~ denied) || (res =~ accepted && matched >= value)
              debug('unknown response from appraisal!') if res.nil?

              @sell_ignore.push(obj.id)
              drag(obj, 'default')
              next
            end
          end

          # rubocop:disable Layout/LineLength
          sell_match = /(?:pays|hands) you [,0-9]+ silver|not quite my field|only deal in gems and jewelry|no use for that|Where do you find this junk|That's basically worthless here/
          # rubocop:enable Layout/LineLength
          res = dothistimeout("sell ##{obj.id}", 3, sell_match)
          @sell_ignore.push(obj.id) if res =~ /no use for that|That's basically worthless here/

          stow_notes

          drag(obj, 'default') if (GameObj.right_hand.id == obj.id) || (GameObj.left_hand.id == obj.id)

          # assume disk is no longer full
          @disk_full = false
        end
      end

      ending_silver = check_silver
      profit = ending_silver - starting_silver - @withdrawn_silver
      keep_silvers = @settings[:sell_keep_silvers].to_i

      if ending_silver.positive? && keep_silvers.zero? || (keep_silvers.positive? && ending_silver != keep_silvers)
        go2('bank')
        fput('share all') if @settings[:sell_share_silvers] && ending_silver > 1
        fput('deposit all')
        fput("withdraw #{keep_silvers}") if keep_silvers.positive?

        if profit.negative?
          info("Your loss was #{profit} silvers.")
        elsif profit.positive?
          info("Your profit was #{profit} silvers.")
        end
      else
        info("That wasn't very useful.")
      end
    end
  end

  $sloot = SLoot.new(CharSetting.to_hash)
end

# most common use-case, running to loot
if script.vars[1].nil?
  script.silent = true if CharSetting[:silence]

  npcs = $sloot.find_dead

  if npcs
    $sloot.skin(npcs)
    $sloot.search(npcs)
  end

  $sloot.loot_objs(GameObj.loot)

  $sloot.cleanup
elsif script.vars[1] == 'help'
  print_option =
    proc do |option, msg, eg = '', pad = 2|
      msg = format("%-40s #{$lich_char}#{script.name} #{eg}", msg) if eg != ''

      respond(format('  %<pad>s%<option>-25s %<msg>s', {
        pad: ' ' * pad,
        option: option,
        msg: msg
      }))
    end

  respond('SLoot by SpiffyJr')
  respond('')
  respond('SLoot is a looter script designed to make looting as fast and easy as possible.')
  respond('')
  respond("Basic usage: #{$lich_char}#{script.name}")
  respond('')
  respond('Extra commands:')
  print_option.call('help', 'show this help message')
  print_option.call('left|right', 'loot your left/right hand')
  print_option.call('list', 'list current settings')
  print_option.call('sell', 'sells your default loot sack')
  print_option.call('silence', 'toggles silencing the script for less feedback')
  print_option.call('stats', 'displays your loot statistics')
  print_option.call('update', 'reload after updating from repository')
  respond('')
  respond('Gem hoarding:')
  print_option.call('get # <gem name>', 'get gems from closest locker hoard')
  print_option.call('forget <room#|all>', 'forget the index for the room (or all)')
  print_option.call('index', 'index the nearest locker')
  print_option.call('list [alpha|gem name]', 'list locker contents')
  print_option.call('store', 'store gems in the nearest locker')
  respond('')
  respond('Configure SLoot by setting options:')
  print_option.call('<setting> <value>', 'set a setting', 'skin true')
  print_option.call('<setting> +<value>', 'add to setting', 'loot_types +gem')
  print_option.call('<setting> -<value>', 'delete from setting', 'loot_types -gem')
  respond('')
  respond('Available options:')
  # default_settings.each do |k, v|
  #   if v[1].nil?
  #     next
  #   end

  #   print_option.call(k, v[1])
  # end
  # respond("")
elsif script.vars[1] == 'silence'
  CharSetting[:silence] = !CharSetting[:silence]
  if CharSetting[:silence]
    echo "-- Fine, I'll be quiet now"
  else
    echo '-- You want to hear what I have to say? Great!'
  end
elsif script.vars[1] == 'hoard'
  if script.vars[2] == 'forget'
    if !script.vars[3]
      echo('-- specify a locker (or all)')
      exit
    elsif script.vars[3] == 'all'
      echo '-- hoard cleared'
      CharSetting[:hoard] = {}
    else
      unless CharSetting[:hoard][script.vars[3].to_i]
        echo("** #{script.vars[3]} has not been indexed yet")
        exit
      end
      CharSetting[:hoard].delete(script.vars[3].to_i)
    end

    $sloot = nil
  elsif script.vars[2] == 'index'
    $sloot.hoard_index
  elsif script.vars[2] == 'list'
    CharSetting.to_hash[:hoard].each_pair do |room_id, data|
      room = Room[room_id]
      _respond("<b>#{room.location} - #{room.title.first} (#{data[:jars].length} jars, #{data[:empty]} empty)</b>")
      respond('gem                                    count  full')
      respond('-------------------------------------- -----  ----')

      if script.vars[3] == 'alpha'
        jars = data[:jars].sort_by { |obj| obj[:gem] }
      elsif !script.vars[3].empty? && script.vars[3].length.positive?
        jars = data[:jars].find_all { |obj| obj[:gem] =~ /#{script.vars[3..-1].join(' ')}/i }
      else
        jars = data[:jars].sort_by { |obj| -1 * obj[:count] }
      end

      jars.each do |jar|
        respond(format('%<gem>-40s %<count>-5d %<full>-4s', {
          gem: jar[:gem],
          count: jar[:count],
          full: jar[:full] ? 'yes' : 'no'
        }))
      end
      respond('-------------------------------------- -----  ----')
      respond
    end
  elsif script.vars[2] == 'store'
    $sloot.hoard_store
  elsif script.vars[2] == 'get'
    if (count = script.vars[3].to_i).zero?
      echo '** invalid gem count; try a number greater than 0'
      exit
    elsif (gem = script.vars[4..-1].join(' ')) == ''
      echo '** invalid gem name'
      exit
    end

    $sloot.hoard_get(gem, count)
  elsif script.vars[2] == 'empty'
    CharSetting[:hoard][$sloot.closest_locker][:jars].each do |jar|
      $sloot.hoard_get(jar[:gem], jar[:count])
    end
  else
    echo "** You're doing it wrong! Try #{$lich_char}#{script.name} help"
  end
elsif script.vars[1] == 'setup'
  unless defined?(Gtk)
    echo '-- the setup UI requires Gtk'
    exit
  end
  if Gtk::Version::MAJOR < 3
    echo '-- slootbeta UI requires Gtk3; this is not yet available but coming soon to a Lich near you'
    # https://bit.ly/WinLich64 to upgrade (warning, this is a beta installer!)
    exit
  end
  SLootSetup.new(script, CharSetting.to_hash).start
  $sloot = nil
elsif script.vars[1] == 'sell'
  room = Room.current.id
  $sloot.sell
  $sloot.go2(room)
  $sloot.cleanup
elsif script.vars[1] == 'bounty'
  $sloot.sell_bounty
elsif script.vars[1] == 'stats'
  CharSetting[:stats].each { |stat, data| echo "-- #{stat}: #{data.inspect}" }
elsif script.vars[1] == 'load'
  echo '-- loaded'
elsif script.vars[1] == 'update'
  Script.run('repository', 'download slootbeta')
  echo '-- updated'
  $sloot = nil
elsif script.vars[1] == 'left' || script.vars[1] == 'right'
  obj = script.vars[1] == 'right' ? GameObj.right_hand : GameObj.left_hand
  obj.type == 'box' ? $sloot.loot_box(obj) : $sloot.stow_it(obj)
elsif script.vars[1] == 'locksmith'
  $sloot.sell_locksmith_pool($sloot.find_boxes)
elsif script.vars[1] == 'list'
  if script.vars[2] !~ /^(?:all|hoard|loot|sell|skin)$/i
    echo "usage: #{$lich_char}#{script.name} list <all|hoard|loot|sell|skin>"
    exit
  end
  SLootSetup.new(script, CharSetting.to_hash).list(script.vars[2])
elsif script.vars[0] =~ /^([^\s]+)(.*)?$/
  SLootSetup
    .new(script, CharSettings.to_hash)
    .update_setting(Regexp.last_match(1).downcase.to_sym, Regexp.last_match(2).strip.downcase)
  $sloot = nil
else
  echo "** You're doing it wrong! Try #{$lich_char}#{script.name} help"
end
