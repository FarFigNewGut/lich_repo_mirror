=begin

https://discord.com/channels/226045346399256576/1284700864132546602

Script created with Chat GPT.

This script is meant to help roleplayers find the right :TONE or =VERB for speech.

To search:
;speechfinder b WORD (Will search VERBS or TONES for exact, closest, or best match)
;speechfinder v WORD (Will search only VERBS for exact, closest, or best match)
;speechfinder t WORD (Will search only TONES for exact, closest, or best match)

1.0.0 (2024-09-14)
    - Initial release.
1.1.0 (2024-09-15)
    - Tones have been added and can be searched via the command ;send tfind TONE
    - Output has been limited to the top 5 most relevant speech tones or speech verbs.
    - Changed script from a loop-based structure to an execution-based structure.
    - Added b variable option to search both verbs and tones at the same time.
1.2.0 (2024-09-22)
    - Introduced relevance-based scoring for matching results.
    - Matches in verb/tone names are given higher weight.
    - Matches in definitions are given medium weight.
    - Matches in categories are given the lowest weight.
    - Limited output to the top 5 most relevant matches, sorted by relevance score.

=end

require 'yaml'

# Define paths for compiled data
DATA_DIR = "#{$data_dir}#{XMLData.game}/#{Char.name}/"
COMPILED_VERBS_PATH = "#{DATA_DIR}compiled_verbs.yaml"
COMPILED_TONES_PATH = "#{DATA_DIR}compiled_tones.yaml"
SPEECHTONESANDVERBS_PATH = "#{$script_dir}/speechtonesandverbs.rb"
METADATA_PATH = "#{DATA_DIR}compiled_speech_metadata.yaml"

# Ensure directories exist
Dir.mkdir("#{$data_dir}#{XMLData.game}") unless Dir.exist?("#{$data_dir}#{XMLData.game}")
Dir.mkdir(DATA_DIR) unless Dir.exist?(DATA_DIR)

# Function to notify player to download the speechtonesandverbs.rb file if missing
def notify_player_to_download
  unless File.exist?(SPEECHTONESANDVERBS_PATH)
    message = "\n\n\n" \
              "************************************************************\n" \
              "*                                                          *\n" \
              "*   speechtonesandverbs.rb is missing.                    *\n" \
              "*                                                          *\n" \
              "*   Please download it using the command:                 *\n" \
              "*                                                          *\n" \
              "*     ;repo download speechtonesandverbs.rb               *\n" \
              "*                                                          *\n" \
              "*   in your game console to ensure the script functions   *\n" \
              "*   correctly.                                            *\n" \
              "*                                                          *\n" \
              "************************************************************\n" \
              "\n\n\n"
    echo(message)
    exit
  end
end

# Ensure speechtonesandverbs.rb is present before proceeding
notify_player_to_download

# Function to get the current file size of speechtonesandverbs.rb
def current_file_size
  File.size(SPEECHTONESANDVERBS_PATH)
end

# Load or compile VERBS_DB and TONES_DB with metadata check
def load_or_compile_data(force_recompile = false)
  metadata = {}

  if File.exist?(METADATA_PATH)
    metadata = YAML.load_file(METADATA_PATH) || {}
  end

  last_compiled_size = metadata['file_size']
  current_size = current_file_size

  if force_recompile || !File.exist?(COMPILED_VERBS_PATH) || !File.exist?(COMPILED_TONES_PATH) || last_compiled_size != current_size
    echo("Compiling data from speechtonesandverbs.rb...")

    begin
      load SPEECHTONESANDVERBS_PATH
    rescue LoadError => e
      echo("Error loading speechtonesandverbs.rb: #{e.message}")
      return {}
    rescue StandardError => e
      echo("Error during loading speechtonesandverbs.rb: #{e.message}")
      return {}
    end

    unless defined?(VERBS_DB) && defined?(TONES_DB)
      echo("Error: VERBS_DB or TONES_DB constant is not defined in speechtonesandverbs.rb. Check that they are defined correctly and accessible.")
      return {}
    end

    # Save compiled data to YAML files
    File.open(COMPILED_VERBS_PATH, 'w') { |file| file.write(VERBS_DB.to_yaml) }
    File.open(COMPILED_TONES_PATH, 'w') { |file| file.write(TONES_DB.to_yaml) }
    # Save metadata
    File.open(METADATA_PATH, 'w') { |file| file.write({ 'file_size' => current_size }.to_yaml) }

    echo("Compiled data saved to YAML files.")
    echo("Note: If speechfinder compiles a new YAML, please run the search again for the term you were searching for.")
  end

  # Load compiled data
  verbs_data = YAML.load_file(COMPILED_VERBS_PATH)
  tones_data = YAML.load_file(COMPILED_TONES_PATH)

  [verbs_data, tones_data]
end

# Load VERBS_DB and TONES_DB initially
VERBS_DB, TONES_DB = load_or_compile_data

# Levenshtein distance function for fuzzy matching
def levenshtein_distance(str1, str2)
  s1, s2 = str1.downcase, str2.downcase
  matrix = [(0..s1.length).to_a]
  (1..s2.length).each { |j| matrix << [j] + [0] * (s1.length) }

  (1..s2.length).each do |i|
    (1..s1.length).each do |j|
      if s2[i - 1] == s1[j - 1]
        matrix[i][j] = matrix[i - 1][j - 1]
      else
        matrix[i][j] = [matrix[i - 1][j], matrix[i][j - 1], matrix[i - 1][j - 1]].min + 1
      end
    end
  end
  matrix.last.last
end

# Function to find and display verbs/tones by terms
def find_speech_by_terms(terms, verbs_db, tones_db)
  minimum_term_length = 3
  terms = terms.map(&:downcase).map(&:strip).select { |term| term.length >= minimum_term_length }

  # Use a hash to avoid duplicate names (verbs/tones), combining categories
  matching_items = {}

  echo("Searching for terms '#{terms.join(' ')}' across name, definition, and category...") if $debug_mode

  # Search in VERBS_DB
  search_db(terms, verbs_db, :verbs, matching_items)
  
  # Search in TONES_DB
  search_db(terms, tones_db, :tones, matching_items)

  # Sort the matched items by relevance score in descending order (most relevant first)
  sorted_matching_items = matching_items.values.sort_by { |item| item[:score] }

  # Call the display function with the sorted items and total count
  display_speech_matches(sorted_matching_items, sorted_matching_items.size)
end

# Helper function to search in a specific database (verbs or tones)
def search_db(terms, database, source, matching_items)
  # Iterate through the items in the database
  database.each do |category, items|
    items.each do |name, definition|
      # Track how many terms match in each field (name, definition, or category)
      relevance_score = 0

      # Define a regex pattern to match words that start with the search term
      terms_regex = terms.map { |term| /\b#{Regexp.escape(term)}\w*/i }

      # Check how many terms match in each field
      name_match_count = terms_regex.count { |term| name.downcase.match?(term) }
      description_match_count = terms_regex.count { |term| definition.downcase.match?(term) }
      category_match_count = terms_regex.count { |term| category.to_s.downcase.match?(term) }

      # Assign scores for matches (heavier weight to name and description)
      if name_match_count > 0
        relevance_score += name_match_count * 30  # Highest score for name match
      end
      if description_match_count > 0
        relevance_score += description_match_count * 6  # Medium score for definition match
      end
      if category_match_count > 0
        relevance_score += category_match_count * 5  # Lowest score for category match
      end

      # If any field matches, add or update the item in the matching list with its relevance score
      if relevance_score > 6
        if matching_items.key?(name)
          # If the item already exists, merge the categories and update the score
          matching_items[name][:categories] << category unless matching_items[name][:categories].include?(category)
          matching_items[name][:score] += relevance_score
        else
          # Create a new entry if the item doesn't exist
          matching_items[name] = {
            name: name,
            definition: definition,
            categories: [category],
            score: relevance_score,
            source: source
          }
        end
      end
    end
  end
end

# Function to display matched speech entries
def display_speech_matches(matching_items, total_matches)
  if matching_items.empty?
    echo("No matching speech items found.")
  else
    # Limit to the last 5 most relevant items after sorting
    limited_items = matching_items.last(5)

    # Display the total number of matches and the cutoff message if applicable
    echo("Showing #{limited_items.size} of #{total_matches} total matching speech items:")

    # Display sorted matches
    limited_items.each do |item|
      # Determine prefix based on source (verbs or tones)
      prefix = item[:source] == :verbs ? '=' : ':'
      echo("\n     #{prefix}#{item[:name]}")
      echo("          (Category: #{item[:categories].join(' | ')})")
      echo("          Definition: #{item[:definition]}")
    end

    # Display a cutoff message if there are more than 5 items
    if total_matches > 5
      echo("\nDisplaying the top 5 most relevant results. There are #{total_matches - 5} more matching items.")
    end
  end
end

# Main function to run the speechfinder
def run_speechfinder(script)
  terms = script.vars
  echo "Using terms: '#{terms.join(' ')}'" if $debug_mode

  if terms.nil? || terms.empty?
    echo("Usage: ;speechfinder TERM (e.g., ;speechfinder happy)")
    return
  end

  # Load the data for verbs and tones
  verbs_db, tones_db = VERBS_DB, TONES_DB

  # Handle the search with the parsed input
  find_speech_by_terms(terms, verbs_db, tones_db)
end

run_speechfinder(script)

