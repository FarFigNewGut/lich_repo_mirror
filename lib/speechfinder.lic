=begin
This script is meant to help roleplayers find the right :TONE or =VERB for speech.

To search:
;speechfinder v VERB
;speechfinder t TONE

Example of output.
>;speechfinder v enthus
--- Lich: speechfinder active.
[speechfinder: Debug: script.vars = ["v enthus", "v", "enthus"]]
[speechfinder: Matching items for 'enthus':]
[speechfinder: 
     holler
          (Category: Sound)
          give a loud shout or cry, often in a commanding or enthusiastic way.]
[speechfinder: 
     effuse
          (Category: Happy/Amused) | (Category: Excited/Interested)
          talk in an unrestrained, excited manner; express enthusiasm or gratitude abundantly.]
[speechfinder: 
     enthuse
          (Category: Happy/Amused) | (Category: Excited/Interested)
          express eager enjoyment, interest, or approval; show or feel excitement.]
[speechfinder: 
     gush
          (Category: Happy/Amused) | (Category: Excited/Interested)
          speak or write effusively or with exaggerated enthusiasm; pour out emotions freely.]
[speechfinder: 
     hail
          (Category: Happy/Amused) | (Category: Excited/Interested) | (Category: Militaristic)
          praise enthusiastically; greet or acclaim loudly.]
--- Lich: speechfinder has exited.	  

Script created with Chat GPT.

1.0.0 (2024-09-14)
    - Initial release.
1.1.0 (2024-09-15)
    - Tones have been added and can be searched via the command ;send tfind TONE
    - Output has been limited to 5 speech tones or 5 speech verbs to limit screen scoll.
    - Changed script from a loop-based structure to an execution-based structure.

Visit https://discord.com/channels/226045346399256576/1284700864132546602 to discuss and offer feedback.

=end

# speechfinder.rb
require 'yaml'

# Define paths for compiled data
DATA_DIR = "#{$data_dir}#{XMLData.game}/#{Char.name}/"
COMPILED_VERBS_PATH = "#{DATA_DIR}compiled_verbs.yaml"
COMPILED_TONES_PATH = "#{DATA_DIR}compiled_tones.yaml"
GLOBAL_CONSTANTS_PATH = "#{$script_dir}/speechtonesandverbs.rb"

# Ensure directories exist
Dir.mkdir("#{$data_dir}#{XMLData.game}") unless Dir.exist?("#{$data_dir}#{XMLData.game}")
Dir.mkdir(DATA_DIR) unless Dir.exist?(DATA_DIR)

# Load or compile VERBS_DB and TONES_DB
def load_or_compile_data
  unless File.exist?(COMPILED_VERBS_PATH) && File.exist?(COMPILED_TONES_PATH)
    echo("Compiling data from speechtonesandverbs.rb...")
    load GLOBAL_CONSTANTS_PATH

    # Save compiled data to YAML files
    File.open(COMPILED_VERBS_PATH, 'w') { |file| file.write(VERBS_DB.to_yaml) }
    File.open(COMPILED_TONES_PATH, 'w') { |file| file.write(TONES_DB.to_yaml) }

    echo("Compiled data saved to YAML files.")
  end

  # Load compiled data
  verbs_data = YAML.load_file(COMPILED_VERBS_PATH)
  tones_data = YAML.load_file(COMPILED_TONES_PATH)

  [verbs_data, tones_data]
end

VERBS_DB, TONES_DB = load_or_compile_data

# Levenshtein distance function for fuzzy matching
def levenshtein_distance(str1, str2)
  s1, s2 = str1.downcase, str2.downcase
  matrix = [(0..s1.length).to_a]
  (1..s2.length).each { |j| matrix << [j] + [0] * (s1.length) }

  (1..s2.length).each do |i|
    (1..s1.length).each do |j|
      if s2[i - 1] == s1[j - 1]
        matrix[i][j] = matrix[i - 1][j - 1]
      else
        matrix[i][j] = [matrix[i - 1][j], matrix[i][j - 1], matrix[i - 1][j - 1]].min + 1
      end
    end
  end
  matrix.last.last
end

# Function to find and display items by term
def find_items_by_term(term, database)
  term = term.downcase.strip
  matching_items = {}
  closest_matches = {}

  # Search through all categories and items
  database.each do |category, items|
    items.each do |item, definition|
      if item.downcase.include?(term) || definition.downcase.include?(term)
        matching_items[item] ||= { categories: [], definition: definition }
        matching_items[item][:categories] << category unless matching_items[item][:categories].include?(category)
      else
        # Calculate distance for fuzzy matching
        distance = levenshtein_distance(term, item)
        closest_matches[item] = { distance: distance, definition: definition, categories: [category] } if distance <= 3
      end
    end
  end

  display_matches(term, matching_items, closest_matches)
end

# Function to display matched items
def display_matches(term, matching_items, closest_matches)
  if matching_items.empty?
    if closest_matches.empty?
      echo("No matching items found for '#{term}'.")
    else
      closest_match = closest_matches.min_by { |_, data| data[:distance] }
      item, data = closest_match
      categories = data[:categories].map { |cat| "(Category: #{cat})" }.join(" | ")
      echo("No exact match found. Closest match for '#{term}':\n")
      echo("     #{item}\n          #{categories}\n          #{data[:definition]}")
    end
  else
    echo("Matching items for '#{term}':")
    matching_items.each_with_index do |(item, data), index|
      break if index >= 5 # Limit output to 5 results
      categories = data[:categories].map { |cat| "(Category: #{cat})" }.join(" | ")
      echo("\n     #{item}\n          #{categories}\n          #{data[:definition]}")
    end
  end
end

# Main function to handle commands
def handle_command(type, term)
  case type
  when 'v'
    find_items_by_term(term, VERBS_DB)
  when 't'
    find_items_by_term(term, TONES_DB)
  else
    echo("Unknown command: #{type} #{term}. Use ;speechfinder v VERB or ;speechfinder t TONE.")
  end
end

# Main function to run the speechfinder
def run_speechfinder(script)
  # Debugging: Log what is being passed
  echo "Debug: script.vars = #{script.vars.inspect}"
  
  # Ensure correct arguments are being used
  if script.vars.empty?
    echo("Usage: ;speechfinder v VERB or ;speechfinder t TONE")
    return
  end

  # Proper parsing by splitting the first variable manually
  input = script.vars[0].strip
  args = input.split(' ', 2) # Splitting the command and term

  if args.length < 2
    echo("Usage: ;speechfinder v VERB or ;speechfinder t TONE")
    return
  end

  type = args[0].downcase
  term = args[1].strip

  # Ensure that valid inputs are used
  if type.nil? || term.nil? || term.empty?
    echo("Usage: ;speechfinder v VERB or ;speechfinder t TONE")
    return
  end

  # Handle the command with the parsed input
  handle_command(type, term)
end

run_speechfinder(script)





