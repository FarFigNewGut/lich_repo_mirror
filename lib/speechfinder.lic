=begin
This script is meant to help roleplayers find the right :TONE or =VERB for speech.

To search:
;speechfinder b WORD (Will search VERBS or TONES for exact, closest, or best match)
;speechfinder v WORD (Will search only VERBS for exact, closest, or best match)
;speechfinder t WORD (Will search only TONES for exact, closest, or best match)

Script created with Chat GPT.

1.0.0 (2024-09-14)
    - Initial release.
1.1.0 (2024-09-15)
    - Tones have been added and can be searched via the command ;send tfind TONE
    - Output has been limited to the top 5 most relevant speech tones or speech verbs.
    - Changed script from a loop-based structure to an execution-based structure.
    - Added b variable option to search both verbs and tones at the same time.

=end

# speechfinder.rb
require 'yaml'

# Define paths for compiled data
DATA_DIR = "#{$data_dir}#{XMLData.game}/#{Char.name}/"
COMPILED_VERBS_PATH = "#{DATA_DIR}compiled_verbs.yaml"
COMPILED_TONES_PATH = "#{DATA_DIR}compiled_tones.yaml"
GLOBAL_CONSTANTS_PATH = "#{$script_dir}/speechtonesandverbs.rb"

# Ensure directories exist
Dir.mkdir("#{$data_dir}#{XMLData.game}") unless Dir.exist?("#{$data_dir}#{XMLData.game}")
Dir.mkdir(DATA_DIR) unless Dir.exist?(DATA_DIR)

# Load or compile VERBS_DB and TONES_DB
def load_or_compile_data
  unless File.exist?(COMPILED_VERBS_PATH) && File.exist?(COMPILED_TONES_PATH)
    echo("Compiling data from speechtonesandverbs.rb...")
    load GLOBAL_CONSTANTS_PATH

    # Save compiled data to YAML files
    File.open(COMPILED_VERBS_PATH, 'w') { |file| file.write(VERBS_DB.to_yaml) }
    File.open(COMPILED_TONES_PATH, 'w') { |file| file.write(TONES_DB.to_yaml) }

    echo("Compiled data saved to YAML files.")
  end

  # Load compiled data
  verbs_data = YAML.load_file(COMPILED_VERBS_PATH)
  tones_data = YAML.load_file(COMPILED_TONES_PATH)

  [verbs_data, tones_data]
end

VERBS_DB, TONES_DB = load_or_compile_data

# Levenshtein distance function for fuzzy matching
def levenshtein_distance(str1, str2)
  s1, s2 = str1.downcase, str2.downcase
  matrix = [(0..s1.length).to_a]
  (1..s2.length).each { |j| matrix << [j] + [0] * (s1.length) }

  (1..s2.length).each do |i|
    (1..s1.length).each do |j|
      if s2[i - 1] == s1[j - 1]
        matrix[i][j] = matrix[i - 1][j - 1]
      else
        matrix[i][j] = [matrix[i - 1][j], matrix[i][j - 1], matrix[i - 1][j - 1]].min + 1
      end
    end
  end
  matrix.last.last
end

# Function to display matched items with specific prefixes for verbs and tones
def display_matches(term, matching_items, closest_matches, source)
  exact_matches = matching_items.select { |item, data| item.downcase == term } # Find exact matches
  other_matches = matching_items.reject { |item, data| item.downcase == term } # Other matches

  # Sort other matches by relevance (name matches first, then description matches)
  sorted_items = other_matches.sort_by do |item, data|
    name_match = item.downcase.include?(term) ? 0 : 1
    description_match = data[:definition].downcase.include?(term) ? 0 : 1
    [name_match, description_match]
  end

  prefix = source == :verbs ? "=" : ":" # Define prefix based on source
  source_label = source == :verbs ? "=VERBS" : ":TONES" # Define label for display

  # Combine exact and sorted matches and limit to top 5
  top_matches = (exact_matches.to_a + sorted_items.to_a).first(5)

  if top_matches.empty?
    if closest_matches.empty?
      echo("No matching items found for '#{term}'.")
    else
      # Display closest match if no exact or partial matches
      closest_match = closest_matches.min_by { |_, data| data[:distance] }
      item, data = closest_match
      categories = data[:categories].map { |cat| "(Category: #{cat})" }.join(" | ")
      echo("No exact match found. Closest match for '#{term}' #{source_label}:\n")
      echo("\n     #{prefix}#{item}\n          #{categories}\n          #{data[:definition]}")
    end
  else
    echo("Top 5 matches for '#{term}' #{source_label}:")

    # Display the top 5 matches
    top_matches.each do |item, data|
      categories = data[:categories].map { |cat| "(Category: #{cat})" }.join(" | ")
      echo("\n     #{prefix}#{item}\n          #{categories}\n          #{data[:definition]}")
    end
  end
end

# Function to find and display items by term (search both name and definition)
def find_items_by_term(term, database)
  term = term.downcase.strip
  matching_items = {}
  closest_matches = {}

  database.each do |category, items|
    items.each do |item, definition|
      # Check if the term matches item name or definition
      if item.downcase.include?(term) || definition.downcase.include?(term)
        matching_items[item] ||= { categories: [], definition: definition }
        matching_items[item][:categories] << category unless matching_items[item][:categories].include?(category)
      else
        # Calculate distance for fuzzy matching
        distance = levenshtein_distance(term, item)
        closest_matches[item] = { distance: distance, definition: definition, categories: [category] } if distance <= 3
      end
    end
  end

  [matching_items, closest_matches]
end

# Function to handle the combined search across both verbs and tones
def handle_combined_search(term)
  # Search in verbs and tones
  verbs_matches, verbs_closest = find_items_by_term(term, VERBS_DB)
  tones_matches, tones_closest = find_items_by_term(term, TONES_DB)

  # Merge both verb and tone matches
  combined_matches = verbs_matches.merge(tones_matches)

  # Sort the combined matches by relevance and limit to top 5
  sorted_combined_matches = combined_matches.sort_by do |item, data|
    name_match = item.downcase.include?(term) ? 0 : 1
    description_match = data[:definition].downcase.include?(term) ? 0 : 1
    [name_match, description_match]
  end.first(5)

  # Display the combined top 5 matches
  sorted_combined_matches.each do |item, data|
    source = verbs_matches.key?(item) ? :verbs : :tones
    display_matches(term, { item => data }, {}, source)
  end
end

# Function to handle commands based on type and term
def handle_command(type, term)
  case type
  when 'v'
    # Search and display for verbs
    matching_items, closest_matches = find_items_by_term(term, VERBS_DB)
    display_matches(term, matching_items, closest_matches, :verbs)
  when 't'
    # Search and display for tones
    matching_items, closest_matches = find_items_by_term(term, TONES_DB)
    display_matches(term, matching_items, closest_matches, :tones)
  when 'b'
    # Combined search for both verbs and tones
    handle_combined_search(term)
  else
   echo("Unknown command: #{type} #{term}. Use ;speechfinder v VERB or ;speechfinder t TONE.")
  end
end

# Main function to run the speechfinder
def run_speechfinder(script)
  # Parse the type and term from script.vars
  input = script.vars[0]&.split(' ')
  
  if input.nil? || input.length < 2
    echo("Usage: ;speechfinder v VERB or ;speechfinder t TONE or ;speechfinder b TERM")
    return
  end

  type = input[0]
  term = input[1]

  # Handle the command with the parsed input
  handle_command(type, term)
end

run_speechfinder(script)
