=begin

https://discord.com/channels/226045346399256576/1284700864132546602

Script created with Chat GPT.

This script is meant to help roleplayers find the right :TONE or =VERB for speech.

To search:
;speechfinder TERM1 TERM2 TERM3 etc

>;speechfinder love happy
--- Lich: speechfinder active.
[speechfinder: Showing 5 of 251 total matching speech items:]
 
     :blissful]
           (Category: Happy | Excited/Bored)]
          Definition: speaking in an extremely happy, peaceful, or joyful manner; showing contentment.
                                Synonyms: euphoric, joyful, serene.]

     :amorous]
           (Category: Happy | Friendly/Polite | Excited/Bored)]
           Definition: speaking in a loving, romantic, or passionate manner; showing affection or
                                desire. Synonyms: affectionate, loving, passionate.]
 
     :loving]
           (Category: Friendly/Polite)]
           Definition: speaking in a manner that shows affection, care, or deep concern for others.
                                Synonyms: affectionate, caring, tender.]
 
     :lovelorn]
           (Category: Unhappy | Uncomfortable | Baffled/Worried)]
           Definition: speaking in a manner that shows sadness or disappointment due to unrequited
                                love. Synonyms: heartbroken, forlorn, disappointed.]
 
     :happy]
           (Category: Happy)]
           Definition: speaking in a joyful, content, or satisfied manner; showing a positive mood.
                                Synonyms: joyful, content, cheerful.]
 
Displaying the top 5 most relevant results. There are 246 more matching items.]
--- Lich: speechfinder has exited.

1.0.0 (2024-09-14)
    - Initial release.
1.1.0 (2024-09-15)
    - Tones have been added and can be searched via the command ;send tfind TONE
    - Output has been limited to the top 5 most relevant speech tones or speech verbs.
    - Changed script from a loop-based structure to an execution-based structure.
    - Added b variable option to search both verbs and tones at the same time.
1.2.0 (2024-09-22)
    - Introduced relevance-based scoring for matching results.
    - Matches in verb/tone names are given higher weight.
    - Matches in definitions are given medium weight.
    - Matches in categories are given the lowest weight.
    - Limited output to the top 5 most relevant matches, sorted by relevance score.

=end

require 'yaml'

# Define paths for compiled data
DATA_DIR = "#{$data_dir}#{XMLData.game}/#{Char.name}/"
COMPILED_VERBS_PATH = "#{DATA_DIR}compiled_verbs.yaml"
COMPILED_TONES_PATH = "#{DATA_DIR}compiled_tones.yaml"
SPEECHTONESANDVERBS_PATH = "#{$script_dir}/speechtonesandverbs.rb"
METADATA_PATH = "#{DATA_DIR}compiled_speech_metadata.yaml"

# Ensure directories exist
Dir.mkdir("#{$data_dir}#{XMLData.game}") unless Dir.exist?("#{$data_dir}#{XMLData.game}")
Dir.mkdir(DATA_DIR) unless Dir.exist?(DATA_DIR)

# Function to notify player to download the speechtonesandverbs.rb file if missing
def notify_player_to_download
  unless File.exist?(SPEECHTONESANDVERBS_PATH)
    message = "\n\n\n" \
              "************************************************************\n" \
              "*                                                          *\n" \
              "*   speechtonesandverbs.rb is missing.                    *\n" \
              "*                                                          *\n" \
              "*   Please download it using the command:                 *\n" \
              "*                                                          *\n" \
              "*     ;repo download speechtonesandverbs.rb               *\n" \
              "*                                                          *\n" \
              "*   in your game console to ensure the script functions   *\n" \
              "*   correctly.                                            *\n" \
              "*                                                          *\n" \
              "************************************************************\n" \
              "\n\n\n"
    echo(message)
    exit
  end
end

# Ensure speechtonesandverbs.rb is present before proceeding
notify_player_to_download

# Function to get the current file size of speechtonesandverbs.rb
def current_file_size
  File.size(SPEECHTONESANDVERBS_PATH)
end

# Load or compile VERBS_DB and TONES_DB with metadata check
def load_or_compile_data(force_recompile = false)
  metadata = {}

  if File.exist?(METADATA_PATH)
    metadata = YAML.load_file(METADATA_PATH) || {}
  end

  last_compiled_size = metadata['file_size']
  current_size = current_file_size

  if force_recompile || !File.exist?(COMPILED_VERBS_PATH) || !File.exist?(COMPILED_TONES_PATH) || last_compiled_size != current_size
    echo("Compiling data from speechtonesandverbs.rb...")

    begin
      load SPEECHTONESANDVERBS_PATH
    rescue LoadError => e
      echo("Error loading speechtonesandverbs.rb: #{e.message}")
      return {}
    rescue StandardError => e
      echo("Error during loading speechtonesandverbs.rb: #{e.message}")
      return {}
    end

    unless defined?(VERBS_DB) && defined?(TONES_DB)
      echo("Error: VERBS_DB or TONES_DB constant is not defined in speechtonesandverbs.rb. Check that they are defined correctly and accessible.")
      return {}
    end

    # Save compiled data to YAML files
    File.open(COMPILED_VERBS_PATH, 'w') { |file| file.write(VERBS_DB.to_yaml) }
    File.open(COMPILED_TONES_PATH, 'w') { |file| file.write(TONES_DB.to_yaml) }
    # Save metadata
    File.open(METADATA_PATH, 'w') { |file| file.write({ 'file_size' => current_size }.to_yaml) }

    echo("Compiled data saved to YAML files.")
    echo("Note: If speechfinder compiles a new YAML, please run the search again for the term you were searching for.")
  end

  # Load compiled data
  verbs_data = YAML.load_file(COMPILED_VERBS_PATH)
  tones_data = YAML.load_file(COMPILED_TONES_PATH)

  [verbs_data, tones_data]
end

# Load VERBS_DB and TONES_DB initially
VERBS_DB, TONES_DB = load_or_compile_data

# Levenshtein distance function for fuzzy matching
def levenshtein_distance(str1, str2)
  s1, s2 = str1.downcase, str2.downcase
  matrix = [(0..s1.length).to_a]
  (1..s2.length).each { |j| matrix << [j] + [0] * (s1.length) }

  (1..s2.length).each do |i|
    (1..s1.length).each do |j|
      if s2[i - 1] == s1[j - 1]
        matrix[i][j] = matrix[i - 1][j - 1]
      else
        matrix[i][j] = [matrix[i - 1][j], matrix[i][j - 1], matrix[i - 1][j - 1]].min + 1
      end
    end
  end
  matrix.last.last
end

# Helper function to get the word root by removing common suffixes
def get_word_root(word)
  # Only apply suffix stripping to words longer than 4 characters
  return word if word.length <= 3
  
  # Common suffixes in English
  word.gsub(/(e|s|y|es|ness|ing|ed|en|ize|ify|ly|ous|ive|al|ful|less|able|ible|ish|ion|tion|ment|ity|ism|ship|hood|er|est|y|ant|ent|ance|ence|ward|wise)$/, '')
end

# Function to find the longest common substring between two words
def longest_common_substring(str1, str2)
  matrix = Array.new(str1.length + 1) { Array.new(str2.length + 1, 0) }
  max_length = 0

  str1.downcase.chars.each_with_index do |char1, i|
    str2.downcase.chars.each_with_index do |char2, j|
      if char1 == char2
        matrix[i + 1][j + 1] = matrix[i][j] + 1
        max_length = [max_length, matrix[i + 1][j + 1]].max
      end
    end
  end

  max_length
end

# Function to find and display verbs/tones by terms with substring matching
def find_speech_by_terms(terms, verbs_db, tones_db)
  minimum_term_length = 3
  terms = terms.map(&:downcase).map(&:strip).select { |term| term.length >= minimum_term_length }
  
  # Use a hash to avoid duplicate names (verbs/tones), combining categories
  matching_items = {}

  echo("Searching for terms '#{terms.join(' ')}' across name, definition, and category...") if $debug_mode

  # Search in VERBS_DB
  search_db(terms, verbs_db, :verbs, matching_items)
  
  # Search in TONES_DB
  search_db(terms, tones_db, :tones, matching_items)

  # Sort the matched items by relevance score in descending order (most relevant first)
  sorted_matching_items = matching_items.values.sort_by { |item| -item[:score] }  # Sort by highest score

  # Call the display function with the sorted items and total count
  display_speech_matches(sorted_matching_items, sorted_matching_items.size)
end

# Helper function to search in a specific database (verbs or tones)
def search_db(terms, database, source, matching_items)
  # Iterate through the items in the database
  database.each do |category, items|
    items.each do |name, definition|
      # Track how many terms match in each field (name, definition, or category)
      relevance_score = 0
      longest_substring_score = 0

      # Define a regex pattern to match exact words or words at boundaries, avoiding partial matches
      terms_regex = terms.map { |term| /\b#{Regexp.escape(term)}\b/i }
      root_terms_regex = terms.map { |term| /\b#{Regexp.escape(get_word_root(term))}\w*/i }

      # Check how many terms match in each field, including root matches
      exact_match_count = terms.count { |term| name.downcase == term }
      name_match_count = terms_regex.count { |term| name.downcase.match?(term) }
      root_match_count = root_terms_regex.count { |term| name.downcase.match?(term) }

      description_match_count = terms_regex.count { |term| definition.downcase.match?(term) }
      root_desc_match_count = root_terms_regex.count { |term| definition.downcase.match?(term) }
      category_match_count = terms_regex.count { |term| category.to_s.downcase.match?(term) }

      # Apply longest common substring matching for name
      terms.each do |term|
        longest_substring_score += longest_common_substring(term, name) * 2  # Assign weight to the length of substring match
      end

      # Assign scores for matches (heavier weight to exact name and root matches)
      if exact_match_count > 0
        relevance_score += exact_match_count * 300  # Stronger weight for exact name match
      elsif name_match_count > 0
        relevance_score += name_match_count * 90  # Medium score for partial name match
      elsif root_match_count > 0
        relevance_score += root_match_count * 60  # Give root matches even more weight
      end

      # Add the longest substring match score
      relevance_score += longest_substring_score

      # Root matches for description get a medium score
      if root_desc_match_count > 0
        relevance_score += root_desc_match_count * 15  # Root match in definition gets high weight
      end

      # Description matches (not roots) still get a lower score
      if description_match_count > 0
        relevance_score += description_match_count * 10  # Lower weight for exact description match
      end

      if category_match_count > 0
        relevance_score += category_match_count * 5  # Lowest score for category match
      end

      # Add a small penalty for partial matches (like "self-satisfied" when searching for "sad")
      if name.downcase.include?(terms.join('')) && name.downcase != terms.join('')
        relevance_score -= 15
      end

      # If any field matches, add or update the item in the matching list with its relevance score
      if relevance_score > 6
        if matching_items.key?(name)
          # If the item already exists, merge the categories and update the score
          matching_items[name][:categories] << category unless matching_items[name][:categories].include?(category)
          matching_items[name][:score] += relevance_score
        else
          # Create a new entry if the item doesn't exist
          matching_items[name] = {
            name: name,
            definition: definition,
            categories: [category],
            score: relevance_score,
            source: source
          }
        end
      end
    end
  end
end

# Function to display matched speech entries in reverse order (most relevant at the bottom)
def display_speech_matches(matching_items, total_matches)
  if matching_items.empty?
    echo("No matching speech items found.")
  else
    # Sort in ascending order so the most relevant (highest score) is at the bottom
    limited_items = matching_items.sort_by { |item| item[:score] }.reverse.first(5)

    # Display the total number of matches and the cutoff message if applicable
    echo("Showing #{limited_items.size} of #{total_matches} total matching speech items:")

    # Display sorted matches (the most relevant result will be at the bottom)
    limited_items.reverse.each do |item|
      # Determine prefix based on source (verbs or tones)
      prefix = item[:source] == :verbs ? '=' : ':'
      echo("\n     #{prefix}#{item[:name]}")
      echo("          (Category: #{item[:categories].join(' | ')})")

      # Apply the text wrapping and indentation to the definition
      wrapped_definition = wrap_text(item[:definition], '          ', 80)  # 80 chars max per line
      echo("          Definition: #{wrapped_definition}")
    end

    # Display a cutoff message if there are more than 5 items
    if total_matches > 5
      echo("\nDisplaying the top 5 most relevant results. There are #{total_matches - 5} more matching items.")
    end
  end
end

# Main function to run the speechfinder
def run_speechfinder(script)
  terms = script.vars
  echo "Using terms: '#{terms.join(' ')}'" if $debug_mode

  if terms.nil? || terms.empty?
    echo("Usage: ;speechfinder TERM (e.g., ;speechfinder happy)")
    return
  end

  # Load the data for verbs and tones
  verbs_db, tones_db = VERBS_DB, TONES_DB

  # Handle the search with the parsed input
  find_speech_by_terms(terms, verbs_db, tones_db)
end

run_speechfinder(script)

