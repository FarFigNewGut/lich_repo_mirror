=begin
This script is meant to help roleplayers find the right =VERB for speech.
Goal is to add tones as well.

To run:
;speechfinder

To search:
;send vfind TERM
;send tfind TONE

Example of output.
>;send vfind enthus
--- sent: vfind enthus
[verbs: Matching verbs for 'enthus':]
[verbs: 
     holler
          (Category: Sound)
          give a loud shout or cry, often in a commanding or enthusiastic way.]
[verbs: 
     effuse
          (Category: Happy/Amused) | (Category: Excited/Interested)
          talk in an unrestrained, excited manner; express enthusiasm or gratitude abundantly.]
[verbs: 
     enthuse
          (Category: Happy/Amused) | (Category: Excited/Interested)
          express eager enjoyment, interest, or approval; show or feel excitement.]
[verbs: 
     gush
          (Category: Happy/Amused) | (Category: Excited/Interested)
          speak or write effusively or with exaggerated enthusiasm; pour out emotions freely.]
[verbs: 
     hail
          (Category: Happy/Amused) | (Category: Excited/Interested) | (Category: Militaristic)
          praise enthusiastically; greet or acclaim loudly.]
[verbs: 
     rave
          (Category: Confused/Querulous) | (Category: Excited/Interested)
          talk wildly or incoherently, as if one were delirious or insane; express extreme enthusiasm.]

>'=rave This pudding is the best!
You rave, "This pudding is the best!"
		  

Script created with Chat GPT.

1.0.0 (2024-09-14)
    - Initial release.
	- Tones have been added and can be searched via the command ;send tfind TONE
=end

# Define constants for the script directory and global constants file
SCRIPTS_DIR = "#{$script_dir}"  # Lich's script directory
GLOBAL_CONSTANTS_FILENAME = "speechtonesandverbs.rb"
GLOBAL_CONSTANTS_PATH = File.join(SCRIPTS_DIR, GLOBAL_CONSTANTS_FILENAME)

# Function to notify player to download the file if missing
def notify_player_to_download_global_constants
  unless File.exist?(GLOBAL_CONSTANTS_PATH)
    message = "\n\n\n" \
              "************************************************************\n" \
              "*                                                          *\n" \
              "*   #{GLOBAL_CONSTANTS_FILENAME} is missing.              *\n" \
              "*                                                          *\n" \
              "*   Please download it using the command:                 *\n" \
              "*                                                          *\n" \
              "*     ;repo download #{GLOBAL_CONSTANTS_FILENAME}         *\n" \
              "*                                                          *\n" \
              "*   in your game console to ensure the script functions   *\n" \
              "*   correctly.                                            *\n" \
              "*                                                          *\n" \
              "************************************************************\n" \
              "\n\n\n"
    echo(message)
    exit
  end
end

# Ensure the constants file is present before proceeding
notify_player_to_download_global_constants

# Load the global constants
load GLOBAL_CONSTANTS_PATH  # Load the global constants after ensuring the file exists

# Levenshtein distance function for finding the closest match
def levenshtein_distance(str1, str2)
  s1, s2 = str1.downcase, str2.downcase
  matrix = [(0..s1.length).to_a]
  (1..s2.length).each { |j| matrix << [j] + [0] * (s1.length) }

  (1..s2.length).each do |i|
    (1..s1.length).each do |j|
      if s2[i - 1] == s1[j - 1]
        matrix[i][j] = matrix[i - 1][j - 1]
      else
        matrix[i][j] = [matrix[i - 1][j], matrix[i][j - 1], matrix[i - 1][j - 1]].min + 1
      end
    end
  end
  matrix.last.last
end

# Function to check if a definition indicates a lack of enthusiasm
def definition_indicates_lack_of_enthusiasm?(definition)
  negative_keywords = ["lacking, "]
  negative_keywords.any? { |phrase| definition.downcase.include?(phrase) }
end

# Function to search terms in a specified database with filtering options
def find_by_term(term, db, db_name, include_lack_of_enthusiasm)
  term = term.downcase.strip
  matching_items = {}
  closest_matches = {}

  # Iterate through the database
  db.each do |category, items|
    items.each do |item, definition|
      # Check if the result should include/exclude items based on lack of enthusiasm
      lack_of_enthusiasm = definition_indicates_lack_of_enthusiasm?(definition)

      # Filtering based on user input
      if (include_lack_of_enthusiasm == 'y' || (include_lack_of_enthusiasm == 'n' && !lack_of_enthusiasm))
        # Check for direct match or close match using inclusion
        if item.downcase.include?(term) || definition.downcase.include?(term)
          matching_items[item] ||= { categories: [], definition: definition }
          matching_items[item][:categories] << category unless matching_items[item][:categories].include?(category)
        else
          # Calculate the distance for fuzzy matching
          distance = levenshtein_distance(term, item)
          closest_matches[item] = { distance: distance, definition: definition, categories: [category] } if distance <= 3
        end
      end
    end
  end

  # Limiting the output to 5 results
  matching_items = matching_items.first(5).to_h
  closest_matches = closest_matches.first(5).to_h

  # Output results based on matches found
  if matching_items.empty?
    if closest_matches.empty?
      echo("No matching items found for '#{term}' in #{db_name}.")
    else
      closest_match = closest_matches.min_by { |_, data| data[:distance] }
      item, data = closest_match
      categories = data[:categories].map { |cat| "(Category: #{cat})" }.join(" | ")
      echo("No exact match found in #{db_name}. Closest match for '#{term}':\n")
      echo("     #{item}\n          #{categories}\n          #{data[:definition]}")
    end
  else
    echo("Matching items for '#{term}' in #{db_name}:")
    matching_items.each do |item, data|
      categories = data[:categories].map { |cat| "(Category: #{cat})" }.join(" | ")
      echo("\n     #{item}\n          #{categories}\n          #{data[:definition]}")
    end
  end
end

# Function to handle commands sent to the script
def handle_command(command)
  if command =~ /^vfind\s+(\S+)\s*(y|n)?$/i
    term, include_lack_of_enthusiasm = $1.strip, ($2 || 'n').downcase
    find_by_term(term, VERBS_DB, "VERBS_DB", include_lack_of_enthusiasm)
  elsif command =~ /^tfind\s+(\S+)\s*(y|n)?$/i
    term, include_lack_of_enthusiasm = $1.strip, ($2 || 'n').downcase
    find_by_term(term, TONES_DB, "TONES_DB", include_lack_of_enthusiasm)
  else
    echo("Unknown command: #{command}. Use ;send vfind TERM [y|n] or ;send tfind TERM [y|n].")
  end
end

# Main loop to continuously listen for commands
begin
  while true
    command = get.strip
    if command =~ /^(vfind|tfind)\s+/i
      handle_command(command)
    end
    sleep 1.0 # Sleep to reduce CPU demand
  end
rescue Interrupt
  echo("Exiting speechfinder script.")
end





