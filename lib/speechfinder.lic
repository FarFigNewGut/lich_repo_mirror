=begin
This script is meant to help roleplayers find the right :TONE or =VERB for speech.

To search:
;speechfinder b WORD (Will search VERBS or TONES for exact, closest, or best match)
;speechfinder v WORD (Will search only VERBS for exact, closest, or best match)
;speechfinder t WORD (Will search only TONES for exact, closest, or best match)

Example of output.
>;speechfinder b happy
		--- Lich: speechfinder active.
		[speechfinder: Debug: script.vars = ["b happy", "b", "happy"]]
		[speechfinder: Searching both Verbs and Tones for 'happy':]
		[speechfinder: No exact match found. Closest match for 'happy' =VERBS:]
		[speechfinder: 
			 =imply
				  (Category: Soothe/Comment)
				  suggest, hint, or indicate something without stating it directly; involve or entail by implication.]
		[speechfinder: ]
		[speechfinder: Matching items for 'happy' :TONES:]
		[speechfinder: 
			 :happy
				  (Category: Happy)
				  speaking in a joyful, content, or satisfied manner; showing a positive mood.]
		  
>;speechfinder v happy
		--- Lich: speechfinder active.
		[speechfinder: Debug: script.vars = ["v happy", "v", "happy"]]
		[speechfinder: No exact match found. Closest match for 'happy' =VERBS:]
		[speechfinder: 
			 =imply
				  (Category: Soothe/Comment)
				  suggest, hint, or indicate something without stating it directly; involve or entail by implication.]

>;speechfinder t happy
		--- Lich: speechfinder active.
		[speechfinder: Debug: script.vars = ["t happy", "t", "happy"]]
		[speechfinder: Matching items for 'happy' :TONES:]
		[speechfinder: 
			 :happy
				  (Category: Happy)
				  speaking in a joyful, content, or satisfied manner; showing a positive mood.]
  

Script created with Chat GPT.

1.0.0 (2024-09-14)
    - Initial release.
1.1.0 (2024-09-15)
    - Tones have been added and can be searched via the command ;send tfind TONE
    - Output has been limited to 5 speech tones or 5 speech verbs to limit screen scoll.
    - Changed script from a loop-based structure to an execution-based structure.
    - Added b variable option to search both verbs and tones at the same time.
	
Visit https://discord.com/channels/226045346399256576/1284700864132546602 to discuss and offer feedback.

=end

# speechfinder.rb
require 'yaml'

# Define paths for compiled data
DATA_DIR = "#{$data_dir}#{XMLData.game}/#{Char.name}/"
COMPILED_VERBS_PATH = "#{DATA_DIR}compiled_verbs.yaml"
COMPILED_TONES_PATH = "#{DATA_DIR}compiled_tones.yaml"
GLOBAL_CONSTANTS_PATH = "#{$script_dir}/speechtonesandverbs.rb"

# Ensure directories exist
Dir.mkdir("#{$data_dir}#{XMLData.game}") unless Dir.exist?("#{$data_dir}#{XMLData.game}")
Dir.mkdir(DATA_DIR) unless Dir.exist?(DATA_DIR)

# Load or compile VERBS_DB and TONES_DB
def load_or_compile_data
  unless File.exist?(COMPILED_VERBS_PATH) && File.exist?(COMPILED_TONES_PATH)
    echo("Compiling data from speechtonesandverbs.rb...")
    load GLOBAL_CONSTANTS_PATH

    # Save compiled data to YAML files
    File.open(COMPILED_VERBS_PATH, 'w') { |file| file.write(VERBS_DB.to_yaml) }
    File.open(COMPILED_TONES_PATH, 'w') { |file| file.write(TONES_DB.to_yaml) }

    echo("Compiled data saved to YAML files.")
  end

  # Load compiled data
  verbs_data = YAML.load_file(COMPILED_VERBS_PATH)
  tones_data = YAML.load_file(COMPILED_TONES_PATH)

  [verbs_data, tones_data]
end

VERBS_DB, TONES_DB = load_or_compile_data

# Levenshtein distance function for fuzzy matching
def levenshtein_distance(str1, str2)
  s1, s2 = str1.downcase, str2.downcase
  matrix = [(0..s1.length).to_a]
  (1..s2.length).each { |j| matrix << [j] + [0] * (s1.length) }

  (1..s2.length).each do |i|
    (1..s1.length).each do |j|
      if s2[i - 1] == s1[j - 1]
        matrix[i][j] = matrix[i - 1][j - 1]
      else
        matrix[i][j] = [matrix[i - 1][j], matrix[i][j - 1], matrix[i - 1][j - 1]].min + 1
      end
    end
  end
  matrix.last.last
end

# Function to display matched items with specific prefixes for verbs and tones
def display_matches(term, matching_items, closest_matches, source)
  prefix = source == :verbs ? "=" : ":" # Define prefix based on source
  exact_matches = matching_items.select { |item, _| item.downcase == term } # Find exact matches
  other_matches = matching_items.reject { |item, _| item.downcase == term } # Other matches

  if matching_items.empty?
    if closest_matches.empty?
      echo("No matching items found for '#{term}'.")
    else
      closest_match = closest_matches.min_by { |_, data| data[:distance] }
      item, data = closest_match
      categories = data[:categories].map { |cat| "(Category: #{cat})" }.join(" | ")
      source_label = source == :verbs ? "=VERBS" : ":TONES"
      echo("No exact match found. Closest match for '#{term}' #{source_label}:\n")
      echo("\n     #{prefix}#{item}\n          #{categories}\n          #{data[:definition]}")
    end
  else
    source_label = source == :verbs ? "=VERBS" : ":TONES"
    echo("Matching items for '#{term}' #{source_label}:")

    # Display exact matches first
    exact_matches.each_with_index do |(item, data), index|
      categories = data[:categories].map { |cat| "(Category: #{cat})" }.join(" | ")
      echo("\n     #{prefix}#{item}\n          #{categories}\n          #{data[:definition]}")
    end

    # Display other matches, limited to 5 results including exact matches
    other_matches.each_with_index do |(item, data), index|
      break if index >= 5 - exact_matches.size # Limit output to 5 results total
      categories = data[:categories].map { |cat| "(Category: #{cat})" }.join(" | ")
      echo("\n     #{prefix}#{item}\n          #{categories}\n          #{data[:definition]}")
    end
  end
end


# Function to find and display items by term with source specification
def find_items_by_term(term, database, source)
  term = term.downcase.strip
  matching_items = {}
  closest_matches = {}

  # Search through all categories and items
  database.each do |category, items|
    items.each do |item, definition|
      if item.downcase.include?(term) || definition.downcase.include?(term)
        matching_items[item] ||= { categories: [], definition: definition }
        matching_items[item][:categories] << category unless matching_items[item][:categories].include?(category)
      else
        # Calculate distance for fuzzy matching
        distance = levenshtein_distance(term, item)
        closest_matches[item] = { distance: distance, definition: definition, categories: [category] } if distance <= 3
      end
    end
  end

  display_matches(term, matching_items, closest_matches, source)
end

# Main function to handle commands with updated display formatting
def handle_command(type, term)
  case type
  when 'v'
    find_items_by_term(term, VERBS_DB, :verbs)
  when 't'
    find_items_by_term(term, TONES_DB, :tones)
  when 'b'
    echo("Searching both Verbs and Tones for '#{term}':\n")
    find_items_by_term(term, VERBS_DB, :verbs)
    echo("\n") # Separate the outputs visually for clarity
    find_items_by_term(term, TONES_DB, :tones)
  else
    echo("Unknown command: #{type} #{term}. Use ;speechfinder v VERB, ;speechfinder t TONE, or ;speechfinder b BOTH.")
  end
end

# Main function to run the speechfinder
def run_speechfinder(script)
  # Debugging: Log what is being passed
  echo "Debug: script.vars = #{script.vars.inspect}"
  
  # Ensure correct arguments are being used
  if script.vars.empty?
    echo("Usage: ;speechfinder v VERB or ;speechfinder t TONE")
    return
  end

  # Proper parsing by splitting the first variable manually
  input = script.vars[0].strip
  args = input.split(' ', 2) # Splitting the command and term

  if args.length < 2
    echo("Usage: ;speechfinder v VERB or ;speechfinder t TONE")
    return
  end

  type = args[0].downcase
  term = args[1].strip

  # Ensure that valid inputs are used
  if type.nil? || term.nil? || term.empty?
    echo("Usage: ;speechfinder v VERB or ;speechfinder t TONE")
    return
  end

  # Handle the command with the parsed input
  handle_command(type, term)
end

run_speechfinder(script)





