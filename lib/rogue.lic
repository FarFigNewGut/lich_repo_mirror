=begin

	Automates many rogue guild tasks. Currently automates all solo sweep, gambit, cheap shot and subdue tasks. Can also automate critter sweep tasks.

	Must do ;rogue setup and fill out the settings before running this script.

	Type ;rogue for usage.

	Type ;rogue sweep to automate solo sweep tasks. ;rogue sweep <partnername> for partner tasks.
	Type ;rogue gam to automate solo gambit tasks. ;rogue gam <partnername> for partner tasks.
	Type ;rogue cheap to automate solo cheap shot tasks. ;rogue cheap <partnername> for partner tasks.
	Type ;rogue sub to automate solo subdue tasks.
	Type ;rogue lmas to do lockmastery tasks. Doesn't do all lockmastery tasks.
	Type ;rogue stun to do stun maneuvers tasks. Currently only does sweep courtyard and clean windows tasks.
	Typing ;rogue <sweep, gam, sub or lmas> will also turn in completed tasks to the NPC.
	Type ;rogue cal to calibrate your calipers.
	Type ;rogue wedge <number> to create specified number of wedges.
	To help another person with their task type ;rogue <sweep, cheap> help
	Note: do not type GLD while script is running, it could make the script stop working.

	Remember afk scripting is a no no in prime/platnium so pay attention to your game screen while running this script.
	Kill this script if going afk.

	########################################################
	Ways to contact me:
	In game: Dreaven
	Player's Corner: Tgo01
	Discord: Dreaven#6436
	Email: LordDreaven@gmail.com
	If you like my scripts feel free to send me a tip via Paypal at: LordDreaven@gmail.com
	########################################################
	
	Author: Dreaven
	Version: 48

=end

if Gem.loaded_specs["gtk3"]
	gtk_version = 3
else
	gtk_version = 2
end

wander_rooms = Array.new
weapon = UserVars.rogue["task_weapon"]
stow_container = UserVars.rogue["stow_container"]
wedge_container = UserVars.rogue["wedge_container"]
calipers_container = UserVars.rogue["calipers_container"]
lockpick_container = UserVars.rogue["lockpick_container"]
mainweapon = UserVars.rogue["mainweapon"]
shield = UserVars.rogue["shield"]
auto_promote = UserVars.rogue["auto_promote"]
update_partner = UserVars.rogue["update_partner"]
lock_create_number = UserVars.rogue["lock_create_number"]
auto_run_after_partner_reps = UserVars.rogue["auto_run_after_partner_reps"]
do_other_guild_tasks = UserVars.rogue["do_other_guild_tasks"]
lmas_lockpick = UserVars.rogue["lmas_lockpick"]
do_critter_sweep_tasks = UserVars.rogue["do_critter_sweep_tasks"]
$stealth_get_item = UserVars.rogue["stealth_get_item"]
$stealth_get_item_container = UserVars.rogue["stealth_get_item_container"]
gam = UserVars.rogue["gambit"]
flee_from_critters = /#{UserVars.rogue["flee_from_critters"]}/i
valid_critter_targets = /#{UserVars.rogue["valid_critter_targets"]}/i
flee_from_critters_count = UserVars.rogue["flee_from_critters_count"].to_i
critter_task_rooms = "#{UserVars.rogue["critter_task_rooms"]}".split(",")
partner_room_number = UserVars.rogue["partner_room_number"]
lich_message_partner = UserVars.rogue["lich_message_partner"]
numberoflockpicks = nil
current_window_rooms = nil
get_item_trick = nil
hide_before_trick = nil
CharSettings['setup_has_been_run'] = nil unless CharSettings['setup_has_been_run']

setup = proc{
	CharSettings['setup_has_been_run'] = true
	Gtk.queue {
		$AAA_WINDOW = Gtk::Window.new
		$AAA_WINDOW.title = "rogue"
		$AAA_WINDOW.set_border_width(10)
		
		#GTK2 and GTK3 nonsense:
		if gtk_version == 2
			$AAA_BOX = Gtk::VBox.new(false)
			$AAA_BOX.set_border_width(5)

			$AAA_VERTICAL_BOX1 = Gtk::VBox.new(false, 0)
			$AAA_VERTICAL_BOX2 = Gtk::VBox.new(false, 0)
			$AAA_VERTICAL_BOX3 = Gtk::VBox.new(false, 0)
			$AAA_VERTICAL_BOX4 = Gtk::VBox.new(false, 0)
			$AAA_VERTICAL_BOX5 = Gtk::VBox.new(false, 0)
		else
			$AAA_BOX = Gtk::Box.new(:vertical)
			$AAA_BOX.set_border_width(5)

			$AAA_VERTICAL_BOX1 = Gtk::Box.new(:vertical, 0)
			$AAA_VERTICAL_BOX2 = Gtk::Box.new(:vertical, 0)
			$AAA_VERTICAL_BOX3 = Gtk::Box.new(:vertical, 0)
			$AAA_VERTICAL_BOX4 = Gtk::Box.new(:vertical, 0)
			$AAA_VERTICAL_BOX5 = Gtk::Box.new(:vertical, 0)
		end
		#####

		$AAA_WINDOW.add($AAA_BOX)
		$AAA_NOTEBOOK = Gtk::Notebook.new
		$AAA_NOTEBOOK.set_show_border(true)
		$AAA_BOX.add($AAA_NOTEBOOK)
		$AAA_NOTEBOOK.append_page($AAA_VERTICAL_BOX1, Gtk::Label.new('Info'))
		$AAA_NOTEBOOK.append_page($AAA_VERTICAL_BOX2, Gtk::Label.new('More Info'))
		$AAA_NOTEBOOK.append_page($AAA_VERTICAL_BOX3, Gtk::Label.new('Gambits'))
		$AAA_NOTEBOOK.append_page($AAA_VERTICAL_BOX4, Gtk::Label.new('Sweep'))
		$AAA_NOTEBOOK.append_page($AAA_VERTICAL_BOX5, Gtk::Label.new('Partner Info'))
		$AAA_ENTRY = Hash.new 
		$AAA_TABLE_SIZE = Hash.new
	}

	Gtk.queue {
		$AAA_TABLE1 = Gtk::Table.new(6, 3, false)
		$AAA_TABLE1.row_spacings=3
		$AAA_TABLE1.column_spacings=3
		$AAA_VERTICAL_BOX1.pack_start($AAA_TABLE1, false, false, 0)

		$AAA_TABLE2 = Gtk::Table.new(6, 3, false)
		$AAA_TABLE2.row_spacings=3
		$AAA_TABLE2.column_spacings=3
		$AAA_VERTICAL_BOX2.pack_start($AAA_TABLE2, false, false, 0)

		$AAA_TABLE3 = Gtk::Table.new(6, 3, false)
		$AAA_TABLE3.row_spacings=3
		$AAA_TABLE3.column_spacings=3
		$AAA_VERTICAL_BOX3.pack_start($AAA_TABLE3, false, false, 0)

		$AAA_TABLE4 = Gtk::Table.new(6, 3, false)
		$AAA_TABLE4.row_spacings=3
		$AAA_TABLE4.column_spacings=3
		$AAA_VERTICAL_BOX4.pack_start($AAA_TABLE4, false, false, 0)

		$AAA_TABLE5 = Gtk::Table.new(6, 3, false)
		$AAA_TABLE5.row_spacings=3
		$AAA_TABLE5.column_spacings=3
		$AAA_VERTICAL_BOX5.pack_start($AAA_TABLE5, false, false, 0)
	}

	def self.add_label_entry(table, label, variable)
		size = $AAA_TABLE_SIZE[table] || 0

		label = Gtk::Label.new(label)
		align = Gtk::Alignment.new 1, 0, 0, 0
		align.set_padding(4, 0, 3, 4)
		align.add(label)
		table.attach(align, 0, 1, size, size + 1)

		entry = Gtk::Entry.new
		entry.text = UserVars.rogue[variable].to_s
		entry.set_width_request(157)
		table.attach(entry, 1, 2, size, size + 1)

		$AAA_ENTRY[variable] = entry
		$AAA_TABLE_SIZE[table] += 1
	end

	Gtk.queue {
		$AAA_ENTRY = Hash.new
		add_label_entry($AAA_TABLE1, "Task weapon:", 'task_weapon')
		add_label_entry($AAA_TABLE1, "Stow container:", 'stow_container')
		add_label_entry($AAA_TABLE1, "Wedge container:", 'wedge_container')
		add_label_entry($AAA_TABLE1, "Calipers container:", 'calipers_container')
		add_label_entry($AAA_TABLE1, "Lockpick container:", 'lockpick_container')
		add_label_entry($AAA_TABLE1, "Main weapon:", 'mainweapon')
		add_label_entry($AAA_TABLE1, "Shield/offhand:", 'shield')
		add_label_entry($AAA_TABLE2, "Auto promote:", 'auto_promote')
		add_label_entry($AAA_TABLE2, "Update partner:", 'update_partner')
		add_label_entry($AAA_TABLE2, "Lock create number:", 'lock_create_number')
		add_label_entry($AAA_TABLE2, "Auto run after partner reps:", 'auto_run_after_partner_reps')
		add_label_entry($AAA_TABLE2, "Do other guild tasks:", 'do_other_guild_tasks')
		add_label_entry($AAA_TABLE2, "Lmas lockpick:", 'lmas_lockpick')
		add_label_entry($AAA_TABLE2, "Do critter sweep tasks", 'do_critter_sweep_tasks')
		add_label_entry($AAA_TABLE3, "Stealth get item:", 'stealth_get_item')
		add_label_entry($AAA_TABLE3, "Stealth get item container:", 'stealth_get_item_container')
		add_label_entry($AAA_TABLE3, "Gambit:", 'gambit')
		add_label_entry($AAA_TABLE4, "Flee from critters:", 'flee_from_critters')
		add_label_entry($AAA_TABLE4, "Valid critter targets:", 'valid_critter_targets')
		add_label_entry($AAA_TABLE4, "Flee from critters count:", 'flee_from_critters_count')
		add_label_entry($AAA_TABLE4, "Critter rooms:", 'critter_task_rooms')
		add_label_entry($AAA_TABLE5, "Partner room number:", 'partner_room_number')
		add_label_entry($AAA_TABLE5, "Lich message partner:", 'lich_message_partner')

	}

	def self.add_checkbox(table, x_pos, label, variable, default = false)
		size = $AAA_TABLE_SIZE[table] || 0
		checkbox = Gtk::CheckButton.new label
		value = UserVars.rogue[variable].nil? ? default : UserVars.rogue[variable]
		checkbox.set_active(value)
		table.attach(checkbox, x_pos, x_pos + 1, size, size + 1)
		$AAA_ENTRY[variable] = checkbox
		$AAA_TABLE_SIZE[table] += 1 if x_pos == 1
	end
        
	Gtk.queue {
		$AAA_WINDOW.signal_connect("delete_event") {
			$AAA_SETUP_COMPLETED = true
		}
	}
        
	Gtk.queue {

		label = Gtk::Label.new
		label.set_markup("Enter <b>nil</b> for any setting you don't want to use.\n<b>Task weapon:</b> Name of weapon you use for tasks.\n<b>Stow container:</b>  Container name for where you stow things. Do NOT use same container you keep your lockpicks in, this might end up throwing them away.\n<b>Wedge container:</b>  Name of container where your wedges are stored.\n<b>Calipers container:</b>  Name of container where your calipers are stored.\n<b>Lockpick container:</b>  Name of container where your lockpicks are stored.\n<b>Main weapon:</b>  Name of weapon you use for hunting/DS.\n<b>Shield/offhand:</b>  Name of shield/offhand weapon you use for hunting/DS.")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$AAA_TABLE1.attach(align, 1, 2, 8, 9)

		label = Gtk::Label.new
		label.set_markup("Enter <b>nil</b> for any setting you don't want to use.\n<b>Auto promote:</b>  Enter <b>on</b> to have script automatically receive promotions from NPC guildmaster.\n<b>Update partner:</b>  Enter <b>on</b> to whisper your partner how many reps you have left after each successful rep.\n<b>Lock create number:</b>  Difficulty level of locks to create for non master create lock reps.\n<b>Auto run after partner reps:</b>  Enter <b>yes</b> to automatically turn in partner tasks as soon as they are finished.\n<b>Do other guild tasks:</b>  Enter <b>yes</b> to automatically go to other guilds to finish window and water plants tasks.\n<b>Lmas lockpick:</b>  Name of your best lockpick, for example <b>vaalin lockpick</b>\n<b>Do critter sweep tasks:</b>  Enter <b>yes</b> if you want to do these tasks manually, <b>no</b> if you want the script to turn these tasks in and continue on, <b>auto</b> if you want the script to automatically finish these tasks.")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$AAA_TABLE2.attach(align, 1, 2, 8, 9)

		label = Gtk::Label.new
		label.set_markup("Enter <b>nil</b> for any setting you don't want to use.\n<b>Stealth get item:</b>  Name of item to use during <b>stealth get gambits.</b>  NOTE This item will be dropped on the ground, don't use an item you don't want to lose.\n<b>Stealth get item container:</b>  Container where your <b>stealth get item</b> is stored.\n<b>Gambit:</b>  Enter what you type to do your current gambit; do not include the word 'rgambit' and don't abbreviate any words.\nIf doing the stealth get gambit then the <b>Gambit</b> setting should be: stealth get # $stealth_get_item (without the space between # and $)")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$AAA_TABLE3.attach(align, 1, 2, 8, 9)


		label = Gtk::Label.new
		label.set_markup("Enter <b>nil</b> for any setting you don't want to use.\n<b>These settings are only required if you're having the script automatically do sweep critter tasks.</b>\n<b>Flee from critters:</b>  Name of critters to always flee from. Seperate each name with a |. Example kobold|orc|rolton\n<b>Valid critter targets:</b>  Name of critters to sweep. Same as above for more than one critter.\n<b>Flee from critters count:</b>  Will flee from current room if number of critters is this amount of higher.\n<b>Critter rooms:</b>  List all rooms of area you want to look for critters in; example 1,2,3\nNo spaces after commas.\n")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$AAA_TABLE4.attach(align, 1, 2, 8, 9)

		label = Gtk::Label.new
		label.set_markup("Fill these settings out if you are running with a dedicated partner who is also running the <b>rogue</b> script and is going to help you automate through partner tasks.\nEnter <b>nil</b> for each setting if you are not running with such a partner or if you don't want to use a particular setting.\n<b>Partner room number:</b>  Room number where you and your partner will meet to do partner tasks.\n<b>Lich message partner:</b>  Enter <b>yes</b> to send a lnet message to your partner when you need them for a partner task.\nThe lnet message is just to inform your partner when you need their help in the room you specified for partner tasks, it does not make your partner move or run any scripts even if they are currently running <b>rogue</b> and <b>task</b>.")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$AAA_TABLE5.attach(align, 1, 2, 8, 9)

		$AAA_WINDOW.show_all
	}
        
	$AAA_SETUP_COMPLETED = false
	until($AAA_SETUP_COMPLETED)
		sleep 1
	end
       
	UserVars.rogue ||= Hash.new
	$AAA_ENTRY.keys.each { |key|
		if( $AAA_ENTRY[key].class.to_s =~ /CheckButton/ )
			value = $AAA_ENTRY[key].active?
			UserVars.rogue[key] = $AAA_ENTRY[key].active?
		else
			if(key == 'wounded_eval')
				UserVars.rogue[key] = $AAA_ENTRY[key].text
			else
				UserVars.rogue[key] = $AAA_ENTRY[key].text.strip.downcase
			end
		end
	}
	UserVars.save()
        
	Gtk.queue {
		$AAA_WINDOW.destroy
	}
}

flower = nil
icedirt_rooms = [ '17972', '17966', '17965', '17976' ]
landingdirt_rooms = [ '16517', '16490', '16438', '16492', '16534', '16540' ]
soldirt_rooms = [ '17949', '17948', '17947', '17946', '17942', '17944', '17945' ]
illistim_dirt_rooms = [ '17840', '17876', '17877', '17879', '17878' ]
rrdirt_rooms = [ '17999', '18000', '18005', '18008', '18009', '18007' ]
icewindow_rooms = [ '17975', '17966', '17965', '17976', '17964' ]
landingwindow_rooms = [ '16557', '16555', '16491', '16490', '16517' ]
solwindow_rooms = [ '17950', '17948', '17946', '17944', '17963' ]
illistimwindow_rooms = [ '17871', '17872', '17853', '17860', '17869' ]
rrwindow_rooms = [ '17989', '17999', '18004', '18002', '18001' ]
iceplant_rooms = [ '17974', '17965', '17967', '17976', '17964' ]
landingplant_rooms = [ '16545', '16504', '16438', '16534', '16517' ]
solplant_rooms = [ '17953', '17950', '17946', '17942', '17944' ]
rrplant_rooms = [ '18009', '18006', '18005', '18000', '17999' ]
illistimplant_rooms = [ '17871', '17851', '17855', '17869', '17870' ]
audience_rooms = [ '2300', '228', '188' ]
training_administrator_room = [ '17967', '16504', '17948', '17798', '17883', '18007' ]
toolbenches_room_number = [ '17978', '16574', '17960', '17881', '18004' ]
guild_master_room_number = [ '17975', '16485', '17956', '17886', '17991' ]
training_master_room_number = [ '17965', '16540', '17951', '17419', '17864','18010' ]
sweeping_dummies_room_number = [ '17976', '16509', '17950', '17862','18008' ]
kitchen_room_number = [ '17969', '16433', '17940', '17889', '18001' ]
mannequin_room_number = [ '17965', '16509', '17949', '17861', '18008' ]
tool_rack_room_number = [ '17969', '16581', '17941', '17861', '18003' ]
training_administrator_names = /maliq|teagais|deluca|milgrew|runaire|boucher/i
guild_master_names = /kuidich|dante|lindil|lydon|tafileh/i
master_names = /mubarak|selima|jafar|harith|duchel|palder|meallan|miller|bean|reilly|varant|triaholly|sneck|jimik|herit|lagick|zardak|faldes|gludac|vigil|ritchie|colvin|purkhiser/i
flower_names = /wildflower|iceflower|dandelion|begonia|iris|rose|wisteria/i
(stand_up = nil;stamina_check = nil;my_room = nil;other_players = nil;other_players_disks = nil;wander = nil;auto_critter_sweep_tasks = nil;critter_target = nil;getpick = nil;checkin = nil;person = nil;help_sweep_partner_start = nil;help = nil;help_cheap_partner_start = nil;go_to_task = nil;stow = nil;gam_teach_help_start = nil;gam_learn_help_start = nil;gam_teach_help_start1 = nil;gam_learn_help_start2 = nil;gam_learn_help_start3 = nil;sweepstart = nil;sweep_partner = nil;sweep_defend = nil;sweep_master = nil;sweep_dummies = nil;sweep_dirt = nil;sweep_critters = nil;promotion = nil;partner_room = nil;sweep_partner_start = nil;auto_run = nil;sweep_defend_start = nil;reps = nil;sweep_master_begin = nil;sweep_master_start = nil;promotion = nil;number = nil;sweep_dummy_start = nil;sweep_dirt_move = nil;sweep_dirt_sweep = nil;sweep_dirt_get = nil;sweep_dirt_full = nil;garlic_start = nil;mannequins_start = nil;windows_get_rag = nil;sub_critters = nil;get_garlic = nil;mannequins_subdue = nil;windows_move = nil;windows_clean = nil;go_to_room = nil;lmas_tough_boxes = nil;lmas_trick = nil;keys = nil;lmas_footpad_talk = nil;lmas_footpad_challenge = nil;customize = nil;lmas_footpad_lock_start = nil;lmas_lockpick_start = nil;customize_footpad_pre = nil;customize_create = nil;customize_footpad_create = nil;customize_footpad_finished = nil;customize_footpad_hand_in1 = nil;lmas_footpad_lock_start = nil;lmas_footpad_challenge_begin = nil;lmas_footpad_challenge_begin1 = nil;lmas_footpad_challenge_wait = nil;lmas_footpad_challenge_trap = nil;lmas_footpad_challenge_pick = nil;lmas_footpad_challenge1 = nil;cal = nil;cal_start = nil;carve_go = nil;buy_block = nil;carve_start = nil;carve = nil;carve_rub = nil;lock_pick_create = nil;lockpick_handin = nil;lockpick_handin1 = nil;gam_learn_start = nil;gam_audience_start = nil;gam_speed_start = nil;gam_teach_start = nil;gam_learn_start1 = nil;gam_learn_start2 = nil;gam_audience_start1 = nil;gam_speed_begin = nil;gam_teach_start1 = nil;repair = nil;keys_1 = nil;footstomp_defend = nil;footstomp_partner = nil;cheap_critter = nil;cheap_plants = nil;foot_stomp_defend1 = nil;footstomp_partner_start = nil;cheap_plants_move = nil;cheap_plants_water = nil;cheapstart = nil;substart = nil;lmasstart = nil;gamstart = nil;master = nil;stunstart = nil)
target_room = nil
dirt_rooms = nil
my_partner = nil
talk_to_footpad_masters = nil
current_plant_rooms = nil
turnin = nil

box = ["filler",
	"first box",
	"second box",
	"third box",
	"fourth box",
	"fifth box"
	]

Pick = ["red lockpick", "steel lockpick", "gold lockpick", "silver lockpick", "ora lockpick", "mithril lockpick", "scrimshaw lockpick", "laje lockpick", "vultite lockpick", "rolaren lockpick", "veniom lockpick", "invar lockpick", "alum lockpick", "golvern lockpick", "kelyn lockpick", "vaalin lockpick", "cast"]
$lockpick_number = 0

getpick = proc{
	exit if $lockpick_number >= 16
	multifput "get my #{Pick[$lockpick_number]} from my keyring", "lmas app my lock"
	while line = get
		if line =~ /It appears to be broken/
			wire = 2 if $lockpick_number == 0
			wire = 4 if $lockpick_number == 1
			wire = 5 if $lockpick_number == 2
			wire = 6 if $lockpick_number == 3
			wire = 7 if $lockpick_number == 4
			wire = 8 if $lockpick_number == 5
			wire = 9 if $lockpick_number == 7
			wire = 11 if $lockpick_number == 8
			wire = 12 if $lockpick_number == 9
			wire = 13 if $lockpick_number == 10
			wire = 15 if $lockpick_number == 11
			wire = 10 if $lockpick_number == 12
			wire = 16 if $lockpick_number == 13
			wire = 14 if $lockpick_number == 14
			wire = 17 if $lockpick_number == 15
			multifput "order #{wire}", "buy", "lmas repair my lock"
			waitrt?
			fput "lmas repair my lock"
			waitrt?
			fput "put my lockpick in my keyring"
			$lockpick_number = $lockpick_number + 1
			getpick.call
		elsif line =~ /You could probably handle/
			fput "lmas repair my lock"
			waitrt?
			fput "put my lockpick in my keyring"
			$lockpick_number = $lockpick_number + 1
			getpick.call	
		end
	end
}

stand_up = proc{
	(waitrt?;fput "stand";sleep 0.1) until standing?
}

stamina_check = proc{
	if checkstamina < 12
		echo "Waiting for stamina."
		wait_until{ checkstamina >= 12 }
	end
}

auto_run = proc{
	if auto_run_after_partner_reps == "yes"
		turnin.call
	else
		exit
	end
}

turnin = proc{
	stand_up.call if !standing?
	waitrt?
	move 'out' if checkpaths 'out'
	target_room = Room.current.find_nearest(training_administrator_room)
	start_script 'go2', [ target_room.to_s ]
	wait_while{ running?('go2') }
	GameObj.npcs.find { |npc| person = npc if npc.name =~ training_administrator_names }
	multifput "ask #{person} about train #{script.vars[1]}", "ask #{person} about train #{script.vars[1]}"
	go_to_task.call
}

promotion = proc{
	if auto_promote == "on"
		move 'out' if checkpaths 'out'
		target_room = Room.current.find_nearest(guild_master_room_number)
		start_script 'go2', [ target_room.to_s ]
		wait_while{ running?('go2') }
		GameObj.npcs.find { |npc| person = npc if npc.name =~ guild_master_names }
		fput "ask #{person} about next #{script.vars[1]}"
		target_room = Room.current.find_nearest(training_administrator_room)
		start_script 'go2', [ target_room.to_s ]
		wait_while{ running?('go2') }
		GameObj.npcs.find { |npc| person = npc if npc.name =~ training_administrator_names }
		fput "ask #{person} about train #{script.vars[1]}"
		go_to_task.call
	else
		exit
	end
}

wander = proc{
	sleep 0.1
	room = Room.current
	acceptable_adjacent_rooms = room.wayto.keys & critter_task_rooms
	not_visited_rooms = acceptable_adjacent_rooms.find_all { |r| not wander_rooms.include?(r) }
	if not_visited_rooms.empty?
		next_room = wander_rooms.find { |r| acceptable_adjacent_rooms.include?(r) }
	else
		next_room = not_visited_rooms[rand(not_visited_rooms.length)]
	end
	if next_room
		wander_rooms.delete(next_room)
		wander_rooms.push(next_room)
		way = room.wayto[next_room]
		if way.class == String 
			move(way)
			my_room = nil
			critter_target = nil
			other_players = nil
			other_players_disks = nil
			other_players = checkpcs.each { |pc| i += 1; break if pc == Char.name }
			(wander.call) if other_players != nil
			other_players_disks = GameObj.loot.find { |obj| (obj.noun == 'disk') and (obj.name !~ /#{checkname}/) }
			(wander.call) if other_players_disks != nil
			my_room = Room.current.id
		else
			way.call
			my_room = nil
			critter_target = nil
			other_players = nil
			other_players_disks = nil
			other_players = checkpcs.each { |pc| i += 1; break if pc == Char.name }
			(wander.call) if other_players != nil
			other_players_disks = GameObj.loot.find { |obj| (obj.noun == 'disk') and (obj.name !~ /#{checkname}/) }
			(wander.call) if other_players_disks != nil
			my_room = Room.current.id
		end
	else
		start_script 'go2', [ Room.current.find_nearest(critter_task_rooms.collect { |id| id.to_i }).to_s ]
		wait_while { running?('go2') }
			my_room = nil
			critter_target = nil
			other_players = nil
			other_players_disks = nil
			other_players = checkpcs.each { |pc| i += 1; break if pc == Char.name }
			(wander.call) if other_players != nil
			other_players_disks = GameObj.loot.find { |obj| (obj.noun == 'disk') and (obj.name !~ /#{checkname}/) }
			(wander.call) if other_players_disks != nil
			my_room = Room.current.id
	end
}

partner_room = proc{
	if partner_room_number != "nil"
		LNet.send_message(h={'to'=>"#{my_partner}", 'type'=>'private'}, "I need your help with a guild task.") if lich_message_partner == "yes"
		if Room.current.id != Integer(partner_room_number)
			move 'out' if checkpaths 'out'
			start_script "go2", [partner_room_number]
			wait_while{ running?('go2') }
		end
	end
}

auto_critter_sweep_tasks = proc{
	loop{
		i_should_wander = nil
		task_all_finished = nil
		if !standing?
			until standing?
				waitrt?
				fput "stand"
				sleep 0.5
			end
		end
		if checkstance != "defensive"
			waitrt?
			fput "stance def"
		end
		if checkstamina < 12
			echo "Waiting for stamina."
			wait_until{ checkstamina >= 12 }		
		end
		critter_target = GameObj.npcs.find { |npc| npc.name =~ valid_critter_targets and npc.status !~ /dead|gone|prone|sit|kneel/ } if my_room == Room.current.id
		i_should_wander = true if (GameObj.targets.count > flee_from_critters_count) || (GameObj.targets.find{ |i| i.name =~ flee_from_critters }) || (my_room != Room.current.id) || (critter_target.nil?)
		if i_should_wander
			wander.call
		else
			if critter_target != nil and critter_target.status !~ /dead|gone|prone|sit|kneel/ and my_room == Room.current.id
				fput "stance off"
				result = dothistimeout "sweep #{critter_target}", 3, /You have completed/i
				if result =~ /You have completed/i
					task_all_finished = true
				end
			end
		end
		sleep 0.1
		break if task_all_finished
	}
	turnin.call
}

stow = proc{
	fput "stow left" if checkleft != nil
	fput "stow right" if checkright != nil
}

go_to_task = proc{
	if script.vars[1] == "sweep"
		sweepstart.call
	elsif script.vars[1] == "gam"
		gamstart.call
	elsif script.vars[1] == "cheap"
		cheapstart.call
	elsif script.vars[1] == "lmas"
		lmasstart.call
	elsif script.vars[1] == "sub"
		substart.call
	elsif script.vars[1] == "stun"
		stunstart.call
	end
}

checkin = proc{
	move 'out' if checkpaths 'out'
	target_room = Room.current.find_nearest(guild_master_room_number)
	start_script 'go2', [ target_room.to_s ]
	wait_while{ running?('go2') }
	GameObj.npcs.find { |npc| person = npc if npc.name =~ guild_master_names }
	fput "ask #{person} about checkin"
	exit
}

help_sweep_partner_start = proc{
	stand_up.call if !standing?
	stamina_check.call if checkstamina < 12
	waitrt?
	result = dothistimeout "sweep #{script.vars[3]}", 3, /is already prone|(You might want to stand up first.|Roundtime)/i
	if result =~ /is already prone/i
		fput "pull #{script.vars[3]}"
		help_sweep_partner_start.call
	elsif result =~ /(You might want to stand up first.|Roundtime)/i
		help_sweep_partner_start.call
	elsif result.nil?
		help_sweep_partner_start.call
	end
}

help_cheap_partner_start = proc{
	stand_up.call if !standing?
	stamina_check.call if checkstamina < 12
	waitrt?
	result = dothistimeout "cheap foot #{script.vars[3]}", 2, /just fell for a footstomp not long ago/i
	if result =~ /just fell for a footstomp not long ago/
		sleep 2
		help_cheap_partner_start.call
	elsif result.nil?
		sleep 13
		help_cheap_partner_start.call
	end
}

gam_teach_help_start = proc{
	stow.call
	waitfor "I am ready to learn"
	partner = GameObj.pcs.find { |pc| pc.name =~ /#{script.vars[3]}(.*)/i }
	gam_teach_help_start1.call
}

gam_teach_help_start1 = proc{
	if $task =~ /stealth/i
		if $task =~ /stand/i
			wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{partner}/i and partner.status =~ /kneel/ } }
		else
			wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{partner}/i and partner.status.nil? } }
		end
	end
	waitrt?
	result = dothistimeout "#$task", 5, /You need to have free hands to teach this gambit|You already have that|You should have a silver coin on you to teach this gambit|Wait a few seconds and try again|You need to be holding something first|Who are you trying to teach/i
	if result =~ /You need to have free hands to teach this gambit/i
		stow.call
		gam_teach_help_start1.call
	elsif result =~ /You already have that/i
		fput "stow #{weapon}"
		gam_teach_help_start1.call
	elsif result =~ /You should have a silver coin on you to teach this gambit/i
		fput "whisper #{script.vars[3]} Need a coin, be right back."
		currentroom = Room.current.id
		start_script 'go2', [ 'bank', '--disable-confirm' ]
		wait_while{ running?('go2') }
		fput "withdraw 2 silvers"
		start_script "go2", [ "#{currentroom}" ]
		wait_while{ running?('go2') }
		gam_teach_help_start1.call
	elsif result =~ /Wait a few seconds and try again/i
		sleep 2
		gam_teach_help_start1.call
	elsif result =~ /You need to be holding something first/
		fput "get my #{weapon}"
		gam_teach_help_start1.call
	elsif result =~ /Who are you trying to teach/
		sleep 2
		gam_teach_help_start1.call
	elsif result.nil?
		gam_teach_help_start1.call
	end
}

gam_learn_help_start = proc{
	stow.call
	fput "#$task"
	if $task =~ /stealth/i
		hide_before_trick = "yes"
	end
	if $task =~ /get/i
		get_item_trick = "yes"
	end
	if get_item_trick == "yes"
		multifput "get my #$stealth_get_item from my #$stealth_get_item_container", "drop my #$stealth_get_item"
	end
	until !hiding?
		waitrt?
		fput "unhide"
	end
	if $task =~ /stealth/i
		if $task =~ /stand/i
			until kneeling?
				waitrt?
				fput "kneel"
				sleep 0.1
			end
		else
			until standing?
				waitrt?
				fput "stand"
				sleep 0.1
			end
		end
	end
	waitrt?
	fput "whisper #{script.vars[3]} I am ready to learn"
	gam_learn_help_start2.call
}

gam_learn_help_start2 = proc{
	waitrt?
	until !hiding?
		waitrt?
		fput "unhide"
		sleep 0.1
	end
	if $task =~ /stealth/i
		if $task =~ /stand/i
			until kneeling?
				waitrt?
				fput "kneel"
				sleep 0.1
			end
		else
			until standing?
				waitrt?
				fput "stand"
				sleep 0.1
			end
		end
	end
	waitrt?
	if get_item_trick == "yes"
		waitfor "shows you how to take an item from the ground without giving yourself away"
	elsif hide_before_trick == "yes"
		waitfor "gives you some pointers"
	end
	gam_learn_help_start3.call
}

gam_learn_help_start3 = proc{
	waitrt?
	until !hiding?
		waitrt?
		fput "unhide"
		sleep 0.1
	end
	if $task =~ /stealth/i
		if $task =~ /stand/i
			until kneeling?
				waitrt?
				fput "kneel"
				sleep 0.1
			end
		else
			until standing?
				waitrt?
				fput "stand"
				sleep 0.1
			end
		end
	end
	waitrt?
	if get_item_trick == "yes"
		fput "drop my #$stealth_get_item"
	end
	if hide_before_trick == "yes"
		until hiding?
			waitrt?
			fput "hide"
			sleep 0.1
		end
	end
	waitrt?
	result = dothistimeout "#$task", 5, /You need to be holding something first|You already have that|Just how stealthy are you trying to be|but realize that doing so would reveal your location|suddenly become aware that your actions have revealed your location|Roundtime|You manage to move to|keeping your location hidden|but have revealed yourself from hiding in doing so|but realize that doing so would compromise your hidden position/i
	if result =~ /You need to be holding something first/i
		fput "get my #{weapon}"
		gam_learn_help_start2.call
	elsif result =~ /You already have that/i
		fput "stow #{weapon}"
		gam_learn_help_start2.call
	elsif result =~ /Roundtime|You manage to move to|keeping your location hidden/i
		gam_learn_help_start2.call
	elsif result =~ /Just how stealthy are you trying to be/i
		gam_learn_help_start3.call
	elsif result =~ /suddenly become aware that your actions have revealed your location|but realize that doing so would reveal your location/i
		gam_learn_help_start2.call
	elsif result =~ /but have revealed yourself from hiding in doing so/i
		if get_item_trick == "yes"
			fput "drop my #$stealth_get_item"
			gam_learn_help_start3.call
		end
	elsif result =~ /but realize that doing so would compromise your hidden position/i
		gam_learn_help_start3.call
	elsif result.nil?
		gam_learn_help_start3.call
	end
}

sweepstart = proc{
	stow.call
	fput "gld"
	waitfor "Sweep skill"
	while line = get
		(sweep_partner.call;break) if line =~ /The Training Administrator told you to practice sweeping a partner./i
		(sweep_defend.call;break) if line =~ /The Training Administrator told you to defend against a partner./i
		(sweep_master.call;break) if line =~ /The Training Administrator told you to get some lessons from the footpads./i
		(sweep_dummies.call;break) if line =~ /The Training Administrator told you to work out on the sweep dummies./i
		(sweep_dirt.call;break) if line =~ /The Training Administrator told you to sweep the guild courtyard./i
		(sweep_critters.call;break) if line =~ /The Training Administrator told you to practice sweeping creatures./i
		(promotion.call;break) if line =~ /Congratulations, you've earned a rank|You need to get promoted to your next rank in Sweep|You have earned enough training points for your next rank.|You need \-(\d+) training points? to earn your next rank/i
		(turnin.call;break) if line =~ /You are not currently training in this skill/i
	end
}

stunstart = proc{
	stow.call
	fput "gld"
	waitfor "Stun Maneuvers skill"
	while line = get
		if line =~ /The Training Administrator told you to sweep the guild courtyard\./
			sweep_dirt.call
			break
		elsif line =~ /The Training Administrator told you to clean the windows in the guild\.|The Training Administrator told you to clean the guild windows\./
			windows_get_rag.call
			break
		end
	end
}

sweep_partner = proc{
	fput "gld"
	waitfor "The Training Administrator told you to practice sweeping a partner"
	while line = get
		(turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
		if line =~ /remaining to complete this task|remaining for this task/i	
			multifput "gld stance off", "stance off"
			partner_room.call
			wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{my_partner}(.*)/i } }
			fput "whisper #{my_partner} I need to sweep you."
			waitfor "Ready to be swept"
			sweep_partner_start.call
			break
		end
	end
}

sweep_partner_start = proc{
	stand_up.call if !standing?
	stamina_check.call if checkstamina < 12
	waitrt?
	result = dothistimeout "sweep #{my_partner}", 3, /You have completed your training task.|is already prone|You might want to stand up first.|Sweep what\?|repetition|Roundtime/i
	if result =~ /You have completed your training task./i
		waitrt?
		fput "pull #{my_partner}"
		fput "whisper #{my_partner} All done!"
		auto_run.call
	elsif result =~ /is already prone/i
		waitrt?
		fput "pull #{my_partner}"
		sweep_partner_start.call
	elsif result =~ /You might want to stand up first./i
		stand_up.call
		sweep_partner_start.call
	elsif result =~ /repetition|Roundtime/i
		sweep_partner_start.call
	elsif result =~ /Sweep what\?/i
		exit
	elsif result.nil?
		sweep_partner_start.call
	end
}

sweep_defend = proc{
	fput "gld"
	waitfor "The Training Administrator told you to defend against a partner"
	while line = get
		(turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
		if line =~ /remaining to complete this task|remaining for this task/i
			stand_up.call if !standing?
			waitrt?
			multifput "gld stance def", "stance off"
			partner_room.call
			wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{my_partner}(.*)/i } }
			fput "whisper #{my_partner} I need to be swept."
			sweep_defend_start.call
			break
		end
	end
}

sweep_defend_start = proc{
	while line = get
		if line =~ /You have (.*) repetition/i
			reps = $1
			fput "whisper #{my_partner} #{reps} more." if update_partner == "on"
		elsif line =~ /You have completed your training task/i
			fput "whisper #{my_partner} All done. Thank you!"
			auto_run.call
		end
	end
}

sweep_master = proc{
	fput "gld"
	waitfor "The Training Administrator told you to get some lessons from the footpads"
	while line = get
		(turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
		if line =~ /remaining to complete this task|remaining for this task/i
			waitrt?
			multifput "gld stance off", "stance off"
			move 'out' if checkpaths 'out'
			target_room = Room.current.find_nearest(training_master_room_number)
			start_script 'go2', [ target_room.to_s ]
			wait_while{ running?('go2') }
			GameObj.npcs.find { |npc| master = npc if npc.name =~ master_names }
			sweep_master_begin.call
			break
		end
	end
}

sweep_master_begin = proc{
	fput "ask #{master} about training sweep"
	waitfor "pulls you aside for some instruction."
	waitfor "says"
	sweep_master_start.call
}

sweep_master_start = proc{
	stand_up.call if !standing?
	stamina_check.call if checkstamina < 12
	waitrt?
	result = dothistimeout "sweep #{master}", 3, /You have completed your training task|is already prone|You might want to stand up first.|Roundtime/i
	if result =~ /You have completed your training task/i
		turnin.call
	elsif result =~ /is already prone/i
		waitrt?
		fput "hide" if !hidden?
		waitfor "stands back up"
		sweep_master_start.call
	elsif result =~ /You might want to stand up first./i
		stand_up.call
		sweep_master_start.call
	elsif result =~ /Roundtime/i
		waitrt?
		fput "hide" if !hidden?
		sweep_master_start.call
	elsif result.nil?
		sweep_master_start.call
	end
}

sweep_dummies = proc{
	fput "gld"
	waitfor "The Training Administrator told you to work out on the sweep dummies"
	while line = get
		(turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
		if line =~ /remaining to complete this task|remaining for this task/i
			waitrt?
			move 'out' if checkpaths 'out'
			target_room = Room.current.find_nearest(sweeping_dummies_room_number)
			start_script 'go2', [ target_room.to_s ]
			wait_while{ running?('go2') }
			fput "go dummies"
			sweep_dummy_start.call
			break
		end
	end
}

sweep_dummy_start = proc{
	stand_up.call if !standing?
	stamina_check.call if checkstamina < 12
	waitrt?
	result = dothistimeout "sweep dummy", 3, /You have completed your training task.|The dummy is swinging back and forth.|The dummy has fallen off its post, you'll need to FIX it.|repetition|fail to flip/i
	if result =~ /You have completed your training task./i
		turnin.call
	elsif result =~ /The dummy is swinging back and forth./i
		waitrt?
		fput "touch dummy"
		sweep_dummy_start.call
	elsif result =~ /The dummy has fallen off its post, you'll need to FIX it./i
		waitrt?
		fput "fix dummy"
		sweep_dummy_start.call
	elsif result =~ /repetition|fail to flip/i
		sweep_dummy_start.call
	elsif result.nil?
		sweep_dummy_start.call
	end
}

sweep_dirt = proc{
	fput "gld"
	waitfor "The Training Administrator told you to sweep the guild courtyard"
	while line = get
		(turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
		if line =~ /remaining to complete this task|remaining for this task/i
			number = 0
			target_room = Room.current.find_nearest(tool_rack_room_number)
			start_script 'go2', [ target_room.to_s ]
			wait_while{ running?('go2') }
			if Room.current.id == 17969
				dirt_rooms = icedirt_rooms
			elsif Room.current.id == 16581
				dirt_rooms = landingdirt_rooms
			elsif Room.current.id == 17941
				dirt_rooms = soldirt_rooms
			elsif Room.current.id == 17861
				dirt_rooms = illistim_dirt_rooms
			elsif Room.current.id == 18003
				dirt_rooms = rrdirt_rooms
			
			else
				echo "Error! Stuck in sweep_dirt, try running script again and please inform author of this error."
			end
			fput "put my broom on rack" if checkright =~ /broom/i || checkleft =~ /broom/i
			fput "put my bag on rack" if checkright =~ /bag/i || checkleft =~ /bag/i
			stow.call
			multifput "get broom from rack", "get bag from rack"
			sweep_dirt_move.call
			break
		end
	end
}

sweep_dirt_move = proc{
	if number > dirt_rooms.length - 1
		sweep_dirt_full.call
	else
		start_script "go2", [dirt_rooms.at(number)]
		wait_while{ running?('go2') }
		number += 1
		sweep_dirt_sweep.call
	end
}

sweep_dirt_sweep = proc{
	waitrt?
	result = dothistimeout "push broom", 3, /There is no dirt here to sweep|Get what|Round time/i
	if result =~ /There is no dirt here to sweep/i
		sweep_dirt_get.call
	elsif result =~ /Get what/i
		sweep_dirt_move.call
	elsif result =~ /Round time/i
		sweep_dirt_sweep.call
	elsif result.nil?
		sweep_dirt_sweep.call
	end
}

sweep_dirt_get = proc{
	waitrt?
	result = dothistimeout "get pile", 3, /Your bag is full\, time to go empty it out|You don't see a dirt pile that you have created here|You gather a dirt pile into your burlap bag.|Get what/i
	if result =~ /Your bag is full\, time to go empty it out|You don't see a dirt pile that you have created here/i
		sweep_dirt_full.call
	elsif result =~ /You gather a dirt pile into your burlap bag.|Get what/i
		sweep_dirt_move.call
	elsif result.nil?
		sweep_dirt_get.call
	end
}

sweep_dirt_full = proc{
	number = 0
	target_room = Room.current.find_nearest(tool_rack_room_number)
	start_script 'go2', [ target_room.to_s ]
	wait_while{ running?('go2') }
	waitrt?
	result = dothistimeout "put my bag in bin", 3, /You have completed|Your burlap bag isn't full yet.|repetition/i
	if result =~ /You have completed/i
		target_room = Room.current.find_nearest(tool_rack_room_number)
		start_script 'go2', [ target_room.to_s ]
		wait_while{ running?('go2') }
		multifput "put my broom on rack", "put my bag on rack"
		turnin.call
	elsif result =~ /Your burlap bag isn't full yet.|repetition/i
		sweep_dirt_move.call
	elsif result.nil?
		sweep_dirt_full.call
	end
}

sweep_critters = proc{
	fput "gld"
	waitfor "The Training Administrator told you to practice sweeping creatures"
	while line = get
		(turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
		if line =~ /remaining to complete this task|remaining for this task/i
			if do_critter_sweep_tasks == "yes"
				fput "gld stance off"
				echo "Go sweep some critters! Restart script when you have finished this task."
				exit
			elsif do_critter_sweep_tasks == "no"
				target_room = Room.current.find_nearest(training_administrator_room)
				start_script 'go2', [ target_room.to_s ]
				wait_while{ running?('go2') }
				GameObj.npcs.find { |npc| person = npc if npc.name =~ training_administrator_names }
				multifput "ask #{person} about trade sweep", "ask #{person} about train sweep"
				go_to_task.call
			elsif do_critter_sweep_tasks == "auto"
				stow.call
				multifput "gld stance o", "get my #{mainweapon}", "get my #{shield}"
				fput "remove my #{shield}" if checkleft == nil
				my_room = Room.current.id
				auto_critter_sweep_tasks.call
			end
			break
		end
	end
}

substart = proc{
	fput "gld"
	waitfor "Subdue skill"
	while line = get
		(garlic_start.call;break) if line =~ /The Training Administrator told you to crush up some/i
		(mannequins_start.call;break) if line =~ /The Training Administrator told you to ding up a few melons at the subdue mannequins./i
		(windows_get_rag.call;break) if line =~ /The Training Administrator told you to clean the windows in the guild./i
		(sub_critters.call;break) if line =~ /The Training Administrator told you to try and subdue some creatures/i
		(promotion.call;break) if line =~ /Congratulations\, you\'ve earned a rank|You need to get promoted to your next rank|You have earned enough training points for your next rank./i
		(turnin.call;break) if line =~ /You are not currently training in this skill/i
	end
}

sub_critters = proc{
	fput "gld stance off"
	echo "Go subdue some critters! Restart script when you have finished this task."
	exit
}

garlic_start = proc{
	fput "gld"
	waitfor "The Training Administrator told you to crush up some"
	while line = get
		(turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
		if line =~ /remaining to complete this task|remaining for this task/i
			stow.call
			fput "get my #{weapon}"
			target_room = Room.current.find_nearest(kitchen_room_number)
			start_script 'go2', [ target_room.to_s ]
			wait_while{ running?('go2') }
			move 'go kitchen'
			get_garlic.call
			break
		end
	end
}

get_garlic = proc{
	stand_up.call if !standing?
	waitrt?
	fput "put clove on block"
	result = dothistimeout "subdue block", 3, /You have completed your training task|You\'re done with this task for now\, you should see the Training Administrator for what to do next|PUT BLOCK IN POT|Put it in the pot now|You\'ll need to have a clove of garlic on the block before trying to smash it properly|You\'re going to need to CLEAN the block before putting another clove on it|Roundtime/i
	if result =~ /You have completed your training task|You\'re done with this task for now\, you should see the Training Administrator for what to do next/i
		turnin.call
	elsif result =~ /PUT BLOCK IN POT|Put it in the pot now/i
		waitrt?
		fput "put block in pot"
		get_garlic.call
	elsif result =~ /You\'ll need to have a clove of garlic on the block before trying to smash it properly|You\'re going to need to CLEAN the block before putting another clove on it/i
		waitrt?
		fput "clean block"
		get_garlic.call
	elsif result =~ /Roundtime/i
		stand_up.call if !standing?
		stamina_check.call if checkstamina < 12
		waitrt?
		fput "subdue block"
		get_garlic.call
	elsif result.nil?
		get_garlic.call
	end
}

mannequins_start = proc{
	fput "gld"
	waitfor "The Training Administrator told you to ding up a few melons at the subdue mannequins"
	while line = get
		(turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
		if line =~ /remaining to complete this task|remaining for this task/i
			waitrt?
			stow.call
			fput "get my #{weapon}"
			target_room = Room.current.find_nearest(mannequin_room_number)
			start_script 'go2', [ target_room.to_s ]
			wait_while{ running?('go2') }
			move 'go mannequin'
			mannequins_subdue.call
			break
		end
	end
}

mannequins_subdue = proc{
	stand_up.call if !standing?
	stamina_check.call if checkstamina < 12
	waitrt?
	result = dothistimeout "subdue mann", 3, /You have completed your training task|clean|needs a head|Round time|repetition|Roundtime/i
	if result =~ /You have completed your training task/i
		turnin.call
	elsif result =~ /Round time|repetition|Roundtime/i
		mannequins_subdue.call
	elsif result =~ /clean/i
		waitrt?
		fput "clean mann"
		mannequins_subdue.call
	elsif result =~ /needs a head/i
		waitrt?
		multifput "clean mann", "put melon on mann"
		mannequins_subdue.call
	elsif result.nil?
		mannequins_subdue.call
	end
}

windows_get_rag = proc{
	fput "gld"
	waitfor "The Training Administrator told you to clean the windows in the guild", "The Training Administrator told you to clean the guild windows."
	while line = get
		(turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
		if line =~ /remaining to complete this task|remaining for this task/i
			number = 0
			target_room = Room.current.find_nearest(tool_rack_room_number)
			start_script 'go2', [ target_room.to_s ]
			wait_while{ running?('go2') }
			my_room = Room.current.id
			if Room.current.id == 17969
				current_window_rooms = icewindow_rooms
			elsif Room.current.id == 16581
				current_window_rooms = landingwindow_rooms
			elsif Room.current.id == 17941
				current_window_rooms = solwindow_rooms
			elsif Room.current.id == 17861
				current_window_rooms = illistimwindow_rooms
			elsif Room.current.id == 18003
				current_window_rooms = rrwindow_rooms
			else
				echo "Error! Stuck in windows_get_rag, try running script again and please inform author of this error."
			end
			fput "put my rag on rack" if checkright =~ /rag/i or checkleft =~ /rag/i
			stow.call
			fput "get rag from rack"
			windows_move.call
			break
		end
	end
}

windows_clean = proc{
	result = dothistimeout "rub window", 3, /You have completed this task|repetition|let someone else have a crack at it/i
	if result =~ /You have completed this task/i
		waitrt?
		target_room = Room.current.find_nearest(tool_rack_room_number)
		start_script 'go2', [ target_room.to_s ]
		wait_while{ running?('go2') }
		multifput "put my rag on rack", "get my #{mainweapon}", "get my #{shield}"
		fput "remove my #{shield}" if checkleft == nil
		fput "stance def"
		start_script 'go2', [my_room]
		wait_while{ running?('go2') }
		turnin.call
	elsif result =~ /repetition|let someone else have a crack at it/i
		windows_move.call
	elsif result.nil?
		windows_clean.call
	end
}

windows_move = proc{
	if number > current_window_rooms.length - 1
		if do_other_guild_tasks == "yes"
			target_room = Room.current.find_nearest(tool_rack_room_number)
			start_script 'go2', [ target_room.to_s ]
			wait_while{ running?('go2') }
			multifput "put my rag on rack", "get my #{mainweapon}", "get my #{shield}" 
			fput "remove my #{shield}" if checkleft == nil
			fput "stance def"
			if Room.current.id == 17969
				go_to_room = 16581
			elsif Room.current.id == 16581
				go_to_room = 17941
			elsif Room.current.id == 17941
				go_to_room = 17969
			end
			start_script "go2", [go_to_room]
			wait_while{ running?('go2') }
			number = 0
			target_room = Room.current.find_nearest(tool_rack_room_number)
			start_script 'go2', [ target_room.to_s ]
			wait_while{ running?('go2') }
			if Room.current.id == 17969
				current_window_rooms = icewindow_rooms
			elsif Room.current.id == 16581
				current_window_rooms = landingwindow_rooms
			elsif Room.current.id == 17941
				current_window_rooms = solwindow_rooms
			elsif Room.current.id == 17861
				current_window_rooms = illistimwindow_rooms
			else
				echo "Error! Stuck in sweep_dirt, try running script again and please inform author of this error."
			end
			fput "put my rag on rack" if checkright =~ /rag/i or checkleft =~ /rag/i
			stow.call
			fput "get rag from rack"
			windows_move.call
		else
			waitrt?
			target_room = Room.current.find_nearest(tool_rack_room_number)
			start_script 'go2', [ target_room.to_s ]
			wait_while{ running?('go2') }
			multifput "put my rag on rack", "get my #{mainweapon}", "get my #{shield}" 
			fput "remove my #{shield}" if checkleft == nil
			fput "stance def"
			start_script 'go2', [my_room]
			wait_while{ running?('go2') }
			_respond "Couldn't finish task, try starting script again in 20 minutes."
			exit
		end
	else
		start_script "go2", [current_window_rooms.at(number)]
		wait_while{ running?('go2') }
		number += 1
		windows_clean.call
	end
}

lmasstart = proc{
	fput "gld"
	waitfor "Lock Mastery skill"
	while line = get
		(lmas_tough_boxes.call;break) if line =~ /pick some tough boxes from creatures/i
		(lmas_trick.call;break) if line =~ /challenging boxes to practice your latest trick for an audience/i
		(keys.call;break) if line =~ /cut keys for some locks you make/i
		(lmas_footpad_talk.call;break) if line =~ /The Training Administrator told you to visit a master footpad for a talk/i
		(lmas_footpad_challenge.call;break) if line =~ /The Training Administrator told you to pit your skills against a footpad./i
		(customize.call;break) if line =~ /customize some lockpicks and keys/i
		(promotion.call;break) if line =~ /(Congratulations\, you\'ve earned a rank|You need to get promoted to your next rank|You have earned enough training points for your next rank.)/i
		(turnin.call;break) if line =~ /You are not currently training in this skill/i
	end
}

lmas_footpad_talk = proc{
	fput "gld"
	waitfor "The Training Administrator told you to visit a master footpad for a talk"
	while line = get
		(turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
		if line =~ /remaining to complete this task|remaining for this task/i
			target_room = Room.current.find_nearest(training_master_room_number)
			start_script 'go2', [ target_room.to_s ]
			wait_while{ running?('go2') }
			GameObj.npcs.find { |npc| master = npc if npc.name =~ master_names }
			talk_to_footpad_masters.call
			break
		end
	end
}

talk_to_footpad_masters = proc{
	fput "ask #{master} about train lmas"
	while line = get
		(lmas_footpad_lock_start.call;break) if line =~ /LMASTER RELOCK the box on the table/i
		(lmas_lockpick_start.call;break) if line =~ /just because you can make your own lockpicks/i
		(customize_footpad_pre.call;break) if line =~ /yer coming down the homestretch now/i
	end
}

lmas_tough_boxes = proc{
	fput "gld"
	waitfor "pick some tough boxes from creatures"
	while line = get
		(turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
		(echo "Pick some tough boxes then restart script when finished with task.";exit) if line =~ /remaining to complete this task|remaining for this task/i
	end
}

lmas_trick = proc{
	fput "gld"
	waitfor "challenging boxes to practice your latest trick for an audience"
	while line = get
		(turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
		(echo "Practice your latest trick for an audience then restart script when finished with task.";exit) if line =~ /remaining to complete this task|remaining for this task/i
	end
}

customize = proc{
	fput "gld"
	waitfor "customize some lockpicks and keys"
	while line = get
		(turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
		if line =~ /remaining to complete this task|remaining for this task/i
			fput "gld"
			waitfor "Lock Mastery skill"
			numberoflockpicks = matchfindword "You have ?"
			numberoflockpicks = Integer(numberoflockpicks)
			start_script 'go2', [ 'bank', '--disable-confirm' ]
			wait_while{ running?('go2') }
			multifput "depo all", "withdraw 5000 silvers"
			target_room = Room.current.find_nearest(toolbenches_room_number)
			start_script 'go2', [ target_room.to_s ]
			wait_while{ running?('go2') }
			fput "go tool"
			customize_create.call
		end
	end
}

customize_create = proc{
	if numberoflockpicks > 0
		waitrt?
		multifput "order 26", "buy"
		result = dothistimeout "lmas create", 3, /You carefully slice the ruined part of|As you remove the resulting/i
		if result =~ /You carefully slice the ruined part of/i
			waitrt?
			fput "drop copper"
			customize_create.call
		elsif result =~ /As you remove the resulting/i
			waitrt?
			fput "swap"
			multifput "lmas customize edge brass", "lmas customize edge brass"
			waitrt?
			numberoflockpicks -= 1
			fput "drop my lockpick"
			customize_create.call
		end
	else
		turnin.call
	end
}

customize_footpad_pre = proc{
	move 'out' if checkpaths 'out'
	fput "gld"
	waitfor "Lock Mastery skill"
	numberoflockpicks = matchfindword "You have ?"
	numberoflockpicks = Integer(numberoflockpicks)
	start_script 'go2', [ 'bank', '--disable-confirm' ]
	wait_while{ running?('go2') }
	multifput "depo all", "withdraw 5000 silvers"
	target_room = Room.current.find_nearest(toolbenches_room_number)
	start_script 'go2', [ target_room.to_s ]
	wait_while{ running?('go2') }
	fput "go tool"
	customize_footpad_create.call
}

customize_footpad_create = proc{
	if numberoflockpicks > 0
		waitrt?
		multifput "order 26", "buy"
		result = dothistimeout "lmas create", 3, /You carefully slice the ruined part of|As you remove the resulting/i
		if result =~ /You carefully slice the ruined part of/i
			waitrt?
			fput "drop copper"
			customize_footpad_create.call
		elsif result =~ /As you remove the resulting/i
			waitrt?
			fput "swap"
			multifput "lmas customize edge brass", "lmas customize edge brass"
			waitrt?
			numberoflockpicks -= 1
			fput "stow my lockpick"
			customize_footpad_create.call
		end
	else
		move 'out' if checkpaths 'out'
		target_room = Room.current.find_nearest(training_master_room_number)
		start_script 'go2', [ target_room.to_s ]
		wait_while{ running?('go2') }
		GameObj.npcs.find { |npc| master = npc if npc.name =~ master_names }
		fput "ask #{master} about training lmas"
		waitfor "I assume you've got some lockpicks or keys to show me"
		customize_footpad_hand_in1.call
	end
}

customize_footpad_hand_in1 = proc{
	result = dothistimeout "get copper lockpick from my #{stow_container}", 3, /Get what|You remove/i
	if result =~ /Get what/i
		turnin.call
	elsif result =~ /You remove/i
		multifput "give lockpick to #{master}", "drop my lockpick"
		customize_footpad_hand_in1.call
	end
}

lmas_footpad_lock_start = proc{
	waitrt?
	fput "get my #{lmas_lockpick}" if checkright !~ /#{lmas_lockpick}/
	multifput "get box", "lmas relock my box"
	result = dothistimeout "give box to #{master}", 3, /You have completed your training task|repetition|roundtime/i
	if result =~ /You have completed your training task/i
		waitrt?
		fput "put my #{lmas_lockpick} in my #{lockpick_container}"
		turnin.call
	elsif result =~ /repetition|roundtime/i
		lmas_footpad_lock_start.call
	elsif result.nil?
		lmas_footpad_lock_start.call
	end
}

lmas_footpad_challenge = proc{
	fput "gld"
	waitfor "pit your skills against a footpad"
	while line = get
		(turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
		if line =~ /remaining to complete this task|remaining for this task/i
			stow.call
			move 'out' if checkpaths 'out'
			target_room = Room.current.find_nearest(training_master_room_number)
			start_script 'go2', [ target_room.to_s ]
			wait_while{ running?('go2') }
			lmas_footpad_challenge1.call
			break
		end
	end
}

lmas_footpad_challenge1 = proc{
	move 'out' if checkpaths 'out'
	GameObj.npcs.find { |npc| master = npc if npc.name =~ master_names }
	number = 0
	fput "ask #{master} about training lmas"
	while line = get
		(turnin.call;break) if line =~/gives you a strange look/i
		(fput "nod";lmas_footpad_challenge_begin.call;break) if line =~ /just nod to me when yer feelin/i
	end			
}


lmas_footpad_challenge_begin = proc{
	fput "put my lockpick on table" if checkright == "lockpick"
	number = number + 1
	if number <= 5
		lmas_footpad_challenge_begin1.call
	else
		lmas_footpad_challenge_wait.call
	end
}

lmas_footpad_challenge_begin1 = proc{
	waitrt?
	result = dothistimeout "disarm #{box[number]}", 3, /You can see what appears to be a tiny hole next to the lock plate which doesn't seem to belong there|You discover no traps./i
	if result =~ /You can see what appears to be a tiny hole next to the lock plate which doesn't seem to belong there/i
		lmas_footpad_challenge_trap.call
	elsif result =~ /You discover no traps./i
		lmas_footpad_challenge_pick.call
	elsif result.nil?
		lmas_footpad_challenge_begin1.call
	end
}

lmas_footpad_challenge_trap = proc{
	waitrt?
	result = dothistimeout "disarm #{box[number]}", 3, /you nudge the end of the flag to one side|You can't seem to get the trap disarmed without setting it off by accident!/i
	if result =~ /you nudge the end of the flag to one side/i
		lmas_footpad_challenge_pick.call
	elsif result =~ /You can't seem to get the trap disarmed without setting it off by accident!/i
		lmas_footpad_challenge_trap.call
	elsif result.nil?
		lmas_footpad_challenge_trap.call
	end
}

lmas_footpad_challenge_pick = proc{
	waitrt?
	fput "get vaalin lockpick from table"
	result = dothistimeout "pick #{box[number]}", 3, /It opens|You are not able to pick the lock|Roundtime/i
	if result =~ /It opens/i
		lmas_footpad_challenge_begin.call
	elsif result =~ /You are not able to pick the lock|Roundtime/i
		lmas_footpad_challenge_pick.call
	elsif result.nil?
		lmas_footpad_challenge_pick.call.call
	end
}

lmas_footpad_challenge_wait = proc{
	while line = get
		(lmas_footpad_challenge1.call;break) if line =~ /escorts you back to the training area|Game\'s over/i
	end
}

cal = proc{
	stow.call
	target_room = Room.current.find_nearest(toolbenches_room_number)
	start_script 'go2', [ target_room.to_s ]
	wait_while{ running?('go2') }
	fput "go toolbench"
	waitfor "workshop instructions"
	fput "get my calipers"
	cal_start.call
}

cal_start = proc{
	waitrt?
	result = dothistimeout "lmaster cal my cal", 3, /Those calipers could not be more perfectly calibrated.|They practically glow with calibration!|need further tuning|Roundtime/i
	if result =~ /Those calipers could not be more perfectly calibrated.|They practically glow with calibration!/i
		fput "put my calipers in my #{calipers_container}"
		move 'out' if checkpaths 'out'
		exit
	elsif result =~ /need further tuning|Roundtime/i
		cal_start.call
	elsif result.nil?
		cal_start.call
	end
}

carve_go = proc{
	number_of_wedges = (script.vars[2].to_i)
	silvers_needed = number_of_wedges * 300
	if number_of_wedges == 1
		echo "Making 1 wedge"
	else
		echo "Making #{number_of_wedges} wedges."
	end
	stow.call
	start_script 'go2', [ 'bank', '--disable-confirm' ]
	wait_while{ running?('go2') }
	multifput "depo all", "withdraw #{silvers_needed} silvers"
	target_room = Room.current.find_nearest(toolbenches_room_number)
	start_script 'go2', [ target_room.to_s ]
	wait_while{ running?('go2') }
	fput "go toolbench"
	waitfor "workshop instructions"
	buy_block.call
}

buy_block = proc{
	fput "put my wedge in my #{wedge_container}" if checkleft == "wedge" or checkright == "wedge"
	fput "stow right" if checkright
	fput "stow left" if checkleft
	number_of_wedges -= 1
	if number_of_wedges <= 0
		echo "Done making wedges"
		move 'out' if checkpaths 'out'
		exit
	end
	waitrt?
	multifput "order 1", "buy"
	carve_start.call
}

carve_start = proc{
	waitrt?
	result = dothistimeout "carve my block", 3, /wedge|wooden block|You can\'t carve that\!/i
	if result =~ /wedge/i
		carve.call
	elsif result =~ /wooden block/i
		carve_start.call
	elsif result =~ /You can\'t carve that\!/
		echo "Done making wedges"
		move 'out' if checkpaths 'out'
		exit
	elsif result.nil?
		carve_start.call
	end
}

carve = proc{
	waitrt?
	result = dothistimeout "carve my wedge", 3, /You should RUB the wedge now.|Roundtime/i
	if result =~ /You should RUB the wedge now./i
		carve_rub.call
	elsif result =~ /Roundtime/i
		carve.call
	elsif result.nil?
		carve.call
	end
}

carve_rub = proc{
	waitrt?
	result = dothistimeout "rub my wedge", 3, /is ready for use!|Roundtime/i
	if result =~ /is ready for use!/i
		buy_block.call
	elsif result =~ /Roundtime/i
		carve_rub.call
	elsif result.nil?
		carve_rub.call
	end
}

lmas_lockpick_start = proc{
	move 'out' if checkpaths 'out'
	fput "gld"
	waitfor "Lock Mastery skill"
	numberoflockpicks = matchfindword "You have ?"
	numberoflockpicks = Integer(numberoflockpicks)
	echo "Making #{numberoflockpicks} lockpicks"
	start_script 'go2', [ 'bank', '--disable-confirm' ]
	wait_while{ running?('go2') }
	multifput "depo all", "withdraw 5000 silvers"
	target_room = Room.current.find_nearest(toolbenches_room_number)
	start_script 'go2', [ target_room.to_s ]
	wait_while{ running?('go2') }
	fput "go tool"
	lock_pick_create.call
}

lock_pick_create = proc{
	if numberoflockpicks > 0
		waitrt?
		multifput "order 26", "buy"
		result = dothistimeout "lmas create", 3, /You carefully slice the ruined part of|As you remove the resulting/i
		if result =~ /You carefully slice the ruined part of/i
			waitrt?
			fput "drop copper"
			lock_pick_create.call
		elsif result =~ /As you remove the resulting/i
			numberoflockpicks -= 1
			waitrt?
			fput "stow my lockpick"
			lock_pick_create.call
		end
	else
		move 'out' if checkpaths 'out'
		target_room = Room.current.find_nearest(training_master_room_number)
		start_script 'go2', [ target_room.to_s ]
		wait_while{ running?('go2') }
		GameObj.npcs.find { |npc| master = npc if npc.name =~ master_names }
		lockpick_handin.call
		fput "ask #{master} about train lmas"
		waitfor "got some lockpicks to show me"
		lockpick_handin1.call
	end
}

lockpick_handin1 = proc{
	result = dothistimeout "get copper lockpick from my #{stow_container}", 3, /Get what|You remove/i
	if result =~ /Get what/i
		move 'out' if checkpaths 'out'
		target_room = Room.current.find_nearest(training_administrator_room)
		start_script 'go2', [ target_room.to_s ]
		wait_while{ running?('go2') }
		GameObj.npcs.find { |npc| person = npc if npc.name =~ training_administrator_names }
		multifput "ask #{training_administrator_names} about train lock", "ask #{training_administrator_names} about train lock"
		lmasstart.call
	elsif result =~ /You remove/i
		multifput "give lockpick to #{master}", "drop my lockpick"
		lockpick_handin1.call
	end
}

gamstart = proc{
	waitrt?
	fput "put my #$stealth_get_item in my #$stealth_get_item_container" if checkleft == "#$stealth_get_item"
	fput "put my #$stealth_get_item in my #$stealth_get_item_container" if checkright == "#$stealth_get_item"
	stow.call
	fput "gld"
	waitfor "Rogue Gambits skill"
	while line = get
		(gam_learn_start.call;break) if line =~ /partner to teach you your latest trick/i
		(gam_audience_start.call;break) if line =~ /The Training Administrator told you to practice your latest trick in front of an audience/i
		(gam_speed_start.call;break) if line =~ /one minute/i
		(gam_teach_start.call;break) if line =~ /teach a fellow guildmember something about rogue gambits/i
		(promotion.call;break) if line =~ /(Congratulations, you've earned a rank|You need to get promoted to your next rank|You have earned enough training points for your next rank.)/i
		(turnin.call;break) if line =~ /You are not currently training in this skill/i
	end
}

gam_learn_start = proc{
	fput "gld"
	waitfor "partner to teach you your latest trick"
	while line = get
		(turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
		if line =~ /remaining to complete this task|remaining for this task/i
			exit if script.vars[2] == nil
			hide_before_trick = "yes" if gam =~ /stealth/i
			get_item_trick = "yes" if gam =~ /get/i
			partner_room.call
			wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{my_partner}(.*)/i } }
			multifput "get my #$stealth_get_item from my #$stealth_get_item_container", "drop my #$stealth_get_item" if get_item_trick == "yes"
			fput "whisper #{my_partner} rgam teach #{checkname} #{gam}"
			until !hiding?
				waitrt?
				fput "unhide"
			end
			if gam =~ /stealth/i
				if gam =~ /stand/i
					until kneeling?
						waitrt?
						fput "kneel"
					end
				else
					until standing?
						waitrt?
						fput "stand"
					end
					waitrt?
				end
			end
			fput "whisper #{my_partner} I am ready to learn"
			gam_learn_start1.call
			break
		end
	end
}

gam_learn_start1 = proc{
	waitrt?
	until !hiding?
		waitrt?
		fput "unhide"
	end
	if gam =~ /stealth/i
		if gam =~ /stand/i
			until kneeling?
				waitrt?
				fput "kneel"
			end
		else
			until standing?
				waitrt?
				fput "stand"
			end
		end
	end
	waitrt?
	if get_item_trick == "yes"
		waitfor "shows you how to take an item from the ground without giving yourself away"
	elsif hide_before_trick == "yes"
		waitfor "gives you some pointers"
	end
	gam_learn_start2.call
}

gam_learn_start2 = proc{
	waitrt?
	until !hiding?
		waitrt?
		fput "unhide"
	end
	if gam =~ /stealth/i
		if gam =~ /stand/i
			until kneeling?
				waitrt?
				fput "kneel"
			end
		else
			until standing?
				waitrt?
				fput "stand"
			end
			waitrt?
		end
	end
	fput "drop my #$stealth_get_item" if get_item_trick == "yes"
	if hide_before_trick == "yes"
		until hiding?
			waitrt?
			fput "hide"
		end
	end
	waitrt?
	result = dothistimeout "rgam #{gam}", 2, /You need to be holding something first|You already have that|You have completed your training task|You have (.*) repetition|but realize that doing so would reveal your location|suddenly become aware that your actions have revealed your location|Just how stealthy are you trying to be|but have revealed yourself from hiding in doing so|but realize that doing so would compromise your hidden position/i
	if result =~ /You need to be holding something first/i
		fput "get my #{weapon}"
		gam_learn_start2.call
	elsif result =~ /You already have that/i
		fput "stow #{weapon}"
		gam_learn_start1.call
	elsif result =~ /You have completed your training task/i
		fput "whisper #{my_partner} All done. Thank you!"
		until !hiding?
			waitrt?
			fput "unhide"
		end
		hide_before_trick = nil
		get_item_trick = nil
		fput "put my #$stealth_get_item in my #$stealth_get_item_container" if get_item_trick == "yes"
		auto_run.call
	elsif result =~ /Just how stealthy are you trying to be/i
		until !hiding?
			waitrt?
			fput "unhide"
		end
		gam_learn_start2.call
	elsif result =~ /suddenly become aware that your actions have revealed your location|but realize that doing so would reveal your location/i
		gam_learn_start2.call
	elsif result =~ /You have (.*) repetition/i
		reps = $1
		fput "whisper #{my_partner} #{reps} more." if update_partner == "on"
		until !hiding?
			waitrt?
			fput "unhide"
		end
		gam_learn_start1.call
	elsif result =~ /but have revealed yourself from hiding in doing so/i
		gam_learn_start2.call
	elsif result =~ /but realize that doing so would compromise your hidden position/i
		gam_learn_start2.call
	elsif result.nil?
		until !hiding?
			waitrt?
			fput "unhide"
		end
		gam_learn_start2.call
	end
}

gam_audience_start = proc{
	fput "gld"
	waitfor "The Training Administrator told you to practice your latest trick in front of an audience"
	while line = get
		(turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
		if line =~ /remaining to complete this task|remaining for this task/i
			target_room = Room.current.find_nearest(audience_rooms)
			start_script 'go2', [ target_room.to_s ]
			wait_while{ running?('go2') }
			hide_before_trick = "yes" if gam =~ /stealth/i
			get_item_trick = "yes" if gam =~ /get/i
			multifput "get my #$stealth_get_item from my #$stealth_get_item_container", "drop my #$stealth_get_item" if get_item_trick == "yes"
			gam_audience_start1.call
			break
		end
	end
}

gam_audience_start1 = proc{
	waitrt?
	until !hiding?
		waitrt?
		fput "unhide"
	end
	if gam =~ /stealth/i
		if gam =~ /stand/i
			until kneeling?
				waitrt?
				fput "kneel"
			end
		else
			until standing?
				waitrt?
				fput "stand"
			end	
		waitrt?
		end
	end
	fput "drop my #$stealth_get_item" if get_item_trick == "yes"
	if hide_before_trick == "yes"
		until hiding?
			waitrt?
			fput "hide"
		end
	end
	i = 0
	checkpcs.each { |pc| i += 1; break if pc == Char.name }
	echo "#{i} people are here."
	waitrt?
	result = dothistimeout "rgam #{gam}", 5, /You need to be holding something first|You already have that|You have completed your training task|repetition|but realize that doing so would reveal your location|suddenly become aware that your actions have revealed your location|Just how stealthy are you trying to be|but have revealed yourself from hiding in doing so/i
	if result =~ /You need to be holding something first/i
			fput "get my #{weapon}"
			gam_audience_start1.call
	elsif result =~ /You already have that/i
			fput "stow #{weapon}"
			gam_audience_start1.call
	elsif result =~ /You have completed your training task/i
		if get_item_trick == "yes"
			fput "put my #$stealth_get_item in my #$stealth_get_item_container"
		end
		hide_before_trick = nil
		get_item_trick = nil
		turnin.call
	elsif result =~ /repetition/i
		until !hiding?
			waitrt?
			fput "unhide"
		end
		sleep 30
		gam_audience_start1.call
	elsif result =~ /suddenly become aware that your actions have revealed your location/i
		until !hiding?
			waitrt?
			fput "unhide"
		end
		gam_audience_start1.call
	elsif result =~ /but have revealed yourself from hiding in doing so|but realize that doing so would compromise your hidden position|Just how stealthy are you trying to be/i
		gam_audience_start1.call
	elsif result.nil?
		until !hiding?
			waitrt?
			fput "unhide"
		end
		sleep 3
		gam_audience_start1.call
	end
}

gam_speed_start = proc{
	fput "gld"
	waitfor "one minute"
	while line = get
		(turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
		(gam_speed_begin.call;break) if line =~ /remaining to complete this task|remaining for this task/i
	end
}

gam_speed_begin = proc{
	hide_before_trick = "yes" if gam =~ /stealth/i
	get_item_trick = "yes" if gam =~ /get/i
	multifput "get my #$stealth_get_item from my #$stealth_get_item_container", "drop my #$stealth_get_item" if get_item_trick == "yes"
	waitrt?
	until !hiding?
		waitrt?
		fput "unhide"
	end
	if gam =~ /stealth/i
		if gam =~ /stand/i
			until kneeling?
				waitrt?
				fput "kneel"
			end
		else
			until standing?
				waitrt?
				fput "stand"
			end
		waitrt?
		end
	end
	fput "drop my #$stealth_get_item" if get_item_trick == "yes"
	if hide_before_trick == "yes"
		until hiding?
			waitrt?
			fput "hide"
		end
	end
	waitrt?
	result = dothistimeout "rgam #{gam}", 5, /You need to be holding something first|You already have that|You have completed your training task|(repetition|You must succeed)|but realize that doing so would reveal your location|suddenly become aware that your actions have revealed your location|Just how stealthy are you trying to be|but have revealed yourself from hiding in doing so|but realize that doing so would compromise your hidden position/i
	if result =~ /You need to be holding something first/i
		fput "get my #{weapon}"
		gam_speed_begin.call
	elsif result =~ /You already have that/i
		fput "stow #{weapon}"
		gam_speed_begin.call
	elsif result =~ /You have completed your training task/i
		fput "put my #$stealth_get_item in my #$stealth_get_item_container" if get_item_trick == "yes"
		hide_before_trick = nil
		get_item_trick = nil
		turnin.call
	elsif result =~ /repetition|You must succeed|but realize that doing so would reveal your location|Just how stealthy are you trying to be|but have revealed yourself from hiding in doing so/i
		gam_speed_begin.call
	elsif result =~ /suddenly become aware that your actions have revealed your location/i
		until !hiding?
			waitrt?
			fput "unhide"
		end
		gam_speed_begin.call
	elsif result.nil?
		until !hiding?
			waitrt?
			fput "unhide"
		end
		gam_speed_begin.call
	end
}

gam_teach_start = proc{
	fput "gld"
	waitfor "teach a fellow guildmember something about rogue gambits"
	while line = get
		(turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
		if line =~ /remaining to complete this task|remaining for this task/i
			exit if script.vars[2] == nil
			partner_room.call
			wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{my_partner}(.*)/i } }
			fput "whisper #{my_partner} rgam #{gam}"
			waitfor "I am ready to learn"
			partner = GameObj.pcs.find { |pc| pc.name =~ /#{my_partner}(.*)/i }
			gam_teach_start1.call
			break
		end
	end
}

gam_teach_start1 = proc{
	if reget 10, "You have completed your training task"
		wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{my_partner}(.*)/i } }
		fput "whisper #{my_partner} All done. Thank you!"
		auto_run.call
	end
	waitrt?
	if gam =~ /stealth/i
		if gam =~ /stand/i
			wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{partner}/i and partner.status =~ /kneel/ } }
		else
			wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{partner}/i and partner.status.nil? } }
		end
	end
	waitrt?
	result = dothistimeout "rgam teach #{my_partner} #{gam}", 5, /You need to have free hands to teach this gambit|You already have that|You should have a silver coin on you to teach this gambit|Wait a few seconds and try again|You have completed your training task|You have (.*) repetition|You need to be holding something first|Who are you trying to teach/i
	if result =~ /You need to have free hands to teach this gambit/i
		stow.call
		gam_teach_start1.call
	elsif result =~ /You already have that/i
		fput "stow #{weapon}"
		gam_teach_start1.call
	elsif result =~ /You should have a silver coin on you to teach this gambit/i
		fput "whisper #{my_partner} Need a coin, be right back."
		currentroom = Room.current.id
		start_script 'go2', [ 'bank', '--disable-confirm' ]
		wait_while{ running?('go2') }
		fput "withdraw 2 silvers"
		start_script "go2", [ "#{currentroom}" ]
		wait_while{ running?('go2') }
		gam_teach_start1.call
	elsif result =~ /Wait a few seconds and try again/i
		sleep 2
		gam_teach_start1.call
	elsif result =~ /You have completed your training task/i
		wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{script.vars[3]}(.*)/i } }
		fput "whisper #{my_partner} All done. Thank you!"
		auto_run.call
	elsif result =~ /You have (.*) repetition/i
		reps = $1
		wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{script.vars[3]}(.*)/i } }
		fput "whisper #{my_partner} #{reps} more." if update_partner == "on"
		gam_teach_start1.call
	elsif result =~ /You need to be holding something first/
		fput "get my #{weapon}"
		gam_teach_start1.call
	elsif result =~ /Who are you trying to teach/
		sleep 2
		gam_teach_start1.call
	elsif result.nil?
		gam_teach_start1.call
	end
}

repair = proc{
	stow.call
	target_room = Room.current.find_nearest(toolbenches_room_number)
	start_script 'go2', [ target_room.to_s ]
	wait_while{ running?('go2') }
	fput "go toolbench"
	getpick.call
}

keys = proc{
	fput "gld"
	waitfor "cut keys for some locks you make"
	while line = get
		(turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
		if line =~ /remaining to complete this task|remaining for this task/i
			start_script 'go2', [ 'bank', '--disable-confirm' ]
			wait_while{ running?('go2') }
			multifput "depo all", "withdraw 5000 silvers"
			target_room = Room.current.find_nearest(toolbenches_room_number)
			start_script 'go2', [ target_room.to_s ]
			wait_while{ running?('go2') }
			fput "go tool"
			keys_1.call
			break
		end
	end
}

keys_1 = proc{
	waitrt?
	multifput "drop my key", "drop my assem"
	multifput "lmas lock create 25", "lmas lock create 25"
	waitrt?
	multifput "order 25", "buy"
	result = dothistimeout "lmas cut key", 5, /repetition|You have completed your training task/i
	if result =~ /repetition/i
		keys_1.call
	elsif result =~ /You have completed your training task/i
		waitrt?
		multifput "drop my key", "drop my assem", "out"
		turnin.call
	end
}

cheapstart = proc{
	fput "gld"
	waitfor "Cheap Shot skill"
	while line = get
		(footstomp_defend.call;break) if line =~ /The Training Administrator told you to practice defending against footstomps./i
		(footstomp_partner.call;break) if line =~ /The Training Administrator told you to practice footstomping a partner./i
		(cheap_critter.call;break) if line =~ /The Training Administrator told you to tweak some creatures\' noses.|The Training Administrator told you to practice templeshot on some creatures./i
		(cheap_plants.call;break) if line =~ /The Training Administrator told you to water the guild plants./i
		(sweep_dirt.call;break) if line =~ /The Training Administrator told you to sweep the guild courtyard./i
		(windows_get_rag.call;break) if line =~ /The Training Administrator told you to clean the guild windows./i
		(promotion.call;break) if line =~ /(Congratulations, you've earned a rank|You need to get promoted to your next rank|You have earned enough training points for your next rank.)/i
		(turnin.call;break) if line =~ /You are not currently training in this skill/i
	end
}

footstomp_defend = proc{
	fput "gld"
	waitfor "The Training Administrator told you to practice defending against footstomps."
	while line = get
		(turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
		if line =~ /remaining to complete this task|remaining for this task/i
			exit if script.vars[2] == nil
			multifput "gld stance def", "stance off"
			partner_room.call
			wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{my_partner}(.*)/i } }
			fput "whisper #{my_partner} I need to be footstomped."
			foot_stomp_defend1.call
			break
		end
	end
}

foot_stomp_defend1 = proc{
	while line = get
		if line =~ /You have (.*) repetition/i
			reps = $1
			fput "whisper #{my_partner} #{reps} more." if update_partner == "on"
		elsif line =~ /You have completed your training task/i
			fput "whisper #{my_partner} All done. Thank you!"
			auto_run.call
			break
		end
	end
}


footstomp_partner = proc{
	fput "gld"
	waitfor "The Training Administrator told you to practice footstomping a partner"
	while line = get
		(turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
		if line =~ /remaining to complete this task|remaining for this task/i
			multifput "gld stance off", "stance off"
			partner_room.call
			wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{my_partner}(.*)/i } }
			fput "whisper #{my_partner} I need to footstomp you."
			waitfor "Ready to be footstomped"
			footstomp_partner_start.call
			break
		end
	end
}

footstomp_partner_start = proc{
	stand_up.call if !standing?
	stamina_check.call if checkstamina < 12
	waitrt?
	result = dothistimeout "cheap foot #{my_partner}", 2, /just fell for a footstomp not long ago|You have completed your training task|You have (.*) repetition/i
	if result =~ /just fell for a footstomp not long ago/
		sleep 2
		footstomp_partner_start.call
	elsif result =~ /You have (.*) repetition/
		reps = $1
		fput "whisper #{my_partner} #{reps} more." if update_partner == "on"
		sleep 13
		footstomp_partner_start.call
	elsif result =~ /You have completed your training task/
		fput "whisper #{my_partner} All done!"
		waitrt?
		auto_run.call
	elsif result.nil?
		sleep 2
		footstomp_partner_start.call
	end
}


cheap_critter = proc{
	fput "gld"
	waitfor "The Training Administrator told you to tweak some creatures' noses.", "The Training Administrator told you to practice templeshot on some creatures."
	while line = get
		(turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
		if line =~ /remaining to complete this task|remaining for this task/i
			fput "gld stance off"
			echo "Go cheap shot some critters!"
			exit
		end
	end
}

cheap_plants = proc{
	fput "gld"
	waitfor "The Training Administrator told you to water the guild plants"
	while line = get
		(turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
		if line =~ /remaining to complete this task|remaining for this task/i
			number = 0
			target_room = Room.current.find_nearest(tool_rack_room_number)
			start_script 'go2', [ target_room.to_s ]
			wait_while{ running?('go2') }
			my_room = Room.current.id
			if Room.current.id == 17969
				current_plant_rooms = iceplant_rooms
			elsif Room.current.id == 16581
				current_plant_rooms = landingplant_rooms
			elsif Room.current.id == 17941
				current_plant_rooms = solplant_rooms
			elsif Room.current.id == 17861
				current_plant_rooms = illistimplant_rooms
			elsif Room.current.id == 18003
				current_plant_rooms = rrplant_rooms
			else
			
				echo "Error! Stuck in sweep_dirt, try running script again and please inform author of this error."
			end
			fput "put my can in rack" if checkright =~ /can/i or checkleft =~ /can/i
			stow.call
			fput "get can"
			cheap_plants_move.call
		end
	end
}

cheap_plants_move = proc{
	if number > current_plant_rooms.length - 1
		if do_other_guild_tasks == "yes"
			target_room = Room.current.find_nearest(tool_rack_room_number)
			start_script 'go2', [ target_room.to_s ]
			wait_while{ running?('go2') }
			multifput "put my can in rack", "get my #{mainweapon}", "get my #{shield}"
			fput "remove my #{shield}" if checkleft == nil
			fput "stance def"
			if Room.current.id == 17969
				go_to_room = 16581
			elsif Room.current.id == 16581
				go_to_room = 17941
			elsif Room.current.id == 17941
				go_to_room = 17969
			end
			start_script "go2", [go_to_room]
			wait_while{ running?('go2') }
			number = 0
			target_room = Room.current.find_nearest(tool_rack_room_number)
			start_script 'go2', [ target_room.to_s ] 
			wait_while{ running?('go2') }
			if Room.current.id == 17969
				current_plant_rooms = iceplant_rooms
			elsif Room.current.id == 16581
				current_plant_rooms = landingplant_rooms
			elsif Room.current.id == 17941
				current_plant_rooms = solplant_rooms
			elsif Room.current.id == 17861
				current_plant_rooms = illistimplant_rooms
			else
				echo "Error! Stuck in cheap_plants_move, try running script again and please inform author of this error."
			end
			fput "put my can in rack" if checkright =~ /can/i or checkleft =~ /can/i
			stow.call
			fput "get can"
			cheap_plants_move.call
		else
			waitrt?
			target_room = Room.current.find_nearest(tool_rack_room_number)
			start_script 'go2', [ target_room.to_s ]
			wait_while{ running?('go2') }
			multifput "put my can in rack", "get my #{mainweapon}", "get my #{shield}"
			fput "remove my #{shield}" if checkleft == nil
			fput "stance def"
			start_script 'go2', [my_room]
			wait_while{ running?('go2') }
			_respond "Couldn't finish task, try starting script again in 20 minutes."
			exit
		end
	else
		start_script "go2", [current_plant_rooms.at(number)]
		wait_while{ running?('go2') }
		number += 1
		cheap_plants_water.call
	end
}

cheap_plants_water = proc{
	waitrt?
	fput "kneel"
	GameObj.loot.find { |loot| flower = loot.name if loot.name =~ flower_names }
	if Room.current.id == 17871 or Room.current.id == 17851 or Room.current.id == 17855 or Room.current.id == 17869 or Room.current.id == 17870
		flower = "wildflower"
	end
	if flower =~ /rose/
		flower = "rose"
	end
	result = dothistimeout "water #{flower}", 2, /You have completed|let someone else have a crack at it|repetition/i
	if result =~ /You have completed/i
		target_room = Room.current.find_nearest(tool_rack_room_number)
		start_script 'go2', [ target_room.to_s ]
		wait_while{ running?('go2') }
		multifput "put my can in rack", "get my #{mainweapon}", "get my #{shield}"
		fput "remove my #{shield}" if checkleft == nil
		fput "stance def"
		start_script 'go2', [my_room]
		wait_while{ running?('go2') }
		turnin.call
	elsif result =~ /let someone else have a crack at it|repetition/i
		cheap_plants_move.call
	end
}

if Char.prof != "Rogue"
	echo  "This script only works for rogues."
	exit
end
stow.call
my_partner = script.vars[2] if script.vars[2] != nil
(setup.call;exit) if script.vars[1] == "setup"
if (CharSettings['setup_has_been_run'] == nil || UserVars.rogue.nil?) and (script.vars[1] != 'setup')
	echo "Setup is required, type ;rogue setup and fill in all settings."	
	exit
end
if script.vars[1] == nil
	_respond "Type ;rogue sweep to automate solo sweep tasks. ;rogue sweep <partnername> for partner tasks."
	_respond "Type ;rogue gam to automate solo gambit tasks. ;rogue gam <partnername> for partner tasks."
	_respond "Type ;rogue cheap to automate solo cheap shot tasks. ;rogue cheap <partnername> for partner tasks."
	_respond "Type ;rogue sub to automate solo subdue tasks."
	_respond "Type ;rogue lmas do lockmastery tasks. Doesn't do all lockmastery tasks."
	_respond "Typing ;rogue <sweep, gam, sub or lmas> will also turn in completed tasks to the NPC."
	_respond "Type ;rogue cal to calibrate your calipers."
	_respond "Type ;rogue wedge <number> to create specified number of wedges."
	_respond "To help another person with their task type ;rogue <sweep, cheap> help"
	_respond "Note, do not type gld while script is running, it could make the script stop working."
	exit 
elsif script.vars[2] == "help"
	multifput "gld stance off", "stance off"
	if script.vars[1] == "sweep"
		help_sweep_partner_start.call	
	elsif script.vars[1] == "cheap"
		help_cheap_partner_start.call	
	end
elsif script.vars[2] == "teach"
	gam_teach_help_start.call
elsif script.vars[2] == "learn"
	gam_learn_help_start.call
elsif script.vars[1] == "def"
	(multifput "gld stance def", "stance off";exit)
elsif script.vars[1] == "cal"
	cal.call
elsif script.vars[1] == "wedge"
	carve_go.call
elsif script.vars[1] == "carve"
	carve_go.call
elsif script.vars[1] == "repair"
	repair.call
elsif script.vars[1] == "checkin"
	checkin.call
else
	go_to_task.call
end