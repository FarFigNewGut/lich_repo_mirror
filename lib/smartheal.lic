# QUIET
=begin
	SmartHeal
	Created By: Vailan
	Date:       05-26-2020
	
	          author: Vailan (Vailan#0875 on discord)
            game: GS
            tags: empath, heal, healing,
        		required: Lich >= 4.6.4
         		version: 2020.05.26.1
	
	Leveraging the concepts behind healself this tool is designed to assist int he clean up of your wounds either as a single pass or on an ongoing basis.
	Intented to allow you to prioritize bleeders first and then order by injuries that prevent spell casting, mana and experience absorbion.
	
	Watches your current mana and looks at the mana cost of the spell needed to cast next and will wait until you have enough mana to cast.
	Watches your current health and if below 90% will cure blood to get over that percentage before resuming other cures.
	Is Level Aware for spells you can cast so will not try to cast spells for which you do not have the levels to cure the injury. (Note: It is NOT checking
		to see if you actually know the spell in question just whether you have the levels suitable to cast)
		
	
	";smartheal setup" will display a dialog that allows you to select what level of wounds and scars to heal and whetehr to continue doing so and also
		allow you to select a priority threshold for bleeding to cure first.
		Setting the Bleeding Threshold allows you to indicate that if you have injuries with a bleed rate equal to or above that number those will get healed first
		in order of largest bleed to smallest above the threshold.
	";smartheal wounds" will ignore your configured settings for wound levels and heal all wounds but ignore scars
	";smartheal scars" will ignore your configured settings for scar levels and heal all scars that dont have wounds on them and ignore healing wounds.
	";smartheal all" will ignore your configured settigs for scar levels and wound levels and will heal down all wounds and then heal down all scar.	
		

	********change log***********
	2020.05.05.1 - Inital Draft
	2020.05.06.1 - Initial Publishing
	2020.05.06.2 - Fixed an issue with ordering between bleeders and regular wounds
	2020.05.07.1 - Completely rewrote this to be more granular on your healing priorities and choices with a whole new setup UI
	2020.05.08.1 - Updated the health check to see bleedin to squelch the returned health information to reduce the 
									screen scroll (Thanks to LostRanger for the nudge on that and the example code)
	2020.05.14.1 - Fixed a couple bugs around wound prioritization and scar identification for being within caster ablity								
	2020.05.26.1 - Major rewrite consilodating multiple hashes into a single has with a class for data to keep everything more organized.
									also significant updates to the logic for caluclating mana needed to heal (especially blood) which would result in 
									overhealing if low on mana and missing significant amounts of blood.
	
	***********todo**************
	-Handle interrupting activities such as casting other spells, appraising or transferring wounds by pausing to allow them when detected
		to allow them to complete. Right now using pause and unpause macro buttons to start it when i want it to run and stop it when i dont
	
	
	*********known issues********
	-When in a loop hides the output of calling the "health" command even if done manually. This seems to be fixed most of the time but
	 have had it still occasionally not show up but am unsure why and thus havent fixed it completely
	
	*********fixed issues********
	-figure out a way to get the levels of bleedign without having to scroll the screen so much by calling "health" and parsing
	-track injuries on an ongoing basis to continually prioritize them. After every heal and during every cycle it re-evaluates your state
		against the settings you have defined.
	-fixed an issue where it would try to repeated heal a scar that was beyond the casters abilitites
	-Almost a complete rewrite fixing several issues with mana utilization, health checking, wound tracking
	 and prioritization when new wounds are taken wheile applciation is runnign through a healing cycle. This is now calcualted every time
	 a wound is goign to be healed isnead of in batches.
	
	
		


=end

VERSION = "2020.05.26.1"

if $frontend != "stormfront"
  respond ""
  respond " Thank you for your interest in SmartHeal"
  respond " This version is specific to the Stormfront frontend"
 	respond ""
  respond ""
  respond " Closing now"
  respond ""
  exit
end


#<name> just gave you <number of coins> coins which you quickly pocket.
settings = CharSettings.to_hash
	settings['laMaxWound'] ||= 0
	settings['raMaxWound'] ||= 0
	settings['lhMaxWound'] ||= 0
	settings['rhMaxWound'] ||= 0
	settings['llMaxWound'] ||= 0
	settings['rlMaxWound'] ||= 0
	settings['leMaxWound'] ||= 0
	settings['reMaxWound'] ||= 0
	settings['headMaxWound'] ||= 0
	settings['neckMaxWound'] ||= 0
	settings['chestMaxWound'] ||= 0
	settings['abdomenMaxWound'] ||= 0
	settings['backMaxWound'] ||= 0
	settings['nervesMaxWound'] ||= 0

	settings['laMaxScar'] ||= 0
	settings['raMaxScar'] ||= 0
	settings['lhMaxScar'] ||= 0
	settings['rhMaxScar'] ||= 0
	settings['llMaxScar'] ||= 0
	settings['rlMaxScar'] ||= 0
	settings['leMaxScar'] ||= 0
	settings['reMaxScar'] ||= 0
	settings['headMaxScar'] ||= 0
	settings['neckMaxScar'] ||= 0
	settings['chestMaxScar'] ||= 0
	settings['abdomenMaxScar'] ||= 0
	settings['backMaxScar'] ||= 0
	settings['nervesMaxScar'] ||= 0
		
	settings['laPriority'] ||= 4
	settings['raPriority'] ||= 2
	settings['lhPriority'] ||= 5
	settings['rhPriority'] ||= 3
	settings['llPriority'] ||= 9
	settings['rlPriority'] ||= 10
	settings['lePriority'] ||= 12
	settings['rePriority'] ||= 13
	settings['headPriority'] ||= 0
	settings['neckPriority'] ||= 6
	settings['chestPriority'] ||= 7
	settings['abdomenPriority'] ||= 8
	settings['backPriority'] ||= 11
	settings['nervesPriority'] ||= 1

	settings['maxBleedRate'] ||= "0"
	settings['minimumhealth'] ||= "0"
	settings['maintainHealing'] ||= false
	settings['debugEnabled'] ||= false

force_setting = Hash.new("force_setting")
	force_setting['force_wound_level'] = -1
	force_setting['force_scar_level'] = -1
	force_setting['max_wound_level'] = 0
	force_setting['max_scar_level'] = 0
	
	
	

	
guiBodyPartElements = Hash.new("guiBodyPartElement")
guiBodyPartElements['head'] = "Head"
guiBodyPartElements['neck'] = "Neck"
guiBodyPartElements['chest'] = "Chest"
guiBodyPartElements['abdomen'] = "Abdomen"
guiBodyPartElements['back'] = "Back"
guiBodyPartElements['ll'] = "Left Leg"
guiBodyPartElements['rl'] = "Right Leg"
guiBodyPartElements['la'] = "Left Arm"
guiBodyPartElements['ra'] = "Right Arm"
guiBodyPartElements['lh'] = "Left Hand"
guiBodyPartElements['rh'] = "Right Hand"
guiBodyPartElements['le'] = "Left Eye"
guiBodyPartElements['re'] = "Right Eye"
guiBodyPartElements['nerves'] = "Nerves"


#new Hash to replace the other 4
injuryDetails = Hash.new("injuryDetails")


#Body locations are in order of preference for healing if there is no difference in bleeding or if bleeding is ignore
body_Locations = {
	0 => "head",
	1 => "nerves",
	2 => "left arm",
	3 => "right arm",
	4 => "left hand",
	5 => "right hand",
	6	=> "chest",
	7	=> "abdomen",
	8	=> "neck",		
	9	=> "back",
	10 => "left leg",
	11 => "right leg",
	12 => "left eye",
	13 => "right eye",
	}



###############################################################################################################################################################
#              Begin the screen setup
###############################################################################################################################################################
setup = proc {
		
	gtk_global = Hash.new
	window = window_action = nil
	Gtk.queue {
		ttips = Gtk::Tooltips.new.enable
		#Setup tooltip text
		ttips_text = {
			'laMaxWound'				=> 'Max Wound for Left Arm (0=None, 1=Minor, 2=Moderate,3=Major)',
			'raMaxWound'				=> 'Max Wound for Right Arm (0=None, 1=Minor, 2=Moderate,3=Major)',
			'lhMaxWound'				=> 'Max Wound for Left Hand (0=None, 1=Minor, 2=Moderate,3=Major)',
			'rhMaxWound'				=> 'Max Wound for Right Hand (0=None, 1=Minor, 2=Moderate,3=Major)',
			'llMaxWound'				=> 'Max Wound for Left Leg (0=None, 1=Minor, 2=Moderate,3=Major)',
			'rlMaxWound'				=> 'Max Wound for Right Leg (0=None, 1=Minor, 2=Moderate,3=Major)',
			'leMaxWound'				=> 'Max Wound for Left Eye (0=None, 1=Minor, 2=Moderate,3=Major)',
			'reMaxWound'				=> 'Max Wound for Right Eye (0=None, 1=Minor, 2=Moderate,3=Major)',
			'headMaxWound'			=> 'Max Wound for Head (0=None, 1=Minor, 2=Moderate,3=Major)',
			'neckMaxWound'			=> 'Max Wound for Neck (0=None, 1=Minor, 2=Moderate,3=Major)',
			'chestMaxWound'			=> 'Max Wound for Chest (0=None, 1=Minor, 2=Moderate,3=Major)',
			'abdomenMaxWound'		=> 'Max Wound for Abdomen (0=None, 1=Minor, 2=Moderate,3=Major)',
			'backMaxWound'			=> 'Max Wound for Back (0=None, 1=Minor, 2=Moderate,3=Major)',
			'nervesMaxWound'		=> 'Max Wound for Nerves (0=None, 1=Minor, 2=Moderate,3=Major)',
			'laMaxScar'					=> 'Max Scar for Left Arm (0=None, 1=Minor, 2=Moderate,3=Major)',               
			'raMaxScar'					=> 'Max Scar for Right Arm (0=None, 1=Minor, 2=Moderate,3=Major)',              
			'lhMaxScar'					=> 'Max Scar for Left Hand (0=None, 1=Minor, 2=Moderate,3=Major)',              
			'rhMaxScar'					=> 'Max Scar for Right Hand (0=None, 1=Minor, 2=Moderate,3=Major)',             
			'llMaxScar'					=> 'Max Scar for Left Leg (0=None, 1=Minor, 2=Moderate,3=Major)',               
			'rlMaxScar'					=> 'Max Scar for Right Leg (0=None, 1=Minor, 2=Moderate,3=Major)',              
			'leMaxScar'					=> 'Max Scar for Left Eye (0=None, 1=Minor, 2=Moderate,3=Major)',               
			'reMaxScar'					=> 'Max Scar for Right Eye (0=None, 1=Minor, 2=Moderate,3=Major)',              
			'headMaxScar'				=> 'Max Scar for Head (0=None, 1=Minor, 2=Moderate,3=Major)',                   
			'neckMaxScar'				=> 'Max Scar for Neck (0=None, 1=Minor, 2=Moderate,3=Major)',                   
			'chestMaxScar'			=> 'Max Scar for Chest (0=None, 1=Minor, 2=Moderate,3=Major)',                  
			'abdomenMaxScar'		=> 'Max Scar for Abdomen (0=None, 1=Minor, 2=Moderate,3=Major)',                
			'backMaxScar'				=> 'Max Scar for Back (0=None, 1=Minor, 2=Moderate,3=Major)',                   
			'nervesMaxScar'			=> 'Max Scar for Nerves (0=None, 1=Minor, 2=Moderate,3=Major)',                 
			'laPriority'				=> 'Healing Priority for Left Arm',               
			'raPriority'				=> 'Healing Priority for Right Arm',              
			'lhPriority'				=> 'Healing Priority for Left Hand',              
			'rhPriority'				=> 'Healing Priority for Right Hand',             
			'llPriority'				=> 'Healing Priority for Left Leg',               
			'rlPriority'				=> 'Healing Priority for Right Leg',              
			'lePriority'				=> 'Healing Priority for Left Eye',               
			'rePriority'				=> 'Healing Priority for Right Eye',              
			'headPriority'			=> 'Healing Priority for Head',                   
			'neckPriority'			=> 'Healing Priority for Neck',                   
			'chestPriority'			=> 'Healing Priority for Chest',                  
			'abdomenPriority'		=> 'Healing Priority for Abdomen',                
			'backPriority'			=> 'Healing Priority for Back',                   
			'nervesPriority'		=> 'Healing Priority for Nerves',                 
			'maxBleedRate'			=> 'If there are wounds bleeding at or over this rate heal them first in order of severity',
			'minimumhealth'			=> 'If your health goes below this percentage then use "Cure Blood" to get over this level and then resume healing',
			'maintainHealing'		=> 'When started if this is enabled it will continue to check for wounds that exceed assigned limits and heal them',
			'debugEnabled'			=> 'This is to turn on very verbose logging to see the steps. You should never need this and it is really for the developer to use when troubleshooting',

			
		}
			
		gtk_global['laMaxWound'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['raMaxWound'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['lhMaxWound'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['rhMaxWound'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['llMaxWound'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['rlMaxWound'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['leMaxWound'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['reMaxWound'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['headMaxWound'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['neckMaxWound'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['chestMaxWound'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['abdomenMaxWound'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['backMaxWound'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['nervesMaxWound'] = Gtk::ComboBox.new(is_text_only = true)
		
		gtk_global['laMaxScar'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['raMaxScar'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['lhMaxScar'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['rhMaxScar'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['llMaxScar'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['rlMaxScar'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['leMaxScar'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['reMaxScar'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['headMaxScar'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['neckMaxScar'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['chestMaxScar'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['abdomenMaxScar'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['backMaxScar'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['nervesMaxScar'] = Gtk::ComboBox.new(is_text_only = true)
		
		gtk_global['laPriority'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['raPriority'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['lhPriority'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['rhPriority'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['llPriority'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['rlPriority'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['lePriority'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['rePriority'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['headPriority'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['neckPriority'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['chestPriority'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['abdomenPriority'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['backPriority'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['nervesPriority'] = Gtk::ComboBox.new(is_text_only = true)
		
		gtk_global['maxBleedRate'] = Gtk::Entry.new.set_text(settings['maxBleedRate'].to_s)
		gtk_global['minimumhealth'] = Gtk::Entry.new.set_text(settings['minimumhealth'].to_s)
		gtk_global['maintainHealing'] = Gtk::CheckButton.new.set_active(settings['maintainHealing'])
		gtk_global['debugEnabled'] = Gtk::CheckButton.new.set_active(settings['debugEnabled'])
		
		#All of these need to be set to active as well
		x = 0
		while x < 4
			gtk_global['laMaxWound'].append_text(x.to_s)
			gtk_global['raMaxWound'].append_text(x.to_s) 
			gtk_global['lhMaxWound'].append_text(x.to_s)
			gtk_global['rhMaxWound'].append_text(x.to_s)
			gtk_global['llMaxWound'].append_text(x.to_s)
			gtk_global['rlMaxWound'].append_text(x.to_s)
			gtk_global['leMaxWound'].append_text(x.to_s)
			gtk_global['reMaxWound'].append_text(x.to_s)
			gtk_global['headMaxWound'].append_text(x.to_s)
			gtk_global['neckMaxWound'].append_text(x.to_s)
			gtk_global['chestMaxWound'].append_text(x.to_s)
			gtk_global['abdomenMaxWound'].append_text(x.to_s)
			gtk_global['backMaxWound'].append_text(x.to_s)
			gtk_global['nervesMaxWound'].append_text(x.to_s) 
			gtk_global['laMaxScar'].append_text(x.to_s)
			gtk_global['raMaxScar'].append_text(x.to_s)
			gtk_global['lhMaxScar'].append_text(x.to_s)
			gtk_global['rhMaxScar'].append_text(x.to_s)
			gtk_global['llMaxScar'].append_text(x.to_s)
			gtk_global['rlMaxScar'].append_text(x.to_s)
			gtk_global['leMaxScar'].append_text(x.to_s)
			gtk_global['reMaxScar'].append_text(x.to_s)
			gtk_global['headMaxScar'].append_text(x.to_s)
			gtk_global['neckMaxScar'].append_text(x.to_s)
			gtk_global['chestMaxScar'].append_text(x.to_s) 
			gtk_global['abdomenMaxScar'].append_text(x.to_s)
			gtk_global['backMaxScar'].append_text(x.to_s)
			gtk_global['nervesMaxScar'].append_text(x.to_s)

			x += 1
		end
		
		x = 1
		while x < 15
			gtk_global['laPriority'].append_text(x.to_s)
			gtk_global['raPriority'].append_text(x.to_s)
			gtk_global['lhPriority'].append_text(x.to_s)
			gtk_global['rhPriority'].append_text(x.to_s)
			gtk_global['llPriority'].append_text(x.to_s)
			gtk_global['rlPriority'].append_text(x.to_s)
			gtk_global['lePriority'].append_text(x.to_s)
			gtk_global['rePriority'].append_text(x.to_s)
			gtk_global['headPriority'].append_text(x.to_s)
			gtk_global['neckPriority'].append_text(x.to_s)
			gtk_global['chestPriority'].append_text(x.to_s)
			gtk_global['abdomenPriority'].append_text(x.to_s)
			gtk_global['backPriority'].append_text(x.to_s)
			gtk_global['nervesPriority'].append_text(x.to_s)
		
			x += 1
		end
		
		gtk_global['laMaxWound'].set_active(settings['laMaxWound']) #have to set active after apending
		gtk_global['raMaxWound'].set_active(settings['raMaxWound']) #have to set active after apending
		gtk_global['lhMaxWound'].set_active(settings['lhMaxWound']) #have to set active after apending
		gtk_global['rhMaxWound'].set_active(settings['rhMaxWound']) #have to set active after apending
		gtk_global['llMaxWound'].set_active(settings['llMaxWound']) #have to set active after apending
		gtk_global['rlMaxWound'].set_active(settings['rlMaxWound']) #have to set active after apending
		gtk_global['leMaxWound'].set_active(settings['leMaxWound']) #have to set active after apending
		gtk_global['reMaxWound'].set_active(settings['reMaxWound']) #have to set active after apending
		gtk_global['headMaxWound'].set_active(settings['headMaxWound']) #have to set active after apending
		gtk_global['neckMaxWound'].set_active(settings['neckMaxWound']) #have to set active after apending
		gtk_global['chestMaxWound'].set_active(settings['chestMaxWound']) #have to set active after apending
		gtk_global['abdomenMaxWound'].set_active(settings['abdomenMaxWound']) #have to set active after apending
		gtk_global['backMaxWound'].set_active(settings['backMaxWound']) #have to set active after apending
		gtk_global['nervesMaxWound'].set_active(settings['nervesMaxWound']) #have to set active after apending
		
		gtk_global['laMaxScar'].set_active(settings['laMaxScar']) #have to set active after apending
		gtk_global['raMaxScar'].set_active(settings['raMaxScar']) #have to set active after apending
		gtk_global['lhMaxScar'].set_active(settings['lhMaxScar']) #have to set active after apending
		gtk_global['rhMaxScar'].set_active(settings['rhMaxScar']) #have to set active after apending
		gtk_global['llMaxScar'].set_active(settings['llMaxScar']) #have to set active after apending
		gtk_global['rlMaxScar'].set_active(settings['rlMaxScar']) #have to set active after apending
		gtk_global['leMaxScar'].set_active(settings['leMaxScar']) #have to set active after apending
		gtk_global['reMaxScar'].set_active(settings['reMaxScar']) #have to set active after apending
		gtk_global['headMaxScar'].set_active(settings['headMaxScar']) #have to set active after apending
		gtk_global['neckMaxScar'].set_active(settings['neckMaxScar']) #have to set active after apending
		gtk_global['chestMaxScar'].set_active(settings['chestMaxScar']) #have to set active after apending
		gtk_global['abdomenMaxScar'].set_active(settings['abdomenMaxScar']) #have to set active after apending
		gtk_global['backMaxScar'].set_active(settings['backMaxScar']) #have to set active after apending
		gtk_global['nervesMaxScar'].set_active(settings['nervesMaxScar']) #have to set active after apending
		
		gtk_global['laPriority'].set_active(settings['laPriority']) #have to set active after apending
		gtk_global['raPriority'].set_active(settings['raPriority']) #have to set active after apending
		gtk_global['lhPriority'].set_active(settings['lhPriority']) #have to set active after apending
		gtk_global['rhPriority'].set_active(settings['rhPriority']) #have to set active after apending
		gtk_global['llPriority'].set_active(settings['llPriority']) #have to set active after apending
		gtk_global['rlPriority'].set_active(settings['rlPriority']) #have to set active after apending
		gtk_global['lePriority'].set_active(settings['lePriority']) #have to set active after apending
		gtk_global['rePriority'].set_active(settings['rePriority']) #have to set active after apending
		gtk_global['headPriority'].set_active(settings['headPriority']) #have to set active after apending
		gtk_global['neckPriority'].set_active(settings['neckPriority']) #have to set active after apending
		gtk_global['chestPriority'].set_active(settings['chestPriority']) #have to set active after apending
		gtk_global['abdomenPriority'].set_active(settings['abdomenPriority']) #have to set active after apending
		gtk_global['backPriority'].set_active(settings['backPriority']) #have to set active after apending
		gtk_global['nervesPriority'].set_active(settings['nervesPriority']) #have to set active after apending
		
		
		
		
		
		ttips_text.each_pair { |widget,tip|
			if widget = gtk_global[widget]# || gtk_locals[widget]
				ttips.set_tip(widget,tip,'')
			end
		}
		
		window = Gtk::Window.new
		window.title = "SmartHeal #{VERSION} for #{Char.name}"
		window.border_width = 3
		window.resizable = true
		#window.resize(10, 10)
		
		
		settings_page = Gtk::VBox.new(false,1).set_border_width(3)
		vb_pg1_Intro = Gtk::HBox.new(false,1).set_border_width(3)
		hb = Gtk::HBox.new(false,1)
		lbl = Gtk::Label.new.set_markup("Set Priorities from #1 to #13 in order of 1st to heal and last to heal and set Max Wounds and Scars to reflect the level of woudns that will automatically healed").set_width_request(450)
		lbl.set_wrap(true).set_padding(0,10)
		vb_pg1_Intro.pack_start(lbl,false)			
		settings_page.pack_start(vb_pg1_Intro,false)
		#vb_pg1_head = Gtk::VBox.new(false,1).set_border_width(3)
		
		##############################################################################################################
		#Begin Loop to Add Body Part Controls to Setup Window
		##############################################################################################################
		
		guiBodyPartElements.each do |bodyPart|
			#echo "BodyPart #{bodyPart[0]} as #{bodyPart[1]}"
			#Start Head Section
			#Create Active Page
			vb_pg1_head = Gtk::HBox.new(false,1).set_border_width(3)
		
			#Create Head Frame in Page		
			fr_pg1_head = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup(bodyPart[1]))
			fr_pg1_head.add(vb_pg1_head)
			settings_page.pack_start(fr_pg1_head,false)
			
		
			#Add Priority		
			hb = Gtk::HBox.new(false,1)
			hb.pack_start(Gtk::Alignment.new(1,0,0,0).add(Gtk::Label.new('Priority : ')).set_width_request(75))
			strPriority = "#{bodyPart[0]}Priority"
			hb.pack_start(gtk_global[strPriority].set_width_request(70),false)
			vb_pg1_head.pack_start(hb,false)
			#MAdd Max Wound
			hb = Gtk::HBox.new(false,1)
			hb.pack_start(Gtk::Alignment.new(1,0,0,0).add(Gtk::Label.new('Max Wound : ')).set_width_request(75))
			strMaxWound = "#{bodyPart[0]}MaxWound"
			hb.pack_start(gtk_global[strMaxWound].set_width_request(70),false)
			vb_pg1_head.pack_start(hb,false)
			#Add Max Scar
			hb = Gtk::HBox.new(false,1)
			hb.pack_start(Gtk::Alignment.new(1,0,0,0).add(Gtk::Label.new('Max Scar : ')).set_width_request(75))
			strmaxScar = "#{bodyPart[0]}MaxScar"
			hb.pack_start(gtk_global[strmaxScar].set_width_request(70),false)
			vb_pg1_head.pack_start(hb,false)
			
			settings_page.pack_start(vb_pg1_head,false)
	
		end
			
		vb_pg1_1 = Gtk::HBox.new(false,1).set_border_width(3)
		fr_pg1_1 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Options </b></big>'))
		fr_pg1_1.add(vb_pg1_1)
		settings_page.pack_start(fr_pg1_1,false)
		
		hb = Gtk::VBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(0,0,0,0).add(Gtk::Label.new('Max Bleed Rate : ')).set_width_request(75))
		hb.pack_start(gtk_global['maxBleedRate'],false).set_width_request(75)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::VBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(0,0,0,0).add(Gtk::Label.new('Min Health % : ')).set_width_request(75))
		hb.pack_start(gtk_global['minimumhealth'],false).set_width_request(75)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Continuous? : ')).set_width_request(75))
		hb.pack_start(gtk_global['maintainHealing'],false)
		vb_pg1_1.pack_start(hb,false)
		
		b = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Debug? : ')).set_width_request(75))
		hb.pack_start(gtk_global['debugEnabled'],false)
		vb_pg1_1.pack_start(hb,false)
				
		
		vb_pg1_1 = Gtk::VBox.new(false,1).set_border_width(3)
		fr_pg1_1 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Control </b></big>'))
		fr_pg1_1.add(vb_pg1_1)
		settings_page.pack_start(fr_pg1_1,false)
					
		hb = Gtk::HBox.new(false,1)
		lbl = Gtk::Label.new.set_markup("Mouse over each box for more help")
		lbl.set_wrap(true).set_padding(0,10)
		vb_pg1_1.pack_start(lbl,false)
		
		hb_saveclose = Gtk::VBox.new(false,1)
		save = Gtk::Button.new('_Save & Close').set_width_request(50)
		close = Gtk::Button.new('E_xit').set_width_request(50)
		save.signal_connect('clicked') { window_action = :save }
		close.signal_connect('clicked') { window_action = :done }
		hb_saveclose.pack_start(save,false)
		hb_saveclose.pack_start(close,false)
		
		vb_pg1_1.pack_start(hb_saveclose,false)
				
		
		# Primary VerticalBox to split up Notebook and Save/Close buttons
		#vb_main = Gtk::VBox.new(false,1)
		#vb_main.border_width = 3
		
		#vb_main.pack_start(nb,false)
		#vb_main.pack_start(hb_saveclose,false)
		
		window.signal_connect('delete_event') { window_action = :exit }
		
		#window.add(vb_main)	
		
		
		window.add(settings_page)
		
		
		window.show_all
		window.keep_above = true # On windows keep_above is required AFTER show_all
		
	}
	
	before_dying { Gtk.queue { window.destroy } }
	wait_while { window_action.nil? }
	undo_before_dying
	Gtk.queue { window.destroy }
	clean_entry = proc { |entry|
		entry.text = entry.text.strip
		if entry.text.empty?
			entry.text = nil
		end
		
		entry.text
	}
		
	if window_action == :save		
		gtk_global.each_pair { |option,widget|
			
			if widget.class == Gtk::CheckButton
				settings[option] = widget.active?
			elsif widget.class == Gtk::Entry
				settings[option] = clean_entry.call(widget)
			elsif widget.class == Gtk::ComboBox
				settings[option] = widget.active
			else
				echo "error: unknown local widget #{option} [#{widget.class}]"
			end
		}
		#check_settings(settings)
		
		echo 'settings saved'
		exit
	else
		echo 'closed without saving'
		exit
	end
}

def monitor_interaction()
        #if @MONITOR_INTERACTION
start_exec_script( <<-eos
	def show_window(line);
	window_title = Char.name + ':' + line;
	Gtk.queue {
		$myWindow = Gtk::Window.new;
		$myWindow.title = "Autobot Alert!";
		$myWindow.set_size_request(450, 25);
		label = Gtk::Label.new window_title;
		$myWindow.add(label);
		$myWindow.show_all;
	};
	end;
	while(line = get);
		break unless running?('smartheal');
		if(line =~ /SEND|POLICY|[Rr](\s)*[Ee](\s)*[Pp](\s)*[Oo](\s)*[Rr](\s)*[Tt]|peaking to you|unresponsive|taps you|nods to you|lease respond|not in control|character|violation|lease speak|peak out loud|Y U SHOU D|whispers,|speaking to you|smiles at you|waves to you|grins at you|hugs you|takes hold your hand|grabs your hand|clasps your hand|trying to drag you/);
			unless(line =~ /LNet/);
				show_window(line);
				echo "AUTOBOT ALERT: " + line;
			end;
		end;
	end;
	eos
)
end


before_dying {
	echo "exiting SmartHeal"
} 

def debugLog(actuallySend,codeSegment,messageToSend)
	if actuallySend
		echo "#{codeSegment} - #{messageToSend}"
	end

end

def self.cleanup
    [DownstreamHook, UpstreamHook].each{|provider|
        provider.list.find_all{|name| name.start_with?('SmartHeal::')}.each{|name| provider.remove(name)}
    }
end


def CheckHealth(settings)
	while percenthealth < settings['minimumhealth'].to_i
		echo "Your health is at #{percenthealth} which is below #{settings['minimumhealth']} so going to heal blood first."
		#the math on this isnt working as i expected for some reason and not rounding rpoeprly so i am fudging it by adding in .5
		manaNeeded = 0.to_f
		manaNeeded = (((Char.level * 2)/10) + 0.5).ceil
		echo "expecting to heal up to #{(Char.level * 2)}"
		echo "expected mana cost to heal blood is #{manaNeeded}"
		wait_while { (checkmana < 1 and Char.level < 6) or checkmana < manaNeeded }
		waitrt?
		waitcastrt?
		fput "cure blood"
		pause 3
	end
end


def self.anon_hook(prefix = '')
        now = Time.now
        "SmartHeal::#{prefix}-#{now.tv_sec}.#{now.tv_usec}-#{Random.rand(10000)}"
    end

def quiet_command(command, start_pattern, end_pattern = /<prompt/, include_end = true, timeout=5)
  result = []
  name = self.anon_hook
  filter = false

  begin
      Timeout::timeout(timeout, Interrupt) {
          DownstreamHook.add(name, proc {|xml|
              if filter
                  if xml =~ end_pattern
                      DownstreamHook.remove(name)
                      filter = false
                      # result << xml.rstrip if include_end
                      # thread.raise(Interrupt)
                      # next(include_end ? nil : xml)
                  else
                      # result << xml.rstrip
                      next(nil)
                  end
              elsif xml =~ start_pattern
                  filter = true
                  # result << xml.rstrip
                  next(nil)
              else
                  xml
              end
          })
          fput command

          until (xml = get) =~ start_pattern; end
          result << xml.rstrip
          until (xml = get) =~ end_pattern
              result << xml.rstrip
          end
          if include_end
              result << xml.rstrip
          end
      }
  rescue Interrupt
      nil
  end
  return result
end


def parseBleedingPerRound(settings,result)
	#result = reget 30, "#{location}  "
	#echo result
	result = result.split()
	debugLog(settings['debugEnabled'],"parseBleedingPerRound", "parseBleedingPerRound Whole Result #{result}")
	debugLog(settings['debugEnabled'],"parseBleedingPerRound", "parseBleedingPerRound 1st Result Part #{result[0]}")
	debugLog(settings['debugEnabled'],"parseBleedingPerRound", "parseBleedingPerRound Location #{result[0].downcase}")
	if result[0].downcase == "left" or result[0].downcase == "right"
		#if getLongName(location.downcase) == "#{result[0].downcase} #{result[1].downcase}"
			
			
			if result[2] == nil
				debugLog(settings['debugEnabled'],"parseBleedingPerRound", "parseBleedingPerRound 2-part location bleeding = nil,nil" )
				return [nil,nil]
			elsif result[3] == "of"
				debugLog(settings['debugEnabled'],"parseBleedingPerRound", "parseBleedingPerRound 2-part location bleeding annd tended = #{result[0]} #{result[1]} - #{result[4]}" )
				return [getShortName("#{result[0].downcase} #{result[1].downcase}"), result[4]]
			else 
				debugLog(settings['debugEnabled'],"parseBleedingPerRound", "parseBleedingPerRound 2-part location bleeding = #{result[0]} #{result[1]} - #{result[2]}" )
				return [getShortName("#{result[0].downcase} #{result[1].downcase}"), result[2]]
			end	
			debugLog(settings['debugEnabled'],"parseBleedingPerRound",  "Sided Result is #{result[2]} as shown in #{location} as #{bleedLevels[location]}")
		#end
	else
		#if getLongName(location.downcase) == "#{result[0].downcase}"
			
			if result[1] == nil
				debugLog(settings['debugEnabled'],"parseBleedingPerRound", "parseBleedingPerRound 1-part location bleeding = nil,nil")
				return [nil,nil]
			elsif result[2] == "of"
				debugLog(settings['debugEnabled'],"parseBleedingPerRound", "parseBleedingPerRound 1-part location bleeding and tended = #{result[0]} - #{result[3]}")
				return [getShortName("#{result[0].downcase}"), result[3]]
			else
				debugLog(settings['debugEnabled'],"parseBleedingPerRound", "parseBleedingPerRound 1-part location bleeding = #{result[0]} - #{result[1]}" )
				return [getShortName("#{result[0].downcase}"), result[1]]
			end	
			debugLog(settings['debugEnabled'],"parseBleedingPerRound", "Single Result is #{result[1]} as shown in #{location} as #{bleedLevels[location]}")
		#end
	end
	

	
end


def updateInjuriesBleeding(settings,injuryDetails)
	#check our health and get the bleeding status and amount for each location
	if bleeding?
		result = quiet_command(
	          "health",
	          /^(?:You seem to be in one piece.)|You have the following injuries:|You have the following scars:/,
	          /(?:<prompt)|Remaining Stamina Points: [0-9]*/,
	          # /(?:<prompt)|(?:items displayed.\)\b)/,
	          false,
	          5
	      )
	  debugLog(settings['debugEnabled'],"updateInjuriesBleeding", "Start Result Output #{result}")
	  #We need to clear the bleeding ebfore we parse through it again to remove bleedin that no longer exists)
	  injuryDetails.each do |area|
			injuryDetails[area[0].downcase].bleedLevel = 0
			end 
		x = 0
		debugLog(settings['debugEnabled'],"updateInjuriesBleeding", "Result Length = #{result.length.to_s}")
		while x < result.length
		 	debugLog(settings['debugEnabled'],"updateInjuriesBleeding", "Result #{x} #{result[x]}")
			x += 1
			parsedBleed = parseBleedingPerRound(settings,result[x])
				
			debugLog(settings['debugEnabled'],"updateInjuriesBleeding", "Parsed Bleed Location = #{parsedBleed[0]}")
			debugLog(settings['debugEnabled'],"updateInjuriesBleeding", "Parsed Bleed Amount = #{parsedBleed[1]}")
						
			injuryDetails.each do |area|
				debugLog(settings['debugEnabled'],"updateInjuriesBleeding", "updateInjuriesBleeding #{area} #{area[0].downcase}")
				#injuryDetails[area[0]].bleedLevel =  	1		
				
				#injuryDetails = HealthPerRound(area[0].downcase,injuryDetails, result[x] )
				if area[0].downcase == parsedBleed[0]
					debugLog(settings['debugEnabled'],"updateInjuriesBleeding", "Area #{area[0].downcase} - #{area[1].bleedLevel.to_s}")
					injuryDetails[area[0].downcase].bleedLevel = parsedBleed[1]
				end 
			end
		end
	end
	#loops though body locations for bleeding
	#echo bleedLevels
	
	
	
	#show bleeding in order of highest to lowest (use this in our loop for prioritizing also)
	
	debugLog(settings['debugEnabled'],"updateInjuriesBleeding","Starting"	)
	debugLog(settings['debugEnabled'],"updateInjuriesBleeding",injuryDetails.sort_by{ |k, v| v.bleedLevel.to_s}.to_h)
	debugLog(settings['debugEnabled'],"updateInjuriesBleeding","Completed"	)	
	return injuryDetails
#end
	

end



def getWoundLevel(body_Location)
	
	if body_Location == "head"
		return Wounds.head
	elsif body_Location == "nerves"
		return Wounds.nerves
	elsif body_Location == "neck"
		return Wounds.neck
	elsif body_Location == "chest"
		return Wounds.chest
	elsif body_Location == "abdomen"
		return Wounds.abdomen
	elsif body_Location == "la"
		return Wounds.leftArm
	elsif body_Location == "ra"
		return Wounds.rightArm
	elsif body_Location == "lh"
		return Wounds.leftHand
	elsif body_Location == "rh"
		return Wounds.rightHand
	elsif body_Location == "ll"
		return Wounds.leftLeg
	elsif body_Location == "rl"
		return Wounds.rightLeg
	elsif body_Location == "back"
		return Wounds.back
	elsif body_Location == "le"
		return Wounds.leftEye
	elsif body_Location == "re"
		return Wounds.rightEye
	else
		return 0
	end
	
end

def getScarLevel(body_Location)
	
	if body_Location == "head"
		return Scars.head
	elsif body_Location == "nerves"
		return Scars.nerves
	elsif body_Location == "neck"
		return Scars.neck
	elsif body_Location == "chest"
		return Scars.chest
	elsif body_Location == "abdomen"
		return Scars.abdomen
	elsif body_Location == "la"
		return Scars.leftArm
	elsif body_Location == "ra"
		return Scars.rightArm
	elsif body_Location == "lh"
		return Scars.leftHand
	elsif body_Location == "rh"
		return Scars.rightHand
	elsif body_Location == "ll"
		return Scars.leftLeg
	elsif body_Location == "rl"
		return Scars.rightLeg
	elsif body_Location == "back"
		return Scars.back
	elsif body_Location == "le"
		return Scars.leftEye
	elsif body_Location == "re"
		return Scars.rightEye
	else
		return 0
	end
	
end

def getBaseManaCost(body_Location)
	
	if body_Location == "head"
		return 4
	elsif body_Location == "nerves"
		return 3
	elsif body_Location == "neck"
		return 4
	elsif body_Location == "chest"
		return 5
	elsif body_Location == "abdomen"
		return 5
	elsif body_Location == "la"
		return 2
	elsif body_Location == "ra"
		return 2
	elsif body_Location == "lh"
		return 2
	elsif body_Location == "rh"
		return 2
	elsif body_Location == "ll"
		return 2
	elsif body_Location == "rl"
		return 2
	elsif body_Location == "back"
		return 5
	elsif body_Location == "le"
		return 5
	elsif body_Location == "re"
		return 5
	else
		#return 5 just in cast we messed up somewhere as a failsafe
		return 5
	end
	
end

def getLongName(body_Location)
	
	if body_Location == "head"
		return "head"
	elsif body_Location == "nerves"
		return "nerves"
	elsif body_Location == "neck"
		return "neck"
	elsif body_Location == "chest"
		return "chest"
	elsif body_Location == "abdomen"
		return "abdomen"
	elsif body_Location == "la"
		return "left arm"
	elsif body_Location == "ra"
		return "right arm"
	elsif body_Location == "lh"
		return "left hand"
	elsif body_Location == "rh"
		return "right hand"
	elsif body_Location == "ll"
		return "left leg"
	elsif body_Location == "rl"
		return "right leg"
	elsif body_Location == "back"
		return "back"
	elsif body_Location == "le"
		return "left eye"
	elsif body_Location == "re"
		return "right eye"
	else
		return 0
	end
	
end

def getShortName(body_Location)
	
	if body_Location == "head"
		return "head"
	elsif body_Location == "nerves"
		return "nerves"
	elsif body_Location == "neck"
		return "neck"
	elsif body_Location == "chest"
		return "chest"
	elsif body_Location == "abdomen"
		return "abdomen"
	elsif body_Location == "left arm"
		return "la"
	elsif body_Location == "right arm"
		return "ra"
	elsif body_Location == "left hand"
		return "lh"
	elsif body_Location == "right hand"
		return "rh"
	elsif body_Location == "left leg"
		return "ll"
	elsif body_Location == "right leg"
		return "rl"
	elsif body_Location == "back"
		return "back"
	elsif body_Location == "left eye"
		return "le"
	elsif body_Location == "right eye"
		return "re"
	else
		return 0
	end
	
end


def checkBusy
	#We want to check if we have an offer outstanding, transferring wounds, appraising someone, and 
	#ideally, casting a non-healing spell like unstun, unpoison, undisease, manabread, etc
	
	
	
	
	return false
	
end

def checkForActivities(settings)
	#This is what i want to call to see if we have anything we are doing that should delay the next loop in healing
	#things like:
	#	- meditating
	# - Being offered something to accept
	# - Trying to transfer a wound (or set of wounds)
	# - Trying to Appraise a target
	debugLog(settings['debugEnabled'],"checkForActivities","checkForActivities at #{Time.now.to_s}")
	
	
	
	return false
end



class Injury

	def initialize(shortLocation)
  	@shortLocation = shortLocation
  end
	
	def shortLocation
		@shortLocation
	end
	
	def woundPriority
		@woundPriority
	end
	
	def woundPriority=(woundPriority)
		@woundPriority = woundPriority
	end
	
	def scarPriority
		@scarPriority
	end
	
	def scarPriority=(scarPriority)
		@scarPriority = scarPriority
	end
	
	def woundLevel
		@woundLevel
	end
	
	def woundLevel=(woundLevel)
		@woundLevel = woundLevel
	end
	
	def bleedLevel
		@bleedLevel
	end
	
	def bleedLevel=(bleedLevel)
		@bleedLevel = bleedLevel
	end

	def scarLevel
		@scarLevel
	end
	
	def scarLevel=(scarLevel)
		@scarLevel = scarLevel
	end

end
def updateInjuriesWounds(settings,force_setting,injuryDetails)
	force_setting['max_wound_level'] = 0
	injuryDetails.each do |area|
		localWoundLevel = getWoundLevel(area[0])
		injuryDetails[area[0]].woundLevel = getWoundLevel(area[0])
		if localWoundLevel > force_setting['max_wound_level'] then force_setting['max_wound_level'] = localWoundLevel end
	
		
		debugLog(settings['debugEnabled'],"updateInjuriesWounds", "Area #{area[0].downcase} - #{area[1].bleedLevel.to_s}")
		#injuryDetails[area[0].downcase].bleedLevel = result[x]
			
	end
	return injuryDetails

end

def updateInjuriesScars(settings,force_setting,injuryDetails)
	force_setting['max_scar_level'] = 0
	injuryDetails.each do |area|
		localScarLevel = getScarLevel(area[0])
		injuryDetails[area[0]].scarLevel = localScarLevel
		if localScarLevel > force_setting['max_scar_level'] then force_setting['max_scar_level'] = localScarLevel end
		
		debugLog(settings['debugEnabled'],"updateInjuriesScars", "Area #{area[0].downcase} - #{area[1].bleedLevel.to_s}")
		#injuryDetails[area[0].downcase].bleedLevel = result[x]
		
	end
	return injuryDetails
end


def updateInjuryDetails(settings,force_setting,injuryDetails)
	#need to reset bleeding here
	injuryDetails.each do |area|
		injuryDetails[area[0].downcase].bleedLevel = 0
	end 
	#echo injuryDetails
	
	injuryDetails = updateInjuriesBleeding(settings,injuryDetails)
	injuryDetails = updateInjuriesWounds(settings,force_setting,injuryDetails)
	injuryDetails = updateInjuriesScars(settings,force_setting,injuryDetails)
	#echo "updateInjuryDetails current status = #{injuryDetails}"
	return injuryDetails
end

def healScar(settings, injuryDetail)	
	CheckHealth(settings)
	manaModifier = 9
	if injuryDetail[1].scarLevel > 1 then manaModifier += 5 end
	totalManaCost = getBaseManaCost(injuryDetail[1].shortLocation) + manaModifier
	echo "healScar - Total Heal Scar Mana Cost for #{injuryDetail[1].shortLocation} Severity of #{injuryDetail[1].scarLevel.to_s} is #{totalManaCost.to_s}"
	while checkmana < totalManaCost
		CheckHealth(settings)		
		pause 5
	end
	
	waitrt?
	waitcastrt?
	#this is here to use for a test mechanism only to pretend like we are healing something and verify detection
	actually_heal = true
	if actually_heal
		fput "cure #{getLongName(injuryDetail[1].shortLocation)}"
	else
		debugLog(settings['debugEnabled'],"healScar","Would have cast 'cure #{getLongName(injuryDetail[1].shortLocation)}'" )
	end
	pause 3

end

def healWound(settings, injuryDetail)	
	CheckHealth(settings)
	manaModifier = 0
	if injuryDetail[1].woundLevel > 1 then manaModifier += 5 end
	totalManaCost = getBaseManaCost(injuryDetail[1].shortLocation) + manaModifier
	echo "healWound - Total Heal Wound Mana Cost for #{injuryDetail[1].shortLocation} Severity of #{injuryDetail[1].woundLevel.to_s} is #{totalManaCost.to_s}"
	
	while checkmana < totalManaCost
		CheckHealth(settings)		
		pause 5
	end
	
	waitrt?
	waitcastrt?
	#this is here to use for a test mechanism only to pretend like we are healing something and verify detection
	actually_heal = true
	if actually_heal and getWoundLevel(injuryDetail[1].shortLocation) > 0
		fput "cure #{getLongName(injuryDetail[1].shortLocation)}"
	else
		debugLog(settings['debugEnabled'],"healWound","Would have cast 'cure #{getLongName(injuryDetail[1].shortLocation)}'" )
	end
	pause 3
end

def healInjuries(settings,force_setting,injuryDetails)
	#Start with Bleeding Injuries
	injuryDetails = updateInjuryDetails(settings,force_setting,injuryDetails)
	debugLog(settings['debugEnabled'],"healInjuries",injuryDetails)
	sortedInjuries = injuryDetails.sort_by{ |k, v| v.bleedLevel.to_i}.reverse.to_h
	sortedInjuries.each do |injuryDetail|
		debugLog(settings['debugEnabled'],"healInjuries-Bleeding Injuries",injuryDetail)
		if injuryDetail[1].bleedLevel.to_i >= settings['maxBleedRate'].to_i
			healWound(settings, injuryDetail)	
			return true
		end 	
	
	end
	injuryDetails = updateInjuryDetails(settings,force_setting,injuryDetails)
	#Next heal injuries above allowed for the location by priority
		sortedInjuries = injuryDetails.sort_by{ |k, v| v.woundPriority.to_i}.to_h
		sortedInjuries.each do |injuryDetail|
		debugLog(settings['debugEnabled'],"healInjuries-Injuries",injuryDetail)
		if (injuryDetail[1].woundLevel.to_i > settings["#{injuryDetail[1].shortLocation}MaxWound"].to_i) or (force_setting['force_wound_level'].to_i >= 0 and (injuryDetail[1].woundLevel.to_i > force_setting['force_wound_level'].to_i))
			#echo "Max Wound"
			#echo settings["#{injuryDetail[1].shortLocation}MaxWound"]
			healWound(settings, injuryDetail)	
			return true
		end 	
	
	end
	injuryDetails = updateInjuryDetails(settings,force_setting,injuryDetails)
	#Next heal scars above allowed for the location by priority
	sortedInjuries = injuryDetails.sort_by{ |k, v| v.scarPriority.to_i}.to_h
	sortedInjuries.each do |injuryDetail|
		debugLog(settings['debugEnabled'],"healInjuries-Scars",injuryDetail)
		
		if (injuryDetail[1].scarLevel.to_i > settings["#{injuryDetail[1].shortLocation}MaxScar"].to_i) or (force_setting['force_scar_level'].to_i >= 0 and (injuryDetail[1].scarLevel.to_i > force_setting['force_scar_level'].to_i))
			#echo "Max Scar"
			#echo settings["#{injuryDetail[1].shortLocation}MaxWound"]
			healScar(settings, injuryDetail)	
			return true
		end 	
	
	end
end

def getMaxWoundLevel(injuryDetails)
	maxLevel = 0
	injuryDetails.each do |injuryDetail|
			echo injuryDetail
		if injuryDetail[1].woundLevel.to_i >= maxLevel
			echo injuryDetail[1].woundlevel.to_s
			maxLevel = injuryDetail[1].woundlevel.to_i
		end
		#if we are already at max then no sense going through the rest
		if maxLevel == 3 then return maxLevel end
	end
	return maxLevel
end

def getMaxScarLevel(injuryDetails)
	maxLevel = 0
	injuryDetails.each do |injuryDetail|
		if injuryDetail[1].scarLevel.to_i >= maxLevel
			maxLevel = injuryDetail[1].scarlevel.to_i
		end
		#if we are already at max then no sense going through the rest
		if maxLevel == 3 then return maxLevel end
	end
	return maxLevel
end

doLoopEnable = true

heal_loop = proc {
	while doLoopEnable == true 	
		debugLog(settings['debugEnabled'],"heal_loop","Starting a Loop Cycle")
		#make sure we have enough health to keep healing
		CheckHealth(settings)
		injuryDetails = updateInjuryDetails(settings,force_setting,injuryDetails)
		debugLog(settings['debugEnabled'],"heal-loop",injuryDetails.sort_by{ |k, v| v.bleedLevel.to_i}.reverse.to_h)
		healSuccess = healInjuries(settings,force_setting,injuryDetails)
		debugLog(settings['debugEnabled'],"heal_loop","healSuccess Result = #{healSuccess}")	
		injuryDetails = updateInjuryDetails(settings,force_setting,injuryDetails)
		if settings['debugEnabled']
			debugLog(settings['debugEnabled'],"heal_loop","Stopping after 1 Execution in debug mode otherwisee the logging scrolls the screen so fast it will crash the GUI")	
			#exit
		end
		
			
		
		doLoopEnable = settings['maintainHealing']
		#echo "doLoopStatus = #{settings['maintainHealing']}"
		if (force_setting['force_wound_level'] >= 0 and force_setting['max_wound_level'] <= force_setting['force_wound_level']) 
			#echo "Wound 0,0 caused loopEnable False"
			doLoopEnable = false
		
		elsif (force_setting['force_scar_level'] >= 0 and force_setting['max_scar_level'] <= force_setting['force_scar_level'])
			#echo "Scar 0,0 caused loopEnable False"
			doLoopEnable = false
		else	
			#Nothing to do here just a placeholder for if needed in the future
		end
	end
}

activy_loop = proc {
	echo "Starting activity Loop"
	heal_thread =  Thread.new{heal_loop.call}	
	
	
	
	echo "Ending activity Loop"
}

#hash to track everything for body locations

echo "loading Injury Hash with Class Objects"
#Loadup my instance of Injuries from my settings
guiBodyPartElements.each do |bodyPart|
	debugLog(settings['debugEnabled'],"Main","Adding #{bodyPart[0]}Priority to priority list")
	
	injuryDetail = Injury.new(bodyPart[0].to_s)
	injuryDetail.woundPriority = settings["#{bodyPart[0]}Priority"]
	injuryDetail.scarPriority = settings["#{bodyPart[0]}Priority"]
	injuryDetail.woundLevel = 0
	injuryDetail.scarLevel = 0
	injuryDetail.bleedLevel = 0
	injuryDetails[bodyPart[0]] = injuryDetail
end

#Want to echo the unsorted versions we can figure out soring by wound priority
#echo injuryDetails

debugLog(settings['debugEnabled'],"main", "attempt to display each sorted item from injuryDetails")
injuryDetails.sort_by{ |k, v| v.woundPriority.to_i}.to_h.each do |injuryDetail|
	debugLog(settings['debugEnabled'],"main", injuryDetail)
end
debugLog(settings['debugEnabled'],"main", "Done trying to output sorted items from injuryDetails")


debugLog(settings['debugEnabled'],"Main",injuryDetails.sort_by{ |k, v| v.woundPriority}.to_h)
before_dying {
    self.cleanup
 
}


	
if variable[0] =~ /setup|config|configure/i
	setup.call
	exit
elsif variable[0] =~ /wound|wounds/i
	echo "Wound Level to Heal is #{variable[1].to_s}"
	if variable[1].to_i == nil 
		force_setting['force_wound_level'] = 0
		echo "Force Healing Wounds down to a level of #{force_setting['force_wound_level'].to_s}"
	elsif variable[1].to_i >= 0 and variable[1].to_i <= 3
		force_setting['force_wound_level'] = variable[1].to_i
		echo "Force Healing Wounds down to a level of #{force_setting['force_wound_level'].to_s}"
	end
	heal_loop.call

elsif variable[0] =~ /scar|scars/i
		echo "Scar Level to Heal is #{variable[2].to_s}"
	if variable[2].to_i == nil 
		force_setting['force_scar_level'] = 0
		echo "Force Healing Scars down to a level of #{force_setting['force_scar_level'].to_s}"
	elsif variable[2].to_i >= 0 and variable[2].to_i <= 3
		force_setting['force_scar_level'] = variable[2].to_i
		echo "Force Healing Scars down to a level of #{force_setting['force_scar_level'].to_s}"
	end
	heal_loop.call
	
elsif variable[0] =~ /all|any/i
	echo "Wound and Scar Level to Heal is #{variable[2].to_s}"
	if variable[2].to_i == nil 
		force_setting['force_scar_level'] = 0
		force_setting['force_wound_level'] = 0
		echo "Force Healing Wounds down to a level of #{force_setting['force_wound_level'].to_s}"
		echo "Force Healing Scars down to a level of #{force_setting['force_scar_level'].to_s}"

	elsif variable[2].to_i >= 0 and variable[2].to_i <= 3
		force_setting['force_scar_level'] = variable[2].to_i
		force_setting['force_wound_level'] = variable[2].to_i
		echo "Force Healing Wounds down to a level of #{force_setting['force_wound_level'].to_s}"
		echo "Force Healing Scars down to a level of #{force_setting['force_scar_level'].to_s}"

	end
	heal_loop.call
	
else
	echo "starting to heal in the loop"
	
	heal_loop.call
	
	exit
end