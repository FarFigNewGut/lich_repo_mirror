=begin

   This script waits for you to kill something, and then it skins (optional),
   searches, and picks up loot.

   ;loot help

    author: Tillmen (tillmen@lichproject.org)
      game: Gemstone
      tags: loot
   version: 0.26

   changelog:
      0.26 (2018-10-25):
         add get/put messages for vanishing point gowns
      0.25 (2018-08-23):
         add a message for skin failure due to lack of blunt weapon
      0.24 (2018-08-20):
         fix bug with safe-kneel (Tysong)

=end
=begin

      0.23 (2017-10-08):
         add category of monster that is skinnable by both edged and blunt weapons: use blunt weapons when available
      0.22 (2017-10-01):
         start using exclude setting on Confluence drops
      0.21 (2017-01-14):
         recognized delayed acid (904) kills
      0.20 (2016-09-17):
         add option to not use your disk
      0.19 (2016-05-05):
         add another message to recognize Maelstrom
      0.18 (2015-07-22):
         add support for Pestilence (716)
      0.17 (2015-07-11):
         make sure $loot_working gets set to false if the script is killed
      0.16 (2015-06-04):
         add support for climatewear
      0.15 (2015-04-27):
         make various settings take effect when changed while the script is running
      0.14 (2014-04-02):
         pick up alchemy reagents in the Elemental Confluence
      0.13 (2015-04-01):
         recognize spirit slayer kills
      0.12 (2015-04-01):
         pick up gems in the Elemental Confluence
      0.11 (2015-03-30):
         fix for picking up things knocked out of a monster's hands
      0.10 (2015-02-01):
         fix bug when setting skinweapon and bluntskinweapons
      0.9 (2015-01-31):
         add new loot type (valuable) to default settings
      0.8 (2015-01-28):
         don't evaluate 740 as an attack (basically freezes when the room is completely full)
      0.7 (2015-01-22):
         added ignore-creatures option (Calael)
         added option to stow herbs in herbsack
         don't phase enruned and mithril boxes
         recognize sorcerer sacrifice deaths
         change sack settings using this script instead of ;settings or ;vars
         pick up things that creatures drop even if the attack that causes the drop doesn't kill them
      0.6 (2014-12-05):
         make safe-kneel ignore passive npcs
      0.5 (2014-11-26):
         fix safe-kneel option
      0.4 (2014-11-10):
         added support for a scripted container
      0.3 (2014-10-01):
         don't loot infernal liches

=end

# todo: setting for items to loot, rather than items to exlude

if defined?(GameObj.type_data)
   GameObj.load_data if GameObj.type_data.empty? or GameObj.type_data.nil?
   if GameObj.type_data.nil?
      wait_while { running?('repository') }
      start_script 'repository', [ 'download', 'gameobj-data.xml' ]
      wait_while { running?('repository') }
      GameObj.load_data
      exit if GameObj.type_data.nil?
   end
end

$loot_settings = char_settings = CharSettings.to_hash

Settings['unskinnable']          = Array.new if Settings['unskinnable'].nil?
Settings['blunt-skinnable']      = Array.new if Settings['blunt-skinnable'].nil?
Settings['free-hand-skinnable']  = Array.new if Settings['free-hand-skinnable'].nil?
CharSettings['skin']             = true      if CharSettings['skin'].nil?
CharSettings['604']              = false     if CharSettings['604'].nil?
CharSettings['safe-kneel']       = false     if CharSettings['safe-kneel'].nil?
CharSettings['kneel']            = false     if CharSettings['kneel'].nil?
CharSettings['stance']           = false     if CharSettings['stance'].nil?
CharSettings['empty']            = false     if CharSettings['empty'].nil?
CharSettings['never-empty']      = false     if CharSettings['never-empty'].nil?
CharSettings['phase-boxes']      = false     if CharSettings['phase-boxes'].nil?
CharSettings['disk-boxes']       = true      if CharSettings['disk-boxes'].nil?
CharSettings['get-arrows']       = false     if CharSettings['get-arrows'].nil?
CharSettings['eblade-arrows']    = false     if CharSettings['eblade-arrows'].nil?
CharSettings['use-ambrominas']   = true      if CharSettings['use-ambrominas'].nil?
CharSettings['ignore-creatures'] = 'ice golem|fire elemental|skayl|lava golem|mein golem|mein android|infernal lich|frostborne lich' if CharSettings['ignore-creatures'].nil?
CharSettings['loot-types']       = 'gem|skin|reagent|herb|jewelry|valuable|magic|scroll|wand|uncommon|box' if CharSettings['loot-types'].nil?

likely_bundle_id_list   = Hash.new
injures_on_skin_regex   = /^(?:myklian)$/
injures_on_search_regex = /^(?:myklian|magru|glacei)$/
free_hand_search_regex  = /^(?:glacei)$/
put_regex               = /^You (?:attempt to shield .*? from view as you |discreetly |carefully |absent-mindedly )?(?:put|place|slip|tuck|add|hang|drop|untie your|find an incomplete bundle|wipe off .*? and sheathe)|^With a nimble flick of your wrist, you slip|^A sigh of grateful pleasure can be heard as you feed .*? to your|^As you place|^I could not find what you were referring to\.$|^Your bundle would be too large|^The .+ is too large to be bundled\.|^As you place your|^The .*? is already a bundle|^Your .*? won't fit in .*?\.$|^You can't .+ It's closed!$|^You need a free hand to pick that up\./
get_regex               = /^You (?:shield the opening of .*? from view as you |discreetly |sleekly |carefully |deftly )?(?:remove|draw|grab|reach|slip|tuck|retrieve|already have|unsheathe|pick up)|^Get what\?$|^Why don't you leave some for others\?$|^You need a free hand|^I could not find what you were referring to\./
skinweapon              = nil
skinweaponsack          = nil
bluntskinweapon         = nil
bluntskinweaponsack     = nil
both_skinnable          = [ 'stone mastiff' ] # can be skinned with both edged or blunt: use blunt if available
script_name             = script.name
lootsack_list           = Array.new
herbsack                = nil
arrowsack               = nil
$loot_working           = false

show_settings = proc {
   fix_setting = { true => 'on', false => 'off' }
   output = String.new
   output.concat "skin:             #{fix_setting[char_settings['skin']]}\n"
   output.concat "604:              #{fix_setting[char_settings['604']]}\n"
   output.concat "kneel:            #{fix_setting[char_settings['kneel']]}\n"
   output.concat "safe-kneel:       #{fix_setting[char_settings['safe-kneel']]}\n"
   output.concat "stance:           #{fix_setting[char_settings['stance']]}\n"
   output.concat "empty:            #{fix_setting[char_settings['empty']]}\n"
   output.concat "never-empty:      #{fix_setting[char_settings['never-empty']]}\n"
   output.concat "phase-boxes:      #{fix_setting[char_settings['phase-boxes']]}\n"
   output.concat "disk-boxes:       #{fix_setting[char_settings['disk-boxes']]}\n"
   output.concat "get-arrows:       #{fix_setting[char_settings['get-arrows']]}\n"
   output.concat "eblade-arrows:    #{fix_setting[char_settings['eblade-arrows']]}\n"
   output.concat "use-ambrominas:   #{fix_setting[char_settings['use-ambrominas']]}\n"
   output.concat "ignore-creatures: #{char_settings['ignore-creatures']}\n"
   output.concat "exclude:          #{char_settings['exclude']}\n"
   output.concat "loot-types:       #{char_settings['loot-types']}\n"
   output.concat "\n"
   output.concat "lootsack:            #{UserVars.lootsack}\n"
   lootsack_num = 2
   while (UserVars.send("lootsack#{lootsack_num}").class == String) and not UserVars.send("lootsack#{lootsack_num}").empty?
      output.concat "lootsack#{lootsack_num}:           #{UserVars.send("lootsack#{lootsack_num}")}\n"
      lootsack_num += 1
   end
   output.concat "skinweapon:          #{UserVars.skinweapon}\n"
   output.concat "skinweaponsack:      #{UserVars.skinweaponsack}\n"
   output.concat "bluntskinweapon:     #{UserVars.bluntskinweapon}\n"
   output.concat "bluntskinweaponsack: #{UserVars.bluntskinweaponsack}\n"
   output.concat "arrowsack:           #{UserVars.arrowsack}\n"
   output.concat "herbsack:            #{UserVars.herbsack}\n"
   respond output
}

show_help = proc {
   spacing = ''.ljust($lich_char.length + script.name.length, ' ')
   output = "\n"
   output.concat "#{$lich_char}#{script.name}                          waits for you to kill someting and loots it\n"
   output.concat "#{$lich_char}#{script.name} skin=<on/off>            skins before looting\n"
   output.concat "#{$lich_char}#{script.name} 604=<on/off>             cast 604 before skinning\n"
   output.concat "#{$lich_char}#{script.name} kneel=<on/off>           always kneels to skin\n"
   output.concat "#{$lich_char}#{script.name} safe-kneel=<on/off>      kneels to skin if no live npcs are in the room\n"
   output.concat "#{$lich_char}#{script.name} stance=<on/off>          changes to offensive stance to skin\n"
   output.concat "#{$lich_char}#{script.name} empty=<on/off>           empty left hand when skinning\n"
   output.concat "#{$lich_char}#{script.name} never-empty=<on/off>     empty hand preference is ignored for critters that\n"
   output.concat "#{spacing                 }                          cannot be skinned without an empty hand; use this\n"
   output.concat "#{spacing                 }                          setting to skip those critters\n"
   output.concat "#{$lich_char}#{script.name} phase-boxes=<on/off>     make boxes lighter\n"
   output.concat "#{$lich_char}#{script.name} disk-boxes=<on/off>      put boxes in your disk\n"
   output.concat "#{$lich_char}#{script.name} get-arrows=<on/off>      pick up the arrows you fire and put them in your\n"
   output.concat "#{spacing                 }                          arrowsack (or lootsack if arrowsack isn't set)\n"
   output.concat "#{$lich_char}#{script.name} eblade-arrows=<on/off>   eblade arrows when they fail to bundle\n"
   output.concat "#{$lich_char}#{script.name} use-ambrominas=<on/off>  eat ambrominas leaf after skinning or searching\n"
   output.concat "#{spacing                 }                          something that causes injury\n"
   output.concat "#{$lich_char}#{script.name} stow-herbs=<on/off>      put herbs in your herbsack\n"
   output.concat "#{$lich_char}#{script.name} ignore-creatures=<regex> regex of creatures not to loot automatically\n"
   output.concat "#{$lich_char}#{script.name} ignore-creatures=nil     clear ignore-creatures setting\n"
   output.concat "#{$lich_char}#{script.name} exclude=<regex>          regex of items not to pick up\n"
   output.concat "#{$lich_char}#{script.name} exclude=nil              clear exclude setting\n"
   output.concat "#{$lich_char}#{script.name} loot-types=<regex>       regex of the types of items to pick up\n"
   output.concat "#{$lich_char}#{script.name} loot-types=nil           reset loot types to the default\n"
   output.concat "\n"
   output.concat "#{$lich_char}#{script.name} lootsack=<container>\n"
   output.concat "#{$lich_char}#{script.name} lootsack2=<container>\n"
   output.concat "#{$lich_char}#{script.name} lootsack<num>=<container>\n"
   output.concat "#{$lich_char}#{script.name} skinweapon=<weapon>\n"
   output.concat "#{$lich_char}#{script.name} skinweaponsack=<container>\n"
   output.concat "#{$lich_char}#{script.name} bluntskinweapon=<weapon>\n"
   output.concat "#{$lich_char}#{script.name} bluntskinweaponsack=<container>\n"
   output.concat "#{$lich_char}#{script.name} arrowsack=<container>\n"
   output.concat "#{$lich_char}#{script.name} herbsack=<container>\n"
   output.concat "\n"
   respond output
}

find_lootsacks = proc {
   lootsack_list = Array.new
   lootsack_num = nil
   while (UserVars.send("lootsack#{lootsack_num}").class == String) and not UserVars.send("lootsack#{lootsack_num}").empty?
      if lootsack = GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.send("lootsack#{lootsack_num}").strip)}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.send("lootsack#{lootsack_num}")).sub(' ', ' .*')}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.send("lootsack#{lootsack_num}")).sub(' ', ' .*')}/i }
         lootsack_list.push(lootsack)
      else
         respond "[#{script_name}: warning: failed to find lootsack#{lootsack_num} (#{UserVars.send("lootsack#{lootsack_num}")})]"
      end
      lootsack_num = 1 if lootsack_num.nil?
      lootsack_num += 1
   end
}

find_skinning_equipment = proc {
   if (UserVars.skinweaponsack.nil? or UserVars.skinweaponsack.empty?)
      respond "[#{script_name}: warning: skinning is enabled, but skinweaponsack is not set.  (;#{script.name} skinweaponsack=<container name>)]"
      skinweaponsack = nil
      skinweapon = nil
   elsif(UserVars.skinweapon.nil? or UserVars.skinweapon.empty?)
      respond "[#{script_name}: warning: skinning is enabled, but skinweapon is not set.  (;#{script.name} skinweapon=<weapon name>)]"
      skinweaponsack = nil
      skinweapon = nil
   else
      unless skinweaponsack = GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.skinweaponsack.strip)}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.skinweaponsack).sub(' ', ' .*')}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.skinweaponsack).sub(' ', ' .*')}/i }
         dothistimeout "pull my #{UserVars.skinweaponsack}", 10, /^You pull|^You reach|^I'm afraid|^What were you referring to/
         dothistimeout "inventory", 10, /^You are wearing/
         if skinweaponsack = GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.skinweaponsack.strip)}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.skinweaponsack).sub(' ', ' .*')}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.skinweaponsack).sub(' ', ' .*')}/i }
            dothistimeout "push ##{skinweaponsack.id}", 10, /^You push|^You reach/
         end
      end
      if not skinweaponsack
         respond "[#{script_name}: warning: failed to find your skinweaponsack]"
         skinweaponsack = nil
         skinweapon = nil
      else
         if skinweaponsack.contents.nil?
            dothistimeout "look in ##{skinweaponsack.id}", 10, /^In the/
         end
         unless skinweapon = (skinweaponsack.contents | [ GameObj.right_hand, GameObj.left_hand ] | GameObj.containers.values.flatten).find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.skinweapon.strip)}$/i } || ([ GameObj.right_hand, GameObj.left_hand ] | GameObj.containers.values.flatten).find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.skinweapon).sub(' ', ' .*')}$/i } || (skinweaponsack.contents | [ GameObj.right_hand, GameObj.left_hand ] | GameObj.containers.values.flatten).find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.skinweapon).sub(' ', ' .*')}/i }
            respond "[#{script_name}: warning: failed to find your skinweapon]"
            skinweaponsack = nil
            skinweapon = nil
         end
      end
   end
   if UserVars.bluntskinweaponsack and UserVars.bluntskinweapon
      if bluntskinweaponsack = GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.bluntskinweaponsack.strip)}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.bluntskinweaponsack).sub(' ', ' .*')}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.bluntskinweaponsack).sub(' ', ' .*')}/i }
         if bluntskinweaponsack.contents.nil?
            dothistimeout "look in ##{bluntskinweaponsack.id}", 10, /^In the/
         end
         unless bluntskinweapon = ([ GameObj.right_hand, GameObj.left_hand ] | GameObj.containers.values.flatten).find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.bluntskinweapon.strip)}$/i } || ([ GameObj.right_hand, GameObj.left_hand ] | GameObj.containers.values.flatten).find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.bluntskinweapon).sub(' ', ' .*')}$/i } || ([ GameObj.right_hand, GameObj.left_hand ] | GameObj.containers.values.flatten).find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.bluntskinweapon).sub(' ', ' .*')}/i }
            respond "[#{script_name}: warning: failed to find your bluntskinweapon: #{UserVars.bluntskinweapon}]"
            bluntskinweaponsack = nil
            bluntskinweapon = nil
         end
      else
         respond "[#{script_name}: warning: failed to find your bluntskinweaponsack: #{UserVars.bluntskinweaponsack}]"
         bluntskinweaponsack = nil
         bluntskinweapon = nil
      end
   else
      bluntskinweaponsack = nil
      bluntskinweapon = nil
   end
}

find_herbsack = proc {
   if UserVars.herbsack.nil? or UserVars.herbsack.empty?
      if CharSettings['stow-herbs']
         respond "[#{script_name}: warning: stow-herbs option is on, but herbsack is not set]"
      elsif CharSettings['use-ambrominas']
         respond "[#{script_name}: warning: use-ambrominas option is on, but herbsack is not set]"
      end
   else
      unless herbsack = (GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.herbsack.strip)}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.herbsack).sub(' ', ' .*')}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.herbsack).sub(' ', ' .*')}/i } || false)
         respond "[#{script_name}: warning: failed to find your herbsack]"
      end
   end
}

find_arrowsack = proc {
   if UserVars.arrowsack.nil? or UserVars.arrowsack.empty?
      arrowsack = lootsack_list[0]
   else
      unless arrowsack = GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.arrowsack.strip)}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.arrowsack).sub(' ', ' .*')}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.arrowsack).sub(' ', ' .*')}/i }
         respond "[#{script_name}: warning: failed to find your arrowsack]"
      end
   end
}

if script.vars.empty?
   nil
elsif script.vars[0].downcase == 'list'
   show_settings.call
   exit
elsif script.vars[0] =~ /^(skin|604|kneel|safe\-kneel|stance|empty|never\-empty|phase\-boxes|disk\-boxes|get\-arrows|eblade\-arrows|use\-ambrominas|stow\-herbs)=(on|off|yes|no|true|false)$/i
   fix_setting = { 'on' => true, 'yes' => true, 'true' => true, 'off' => false, 'no' => false, 'false' => false }
   CharSettings[$1.downcase] = fix_setting[$2.downcase]
   echo 'setting saved'
   exit
elsif script.vars[0] =~ /^(skinweapon|bluntskinweapon)=(.*)$/i
   var = $1
   name = $2.strip
   if name == 'nil'
      UserVars.send("#{var}=", nil)
      echo 'setting cleared'
   else
      UserVars.send("#{var}=", name)
      echo 'setting saved'
   end
   exit
elsif script.vars[0] =~ /^(lootsack\d*|skinweaponsack|bluntskinweaponsack|arrowsack|herbsack)=(.*)$/i
   var = $1
   name = $2.strip
   if name == 'nil'
      UserVars.send("#{var}=", nil)
      echo 'setting cleared'
   else
      obj_list = GameObj.inv.find_all { |obj| obj.noun == name }
      if obj_list.empty?
         obj_list = GameObj.inv.find_all { |obj| obj.name == name }
      end
      if obj_list.empty?
         obj_list = GameObj.inv.find_all { |obj| obj.name =~ /\b#{Regexp.escape(name)}$/i }
      end
      if obj_list.empty?
         obj_list = GameObj.inv.find_all { |obj| obj.name =~ /\b#{name.split(' ').collect { |n| Regexp.escape(n) }.join(".*\\b")}/i }
      end
      if obj_list.empty?
         echo "error: failed to find a container in your inventory by the name of \"#{name}\""
      elsif obj_list.length > 1
         echo "error: multiple containers in your inventory match the name \"#{name}\""
      else
         UserVars.send("#{var}=", name)
         echo 'setting saved'
      end
   end
   exit
elsif script.vars[0] =~ /^ignore-creatures=(.*)$/i
   if $1 == 'nil'
      CharSettings['ignore-creatures'] = false
      echo 'setting cleared'
   else
      CharSettings['ignore-creatures'] = $1
      echo 'setting saved'
   end
   exit
elsif script.vars[0] =~ /^exclude=(.*)$/i
   if $1 == 'nil'
      CharSettings['exclude'] = nil
      echo 'setting cleared'
   else
      CharSettings['exclude'] = $1
      echo 'setting saved'
   end
   exit
elsif script.vars[0] =~ /^loot\-?types=(.*)$/i
   if $1 == 'nil'
      CharSettings['loot-types'] = 'gem|skin|reagent|herb|jewelry|valuable|magic|scroll|wand|uncommon|box'
      echo 'setting reset'
   else
      CharSettings['loot-types'] = $1
      echo 'setting saved'
   end
   exit
else
   show_help.call
   exit
end

status_tags
silence_me

find_lootsacks.call

if lootsack_list.empty?
   echo 'error: no lootsacks found'
   exit
end

if CharSettings['skin']
   find_skinning_equipment.call
end

if CharSettings['stow-herbs'] or CharSettings['use-ambrominas']
   find_herbsack.call
end

if CharSettings['get-arrows']
   find_arrowsack.call
end

before_dying { DownstreamHook.remove 'loot-watch-sack' }
original_lootsack_list = lootsack_list.dup
watch_lootsack = proc {
   unless DownstreamHook.list.include?('loot-watch-sack')
      remove_count = 0
      hook_proc = proc { |server_string|
         if server_string =~ /^<clearContainer.*You (?:deftly )?remove .* from .* exist="#{original_lootsack_list.first.id}"/
            remove_count += 1
            if remove_count > 2
               DownstreamHook.remove('loot-watch-sack')
               lootsack_list = original_lootsack_list.dup
            end
         elsif server_string =~ /^<clearContainer.*You put .* in .* exist="#{original_lootsack_list.first.id}"/
            remove_count -= 1
         end
         server_string
      }
      DownstreamHook.add('loot-watch-sack', hook_proc)
   end
}

script_name = script.name.dup
hook_proc = proc { |client_string|
   begin
      if client_string =~ /^(?:<c>)?#{$lich_char}#{script_name}\s+(.*)$/
         cmd = $1
         if cmd.downcase == 'list'
            show_settings.call
            nil
         elsif cmd =~ /^(skin|604|kneel|safe\-kneel|stance|empty|never\-empty|phase\-boxes|disk\-boxes|get\-arrows|eblade\-arrows|use\-ambrominas|stow\-herbs)=(on|off|yes|no|true|false)$/i
            fix_setting = { 'on' => true, 'yes' => true, 'true' => true, 'off' => false, 'no' => false, 'false' => false }
            opt = $1
            value = fix_setting[$2.downcase]
            char_settings[opt] = value
            respond "[#{script_name}: setting saved]"
            if (opt == 'skin') and (value == true)
               find_skinning_equipment.call
            elsif (opt == 'get-arrows') and (value == true)
               find_arrowsack.call
            elsif ((opt == 'stow-herbs') or (opt == 'use-ambrominas')) and (value == true)
               find_herbsack.call
            end
            nil
         elsif cmd =~ /^(skinweapon|bluntskinweapon)=(.*)$/i
            var = $1
            name = $2.strip
            if name == 'nil'
               UserVars.send("#{var}=", nil)
               respond '[loot: setting cleared]'
            else
               UserVars.send("#{var}=", name)
               respond '[loot: setting saved]'
            end
            find_skinning_equipment.call
            nil
         elsif cmd =~ /^(lootsack\d*|skinweaponsack|bluntskinweaponsack|arrowsack|herbsack)=(.*)$/i
            var = $1
            name = $2.strip
            if name == 'nil'
               UserVars.send("#{var}=", nil)
               respond '[loot: setting cleared]'
            else
               obj_list = GameObj.inv.find_all { |obj| obj.noun == name }
               if obj_list.empty?
                  obj_list = GameObj.inv.find_all { |obj| obj.name == name }
               end
               if obj_list.empty?
                  obj_list = GameObj.inv.find_all { |obj| obj.name =~ /\b#{Regexp.escape(name)}$/i }
               end
               if obj_list.empty?
                  obj_list = GameObj.inv.find_all { |obj| obj.name =~ /\b#{name.split(' ').collect { |n| Regexp.escape(n) }.join(".*\\b")}/i }
               end
               if obj_list.empty?
                  respond "[loot: error: failed to find a container in your inventory by the name of \"#{name}\"]"
               elsif obj_list.length > 1
                  respond "[loot: error: multiple containers in your inventory match the name \"#{name}\"]"
               else
                  UserVars.send("#{var}=", name)
                  respond '[loot: setting saved]'
                  if var =~ /^(?:blunt)?skinweaponsack$/
                     find_skinning_equipment.call
                  elsif var =~ /^lootsack\d*$/
                     find_lootsacks.call
                  elsif var == 'herbsack'
                     find_herbsack.call
                  elsif var == 'arrowsack'
                     find_arrowsack.call
                  end
               end
            end
            nil
         elsif cmd =~ /^ignore-creatures=(.*)$/i
            if $1 == 'nil'
               char_settings['ignore-creatures'] = nil
               respond "[#{script_name}: setting cleared]"
            else
               char_settings['ignore-creatures'] = $1
               respond "[#{script_name}: setting saved]"
            end
            $loot_ignore_creatures = char_settings['ignore-creatures']
            nil
         elsif cmd =~ /^exclude=(.*)$/i
            if $1 == 'nil'
               char_settings['exclude'] = nil
               respond "[#{script_name}: setting cleared]"
            else
               char_settings['exclude'] = $1
               respond "[#{script_name}: setting saved]"
            end
            nil
         elsif cmd =~ /^loot\-?types=(.*)$/i
            if $1 == 'nil'
               char_settings['loot-types'] = 'gem|reagent|herb|jewelry|magic|scroll|wand|uncommon|box'
               respond "[#{script_name}: setting reset]"
            else
               char_settings['loot-types'] = $1
               respond "[#{script_name}: setting saved]"
            end
            nil
         else
            show_help.call
            nil
         end
      else
         client_string
      end
   rescue
      UpstreamHook.remove(script_name)
      client_string
   end
}
before_dying { UpstreamHook.remove(script_name) }
UpstreamHook.add(script_name, hook_proc)

$loot_ignore_creatures = CharSettings['ignore-creatures']

$loot_dead_npcs  = Array.new
$loot_grab_list  = Array.new
$loot_working    = false
$loot_berserking = false

$loot_stats ||= Hash.new
$loot_stats['start_time']       ||= Time.now
$loot_stats['kills']            ||= 0
$loot_stats['successful_skins'] ||= 0
$loot_stats['failed_skins']     ||= 0
$loot_stats['loot_count']       ||= 0
$loot_arrow_ids                 ||= LimitedArray.new
$loot_arrow_wait                  = Array.new
$loot_needs_eblade              ||= Array.new
$loot_search_rooms              ||= Array.new
failed_drag_lootsack              = Hash.new
need_close_lootsack               = Array.new

can_drag = true

exec_string = "
   hide_me
   status_tags
   before_dying { kill_script(#{script.name.inspect}) if running?(#{script.name.inspect}) }
   Thread.new { wait_while { running?(#{Script.self.name.inspect}) }; Script.self.kill }
   immolated = LimitedArray.new
   immolated.max_size = 15
   weapon_fired = LimitedArray.new
   weapon_fired.max_size = 15
   maelstromed = LimitedArray.new
   maelstromed.max_size = 15
   lightning_called = LimitedArray.new
   lightning_called.max_size = 15
   holy_bolted = LimitedArray.new
   holy_bolted.max_size = 15
   pestilenced = LimitedArray.new
   pestilenced.max_size = 15
   acid_covered = LimitedArray.new
   acid_covered.max_size = 15
   deity = nil
   divine_wrath_active = false
   divine_wrath_message = {
      'Charl'           => /^White sparks flicker around you, and you sense electrical energy gathering in the instant before a massive bolt of lightning spears toward/,
      'Cholen'          => /^A throwing knife formed of shimmering golden light hurtles from the hand of one of the spirit jesters toward/,
      'Eonak'           => /^Within the reddish haze swirling beside/,
      'Imaera'          => /^A brown stag materializes in midair, leaping out of nowhere to try to impale/,
      'Jastev'          => /^A beam of .*? light lances away from the rainbow around you to strike/,
      'Koar'            => /^An aura of divine golden light blazes into existence around/,
      'Lorminstra'      => /^As several faintly glowing snowflakes settle upon/,
      'Lumnis'          => /^Guided by the knowledge within you, you concentrate upon/,
      'Ronan'           => /^Seen only by your spirit gaze, one of the dream unicorns lowers its head and charges fiercely toward/,
      'Tonis'           => /^Accompanied by a particularly impressive gust of wind, a fleeting golden blur flashes past/,
      'Gosaena'         => /^An ethereal pair of feathered white wings materializes from midair and closes around/,
      'Zelia'           => /^You notice .*? nearby\\. How marvelous!/,
      'Eorgina'         => /^Shimmering black flames lash out toward/,
      'Fash\\'lo\\'nae' => /^A matte grey scalpel appears from midair, and it moves with evident purpose to take a deliberate, methodical slice at/,
      'Luukos'          => /^Long, spectral talons materialize from midair to tear viciously at the body of/,
      'Marlu'           => /^A tendril of black mist suddenly senses the proximity of/,
      'Mularos'         => /^The ethereal barbed whip that lies loosely coiled around you uncoils at terrifying speed\\. It snaps out toward/,
      'Sheru'           => /^Suddenly, .*? tries to bolt away, but instead smashes into a wall of spectral force hidden within the shadows!/,
      'V\\'tull'        => /^Divine will surges through you, and you command the scimitar to strike at/,
      'the Huntress'    => /^A silver-bladed scythe materializes from thin air, spinning end over end as it hurtles toward/,
      'Laethe'          => /^A shadowy black rose touches/,
      'Leya'            => /^A dagger of ivory light suddenly flashes away from the aura surrounding you to strike at/,
      'Niima'           => /^As the song from the pillar of water crescendos, it reaches a pitch that normally only trained bards can achieve, and the intense waves of elegant sound focus upon/,
      'Voaris'          => /^A glowing golden rose touches/,
      # fixme: missing Kai, Oleani, Phoen, Andelas, Ivas, Aeia, Amasalen, Arachne, Jaston, Kuon, Onar, Tilamaire, Voln
   }

   while line = get
      if line =~ /<stream id=\"thoughts\">/
         next
      elsif line =~ /^(?:<.*?>)?You nock an? .*?<a exist=\"(\\-?[0-9]+)\" noun=\"arrow\">/
         $loot_arrow_ids.push($1) unless $loot_arrow_ids.include?($1)
      elsif line =~ /^(?:<.*?>)?The scintillating light fades from an .*?<a exist=\"(\\-?[0-9]+)\" noun=\"arrows\">.*?<\\/a>\\./
         $loot_needs_eblade.push($1)
      elsif line =~ /^(?:<.*?>)?The scintillating .*?light surrounding the .*?<a exist=\"(\\-?[0-9]+)\" noun=\"arrow\">.*?<\\/a> fades away\\./
         $loot_needs_eblade.push($1)
      elsif line =~ /<comp(?:onent|Def) id='room objs'>.*?<a exist=\"(?:\#{$loot_arrow_ids.join('|')})\".*?<\\/comp(?:onent|Def)>/
         $loot_grab_list = ($loot_grab_list | GameObj.loot.to_a.find_all { |obj| $loot_arrow_ids.include?(obj.id) }.collect { |obj| obj.id }) - $loot_arrow_wait
      elsif line =~ /^(?:The|Glancing shot.  The|Bad angle.  The|Lacking the force and angle to lodge in .*?, the) <a exist=\"(\\-?[0-9]+)\" noun=\"arrow\">.*?<\\/a> (?:ricochets away from .*?, landing nearby\\.|zips past its target to the ground\\.|flips over, landing behind .*?\\.|fails to stick in .*?\\.|simply falls\\.|is deflected to one side, sailing to the ground\\.|disappears into the local environs|zips past its target to the ground\\.)/
         arrow_id = $1.dup
         if $loot_arrow_ids.include?(arrow_id) and not $loot_arrow_wait.include?(arrow_id)
            $loot_arrow_wait.push(arrow_id)
            Thread.new {
               sleep 16
               arrow_id = $loot_arrow_wait.shift
               unless $loot_grab_list.include?(arrow_id) or !GameObj.loot.any? { |obj| obj.id == arrow_id }
                  $loot_grab_list.push(arrow_id)
               end
            }
            if (line =~ /disappears into the local environs/) and (room = Room.current)
               $loot_search_rooms.push(room.id)
            end
         end
      elsif (line =~ /You (?:swing|gesture|sing|weave another verse|continue to sing|channel|fire|wave|tap|rub|hurl|thrust|slash|throw|punch|attempt to punch|attempt to kick|attempt to throw|quickly dart behind .*? and try to hamstring|mentally attempt to locate your implanted essence|rush forward|exhale a virulent green mist)|You .*?attempt to (?:kick|punch|jab|grapple)|A wave of power flows out of you and toward|Abruptly, you sense the attention of your spirit slayer focus upon|Your (?:<.*?>)?raging sandstorm(?:<.*?>)? swirls around|^Your senses tingle, then become awash in a flood of power as the life leaves your hapless foe!|^The flames surrounding <pushBold\\/>an? <a exist=\"(?:\#{immolated.join('|')})\" noun=\".*?\">.*?<\\/a><popBold\\/> flare up violently\\.\\.\\.|^<pushBold\\/>An? <a exist=\"(?:\#{pestilenced.join('|')})\" noun=\".*?\">.*?<\\/a><popBold\\/> (?:.*? as virulent green mist passes through|convulses with a crippling affliction|skin necrotizes and falls away as an indiscernible mass|skin hardens into a black rot and begins to crumble causing)|^(?:The sickly green miasma around|Light and dark pockmarks appear on|A spiritual malady wracks|Pustules break out all over|Pus-filled sores erupt on|Painful, pus-filled bumps begin to appear on) <pushBold\\/>an? <a exist=\"(?:\#{pestilenced.join('|')})\" noun=\".*?\">.*?<\\/a><popBold\\/> (?:flares|causing)|A .*? leaps from a <a.*?>.*?<\\/a> <pushBold\\/>.*?<a exist=\"(?:\#{weapon_fired.join('|')})\".*?>.*?<\\/a><popBold\\/> is wielding\\.|(?:Brilliant flashes of lightning surround|Large hailstones pound relentlessly on|Violent winds tighten around|Large rocks swirl around) <pushBold\\/>.*?<a exist=\"(?:\#{maelstromed.join('|')})\" noun=\".*?\">.*?<\\/a><popBold\\/>\\.|Suddenly a lightning bolt explodes from the small thundercloud and strikes <pushBold\\/>.*?<a exist=\"(?:\#{lightning_called.join('|')})\" noun=\".*?\">.*?<\\/a><popBold\\/> with a brilliant flash!|^Holy water continues to burn away at .*?exist=\"(?:\#{holy_bolted.join('|')})\"|^Acid continues to eat away at .*?<a exist=\"(\#{acid_covered.join('|')})\"|A shimmering field of energy flashes around you, reflecting the magic/) or (divine_wrath_active and divine_wrath_message[deity] and line =~ divine_wrath_message[deity])
         next if line =~ /You gesture sharply/
         candidates = Array.new
         possible_holy_bolted = nil
         if line =~ /^You exhale a virulent green mist toward <pushBold\\/>.*?<a exist=\"(.*?)\" noun=\".*?\">.*?<\\/a><popBold\\/>, instantly infecting/
            pestilenced.push($1) unless pestilenced.include?($1)
         end
         while (line = get) and (line !~ /Roundtime|A little bit late for that don't you think|<prompt|<style id=\"roomName\"/)
            if (line =~ /^The glimmer of an? <a exist=\"(.*?)\" noun=\".*?\">.*?<\\/a> catches your eye/) or line =~ (/^<pushBold\\/>A <a exist=\".*?\" noun=\".*?\">.*?<\\/a><popBold\\/> releases a groan of mingled ecstasy and relief as <pushBold\\/><a exist=\".*?\" noun=\".*?\">.*?<\\/a><popBold\\/> fades away, leaving (?:an?|some) <a exist=\"(.*?)\" noun=\".*?\">.*?<\\/a> behind!$/)
               $loot_grab_list.push($1) unless $loot_grab_list.include?($1)
               next
            elsif line =~ /^As the last of .*? disappears, (.+) appears? in .*? place\\.$/
               $1.scan(/exist=\"(.*?)\"[^>]*>([^<]+)</).each { |i,n|
                  $loot_grab_list.push(i) unless ($loot_settings['exclude'] and n =~ /\#{$loot_settings['exclude']}/)
               }
               next
            elsif (line =~ /<a exist=\"([^\"]+)\" noun=\"([^\"]+)\">([^<]+)<\\/a> falls to the ground\\./) or (line =~ /^(?:<.*?>)?It(?:<.*?>)? (?:also )?left .*?<a exist=\"([^\"]+)\" noun=\"([^\"]+)\">([^<]+)<\\/a>.*? behind\./)
               exist, noun, name = $1, $2, $3
               unless thing = GameObj.loot.find { |obj| obj.id == exist }
                  next if GameObj.npcs.any? { |n| n.id == exist }
                  thing = GameObj.new(exist, noun, name)
               end
               if thing.type.nil?
                  Script.log \"\#{Time.now.strftime(\"%Y-%m-%d %I:%M%P\")}: missing type for: \#{thing.name}\"
               elsif (thing.type =~ /junk/) or ($loot_settings['exclude'] and thing.name =~ /\#{$loot_settings['exclude']}/)
                  nil
               elsif thing.type =~ /\#{$loot_settings['loot-types']}/
                  $loot_grab_list.push(thing.id) unless $loot_grab_list.include?(thing.id)
                  unless thing.sellable or (thing.type =~ /herb/)
                     Script.log \"\#{Time.now.strftime(\"%Y-%m-%d %I:%M%P\")}: missing sellable for: \#{thing.name}\"
                  end
               end
               next
            elsif line =~ /^(?:The|Glancing shot.  The|Bad angle.  The|Lacking the force and angle to lodge in .*?, the) <a exist=\"(\\-?[0-9]+)\" noun=\"arrow\">.*?<\\/a> (?:ricochets away from .*?, landing nearby\\.|zips past its target to the ground\\.|flips over, landing behind .*?\\.|fails to stick in .*?\\.|simply falls\\.|is deflected to one side, sailing to the ground\\.|disappears into the local environs\\.|zips past its target to the ground\\.)/
               arrow_id = $1.dup
               if $loot_arrow_ids.include?(arrow_id) and not $loot_arrow_wait.include?(arrow_id)
                  $loot_arrow_wait.push(arrow_id)
                  Thread.new {
                     sleep 16
                     arrow_id = $loot_arrow_wait.shift
                     $loot_grab_list.push(arrow_id) unless $loot_grab_list.include?(arrow_id) or !GameObj.loot.any? { |obj| obj.id == arrow_id }
                  }
               end
               if (line =~ /disappears into the local environs/) and (room = Room.current)
                  $loot_search_rooms.push(room.id)
               end
            elsif line =~ /Wisps of black smoke swirl around <pushBold\\/>.*?<a exist=\"(.*?)\" noun=\".*?\">.*?<\\/a><popBold\\/> and s?he bursts into flame!/
               immolated.push($1) unless immolated.include?($1)
            elsif line =~ /^You exhale a virulent green mist toward <pushBold\\/>.*?<a exist=\"(.*?)\" noun=\".*?\">.*?<\\/a><popBold\\/>, instantly infecting/
               pestilenced.push($1) unless pestilenced.include?($1)
            elsif line =~ /You successfully hit <pushBold\\/>.*?<a exist=\"(.*?)\".*?>.*?<\\/a><popBold\\/> <a.*?>.*?<\\/a> with the spell\\./
               weapon_fired.push($1) unless weapon_fired.include?($1)
            elsif line =~ /A stiff breeze begins to swirl around <pushBold\\/>.*?<a exist=\"(.*?)\" noun=\".*?\">.*?<\\/a><popBold\\/>\\./
               maelstromed.push($1) unless maelstromed.include?($1)
            elsif (Skills.slreligion >= 30) and (line =~ /You hurl a stream of holy water at <pushBold\\/>.*?<a exist=\"(.*?)\" noun=\".*?\">.*?<\\/a><popBold\\/>!/)
               possible_holy_bolted = $1
            elsif possible_holy_bolted and (line =~ /^\\s*AS\\: [\\+\\-][0-9]+ vs DS\\: [\\+\\-][0-9]+ with AvD\\: [\\+\\-][0-9]+ \\+ d100 roll\\: \\+[0-9]+ = ([\\+\\-])([0-9]+)/)
               if ($1 == '+') and ($2.to_i > 100)
                  holy_bolted.push(possible_holy_bolted) unless holy_bolted.include?(possible_holy_bolted)
               end
            elsif line =~ /You notice a small cloud form above <pushBold\\/>.*?<a exist=\"(.*?)\" noun=\".*?\">.*?<\\/a><popBold\\/>\\./
               lightning_called.push($1)
            elsif line =~ /^As you pour your soul into an appeal to (.*?), /
               deity = $1
               divine_wrath_active = true
            elsif line =~ /^A final rumble of thunder rolls through the area, and, as its last echoes fade away, your skin ceases to tingle as your connection to Charl lessens\\.|^Your connection to Cholen lessens\\. The airy, brisk trill of a well-played fife and a quick cymbal crash heralds the departure of the spirit jesters\\.|^The ruddy haze near you dissipates, and the sound of the forging hammer dies away\\. As the forge-fire's heat leaves your skin, your connection to Eonak lessens\\.|^You sense the last of the spirit animals running away unseen, and the aroma of forest loam fades as your connection to Imaera lessens\\.|^The iridescent lights surrounding you pop like soap bubbles, one by one, until the last one bursts in a small flare of starry radiance and is gone\\. Your connection to Jastev lessens\\.|^Your connection to Koar lessens, and the divine light fades around you\\. The ground shudders one last time before falling still\\.|^As your connection to Lorminstra lessens, the snowflakes stop falling, and the few that still cling to you melt away\\. The icy cold gradually lifts from your body\\.|^As your connection to Lumnis lessens, the world of divine insight slips away from you, destroying the subtle understanding that you so briefly managed to grasp\\.|^You lose sight of the dream unicorns and the barren plain upon which they run as your connection to Ronan lessens\\. The waking world seems brighter again as the sense of dreamlike lassitude leaves you\\.|^You glimpse the golden blur one last time, but then you lose track of it entirely as your connection to Tonis lessens\\. The wind's force lessens as well, and then the air falls still\\.|^You realize that you had ceased to hear the sound of your own heartbeat only when you become aware of it again, and other sounds filter back into your awareness as well\\. Warmth returns to your body as your connection to Gosaena lessens\\.|^Suddenly, the important insights slip away, leaving you drained and exhausted as you plummet back to a more mundane state of mind\\. Your throat and sides are slightly sore, and your cheeks are wet with tears\\. Your connection to Zelia has lessened\\.|^Your connection to Eorgina lessens, and the black flames instantly vanish, leaving you stranded and bereft of the presence of the Arkati's power\\.|^Your connection to Fash'lo'nae lessens\\.  The quiet sound of a blade being honed persists a moment longer before fading away into silence\\.|^A spectral howl echoes through the air, resonant with pain and anguish\\. Your skin prickles again as your connection to Luukos lessens\\.|^As your connection to Mularos lessens, the cold, invisible collar locked about your throat fades into a compassionate caress, and a similar caress traces its way across the side of your cheek\\. Beneath that gentle touch, the wounds upon your face heal immediately\\. The ethereal barbed whip twitches one last time before dissolving back into air\\.|^Your connection to Sheru lessens, and the murky shadows brought by your appeal fade away, yet the feeling of being watched does not\\. On any night, in any dream or nightmare, those amber eyes will follow you endlessly\\.\\.\\. but such is the prize and the price of your devotion\\.|^As your connection to the Huntress lessens, the foreign anger that lent you strength passes from your body as well, and your heartbeat returns to its regular pace\\.|^You feel the kiss of benediction once more upon your brow, and then your connection to Laethe lessens\\. The shadowy black roses dissolve into tendrils of black, rose-scented smoke that dissipate rapidly\\.|^The ivory light around you fades and glimmers out, and the strength and control of your movements lessens along with your connection to Leya\\.|^The singing from the watery pillar begins to fade as your connection to Niima lessens\\. The pillar thins, then suddenly drops with a great splash! You are utterly drenched in water\\.|^You feel the kiss of benediction once more upon your brow, and then your connection to Voaris lessens\\. One of the glowing golden roses lights with scarlet flame, and the fire spreads rapidly down the vine until every rose is burning\\. The flames consume the roses swiftly and without smoke, until, in less than a second, the roses are gone entirely\\./
               # fixme: missing Kai, Oleani, Phoen, Andelas, Ivas, Marlu, V'tull, Aeia, Amasalen, Arachne, Jaston, Kuon, Onar, Tilamaire, Voln
               divine_wrath_active = false
            elsif line =~ /^\\s*Some of the acid sticks to .+? exist=\"(\\-?\\d+)\".+? and continues to bubble away!/
               acid_covered.push($1)
            end
            if line =~ /<a exist=['\"](.*?)['\"]/
               candidates.push($1) unless candidates.include?($1)
            end
         end
         for obj_id in candidates
            if (npc = GameObj.npcs.find { |npc| npc.id == obj_id }) and (npc.status == 'dead')
               unless $loot_dead_npcs.include?(obj_id)
                  $loot_dead_npcs.push(obj_id) unless $loot_ignore_creatures and not $loot_ignore_creatures.empty? and (npc.name =~ /\#{$loot_ignore_creatures}/)
                  $loot_stats['kills'] += 1
               end
            end
         end
      elsif line =~ /^You spy .*?<a exist=\"(.*?)\" noun=\".*?\">.*?<\\/a>, which looks like the heirloom that you are searching for!$/
         $loot_grab_list.push($1) unless $loot_grab_list.include?($1)
      elsif line =~ /^You cannot do that while berserking\.$|^Everything around you turns red as you work yourself into a berserker's rage!|^You rage across the battlefield, striking with unrelenting fury!/
         $loot_berserking = true
      elsif line =~ /^The redness fades from the world and you begin to breathe harder\.$/
         $loot_berserking = false
      end
   end
"
start_exec_script(exec_string, flags={ :quiet => true })

drag_to_sack = proc { |obj,sack|
   if failed_drag_lootsack[sack.id]
      unless (GameObj.right_hand.id == obj.id) or (GameObj.left_hand.id == obj.id)
         dothistimeout "get ##{obj.id}", 10, get_regex
      end
      result = dothistimeout "put ##{obj.id} in ##{sack.id}", 10, put_regex
   else
      result = dothistimeout "_drag ##{obj.id} ##{sack.id}", 10, put_regex
      if result =~ /^Do you want to put that in or on/
         failed_drag_lootsack[sack.id] = true
         result = dothistimeout "put ##{obj.id} in ##{sack.id}", 10, put_regex
      end
   end
   if result =~ /It's closed!/
      dothistimeout "open ##{sack.id}", 10, /^You open|^That is already open\./
      need_close_lootsack.push(sack.id)
      result = dothistimeout "put ##{obj.id} in ##{sack.id}", 10, put_regex
   end
   result
}

lootsack_put = proc { |obj|
   done_been_put = false
   rotate_lootsack = 0
   $loot_stats['loot_count'] += 1
   if (CharSettings['stow-herbs'] and herbsack and (obj.type =~ /herb/))
      result = drag_to_sack.call(obj, herbsack)
      unless result =~ /won't fit/
         done_been_put = true
      end
   end
   unless done_been_put
      for lootsack in lootsack_list
         result = drag_to_sack.call(obj, lootsack)
         if result =~ /won't fit/
            rotate_lootsack += 1
            watch_lootsack.call
         else
            if CharSettings['phase-boxes'] and (obj.type =~ /box/) and (obj.name !~ /mithril|enruned/) and Spell[704].known? and Spell[704].affordable?
               loop {
                  result = cast 704, obj
                  break unless (result =~ /^\[Spell Hindrance for/) and Spell[704].affordable?
               }
            end
            done_been_put = true
            break
         end
      end
      rotate_lootsack.times { lootsack_list.push(lootsack_list.shift) }
   end
   unless done_been_put
      fput "drop ##{obj.id}"
   end
}

loop {
   if ($loot_dead_npcs.empty? and $loot_grab_list.empty?) or $loot_berserking
      script.want_downstream = false
      clear
      wait_while { ($loot_dead_npcs.empty? and $loot_grab_list.empty?) or $loot_berserking }
   end
   begin
      $loot_working = true
      need_fill_hand = false
      need_fill_left_hand = false
      need_fill_right_hand = false
      save_stance = nil
      waitrt?
      script.want_downstream = true
      right_hand_save = GameObj.right_hand
      unless $loot_dead_npcs.empty?
         dead_npcs = Array.new
         while target = $loot_dead_npcs.shift
            if (dead_npc = GameObj.npcs.find { |npc| npc.id == target }) and (dead_npc.status == 'dead')
               dead_npcs.push(dead_npc)
            end
         end
         if CharSettings['skin'] and skinweapon and skinweaponsack and dead_npcs.any? { |npc| not Settings['unskinnable'].include?(npc.name) and (not both_skinnable.include?(npc.name) or not bluntskinweapon or not bluntskinweaponsack) and (not CharSettings['never-empty'] or (GameObj.right_hand.id == skinweapon.id and GameObj.left_hand.id.nil?) or (GameObj.left_hand.id == skinweapon.id and GameObj.right_hand.id.nil?) or (GameObj.left_hand.id.nil? and GameObj.right_hand.id.nil?) or not Settings['free-hand-skinnable'].include?(npc.name)) }
            unless (GameObj.right_hand.id == skinweapon.id) or (GameObj.left_hand.id == skinweapon.id)
               empty_hand
               need_fill_hand = true
               dothistimeout "get ##{skinweapon.id}", 10, get_regex
            end
            if CharSettings['604'] and (skinning = Spell[604]) and skinning.known? and skinning.affordable? and not skinning.active?
               skinning.cast
            end
            if CharSettings['kneel'] or (CharSettings['safe-kneel'] and not GameObj.npcs.any? { |npc| (npc.status !~ /dead/) and (npc.type !~ /passive/) })
               dothistimeout 'kneel', 5, /You kneel|You are already kneeling/
            end
            if CharSettings['stance'] and stance != 'offensive'
               save_stance = stance
               dothistimeout 'stance offensive', 5, /You are now in an offensive stance/
            end
            if CharSettings['empty'] and GameObj.right_hand.id and (GameObj.right_hand.id != skinweapon.id)
               need_fill_right_hand = true
               empty_right_hand
            end
            if CharSettings['empty'] and GameObj.left_hand.id and (GameObj.left_hand.id != skinweapon.id)
               need_fill_left_hand = true
               empty_left_hand
            end
            for target in dead_npcs
               unless (target.status =~ /gone/) or Settings['unskinnable'].include?(target.name) or (both_skinnable.include?(target.name) and bluntskinweapon and bluntskinweaponsack) or Settings['free-hand-skinnable'].include?(target.name)
                  if GameObj.left_hand.id == skinweapon.id
                     skin_result = dothistimeout "skin ##{target.id} left", 10, /^You (?:skinned|botched)|^You might want to wait until after it is dead|^You can only skin creatures|has already been skinned|^You cannot skin|^Could not find your target creature|unable to cut|^You are unable to (?:properly )?break through|^You cannot .*? break through|^You need a free hand to do that!/
                  else
                     skin_result = dothistimeout "skin ##{target.id}", 10, /You (?:skinned|botched)|You might want to wait until after it is dead|You can only skin creatures|has already been skinned|You cannot skin|Could not find your target creature|unable to cut|^You are unable to (?:properly )?break through|^You cannot .*? break through|^You need a free hand to do that!/
                  end
                  if skin_result =~ /You cannot skin/
                     Settings['unskinnable'].push(target.name)
                  elsif skin_result =~ /unable to cut|^You are unable to (?:properly )?break through|^You cannot .*? break through/
                     Settings['unskinnable'].push(target.name)
                     Settings['blunt-skinnable'].push(target.name)
                  elsif skin_result =~ /You need a free hand/
                     Settings['free-hand-skinnable'].push(target.name)
                  elsif skin_result =~ /yielding an? <a exist="(.*?)"/
                     $loot_grab_list.push($1) unless $loot_grab_list.include?($1)
                     $loot_stats['successful_skins'] += 1
                  else
                     $loot_stats['failed_skins'] += 1
                  end
                  if CharSettings['use-ambrominas'] and herbsack and (target.noun =~ injures_on_skin_regex) and ((Wounds.leftHand == 1) or (Wounds.rightHand == 1))
                     close_herbsack = false
                     if herbsack.contents.nil?
                        r = dothistimeout "open ##{herbsack.id}", 5, /^You open|^That is already open/
                        if r =~ /^You open/
                           close_herbsack = true
                        end
                     end
                     if (leaf = herbsack.contents.find { |obj| obj.name == 'some ambrominas leaf' })
                        empty_hand
                        dothistimeout "get ##{leaf.id}", 10, get_regex
                        dothistimeout "eat ##{leaf.id}", 10, /^You take a bite/
                        waitrt?
                        if (GameObj.left_hand.id == leaf.id) or (GameObj.right_hand.id == leaf.id)
                           dothistimeout "put ##{leaf.id} in ##{herbsack.id}", 10, put_regex
                        end
                        fill_hand
                     end
                     fput "close ##{herbsack.id}" if close_herbsack
                  end
               end
            end
            if ((GameObj.right_hand.id == skinweapon.id and GameObj.left_hand.id.nil?) or (GameObj.left_hand.id == skinweapon.id and GameObj.right_hand.id.nil?) or (GameObj.left_hand.id.nil? and GameObj.right_hand.id.nil?) or not CharSettings['never-empty']) and dead_npcs.any? { |npc| (npc.status !~ /gone/) and not Settings['unskinnable'].include?(target.name) and Settings['free-hand-skinnable'].include?(target.name) }
               if GameObj.right_hand.id and (GameObj.right_hand.id != skinweapon.id)
                  need_fill_right_hand = true
                  empty_right_hand
               end
               if GameObj.left_hand.id and (GameObj.left_hand.id != skinweapon.id)
                  need_fill_left_hand = true
                  empty_left_hand
               end
               for target in dead_npcs
                  unless (target.status =~ /gone/) or Settings['unskinnable'].include?(target.name) or not Settings['free-hand-skinnable'].include?(target.name)
                     if GameObj.left_hand.id == skinweapon.id
                        skin_result = dothistimeout "skin ##{target.id} left", 10, /^You (?:skinned|botched)|^You might want to wait until after it is dead|^You can only skin creatures|has already been skinned|^You cannot skin|^Could not find your target creature|unable to cut|^You are unable to (?:properly )?break through|^You cannot .*? break through/
                     else
                        skin_result = dothistimeout "skin ##{target.id}", 10, /You (?:skinned|botched)|You might want to wait until after it is dead|You can only skin creatures|has already been skinned|You cannot skin|Could not find your target creature|unable to cut|^You are unable to (?:properly )?break through|^You cannot .*? break through/
                     end
                     if skin_result =~ /You cannot skin/
                        Settings['unskinnable'].push(target.name)
                     elsif skin_result =~ /unable to cut|^You are unable to (?:properly )?break through|^You cannot .*? break through/
                        Settings['unskinnable'].push(target.name)
                        Settings['blunt-skinnable'].push(target.name)
                     elsif skin_result =~ /yielding an? <a exist="(.*?)"/
                        $loot_grab_list.push($1) unless $loot_grab_list.include?($1)
                        $loot_stats['successful_skins'] += 1
                     else
                        $loot_stats['failed_skins'] += 1
                     end
                  end
               end
            end
            if need_fill_hand
               dothistimeout "put ##{skinweapon.id} in ##{skinweaponsack.id}", 10, put_regex
            end
         end
         if CharSettings['skin'] and bluntskinweapon and bluntskinweaponsack and dead_npcs.any? { |npc| (Settings['blunt-skinnable'].include?(npc.name) or both_skinnable.include?(npc.name)) and (not CharSettings['never-empty'] or (GameObj.right_hand.id == bluntskinweapon.id and GameObj.left_hand.id.nil?) or (GameObj.left_hand.id == bluntskinweapon.id and GameObj.right_hand.id.nil?) or (GameObj.left_hand.id.nil? and GameObj.right_hand.id.nil?) or not Settings['free-hand-skinnable'].include?(npc.name)) }
            if CharSettings['604'] and (skinning = Spell[604]) and skinning.known? and skinning.affordable? and not skinning.active?
               skinning.cast
            end
            if CharSettings['empty'] and GameObj.right_hand.id and (GameObj.right_hand.id != bluntskinweapon.id)
               need_fill_right_hand = true
               empty_right_hand
            end
            if CharSettings['empty'] and GameObj.left_hand.id and (GameObj.left_hand.id != bluntskinweapon.id)
               need_fill_left_hand = true
               empty_left_hand
            end
            unless (GameObj.right_hand.id == bluntskinweapon.id) or (GameObj.left_hand.id == bluntskinweapon.id)
               empty_hand
               need_fill_hand = true
               dothistimeout("get ##{bluntskinweapon.id}", 10, get_regex)
            end
            if CharSettings['kneel'] or (CharSettings['safe-kneel'] and not GameObj.npcs.any? { |npc| npc.status !~ /dead/ })
               dothistimeout 'kneel', 5, /You kneel/
            end
            if CharSettings['stance'] and stance != 'offensive'
               save_stance = stance
               dothistimeout 'stance offensive', 5, /You are now in an offensive stance/
            end
            for target in dead_npcs
               if (target.status !~ /gone/) and (Settings['blunt-skinnable'].include?(target.name) or both_skinnable.include?(target.name)) and not Settings['free-hand-skinnable'].include?(target.name)
                  if GameObj.left_hand.id == bluntskinweapon.id
                     skin_result = dothistimeout "skin ##{target.id} left", 10, /^You (?:skinned|botched)|^You might want to wait until after it is dead|^You can only skin creatures|has already been skinned|^You cannot skin|^Could not find your target creature|unable to cut|^You are unable to (?:properly )?break through|^You cannot .*? break through|You .*? withdraw (?:a|an|some) <a exist="\-?[0-9]+"|You .*? but find nothing\.|^You need a free hand to do that!/
                  else
                     skin_result = dothistimeout "skin ##{target.id}", 10, /You (?:skinned|botched)|You might want to wait until after it is dead|You can only skin creatures|has already been skinned|You cannot skin|Could not find your target creature|unable to cut|^You are unable to (?:properly )?break through|^You cannot .*? break through|You .*? withdraw (?:a|an|some) <a exist="\-?[0-9]+"|You .*? but find nothing\.|^You need a free hand to do that!/
                  end
                  if skin_result =~ /You .*? withdraw (?:a|an|some) <a exist="(\-?[0-9]+)"/
                     skin_id = $1
                     $loot_stats['successful_skins'] += 1
                     if GameObj.right_hand.id == skin_id
                        lootsack_put.call(GameObj.right_hand)
                     elsif GameObj.left_hand.id == skin_id
                        lootsack_put.call(GameObj.left_hand)
                     else
                        $loot_grab_list.push(skin_id) unless $loot_grab_list.include?(skin_id)
                     end
                  elsif skin_result =~ /You cannot skin/
                     Settings['unskinnable'].push(target.name)
                  elsif skin_result =~ /unable to cut|^You are unable to (?:properly )?break through|^You cannot .*? break through/
                     Settings['unskinnable'].push(target.name)
                  elsif skin_result =~ /You need a free hand to do that!/
                     Settings['free-hand-skinnable'].push(target.name)
                  elsif skin_result =~ /yielding an? <a exist="(.*?)"/
                     $loot_grab_list.push($1) unless $loot_grab_list.include?($1)
                     $loot_stats['successful_skins'] += 1
                  else
                     $loot_stats['failed_skins'] += 1
                  end
               end
            end
            if ((GameObj.right_hand.id == bluntskinweapon.id and GameObj.left_hand.id.nil?) or (GameObj.left_hand.id == bluntskinweapon.id and GameObj.right_hand.id.nil?) or (GameObj.left_hand.id.nil? and GameObj.right_hand.id.nil?) or not CharSettings['never-empty']) and dead_npcs.any? { |npc| (npc.status !~ /gone/) and Settings['blunt-skinnable'].include?(target.name) and Settings['free-hand-skinnable'].include?(target.name) }
               if GameObj.right_hand.id and (GameObj.right_hand.id != bluntskinweapon.id)
                  need_fill_right_hand = true
                  empty_right_hand
               end
               if GameObj.left_hand.id and (GameObj.left_hand.id != bluntskinweapon.id)
                  need_fill_left_hand = true
                  empty_left_hand
               end
               for target in dead_npcs
                  if (target.status !~ /gone/) and (Settings['blunt-skinnable'].include?(target.name) or both_skinnable.include?(target.name)) and Settings['free-hand-skinnable'].include?(target.name)
                     if GameObj.left_hand.id == bluntskinweapon.id
                        skin_result = dothistimeout "skin ##{target.id} left", 10, /^You (?:skinned|botched)|^You might want to wait until after it is dead|^You can only skin creatures|has already been skinned|^You cannot skin|^Could not find your target creature|unable to cut|^You are unable to (?:properly )?break through|^You cannot .*? break through|You .*? withdraw (?:a|an|some) <a exist="\-?[0-9]+"|You .*? but find nothing\./
                     else
                        skin_result = dothistimeout "skin ##{target.id}", 10, /You (?:skinned|botched)|You might want to wait until after it is dead|You can only skin creatures|has already been skinned|You cannot skin|Could not find your target creature|unable to cut|^You are unable to (?:properly )?break through|^You cannot .*? break through|You .*? withdraw (?:a|an|some) <a exist="\-?[0-9]+"|You .*? but find nothing\./
                     end
                     if skin_result =~ /You .*? withdraw (?:a|an|some) <a exist="(\-?[0-9]+)"/
                        skin_id = $1
                        $loot_stats['successful_skins'] += 1
                        if GameObj.right_hand.id == skin_id
                           lootsack_put.call(GameObj.right_hand)
                        elsif GameObj.left_hand.id == skin_id
                           lootsack_put.call(GameObj.left_hand)
                        else
                           $loot_grab_list.push(skin_id) unless $loot_grab_list.include?(skin_id)
                        end
                     elsif skin_result =~ /You cannot skin/
                        Settings['unskinnable'].push(target.name)
                     elsif skin_result =~ /unable to cut|^You are unable to (?:properly )?break through|^You cannot .*? break through/
                        Settings['unskinnable'].push(target.name)
                     elsif skin_result =~ /yielding an? <a exist="(.*?)"/
                        $loot_grab_list.push($1) unless $loot_grab_list.include?($1)
                        $loot_stats['successful_skins'] += 1
                     else
                        $loot_stats['failed_skins'] += 1
                     end
                  end
               end
            end
            if need_fill_hand
               dothistimeout "put ##{bluntskinweapon.id} in ##{bluntskinweaponsack.id}", 10, put_regex
            end
         end
         if need_fill_left_hand
            fill_left_hand
         end
         if need_fill_right_hand
            fill_right_hand
         end
         unless standing?
            fput 'stand'
            waitrt?
         end
         if save_stance
            fput "stance #{save_stance}"
         end
         for target in dead_npcs
            next if target.status =~ /gone/
            if target.noun =~ free_hand_search_regex
               empty_hand
               need_fill_hand = true
            end
            search_result = dothistimeout "search ##{target.id}", 10, /You (?:reach out to )?search|What were you referring to|Could not find a valid target to loot|You plunge your hand into|^You're not in any condition to be searching around!/
            if search_result =~ /You plunge your hand into .*? withdraw (?:your arm to find )?a .*? (\w+) (?:in your grasp|at the cost of freezing your hand)!/
               noun = $1
               if GameObj.right_hand.noun == noun
                  obj = GameObj.right_hand
                  lootsack_put.call(obj)
               elsif GameObj.left_hand.noun == noun
                  obj = GameObj.left_hand
                  lootsack_put.call(obj)
               else
                  echo 'fixme'
               end
            elsif search_result =~ /You (?:reach out to )?search/
               while (line = get) and (line !~ /prompt/)
                  if line =~ /exist="(.*?)".*which looks like the heirloom that you are searching for/
                     $loot_grab_list.push($1) unless $loot_grab_list.include?($1)
                  else
                     for link in line.scan(/<a.*?>.*?<\/a>/)
                        if link =~ /<a exist="(.*?)" noun="(.*?)">(.*?)<\/a>/
                           exist, noun, name = $1, $2, $3
                           next if name =~ /^(?:he|she|it|her|his|him|its|itself)$|'s$/i
                           unless thing = GameObj.loot.find { |obj| obj.id == exist }
                              thing = GameObj.new(exist, noun, name)
                           end
                           if thing.type.nil?
                              Script.log "#{Time.now.strftime("%Y-%m-%d %I:%M%P")}: missing type for: #{thing.name}"
                           elsif (thing.type =~ /junk/) or (CharSettings['exclude'] and thing.name =~ /#{CharSettings['exclude']}/)
                              nil
                           elsif thing.type =~ /#{CharSettings['loot-types']}/
                              $loot_grab_list.push(thing.id) unless $loot_grab_list.include?(thing.id)
                              unless thing.sellable or (thing.type =~ /herb/)
                                 Script.log "#{Time.now.strftime("%Y-%m-%d %I:%M%P")}: missing sellable for: #{thing.name}"
                              end
                           end
                        end
                     end
                  end
               end
            end
            if CharSettings['use-ambrominas'] and herbsack and (target.noun =~ injures_on_search_regex) and ((Wounds.leftHand == 1) or (Wounds.rightHand == 1))
               close_herbsack = false
               if herbsack.contents.nil?
                  r = dothistimeout "open ##{herbsack.id}", 5, /^You open|^That is already open/
                  if r =~ /^You open/
                     close_herbsack = true
                  end
               end
               if (leaf = herbsack.contents.find { |obj| obj.name == 'some ambrominas leaf' })
                  empty_hand
                  dothistimeout "get ##{leaf.id}", 10, get_regex
                  dothistimeout "eat ##{leaf.id}", 10, /^You take a bite/
                  waitrt?
                  if (GameObj.left_hand.id == leaf.id) or (GameObj.right_hand.id == leaf.id)
                     dothistimeout "put ##{leaf.id} in ##{herbsack.id}", 10, put_regex
                  end
                  fill_hand
               end
               fput "close ##{herbsack.id}" if close_herbsack
            end
         end
      end
      if CharSettings['get-arrows'] and not $loot_search_rooms.empty? and not GameObj.npcs.any? { |npc| (npc.type !~ /passive npc/) and (npc.status !~ /dead/) } and (room = Room.current) and $loot_search_rooms.include?(room.id)
         $loot_search_rooms.count(room.id).times {
            dothistimeout 'search', 10, /^You don't find|^You spy|^You're not in any condition to be searching around!/
            waitrt?
         }
         $loot_search_rooms.delete(room.id)
      end
      if $loot_grab_list.empty?
         if need_fill_hand
            fill_hand
         end
      else
         need_close_disk = false
         unless need_fill_hand
            empty_hand
         end
         while obj_id = $loot_grab_list.shift
            unless obj = GameObj.loot.find { |o| o.id == obj_id }
               next if CharSettings['get-arrows'] and $loot_arrow_ids.include?(obj_id)
               dothistimeout "get ##{obj_id}", 10, get_regex
               if GameObj.right_hand.id == obj_id
                  obj = GameObj.right_hand
               elsif GameObj.left_hand.id == obj_id
                  obj = GameObj.left_hand
               else
                  echo 'fixme'
                  next
               end
            end
            if (obj.name == 'belt pouch')
               dothistimeout "look in ##{obj.id}", 5, /^In the|^That is closed|^I could not find/
               if (obj.contents.length == 1) and (obj.contents[0].name == 'some silver coins')
                  fput "get coins from ##{obj.id}"
                  sleep 0.2
                  waitrt?
                  next
               end
            end
            if (obj.type =~ /box/) and CharSettings['disk-boxes'] and ((disk = GameObj.loot.find { |o| o.name =~ /#{Char.name} disk$/ }) or reget.any? { |line| line =~ /^Your disk arrives, following you dutifully\.\r?$/ })
               25.times { break if GameObj.loot.any? { |o| o.name =~ /#{Char.name} disk$/ }; sleep 0.1 }
               if disk
                  result = dothistimeout "_drag ##{obj.id} ##{disk.id}", 10, put_regex
                  if result =~ /It's closed!/
                     dothistimeout "open ##{disk.id}", 10, /^You open|^That is already open\./
                     need_close_disk = true
                     result = dothistimeout "_drag ##{obj.id} ##{disk.id}", 10, put_regex
                  end
                  if result =~ /You put/
                     next
                  end
               end
            end
            while CharSettings['eblade-arrows'] and (eblade = Spell[411]) and eblade.known? and eblade.affordable? and (arrow_id = $loot_needs_eblade.shift)
               if arrow = (GameObj.loot.to_a + arrowsack.contents.to_a).find { |obj| obj.id == arrow_id }
                  waitcastrt?
                  result = eblade.cast(arrow)
                  if (result == false) or (result =~ /^\[Spell Hindrance/)
                     arrow_id = $loot_needs_eblade.unshift(arrow_id)
                  end
               end
            end
            if CharSettings['get-arrows'] and $loot_arrow_ids.include?(obj.id)
               next unless GameObj.loot.any? { |o| o.id == obj.id }
               next if $loot_arrow_wait.include?(obj.id)
               bundle_list = arrowsack.contents.find_all { |o| o.noun == 'arrows' }
               if (likely_bundle_id = likely_bundle_id_list[obj.full_name]) and (likely_bundle = bundle_list.find { |o| o.id == likely_bundle_id })
                  # try the last working bundle for this arrow name first
                  bundle_list.delete(likely_bundle)
                  bundle_list.unshift(likely_bundle)
               end
               obj_full_name = obj.full_name # obj and name will change if gather is used
               for bundle in arrowsack.contents.find_all { |o| o.noun == 'arrows' }
                  if GameObj.loot.find_all { |o| o.noun == 'arrow' }.length > 2
                     result = dothistimeout "gather ##{obj.id}", 10, /^You gather|^You pick up|^You need a free hand to pick that up\.|^I could not find what you were referring to\.|^Get what\?|^The .*? is out of your reach\.|^You (?:deftly )?remove/
                     if result =~ /^You gather|^You pick up/
                        if GameObj.right_hand.noun =~ /^arrows?$/
                           obj = GameObj.right_hand
                        elsif GameObj.left_hand.noun =~ /^arrows?$/
                           obj = GameObj.left_hand
                        end
                        result = dothistimeout "put my arrow in ##{bundle.id}", 10, /^You add|^You bundle|^I could not find what you were referring to\.|^You cannot bundle these together\./
                     end
                  else
                     result = dothistimeout "_drag ##{obj.id} ##{bundle.id}", 10, /You add|You need a free hand to pick that up\.|^I could not find what you were referring to\.|^Get what\?|^The .*? is out of your reach\.|^You cannot bundle these together\./
                  end
                  if result =~ /^You add|^You bundle/
                     likely_bundle_id_list[obj_full_name] = bundle.id
                     break
                  end
               end
               if (GameObj.right_hand.id == obj.id) or (GameObj.left_hand.id == obj.id) or GameObj.loot.any? { |o| o.id == obj.id }
                  result = dothistimeout "_drag ##{obj.id} ##{arrowsack.id}", 10, put_regex
               end
            else
               lootsack_put.call(obj)
            end
         end
         fill_hand
         for lootsack_id in need_close_lootsack
            dothistimeout "close ##{lootsack_id}", 10, /^You close|^That is already closed;\./
         end
         need_close_lootsack.clear
         if need_close_disk
            dothistimeout "close ##{disk.id}", 10, /^You close|^That is already closed;\./
         end
      end
   ensure
      $loot_working = false
   end
}

=begin
   start second arrow bundle when charges run out
   keep track of charged/dead bundle
   option to bless dead arrows

   The scintillating red light surrounding the arrow fades away.

   only gather after kill
   only gather with no live npcs

   You are unable to properly break through the greater krynch's rocky hide with a straight razor.
   You are unable to break through the krag dweller's stone hide with a dagger!
=end
