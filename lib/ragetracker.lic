=begin
  Rage Tracker - Rage Armor & Storm of Rage Monitor

  Tracks Rage Armor activation bonuses, durations, and high scores.
  Separately monitors Storm of Rage gemstone tiers, kill streaks,
  and total kills. Displays real-time statistics to help evaluate
  the effectiveness of both abilities independently.

  Usage:
    ;ragetracker              - Start tracking
    ;ragetracker reset        - Clear all saved data

  In-game Commands (while running):
    *rage                     - Show full status summary
    *rage status              - Show full status summary
    *rage main                - Send output to main window (default)
    *rage fam                 - Send output to familiar window
    *rage off                 - Suppress all output

  Author: ChatGPT / Claude
  Tags: combat, tracking, rage armor, storm of rage, buffs
  Version: 1.4.0

  Changelog:
  1.4.0 (2026-02-16)
    - Refactored into proper module structure.
    - Output mode now supports three states: main, familiar, or off.
    - Commands: *rage main, *rage fam, *rage off, *rage status.
  1.3.1 (2025-05-21)
    - Fix for output being saved between sessions to familiar or main window.
    - Command to swap output changed to *rage.
  1.3.0 (2025-05-16)
    - Added separate tracking for Storm of Rage gemstone tiers and durations.
    - Storm of Rage now tracks current streak and total kill count.
    - Storm of Rage now also tracks best (longest) streak.
  1.2.1 (2025-04-26)
    - Output switching now saves preference and confirms change.
  1.2.0 (2025-04-18)
    - Added output switching via upstream hook.
  1.1.0 (2024-09-08)
    - Implemented a Biggest Hit high score tracker.
  1.0.0 (2024-08-26)
    - Initial release of the Rage Armor Tracker.
=end
no_kill_all

require 'yaml'

module RageTracker
  UPSTREAM_HOOK_ID = "ragetracker::upstream" unless defined?(UPSTREAM_HOOK_ID)
  VALID_MODES = %w[main familiar off].freeze unless defined?(VALID_MODES)

  @last_displayed_bonus = nil
  @last_displayed_high_score = nil
  @rage_data = nil
  @rage_file_path = nil
  @output_mode = "main"

  module_function

  def data_dir
    dir = "#{$data_dir}#{XMLData.game}/#{Char.name}/"
    Dir.mkdir("#{$data_dir}#{XMLData.game}") unless Dir.exist?("#{$data_dir}#{XMLData.game}")
    Dir.mkdir(dir) unless Dir.exist?(dir)
    dir
  end

  def load_data
    @rage_file_path = "#{data_dir}rage_data.yaml"
    defaults = {
      "buffs" => [], "high_score" => 0, "output_mode" => "main",
      "storm_tier" => 0, "storm_active" => false, "storm_streak" => 0,
      "storm_kills" => 0, "storm_best_streak" => 0
    }

    @rage_data = if File.exist?(@rage_file_path)
                   YAML.load_file(@rage_file_path) || defaults.dup
                 else
                   defaults.dup
                 end

    # Ensure all keys exist
    defaults.each { |k, v| @rage_data[k] = v if @rage_data[k].nil? }

    # Migrate old boolean format to new string mode
    if @rage_data.key?("use_familiar_window")
      @rage_data["output_mode"] = @rage_data.delete("use_familiar_window") ? "familiar" : "main"
    end

    @output_mode = VALID_MODES.include?(@rage_data["output_mode"]) ? @rage_data["output_mode"] : "main"
  end

  def save_data
    return unless @rage_data && @rage_file_path
    File.open(@rage_file_path, "w") { |f| f.write(@rage_data.to_yaml) }
  end

  def reset_data
    File.delete(@rage_file_path) if @rage_file_path && File.exist?(@rage_file_path)
    echo "Rage armor data has been reset."
  end

  def output_mode
    @output_mode
  end

  def set_output_mode(mode)
    mode = mode.downcase.strip
    mode = "familiar" if mode == "fam"
    unless VALID_MODES.include?(mode)
      respond "--- Rage Tracker: Invalid mode '#{mode}'. Use: main, fam, or off"
      return
    end
    @output_mode = mode
    @rage_data["output_mode"] = mode
    save_data
    respond "--- Rage Tracker output set to: #{mode.upcase}"
  end

  def output(message)
    case @output_mode
    when "off"
      return
    when "familiar"
      if $frontend =~ /stormfront|profanity/i
        fam_begin = "<pushStream id=\"familiar\" ifClosedStyle=\"watching\"/><output class=\"mono\"/>\n"
        fam_end = "\n<output class=\"\"/><popStream/>\r\n"
      else
        fam_begin = "\034GSe\r\n"
        fam_end = "\034GSf\r\n"
      end
      _respond("#{fam_begin}#{message}#{fam_end}")
    else
      echo message
    end
  end

  def update_buffs
    current_time = Time.now.to_i
    @rage_data["buffs"].reject! { |buff| current_time > buff["end_time"] }
    total = @rage_data["buffs"].map { |b| b["bonus"] }.sum
    total > 50 ? 50 : total
  end

  def display_rage_status
    total_bonus = update_buffs
    if @last_displayed_bonus != total_bonus || @last_displayed_high_score != @rage_data["high_score"]
      @last_displayed_bonus = total_bonus
      @last_displayed_high_score = @rage_data["high_score"]
      output("RAGE: +#{total_bonus} AS (#{@rage_data["buffs"].size} active buffs) | Biggest Hit: #{@rage_data["high_score"]} damage")
    end
  end

  def display_storm_status
    return unless @rage_data["storm_active"]
    output("Storm of Rage Active (Tier #{@rage_data["storm_tier"]}) | Streak: #{@rage_data["storm_streak"]} kills | Best: #{@rage_data["storm_best_streak"]} | Total: #{@rage_data["storm_kills"]}")
  end

  def display_status
    respond "--- Rage Tracker Status ---"
    total_bonus = update_buffs
    respond "--- Output Mode: #{@output_mode.upcase}"
    respond "--- Rage Armor: +#{total_bonus} AS (#{@rage_data["buffs"].size} active buffs)"
    respond "--- Biggest Hit: #{@rage_data["high_score"]} damage"
    if @rage_data["storm_active"]
      respond "--- Storm of Rage: Active (Tier #{@rage_data["storm_tier"]}) | Streak: #{@rage_data["storm_streak"]}"
    else
      respond "--- Storm of Rage: Inactive"
    end
    respond "--- Best Streak: #{@rage_data["storm_best_streak"]} | Total Kills: #{@rage_data["storm_kills"]}"
  end

  def handle_storm(line)
    case line
    when /A burning rage awakens within you/
      @rage_data["storm_tier"] = 1
      @rage_data["storm_active"] = true
      @rage_data["storm_streak"] += 1
      @rage_data["storm_kills"] += 1
      display_storm_status
    when /The burning rage mounts within your soul/
      @rage_data["storm_tier"] = 2
      @rage_data["storm_streak"] += 1
      @rage_data["storm_kills"] += 1
      display_storm_status
    when /The burning rage reaches its zenith/
      @rage_data["storm_tier"] = 3
      @rage_data["storm_streak"] += 1
      @rage_data["storm_kills"] += 1
      display_storm_status
    when /The conflagration of rage continues to burn/
      @rage_data["storm_streak"] += 1
      @rage_data["storm_kills"] += 1
      display_storm_status
    when /The burning rage abates/
      @rage_data["storm_active"] = false
      @rage_data["storm_tier"] = 0
      if @rage_data["storm_streak"] > @rage_data["storm_best_streak"]
        @rage_data["storm_best_streak"] = @rage_data["storm_streak"]
      end
      output("Storm of Rage has faded. Final streak: #{@rage_data["storm_streak"]} kills.")
      @rage_data["storm_streak"] = 0
    end
  end

  def handle_rage_armor(line, line_buffer)
    return unless line =~ /rage ignites within you|your .*? as the rage within surges/
    recent_damage = line_buffer.reverse.find { |prev| prev =~ /(\d+) points? of damage!/ }
    return unless recent_damage
    damage = recent_damage.match(/(\d+) points? of damage!/)[1].to_i
    echo "RAGE +#{damage} RAGE".upcase.center(45)
    @rage_data["buffs"] << { "bonus" => damage, "end_time" => Time.now.to_i + 30 }
    @rage_data["high_score"] = damage if damage > @rage_data["high_score"]
    display_rage_status
    save_data
  end

  def setup_hook
    UpstreamHook.add(UPSTREAM_HOOK_ID, proc do |command|
      cmd = command.to_s.strip.sub(/^<c>/i, '').strip
      if cmd =~ /^\*rage(?:\s+(.*))?$/i
        arg = $1&.strip&.downcase
        if arg.nil? || arg.empty?
          RageTracker.display_status
        elsif %w[main fam familiar off].include?(arg)
          RageTracker.set_output_mode(arg)
        elsif arg == "status"
          RageTracker.display_status
        else
          respond "--- Rage Tracker: Usage: *rage [main|fam|off|status]"
        end
        nil
      else
        command
      end
    end)
  end

  def run
    load_data

    if Script.current.vars[1] =~ /reset/i
      reset_data
      exit
    end

    echo "Rage Tracker started. Output: #{@output_mode.upcase}"
    echo "Commands: *rage main | *rage fam | *rage off | *rage status"

    setup_hook
    before_dying { UpstreamHook.remove(UPSTREAM_HOOK_ID) }

    Thread.new do
      loop do
        sleep 1
        display_rage_status
      end
    end

    line_buffer = []

    begin
      loop do
        line = get
        line_buffer << line
        line_buffer.shift if line_buffer.size > 5
        handle_storm(line)
        handle_rage_armor(line, line_buffer)
        sleep 0.1
      end
    rescue Interrupt
      save_data
      output("Rage tracker data saved. Exiting script.")
    end
  end
end

RageTracker.run
