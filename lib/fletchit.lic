
=begin

*** Made some updates to ;fletching. ***

Learning mode will restart after cutting nocks, and wait while mind is above 60%
Has the ability to make arrows, light and heavy bolts.

Have only the fletchings you want to use in your supplies container, the script does not distinguish
between types of fletchings when working, it only checks to make sure the kind you entered are in your
supplies sack.

Will make, paint and crest arrows. If you are in a mapped room it can run to the shop and buy more basic items.
Will keep on going untill you tell it to stop or you hit the limit you set.

Bow or crossbow must be worn before starting script. Crossbow must be cocked and unloaded.

';fletchit help' for help
';fletchit setup' to change your settings
';fletchit bundle' will attempt to bundle all your arrows, this will likely fail if you are not at, or near mastered, as you make arrows of all different qualities
';fletchit' while the script is running will bring up a mini report(same as you get after finishing an arrow
';fletchit stop' while the script is running will tell the script to stop after finsihing the current arrow


=end

#todo
#add waste barrel detection
#cut all shafts in batches
#make own fletchings
#save arrow profiles
#flip arrows
#toggle for waggle
#scan inventory for knife/axe/bow
#scan inventory for containers

#fixme1 - Bow currently must be worn, change so checks GameObj.inv and if not there gets it from container instead
#silence_me
settings = CharSettings.to_hash
settings[:sack] 		  ||= "backpack"
settings[:quiver] 		  ||= "backpack"
settings[:axe] 			  ||= "handaxe"
settings[:knife] 		  ||= "dagger"
settings[:bow]		 	  ||= "bow"
settings[:enable_buying]  ||= false
settings[:paint] 		  ||= 0
settings[:paintstick1] 	  ||= ""
settings[:paintstick2] 	  ||= ""
settings[:wood] 		  ||= "limb of wood"
settings[:fletchings] 	  ||= "bundle of fletchings" 
settings[:limit] 		  ||= ""
settings[:waggle] 		  ||= false
settings[:learning]		  ||= false
settings[:alerts] 		  ||= false
settings[:tip]			  ||= ""
settings[:drill]		  ||= ""
settings[:ammo]			  ||= 0
settings[:mind]			  ||= "60"

#doesnt really need to be a hash but had to make sure they were in the right order to add the drop down menu on the gui
ammo_types = {
	0	=> 'none',		
	1	=> 'arrow',
	2	=> 'light bolt',
	3	=> 'heavy bolt',
}
paints = {
	0	=> 'none',		
	1	=> 'bright golden paint',
	2	=> 'fiery orange paint',
	3	=> 'bright yellow paint',
	4 	=> 'dark russet paint',
	5	=> 'dark brown paint',
	6	=> 'silvery grey paint',
	7	=> 'twilight grey paint',
	8	=> 'storm grey paint',
	9	=> 'charcoal grey paint',
	10	=> 'icy blue paint',
	11	=> 'midnight blue paint',
	12	=> 'dusky blue paint',
	13	=> 'silvery white paint',
	14	=> 'bone white paint',
	15	=> 'pure white paint',
	16	=> 'glossy black paint',
	17	=> 'dull black paint',
	18	=> 'inky black paint',
	19	=> 'forest green paint',
	20	=> 'hunter green paint',
	21	=> 'dark green paint',
	22	=> 'blood red paint',
	23	=> 'glossy red paint',
	24	=> 'dull red paint',
}

#Ripped setup from sloot, no clue waht is going on here but it works!
setup = proc {
	
	
	
	gtk_global = Hash.new
	window = window_action = nil
	Gtk.queue {
		ttips = Gtk::Tooltips.new.enable
		ttips_text = {
			:sack => 'This is the container all your supplies, axe and dagger will be in',
			:quiver => 'This is the container you want your finshed arrows to be stored in, it can be the same as the container above if you wish',
			:axe => 'This is the axe you will use for creating the shafts, needs to be what ever you would type following the get comand to remove it from your container.' ,
			:knife => 'This is the knife or dagger you will be using to cut the shafts, needs to be what ever you would type following the get comand to remove it from your container.' ,
			:bow => 'This is the bow you will be using to measure the shaft, MUST BE WORN!',
			:enable_painting => 'Check this if you would like to paint your arrows',
			:enable_buying => 'Check this if you would like the script to go buy wood, glue and fletchings from the shop',
			:wood => 'The name of the wood you would like to buy, leaving off a/an/some at the start. Eg. "limb of faewood" or "branch of kakore"',
			:paint => 'The name of the paint you would like to buy, leaving off a/an/some at the start',
			:paintstick1 => 'Leave blank if you do not want to use a paintstick to crest your arrows. If you want to crest you arrows please enter the colour of the paintstick.',
			:paintstick2 => 'Leave blank if you do not want to use a paintstick to crest your arrows a second time. If you want to crest you arrows a second time please enter the colour of the paintstick.',
			:fletchings => 'The name of the fletchings you would like to buy, leaving off a/an/some at the start.',
			:limit => 'This is the number of arrows you would like the script to make, leave blank for no limit. It will just keep making more till you tell it to stop, run out of space or run out of money.',
			:learning => 'Enable learning mode, will drop shafts and clean table so works best at a table.',
			:mind => 'When learning, script will wait when your mind is above this percentage.',
			:alerts => 'Monitors interactions and pops up an alert.',
			:ammo => 'Type of ammunition you want to make. Please select one',
			:drill => 'The noun of your drill which should be in your supplies container.',
			:tip => 'The noun of the tips you wish to use which should be in your supplies container.',
		}
		
		gtk_global[:sack] = Gtk::Entry.new.set_text(settings[:sack])
		gtk_global[:quiver] = Gtk::Entry.new.set_text(settings[:quiver])
		gtk_global[:axe] = Gtk::Entry.new.set_text(settings[:axe])
		gtk_global[:knife] = Gtk::Entry.new.set_text(settings[:knife])
		gtk_global[:bow] = Gtk::Entry.new.set_text(settings[:bow])
		gtk_global[:wood] = Gtk::Entry.new.set_text(settings[:wood])
		gtk_global[:ammo] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global[:paint] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global[:paintstick1] = Gtk::Entry.new.set_text(settings[:paintstick1])
		gtk_global[:paintstick2] = Gtk::Entry.new.set_text(settings[:paintstick2])
		gtk_global[:fletchings] = Gtk::Entry.new.set_text(settings[:fletchings])
		gtk_global[:limit] = Gtk::Entry.new.set_text(settings[:limit].to_s)
		gtk_global[:waggle] = Gtk::CheckButton.new.set_active(settings[:waggle])
		gtk_global[:enable_buying] = Gtk::CheckButton.new.set_active(settings[:enable_buying])
		gtk_global[:learning] = Gtk::CheckButton.new.set_active(settings[:learning])
		gtk_global[:alerts] = Gtk::CheckButton.new.set_active(settings[:alerts])
		gtk_global[:mind] = Gtk::Entry.new.set_text(settings[:mind])
#		gtk_global[:drill] = Gtk::Entry.new.set_text(settings[:drill])
#		gtk_global[:tip] = Gtk::Entry.new.set_tip(settings[:tip])
		
		#use paints array to form combox
		x = 0
		while x < paints.length
			gtk_global[:paint].append_text(paints[x])
			x += 1
		end
		x = 0
		while x < ammo_types.length
			gtk_global[:ammo].append_text(ammo_types[x])
			x += 1
		end
		gtk_global[:paint].set_active(settings[:paint]) #have to set active after apending
		gtk_global[:ammo].set_active(settings[:ammo])
		
		
		
		ttips_text.each_pair { |widget,tip|
			if widget = gtk_global[widget]# || gtk_locals[widget]
				ttips.set_tip(widget,tip,'')
			end
		}
		
		window = Gtk::Window.new
		window.title = "FletchIT"
		window.border_width = 3
		window.resizable = true
		#window.resize(10, 10)
		
		settings_page = Gtk::VBox.new(false,1).set_border_width(3)
		vb_pg1_1 = Gtk::VBox.new(false,1).set_border_width(3)
		fr_pg1_1 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Settings</b></big>'))
		fr_pg1_1.add(vb_pg1_1)
		settings_page.pack_start(fr_pg1_1,false)

		#random note to self width will be ignored if text is longer
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Supplies Container: ')).set_width_request(120))
		hb.pack_start(gtk_global[:sack],false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Finished Container: ')).set_width_request(120))
		hb.pack_start(gtk_global[:quiver],false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Bow: ')).set_width_request(120))
		hb.pack_start(gtk_global[:bow],false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Ammo: ')).set_width_request(120))
		hb.pack_start(gtk_global[:ammo].set_width_request(158),false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Axe: ')).set_width_request(120))
		hb.pack_start(gtk_global[:axe],false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Knife: ')).set_width_request(120))
		hb.pack_start(gtk_global[:knife],false)
		vb_pg1_1.pack_start(hb,false)
		
#		hb = Gtk::HBox.new(false,1)
#		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Drill: ')).set_width_request(120))
#		hb.pack_start(gtk_global[:drill],false)
#		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Buy Items: ')).set_width_request(120))
		hb.pack_start(gtk_global[:enable_buying],false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Wood: ')).set_width_request(120))
		hb.pack_start(gtk_global[:wood],false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Paint: ')).set_width_request(120))
		hb.pack_start(gtk_global[:paint].set_width_request(158),false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Paintstick 1: ')).set_width_request(120))
		hb.pack_start(gtk_global[:paintstick1],false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Paintstick 2: ')).set_width_request(120))
		hb.pack_start(gtk_global[:paintstick2],false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Fletchings: ')).set_width_request(120))
		hb.pack_start(gtk_global[:fletchings],false)
		vb_pg1_1.pack_start(hb,false)
		
#		hb = Gtk::HBox.new(false,1)
#		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Tip Ammo: ')).set_width_request(120))
#		hb.pack_start(gtk_global[:tip],false)
#		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Make limit: ')).set_width_request(120))
		hb.pack_start(gtk_global[:limit],false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Learn Fletching: ')).set_width_request(120))
		hb.pack_start(gtk_global[:learning],false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Mind: ')).set_width_request(120))
		hb.pack_start(gtk_global[:mind],false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Monitor Interactions: ')).set_width_request(120))
		hb.pack_start(gtk_global[:alerts],false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Use waggle: ')).set_width_request(120))
		hb.pack_start(gtk_global[:waggle],false)
		vb_pg1_1.pack_start(hb,false)
		
		
		lbl = Gtk::Label.new.set_markup("Mouse over each box for more help")
		lbl.set_wrap(true).set_padding(0,10)
		vb_pg1_1.pack_start(lbl,false)
		
		hb_saveclose = Gtk::HBox.new(false,1)
		save = Gtk::Button.new('_Save & Close')
		close = Gtk::Button.new('E_xit')
		save.signal_connect('clicked') { window_action = :save }
		close.signal_connect('clicked') { window_action = :done }
		hb_saveclose.pack_start(save,false)
		hb_saveclose.pack_start(close,false)
		vb_pg1_1.pack_start(hb_saveclose,false)
		
		window.signal_connect('delete_event') { window_action = :exit }
		
		window.add(settings_page)
		
		window.show_all
		window.keep_above = true
		
	}
	
	before_dying { Gtk.queue { window.destroy } }
	wait_while { window_action.nil? }
	undo_before_dying
	Gtk.queue { window.destroy }
	
	if window_action == :save		
		gtk_global.each_pair { |option,widget|
			
			if widget.class == Gtk::CheckButton
				settings[option] = widget.active?
			elsif widget.class == Gtk::Entry
				settings[option] = widget.text.strip.downcase
			elsif widget.class == Gtk::ComboBox
				settings[option] = widget.active
			else
				echo "error: unknown local widget #{option} [#{widget.class}]"
			end
		}
		
		#attempt some error checking
		warning = ""
		if settings[:sack] == ""
			warning += "The container for you supplies has not yet been set, the script will not run untill this is added.\r\n"
		end
		if settings[:quiver] == ""
			warning += "The container for you finished arrows has not yet been set, the script will not run untill this is added.\r\n"
		end
		if settings[:knife] == ""
			warning += "Have not set a knife/dagger to cut the shafts with, the script will not run untill this is added.\r\n"
		end
		if settings[:bow] == ""
			warning += "Have not set a bow to measure the shafts with, the script will not run untill this is added.\r\n"
		end
		if settings[:axe] == ""
			warning += "Have not set an axe to make shafts with, the script will not run untill this is added.\r\n"
		end
		if settings[:wood] == ""
			warning += "Have not set a what wood you want to use, the script will not run untill this is added.\r\n"
		end
		if settings[:wood] != "" and settings[:wood] !~ /wood|log/
			warning += "You have set what wood you want to use but appears you may have done so incorectly. It should read along the lines of 'limb of wood' or 'branch of faewood' for example.\r\n"
		end
		if settings[:wood] =~ /\s*a |\s*an |\s*some /
			settings[:wood].gsub!(/\s*a |\s*an |\s*some /, '')
		end
		if settings[:paintstick1] != "" and settings[:paintstick1] !~ /paintstick/
			settings[:paintstick1] = "#{settings[:paintstick1].strip} paintstick"
		end
		if settings[:paintstick2] != "" and settings[:paintstick2] !~ /paintstick/
			settings[:paintstick2] = "#{settings[:paintstick2].strip} paintstick"
		end
		if settings[:fletchings] != "" and settings[:fletchings] !~ /fletching/
			warning += "You have set what fletchings you want to use but appears you may have done so incorectly. It should read along the lines of 'bundle of fletchings' for example. Leave off any a/an/some from the start.\r\n"
		end
		if settings[:fletchings] =~ /\s*a |\s*an |\s*some /
			settings[:fletchings].gsub!(/\s*a |\s*an |\s*some /, '')
		end
		if warning.length > 0
			if !$fake_stormfront
				puts "<output class=\"mono\"/>#{monsterbold_start}#{warning}#{monsterbold_end}\r\n<output class=\"\"/>"
			else
				puts "#{monsterbold_start}#{warning}#{monsterbold_end}"
			end
		end
		echo 'settings saved'
	else
		echo 'closed without saving'
	end
}

def monitor_interaction()
        #if @MONITOR_INTERACTION
start_exec_script( <<-eos
	def show_window(line);
	window_title = Char.name + ':' + line;
	Gtk.queue {
		$myWindow = Gtk::Window.new;
		$myWindow.title = "Autobot Alert!";
		$myWindow.set_size_request(450, 25);
		label = Gtk::Label.new window_title;
		$myWindow.add(label);
		$myWindow.show_all;
	};
	end;
	while(line = get);
		break unless running?('fletchit');
		if(line =~ /SEND|POLICY|[Rr](\s)*[Ee](\s)*[Pp](\s)*[Oo](\s)*[Rr](\s)*[Tt]|peaking to you|unresponsive|taps you|nods to you|lease respond|not in control|character|violation|lease speak|peak out loud|Y U SHOU D|whispers,|speaking to you|smiles at you|waves to you|grins at you|hugs you|takes hold your hand|grabs your hand|clasps your hand|trying to drag you/);
			unless(line =~ /LNet/);
				show_window(line);
				echo "AUTOBOT ALERT: " + line;
			end;
		end;
	end;
	eos
)
end
   # end

def checksilver
	silvers = nil
	action = proc { |server_string|
		if server_string =~ /^\s*Name\:|^\s*Gender\:|^\s*Normal \(Bonus\)|^\s*Strength \(STR\)\:|^\s*Constitution \(CON\)\:|^\s*Dexterity \(DEX\)\:|^\s*Agility \(AGI\)\:|^\s*Discipline \(DIS\)\:|^\s*Aura \(AUR\)\:|^\s*Logic \(LOG\)\:|^\s*Intuition \(INT\)\:|^\s*Wisdom \(WIS\)\:|^\s*Influence \(INF\)\:/
			nil
		elsif server_string =~ /^\s*Mana\:\s+\-?[0-9]+\s+Silver\:\s+([0-9]+)/
			silvers = $1.to_i
			DownstreamHook.remove("slib_check_silvers")
			nil
		else
			server_string
		end
	}
	DownstreamHook.add("slib_check_silvers", action)
	$_SERVER_.puts "#{$cmd_prefix}info\n"
	wait_until { silvers }
	silvers
end

def get_container_contents(container_name)
	
	if container_name.nil?
		echo 'Blank name passed to get_container_contents'
		sleep 1
		exit
	else
		container_contents = GameObj.inv.find { |obj| obj.name =~ /#{Regexp.escape(container_name.strip)}/i } || GameObj.inv.find { |obj| obj.name =~ /#{Regexp.escape(container_name).sub(' ', ' .*')}/i }
		if container_contents.nil?
			echo "warning: failed to find your fletchsack (#{container_name})"
			sleep 1
		else
			if container_contents.contents.nil?
				open_result = dothistimeout "open ##{container_contents.id}", 10, /You open|already open/
				close_container_contents = true if open_result =~ /You open/
				if container_contents.contents.nil?
					dothistimeout "look in ##{container_contents.id}", 10, /In the .* you see/
					if container_contents.contents.nil?
						echo "warning: failed to find the contents of your fletchsack (#{container_name})"
						sleep 1
					end
				end
			end
		end
	end
	return container_contents.contents
end

def check_needed_items(settings,fletch_sack_contents,paints)
	items = Array.new
	needed_items = Array.new
	need_wood = true
	need_paint = true
	need_glue = true
	need_fletchings = true
	need_paintstick1 = true
	need_paintstick2 = true
	#check container and if we have it mark as not needed
	fletch_sack_contents.each{|item|
		#fixme: see if can get more specfic then shaft
		if item.name =~ /shaft/ or item.name =~ /#{settings[:wood]}/
			need_wood = false
		elsif item.name =~ /#{paints[settings[:paint]]}/
			need_paint = false
		elsif item.name =~ /#{settings[:fletchings]}/
			need_fletchings = false
		elsif item.name =~ /bottle of fletching glue/
			need_glue = false
		elsif item.name =~ /#{settings[:paintstick1]}/ and settings[:paintstick1].length > 0
			need_paintstick1 = false
		elsif item.name =~ /#{settings[:paintstick2]}/ and settings[:paintstick2].length > 0
			need_paintstick2 = false
		end
	}
	
	needed_items = Array.new
	
	if need_wood
		needed_items << settings[:wood]
	end
	if need_glue
		needed_items << "bottle of fletching glue"
	end
	if need_fletchings
		needed_items << settings[:fletchings]
	end
	if need_paint and settings[:paint] != 0
		needed_items << "vial of paint"
	end
	if need_paintstick1 and settings[:paintstick1].length > 0
		needed_items << settings[:paintstick1]
	end
	if need_paintstick2 and settings[:paintstick2].length > 0
		needed_items << settings[:paintstick2]
	end
	
	
	
	return needed_items
end

def find_order_num(supply)

	status_tags
	clear
	fput 'unhide' if hidden? or invisible?
	fput 'order'
	menu = Hash.new
	while (line = get) and (line !~ /ORDER|BUY/)
		for item in line.scan(/<d.*?cmd=["']order ([0-9]+).*?>(.*?)<\/d>/)
			menu[item[1].sub(/^a /, '')] = item[0]
		end
	end
	clear
	status_tags
	
	#menu = read_menu.call
	#echo menu.inspect
	
	item_name = menu.keys.find { |name| name =~ /#{supply}/i }
	unless order_number = menu[item_name]
		echo ""
		echo "Error: failed to find the item! Remember to leave off the a/an/some at the start. eg. 'limb of faewood"
		echo ""
	end
	return order_number
	
end

def buy_items(settings, needed_items)
	if invisible?
		invis = true
	else 
		invis = false
	end
	start_room = Room.current.id
	silver = checksilver
	if silver < 5000
		silver = 5000 - silver
		start_script "go2",['bank']
		wait_while {running?("go2")}
		fput "unhide" if hidden? or invisible?
		fput "withdraw #{silver}"
		if checksilver < 5000
			echo "Failed to get money from the bank"
			exit
		end
	end
	start_script "go2",['fletcher']
	wait_while {running?("go2")}
	move "south" if Room.current.location == "Ta'Vaalor"
					
	if checkleft != nil
		empty_left_hand
	end
	if checkright != nil
		empty_right_hand
	end
	needed_items.each {|item|
		
		if item =~ /vial of paint/
			order_number = find_order_num(item)
			multifput "order #{order_number} color #{settings[:paint]}", "buy"
		else
			order_number = find_order_num(item)
			multifput "order #{order_number}", "buy"
		end
		
		#wait up to three seconds to see if purchase was succesful
		endtime = Time.now + 3
		loop {
			if checkright.nil?
				sleep 1
			elsif Time.now > endtime
				echo "For some reason buying an item failed"
				exit
			elsif checkright
				echo "got item"
				break
			end
		}
		stow_check = dothistimeout "put my #{checkright} in my #{settings[:sack]}", 3, /won't fit|You put a/
		if stow_check =~ /won't fit/
			echo "fletchsack full, stopping"
			exit
		elsif stow_check.nil?
			echo "stowcheck failed, stopping"
			exit
		end
		
	}
	spent_silver += (5000 - checksilver)
	
	start_script "go2",['bank']
	wait_while {running?("go2")}
	fput "unhide" if hidden? or invisible?
	fput "depo all"
	if invis and Spell[916].affordable?
		fput "incant 916"
	end
	start_script "go2",[start_room]
	wait_while {running?("go2")}
	return spent_silver
end

def stow(hand,container)
	if (hand == "left")
		return if checkleft.nil?
	elsif (hand == "right")
		return if checkright.nil?
	else
		respond "This should not of happened"
		respond "Invalid hand of: #{hand}"
		exit
	end
	fput "put #{hand} in my #{container}"
	again = false
	endtime = Time.now + 6
	loop{
		if (checkleft.nil? && hand == "left")
			break
		elsif (checkright.nil? && hand == "right")
			break
		elsif Time.now > endtime -3 and !again
			again = true
			fput "put #{hand} in my #{container}"
		elsif Time.now > endtime
			"Stowing item failed"
		else
			sleep 0.1
		end
	}
end

def get_knife(settings)
	check = dothistimeout "get my #{settings[:knife]}", 3, /You remove|get what?/
	if check =~ /get what?/
		echo "Failed to get your knife."
		exit
	elsif check.nil?
		endtime = Time.now + 5
		loop {
			if checkleft =~ /#{settings[:knife]}/
				break
			elsif Time.now > endtime
				echo "Failed to get your knife."
				exit
			else
				sleep 1
			end
			}
	end
end

def haste!()
	waitcastrt?
	fput "incant 535" if Spell[535].known? and !Spell[535].active? and Spell[535].affordable?
end

def bundle(settings)

	quiver = GameObj.inv.find { |obj| obj.name =~ /#{settings[:quiver]}/ }
	contents = Hash.new
	quiver.contents.each {|item|
		item_id = item.id
		contents[item_id] = item.name
	}
	#finds the description of each different type of arrow
	arrow_types = Array.new
	contents.each_pair{|id,name|
		if name =~ /(arrow|bolt)$/ and !arrow_types.include? name
			arrow_types << name
		end
	}
	arrow_types.each{|desc|
		contents.each_pair{|id,name|
			if desc =~ /#{name}/
				if checkright.nil?
					fput "get ##{id} in my #{settings[:quiver]}"
					endtime = Time.now + 6
					wait_until{!checkright.nil? || Time.now > endtime}
				else
					fput "get ##{id} in my #{settings[:quiver]}"
				end
				if !checkleft.nil? and !checkright.nil?
					check = dothistimeout "bundle", 3, /You bundle your (arrow|bolt)s together.|You add a .+? to your bundle.|You may not combine more than 100 shafts./
					if check.nil?
						echo "bundling failed for some reason, stopping"
						exit
					elsif check =~ /You may not combine more than 100 shafts./
						stow("right",settings[:quiver])
					end
					endtime = Time.now + 6
					wait_until{checkleft.nil? || Time.now > endtime}
				end
			end
		}
		#fput "stow right"
		stow("right",settings[:quiver])
	}
	#now arrows are bundled see about condensing the bundles down
	bundle_ids = Array.new
	quiver_contents = get_container_contents(settings[:quiver])
	quiver_contents.each{|item|
		if item.name =~ /bundle .+? (bolt|arrow)s/
			bundle_ids << item.id
		end
	}
	
	bundle_amount = Array.new
	bundle_desc = Array.new
	bundle_check = proc{|server_string|
	#
	#Individual projectiles from this bundle will have a long of "a wooden arrow"
	#

		if server_string.nil?
			#nil
		elsif server_string =~ /You carefully count the <a exist="\d+" noun="\w+">\w+<\/a> and find (\d+) in the bundle, each one being .+, with a strength of \d+ and a durability of \d+./
			bundle_amount << $1
			nil
		elsif server_string =~ /^Individual projectiles from this bundle will have a (show|long) of "(.+?)".$|(.+?). You also notice a small enchanter's glyph.$/
			bundle_desc << $2
			nil
		elsif server_string =~ /Each individual projectile will be "(.+?)".$/
			nil
		elsif server_string =~ /<prompt time="\d+">&gt;<\/prompt>/
			nil
		else
			if server_string.length > 2
				server_string
			else
				nil
			end
		end
	}
	DownstreamHook.add('fletch_budle_check', bundle_check)
	silence_me
	bundle_ids.each{|id|
		fput "look ##{id}"
	}
	silence_me
	endtime = Time.now + 6
	wait_until{(bundle_ids.length == bundle_desc.length) || Time.now > endtime}
	DownstreamHook.remove('fletch_budle_check')
	if bundle_ids.length != bundle_desc.length
		echo "failed to get bundles info, stopping"
		exit
	end
	x = 0
	bundles = Array.new
	until x == bundle_ids.length
		bundles << bundle = {
			"id" => bundle_ids[x],
			"count" => bundle_amount[x],
			"desc" => bundle_desc[x]
		}
		x +=1
	end
	uniq_bundle_desc = bundle_desc & bundle_desc
	last_bundle = ""
	uniq_bundle_desc.each{|desc|
		total = 0
		bundles.each{|bundle|
			if bundle['desc'] == desc and total == 0 and bundle['count'].to_i!=100
				#there is a match but if there might only be one of that bundle so take note but do nothing
				total += bundle['count'].to_i
				last_bundle = bundle['id'].dup
			elsif bundle['desc'] == desc and total > 0 and bundle['count'].to_i!=100
				#match and the total is already above 0, must of already found a bundle of the same arrows
				total += bundle['count'].to_i
				if total < 100
					fput "get ##{bundle['id']}"
					matchtimeout 1, "You remove"
					fput "get ##{last_bundle}" if checkleft.nil?
					fput "bundle"
					last_bundle = bundle['id']
				else
				
					if total == 100
						fput "get ##{bundle['id']}"
						matchtimeout 1, "You remove"
						fput "get ##{last_bundle}" if checkleft.nil?
						fput "bundle"
						#fput "stow r"
						stow("right",settings[:quiver])
						total = 0
					else
						amount_over = total - 100
						amount_to_get = bundle['count'].to_i - amount_over
						fput "get #{amount_to_get} ##{bundle['id']}"
						matchtimeout 1, "You remove"
						fput "get ##{last_bundle}" if checkleft.nil?
						fput "bundle"
						#fput "stow r"
						stow("right",settings[:quiver])
						bundle['amount'] = bundle['amount'].to_i - amount_to_get	#resize the bundle
						bundles << bundle											#and add back on the end
						total = 0
					end
					
					
					
				end
			end
		}
		#fput "stow r" if !checkright.nil?
		stow("right",settings[:quiver]) if !checkright.nil?
	}
end

def make_shafts(settings)

	if settings[:wood] =~ /log/
		#get wood
		check = dothistimeout "get my log in my #{settings[:sack]}", 1, /You remove|Get what?/
		if check =~ /Get what?/
			echo "Run out of shafts some how, this shouldn't be happening."
			exit
		elsif check.nil?
			#backup for scripted containers
			endtime = Time.now + 5
			loop {
				if checkright =~ /log/
					break
				elsif Time.now > endtime
					echo "Could not get log, stopping"
					exit
				else
					sleep 1
				end
			}
		end
		#get axe
		check = dothistimeout "get my #{settings[:axe]}", 3, /You remove|get what?/
		if check =~ /get what?/
			echo "Could not get your axe to cut the shafts"
			exit
		elsif check.nil?
			#backup for scripted containers
			endtime = Time.now + 5
			loop {
				if checkright =~ /#{settings[:axe]}/
					break
				elsif Time.now > endtime
					echo "Could not get your axe to cut the shafts"
					exit
				else
					sleep 1
				end
			}
		end
		#cut shafts
		haste!
		if settings[:ammo] == 1
			fput "cut arrow shaft my log"
			endtime = Time.now + 6
			loop {
				if checkright =~ /shaft/
					need_shafts = false
					break
				elsif Time.now > endtime
					echo "Failed to cut shafts."
					exit
				else
					sleep 1
					echo "sleeping"
				end
			}
		elsif settings[:ammo] == 2
			fput "cut light bolt my log"
			endtime = Time.now + 6
			loop {
				if checkright =~ /shaft/
					need_shafts = false
					break
				elsif Time.now > endtime
					echo "Failed to cut shafts."
					exit
				else
					sleep 1
					echo "sleeping"
				end
			}
		elsif settings[:ammo] == 3
			fput "cut heavy bolt my log"
			endtime = Time.now + 6
			loop {
				if checkright =~ /shaft/
					need_shafts = false
					break
				elsif Time.now > endtime
					echo "Failed to cut shafts."
					exit
				else
					sleep 1
					echo "sleeping"
				end
			}
		end
	elsif settings[:wood] =~ /wood/
		#get wood
		check = dothistimeout "get my wood in my #{settings[:sack]}", 1, /You remove|Get what?/
		if check =~ /Get what?/
			echo "Run out of shafts some how, this shouldn't be happening."
			exit
		elsif check.nil?
			#backup for scripted containers
			endtime = Time.now + 5
			loop {
				if checkright =~ /wood/
					break
				elsif Time.now > endtime
					echo "Could not get wood, stopping"
					exit
				else
					sleep 1
				end
			}
		end
		#get axe
		check = dothistimeout "get my #{settings[:axe]}", 3, /You remove|get what?/
		if check =~ /get what?/
			echo "Could not get your axe to cut the shafts"
			exit
		elsif check.nil?
			#backup for scripted containers
			endtime = Time.now + 5
			loop {
				if checkright =~ /#{settings[:axe]}/
					break
				elsif Time.now > endtime
					echo "Could not get your axe to cut the shafts"
					exit
				else
					sleep 1
				end
			}
		end
		#cut shafts
		haste!
		if settings[:ammo] == 1
			fput "cut arrow shaft my wood"
			endtime = Time.now + 6
			loop {
				if checkright =~ /shaft/
					need_shafts = false
					break
				elsif Time.now > endtime
					echo "Failed to cut shafts."
					exit
				else
					sleep 1
					echo "sleeping"
				end
			}
		elsif settings[:ammo] == 2
			fput "cut light bolt my wood"
			endtime = Time.now + 6
			loop {
				if checkright =~ /shaft/
					need_shafts = false
					break
				elsif Time.now > endtime
					echo "Failed to cut shafts."
					exit
				else
					sleep 1
					echo "sleeping"
				end
			}
		elsif settings[:ammo] == 3
			fput "cut heavy bolt my wood"
			endtime = Time.now + 6
			loop {
				if checkright =~ /shaft/
					need_shafts = false
					break
				elsif Time.now > endtime
					echo "Failed to cut shafts."
					exit
				else
					sleep 1
					echo "sleeping"
				end
			}
		end
	end
	
	
	sleep 1
	waitrt?
	
	stow("right",settings[:sack])
	#fput "put right in my #{settings[:sack]}"
	endtime = Time.now + 6
	loop{
		if checkright.nil?
			break
		elsif Time.now > endtime
			"Stowing item failed"
			exit
		else
			sleep 0.5
		end
	}
	stow("left",settings[:sack])
end

def make_arrow(settings,paints)
	#get shaft
	check = dothistimeout "get 1 my shaft", 3, /You remove|get what?/
	if check =~ /get what?/
		echo "Run out of shafts some how, this shouldn't be happening."
		exit
	elsif check.nil?
		#backup for scripted containers
		endtime = Time.now + 5
		loop {
			if checkright =~ /shaft/
				break
			elsif Time.now > endtime
				echo "Could not get shaft, stopping"
				exit
			else
				sleep 1
			end
			}
	end
	get_knife(settings)
	#cut shaft
	haste!
	fput "cut my shaft with my #{settings[:knife]}"
	sleep 1
	waitrt?
	
	if checkright !~ /shaft/
		stow("left",settings[:sack])
		return
	end
	
	#painting goes here
	if settings[:paint] != 0
		stow("left",settings[:sack])
		paint = paints[settings[:paint]].split(" ")
		fput "get my #{paint[0]} paint"
		endtime = Time.now + 6
		loop{
			if checkleft =~ /paint/
				break
			elsif Time.now > (endtime - 3)
				fput "get my #{paint[0]} paint"
			elsif Time.now > endtime
				echo "Run out of paint, probably means you have another colour paint on you messing with my check. Get it out your fletchsack"
				exit
			else
				sleep 0.5
			end
		}
		haste!
		check = dothistimeout "paint my shaft", 3, /You carefully smear a bit of paint/
		if check.nil?
			#if the first check failed for some reason double check by looking at the arrow
			check = dothistimeout "look my shaft", 3, /has been pared down and smoothed.$|paint covers the shaft./
			if check !~ /paint covers the shaft./
				echo "Could not determine if painting was successful, stopping"
				exit
			end
		end
		check = matchtimeout 40, "The paint on your" 
		if !check
			echo "Did not see paint dry for some reason, carrying on in case it did but might cause problems if it didn't"
		end
		stow("left",settings[:sack])
		
	end
	#paintstick1
	if settings[:paintstick1].length > 0
		stow("left",settings[:sack])
		fput "get my #{settings[:paintstick1]}"
		endtime = Time.now + 6
		loop{
			if checkleft =~ /paintstick/
				break
			elsif Time.now > (endtime - 3)
				fput "get my #{settings[:paintstick1]}"
			elsif Time.now > endtime
				echo "Could not get your paintstick"
				exit
			else
				sleep 0.5
			end
		}
		haste!
		check = dothistimeout "paint my shaft", 3, /You carefully apply a band of/
		if check.nil?
			#if the first check failed for some reason double check by looking at the arrow
			check = dothistimeout "look my shaft", 3, /It looks like someone has painted a single .+ band on the end/
			if check !~ /It looks like someone has painted a single .+ band on the end/
				echo "Could not determine if painting was succesful, stopping"
				exit
			end
		end
		check = matchtimeout 40, "The paint on your" 
		if !check
			echo "Did not see paint dry for some reason, carrying on in case it did but might cause problems if it didn't"
		end
		waitrt?
		stow("left",settings[:sack])
	end
	
	#paintstick2
	if settings[:paintstick2].length > 0
		stow("left",settings[:sack])
		fput "get my #{settings[:paintstick2]}"
		endtime = Time.now + 6
		loop{
			if checkleft =~ /paintstick/
				break
			elsif Time.now > (endtime - 3)
				fput "get my #{settings[:paintstick2]}"
			elsif Time.now > endtime
				echo "Could not get your paintstick"
				exit
			else
				sleep 0.5
			end
		}
		haste!
		check = dothistimeout "paint my shaft", 3, /You carefully apply a band of/
		if check.nil?
			#if the first check failed for some reason double check by looking at the arrow
			check = dothistimeout "look my shaft", 3, /It looks like someone has painted a pair of .+ and .+ bands on the end.|It looks like someone has painted a single .+ band on the end/
			if check !~ /It looks like someone has painted a pair of .+ and .+ bands on the end.|It looks like someone has painted a single .+ band on the end/
				echo "Could not determine if painting was succesful, stopping"
				exit
			end
		end
		check = matchtimeout 40, "The paint on your" 
		if !check
			echo "Did not see paint dry for some reason, carrying on in case it did but might cause problems if it didn't"
		end
		waitrt?
		stow("left",settings[:sack])
	end
	
	#cut nocks in shaft
	if settings[:ammo] == 1
		sleep 1
		waitrt?
		waitrt?
		get_knife(settings) if settings[:paint] != 0 or settings[:paintstick1].length != 0  or settings[:paintstick2].length != 0
		haste!
		fput "cut nock in my shaft with my #{settings[:knife]}"
		fput "cut nock in my shaft with my #{settings[:knife]}" if settings[:paint] == 0 and settings[:paintstick1].length == 0  and settings[:paintstick2].length == 0
		sleep 2
		waitrt?
		if checkright !~ /shaft/
			stow("left",settings[:sack])
			return
		end
		stow("left",settings[:sack])
	end

	if settings[:learning]
		#set something up to search for waste barrel and put right in it.
		fput "drop right"
		fput "clean table"
		return
	end

	#measure shaft
	waitrt?
	check = dothistimeout "remove my #{settings[:bow]}", 1, /You unsling|remove what?|You sling/
	if check =~ /remove what?/
		echo "Failed to get your #{settings[:bow]}."
		exit
	elsif check.nil?
		endtime = Time.now + 5
		loop {
			if checkleft =~ /bow|crossbow/
				break
			elsif Time.now > endtime
				echo "Failed to get your bow."
				exit
			else
				sleep 1
			end
			}
	end
	haste!
	check = dothistimeout "measure my shaft with my #{settings[:bow]}", 3, /a tiny cut on the shaft/
	if check.nil?
		echo "failed, do something about this later"
		exit
	end
	sleep 1
	waitrt?
	check = dothistimeout "wear my #{settings[:bow]}", 3, /You sling/
	if check.nil?
		echo "failed, do something about this later"
		exit
	end
	get_knife(settings)
	haste!
	check = dothistimeout "cut my shaft with my  #{settings[:knife]}", 3, /Using your previous mark as a guide, you cleanly slice the end off|You might want to think about attaching fletchings first|you should paint or crest your shafts before cutting them to length/
	if check.nil?
		echo "failed, do something about this later"
		exit
	end
	if check =~ /you should paint or crest your shafts before cutting them to length/
		fput "cut my shaft with my #{settings[:knife]}"
	end
	sleep 1
	waitrt?
	if checkright !~ /shaft/
		stow("left",settings[:sack])
		return
	end
	stow("left",settings[:sack])
	
	fput "get my glue"
	endtime = Time.now + 6
	loop{
		
		if checkleft =~ /glue/
			break
		elsif Time.now > endtime
			"Failed to get glue"
			exit
		else
			sleep 0.1
		end
	}
	
	haste!
	check = dothistimeout "put my glue on my shaft", 3, /You carefully smear a bit of glue/
	if check.nil?
		echo "failed, do something about this later"
		exit
	end
	sleep 1
	waitrt?
	stow("left",settings[:sack])
	
	fput "get 3 fletching in my #{settings[:sack]}"
	endtime = Time.now + 6
	loop{
		if checkleft =~ /fletching/
			break
		elsif Time.now > endtime
			"Failed to get fletchings"
			exit
		else
			sleep 0.1
		end
	}
	
	haste!
	check = dothistimeout "put my fletching on my shaft", 3, /You attach your|Unfortunately, the glue is now too dry to remove them and try again, so you discard /
	if check =~/Unfortunately, the glue is now too dry to remove them and try again, so you discard /
		return
	end
	if !(checkright =~ /shaft/ and checkleft.nil?)
		echo "failed, do something about this later"
		exit
	end
	check = matchtimeout 60, "has dried."
	if check == false
		echo "didnt see glue dry for some reason, stopping"
		exit
	end
	waitrt?
	if checkright !~ /shaft/
		stow("left",settings[:sack])
		return
	end

	# Portion about adding arrow head.	
#	check = dothistimeout "get 1 triangle cap", 1, /You (get|remove)/
#	if check.nil?
#		echo "failed to get your tip"
#		exit
#	end
#	
#	check = dothistimeout "turn my cap", 2, /secure in place with an amazingly tight fit/
#	if check.nil?
#		echo "failed to apply your tip"
#		exit
#	end

	get_knife(settings)
	haste!
	put "cut my shaft with my  #{settings[:knife]}"
	put "cut my shaft with my  #{settings[:knife]}"
	check = matchtimeout 6, "With a few quick cuts,", "Working a bit too hastily, you slice the end right off!"
	if check == false
		echo "didnt see you cut the shaft for some reason, stopping"
		exit
	end
	
	waitrt?
	stow("left",settings[:sack])
	

end


container_contents = nil
needed_items = nil
start_time = Time.now
arrows_made = 0
arrows_failed = 0
spent_silver = 0
finished = false

if variable[0] =~ /setup|config|configure/i
	setup.call
	exit
elsif variable[0] =~ /bundle/i
	bundle(settings)
	exit
elsif !variable[0].nil?
	message = ""
	message += "This script needs a map room if you want it to buy items for you. If this is the case when ever you run out of an item the script will run and buy more\r\n"
	message += "Run ;fletchit setup at any times to change you settings\r\n"
	message += "Anytime the script is running ;fletchit will give you a progress report. ;fletchit stop will tell the script to end after finishing the arrow it is curently on. This is the prefered method of stopping, partially cut shafts left in a container migt cause the script to fail\r\n"
	
	if !$fake_stormfront
		puts "<output class=\"mono\"/>#{monsterbold_start}#{message}#{monsterbold_end}\r\n<output class=\"\"/>"
	else
		puts "#{monsterbold_start}#{message}#{monsterbold_end}"
	end
	exit
end


fletching_report = proc { |client_string|
    if client_string =~ /^(?:<c>)?#{$clean_lich_char}(?:fletchit)$/i
		
        respond ""
		respond "Script has been running for #{Time.at(Time.now - start_time).strftime("%H hours, %M minutes %S seconds")}, made #{arrows_made} arrows, ruined #{arrows_failed} arrows and spent #{spent_silver} silver"
		respond ""
	elsif client_string =~ /^(?:<c>)?#{$clean_lich_char}fletchit (?:stop|done|end|finish|finished)$/i
		finished = true
		respond ""
		respond "Once current arrow is complete script will end"
		respond ""
    else
        client_string
    end
}

UpstreamHook.add('fletching_hook', fletching_report)
before_dying{;UpstreamHook.remove('fletching_hook');}

warning = ""
if settings[:sack] == "" or settings[:sack].nil?
	warning += "The container for you supplies has not yet been set, the script will not run until this is added.\r\n"
end
if settings[:quiver] == "" or settings[:quiver].nil?
	warning += "The container for you finished arrows has not yet been set, the script will not run until this is added.\r\n"
end
if settings[:knife] == ""
	warning += "Have not set a knife/dagger to cut the shafts with, the script will not run until this is added.\r\n"
end
if settings[:bow] == ""
	warning += "Have not set a bow to measure the shafts with, the script will not run until this is added.\r\n"
end
if settings[:axe] == ""
	warning += "Have not set an axe to make shafts with, the script will not run until this is added.\r\n"
end
if settings[:wood] == ""
	warning += "Have not set a what wood you want to use, the script will not run until this is added.\r\n"
end
if settings[:wood] != "" and settings[:wood] !~ /wood|log/
	warning += "You have set what wood you want to use but appears you may have done so incorrectly. It should read along the lines of 'limb of wood' or 'branch of faewood' for example. Leave off any a/an/some from the start\r\n"
end
if settings[:fletchings] != "" and settings[:fletchings] !~ /fletching/
	warning += "You have set what fletchings you want to use but appears you may have done so incorrectly. It should read along the lines of 'bundle of fletchings' for example. Leave off any a/an/some from the start.\r\n"
end
		
if warning.length > 0
	if !$fake_stormfront
		puts "<output class=\"mono\"/>#{monsterbold_start}#{warning}#{monsterbold_end}\r\n<output class=\"\"/>"
	else
		puts "#{monsterbold_start}#{warning}#{monsterbold_end}"
	end
	setup.call
	exit
end
if settings[:alerts]
	monitor_interaction()
end
empty_left_hand
empty_right_hand
loop{
	if settings[:waggle]
		start_script "waggle"
		wait_while {running?("waggle")}
	end
	fletch_sack_contents = get_container_contents(settings[:sack])
	needed_items = check_needed_items(settings,fletch_sack_contents,paints)
	if !needed_items.empty?
		if !settings[:enable_buying]
			echo "Run out of #{needed_items[0]} and the script is not set to buy more, ';fletchit setup' to change this."
			exit
		end
		respond ""
		needed_items.each{|item|
			respond "Out of #{item}"
		}
		respond "Off to buy"
		respond ""
		sleep 1
		spent_silver += buy_items(settings, needed_items)
		needed_items = Array.new
	end
	fletch_sack_contents = get_container_contents(settings[:sack])
	make_shafts(settings) if fletch_sack_contents.to_s.include? '@noun="wood"'
	
	if settings[:learning]
		#if percentmind > 55
		#	fput "boost long"
		#end
		wait_while { percentmind > 70 }
	end
	
	make_arrow(settings,paints)
	if !(checkright =~ /arrow|bolt/).nil?
		echo "stowing"
		stow("right",settings[:quiver])
		arrows_made += 1
	else
		arrows_failed += 1
	end
	
	if !settings[:learning] 
		respond ""
		respond "Script has been running for #{Time.at(Time.now - start_time).strftime("%H hours, %M minutes %S seconds")}, made #{arrows_made} arrows, ruined #{arrows_failed} arrows and spent #{spent_silver} silver"
		respond ""
	end
	exit if finished
	exit if settings[:limit].to_i > 0 and arrows_made == settings[:limit].to_i
	}



#You take a deep breath as you realize with pride that you have mastered the skill of fletching!