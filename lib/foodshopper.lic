=begin
	https://discord.com/channels/226045346399256576/1285045233238806539
	
	Script created with Chat GPT.
=end
require 'yaml'

# Define paths for compiled data
DATA_DIR = "#{$data_dir}#{XMLData.game}/#{Char.name}/"
COMPILED_FOODS_PATH = "#{DATA_DIR}compiled_foods.yaml"
GLOBAL_CONSTANTS_PATH = "#{$script_dir}/npcfoods.rb"  # Load from npcfoods.rb
METADATA_PATH = "#{DATA_DIR}compiled_foods_metadata.yaml"

# Ensure directories exist
Dir.mkdir("#{$data_dir}#{XMLData.game}") unless Dir.exist?("#{$data_dir}#{XMLData.game}")
Dir.mkdir(DATA_DIR) unless Dir.exist?(DATA_DIR)

# Function to get the current file size of npcfoods.rb
def current_file_size
  File.size(GLOBAL_CONSTANTS_PATH)
end

# Load or compile FOODS_DB with metadata check
def load_or_compile_foods_data(force_recompile = false)
  metadata = {}

  if File.exist?(METADATA_PATH)
    metadata = YAML.load_file(METADATA_PATH) || {}
  end

  last_compiled_size = metadata['file_size']
  current_size = current_file_size

  if force_recompile || !File.exist?(COMPILED_FOODS_PATH) || last_compiled_size != current_size
    echo("Compiling food data from npcfoods.rb...")

    begin
      load GLOBAL_CONSTANTS_PATH
    rescue LoadError => e
      echo("Error loading npcfoods.rb: #{e.message}")
      return {}
    rescue StandardError => e
      echo("Error during loading npcfoods.rb: #{e.message}")
      return {}
    end

    unless defined?(FOODS_DB)
      echo("Error: FOODS_DB constant is not defined in npcfoods.rb. Check that it is defined correctly and accessible.")
      return {}
    end

    # Save compiled data to YAML file
    File.open(COMPILED_FOODS_PATH, 'w') { |file| file.write(FOODS_DB.to_yaml) }
    # Save metadata
    File.open(METADATA_PATH, 'w') { |file| file.write({ 'file_size' => current_size }.to_yaml) }

    echo("Compiled food data saved to YAML file.")
    echo("Note: If foodshopper compiles a new YAML, please run the search again for the term you were searching for.")
    return {} # Return empty to indicate recompilation
  else
    # Attempt to load compiled data
    begin
      YAML.load_file(COMPILED_FOODS_PATH)
    rescue StandardError => e
      echo("Error loading compiled foods data: #{e.message}")
      {}
    end
  end
end

# Load FOODS_DB initially without reassigning the constant
FOODS_DB = load_or_compile_foods_data

# Function to safely access and possibly recompile FOODS_DB without reassigning the constant
def get_foods_db(force_recompile = false)
  force_recompile ? load_or_compile_foods_data(force_recompile) : FOODS_DB
end

# Levenshtein distance function for fuzzy matching
def levenshtein_distance(str1, str2)
  s1, s2 = str1.downcase, str2.downcase
  matrix = [(0..s1.length).to_a]
  (1..s2.length).each { |j| matrix << [j] + [0] * (s1.length) }

  (1..s2.length).each do |i|
    (1..s1.length).each do |j|
      if s2[i - 1] == s1[j - 1]
        matrix[i][j] = matrix[i - 1][j - 1]
      else
        matrix[i][j] = [matrix[i - 1][j], matrix[i][j - 1], matrix[i - 1][j - 1]].min + 1
      end
    end
  end
  matrix.last.last
end

# Function to display matched foods with sorting by relevance
def display_food_matches(term, matching_items, closest_matches)
  exact_matches = matching_items.select { |item| item[:name].downcase == term } # Find exact matches
  other_matches = matching_items.reject { |item| item[:name].downcase == term } # Other matches

  # Sort matches by relevance (name matches first, then description matches)
  matching_items.sort_by! do |item|
    name_match = item[:name].downcase.include?(term) ? 0 : 1
    description_match = item[:description].downcase.include?(term) ? 0 : 1
    [name_match, description_match]
  end

  if matching_items.empty?
    if closest_matches.empty?
      echo("No matching food items found for '#{term}'.")
    else
      closest_match = closest_matches.min_by { |_, data| data[:distance] }
      item, data = closest_match
      echo("No exact match found. Closest match for '#{term}':\n")
      echo("\n     #{item[:name]}\n          UID: #{item[:uid]} | #{item[:shop_name]} | #{item[:location]}\n          Menu#: #{item[:order_number]} | Backroom: #{item[:backroom_access]}\n\n          Description: #{item[:description]}\n          Exists in Real Life: #{item[:real_world_equivalent].include?('Exists') ? 'Y' : 'N'}")
    end
  else
    echo("Matching food items for '#{term}':")

    # Display sorted matches
    matching_items.each do |item|
      echo("\n     #{item[:name]}\n          UID: #{item[:uid]} | #{item[:shop_name]} | #{item[:location]}\n          Menu#: #{item[:order_number]} | Backroom: #{item[:backroom_access]}\n\n          Description: #{item[:description]}\n          Exists in Real Life: #{item[:real_world_equivalent].include?('Exists') ? 'Y' : 'N'}")
    end
  end
end

# Function to find and display foods by term
def find_foods_by_term(term, database)
  term = term.downcase.strip
  matching_items = []
  closest_matches = {}

  echo("Searching for term '#{term}' across specific fields...") if $debug_mode

  # Use a safe iteration by collecting matching items without modifying the hash directly
  database.each do |shop_name, foods|
    foods.each do |food|
      # Include the shop name in the food item for display purposes
      food = food.dup
      food[:shop_name] = shop_name

      # Check if term matches only the food name or description
      food_name_match = food[:name].downcase.include?(term)
      description_match = food[:description].downcase.include?(term)

      # Debugging output for each comparison
      if $debug_mode
        echo("Checking food name: '#{food[:name].downcase}' includes '#{term}': #{food_name_match}")
        echo("Checking description: '#{food[:description].downcase}' includes '#{term}': #{description_match}")
      end

      if food_name_match || description_match
        echo("Match found: Name='#{food[:name]}', Desc='#{food[:description]}', Location='#{food[:location]}'") if $debug_mode
        matching_items << food
      else
        # Calculate distance for fuzzy matching
        distance = levenshtein_distance(term, food[:name])
        closest_matches[food] = { distance: distance } if distance <= 3
      end
    end
  end

  display_food_matches(term, matching_items, closest_matches)
end

# Main function to run the foodshopper
def run_foodfinder(script)
  # Determine if recompile is requested
  force_recompile = script.vars.include?("recompile")
  $debug_mode = script.vars.include?("debug")

  # Remove 'recompile' and 'debug' from the term if present
  term = script.vars.reject { |var| var == "recompile" || var == "debug" }.first&.strip&.downcase
  echo "Using term: '#{term}'" if $debug_mode

  if term.nil? || term.empty?
    echo("Usage: ;foodshopper TERM (e.g., ;foodshopper coffee) or ;foodshopper TERM debug for detailed output, or ;foodshopper recompile to refresh data.")
    return
  end

  # Load or recompile FOODS_DB based on the recompile flag
  foods_db = get_foods_db(force_recompile)

  # Handle the command with the parsed input
  find_foods_by_term(term, foods_db)
end

run_foodfinder(script)
