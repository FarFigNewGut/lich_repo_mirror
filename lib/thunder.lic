=begin

	You need to download the script ;struck and run it for any character that you want to connect to the server created by running this script.

	This script essentially creates a server on your computer so all of your characters can communicate with one another, no matter where they are in the game world.
	
	This script also creates a window which shows a lot of information about your characters; such as their health, stamina, mana, current bounty, Lich room number, and more!
	
	The script also tracks which characters are connected to the server, which ones have disconnected, and which ones have become unresponsive.
	
	You can also send commands to all of your characters or just one character and those character(s) will perform those actions, just as if you entered the command manually in their game window.
	
	There are various settings so you can make the script work just the way you want it.
	
	Be sure to start this script first on the character you want to act as the server, then start the script ;struck on any character you want to connect to the server.

	Version 1: Initial release!
	Version 2: Sending a command from ;thunder that starts with either 'script' or ';' will start a lich script.
	Version 2: Example: script go2 400 and ;go2 400 would both work.
	Version 3: Script now tracks more status conditions and will now track multiple status conditions. You can now see if a character is bleeding AND stunned. Or even bleeding, stunned, and sleeping!
	Version 3: Script can now track the field experience of all characters.
	Version 3: Script can now track the encumbrance of all characters.
	Version 3: You can now send commands to clients via ;send, because clicking buttons is too much work.
		To send a command to everyone do: ;send t all <command> || example: ;send t all wave
		To send a command to a specific character do: ;send t <name> <command> || example ;send t dreaven wave
		Works for scripts too! ;send t Dreaven ;go2 bank
		You can also partially match a character's name. Example: ;send t dre wave
	Version 4: The Settings tab is now scrollable, so be sure to scroll to the bottom if you don't see the "Save" button. Now without the Settings stretching out the window it means you can make the Main window smaller now if you want.
	Version 4: You now have the option of having the Stats tab and the Logs tab in their own separate windows, or hiding the tab/window altogether.
	Version 4: Added a Monitor tab which can monitor the game lines of a client as well as the scripts that client is currently running. Monitor also has the option of being a tab, being in its own window, or being hidden.
	Version 4: Added option to hide the Settings tab. If tab is hidden then start script as ;thunder set to show the tab again.

	########################################################
	Ways to contact me:
	In game: Dreaven
	Player's Corner: Tgo01
	Discord: Dreaven#6436
	Email: LordDreaven@gmail.com
	If you like my scripts feel free to send me a tip via Paypal at: LordDreaven@gmail.com
	########################################################
	
	Author: Dreaven
	Version: 4

=end

silence_me

require 'socket'

hide_me

class ThunderMain
	@save_file = "Thunder Settings.json"
	@lock_file = "Lock File.lock"
	@load_data = nil
	@close_windows = nil
	@needed_values = {}
	@current_stats = {}
	@windows = {}
	
	size_info = "\n\nNote: Manually resizing the window won't work because some tabs use a scrolled window and scrolled windows won't change size by manually resizing the window, so you must set this setting to get the proper size you want."
	stat_info = "\n\nUncheck this box to not see this info."
	update_info = "\n\nRegardless of what you enter here, information is only sent from a client/updated if there has been a change in that specific stat since the last update."
	window_info = "Selet 'Tab' to have this information shown in a tab on the Main window\n\nSelect 'Window' to have this information shown in its own window instead of a tab.\n\nSelect 'Hide' to not have this information shown at all."
	auto_scroll = "Click the log below to turn auto scroll on and off.\n\nWhile on the window will automatically scroll to the bottom as more lines are added to the log.\n\nWhile off the window won't automatically scroll to the bottom."
	
	@tooltips = {
		"Server Status" => "The current status of the server.",
		"Latest Client Status" => "The latest status report received from a client.",
		"Everyone Connected" => "Everyone currently connected to the server.",
		"Latest Message" => "The latest message received from a client.",
		"Last Command Sent" => "The last command you sent to a client.",
		"Update Room" => "How many seconds clients (and yourself) will wait until updating their current room number again.#{update_info}",
		"Update Info" => "How many seconds clients (and yourself) will wait until updating their info (health, mana, bounty info, etc) again.#{update_info}",
		"Update Exp" => "How many seconds clients (and yourself) will wait until updating their experience again. Script will also update experience whenever the character's mind state changes, and then wait this many seconds before updating again.#{update_info}",
		"Log Entries" => "The number of entries you want to save for each log.",
		"Monitor Entries" => "The number of entries you want to save for Monitor logging.\n\nMonitor allows you to select a client and the game lines the client sees will appear in the Monitor area. the 'Seen Lines' setting is related to this feature.\n\nSet to 0 to not make use of the Monitor system at all and the client won't track how many times they have seen game lines.",
		"Main Width" => "The width in pixels you want the Main window to be.#{size_info}",
		"Main Height" => "The height in pixels you want the Main window to be.#{size_info}",
		"Stats Width" => "The width in pixels you want the Stats window to be.#{size_info}",
		"Stats Height" => "The height in pixels you want the Stats window to be.#{size_info}",
		"Logs Width" => "The width in pixels you want the Logs window to be.#{size_info}",
		"Logs Height" => "The height in pixels you want the Logs window to be.#{size_info}",
		"Monitor Width" => "The width in pixels you want the Monitor window to be.#{size_info}",
		"Monitor Height" => "The height in pixels you want the Monitor window to be.#{size_info}",
		"Port Number" => "The port number you want the server to be set up on.\n\nIMPORTANT: You must set the port number on each client/character to match this number. Start ;struck on every client for more info on how to set the port number.\n\nBy default ;thunder and ;struck all connect to port 4000.",
		"Client Menu" => "List of everyone connected to the server.\n\nSelect who you want to send a command to. 'Everyone' will send a command to everyone.",
		"Logs Menu" => "Select which log you want to view.",
		"Send Command" => "Select the person you want to send a command to from the drop down menu, then enter the command you want to send in the box, then click 'Send' to have the selected person perform that command.\n\nFor example if you want someone to wave simply type in 'wave' and click 'Send.'\n\nTo have the character(s) start a script enter the word 'script' or enter ';' first, followed by the script name then any command line variables.\n\nExample: script go2 400\n\nExample: ;go2 400",
		"Save" => "Click this button to save all current settings.\n\nIMPORTANT: Saved settings won't take effect until you restart the script.\n\nIMPORTANT: Clicking this button will also save the current position of the windows so whenever you load the script the windows will return to these positions.",
		"Defaults" => "Click this button to set all settings back to their default values.\n\nIMPORTANT: You still have to click the 'Save' button to save these settings, you would then need to restart the script for the settings to take effect.",
		"Show Tooltips" => "Check this box if you want to see tooltips when you hover the mouse over items.\n\nUncheck this box to not see tooltips.",
		"Health" => "Check this box if you want to see everyone's Health in the status tab.#{stat_info}",
		"Mana" => "Check this box if you want to see everyone's Mana in the status tab.#{stat_info}",
		"Stamina" => "Check this box if you want to see everyone's Stamina in the status tab.#{stat_info}",
		"Spirit" => "Check this box if you want to see everyone's Spirit in the status tab.#{stat_info}",
		"Field Exp" => "Check this box if you want to see everyone's current field experience in the status tab.#{stat_info}",
		"Encumbrance" => "Check this box if you want to see everyone's current encumbrance in the status tab.#{stat_info}",
		"Status" => "Check this box if you want to see everyone's Status (stunned, prone, bleeding, etc) in the status tab.#{stat_info}",
		"Bounty" => "Check this box if you want to see everyone's Bounty info in the status tab.#{stat_info}",
		"Room #" => "Check this box if you want to see the everyone's current Lich room number in the status tab.#{stat_info}",
		"Debug Mode" => "Check this box if you want each client to echo back every command they send to the server and every command they receive from the server. This can cause a lot of echo information to be displayed for each client so you really only need it on to identify an issue, or if you just like to see these kinds of things.\n\nUncheck to not see these messages.",
		"Characters/Row" => "How many characters to show per row in the 'Stats' tab.",
		"Stats" => window_info,
		"Logs" => window_info,
		"Monitor" => window_info,
		"Link Windows" => "Check this box if you want all windows to be minimized/return to normal state when any window is minimized/returned to normal state.\n\nUncheck this box to unlink the windows.",
		"Hide Settings" => "Check this box if you want to hide the Settings tab on the Main window.\n\nUncheck this box to show the Settings tab on the Main window.\n\nIMPORTANT: If you hide the Settings tab then the only way to see the tab again is to start script as ;thunder set, which will show the Settings tab but won't change the setting you have here.",
		"Logs Scroll Active" => auto_scroll,
		"Monitor Scroll Active" => auto_scroll,
		"Seen Lines" => "How many times the client can see the same game line before they stop sending that game line to the Monitor.\n\nFor example: if you enter 2 here, then the first two times the selected client sees the same game line it will appear in the monitor area, however if the client sees the same game line anymore after that the game line won't show in the Monitor.\n\nSet to 0 to have every game line shown in the Monitor, regardless of how many times it has been seen.\n\nNote: Each client tracks how many times they have seen the same game line, regardless of whether they are the selected person to Monitor or not.",
	}
	
	@silence = proc{
		started = false
		hook_proc = proc { |s|
			if started
				if s =~ /<prompt/
					DownstreamHook.remove("thunder_silence")
					nil
				elsif s =~ /<output/
					s
				else
					nil
				end
			elsif s =~ /Level:/
				started = true
				nil
			else
				s
			end
		}
		DownstreamHook.add("thunder_silence", hook_proc)
	}
	
	@defaults = {
		"Update Room" => 1.0,
		"Update Info" => 0.5,
		"Update Exp" => 60,
		"Log Entries" => 100,
		"Monitor Entries" => 0,
		"Seen Lines" => 2,
		"Main Width" => 400,
		"Main Height" => 400,
		"Stats Width" => 400,
		"Stats Height" => 400,
		"Logs Width" => 400,
		"Logs Height" => 400,
		"Monitor Width" => 400,
		"Monitor Height" => 400,
		"Port Number" => 4000,
		"Characters/Row" => 2,
		"Main Horizontal Position" => 0,
		"Main Vertical Position" => 0,
		"Stats Horizontal Position" => 0,
		"Stats Vertical Position" => 0,
		"Logs Horizontal Position" => 0,
		"Logs Vertical Position" => 0,
		"Monitor Horizontal Position" => 0,
		"Monitor Vertical Position" => 0,
		"Health" => "Yes",
		"Mana" => "Yes",
		"Stamina" => "Yes",
		"Spirit" => "Yes",
		"Field Exp" => "Yes",
		"Encumbrance" => "Yes",
		"Status" => "Yes",
		"Bounty" => "Yes",
		"Room #" => "Yes",
		"Show Tooltips" => "Yes",
		"Debug Mode" => "No",
		"Stats" => "Tab",
		"Logs" => "Tab",
		"Monitor" => "Tab",
		"Link Windows" => "Yes",
		"Hide Settings" => "No",
	}
	
	def self.load_the_data
		begin
			File.open(@lock_file, File::RDWR | File::CREAT){ |lock_file|
				lock_file.flock(File::LOCK_EX)
				
				return unless File.exist?(@save_file)
				
				@load_data = JSON.parse(File.read(@save_file))
			}
			@load_data = @load_data[checkname]
		rescue StandardError => e
			respond "Error message from ;thunder: #{e.message}"
		ensure
			File.open(@lock_file, File::RDWR | File::CREAT){ |lock_file| lock_file.flock(File::LOCK_UN) }
		end
	end
	
	load_the_data
	
	@defaults.each{ |setting_name,value|
		if value.is_a?(Integer)
			@needed_values[setting_name] = @load_data[setting_name] ? @load_data[setting_name].to_i : @defaults[setting_name]
		elsif value.is_a?(Float)
			@needed_values[setting_name] = @load_data[setting_name] ? @load_data[setting_name].to_f : @defaults[setting_name]
		else
			@needed_values[setting_name] = @load_data[setting_name] ? @load_data[setting_name] : @defaults[setting_name]
		end
	}
	@needed_values["Monitor Entries"] = 0 if @needed_values["Monitor"] == "Hide"
	
	bar_names = [ "Health", "Mana", "Stamina", "Spirit", "Field Exp", "Encumbrance" ]
	@needed_bars = []
	bar_names.each{ |bar_name| @needed_bars.push(bar_name) if @needed_values[bar_name] == "Yes" }
	@regex_bars = @needed_bars.map{ |label| label.gsub(",","") }.join("|")
	
	labels = [ "Status", "Bounty", "Room #" ]
	@status_labels = []
	labels.each{ |label_name| @status_labels.push(label_name) if @needed_values[label_name] == "Yes" }
	@regex_labels = @status_labels.map{ |label| label.gsub(",","") }.join("|")
	
	stat_list = [ "Health", "Mana", "Stamina", "Spirit", "Field Exp", "Encumbrance", "Status", "Bounty", "Room #", "Debug Mode", "Update Room", "Update Info", "Update Exp", "Stats", "Monitor Entries", "Seen Lines" ]
	@required_info = "Requests: "
	stat_list.each{ |name| @required_info += "#{name}: #{@needed_values[name]}, " }
	@required_info.chop!.chop!

	def self.save_settings
		File.open(@lock_file, File::RDWR | File::CREAT){ |lock|
			lock.flock(File::LOCK_EX)
			
			if File.exist?(@save_file)
				save_data = JSON.parse(File.read(@save_file))
			else
				save_data = {}
			end
			
			save_data[checkname] ||= {}
			
			@windows.each{ |name,window|
				x, y = window.position
				save_data[checkname]["#{name} Horizontal Position"] = x
				save_data[checkname]["#{name} Vertical Position"] = y
			}
			
			@spin_buttons.each{ |name,button| save_data[checkname][name] = button.value.round(1) }
			@check_boxes.each{ |name,box|
				if box.active?
					save_data[checkname][name] = "Yes"
				else
					save_data[checkname][name] = "No"
				end
			}
			
			@radio_buttons.each{ |name,button|
				if button.active?
					info = name.split(" ")
					save_data[checkname][info[0]] = info[1]
				end
			}
				
			File.open(@save_file, 'w'){ |file| file.write(JSON.pretty_generate(save_data)) }
			respond ";thunder: Data saved."
		}
	end

	def self.create_main_window
		if @needed_values["Hide Settings"] == "Yes"
			respond "#################################################################################################################"
			respond "Message from ;thunder"
			respond "You have the Settings tab hidden. To see the settings tab again start script as: ;thunder set"
			respond "Starting script like this won't change the setting you have for the 'Hide Settings' option."
			respond "#################################################################################################################"
		end
		@windows["Main"] = Gtk::Window.new(:toplevel)
		@windows["Main"].set_keep_above(true)
		@windows["Main"].set_title("Main - #{checkname}")
		@windows["Main"].move(@needed_values["Main Horizontal Position"], @needed_values["Main Vertical Position"])
		@windows["Main"].set_size_request(@needed_values["Main Width"], @needed_values["Main Height"])
		
		@all_labels = {}
		@all_menus = {}
		@logs = {}
		@all_grids = {}
		@info_labels = {}
		@progress_bars = {}
		@overlays = {}
		@threads = {}
		@scroll_windows = {}
		@buttons = {}
		@event_boxes = {}
		@auto_scroll = {}
		@click_timers = {}
		
		grids = [ "Main Parent", "Main Info", "Main Menu", "Main Entry", "Stats Parent", "Stats Players", "Logs Parent", "Logs Menu", "Logs Labels", "Logs Scroll", "Settings Parent", "Settings Spin Buttons", "Settings Checkboxes", "Settings Radio Buttons", "Settings Button", "Monitor Parent", "Monitor Menu", "Monitor Labels", "Monitor Scroll" ]
		grids.each{ |grid| @all_grids[grid] = Gtk::Grid.new }

		@scroll_windows["Settings"] = Gtk::ScrolledWindow.new
		@scroll_windows["Settings"].add(@all_grids["Settings Parent"])
		
		@main_notebook = Gtk::Notebook.new
		@main_notebook.append_page(@all_grids["Main Parent"], Gtk::Label.new("Main"))
		@main_notebook.append_page(@all_grids["Stats Parent"], Gtk::Label.new("Stats")) if @needed_values["Stats"] == "Tab"
		@main_notebook.append_page(@all_grids["Logs Parent"], Gtk::Label.new("Logs")) if @needed_values["Logs"] == "Tab"
		@main_notebook.append_page(@all_grids["Monitor Parent"], Gtk::Label.new("Monitor")) if @needed_values["Monitor"] == "Tab"
		@main_notebook.append_page(@scroll_windows["Settings"], Gtk::Label.new("Settings")) if @needed_values["Hide Settings"] == "No" || @show_settings
		
		create_settings_page if @needed_values["Hide Settings"] == "No" || @show_settings
		
		row = -1
		@all_grids["Main Parent"].attach(@all_grids["Main Info"], 0, row += 1, 1, 1)
		@all_grids["Main Parent"].attach(@all_grids["Main Menu"], 0, row += 1, 1, 1)
		@all_grids["Main Parent"].attach(@all_grids["Main Entry"], 0, row += 1, 1, 1)

		row = -1
		@all_grids["Settings Parent"].attach(@all_grids["Settings Spin Buttons"], 0, row += 1, 1, 1)
		@all_grids["Settings Parent"].attach(@all_grids["Settings Checkboxes"], 0, row += 1, 1, 1)
		@all_grids["Settings Parent"].attach(@all_grids["Settings Radio Buttons"], 0, row += 1, 1, 1)
		@all_grids["Settings Parent"].attach(@all_grids["Settings Button"], 0, row += 1, 1, 1)

		row = -1
		labels = [ "Server Status", "Latest Client Status", "Everyone Connected", "Latest Message", "Last Command Sent", "Clients Unresponsive" ]
		labels.each{ |label|
			@all_labels[label] = Gtk::Label.new("#{label}: ")
			@all_labels[label].set_line_wrap(true)
			@all_labels[label].set_line_wrap_mode(:word)
			@all_labels[label].set_halign(Gtk::Align::START)
			@all_grids["Main Info"].attach(@all_labels[label], 0, row += 1, 1, 1)
		}
		@all_labels["Clients Unresponsive"].text = "Clients Unresponsive: NONE"
		
		@all_menus["Client Menu"] = Gtk::ComboBoxText.new
		
		@command_entry = Gtk::Entry.new
		@buttons["Command"] = Gtk::Button.new("Send")
		add_tooltip(@command_entry, "Send Command")
		add_tooltip(@buttons["Command"], "Send Command")
		@all_grids["Main Menu"].attach(@all_menus["Client Menu"], 0, 0, 1, 1)
		@all_grids["Main Entry"].attach(@command_entry, 0, 0, 1, 1)
		@all_grids["Main Entry"].attach(@buttons["Command"], 1, 0, 1, 1)
		
		create_tab("Logs") if @needed_values["Logs"] != "Hide"
		create_tab("Monitor") if @needed_values["Monitor"] != "Hide" && @needed_values["Monitor Entries"] > 0
		
		if @needed_values["Stats"] != "Hide"
			@scroll_windows["Stats"] = Gtk::ScrolledWindow.new
			@scroll_windows["Stats"].add(@all_grids["Stats Players"])
			@all_grids["Stats Parent"].attach(@scroll_windows["Stats"], 0, 0, 1, 1)
		end
		
		@buttons["Command"].signal_connect("clicked"){
			person = @all_menus["Client Menu"].active_text
			command = @command_entry.text
			command_to_send(person, command)
		}
		
		@windows["Main"].signal_connect("destroy") do
			@windows.each{ |name,window|
				@close_windows = true
				@windows[name].close
				@windows[name] = nil
			}
			GLib::Source.remove(@timer_id)
			@threads.each{ |_,thread| thread.kill if thread&.alive? }
			Gtk.main_quit
			kill_script "thunder" if running? "thunder"
		end
		
		@all_labels.each{ |label_name,label| add_tooltip(label, label_name) if label_name != "Logs" && label_name != "Monitor" }
		@all_menus.each{ |menu_name,menu| add_tooltip(menu, menu_name) }
		
		@windows["Main"].add(@main_notebook)
		@windows["Main"].show_all
		
		@scroll_windows.each{ |name,scroll_window|
			scroll_window.set_policy(:always, :always)
			scroll_window.set_size_request(@needed_values["Main Width"], @needed_values["Main Height"])
		}
		
		create_other_window("Stats") if @needed_values["Stats"] == "Window"
		create_other_window("Logs") if @needed_values["Logs"] == "Window"
		create_other_window("Monitor") if @needed_values["Monitor"] == "Window"
		
		if @needed_values["Link Windows"] == "Yes"
			@windows.each{ |name,window|
				window.signal_connect("window-state-event"){ |_, event|
					if event.new_window_state & Gdk::WindowState::ICONIFIED != 0
						@windows.each{ |name,window| window.iconify }
					else
						@windows.each{ |name,window| window.deiconify }
					end
				}
			}
		end
		
		start_log_timer
		Thread.new{ create_server }
	end
	
	def self.create_tab(name)
		@old_person_sending_lines = nil
		@person_sending_lines = nil
		@auto_scroll[name] = true
		@click_timers[name] = Time.now
		@all_menus["#{name} Menu"] = Gtk::ComboBoxText.new
		if name == "Logs"
			@all_menus["Logs Menu"].append_text("Client Status")
			@all_menus["Logs Menu"].append_text("Messages Received")
		elsif name == "Monitor"
			@all_menus["#{name} Menu"].append_text("NO ONE")
			new_name = "Scripts Running"
			@all_labels[new_name] = Gtk::Label.new
			@all_labels[new_name].set_padding(10, 10)
			@all_labels[new_name].set_alignment(0, 0)
			@all_labels[new_name].set_line_wrap(true)
			@all_labels[new_name].set_line_wrap_mode(:word)
		end
		@event_boxes[name] = Gtk::EventBox.new
		@all_labels[name] = Gtk::Label.new
		@all_labels["#{name} Scroll Active"] = Gtk::Label.new("Auto Scroll Active: Yes")
		@event_boxes[name].add(@all_labels[name])
		@all_labels[name].set_padding(10, 10)
		@all_labels[name].set_alignment(0, 0)
		@all_labels[name].set_line_wrap(true)
		@all_labels[name].set_line_wrap_mode(:word)
		
		@scroll_windows[name] = Gtk::ScrolledWindow.new
		@scroll_windows[name].add(@event_boxes[name])
		
		@all_menus["#{name} Menu"].set_active(0)
		@all_menus["#{name} Menu"].signal_connect("changed"){ |menu|
			@old_person_sending_lines = @person_sending_lines
			person = menu.active_text
			@person_sending_lines = person
			if name == "Logs"
				update_log
			elsif name == "Monitor"
				@all_labels["Scripts Running"].text = ""
				@clients[@old_person_sending_lines].puts "Stop sending game lines." if (@old_person_sending_lines) && (@old_person_sending_lines != @person_sending_lines)
				@logs["Monitor"] = []
				@clients[person].puts "Send game lines." if person != "NO ONE"
				update_monitor
			end
		}

		@event_boxes[name].signal_connect("button_press_event"){ |box, event|
			if (event.button == Gdk::BUTTON_PRIMARY) && (Time.now > @click_timers[name] + 0.30)
				@click_timers[name] = Time.now
				@auto_scroll[name] = @auto_scroll[name] == true ? @auto_scroll[name] = nil : @auto_scroll[name] = true
				if @auto_scroll[name]
					@all_labels["#{name} Scroll Active"].text = "Auto Scroll Active: Yes"
				else
					@all_labels["#{name} Scroll Active"].text = "Auto Scroll Active: No"
				end
			end
		}

		@all_grids["#{name} Parent"].attach(@all_grids["#{name} Menu"], 0, 0, 1, 1)
		@all_grids["#{name} Parent"].attach(@all_grids["#{name} Labels"], 0, 1, 1, 1)
		@all_grids["#{name} Parent"].attach(@all_grids["#{name} Scroll"], 0, 2, 1, 1)
		
		@all_grids["#{name} Labels"].attach(@all_labels["#{name} Scroll Active"], 0, 0, 1, 1)
		@all_grids["#{name} Labels"].attach(@all_labels["Scripts Running"], 0, 1, 1, 1) if name == "Monitor"
		
		@all_grids["#{name} Menu"].attach(@all_menus["#{name} Menu"], 0, 0, 1, 1)
		
		@all_grids["#{name} Scroll"].attach(@scroll_windows[name], 0, 0, 1, 1)
	end
	
	def self.command_to_send(person, command)
		if person.length > 0 && command.length > 0
			if person == "Everyone" || person == "All"
				@clients.each{ |_,client| client.puts "Action: #{command}" }
			else
				person = @clients.keys.find { |name| name.start_with?(person) } if !@clients.include?(person)
				@clients[person].puts "Action: #{command}"
			end
			@all_labels["Last Command Sent"].text = "Last Command Sent: '#{command}' sent to #{person}."
		end
	end

	def self.create_settings_page
		@spin_buttons = {}
		@check_boxes = {}
		@radio_buttons = {}
		adjustments = {}

		row = -1
		buttons = [ "Update Room", "Update Info", "Update Exp", "Log Entries", "Monitor Entries", "Seen Lines", "Main Width", "Main Height", "Stats Width", "Stats Height", "Logs Width", "Logs Height", "Monitor Width", "Monitor Height", "Characters/Row", "Port Number" ]
		buttons.each{ |button_name|
			if button_name =~ /Update Room|Update Info/
				adjustments[button_name] = Gtk::Adjustment.new(@needed_values[button_name], 0.5, 10, 0.1, 0.1, 0)
				@spin_buttons[button_name] = Gtk::SpinButton.new(adjustments[button_name], 0.1, 1)
			elsif button_name == "Update Exp"
				adjustments[button_name] = Gtk::Adjustment.new(@needed_values[button_name], 5, 300, 1, 10, 0)
				@spin_buttons[button_name] = Gtk::SpinButton.new(adjustments[button_name])
			elsif button_name == "Seen Lines"
				adjustments[button_name] = Gtk::Adjustment.new(@needed_values[button_name], 0, 25, 1, 1, 0)
				@spin_buttons[button_name] = Gtk::SpinButton.new(adjustments[button_name])
			else
				if button_name =~ /Log Entries|Monitor Entries/
					adjustments[button_name] = Gtk::Adjustment.new(@needed_values[button_name], 0, 1000, 1, 10, 0)
				elsif button_name =~ /Width|Height/
					adjustments[button_name] = Gtk::Adjustment.new(@needed_values[button_name], 200, 2000, 1, 10, 0)
				elsif button_name == "Port Number"
					adjustments[button_name] = Gtk::Adjustment.new(@needed_values[button_name], 1025, 65535, 1, 10, 0)
				elsif button_name == "Characters/Row"
					adjustments[button_name] = Gtk::Adjustment.new(@needed_values[button_name], 1, 10, 1, 1, 0)
				end
				@spin_buttons[button_name] = Gtk::SpinButton.new(adjustments[button_name])
			end
			label = Gtk::Label.new("#{button_name}:     ")
			add_tooltip(label, button_name)
			add_tooltip(@spin_buttons[button_name], button_name)
			@all_grids["Settings Spin Buttons"].attach(label, 0, row += 1, 1, 1)
			@all_grids["Settings Spin Buttons"].attach(@spin_buttons[button_name], 1, row, 1, 1)
		}
		
		column = -1
		row = 0
		checkboxes = [ "Health", "Mana", "Stamina", "Spirit", "Field Exp", "Encumbrance", "Status", "Bounty", "Room #", "Show Tooltips", "Link Windows", "Hide Settings" , "Debug Mode" ]
		checkboxes.each{ |box_name|
			@check_boxes[box_name] = Gtk::CheckButton.new(box_name)
			checkbox = @check_boxes[box_name]
			add_tooltip(checkbox, box_name)
			if @needed_values[box_name] == "Yes"
				checkbox.active = true
			else
				checkbox.active = false
			end
			@all_grids["Settings Checkboxes"].attach(checkbox, column += 1, row, 1, 1)
			if column >= 1
				column = -1
				row += 1
			end
		}

		radio_buttons = [ "Stats", "Logs", "Monitor" ]
		first_option = "Tab"
		other_options = [ "Window", "Hide" ]
		
		grid = @all_grids["Settings Radio Buttons"]
		radio_buttons.each{ |group_name|
			column = -1
			row += 1
			grid.attach(Gtk::Label.new(group_name), column += 1, row += 1, 1, 1)
			@radio_buttons["#{group_name} #{first_option}"] = Gtk::RadioButton.new(label: first_option)
			main_radio = @radio_buttons["#{group_name} #{first_option}"]
			main_radio.active = true if @needed_values[group_name] == first_option
			add_tooltip(main_radio, group_name)
			grid.attach(main_radio, column += 1, row, 1, 1)
			other_options.each{ |other_name|
				@radio_buttons["#{group_name} #{other_name}"] = Gtk::RadioButton.new(label: other_name, member: main_radio)
				radio = @radio_buttons["#{group_name} #{other_name}"]
				grid.attach(radio, column += 1, row, 1, 1)
				radio.active = true if @needed_values[group_name] == other_name
			}
		}
		
		@buttons["Save"] = Gtk::Button.new("Save")
		add_tooltip(@buttons["Save"], "Save")
		@buttons["Save"].signal_connect("clicked"){ save_settings }
		@all_grids["Settings Button"].attach(@buttons["Save"], 0, 0, 1, 1)
		
		name = "Defaults"
		@buttons[name] = Gtk::Button.new(name)
		add_tooltip(@buttons[name], name)
		@buttons[name].signal_connect("clicked"){
			@spin_buttons.each{ |button_name,button| button.value = @defaults[button_name] }
			@check_boxes.each{ |box_name,checkbox|
				if @defaults[box_name] == "Yes"
					checkbox.active = true
				else
					checkbox.active = false
				end
			}
		}
		@all_grids["Settings Button"].attach(@buttons[name], 1, 0, 1, 1)
	end
	
	def self.port_in_use?(port)
		begin
			TCPServer.open('localhost', port).close
			false
		rescue Errno::EADDRINUSE
			true
		end
	end

	def self.free_port(port)
		begin
			@main_server = TCPServer.open('localhost', port)
			@main_server.close
		rescue Errno::EADDRINUSE
			sleep 0.1
			retry
		end
	end
	
	def self.create_server
		port = @needed_values["Port Number"]
		@clients = {}

		if port_in_use?(port)
			@all_labels["Server Status"].text = "Port #{port} is already in use, waiting for port to be free."
			free_port(port)
			@all_labels["Server Status"].text = "Port #{port} is now free."
		end

		@main_server = TCPServer.new('localhost', port)

		@all_labels["Server Status"].text = "Server now running on port #{port}."

		add_client_info(checkname) if @needed_values["Stats"] != "Hide"
		
		if @needed_values["Stats"] != "Hide"
			@threads["Watch"] = Thread.new{
				loop{
					update_stat_values("Health", health, maxhealth)
					update_stat_values("Mana", mana, maxmana)
					update_stat_values("Stamina", stamina, maxstamina)
					update_stat_values("Spirit", spirit, maxspirit)
					update_stat_values("Encumbrance", percentencumbrance, 100)
					update_status if (@needed_values["Status"] == "Yes")
					update_bounty if (@needed_values["Bounty"] == "Yes")
					sleep @needed_values["Update Info"]
				}
			}
			
			@threads["Watch 2"] = Thread.new{
				if @needed_values["Room #"] == "Yes"
					loop{
						update_room
						sleep @needed_values["Update Room"]
					}
				end
			}
			
			@threads["Watch 3"] = Thread.new{
				if @needed_values["Field Exp"] == "Yes"
					loop{
						@last_mind_state = checkmind.dup
						update_exp
						seconds_remaining = @needed_values["Update Exp"].dup
						@needed_values["Update Exp"].times{
							sleep 1
							seconds_remaining -= 1
							break if seconds_remaining < 1
							break if @last_mind_state != checkmind
						}
					}
				end
			}
		end
		
		@threads["Respond Now"] = Thread.new{
			loop{
				sleep 60
				@all_unresponsive = []
				@clients.each{ |name,client|
					@all_unresponsive.push(name)
					@clients[name].puts "Respond now."
				}
				sleep 5
				@all_unresponsive.each{ |name| @clients[name].puts "Respond now." } if @all_unresponsive.count > 0
				sleep 5
				if @all_unresponsive.count > 0
					@all_labels["Clients Unresponsive"].text = "Clients Unresponsive: #{@all_unresponsive.join(", ")}"
					@all_labels["Clients Unresponsive"].override_color(:normal, Gdk::RGBA.new(255, 0, 0, 1.0))
				else
					@all_labels["Clients Unresponsive"].text = "Clients Unresponsive: NONE"
					@all_labels["Clients Unresponsive"].override_color(:normal, nil)
				end
			}
		}

		loop{
			client = @main_server.accept
			name = client.gets.chomp.strip
			@clients[name] = client
			@all_labels["Latest Client Status"].text = "Latest Client Status: #{name} connected."
			add_log("Client Status", "#{name} connected.")
			@clients[name].puts @required_info
			add_client_info(name) if @needed_values["Stats"] != "Hide"
			sort_name_list

			Thread.new{
				loop{
					data = @clients[name].gets.chomp
					if data =~ /Game Line: (.*)/
						add_log("Monitor", $1)
					elsif data !~ /Running Scripts:/
						add_log("Messages Received", data)
						@all_labels["Latest Message"].text = "Latest message: #{data}"
					end
					if data.nil? || data =~ /Disconnecting\: /
						break
					elsif data =~ /I am responding./
						@all_unresponsive.delete(name)
					elsif data =~ /(#{@regex_bars}): (-?\d+)\/(\d+)/
						update_progress_bar(name, $1, $2, $3)
					elsif data =~ /(#{@regex_labels}): (.*)/
						update_label(name, $1, $2)
					elsif data =~ /Running Scripts: (.*)/
						@all_labels["Scripts Running"].text = "Running scripts: #{$1}"
					end
					@clients[name].puts "Server received: #{data}" if @needed_values["Debug Mode"] == "Yes"
				}
				remove_character(@all_menus["Client Menu"], name)
				remove_character(@all_menus["Monitor Menu"], name)
				@all_labels["Latest Client Status"].text = "Latest Client Status: #{name} disconnected."
				add_log("Client Status", "#{name} disconnected.")
				@clients[name].close
				@clients.delete(name)
				arrange_all_clients if @needed_values["Stats"] != "Hide"
				sort_name_list
			}
		}
	end
	
	def self.add_client_info(name)
		@info_labels[name] = {}
		@progress_bars[name] = {}
		@overlays[name] = {}
		@info_labels[name]["Name"] = Gtk::Label.new(name)

		@needed_bars.each{ |bar_name|
			@progress_bars[name][bar_name] = Gtk::ProgressBar.new
			@progress_bars[name][bar_name].set_size_request(1, 1)
			@info_labels[name][bar_name] = Gtk::Label.new
			@overlays[name][bar_name] = Gtk::Overlay.new
			@overlays[name][bar_name].add(@progress_bars[name][bar_name])
			@overlays[name][bar_name].add_overlay(@info_labels[name][bar_name])
		
			if bar_name == "Health"
				bar_color = "rgba(255, 0, 0, 1.0)"
				border_color = "rgba(255, 0, 0, 1.0)"
				trough_color = "rgba(0, 0, 0, 1.0)"
			elsif bar_name == "Mana"
				bar_color = "rgba(0, 0, 255, 1.0)"
				border_color = "rgba(0, 0, 255, 1.0)"
				trough_color = "rgba(0, 0, 0, 1.0)"
			elsif bar_name == "Stamina"
				bar_color = "rgba(139, 128, 0, 1.0)"
				border_color = "rgba(139, 128, 0, 1.0)"
				trough_color = "rgba(0, 0, 0, 1.0)"
			elsif bar_name == "Spirit"
				bar_color = "rgba(128, 128, 128, 1.0)"
				border_color = "rgba(128, 128, 128, 1.0)"
				trough_color = "rgba(0, 0, 0, 1.0)"
			elsif bar_name == "Field Exp"
				bar_color = "rgba(255, 140, 0, 1.0)"
				border_color = "rgba(255, 140, 0, 1.0)"
				trough_color = "rgba(0, 0, 0, 1.0)"
			elsif bar_name == "Encumbrance"
				bar_color = "rgba(92, 64, 51, 1.0)"
				border_color = "rgba(92, 64, 51, 1.0)"
				trough_color = "rgba(0, 0, 0, 1.0)"
			end
			@info_labels[name][bar_name].override_color(:normal, Gdk::RGBA.new(255, 255, 255, 1.0))
		
			provider = Gtk::CssProvider.new
			css = <<~CSS
				progressbar progress {
					min-height: 12px;
					background-color: #{bar_color};
					border-color: #{border_color};
				}

				progressbar trough {
					min-height: 12px;
					background-color: #{trough_color};
					border-color: #{border_color};
				}
			CSS
			provider.load_from_data(css)
			context = @progress_bars[name][bar_name].style_context
			context.add_provider(provider, Gtk::StyleProvider::PRIORITY_APPLICATION)
		}
		@status_labels.each{ |label_name|
			@info_labels[name][label_name] = Gtk::Label.new
			@info_labels[name][label_name].override_color(:normal, Gdk::RGBA.new(0, 0, 0, 1.0))
		}
		arrange_all_clients if @needed_values["Stats"] != "Hide"
	end
	
	def self.add_tooltip(widget, name)
		widget.set_tooltip_text(@tooltips[name]) if @needed_values["Show Tooltips"] == "Yes"
	end
	
	def self.create_other_window(name)
		@windows[name] = Gtk::Window.new(:toplevel)
		@windows[name].set_keep_above(true)
		@windows[name].set_title("#{name} - #{checkname}")
		@windows[name].move(@needed_values["#{name} Horizontal Position"], @needed_values["#{name} Vertical Position"])
		@windows[name].set_size_request(@needed_values["#{name} Width"], @needed_values["#{name} Height"])
		@scroll_windows[name].set_policy(:always, :always)
		@scroll_windows[name].set_size_request(@needed_values["#{name} Width"], @needed_values["#{name} Height"])
		
		@windows[name].signal_connect("delete-event") do
			@windows["Main"].close if @windows["Main"]
			if @close_windows
				false
			else
				true
			end
		end

		@windows[name].add(@all_grids["#{name} Parent"])
		@windows[name].show_all
	end
	
	def self.arrange_all_clients
		chars_per_row = 0
		@info_row = -1
		@info_column = -1
		new_hash = @clients.dup
		new_hash[checkname] = ""
		new_hash = new_hash.sort.to_h
		grid = @all_grids["Stats Players"]
		grid.each { |widget| grid.remove(widget) }
		new_hash.each{ |name,_|
			starting_row = @info_row
			grid.attach(@info_labels[name]["Name"], @info_column += 1, @info_row += 1, 1, 1)
			@needed_bars.each{ |bar_name| grid.attach(@overlays[name][bar_name], @info_column, @info_row += 1, 1, 1) }
			
			@status_labels.each{ |label_name| grid.attach(@info_labels[name][label_name], @info_column, @info_row += 1, 1, 1) }
			
			grid.attach(Gtk::Label.new("     "), @info_column, @info_row += 1, 1, 1)

			chars_per_row += 1
			if chars_per_row >= (@needed_values["Characters/Row"])
				@info_column = -1
				@info_row += 1
				chars_per_row = 0
			else
				grid.attach(Gtk::Label.new("     "), @info_column += 1, @info_row, 1, 1)
				@info_row = starting_row
			end
			
			@info_labels[name].each{ |label_name, label|
				label.set_line_wrap(true)
				label.set_max_width_chars(10)
			}
		}
		grid.show_all
	end
	
	def self.update_label(name, label_name, value)
		if label_name == "Status"
			if value == "GREAT!"
				@info_labels[name][label_name].override_color(:normal, Gdk::RGBA.new(0, 255, 0, 1.0))
			else
				@info_labels[name][label_name].override_color(:normal, Gdk::RGBA.new(255, 0, 0, 1.0))
			end
			@info_labels[name][label_name].set_markup("<b>#{label_name}: #{value}</b>")
		else
			value = "Bounty: None" if value == "None" && label_name == "Bounty"
			value = "#{label_name}: #{value}" if label_name == "Room #"
			@info_labels[name][label_name].text = value
		end
	end
	 
	def self.update_progress_bar(name, stat, min, max)
		min = min.to_i
		max = max.to_i
		new_min = [0, min.to_i].max
		if max == 0
			@progress_bars[name][stat].fraction = 0
		elsif new_min > max
			@progress_bars[name][stat].fraction = 1
		else
			@progress_bars[name][stat].fraction = ((new_min.to_f) / max.to_f)
		end
		@info_labels[name][stat].set_markup("<b>#{min}/#{max}</b>")
	end
	
	def self.update_stat_values(stat_name, current_number, max_number)
		if (current_number != @current_stats[stat_name]) && (@needed_values[stat_name] == "Yes")
			update_progress_bar(checkname, stat_name, current_number, max_number)
			@current_stats[stat_name] = current_number
		end
	end
	
	def self.update_status
		all_wounds = Wounds.head, Wounds.neck, Wounds.abs, Wounds.lhand, Wounds.rhand, Wounds.larm, Wounds.rarm, Wounds.chest, Wounds.back, Wounds.rleg, Wounds.lleg, Wounds.nerves, Wounds.leye, Wounds.reye, Scars.head, Scars.neck, Scars.abs, Scars.lhand, Scars.rhand, Scars.larm, Scars.rarm, Scars.chest, Scars.back, Scars.rleg, Scars.lleg, Scars.nerves, Scars.leye, Scars.reye
		info = []
		info.push("Injured") if all_wounds.any?{ |i| i > 0 }
		info.push("Prone") if checkprone
		info.push("Poisoned") if checkpoison
		info.push("Diseased") if checkdisease
		info.push("Bleeding") if checkbleeding
		info.push("Stunned") if checkstunned
		info.push("Webbed") if checkwebbed
		info.push("Bound") if checkbound
		info.push("Calmed") if checkcalmed
		info.push("Cut Throat") if checkcutthroat
		info.push("Silenced") if checksilenced
		info.push("Sleeping") if checksleeping
		info = "GREAT!" if info.empty?
		info = "DEAD" if checkdead

		info = info.join(", ") if info.is_a?(Array)
		
		stat_name = "Status"
		if info != @current_stats[stat_name]
			update_label(checkname, stat_name, info)
			@current_stats[stat_name] = info
		end
	end

	def self.update_bounty
		if checkbounty =~ /The local gem dealer, .*, has an order to fill and wants our help./
			info = "Gem NPC"
		elsif checkbounty =~ /received orders from multiple customers requesting [a-zA-Z]+ (.*)\.  You have been tasked to retrieve (\d+) of them./
			info = "#{$2} #{$1}"
		elsif checkbounty =~ /WAIT for [a-zA-Z]+ to meet you there.  You must guarantee [a-zA-Z]+ safety to (.*) as soon as you can/
			info = "Escort #{$1}"
		elsif checkbounty =~ /The local healer, .*, has asked for our aid./
			info = "Herb NPC"
		elsif checkbounty =~ /working on a concoction that requires [a-zA-Z]+ (.*) found (?:on|in|near) (.*).  These samples must be in .* condition.  You have been tasked to retrieve (\d+) samples/
			info = "#{$3} #{$1} #{$2}"
		elsif checkbounty =~ /The local furrier .* has an order to fill and wants our help/
			info = "Skin NPC"
		elsif checkbounty =~ /You have been tasked to retrieve (\d+) (.*) of at least (.*) quality .* You can SKIN them off the corpse of [a-zA-Z]+ (.*) or purchase them from another adventurer./
			info = "#{$1} #{$2}"
		elsif checkbounty =~ /It appears they need your help in tracking down some kind of lost heirloom/
			info = "Heirloom NPC"
		elsif checkbounty =~ /You have been tasked to recover (.*) that an unfortunate citizen lost after being attacked by [a-zA-Z]+ (.*?) (?:on|in|near) (.*)\.  The heirloom .*SEARCH the area until you find it/
			info = "Heirloom Search #{$3}"
		elsif checkbounty =~ /You have been tasked to recover (.*) that an unfortunate citizen lost after being attacked by [a-zA-Z]+ (.*?) (?:on|in|near) (.*)\.  The heirloom .*Hunt down the creature and LOOT the item from its corpse./
			info = "Heirloom #{$1} #{$2} #{$3}"
		elsif checkbounty =~ /You have located .* and should bring it back to/
			info = "Heirloom FOUND"
		elsif checkbounty =~ /It appears that a local resident urgently needs our help in some matter./
			info = "Child NPC"
		elsif checkbounty =~ /A local divinist has had visions of the child fleeing from an? (.*?) (?:on|in|near) (.*)\.  Find the area/
			info = "Find Child #{$1} #{$2}"
		elsif checkbounty =~ /You have made contact with the child/
			info = "Return Child"
		elsif checkbounty =~ /child you were tasked to rescue is gone and your task is failed/
			info = "Child FAILED"
		elsif checkbounty =~ /It appears they have a bandit problem they'd like you to solve.|order to help [a-zA-Z]+ take care of a bandit problem./
			info = "Bandits NPC"
		elsif checkbounty =~ /You have been tasked to suppress bandit activity (?:on|in|near) (.*)\.  You need to kill (\d+).*of them to complete your task./ || checkbounty =~ /You have been tasked to help [a-zA-Z]+ suppress bandit activity (?:on|in|near) (.*)\.  You need to kill (\d+).*of them to complete your task./
			info = "#{$2} Bandits"
		elsif checkbounty =~ /It appears they have a creature problem they'd like you to solve/
			info = "Creatures NPC"
		elsif checkbounty =~ /You have been tasked to suppress (.*) activity (?:on|in|near) (.*)\.  You need to kill (\d+) of them to complete your task./ || checkbounty =~ /suppressing (.*) activity (?:on|in|near) (.*) during .*\.  You need to kill (\d+).*of them to complete your task./ || checkbounty =~ /suppress (.*) activity (?:on|in|near) (.*)\.  You need to kill (\d+).*of them to complete your task./
			info = "#{$3} #{$1}"
		elsif checkbounty =~ /You have been tasked to hunt down and kill a particularly dangerous (.*) that has established a territory (?:on|in|near) (.*)\.  You can get its attention by killing other creatures of the same type in its territory./
			info = "Dangerous #{$1}"
		elsif checkbounty =~ /You have been tasked to hunt down and kill a particularly dangerous (.*) that has established a territory (?:on|in|near) (.*)\.  You have provoked .* attention/
			info = "Dangerous #{$1}"
		elsif checkbounty =~ /to help [a-zA-Z]+ take care of an urgent matter.|to help [a-zA-Z]+ retrieve a lost heirloom|to help [a-zA-Z]+ take care of a creature problem./
			info = "Help NPC"
		elsif checkbounty =~ /You have succeeded in your task and can return to the Adventurer's Guild to receive your reward./
			info = "Finished Guild"
		elsif checkbounty =~ /You succeeded in your task and should report back/
			info = "Finished Guard"
		elsif checkbounty =~ /You are not currently assigned a task./
			info = "None"
		end
		
		stat_name = "Bounty"
		if info != @current_stats[stat_name]
			update_label(checkname, stat_name, info)
			@current_stats[stat_name] = info
		end
	end

	def self.update_room
		info = Room.current.id

		stat_name = "Room #"
		if info != @current_stats[stat_name]
			update_label(checkname, stat_name, info)
			@current_stats[stat_name] = info
		end
	end
	
	def self.update_exp
		$current_field_exp = nil
		$max_field_exp = nil
		$update_field_exp = true
		@silence.call
		wait_until{ $max_field_exp }
		update_stat_values("Field Exp", $current_field_exp, $max_field_exp)
	end
	
	def self.add_log(log, data)
		if (log == "Client Status") || (log == "Messages Received")
			max_entries = @needed_values["Log Entries"]
		elsif log == "Monitor"
			max_entries = @needed_values["Monitor Entries"]
		end
		if max_entries > 0
			@logs[log] ||= []
			@logs[log].shift if @logs[log].count >= max_entries
			@logs[log].push(data)
		end
	end
	
	def self.update_log
		current_log = @all_menus["Logs Menu"].active_text
		text = @logs[current_log].join("\n")
		@all_labels["Logs"].text = text if text
		if @auto_scroll["Logs"]
			adjustment = @scroll_windows["Logs"].vadjustment
			adjustment.value = adjustment.upper
		end
	end
	
	def self.update_monitor
		text = @logs["Monitor"].join("\n")
		@all_labels["Monitor"].text = text if text
		if @auto_scroll["Monitor"]
			adjustment = @scroll_windows["Monitor"].vadjustment
			adjustment.value = adjustment.upper
		end
	end
	
	def self.sort_name_list
		new_hash = @clients.sort.to_h
		[@all_menus["Client Menu"], @all_menus["Monitor Menu"]].each{ |menu|
			current_person = menu.active_text
			menu.remove_all
			if menu.equal?(@all_menus["Client Menu"])
				menu.append_text("Everyone") if new_hash.count > 0
			elsif menu.equal?(@all_menus["Monitor Menu"])
				menu.append_text("NO ONE")
			end
			new_hash.each{ |name,client|
				menu.append_text(name)
			}
			if !new_hash.include?(current_person)
				menu.set_active(0)
			else
				match_menu_item(menu, current_person)
			end
		}
		@all_labels["Everyone Connected"].text = "Everyone connected (#{new_hash.count}): #{new_hash.keys.join(", ")}"
	end
	
	def self.match_menu_item(menu, item_needed)
		menu.model.each{ |model, path, iter|
			if item_needed == menu.model.get_value(iter, 0)
				menu.set_active_iter(iter)
				break
			end
		}
	end
	
	def self.start_log_timer
		@timer_id = GLib::Timeout.add(3000){
			update_log
			update_monitor
			true
		}
	end
	
	def self.remove_character(menu, name)
		index = 0
		menu.model.each{ |model, path, iter|
			if name == menu.model.get_value(iter, 0)
				menu.remove(index)
				break
			end
			index += 1
		}
	end
	
	def self.variable=(value)
		if value
			@show_settings = true
		else
			@show_settings = nil
		end
	end
	
	before_dying{
		@windows["Main"].close if @windows["Main"]
		DownstreamHook.remove("thunder_silence")
		echo "Shutting down server..."
		@clients.each{ |name,client| 
			unless client.closed?
				client.puts "Shut down."
				client.close
			end
		}
		@main_server.close
	}
end

Gtk.queue {
	ThunderMain.variable = script.vars[1]
	ThunderMain.create_main_window
	Gtk.main
}

Thread.new{
	loop{
		wait_until { $update_field_exp }
		$update_field_exp = nil
		put "exp"
	}
}

while line = get
	if line =~ /^t ([a-zA-Z]+) (.*)/i
		person = $1.capitalize
		command = $2
		ThunderMain.command_to_send(person, command)
	elsif line =~ /Field Exp: ([\d,]+)\/([\d,]+)/ && $max_field_exp.nil?
		$current_field_exp = $1.delete(",").to_i
		$max_field_exp = $2.delete(",").to_i
	end
end