=begin

	You need to download the script ;struck and run it for any character that you want to connect to the server created by running this script.

	This script essentially creates a server on your computer so all of your characters can communicate with one another, no matter where they are in the game world.
	
	This script also creates a window which shows a lot of information about your characters; such as their health, stamina, mana, current bounty, Lich room number, and more!
	
	The script also tracks which characters are connected to the server, which ones have disconnected, and which ones have become unresponsive.
	
	You can also send commands to all of your characters or just one character and those character(s) will perform those actions, just as if you entered the command manually in their game window.
	
	There are various settings so you can make the script work just the way you want it.
	
	Be sure to start this script first on the character you want to act as the server, then start the script ;struck on any character you want to connect to the server.

	Version 8: Fixed bug with script showing 1000 or "PLACEHOLDER" for every stat if you started up ;thunder without ever clicking the "Save" button. Now the script will work with the default settings regardless if you click the "Save" button or not.
	Version 9: The bugfix in Version 8 only worked for the very first character you started ;thunder on, any subsequent character running ;thunder would run into the same problem. This version fixes this bug for all characters.
	Version 10: The server can now use the ;k and ;ka commands to send to clients.
		;k will stop the specified script. Example: ;k test
		;ka will stop all running scripts (except for ;struck).
	Version 11: Fixed issue with scroll windows not using all available space in a window.
	Version 12: Fixed bug with script crashing.
	Version 13: Added instructions upon start up explaining how to fix the 1000/PLACEHOLDER stats issue.
	Version 14: Fixed issue with commands not going through to ;struck if a script with started via ;struck that ran in the background and never exited.

	########################################################
	Ways to contact me:
	In game: Dreaven
	Player's Corner: Tgo01
	Discord: dreaven.
	Email: LordDreaven@gmail.com
	If you like my scripts feel free to send me a tip via Paypal at: LordDreaven@gmail.com
	########################################################
	
	Author: Dreaven
	Version: 14

=end

silence_me

require 'gtk3'
require 'socket'

hide_me

class ThunderMain
	@save_file = "Thunder Settings.json"
	@lock_file = "Lock File.lock"
	@load_data = nil

	@all_vars = {}
	hashes = [ "Labels", "Menus", "Logs", "Grids", "Info Labels", "Progress Bars", "Overlays", "Threads", "Scroll Windows", "Buttons", "Event Boxes", "Auto Scroll", "Click Timers", "Entries", "Current Stats", "Windows", "Requested Hash" ]
	hashes.each{ |hash| @all_vars[hash] = {} }
	
	@needed_values = {}
	
	size_info = "\n\nNote: Manually resizing the window won't work because some tabs use a scrolled window and scrolled windows won't change size by manually resizing the window, so you must set this setting to get the proper size you want."
	stat_info = "\n\nUncheck this box to not see this info.\n\nNOTE: Checking this box might show inaccurate information in the Stats tab. These are just placeholders so you can see what the window looks like with this option checked. Once you click 'Save' and restart the script the stats will be accurate."
	update_info = "\n\nRegardless of what you enter here, information is only sent from a client/updated if there has been a change in that specific stat since the last update."
	window_info = "Selet 'Tab' to have this information shown in a tab on the Main window\n\nSelect 'Window' to have this information shown in its own window instead of a tab.\n\nSelect 'Hide' to not have this information shown at all."
	auto_scroll = "Click the log below to turn auto scroll on and off.\n\nWhile on the window will automatically scroll to the bottom as more lines are added to the log.\n\nWhile off the window won't automatically scroll to the bottom."
	info_info = "\n\nNOTE: This will also save all current settings set in the Settings tab."
	
	@tooltips = {
		"Server Status" => "The current status of the server.",
		"Latest Client Status" => "The latest status report received from a client.",
		"Everyone Connected" => "Everyone currently connected to the server.",
		"Latest Message" => "The latest message received from a client.",
		"Last Command Sent" => "The last command you sent to a client.",
		"Update Room" => "How many seconds clients (and yourself) will wait until updating their current room number again.#{update_info}",
		"Update Info" => "How many seconds clients (and yourself) will wait until updating their info (health, mana, bounty info, etc) again.#{update_info}",
		"Update Exp" => "How many seconds clients (and yourself) will wait until updating their experience again. Script will also update experience whenever the character's mind state changes, and then wait this many seconds before updating again.#{update_info}",
		"Log Entries" => "The number of entries you want to save for each log.",
		"Monitor Entries" => "The number of entries you want to save for Monitor logging.\n\nMonitor allows you to select a client and the game lines the client sees will appear in the Monitor area. the 'Seen Lines' setting is related to this feature.\n\nSet to 0 to not make use of the Monitor system at all and the client won't track how many times they have seen game lines.",
		"Main Width" => "The width in pixels you want the Main window to be.#{size_info}",
		"Main Height" => "The height in pixels you want the Main window to be.#{size_info}",
		"Stats Width" => "The width in pixels you want the Stats window to be.#{size_info}",
		"Stats Height" => "The height in pixels you want the Stats window to be.#{size_info}",
		"Logs Width" => "The width in pixels you want the Logs window to be.#{size_info}",
		"Logs Height" => "The height in pixels you want the Logs window to be.#{size_info}",
		"Monitor Width" => "The width in pixels you want the Monitor window to be.#{size_info}",
		"Monitor Height" => "The height in pixels you want the Monitor window to be.#{size_info}",
		"Info Width" => "The width in pixels you want the Monitor window to be.#{size_info}",
		"Info Height" => "The height in pixels you want the Monitor window to be.#{size_info}",
		"Port Number" => "The port number you want the server to be set up on.\n\nIMPORTANT: You must set the port number on each client/character to match this number. Start ;struck on every client for more info on how to set the port number.\n\nBy default ;thunder and ;struck all connect to port 4000.",
		"Client Menu" => "List of everyone connected to the server.\n\nSelect who you want to send a command to. 'Everyone' will send a command to everyone.",
		"Logs Menu" => "Select which log you want to view.",
		"Command" => "Select the person you want to send a command to from the drop down menu, then enter the command you want to send in the box, then click 'Send' to have the selected person perform that command.\n\nFor example if you want someone to wave simply type in 'wave' and click 'Send.'\n\nTo have the character(s) start a script enter the word 'script' or enter ';' first, followed by the script name then any command line variables.\n\nExample: script go2 400\n\nExample: ;go2 400\n\nTo stop a script enter ;k <script name>\n\nExample: ;k test\n\nTo stop ALL running scripts (except for ;struck) enter ;ka",
		"Save" => "Click this button to save all current settings.\n\nIMPORTANT: Some changes (such as window size and 'Characters/Row') will take effect immediately but the changes won't be saved until you click this button. Once you are satisfied with all of your changes, click this button then restart the script because some changes don't take effect until the script is restarted.\n\nIMPORTANT: Clicking this button will also save the current position of the windows so whenever you load the script the windows will return to these positions.",
		"Defaults" => "Click this button to set all settings back to their default values.\n\nIMPORTANT: You still have to click the 'Save' button to save these settings, you would then need to restart the script for the settings to take effect.",
		"Show Tooltips" => "Check this box if you want to see tooltips when you hover the mouse over items.\n\nUncheck this box to not see tooltips.",
		"Health" => "Check this box if you want to see everyone's Health in the status tab.#{stat_info}",
		"Mana" => "Check this box if you want to see everyone's Mana in the status tab.#{stat_info}",
		"Stamina" => "Check this box if you want to see everyone's Stamina in the status tab.#{stat_info}",
		"Spirit" => "Check this box if you want to see everyone's Spirit in the status tab.#{stat_info}",
		"Field Exp" => "Check this box if you want to see everyone's current field experience in the status tab.#{stat_info}",
		"Encumbrance" => "Check this box if you want to see everyone's current encumbrance in the status tab.#{stat_info}",
		"Status" => "Check this box if you want to see everyone's Status (stunned, prone, bleeding, etc) in the status tab.#{stat_info}",
		"Bounty" => "Check this box if you want to see everyone's Bounty info in the status tab.#{stat_info}",
		"Room #" => "Check this box if you want to see the everyone's current Lich room number in the status tab.#{stat_info}",
		"Debug Mode" => "Check this box if you want each client to echo back every command they send to the server and every command they receive from the server. This can cause a lot of echo information to be displayed for each client so you really only need it on to identify an issue, or if you just like to see these kinds of things.\n\nUncheck to not see these messages.",
		"Characters/Row" => "How many characters to show per row in the 'Stats' tab.",
		"Stats" => window_info,
		"Logs" => window_info,
		"Monitor" => window_info,
		"Info" => window_info,
		"Link Windows" => "Check this box if you want all windows to be minimized/return to normal state when any window is minimized/returned to normal state.\n\nUncheck this box to unlink the windows.",
		"Hide Settings" => "Check this box if you want to hide the Settings tab on the Main window.\n\nUncheck this box to show the Settings tab on the Main window.\n\nIMPORTANT: If you hide the Settings tab then the only way to see the tab again is to start script as ;thunder set, which will show the Settings tab but won't change the setting you have here.",
		"Logs Scroll Active" => auto_scroll,
		"Monitor Scroll Active" => auto_scroll,
		"Seen Lines" => "How many times the client can see the same game line before they stop sending that game line to the Monitor.\n\nFor example: if you enter 2 here, then the first two times the selected client sees the same game line it will appear in the monitor area, however if the client sees the same game line anymore after that the game line won't show in the Monitor.\n\nSet to 0 to have every game line shown in the Monitor, regardless of how many times it has been seen.\n\nNote: Each client tracks how many times they have seen the same game line, regardless of whether they are the selected person to Monitor or not.",
		"Info Create" => "Click this button to create a command with the current entry information.\n\nIMPORTANT: Created commands won't work until you restart the script.#{info_info}",
		"Info Delete" => "Double click this button to delete the currently selected command.\n\nIMPORTANT: This button requires a double click to work.#{info_info}",
		"Info Update" => "Click this button to update the currently selected command with the information filled out in the entries.#{info_info}",
		"Info Name" => "Enter what you want this command's name to be.",
		"Info Command" => "Enter the command your characters will enter into the game to get the required information.",
		"Info Game Line" => "The game line which will have the information you want this command to gather.\n\nIMPORTANT: This uses regex to get the required information. If you are unfamiliar with regex then look at the already made examples to get an idea of how they work, but here is also a basic rundown:\n\nYou need to match the game line, but you can use .* to match any text you don't care about. Careful though because .* will match as much as it can, so you will need to use spaces or text that appears on the line to make sure it doesn't match the information you are looking for.\n\nFor the most part you can use (.*) to get the information you are looking for.\n\nIf you can't use .* to match some of the game line then keep in mind some text needs to be 'escaped', meaning you need to put a \\ in front of it, notable examples are: ( ) \\ |\n\nExample, if this were a game line: This is a | test. You would need to enter this: This is a \\| test.\n\nAnother example, if this were the game line: This is a \\ test. You would need to enter: This is a \\\\ test.",
		"Info Send" => "Click this button to send this command to your characters.\n\nNote: This information is not gathered in real time, it is only gathered once whenever you click this button.",
		"Client Menu" => "A list of everyone currently connected to the server.\n\nSelect 'Everyone' to send a command to everyone.\n\nSelect a character's name to send a command to just that character.",
		"Info Menu" => "Select which command you want to send to all of your characters and then click the 'Send' button.",
		"Info Sort" => "Select how you want the information to be sorted.\n\nCharacter Name will sort the information alphabetically by your characters' names.\n\nInfo Value will sort the information by the value.\nIf the information is a number then it will be sorted from smallest number to largest number\nIf the information is not a number then it will be sorted alphabetically.",
	}
	
	@silence = proc{
		started = false
		hook_proc = proc { |s|
			if started
				if s =~ /<prompt/
					DownstreamHook.remove("thunder_silence")
					nil
				elsif s =~ /<output/
					s
				else
					nil
				end
			elsif s =~ /Level:/
				started = true
				nil
			else
				s
			end
		}
		DownstreamHook.add("thunder_silence", hook_proc)
	}
	
	@defaults = {
		"Update Room" => 1.0,
		"Update Info" => 0.5,
		"Update Exp" => 60,
		"Log Entries" => 100,
		"Monitor Entries" => 0,
		"Seen Lines" => 2,
		"Main Width" => 400,
		"Main Height" => 400,
		"Stats Width" => 400,
		"Stats Height" => 400,
		"Logs Width" => 400,
		"Logs Height" => 400,
		"Monitor Width" => 400,
		"Monitor Height" => 400,
		"Info Width" => 400,
		"Info Height" => 400,
		"Port Number" => 4000,
		"Characters/Row" => 2,
		"Main Horizontal Position" => 0,
		"Main Vertical Position" => 0,
		"Stats Horizontal Position" => 0,
		"Stats Vertical Position" => 0,
		"Logs Horizontal Position" => 0,
		"Logs Vertical Position" => 0,
		"Monitor Horizontal Position" => 0,
		"Monitor Vertical Position" => 0,
		"Info Horizontal Position" => 0,
		"Info Vertical Position" => 0,
		"Health" => "Yes",
		"Mana" => "Yes",
		"Stamina" => "Yes",
		"Spirit" => "Yes",
		"Field Exp" => "Yes",
		"Encumbrance" => "Yes",
		"Status" => "Yes",
		"Bounty" => "Yes",
		"Room #" => "Yes",
		"Show Tooltips" => "Yes",
		"Debug Mode" => "No",
		"Stats" => "Tab",
		"Logs" => "Tab",
		"Monitor" => "Tab",
		"Info" => "Tab",
		"Link Windows" => "Yes",
		"Hide Settings" => "No",
	}
	
	def self.load_the_data
		begin
			File.open(@lock_file, File::RDWR | File::CREAT){ |lock_file|
				lock_file.flock(File::LOCK_EX)
				
				return unless File.exist?(@save_file)
				
				@load_data = JSON.parse(File.read(@save_file))
			}

			@load_data = @load_data[checkname]
			@info_commands = @load_data["Info Commands"]
		rescue StandardError => e
			respond "Error message from ;thunder: #{e.message}"
		ensure
			File.open(@lock_file, File::RDWR | File::CREAT){ |lock_file| lock_file.flock(File::LOCK_UN) }
		end
	end
	
	load_the_data
	
	@defaults.each{ |setting_name,value|
		if value.is_a?(Integer)
			@needed_values[setting_name] = @load_data[setting_name] ? @load_data[setting_name].to_i : @defaults[setting_name]
		elsif value.is_a?(Float)
			@needed_values[setting_name] = @load_data[setting_name] ? @load_data[setting_name].to_f : @defaults[setting_name]
		else
			@needed_values[setting_name] = @load_data[setting_name] ? @load_data[setting_name] : @defaults[setting_name]
		end
	}
	@needed_values["Monitor Entries"] = 0 if @needed_values["Monitor"] == "Hide"
	
	@bar_names = [ "Health", "Mana", "Stamina", "Spirit", "Field Exp", "Encumbrance" ]
	@regex_bars = @bar_names.map{ |label| label.gsub(",","") }.join("|")
	
	@status_labels = [ "Status", "Bounty", "Room #" ]
	@regex_labels = @status_labels.map{ |label| label.gsub(",","") }.join("|")

	def self.save_settings
		File.open(@lock_file, File::RDWR | File::CREAT){ |lock|
			lock.flock(File::LOCK_EX)
			
			if File.exist?(@save_file)
				save_data = JSON.parse(File.read(@save_file))
			else
				save_data = {}
			end
			
			save_data[checkname] ||= {}
			
			@all_vars["Windows"].each{ |name,window|
				x, y = window.position
				save_data[checkname]["#{name} Horizontal Position"] = x
				save_data[checkname]["#{name} Vertical Position"] = y
			}
			
			@spin_buttons.each{ |name,button| save_data[checkname][name] = button.value.round(1) }
			@check_boxes.each{ |name,box|
				if box.active?
					save_data[checkname][name] = "Yes"
				else
					save_data[checkname][name] = "No"
				end
			}
			
			@radio_buttons.each{ |name,button|
				if button.active?
					info = name.split(" ")
					save_data[checkname][info[0]] = info[1]
				end
			}

			save_data[checkname]["Info Commands"] = @info_commands
				
			File.open(@save_file, 'w'){ |file| file.write(JSON.pretty_generate(save_data)) }
			respond ";thunder: Data saved."
		}
	end
	
	if @info_commands.nil? || @info_commands.empty?
		@info_commands = {}
		@info_commands["Deeds"] = { "Command" => "experience", "Game Line" => "Deeds: (.*)" }
		@info_commands["Weekly Resources"] = { "Command" => "resources", "Game Line" => ":( .*\\/50,000) \\(Weekly\\)" }
		@info_commands["Total Resources"] = { "Command" => "resources", "Game Line" => "     (.*\\/200,000) \\(Total\\)" }
		@info_commands["Level"] = { "Command" => "experience", "Game Line" => "Level: (.*)     " }
		@info_commands["Ascension Exp"] = { "Command" => "experience", "Game Line" => "Ascension Exp: (.*)     " }
		@info_commands["Total Exp"] = { "Command" => "experience", "Game Line" => "Total Exp: (.*)     " }
		@info_commands["Fame"] = { "Command" => "fame", "Game Line" => "Your personal fame is (.*)." }
		@info_commands["Bank Total"] = { "Command" => "bank account", "Game Line" => "Total: (.*)" }
		@info_commands["Race"] = { "Command" => "info", "Game Line" => "Race: (.*) Profession:" }
		@info_commands["ATPs Available"] = { "Command" => "asc exp", "Game Line" => "ATPs Available: (.*)" }
		@info_commands["Physical Fitness Ranks"] = { "Command" => "skills", "Game Line" => "Physical Fitness.* (.*)" }
		@info_commands["Voln Favor"] = { "Command" => "resources", "Game Line" => "Voln Favor: (.*)" }
		@info_commands["CMAN Points Available"] = { "Command" => "cman info", "Game Line" => "Available Combat Maneuvers Points: (.*)" }
		save_settings
	end

	def self.create_main_window
		if @needed_values["Hide Settings"] == "Yes"
			respond "#################################################################################################################"
			respond "Message from ;thunder"
			respond "You have the Settings tab hidden. To see the settings tab again start script as: ;thunder set"
			respond "Starting script like this won't change the setting you have for the 'Hide Settings' option."
			respond "#################################################################################################################"
		end
		@all_vars["Windows"]["Main"] = Gtk::Window.new(:toplevel)
		@all_vars["Windows"]["Main"].set_keep_above(true)
		@all_vars["Windows"]["Main"].set_title("Main - #{checkname}")
		@all_vars["Windows"]["Main"].move(@needed_values["Main Horizontal Position"], @needed_values["Main Vertical Position"])
		
		grids = [ "Main Parent", "Main Info", "Main Menu", "Main Entry", "Stats Parent", "Stats Scroll", "Logs Parent", "Logs Menu", "Logs Labels", "Logs Scroll", "Settings Parent", "Settings Spin Buttons", "Settings Checkboxes", "Settings Radio Buttons", "Settings Button", "Monitor Parent", "Monitor Menu", "Monitor Labels", "Monitor Scroll", "Info Parent", "Info Menu", "Info Entries", "Info Buttons", "Info Scroll" ]
		grids.each{ |grid| @all_vars["Grids"][grid] = Gtk::Grid.new }

		@all_vars["Scroll Windows"]["Settings"] = Gtk::ScrolledWindow.new
		@all_vars["Scroll Windows"]["Settings"].add(@all_vars["Grids"]["Settings Parent"])
		
		@main_notebook = Gtk::Notebook.new
		@main_notebook.append_page(@all_vars["Grids"]["Main Parent"], Gtk::Label.new("Main"))
		@main_notebook.append_page(@all_vars["Grids"]["Stats Parent"], Gtk::Label.new("Stats")) if @needed_values["Stats"] == "Tab"
		@main_notebook.append_page(@all_vars["Grids"]["Logs Parent"], Gtk::Label.new("Logs")) if @needed_values["Logs"] == "Tab"
		@main_notebook.append_page(@all_vars["Grids"]["Monitor Parent"], Gtk::Label.new("Monitor")) if @needed_values["Monitor"] == "Tab"
		@main_notebook.append_page(@all_vars["Grids"]["Info Parent"], Gtk::Label.new("Info")) if @needed_values["Info"] == "Tab"
		@main_notebook.append_page(@all_vars["Scroll Windows"]["Settings"], Gtk::Label.new("Settings")) if @needed_values["Hide Settings"] == "No" || @show_settings
		
		create_settings_page if @needed_values["Hide Settings"] == "No" || @show_settings
		
		row = -1
		grids = [ "Main Info", "Main Menu", "Main Entry" ]
		grids.each{ |name| @all_vars["Grids"]["Main Parent"].attach(@all_vars["Grids"][name], 0, row += 1, 1, 1) }

		row = -1
		grids = [ "Settings Spin Buttons", "Settings Checkboxes", "Settings Radio Buttons", "Settings Button" ]
		grids.each{ |name| @all_vars["Grids"]["Settings Parent"].attach(@all_vars["Grids"][name], 0, row += 1, 1, 1) }

		row = -1
		labels = [ "Server Status", "Latest Client Status", "Everyone Connected", "Latest Message", "Last Command Sent", "Clients Unresponsive" ]
		labels.each{ |label|
			@all_vars["Labels"][label] = Gtk::Label.new("#{label}: ")
			@all_vars["Labels"][label].set_line_wrap(true)
			@all_vars["Labels"][label].set_line_wrap_mode(:word)
			@all_vars["Labels"][label].set_halign(Gtk::Align::START)
			@all_vars["Grids"]["Main Info"].attach(@all_vars["Labels"][label], 0, row += 1, 1, 1)
		}
		@all_vars["Labels"]["Clients Unresponsive"].text = "Clients Unresponsive: NONE"
		
		@all_vars["Menus"]["Client Menu"] = Gtk::ComboBoxText.new

		@all_vars["Entries"]["Command"] = Gtk::Entry.new
		@all_vars["Buttons"]["Command"] = Gtk::Button.new("Send")
		@all_vars["Grids"]["Main Menu"].attach(@all_vars["Menus"]["Client Menu"], 0, 0, 1, 1)
		@all_vars["Grids"]["Main Entry"].attach(@all_vars["Entries"]["Command"], 0, 0, 1, 1)
		@all_vars["Grids"]["Main Entry"].attach(@all_vars["Buttons"]["Command"], 1, 0, 1, 1)
		
		create_tab("Logs") if @needed_values["Logs"] != "Hide"
		create_tab("Monitor") if @needed_values["Monitor"] != "Hide" && @needed_values["Monitor Entries"] > 0
		
		@all_vars["Buttons"]["Command"].signal_connect("clicked"){
			person = @all_vars["Menus"]["Client Menu"].active_text
			command = @all_vars["Entries"]["Command"].text
			command_to_send(person, command)
		}
		
		@all_vars["Windows"]["Main"].signal_connect("destroy"){
			@all_vars["Windows"].each{ |name,window|
				@all_vars["Close Windows"] = true
				@all_vars["Windows"][name].close
				@all_vars["Windows"][name] = nil
			}
			GLib::Source.remove(@timer_id)
			@all_vars["Threads"].each{ |_,thread| thread.kill if thread&.alive? }
			Gtk.main_quit
			kill_script "thunder" if running? "thunder"
		}
		
		@all_vars["Windows"]["Main"].add(@main_notebook)
		
		if @needed_values["Stats"] != "Hide"
			@all_vars["Scroll Windows"]["Stats"] = Gtk::ScrolledWindow.new
			@all_vars["Scroll Windows"]["Stats"].add(@all_vars["Grids"]["Stats Scroll"])
			@all_vars["Grids"]["Stats Parent"].attach(@all_vars["Scroll Windows"]["Stats"], 0, 0, 1, 1)
		end
		
		create_info_page if @needed_values["Info"] != "Hide"
		
		create_other_window("Stats") if @needed_values["Stats"] == "Window"
		create_other_window("Logs") if @needed_values["Logs"] == "Window"
		create_other_window("Monitor") if @needed_values["Monitor"] == "Window"
		create_other_window("Info") if @needed_values["Info"] == "Window"
		
		update_windows
		
		@all_vars["Buttons"].each{ |button_name,button| add_tooltip(button, button_name) }
		@all_vars["Entries"].each{ |entry_name,entry| add_tooltip(entry, entry_name) }
		@all_vars["Labels"].each{ |label_name,label| add_tooltip(label, label_name) if label_name != "Logs" && label_name != "Monitor" }
		@all_vars["Menus"].each{ |menu_name,menu| add_tooltip(menu, menu_name) }
		
		@all_vars["Windows"].each{ |_,window| window.show_all }
		
		@all_vars["Scroll Windows"].each{ |name,scroll_window|
			scroll_window.hexpand = true
			scroll_window.vexpand = true
		}
		
		if @needed_values["Link Windows"] == "Yes"
			@all_vars["Windows"].each{ |name,window|
				window.signal_connect("window-state-event"){ |_, event|
					if event.new_window_state & Gdk::WindowState::ICONIFIED != 0
						@all_vars["Windows"].each{ |name,window| window.iconify }
					else
						@all_vars["Windows"].each{ |name,window| window.deiconify }
					end
				}
			}
		end
		
		start_log_timer
		Thread.new{ create_server }
	end
	
	def self.create_tab(name)
		@old_person_sending_lines = nil
		@person_sending_lines = nil
		@all_vars["Auto Scroll"][name] = true
		@all_vars["Click Timers"][name] = Time.now
		@all_vars["Menus"]["#{name} Menu"] = Gtk::ComboBoxText.new
		if name == "Logs"
			@all_vars["Menus"]["#{name} Menu"].append_text("Client Status")
			@all_vars["Menus"]["#{name} Menu"].append_text("Messages Received")
		elsif name == "Monitor"
			@all_vars["Menus"]["#{name} Menu"].append_text("NO ONE")
			new_name = "Scripts Running"
			@all_vars["Labels"][new_name] = Gtk::Label.new
			@all_vars["Labels"][new_name].set_padding(10, 10)
			@all_vars["Labels"][new_name].set_alignment(0, 0)
			@all_vars["Labels"][new_name].set_line_wrap(true)
			@all_vars["Labels"][new_name].set_line_wrap_mode(:word)
		end
		@all_vars["Event Boxes"][name] = Gtk::EventBox.new
		@all_vars["Labels"][name] = Gtk::Label.new
		@all_vars["Labels"]["#{name} Scroll Active"] = Gtk::Label.new("Auto Scroll Active: Yes")
		@all_vars["Event Boxes"][name].add(@all_vars["Labels"][name])
		@all_vars["Labels"][name].set_padding(10, 10)
		@all_vars["Labels"][name].set_alignment(0, 0)
		@all_vars["Labels"][name].set_line_wrap(true)
		@all_vars["Labels"][name].set_line_wrap_mode(:word)
		
		@all_vars["Scroll Windows"][name] = Gtk::ScrolledWindow.new
		@all_vars["Scroll Windows"][name].add(@all_vars["Event Boxes"][name])
		
		@all_vars["Menus"]["#{name} Menu"].set_active(0)
		@all_vars["Menus"]["#{name} Menu"].signal_connect("changed"){ |menu|
			@old_person_sending_lines = @person_sending_lines
			person = menu.active_text
			@person_sending_lines = person
			if name == "Logs"
				update_log
			elsif name == "Monitor"
				@all_vars["Labels"]["Scripts Running"].text = ""
				@clients[@old_person_sending_lines].puts "Stop sending game lines." if (@old_person_sending_lines) && (@old_person_sending_lines != @person_sending_lines)
				@all_vars["Logs"]["Monitor"] = []
				@clients[person].puts "Send game lines." if person != "NO ONE"
				update_monitor
			end
		}

		@all_vars["Event Boxes"][name].signal_connect("button_press_event"){ |box, event|
			if (event.button == Gdk::BUTTON_PRIMARY) && (Time.now > @all_vars["Click Timers"][name] + 0.30)
				@all_vars["Click Timers"][name] = Time.now
				@all_vars["Auto Scroll"][name] = @all_vars["Auto Scroll"][name] == true ? @all_vars["Auto Scroll"][name] = nil : @all_vars["Auto Scroll"][name] = true
				if @all_vars["Auto Scroll"][name]
					@all_vars["Labels"]["#{name} Scroll Active"].text = "Auto Scroll Active: Yes"
				else
					@all_vars["Labels"]["#{name} Scroll Active"].text = "Auto Scroll Active: No"
				end
			end
		}

		@all_vars["Grids"]["#{name} Parent"].attach(@all_vars["Grids"]["#{name} Menu"], 0, 0, 1, 1)
		@all_vars["Grids"]["#{name} Parent"].attach(@all_vars["Grids"]["#{name} Labels"], 0, 1, 1, 1)
		@all_vars["Grids"]["#{name} Parent"].attach(@all_vars["Grids"]["#{name} Scroll"], 0, 2, 1, 1)
		
		@all_vars["Grids"]["#{name} Labels"].attach(@all_vars["Labels"]["#{name} Scroll Active"], 0, 0, 1, 1)
		@all_vars["Grids"]["#{name} Labels"].attach(@all_vars["Labels"]["Scripts Running"], 0, 1, 1, 1) if name == "Monitor"
		
		@all_vars["Grids"]["#{name} Menu"].attach(@all_vars["Menus"]["#{name} Menu"], 0, 0, 1, 1)
		
		@all_vars["Grids"]["#{name} Scroll"].attach(@all_vars["Scroll Windows"][name], 0, 0, 1, 1)
	end
	
	def self.command_to_send(person, command)
		if person.length > 0 && command.length > 0
			if person == "Everyone" || person == "All"
				@clients.each{ |_,client| client.puts "Action: #{command}" }
			else
				person = @clients.keys.find { |name| name.start_with?(person) } if !@clients.include?(person)
				@clients[person].puts "Action: #{command}"
			end
			@all_vars["Labels"]["Last Command Sent"].text = "Last Command Sent: '#{command}' sent to #{person}."
		end
	end
	
	def self.create_info_page		
		@all_vars["Scroll Windows"]["Info"] = Gtk::ScrolledWindow.new
		@all_vars["Scroll Windows"]["Info"].add(@all_vars["Grids"]["Info Scroll"])
		
		@all_vars["Labels"]["Requested Info"] = Gtk::Label.new
		@all_vars["Labels"]["Requested Info"].override_font(Pango::FontDescription.new("Monospace 10"))
		@all_vars["Grids"]["Info Scroll"].attach(@all_vars["Labels"]["Requested Info"], 0, 0, 1, 1)
		
		row = -1
		@all_vars["Grids"]["Info Parent"].attach(@all_vars["Grids"]["Info Menu"], 0, row += 1, 1, 1)
		@all_vars["Grids"]["Info Parent"].attach(@all_vars["Grids"]["Info Entries"], 0, row += 1, 1, 1)
		@all_vars["Grids"]["Info Parent"].attach(@all_vars["Grids"]["Info Buttons"], 0, row += 1, 1, 1)
		@all_vars["Grids"]["Info Parent"].attach(@all_vars["Scroll Windows"]["Info"], 0, row += 1, 1, 1)
		
		@all_vars["Buttons"]["Info Send"] = Gtk::Button.new(label: "Send")
		@all_vars["Buttons"]["Info Create"] = Gtk::Button.new(label: "Create")
		@all_vars["Buttons"]["Info Delete"] = Gtk::Button.new(label: "Delete")
		@all_vars["Buttons"]["Info Update"] = Gtk::Button.new(label: "Update")
		@all_vars["Menus"]["Info Menu"] = Gtk::ComboBoxText.new
		@all_vars["Menus"]["Info Sort"] = Gtk::ComboBoxText.new
		
		@all_vars["Menus"]["Info Sort"].append_text("Character Name")
		@all_vars["Menus"]["Info Sort"].append_text("Info Value")
		@all_vars["Menus"]["Info Sort"].set_active(0)
		
		column = -1
		@all_vars["Grids"]["Info Menu"].attach(@all_vars["Menus"]["Info Menu"], column += 1, 0, 1, 1)
		@all_vars["Grids"]["Info Menu"].attach(@all_vars["Buttons"]["Info Send"], column += 1, 0, 1, 1)
		@all_vars["Grids"]["Info Menu"].attach(@all_vars["Menus"]["Info Sort"], 0, 1, 1, 1)
		
		column = -1
		@all_vars["Grids"]["Info Buttons"].attach(@all_vars["Buttons"]["Info Create"], column += 1, 0, 1, 1)
		@all_vars["Grids"]["Info Buttons"].attach(@all_vars["Buttons"]["Info Delete"], column += 1, 0, 1, 1)
		@all_vars["Grids"]["Info Buttons"].attach(@all_vars["Buttons"]["Info Update"], column += 1, 0, 1, 1)
		
		entries = [ "Info Name", "Info Command", "Info Game Line" ]
		row = -1
		entries.each{ |entry_name|
			@all_vars["Entries"][entry_name] = Gtk::Entry.new
			label_text = entry_name.gsub("Info ", "")
			@all_vars["Grids"]["Info Entries"].attach(Gtk::Label.new("#{label_text}  "), 0, row += 1, 1, 1)
			@all_vars["Grids"]["Info Entries"].attach(@all_vars["Entries"][entry_name], 1, row, 1, 1)
		}
		
		update_info_commands_menu
		@all_vars["Buttons"]["Info Create"].signal_connect("clicked"){
				name = @all_vars["Entries"]["Info Name"].text
				command = @all_vars["Entries"]["Info Command"].text
				line = @all_vars["Entries"]["Info Game Line"].text
				if (name.length > 0) && (command.length > 0) && (line.length > 0)
					if @info_commands.include?(name)
						respond "###############################"
						respond "Message from ;thunder:"
						respond "An Info Command with that name already exists."
						respond "###############################"
					else
						@info_commands[name] = { "Command" => command, "Game Line" => line }
						entries.each{ |entry_name| @all_vars["Entries"][entry_name].text = "" }
						update_info_commands_menu
						save_settings
					end
				else
					respond "###############################"
					respond "Message from ;thunder:"
					respond "You must fill out all settings."
					respond "###############################"
				end
		}

		@last_click_time = 0
		@click_interval = 300
		@all_vars["Buttons"]["Info Delete"].signal_connect("clicked"){
			current_time = Time.now.to_f * 1000
			if current_time - @last_click_time <= @click_interval
				if @all_vars["Menus"]["Info Menu"].active_text.length > 0
					@info_commands.delete(@all_vars["Menus"]["Info Menu"].active_text)
					update_info_commands_menu
					save_settings
				end
			end
			@last_click_time = current_time
		}
		
		@all_vars["Buttons"]["Info Send"].signal_connect("clicked"){
			command_name = @all_vars["Menus"]["Info Menu"].active_text
			@all_vars["Requested Hash"] = {}
			@all_vars["Labels"]["Requested Info"].text = ""
			@all_vars["Current Request"] = @info_commands[command_name]["Game Line"]
			put @info_commands[command_name]["Command"]
			@clients.each{ |_,client| client.puts "Request: #{command_name}" }
		}
		
		@all_vars["Buttons"]["Info Update"].signal_connect("clicked"){
			name = @all_vars["Entries"]["Info Name"].text
			command = @all_vars["Entries"]["Info Command"].text
			line = @all_vars["Entries"]["Info Game Line"].text
			if (name.length > 0) && (command.length > 0) && (line.length > 0)
				if name == @all_vars["Menus"]["Info Menu"].active_text
					@info_commands[name] = { "Command" => command, "Game Line" => line }
					entries.each{ |entry_name| @all_vars["Entries"][entry_name].text = "" }
					update_info_commands_menu
					save_settings
				else
					respond "###############################"
					respond "Message from ;thunder:"
					respond "The name must remain the same when you are updating a command."
					respond "###############################"
				end
			else
				respond "###############################"
				respond "Message from ;thunder:"
				respond "You must fill out all settings."
				respond "###############################"
			end
		}
		
		@all_vars["Menus"]["Info Menu"].signal_connect("changed"){ |menu|
			name = menu.active_text
			if name.length > 0
				@all_vars["Entries"]["Info Name"].text = name
				@all_vars["Entries"]["Info Command"].text = @info_commands[name]["Command"]
				@all_vars["Entries"]["Info Game Line"].text = @info_commands[name]["Game Line"]
			else
				@all_vars["Entries"]["Info Name"].text = ""
				@all_vars["Entries"]["Info Command"].text = ""
				@all_vars["Entries"]["Info Game Line"].text = ""
			end
		}
		
		@all_vars["Menus"]["Info Sort"].signal_connect("changed"){ |menu| update_request }

		@all_vars["Menus"]["Info Menu"].set_active(1)
		@all_vars["Menus"]["Info Menu"].set_active(0)
	end
	
	def self.update_info_commands_menu
		new_hash = @info_commands.sort.to_h
		menu = @all_vars["Menus"]["Info Menu"]
		current_selection = menu.active_text
		menu.remove_all
		new_hash.each{ |name,_| menu.append_text(name) }
		if !new_hash.include?(current_selection)
			menu.set_active(0)
		else
			match_menu_item(menu, current_selection)
		end
	end

	def self.create_settings_page
		@spin_buttons = {}
		@check_boxes = {}
		@radio_buttons = {}
		adjustments = {}

		row = -1
		buttons = [ "Update Room", "Update Info", "Update Exp", "Log Entries", "Monitor Entries", "Seen Lines", "Main Width", "Main Height", "Stats Width", "Stats Height", "Logs Width", "Logs Height", "Monitor Width", "Monitor Height", "Info Width", "Info Height", "Characters/Row", "Port Number" ]
		buttons.each{ |button_name|
			if button_name =~ /Update Room|Update Info/
				adjustments[button_name] = Gtk::Adjustment.new(@needed_values[button_name], 0.5, 10, 0.1, 0.1, 0)
				@spin_buttons[button_name] = Gtk::SpinButton.new(adjustments[button_name], 0.1, 1)
			elsif button_name == "Update Exp"
				adjustments[button_name] = Gtk::Adjustment.new(@needed_values[button_name], 5, 300, 1, 10, 0)
				@spin_buttons[button_name] = Gtk::SpinButton.new(adjustments[button_name])
			elsif button_name == "Seen Lines"
				adjustments[button_name] = Gtk::Adjustment.new(@needed_values[button_name], 0, 25, 1, 1, 0)
				@spin_buttons[button_name] = Gtk::SpinButton.new(adjustments[button_name])
			else
				if button_name =~ /Log Entries|Monitor Entries/
					adjustments[button_name] = Gtk::Adjustment.new(@needed_values[button_name], 0, 1000, 1, 10, 0)
				elsif button_name =~ /Width|Height/
					adjustments[button_name] = Gtk::Adjustment.new(@needed_values[button_name], 200, 2000, 1, 10, 0)
				elsif button_name == "Port Number"
					adjustments[button_name] = Gtk::Adjustment.new(@needed_values[button_name], 1025, 65535, 1, 10, 0)
				elsif button_name == "Characters/Row"
					adjustments[button_name] = Gtk::Adjustment.new(@needed_values[button_name], 1, 10, 1, 1, 0)
				end
				@spin_buttons[button_name] = Gtk::SpinButton.new(adjustments[button_name])
			end
			label = Gtk::Label.new("#{button_name}:     ")
			add_tooltip(label, button_name)
			add_tooltip(@spin_buttons[button_name], button_name)
			@all_vars["Grids"]["Settings Spin Buttons"].attach(label, 0, row += 1, 1, 1)
			@all_vars["Grids"]["Settings Spin Buttons"].attach(@spin_buttons[button_name], 1, row, 1, 1)
		}
		
		update_buttons = [ "Main Width", "Main Height", "Stats Width", "Stats Height", "Logs Width", "Logs Height", "Monitor Width", "Monitor Height", "Info Width", "Info Height", "Characters/Row" ]
		@spin_buttons.each{ |button_name,button| 
			if update_buttons.include?(button_name)
				button.signal_connect("value-changed"){
					@needed_values[button_name] = @spin_buttons[button_name].value.to_i
					update_windows
					arrange_all_clients
				}
			end
		}
		
		column = -1
		row = 0
		checkboxes = [ "Health", "Mana", "Stamina", "Spirit", "Field Exp", "Encumbrance", "Status", "Bounty", "Room #", "Show Tooltips", "Link Windows", "Hide Settings" , "Debug Mode" ]
		checkboxes.each{ |box_name|
			@check_boxes[box_name] = Gtk::CheckButton.new(box_name)
			checkbox = @check_boxes[box_name]
			add_tooltip(checkbox, box_name)
			if @needed_values[box_name] == "Yes"
				checkbox.active = true
			else
				checkbox.active = false
			end
			@all_vars["Grids"]["Settings Checkboxes"].attach(checkbox, column += 1, row, 1, 1)
			if column >= 1
				column = -1
				row += 1
			end
			
			checkbox.signal_connect("toggled"){ |box|
				if box.active?
					@needed_values[box_name] = "Yes"
				else
					@needed_values[box_name] = "No"
				end
				arrange_all_clients
			}
		}

		radio_buttons = [ "Stats", "Logs", "Monitor", "Info" ]
		first_option = "Tab"
		other_options = [ "Window", "Hide" ]
		
		grid = @all_vars["Grids"]["Settings Radio Buttons"]
		radio_buttons.each{ |group_name|
			column = -1
			row += 1
			grid.attach(Gtk::Label.new(group_name), column += 1, row += 1, 1, 1)
			@radio_buttons["#{group_name} #{first_option}"] = Gtk::RadioButton.new(label: first_option)
			main_radio = @radio_buttons["#{group_name} #{first_option}"]
			main_radio.active = true if @needed_values[group_name] == first_option
			add_tooltip(main_radio, group_name)
			grid.attach(main_radio, column += 1, row, 1, 1)
			other_options.each{ |other_name|
				@radio_buttons["#{group_name} #{other_name}"] = Gtk::RadioButton.new(label: other_name, member: main_radio)
				radio = @radio_buttons["#{group_name} #{other_name}"]
				grid.attach(radio, column += 1, row, 1, 1)
				radio.active = true if @needed_values[group_name] == other_name
			}
		}
		
		@all_vars["Buttons"]["Save"] = Gtk::Button.new("Save")
		@all_vars["Buttons"]["Save"].signal_connect("clicked"){ save_settings }
		@all_vars["Grids"]["Settings Button"].attach(@all_vars["Buttons"]["Save"], 0, 0, 1, 1)
		
		name = "Defaults"
		@all_vars["Buttons"][name] = Gtk::Button.new(name)
		@all_vars["Buttons"][name].signal_connect("clicked"){
			@spin_buttons.each{ |button_name,button| button.value = @defaults[button_name] }
			@check_boxes.each{ |box_name,checkbox|
				if @defaults[box_name] == "Yes"
					checkbox.active = true
				else
					checkbox.active = false
				end
			}
		}
		@all_vars["Grids"]["Settings Button"].attach(@all_vars["Buttons"][name], 1, 0, 1, 1)
	end
	
	def self.update_windows	
		@all_vars["Scroll Windows"].each{ |name,scroll_window|
			value_name = @needed_values[name] == "Window" ? name : "Main"
			scroll_window.width_request = @needed_values["#{value_name} Width"]
			scroll_window.height_request  = @needed_values["#{value_name} Height"]
		}
		
		@all_vars["Windows"].each{ |name,window|
			value_name = @needed_values[name] == "Window" ? name : "Main"
			window.resize(@needed_values["#{value_name} Width"], @needed_values["#{value_name} Height"])
		}
	end
	
	def self.port_in_use?(port)
		begin
			TCPServer.open('localhost', port).close
			false
		rescue Errno::EADDRINUSE
			true
		end
	end

	def self.free_port(port)
		begin
			@main_server = TCPServer.open('localhost', port)
			@main_server.close
		rescue Errno::EADDRINUSE
			sleep 0.1
			retry
		end
	end
	
	def self.create_server
		port = @needed_values["Port Number"]
		@clients = {}

		if port_in_use?(port)
			@all_vars["Labels"]["Server Status"].text = "Port #{port} is already in use, waiting for port to be free."
			free_port(port)
			@all_vars["Labels"]["Server Status"].text = "Port #{port} is now free."
		end

		@main_server = TCPServer.new('localhost', port)

		@all_vars["Labels"]["Server Status"].text = "Server now running on port #{port}."

		add_client_info(checkname)
		
		if @needed_values["Stats"] != "Hide"
			@all_vars["Threads"]["Watch"] = Thread.new{
				loop{
					update_stat_values("Health", health, maxhealth)
					update_stat_values("Mana", mana, maxmana)
					update_stat_values("Stamina", stamina, maxstamina)
					update_stat_values("Spirit", spirit, Char.max_spirit)
					update_stat_values("Encumbrance", percentencumbrance, 100)
					update_status if (@needed_values["Status"] == "Yes")
					update_bounty if (@needed_values["Bounty"] == "Yes")
					sleep @needed_values["Update Info"]
				}
			}
			
			@all_vars["Threads"]["Watch 2"] = Thread.new{
				if @needed_values["Room #"] == "Yes"
					loop{
						update_room
						sleep @needed_values["Update Room"]
					}
				end
			}
			
			@all_vars["Threads"]["Watch 3"] = Thread.new{
				if @needed_values["Field Exp"] == "Yes"
					loop{
						@last_mind_state = checkmind.dup
						update_exp
						seconds_remaining = @needed_values["Update Exp"].dup
						@needed_values["Update Exp"].times{
							sleep 1
							seconds_remaining -= 1
							break if seconds_remaining < 1
							break if @last_mind_state != checkmind
						}
					}
				end
			}
		end
		
		@all_vars["Threads"]["Respond Now"] = Thread.new{
			loop{
				sleep 60
				@all_unresponsive = []
				@clients.each{ |name,client|
					@all_unresponsive.push(name)
					@clients[name].puts "Respond now."
				}
				sleep 5
				@all_unresponsive.each{ |name| @clients[name].puts "Respond now." } if @all_unresponsive.count > 0
				sleep 5
				if @all_unresponsive.count > 0
					@all_vars["Labels"]["Clients Unresponsive"].text = "Clients Unresponsive: #{@all_unresponsive.join(", ")}"
					@all_vars["Labels"]["Clients Unresponsive"].override_color(:normal, Gdk::RGBA.new(255, 0, 0, 1.0))
				else
					@all_vars["Labels"]["Clients Unresponsive"].text = "Clients Unresponsive: NONE"
					@all_vars["Labels"]["Clients Unresponsive"].override_color(:normal, nil)
				end
			}
		}

		loop{
			client = @main_server.accept
			name = client.gets.chomp.strip
			@clients[name] = client
			@all_vars["Labels"]["Latest Client Status"].text = "Latest Client Status: #{name} connected."
			add_log("Client Status", "#{name} connected.")
			@clients[name].puts "Host Name: #{checkname}"
			add_client_info(name)
			sort_name_list

			Thread.new{
				loop{
					data = @clients[name].gets.chomp
					if data =~ /Game Line: (.*)/
						add_log("Monitor", $1)
					elsif data !~ /Running Scripts:/
						add_log("Messages Received", data)
						@all_vars["Labels"]["Latest Message"].text = "Latest message: #{data}"
					end
					if data.nil? || data =~ /Disconnecting\: /
						break
					elsif data =~ /I am responding./
						@all_unresponsive.delete(name)
					elsif data =~ /(#{@regex_bars}): (-?\d+)\/(\d+)/
						update_progress_bar(name, $1, $2, $3)
					elsif data =~ /(#{@regex_labels}): (.*)/
						update_label(name, $1, $2)
					elsif data =~ /Running Scripts: (.*)/
						@all_vars["Labels"]["Scripts Running"].text = "Running scripts: #{$1}"
					elsif data =~ /Requested Info: (.*)/
						@all_vars["Requested Hash"][name] = $1
						update_request
					end
					@clients[name].puts "Server received: #{data}" if @needed_values["Debug Mode"] == "Yes"
				}
				remove_menu_item(@all_vars["Menus"]["Client Menu"], name)
				remove_menu_item(@all_vars["Menus"]["Monitor Menu"], name)
				@all_vars["Labels"]["Latest Client Status"].text = "Latest Client Status: #{name} disconnected."
				add_log("Client Status", "#{name} disconnected.")
				@clients[name].close
				@clients.delete(name)
				arrange_all_clients
				sort_name_list
			}
		}
	end
	
	def self.update_request
		longest_name = @all_vars["Requested Hash"].keys.max_by(&:length).length
		text = ""
		if @all_vars["Menus"]["Info Sort"].active_text == "Character Name"
			new_hash = @all_vars["Requested Hash"].sort.to_h
			new_hash.each{ |name,value| text += "#{name.ljust(longest_name)}     #{value}\n" }
		elsif @all_vars["Menus"]["Info Sort"].active_text == "Info Value"
			key_value = @all_vars["Requested Hash"].first
			if key_value[1] =~ /[\d,]/
				new_hash = @all_vars["Requested Hash"].sort_by { |name, value| [value.gsub(',', '').to_i, name] }.to_h
				new_hash.each{ |name,value| text += "#{name.ljust(longest_name)}     #{value.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}\n" }
			else
				new_hash = @all_vars["Requested Hash"].sort_by { |name, value| [value, name] }.to_h
				new_hash.each{ |name,value| text += "#{name.ljust(longest_name)}     #{value.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}\n" }
			end
		end
		@all_vars["Labels"]["Requested Info"].text = "#{@all_vars["Menus"]["Info Menu"].active_text}:\n"
		@all_vars["Labels"]["Requested Info"].text += text
	end
	
	def self.add_client_info(name)
		if @needed_values["Stats"] != "Hide"
			@all_vars["Info Labels"][name] = {}
			@all_vars["Progress Bars"][name] = {}
			@all_vars["Overlays"][name] = {}
			@all_vars["Info Labels"][name]["Name"] = Gtk::Label.new(name)

			@bar_names.each{ |bar_name|
				@all_vars["Progress Bars"][name][bar_name] = Gtk::ProgressBar.new
				@all_vars["Progress Bars"][name][bar_name].set_size_request(1, 1)
				@all_vars["Info Labels"][name][bar_name] = Gtk::Label.new
				@all_vars["Overlays"][name][bar_name] = Gtk::Overlay.new
				@all_vars["Overlays"][name][bar_name].add(@all_vars["Progress Bars"][name][bar_name])
				@all_vars["Overlays"][name][bar_name].add_overlay(@all_vars["Info Labels"][name][bar_name])
			
				if bar_name == "Health"
					bar_color = "rgba(255, 0, 0, 1.0)"
					border_color = "rgba(255, 0, 0, 1.0)"
					trough_color = "rgba(0, 0, 0, 1.0)"
				elsif bar_name == "Mana"
					bar_color = "rgba(0, 0, 255, 1.0)"
					border_color = "rgba(0, 0, 255, 1.0)"
					trough_color = "rgba(0, 0, 0, 1.0)"
				elsif bar_name == "Stamina"
					bar_color = "rgba(139, 128, 0, 1.0)"
					border_color = "rgba(139, 128, 0, 1.0)"
					trough_color = "rgba(0, 0, 0, 1.0)"
				elsif bar_name == "Spirit"
					bar_color = "rgba(128, 128, 128, 1.0)"
					border_color = "rgba(128, 128, 128, 1.0)"
					trough_color = "rgba(0, 0, 0, 1.0)"
				elsif bar_name == "Field Exp"
					bar_color = "rgba(255, 140, 0, 1.0)"
					border_color = "rgba(255, 140, 0, 1.0)"
					trough_color = "rgba(0, 0, 0, 1.0)"
				elsif bar_name == "Encumbrance"
					bar_color = "rgba(92, 64, 51, 1.0)"
					border_color = "rgba(92, 64, 51, 1.0)"
					trough_color = "rgba(0, 0, 0, 1.0)"
				end
				@all_vars["Info Labels"][name][bar_name].override_color(:normal, Gdk::RGBA.new(255, 255, 255, 1.0))
			
				provider = Gtk::CssProvider.new
				css = <<~CSS
					progressbar progress {
						min-height: 12px;
						background-color: #{bar_color};
						border-color: #{border_color};
					}

					progressbar trough {
						min-height: 12px;
						background-color: #{trough_color};
						border-color: #{border_color};
					}
				CSS
				provider.load_from_data(css)
				context = @all_vars["Progress Bars"][name][bar_name].style_context
				context.add_provider(provider, Gtk::StyleProvider::PRIORITY_APPLICATION)
				
				update_progress_bar(name, bar_name, 1000, 1000)
			}
			@status_labels.each{ |label_name|
				@all_vars["Info Labels"][name][label_name] = Gtk::Label.new
				@all_vars["Info Labels"][name][label_name].override_color(:normal, Gdk::RGBA.new(0, 0, 0, 1.0))
				update_label(name, label_name, "PLACEHOLDER")
			}
			arrange_all_clients
		end
	end
	
	def self.add_tooltip(widget, name)
		widget.set_tooltip_text(@tooltips[name]) if @needed_values["Show Tooltips"] == "Yes"
	end
	
	def self.create_other_window(name)
		@all_vars["Windows"][name] = Gtk::Window.new(:toplevel)
		@all_vars["Windows"][name].set_keep_above(true)
		@all_vars["Windows"][name].set_title("#{name} - #{checkname}")
		@all_vars["Windows"][name].move(@needed_values["#{name} Horizontal Position"], @needed_values["#{name} Vertical Position"])
		@all_vars["Scroll Windows"][name].set_policy(:always, :always) if @all_vars["Scroll Windows"][name]
		
		@all_vars["Windows"][name].signal_connect("delete-event") do
			@all_vars["Windows"]["Main"].close if @all_vars["Windows"]["Main"]
			if @all_vars["Close Windows"]
				false
			else
				true
			end
		end

		@all_vars["Windows"][name].add(@all_vars["Grids"]["#{name} Parent"])
	end
	
	def self.arrange_all_clients
		if @needed_values["Stats"] != "Hide"
			chars_per_row = 0
			@info_row = -1
			@info_column = -1
			new_hash = @clients.dup
			new_hash[checkname] = ""
			new_hash = new_hash.sort.to_h
			grid = @all_vars["Grids"]["Stats Scroll"]
			grid.each { |widget| grid.remove(widget) }
			new_hash.each{ |name,_|
				starting_row = @info_row
				grid.attach(@all_vars["Info Labels"][name]["Name"], @info_column += 1, @info_row += 1, 1, 1)
				@bar_names.each{ |bar_name| grid.attach(@all_vars["Overlays"][name][bar_name], @info_column, @info_row += 1, 1, 1) if @needed_values[bar_name] == "Yes" }
					
				@status_labels.each{ |label_name| grid.attach(@all_vars["Info Labels"][name][label_name], @info_column, @info_row += 1, 1, 1) if @needed_values[label_name] == "Yes" }
				
				grid.attach(Gtk::Label.new("     "), @info_column, @info_row += 1, 1, 1)

				chars_per_row += 1
				if chars_per_row >= (@needed_values["Characters/Row"])
					@info_column = -1
					@info_row += 1
					chars_per_row = 0
				else
					grid.attach(Gtk::Label.new("     "), @info_column += 1, @info_row, 1, 1)
					@info_row = starting_row
				end
					
				@all_vars["Info Labels"][name].each{ |label_name, label|
					label.set_line_wrap(true)
					label.set_max_width_chars(10)
				}
			}
			grid.show_all
		end
	end
	
	def self.update_label(name, label_name, value)
		if label_name == "Status"
			if value == "GREAT!"
				@all_vars["Info Labels"][name][label_name].override_color(:normal, Gdk::RGBA.new(0, 255, 0, 1.0))
			else
				@all_vars["Info Labels"][name][label_name].override_color(:normal, Gdk::RGBA.new(255, 0, 0, 1.0))
			end
			@all_vars["Info Labels"][name][label_name].set_markup("<b>#{label_name}: #{value}</b>")
		else
			value = "Bounty: None" if value == "None" && label_name == "Bounty"
			value = "#{label_name}: #{value}" if label_name == "Room #"
			@all_vars["Info Labels"][name][label_name].text = value
		end
	end
	 
	def self.update_progress_bar(name, stat, min, max)
		min = min.to_i
		max = max.to_i
		new_min = [0, min.to_i].max
		if max == 0
			@all_vars["Progress Bars"][name][stat].fraction = 0
		elsif new_min > max
			@all_vars["Progress Bars"][name][stat].fraction = 1
		else
			@all_vars["Progress Bars"][name][stat].fraction = ((new_min.to_f) / max.to_f)
		end
		@all_vars["Info Labels"][name][stat].set_markup("<b>#{min}/#{max}</b>")
	end
	
	def self.update_stat_values(stat_name, current_number, max_number)
		if (current_number != @all_vars["Current Stats"][stat_name]) && (@needed_values[stat_name] == "Yes")
			update_progress_bar(checkname, stat_name, current_number, max_number)
			@all_vars["Current Stats"][stat_name] = current_number
		end
	end
	
	def self.update_status
		all_wounds = Wounds.head, Wounds.neck, Wounds.abs, Wounds.lhand, Wounds.rhand, Wounds.larm, Wounds.rarm, Wounds.chest, Wounds.back, Wounds.rleg, Wounds.lleg, Wounds.nerves, Wounds.leye, Wounds.reye, Scars.head, Scars.neck, Scars.abs, Scars.lhand, Scars.rhand, Scars.larm, Scars.rarm, Scars.chest, Scars.back, Scars.rleg, Scars.lleg, Scars.nerves, Scars.leye, Scars.reye
		info = []
		info.push("Injured") if all_wounds.any?{ |i| i > 0 }
		info.push("Prone") if checkprone
		info.push("Poisoned") if checkpoison
		info.push("Diseased") if checkdisease
		info.push("Bleeding") if checkbleeding
		info.push("Stunned") if checkstunned
		info.push("Webbed") if checkwebbed
		info.push("Bound") if checkbound
		info.push("Calmed") if checkcalmed
		info.push("Cut Throat") if checkcutthroat
		info.push("Silenced") if checksilenced
		info.push("Sleeping") if checksleeping
		info = "GREAT!" if info.empty?
		info = "DEAD" if checkdead

		info = info.join(", ") if info.is_a?(Array)
		
		stat_name = "Status"
		if info != @all_vars["Current Stats"][stat_name]
			update_label(checkname, stat_name, info)
			@all_vars["Current Stats"][stat_name] = info
		end
	end

	def self.update_bounty
		if checkbounty =~ /The local gem dealer, .*, has an order to fill and wants our help./
			info = "Gem NPC"
		elsif checkbounty =~ /received orders from multiple customers requesting [a-zA-Z]+ (.*)\.  You have been tasked to retrieve (\d+) (?:more )?of them./
			info = "#{$2} #{$1}"
		elsif checkbounty =~ /WAIT for [a-zA-Z]+ to meet you there.  You must guarantee [a-zA-Z]+ safety to (.*) as soon as you can/
			info = "Escort #{$1}"
		elsif checkbounty =~ /The local healer, .*, has asked for our aid./
			info = "Herb NPC"
		elsif checkbounty =~ /working on a concoction that requires [a-zA-Z]+ (.*) found (?:on|in|near) (.*).  These samples must be in .* condition.  You have been tasked to retrieve (\d+) samples/
			info = "#{$3} #{$1} #{$2}"
		elsif checkbounty =~ /The local furrier .* has an order to fill and wants our help/
			info = "Skin NPC"
		elsif checkbounty =~ /You have been tasked to retrieve (\d+) (.*) of at least (.*) quality .* You can SKIN them off the corpse of [a-zA-Z]+ (.*) or purchase them from another adventurer./
			info = "#{$1} #{$2}"
		elsif checkbounty =~ /It appears they need your help in tracking down some kind of lost heirloom/
			info = "Heirloom NPC"
		elsif checkbounty =~ /You have been tasked to recover (.*) that an unfortunate citizen lost after being attacked by [a-zA-Z]+ (.*?) (?:on|in|near) (.*)\.  The heirloom .*SEARCH the area until you find it/
			info = "Heirloom Search #{$3}"
		elsif checkbounty =~ /You have been tasked to recover (.*) that an unfortunate citizen lost after being attacked by [a-zA-Z]+ (.*?) (?:on|in|near) (.*)\.  The heirloom .*Hunt down the creature and LOOT the item from its corpse./
			info = "Heirloom #{$1} #{$2} #{$3}"
		elsif checkbounty =~ /You have located .* and should bring it back to/
			info = "Heirloom FOUND"
		elsif checkbounty =~ /It appears that a local resident urgently needs our help in some matter./
			info = "Child NPC"
		elsif checkbounty =~ /A local divinist has had visions of the child fleeing from an? (.*?) (?:on|in|near) (.*)\.  Find the area/
			info = "Find Child #{$1} #{$2}"
		elsif checkbounty =~ /You have made contact with the child/
			info = "Return Child"
		elsif checkbounty =~ /child you were tasked to rescue is gone and your task is failed/
			info = "Child FAILED"
		elsif checkbounty =~ /It appears they have a bandit problem they'd like you to solve.|order to help [a-zA-Z]+ take care of a bandit problem./
			info = "Bandits NPC"
		elsif checkbounty =~ /You have been tasked to suppress bandit activity (?:on|in|near) (.*)\.  You need to kill (\d+).*of them to complete your task./ || checkbounty =~ /You have been tasked to help [a-zA-Z]+ suppress bandit activity (?:on|in|near) (.*)\.  You need to kill (\d+).*of them to complete your task./
			info = "#{$2} Bandits"
		elsif checkbounty =~ /It appears they have a creature problem they'd like you to solve/
			info = "Creatures NPC"
		elsif checkbounty =~ /You have been tasked to suppress (.*) activity (?:on|in|near) (.*)\.  You need to kill (\d+) of them to complete your task./ || checkbounty =~ /suppressing (.*) activity (?:on|in|near) (.*) during .*\.  You need to kill (\d+).*of them to complete your task./ || checkbounty =~ /suppress (.*) activity (?:on|in|near) (.*)\.  You need to kill (\d+).*of them to complete your task./
			info = "#{$3} #{$1}"
		elsif checkbounty =~ /You have been tasked to hunt down and kill a particularly dangerous (.*) that has established a territory (?:on|in|near) (.*)\.  You can get its attention by killing other creatures of the same type in its territory./
			info = "Dangerous #{$1}"
		elsif checkbounty =~ /You have been tasked to hunt down and kill a particularly dangerous (.*) that has established a territory (?:on|in|near) (.*)\.  You have provoked .* attention/
			info = "Dangerous #{$1}"
		elsif checkbounty =~ /to help [a-zA-Z]+ take care of an urgent matter.|to help [a-zA-Z]+ retrieve a lost heirloom|to help [a-zA-Z]+ take care of a creature problem./
			info = "Help NPC"
		elsif checkbounty =~ /You have succeeded in your task and can return to the Adventurer's Guild to receive your reward./
			info = "Finished Guild"
		elsif checkbounty =~ /You succeeded in your task and should report back/
			info = "Finished Guard"
		elsif checkbounty =~ /You are not currently assigned a task./
			info = "None"
		end
		
		stat_name = "Bounty"
		if info != @all_vars["Current Stats"][stat_name]
			update_label(checkname, stat_name, info)
			@all_vars["Current Stats"][stat_name] = info
		end
	end

	def self.update_room
		info = Room.current.id

		stat_name = "Room #"
		if info != @all_vars["Current Stats"][stat_name]
			update_label(checkname, stat_name, info)
			@all_vars["Current Stats"][stat_name] = info
		end
	end
	
	def self.update_exp
		$current_field_exp = nil
		$max_field_exp = nil
		put "exp"
		@silence.call
		wait_until{ $max_field_exp }
		update_stat_values("Field Exp", $current_field_exp, $max_field_exp)
	end
	
	def self.add_log(log, data)
		if (log == "Client Status") || (log == "Messages Received")
			max_entries = @needed_values["Log Entries"]
		elsif log == "Monitor"
			max_entries = @needed_values["Monitor Entries"]
		end
		if max_entries > 0
			@all_vars["Logs"][log] ||= []
			@all_vars["Logs"][log].shift if @all_vars["Logs"][log].count >= max_entries
			@all_vars["Logs"][log].push(data)
		end
	end
	
	def self.update_log
		current_log = @all_vars["Menus"]["Logs Menu"].active_text
		text = @all_vars["Logs"][current_log].join("\n")
		@all_vars["Labels"]["Logs"].text = text if text
		if @all_vars["Auto Scroll"]["Logs"]
			adjustment = @all_vars["Scroll Windows"]["Logs"].vadjustment
			adjustment.value = adjustment.upper
		end
	end
	
	def self.update_monitor
		text = @all_vars["Logs"]["Monitor"].join("\n")
		@all_vars["Labels"]["Monitor"].text = text if text
		if @all_vars["Auto Scroll"]["Monitor"]
			adjustment = @all_vars["Scroll Windows"]["Monitor"].vadjustment
			adjustment.value = adjustment.upper
		end
	end
	
	def self.sort_name_list
		new_hash = @clients.sort.to_h
		[@all_vars["Menus"]["Client Menu"], @all_vars["Menus"]["Monitor Menu"]].each{ |menu|
			current_person = menu.active_text
			menu.remove_all
			if menu.equal?(@all_vars["Menus"]["Client Menu"])
				menu.append_text("Everyone") if new_hash.count > 0
			elsif menu.equal?(@all_vars["Menus"]["Monitor Menu"])
				menu.append_text("NO ONE")
			end
			new_hash.each{ |name,client|
				menu.append_text(name)
			}
			if !new_hash.include?(current_person)
				menu.set_active(0)
			else
				match_menu_item(menu, current_person)
			end
		}
		@all_vars["Labels"]["Everyone Connected"].text = "Everyone connected (#{new_hash.count}): #{new_hash.keys.join(", ")}"
	end
	
	def self.match_menu_item(menu, item_needed)
		menu.model.each{ |model, path, iter|
			if item_needed == menu.model.get_value(iter, 0)
				menu.set_active_iter(iter)
				break
			end
		}
	end
	
	def self.start_log_timer
		@timer_id = GLib::Timeout.add(3000){
			update_log
			update_monitor
			true
		}
	end
	
	def self.remove_menu_item(menu, name)
		index = 0
		menu.model.each{ |model, path, iter|
			if name == menu.model.get_value(iter, 0)
				menu.remove(index)
				break
			end
			index += 1
		}
	end
	
	def self.variable=(value)
		if value
			@show_settings = true
		else
			@show_settings = nil
		end
	end
	
	def self.watching
		respond
		respond "#################################################################################################################"
		respond "Message from ;thunder"
		respond "If stats in the 'Stats' tab show up as 1000 or 'PLACEHOLDER', do this: go to the 'Settings' tab, scroll down to the bottom of the window, then click the 'Save' button, then close the ;thunder window and restart ;thunder. This should fix the issue."
		respond "#################################################################################################################"
		respond
	
		while line = get
			if (@all_vars["Current Request"]) && line =~ /#{@all_vars["Current Request"]}/
				@all_vars["Requested Hash"][checkname] = $1
				update_request
				@all_vars["Current Request"] = nil
			end
			if line =~ /^t ([a-zA-Z]+) (.*)/i
				person = $1.capitalize
				command = $2
				command_to_send(person, command)
			elsif line =~ /Field Exp: ([\d,]+)\/([\d,]+)/ && $max_field_exp.nil?
				$current_field_exp = $1.delete(",").to_i
				$max_field_exp = $2.delete(",").to_i
			end
		end
	end
	
	toggle_upstream
	thunder_message = proc{ |server_string|
		if server_string =~ /^(?:<c>);thun(?:d?e?r?) ([a-zA-Z]+) (.*)/
			person = $1.capitalize
			command = $2
			command_to_send(person, command)
			nil
		else
			server_string
		end
	}
	
	UpstreamHook.add("thunder_message", thunder_message)

	save_settings if @load_data.nil?

	before_dying{
		@all_vars["Windows"]["Main"].close if @all_vars["Windows"]["Main"]
		DownstreamHook.remove("thunder_silence")
		UpstreamHook.remove("thunder_message")
		echo "Shutting down server..."
		@clients.each{ |name,client| 
			unless client.closed?
				client.puts "Shut down."
				client.close
			end
		}
		@main_server.close
	}
end

Gtk.queue {
	ThunderMain.variable = script.vars[1]
	ThunderMain.create_main_window
	Gtk.main
}

ThunderMain.watching

sleep