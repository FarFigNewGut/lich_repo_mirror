=begin

	You need to download the script ;struck and run it for any character that you want to connect to the server created by running this script.

	This script essentially creates a server on your computer so all of your characters can communicate with one another, no matter where they are in the game world.
	
	This script also creates a window which shows a lot of information about your characters; such as their health, stamina, mana, current bounty, Lich room number, and more!
	
	The script also tracks which characters are connected to the server, which ones have disconnected, and which ones have become unresponsive.
	
	You can also send commands to all of your characters or just one character and those character(s) will perform those actions, just as if you entered the command manually in their game window.
	
	There are various settings so you can make the script work just the way you want it.
	
	Be sure to start this script first on the character you want to act as the server, then start the script ;struck on any character you want to connect to the server.

	Version 1: Initial release!
	Version 2: Sending a command from ;thunder that starts with either 'script' or ';' will start a lich script.
	Version 2: Example: script go2 400 and ;go2 400 would both work.
	Version 3: Script now tracks more status conditions and will now track multiple status conditions. You can now see if a character is bleeding AND stunned. Or even bleeding, stunned, and sleeping!
	Version 3: Script can now track the field experience of all characters.
	Version 3: Script can now track the encumbrance of all characters.
	Version 3: You can now send commands to clients via ;send, because clicking buttons is too much work.
		To send a command to everyone do: ;send t all <command> || example: ;send t all wave
		To send a command to a specific character do: ;send t <name> <command> || example ;send t dreaven wave
		Works for scripts too! ;send t Dreaven ;go2 bank
		You can also partially match a character's name. Example: ;send t dre wave
	

	########################################################
	Ways to contact me:
	In game: Dreaven
	Player's Corner: Tgo01
	Discord: Dreaven#6436
	Email: LordDreaven@gmail.com
	If you like my scripts feel free to send me a tip via Paypal at: LordDreaven@gmail.com
	########################################################
	
	Author: Dreaven
	Version: 3

=end

silence_me

require 'socket'

hide_me

class ThunderMain
	@save_file = "Thunder Settings.json"
	@lock_file = "Lock File.lock"
	@load_data = nil
	@needed_values = {}
	@current_stats = {}
	
	size_info = "\n\nNote: Manually resizing the window won't work because some tabs use a scrolled window and scrolled windows won't change size by manually resizing the window, so you must set this setting to get the proper size you want."
	stat_info = "\n\nUncheck this box to not see this info."
	update_info = "\n\nRegardless of what you enter here, information is only sent from a client/updated if there has been a change in that specific stat since the last update."
	
	@tooltips = {
		"Server Status" => "The current status of the server.",
		"Latest Client Status" => "The latest status report received from a client.",
		"Everyone Connected" => "Everyone currently connected to the server.",
		"Latest Message" => "The latest message received from a client.",
		"Last Command Sent" => "The last command you sent to a client.",
		"Update Room" => "How many seconds clients (and yourself) will wait until updating their current room number again.#{update_info}",
		"Update Info" => "How many seconds clients (and yourself) will wait until updating their info (health, mana, bounty info, etc) again.#{update_info}",
		"Update Exp" => "How many seconds clients (and yourself) will wait until updating their experience again. Script will also update experience whenever the character's mind state changes, and then wait this many seconds before updating again.#{update_info}",
		"Log Entries" => "The number of entries you want to save for each log.",
		"Window Width" => "The width in pixels you want the window to be.#{size_info}",
		"Window Height" => "The height in pixels you want the window to be.#{size_info}",
		"Port Number" => "The port number you want the server to be set up on.\n\nIMPORTANT: You must set the port number on each client/character to match this number. Start ;struck on every client for more info on how to set the port number.\n\nBy default ;thunder and ;struck all connect to port 4000.",
		"Client Menu" => "List of everyone connected to the server.\n\nSelect who you want to send a command to. 'Everyone' will send a command to everyone.",
		"Log Menu" => "Select which log you want to view.",
		"Send Command" => "Select the person you want to send a command to from the drop down menu, then enter the command you want to send in the box, then click 'Send' to have the selected person perform that command.\n\nFor example if you want someone to wave simply type in 'wave' and click 'Send.'\n\nTo have the character(s) start a script enter the word 'script' or enter ';' first, followed by the script name then any command line variables.\n\nExample: script go2 400\n\nExample: ;go2 400",
		"Save" => "Click this button to save all current settings.\n\nIMPORTANT: Saved settings won't take effect until you restart the script.\n\nIMPORTANT: Clicking this button will also save the current position of the window so whenever you load the script the window will return to this position.",
		"Defaults" => "Click this button to set all settings back to their default values.\n\nIMPORTANT: You still have to click the 'Save' button to save these settings, you would then need to restart the script for the settings to take effect.",
		"Show Tooltips" => "Check this box if you want to see tooltips when you hover the mouse over items.\n\nUncheck this box to not see tooltips.",
		"Health" => "Check this box if you want to see everyone's Health in the status tab.#{stat_info}",
		"Mana" => "Check this box if you want to see everyone's Mana in the status tab.#{stat_info}",
		"Stamina" => "Check this box if you want to see everyone's Stamina in the status tab.#{stat_info}",
		"Spirit" => "Check this box if you want to see everyone's Spirit in the status tab.#{stat_info}",
		"Field Exp" => "Check this box if you want to see everyone's current field experience in the status tab.#{stat_info}",
		"Encumbrance" => "Check this box if you want to see everyone's current encumbrance in the status tab.#{stat_info}",
		"Status" => "Check this box if you want to see everyone's Status (stunned, prone, bleeding, etc) in the status tab.#{stat_info}",
		"Bounty" => "Check this box if you want to see everyone's Bounty info in the status tab.#{stat_info}",
		"Room #" => "Check this box if you want to see the everyone's current Lich room number in the status tab.#{stat_info}",
		"Debug Mode" => "Check this box if you want each client to echo back every command they send to the server and every command they receive from the server. This can cause a lot of echo information to be displayed for each client so you really only need it on to identify an issue, or if you just like to see these kinds of things.\n\nUncheck to not see these messages.",
		"Characters/Row" => "How many characters to show per row in the 'Stats' tab.",
	}
	
	@silence = proc{
		started = false
		hook_proc = proc { |s|
			if started
				if s =~ /<prompt/
					DownstreamHook.remove("thunder_silence")
					nil
				elsif s =~ /<output/
					s
				else
					nil
				end
			elsif s =~ /Level:/
				started = true
				nil
			else
				s
			end
		}
		DownstreamHook.add("thunder_silence", hook_proc)
	}
	
	@defaults = {
		"Update Room" => 1.0,
		"Update Info" => 0.5,
		"Update Exp" => 60,
		"Log Entries" => 100,
		"Window Width" => 400,
		"Window Height" => 400,
		"Port Number" => 4000,
		"Characters/Row" => 2,
		"Horizontal Position" => 0,
		"Vertical Position" => 0,
		"Show Tooltips" => "Yes",
		"Health" => "Yes",
		"Mana" => "Yes",
		"Stamina" => "Yes",
		"Spirit" => "Yes",
		"Field Exp" => "Yes",
		"Encumbrance" => "Yes",
		"Status" => "Yes",
		"Bounty" => "Yes",
		"Room #" => "Yes",
		"Debug Mode" => "No",
	}
	
	def self.load_the_data
		begin
			File.open(@lock_file, File::RDWR | File::CREAT){ |lock_file|
				lock_file.flock(File::LOCK_EX)
				
				return unless File.exist?(@save_file)
				
				@load_data = JSON.parse(File.read(@save_file))
			}
			@load_data = @load_data[checkname]
		rescue StandardError => e
			respond "Error message from ;thunder: #{e.message}"
		ensure
			File.open(@lock_file, File::RDWR | File::CREAT){ |lock_file| lock_file.flock(File::LOCK_UN) }
		end
	end
	
	load_the_data
	
	@defaults.each{ |setting_name,value|
		if value.is_a?(Integer)
			@needed_values[setting_name] = @load_data[setting_name] ? @load_data[setting_name].to_i : @defaults[setting_name]
		elsif value.is_a?(Float)
			@needed_values[setting_name] = @load_data[setting_name] ? @load_data[setting_name].to_f : @defaults[setting_name]
		else
			@needed_values[setting_name] = @load_data[setting_name] ? @load_data[setting_name] : @defaults[setting_name]
		end
	}
	
	bar_names = [ "Health", "Mana", "Stamina", "Spirit", "Field Exp", "Encumbrance" ]
	@needed_bars = []
	bar_names.each{ |bar_name| @needed_bars.push(bar_name) if @needed_values[bar_name] == "Yes" }
	@regex_bars = @needed_bars.map{ |label| label.gsub(",","") }.join("|")
	
	labels = [ "Status", "Bounty", "Room #" ]
	@status_labels = []
	labels.each{ |label_name| @status_labels.push(label_name) if @needed_values[label_name] == "Yes" }
	@regex_labels = @status_labels.map{ |label| label.gsub(",","") }.join("|")
	
	stat_list = [ "Health", "Mana", "Stamina", "Spirit", "Field Exp", "Encumbrance", "Status", "Bounty", "Room #", "Debug Mode", "Update Room", "Update Info", "Update Exp" ]
	@required_info = "Requests: "
	stat_list.each{ |name| @required_info += "#{name}: #{@needed_values[name]}, " }
	@required_info.chop!.chop!
	
	
	def self.save_settings
		File.open(@lock_file, File::RDWR | File::CREAT){ |lock|
			lock.flock(File::LOCK_EX)
			
			if File.exist?(@save_file)
				save_data = JSON.parse(File.read(@save_file))
			else
				save_data = {}
			end
			
			save_data[checkname] ||= {}
			
			x, y = @main_window.position
			save_data[checkname]["Horizontal Position"] = x
			save_data[checkname]["Vertical Position"] = y
			
			@spin_buttons.each{ |name,button| save_data[checkname][name] = button.value.round(1) }
			@check_boxes.each{ |name,box|
				if box.active?
					save_data[checkname][name] = "Yes"
				else
					save_data[checkname][name] = "No"
				end
			}
				
			File.open(@save_file, 'w'){ |file| file.write(JSON.pretty_generate(save_data)) }
			respond ";thunder: Data saved."
		}
	end

	def self.create_window
		@main_window = Gtk::Window.new(:toplevel)
		@main_window.set_keep_above(true)
		@main_window.set_title("Thunder - #{checkname}")
		@main_window.move(@needed_values["Horizontal Position"], @needed_values["Vertical Position"])
		@main_window.set_size_request(@needed_values["Window Width"], @needed_values["Window Height"])
		
		@all_labels = {}
		@all_menus = {}
		@logs = {}
		@all_grids = {}
		@info_labels = {}
		@progress_bars = {}
		@overlays = {}
		@threads = {}
		
		grids = [ "Main Parent", "Main Info", "Main Menu", "Main Entry", "Stats Parent", "Stats Players", "Logs Parent", "Logs Menu", "Logs Scroll", "Settings Parent", "Settings Spin Buttons", "Settings Checkboxes", "Settings Button" ]
		grids.each{ |grid| @all_grids[grid] = Gtk::Grid.new }
		
		@main_notebook = Gtk::Notebook.new
		@main_notebook.append_page(@all_grids["Main Parent"], Gtk::Label.new("Main"))
		@main_notebook.append_page(@all_grids["Stats Parent"], Gtk::Label.new("Stats"))
		@main_notebook.append_page(@all_grids["Logs Parent"], Gtk::Label.new("Logs"))
		@main_notebook.append_page(@all_grids["Settings Parent"], Gtk::Label.new("Settings"))
		
		create_settings_page
		
		@all_grids["Main Parent"].attach(@all_grids["Main Info"], 0, 0, 1, 1)
		@all_grids["Main Parent"].attach(@all_grids["Main Menu"], 0, 1, 1, 1)
		@all_grids["Main Parent"].attach(@all_grids["Main Entry"], 0, 2, 1, 1)
		
		@all_grids["Settings Parent"].attach(@all_grids["Settings Spin Buttons"], 0, 0, 1, 1)
		@all_grids["Settings Parent"].attach(@all_grids["Settings Checkboxes"], 0, 1, 1, 1)
		@all_grids["Settings Parent"].attach(@all_grids["Settings Button"], 0, 2, 1, 1)

		row = -1
		labels = [ "Server Status", "Latest Client Status", "Everyone Connected", "Latest Message", "Last Command Sent", "Clients Unresponsive" ]
		labels.each{ |label|
			@all_labels[label] = Gtk::Label.new("#{label}: ")
			@all_labels[label].set_line_wrap(true)
			@all_labels[label].set_line_wrap_mode(:word)
			@all_labels[label].set_halign(Gtk::Align::START)
			@all_grids["Main Info"].attach(@all_labels[label], 0, row += 1, 1, 1)
		}
		@all_labels["Clients Unresponsive"].text = "Clients Unresponsive: NONE"
		
		@all_menus["Client Menu"] = Gtk::ComboBoxText.new
		@all_menus["Log Menu"] = Gtk::ComboBoxText.new
		
		@command_entry = Gtk::Entry.new
		@command_button = Gtk::Button.new("Send")
		add_tooltip(@command_entry, "Send Command")
		add_tooltip(@command_button, "Send Command")
		@all_grids["Main Menu"].attach(@all_menus["Client Menu"], 0, 0, 1, 1)
		@all_grids["Main Entry"].attach(@command_entry, 0, 0, 1, 1)
		@all_grids["Main Entry"].attach(@command_button, 1, 0, 1, 1)
		
		@all_menus["Log Menu"]
		@all_menus["Log Menu"].append_text("Client Status")
		@all_menus["Log Menu"].append_text("Messages Received")
		@all_labels["Log"] = Gtk::Label.new
		@all_labels["Log"].set_padding(10, 10)
		@all_labels["Log"].set_alignment(0, 0)
		@all_labels["Log"].set_line_wrap(true)
		@all_labels["Log"].set_line_wrap_mode(:word)
		
		@all_menus["Log Menu"].set_active(0)
		@all_menus["Log Menu"].signal_connect("changed"){ |menu| update_log }
		
		@scroll_window = Gtk::ScrolledWindow.new
		@scroll_window.set_policy(:always, :always)
		@scroll_window.set_size_request(@needed_values["Window Width"], @needed_values["Window Height"])
		@scroll_window.add(@all_labels["Log"])

		@all_grids["Logs Parent"].attach(@all_grids["Logs Menu"], 0, 0, 1, 1)
		@all_grids["Logs Parent"].attach(@all_grids["Logs Scroll"], 0, 1, 1, 1)
		@all_grids["Logs Menu"].attach(@all_menus["Log Menu"], 0, 0, 1, 1)
		@all_grids["Logs Scroll"].attach(@scroll_window, 0, 0, 1, 1)
		
		scrolled_window = Gtk::ScrolledWindow.new
		scrolled_window.set_policy(:automatic, :automatic)
		scrolled_window.set_size_request(@needed_values["Window Width"], @needed_values["Window Height"])
		scrolled_window.add(@all_grids["Stats Players"])
		@all_grids["Stats Parent"].attach(scrolled_window, 0, 0, 1, 1)
		
		@command_button.signal_connect("clicked"){
			person = @all_menus["Client Menu"].active_text
			command = @command_entry.text
			command_to_send(person, command)
		}
		
		@main_window.signal_connect("destroy") do
			@main_window.close
			@main_window = nil
			GLib::Source.remove(@timer_id)
			@threads.each{ |_,thread| thread.kill if thread&.alive? }
			Gtk.main_quit
			kill_script "thunder" if running? "thunder"
		end
		
		@all_labels.each{ |label_name,label| add_tooltip(label, label_name) }
		@all_menus.each{ |menu_name,menu| add_tooltip(menu, menu_name) }
		
		@main_window.add(@main_notebook)
		@main_window.show_all
		
		start_log_timer
		Thread.new{ create_server }
	end
	
	def self.command_to_send(person, command)
		if person.length > 0 && command.length > 0
			if person == "Everyone" || person == "All"
				@clients.each{ |_,client| client.puts "Action: #{command}" }
			else
				person = @clients.keys.find { |name| name.start_with?(person) } if !@clients.include?(person)
				@clients[person].puts "Action: #{command}"
			end
			@all_labels["Last Command Sent"].text = "Last Command Sent: '#{command}' sent to #{person}."
		end
	end

	def self.create_settings_page
		@spin_buttons = {}
		@check_boxes = {}
		adjustments = {}
		
		row = -1
		buttons = [ "Update Room", "Update Info", "Update Exp", "Log Entries", "Window Width", "Window Height", "Characters/Row", "Port Number" ]
		buttons.each{ |button_name|
			if button_name =~ /Update Room|Update Info/
				adjustments[button_name] = Gtk::Adjustment.new(@needed_values[button_name], 0.5, 10, 0.1, 0.1, 0)
				@spin_buttons[button_name] = Gtk::SpinButton.new(adjustments[button_name], 0.1, 1)
			elsif button_name == "Update Exp"
				adjustments[button_name] = Gtk::Adjustment.new(@needed_values[button_name], 5, 300, 1, 10, 0)
				@spin_buttons[button_name] = Gtk::SpinButton.new(adjustments[button_name])
			else
				if button_name == "Log Entries"
					adjustments[button_name] = Gtk::Adjustment.new(@needed_values[button_name], 0, 1000, 1, 10, 0)
				elsif button_name =~ /Window Width|Window Height/
					adjustments[button_name] = Gtk::Adjustment.new(@needed_values[button_name], 300, 2000, 1, 10, 0)
				elsif button_name == "Port Number"
					adjustments[button_name] = Gtk::Adjustment.new(@needed_values[button_name], 1025, 65535, 1, 10, 0)
				elsif button_name == "Characters/Row"
					adjustments[button_name] = Gtk::Adjustment.new(@needed_values[button_name], 1, 10, 1, 1, 0)
				end
				@spin_buttons[button_name] = Gtk::SpinButton.new(adjustments[button_name])
			end
			label = Gtk::Label.new("#{button_name}:     ")
			add_tooltip(label, button_name)
			add_tooltip(@spin_buttons[button_name], button_name)
			@all_grids["Settings Spin Buttons"].attach(label, 0, row += 1, 1, 1)
			@all_grids["Settings Spin Buttons"].attach(@spin_buttons[button_name], 1, row, 1, 1)
		}
		
		column = -1
		row = 0
		checkboxes = [ "Show Tooltips", "Health", "Mana", "Stamina", "Spirit", "Field Exp", "Encumbrance", "Status", "Bounty", "Room #", "Debug Mode" ]
		checkboxes.each{ |box_name|
			@check_boxes[box_name] = Gtk::CheckButton.new(box_name)
			checkbox = @check_boxes[box_name]
			add_tooltip(checkbox, box_name)
			if @needed_values[box_name] == "Yes"
				checkbox.active = true
			else
				checkbox.active = false
			end
			@all_grids["Settings Checkboxes"].attach(checkbox, column += 1, row, 1, 1)
			if column >= 3
				column = -1
				row += 1
			end
		}
		
		save_button = Gtk::Button.new(label: "Save")
		add_tooltip(save_button, "Save")
		save_button.signal_connect("clicked"){ save_settings }
		@all_grids["Settings Button"].attach(save_button, 0, 0, 1, 1)
		
		defaults_button = Gtk::Button.new(label: "Defaults")
		add_tooltip(defaults_button, "Defaults")
		defaults_button.signal_connect("clicked"){
			@spin_buttons.each{ |button_name,button| button.value = @defaults[button_name] }
			@check_boxes.each{ |box_name,checkbox|
				if @defaults[box_name] == "Yes"
					checkbox.active = true
				else
					checkbox.active = false
				end
			}
		}
		@all_grids["Settings Button"].attach(defaults_button, 1, 0, 1, 1)
	end
	
	def self.port_in_use?(port)
		begin
			TCPServer.open('localhost', port).close
			false
		rescue Errno::EADDRINUSE
			true
		end
	end

	def self.free_port(port)
		begin
			@main_server = TCPServer.open('localhost', port)
			@main_server.close
		rescue Errno::EADDRINUSE
			sleep 0.1
			retry
		end
	end
	
	def self.create_server
		port = @needed_values["Port Number"]
		@clients = {}

		if port_in_use?(port)
			@all_labels["Server Status"].text = "Port #{port} is already in use, waiting for port to be free."
			free_port(port)
			@all_labels["Server Status"].text = "Port #{port} is now free."
		end

		@main_server = TCPServer.new('localhost', port)

		@all_labels["Server Status"].text = "Server now running on port #{port}."

		add_client_info(checkname)
		
		@threads["Watch"] = Thread.new{
			loop{
				update_stat_values("Health", health, maxhealth)
				update_stat_values("Mana", mana, maxmana)
				update_stat_values("Stamina", stamina, maxstamina)
				update_stat_values("Spirit", spirit, maxspirit)
				update_stat_values("Encumbrance", percentencumbrance, 100)
				update_status if (@needed_values["Status"] == "Yes")
				update_bounty if (@needed_values["Bounty"] == "Yes")
				sleep @needed_values["Update Info"]
			}
		}
		
		@threads["Watch 2"] = Thread.new{
			if @needed_values["Room #"] == "Yes"
				loop{
					update_room
					sleep @needed_values["Update Room"]
				}
			end
		}
		
		@threads["Watch 3"] = Thread.new{
			if @needed_values["Field Exp"] == "Yes"
				loop{
					@last_mind_state = checkmind.dup
					update_exp
					seconds_remaining = @needed_values["Update Exp"].dup
					@needed_values["Update Exp"].times{
						sleep 1
						seconds_remaining -= 1
						break if seconds_remaining < 1
						break if @last_mind_state != checkmind
					}
				}
			end
		}
		
		@threads["Respond Now"] = Thread.new{
			loop{
				sleep 60
				@all_unresponsive = []
				@clients.each{ |name,client|
					@all_unresponsive.push(name)
					@clients[name].puts "Respond now."
				}
				sleep 5
				@all_unresponsive.each{ |name| @clients[name].puts "Respond now." } if @all_unresponsive.count > 0
				sleep 5
				if @all_unresponsive.count > 0
					@all_labels["Clients Unresponsive"].text = "Clients Unresponsive: #{@all_unresponsive.join(" ")}"
					@all_labels["Clients Unresponsive"].override_color(:normal, Gdk::RGBA.new(255, 0, 0, 1.0))
				else
					@all_labels["Clients Unresponsive"].text = "Clients Unresponsive: NONE"
					@all_labels["Clients Unresponsive"].override_color(:normal, nil)
				end
			}
		}

		loop{
			client = @main_server.accept
			name = client.gets.chomp.strip
			@clients[name] = client
			@all_labels["Latest Client Status"].text = "Latest Client Status: #{name} connected."
			add_log("Client Status", "#{name} connected.")
			@clients[name].puts @required_info
			add_client_info(name)
			sort_name_list

			Thread.new{
				loop{
					data = @clients[name].gets.chomp
					add_log("Messages Received", data)
					@all_labels["Latest Message"].text = "Latest message: #{data}"
					if data.nil? || data =~ /Disconnecting\: /
						break
					elsif data =~ /(#{@regex_bars}): (-?\d+)\/(\d+)/
						update_progress_bar(name, $1, $2, $3)
					elsif data =~ /(#{@regex_labels}): (.*)/
						update_label(name, $1, $2)
					elsif data =~ /I am responding./
						@all_unresponsive.delete(name)
					end
					@clients[name].puts "Server received: #{data}" if @needed_values["Debug Mode"] == "Yes"
				}
				remove_character(@all_menus["Client Menu"], name)
				@all_labels["Latest Client Status"].text = "Latest Client Status: #{name} disconnected."
				add_log("Client Status", "#{name} disconnected.")
				@clients[name].close
				@clients.delete(name)
				arrange_all_clients
				sort_name_list
			}
		}
	end
	
	def self.add_client_info(name)
		@info_labels[name] = {}
		@progress_bars[name] = {}
		@overlays[name] = {}
		@info_labels[name]["Name"] = Gtk::Label.new(name)

		@needed_bars.each{ |bar_name|
			@progress_bars[name][bar_name] = Gtk::ProgressBar.new
			@progress_bars[name][bar_name].set_size_request(1, 1)
			@info_labels[name][bar_name] = Gtk::Label.new
			@overlays[name][bar_name] = Gtk::Overlay.new
			@overlays[name][bar_name].add(@progress_bars[name][bar_name])
			@overlays[name][bar_name].add_overlay(@info_labels[name][bar_name])
		
			if bar_name == "Health"
				bar_color = "rgba(255, 0, 0, 1.0)"
				border_color = "rgba(255, 0, 0, 1.0)"
				trough_color = "rgba(0, 0, 0, 1.0)"
			elsif bar_name == "Mana"
				bar_color = "rgba(0, 0, 255, 1.0)"
				border_color = "rgba(0, 0, 255, 1.0)"
				trough_color = "rgba(0, 0, 0, 1.0)"
			elsif bar_name == "Stamina"
				bar_color = "rgba(139, 128, 0, 1.0)"
				border_color = "rgba(139, 128, 0, 1.0)"
				trough_color = "rgba(0, 0, 0, 1.0)"
			elsif bar_name == "Spirit"
				bar_color = "rgba(128, 128, 128, 1.0)"
				border_color = "rgba(128, 128, 128, 1.0)"
				trough_color = "rgba(0, 0, 0, 1.0)"
			elsif bar_name == "Field Exp"
				bar_color = "rgba(255, 140, 0, 1.0)"
				border_color = "rgba(255, 140, 0, 1.0)"
				trough_color = "rgba(0, 0, 0, 1.0)"
			elsif bar_name == "Encumbrance"
				bar_color = "rgba(92, 64, 51, 1.0)"
				border_color = "rgba(92, 64, 51, 1.0)"
				trough_color = "rgba(0, 0, 0, 1.0)"
			end
			@info_labels[name][bar_name].override_color(:normal, Gdk::RGBA.new(255, 255, 255, 1.0))
		
			provider = Gtk::CssProvider.new
			css = <<~CSS
				progressbar progress {
					min-height: 12px;
					background-color: #{bar_color};
					border-color: #{border_color};
				}

				progressbar trough {
					min-height: 12px;
					background-color: #{trough_color};
					border-color: #{border_color};
				}
			CSS
			provider.load_from_data(css)
			context = @progress_bars[name][bar_name].style_context
			context.add_provider(provider, Gtk::StyleProvider::PRIORITY_APPLICATION)
		}
		@status_labels.each{ |label_name|
			@info_labels[name][label_name] = Gtk::Label.new
			@info_labels[name][label_name].override_color(:normal, Gdk::RGBA.new(0, 0, 0, 1.0))
		}
		arrange_all_clients
	end
	
	def self.add_tooltip(widget, name)
		widget.set_tooltip_text(@tooltips[name]) if @needed_values["Show Tooltips"] == "Yes"
	end
	
	def self.arrange_all_clients
		chars_per_row = 0
		@info_row = -1
		@info_column = -1
		new_hash = @clients.dup
		new_hash[checkname] = ""
		new_hash = new_hash.sort.to_h
		grid = @all_grids["Stats Players"]
		grid.each { |widget| grid.remove(widget) }
		new_hash.each{ |name,_|
			starting_row = @info_row
			grid.attach(@info_labels[name]["Name"], @info_column += 1, @info_row += 1, 1, 1)
			@needed_bars.each{ |bar_name| grid.attach(@overlays[name][bar_name], @info_column, @info_row += 1, 1, 1) }
			
			@status_labels.each{ |label_name| grid.attach(@info_labels[name][label_name], @info_column, @info_row += 1, 1, 1) }
			
			grid.attach(Gtk::Label.new("     "), @info_column, @info_row += 1, 1, 1)

			chars_per_row += 1
			if chars_per_row >= (@needed_values["Characters/Row"])
				@info_column = -1
				@info_row += 1
				chars_per_row = 0
			else
				grid.attach(Gtk::Label.new("     "), @info_column += 1, @info_row, 1, 1)
				@info_row = starting_row
			end
			
			@info_labels[name].each{ |label_name, label|
				label.set_line_wrap(true)
				label.set_max_width_chars(10)
			}
		}
		
		grid.show_all
	end
	
	def self.update_label(name, label_name, value)
		if label_name == "Status"
			if value == "GREAT!"
				@info_labels[name][label_name].override_color(:normal, Gdk::RGBA.new(0, 255, 0, 1.0))
			else
				@info_labels[name][label_name].override_color(:normal, Gdk::RGBA.new(255, 0, 0, 1.0))
			end
			@info_labels[name][label_name].set_markup("<b>#{label_name}: #{value}</b>")
		else
			value = "Bounty: None" if value == "None" && label_name == "Bounty"
			value = "#{label_name}: #{value}" if label_name == "Room #"
			@info_labels[name][label_name].text = value
		end
	end
	 
	def self.update_progress_bar(name, stat, min, max)
		min = min.to_i
		max = max.to_i
		new_min = [0, min.to_i].max
		if max == 0
			@progress_bars[name][stat].fraction = 0
		elsif new_min > max
			@progress_bars[name][stat].fraction = 1
		else
			@progress_bars[name][stat].fraction = ((new_min.to_f) / max.to_f)
		end
		@info_labels[name][stat].set_markup("<b>#{min}/#{max}</b>")
	end
	
	def self.update_stat_values(stat_name, current_number, max_number)
		if (current_number != @current_stats[stat_name]) && (@needed_values[stat_name] == "Yes")
			update_progress_bar(checkname, stat_name, current_number, max_number)
			@current_stats[stat_name] = current_number
		end
	end
	
	def self.update_status
		all_wounds = Wounds.head, Wounds.neck, Wounds.abs, Wounds.lhand, Wounds.rhand, Wounds.larm, Wounds.rarm, Wounds.chest, Wounds.back, Wounds.rleg, Wounds.lleg, Wounds.nerves, Wounds.leye, Wounds.reye, Scars.head, Scars.neck, Scars.abs, Scars.lhand, Scars.rhand, Scars.larm, Scars.rarm, Scars.chest, Scars.back, Scars.rleg, Scars.lleg, Scars.nerves, Scars.leye, Scars.reye
		info = []
		info.push("Injured") if all_wounds.any?{ |i| i > 0 }
		info.push("Prone") if checkprone
		info.push("Poisoned") if checkpoison
		info.push("Diseased") if checkdisease
		info.push("Bleeding") if checkbleeding
		info.push("Stunned") if checkstunned
		info.push("Webbed") if checkwebbed
		info.push("Bound") if checkbound
		info.push("Calmed") if checkcalmed
		info.push("Cut Throat") if checkcutthroat
		info.push("Silenced") if checksilenced
		info.push("Sleeping") if checksleeping
		info = "GREAT!" if info.empty?
		info = "DEAD" if checkdead

		info = info.join(", ") if info.is_a?(Array)
		
		stat_name = "Status"
		if info != @current_stats[stat_name]
			update_label(checkname, stat_name, info)
			@current_stats[stat_name] = info
		end
	end

	def self.update_bounty
		if checkbounty =~ /The local gem dealer, .*, has an order to fill and wants our help./
			info = "Gem NPC"
		elsif checkbounty =~ /received orders from multiple customers requesting [a-zA-Z]+ (.*)\.  You have been tasked to retrieve (\d+) of them./
			info = "#{$2} #{$1}"
		elsif checkbounty =~ /WAIT for [a-zA-Z]+ to meet you there.  You must guarantee [a-zA-Z]+ safety to (.*) as soon as you can/
			info = "Escort #{$1}"
		elsif checkbounty =~ /The local healer, .*, has asked for our aid./
			info = "Herb NPC"
		elsif checkbounty =~ /working on a concoction that requires [a-zA-Z]+ (.*) found (?:on|in|near) (.*).  These samples must be in .* condition.  You have been tasked to retrieve (\d+) samples/
			info = "#{$3} #{$1} #{$2}"
		elsif checkbounty =~ /The local furrier .* has an order to fill and wants our help/
			info = "Skin NPC"
		elsif checkbounty =~ /You have been tasked to retrieve (\d+) (.*) of at least (.*) quality .* You can SKIN them off the corpse of [a-zA-Z]+ (.*) or purchase them from another adventurer./
			info = "#{$1} #{$2}"
		elsif checkbounty =~ /It appears they need your help in tracking down some kind of lost heirloom/
			info = "Heirloom NPC"
		elsif checkbounty =~ /You have been tasked to recover (.*) that an unfortunate citizen lost after being attacked by [a-zA-Z]+ (.*?) (?:on|in|near) (.*)\.  The heirloom .*SEARCH the area until you find it/
			info = "Heirloom Search #{$3}"
		elsif checkbounty =~ /You have been tasked to recover (.*) that an unfortunate citizen lost after being attacked by [a-zA-Z]+ (.*?) (?:on|in|near) (.*)\.  The heirloom .*Hunt down the creature and LOOT the item from its corpse./
			info = "Heirloom #{$1} #{$2} #{$3}"
		elsif checkbounty =~ /You have located .* and should bring it back to/
			info = "Heirloom FOUND"
		elsif checkbounty =~ /It appears that a local resident urgently needs our help in some matter./
			info = "Child NPC"
		elsif checkbounty =~ /A local divinist has had visions of the child fleeing from an? (.*?) (?:on|in|near) (.*)\.  Find the area/
			info = "Find Child #{$1} #{$2}"
		elsif checkbounty =~ /You have made contact with the child/
			info = "Return Child"
		elsif checkbounty =~ /child you were tasked to rescue is gone and your task is failed/
			info = "Child FAILED"
		elsif checkbounty =~ /It appears they have a bandit problem they'd like you to solve.|order to help [a-zA-Z]+ take care of a bandit problem./
			info = "Bandits NPC"
		elsif checkbounty =~ /You have been tasked to suppress bandit activity (?:on|in|near) (.*)\.  You need to kill (\d+).*of them to complete your task./ || checkbounty =~ /You have been tasked to help [a-zA-Z]+ suppress bandit activity (?:on|in|near) (.*)\.  You need to kill (\d+).*of them to complete your task./
			info = "#{$2} Bandits"
		elsif checkbounty =~ /It appears they have a creature problem they'd like you to solve/
			info = "Creatures NPC"
		elsif checkbounty =~ /You have been tasked to suppress (.*) activity (?:on|in|near) (.*)\.  You need to kill (\d+) of them to complete your task./ || checkbounty =~ /suppressing (.*) activity (?:on|in|near) (.*) during .*\.  You need to kill (\d+).*of them to complete your task./ || checkbounty =~ /suppress (.*) activity (?:on|in|near) (.*)\.  You need to kill (\d+).*of them to complete your task./
			info = "#{$3} #{$1}"
		elsif checkbounty =~ /You have been tasked to hunt down and kill a particularly dangerous (.*) that has established a territory (?:on|in|near) (.*)\.  You can get its attention by killing other creatures of the same type in its territory./
			info = "Dangerous #{$1}"
		elsif checkbounty =~ /You have been tasked to hunt down and kill a particularly dangerous (.*) that has established a territory (?:on|in|near) (.*)\.  You have provoked .* attention/
			info = "Dangerous #{$1}"
		elsif checkbounty =~ /to help [a-zA-Z]+ take care of an urgent matter.|to help [a-zA-Z]+ retrieve a lost heirloom|to help [a-zA-Z]+ take care of a creature problem./
			info = "Help NPC"
		elsif checkbounty =~ /You have succeeded in your task and can return to the Adventurer's Guild to receive your reward./
			info = "Finished Guild"
		elsif checkbounty =~ /You succeeded in your task and should report back/
			info = "Finished Guard"
		elsif checkbounty =~ /You are not currently assigned a task./
			info = "None"
		end
		
		stat_name = "Bounty"
		if info != @current_stats[stat_name]
			update_label(checkname, stat_name, info)
			@current_stats[stat_name] = info
		end
	end

	def self.update_room
		info = Room.current.id

		stat_name = "Room #"
		if info != @current_stats[stat_name]
			update_label(checkname, stat_name, info)
			@current_stats[stat_name] = info
		end
	end
	
	def self.update_exp
		$current_field_exp = nil
		$max_field_exp = nil
		$update_field_exp = true
		@silence.call
		wait_until{ $max_field_exp }
		update_stat_values("Field Exp", $current_field_exp, $max_field_exp)
	end
	
	def self.add_log(log, data)
		max_entries = @needed_values["Log Entries"]
		if max_entries > 0
			@logs[log] ||= []
			@logs[log].shift if @logs[log].count >= max_entries
			@logs[log].push(data)
		end
	end
	
	def self.update_log
		current_log = @all_menus["Log Menu"].active_text
		text = @logs[current_log].join("\n")
		@all_labels["Log"].text = text if text
	end
	
	def self.sort_name_list
		new_hash = @clients.sort.to_h
		@current_person = @all_menus["Client Menu"].active_text
		@all_menus["Client Menu"].remove_all
		@all_menus["Client Menu"].append_text("Everyone") if new_hash.count > 0
		new_hash.each{ |name,client| @all_menus["Client Menu"].append_text(name) }
		if !new_hash.include?(@current_person)
			@all_menus["Client Menu"].set_active(0)
		else
			match_menu_item(@all_menus["Client Menu"], @current_person)
		end
		@all_labels["Everyone Connected"].text = "Everyone connected (#{new_hash.count}): #{new_hash.keys.join(", ")}"
	end
	
	def self.match_menu_item(menu, item_needed)
		menu.model.each{ |model, path, iter|
			if item_needed == menu.model.get_value(iter, 0)
				menu.set_active_iter(iter)
				break
			end
		}
	end
	
	def self.start_log_timer
		@timer_id = GLib::Timeout.add(3000){
			update_log
			true
		}
	end
	
	def self.remove_character(menu, name)
		index = 0
		menu.model.each{ |model, path, iter|
			if name == menu.model.get_value(iter, 0)
				menu.remove(index)
				break
			end
			index += 1
		}
	end
	
	before_dying{
		@main_window.close if @main_window
		DownstreamHook.remove("thunder_silence")
		echo "Shutting down server..."
		@clients.each{ |name,client| 
			unless client.closed?
				client.puts "Shut down."
				client.close
			end
		}
		@main_server.close
	}
end

Gtk.queue {
	ThunderMain.create_window
	Gtk.main
}

Thread.new{
	loop{
		wait_until { $update_field_exp }
		$update_field_exp = nil
		put "exp"
	}
}

while line = get
	if line =~ /^t ([a-zA-Z]+) (.*)/i
		person = $1.capitalize
		command = $2
		ThunderMain.command_to_send(person, command)
	elsif line =~ /Field Exp: ([\d,]+)\/([\d,]+)/ && $max_field_exp.nil?
		$current_field_exp = $1.delete(",").to_i
		$max_field_exp = $2.delete(",").to_i
	end
end