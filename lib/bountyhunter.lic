##quiet
## vim: set ft=ruby:
=begin
    ----------------
    SBounty Fork by Alastir

	v3.14.18:
		Fixed foraging tasks in OTF.
			-- layer of onion skin
			-- stem of freesia flower

    Daedeus Features:
      ;bountyhunter load
         - will load the hunter (like bigshot) with parameters
           for current bounty.  Useful if you want to MA bigshot
           with data stored in sbounty
      ;bountyhunter load "monster name"
         - will load the hunter (like bigshot) with parameters
           for the specified monster name

    Previous Updates:
      Dark Elf: will route to Tanzania and Gaedrein in Illistim even if rest_room is in Cysaegir

	  -------------------
    BountyHunter by Alastir (GS4Alastir@gmail.com)

    Does all bounties except gems, escorts, and bandits.
	Gems should be handled via your loot with stockpiling, I suggest using ;gemhoarder

    Feel free to send donations or Gift's of Adventure.

     author: Alastir
       tags: bounty
    version: 1.0

=end

CharSettings[:hunter] ||= 'bountyhunter-explorer'

CharSettings[:enable_cull]      = CharSettings[:enable_cull].nil? ? true : CharSettings[:enable_cull]
CharSettings[:enable_dangerous] = CharSettings[:enable_dangerous].nil? ? true : CharSettings[:enable_dangerous]
CharSettings[:enable_forage]    = CharSettings[:enable_forage].nil? ? true : CharSettings[:enable_forage]
CharSettings[:enable_loot]      = CharSettings[:enable_loot].nil? ? true : CharSettings[:enable_loot]
CharSettings[:enable_rescue]    = CharSettings[:enable_rescue].nil? ? true : CharSettings[:enable_rescue]
CharSettings[:enable_search]    = CharSettings[:enable_search].nil? ? true : CharSettings[:enable_search]
CharSettings[:enable_bandit]    = CharSettings[:enable_bandit].nil? ? false : CharSettings[:enable_bandit]
CharSettings[:enable_skin]      = CharSettings[:enable_skin].nil? ? true : CharSettings[:enable_skin]
CharSettings[:enable_expedite]  = CharSettings[:enable_expedite].nil? ? true : CharSettings[:enable_expedite]

CharSettings[:enable_hunt_complete] = CharSettings[:enable_hunt_complete].nil? ? true : CharSettings[:enable_hunt_complete]

CharSettings[:hunting_scripts]       ||= ['bountyhunter-support']
CharSettings[:enable_bandit_script]  ||= false
CharSettings[:bandit_script]         ||= 'sbounty-bandit-example'
CharSettings[:pre_search_commands]   ||= ['store all']
CharSettings[:post_search_commands]  ||= ['gird']
CharSettings[:forage_retry_delay]    ||= 300
CharSettings[:loot_script]           ||= 'sloot'
CharSettings[:turn_in_percent]       ||= 95
CharSettings[:enable_turn_in_bounty] ||= CharSettings[:enable_turn_in_bounty].nil? ? true : CharSettings[:enable_turn_in_bounty]

CharSettings[:should_hunt_mind]    ||= 60
CharSettings[:should_hunt_mana]    ||= 75
CharSettings[:should_hunt_spirit]  ||= 8
CharSettings[:hunt_pre_commands]   ||= ['gird']
CharSettings[:should_rest_mind]    ||= 100
CharSettings[:should_rest_mana]    ||= 0
CharSettings[:should_rest_encum]   ||= 20
CharSettings[:should_rest_wounded] ||= StringProc.new('bleeding? || percenthealth <= 50 || ([Wounds.head, Scars.head].max >= 2) || ([Wounds.nsys, Scars.nsys].max >= 2) || ([Wounds.leftArm, Wounds.leftHand, Wounds.rightArm, Wounds.rightHand, Scars.leftArm, Scars.leftHand, Scars.rightArm, Scars.rightHand].max >= 3) || ( ([Wounds.leftArm, Wounds.leftHand, Scars.leftArm, Scars.leftHand].max >= 2) or ([Wounds.rightArm, Wounds.rightHand, Scars.leftArm, Scars.leftHand].max >= 2) )')
#CharSettings[:should_rest_wounded] ||= StringProc.new('bleeding? || percenthealth <= 75 || [Wounds.nsys, Wounds.limbs, Wounds.neck, Wounds.head, Wounds.leftEye, Wounds.rightEye].max > 1')

CharSettings[:rest_in_commands]    ||= ['go table, sit']
CharSettings[:rest_out_commands]   ||= ['stand', 'out']
CharSettings[:rest_pre_commands]   ||= ['store all']
CharSettings[:rest_scripts]        ||= ['waggle']
CharSettings[:rest_sleep_interval] ||= 30

CharSettings[:locations] ||= {}

$sbounty_rest        = false
$sbounty_rest_reason = nil
in_rest_area         = false
rest_reason          = nil
hunt_reason          = nil
can_do_bounty_cache  = nil
expedite_left        = true
last_forage_attempt  = 0
last_forage_delay    = 300
first_run            = true
$mount_active         = false

if UserVars.lootsack.nil? or UserVars.lootsack.empty?
    echo '** lootsack has not been set, set it with ;set change lootsack [container]'
    exit
end

if CharSettings[:enable_skin] and (UserVars.skinsack.nil? or UserVars.skinsack.empty?)
    echo '** skinsack has not been set, set it with ;set change skinsack [container]'
    exit
end

lootsack = GameObj.inv.find { |i| i.noun =~ /#{UserVars.lootsack}/ } or GameObj.inv.find { |i| i.name =~ /#{UserVars.lootsack}/ }
skinsack = GameObj.inv.find { |i| i.noun =~ /#{UserVars.skinsack}/ } or GameObj.inv.find { |i| i.name =~ /#{UserVars.lootsack}/ }

if lootsack.nil?
    echo '** failed to find your lootsack, set it with ;set change lootsack [container]'
    exit
end

if CharSettings[:enable_skin] and skinsack.nil?
    echo '** failed to find your skinsack, set it with ;set change skinsack [container]'
    exit
end

bounty_patterns = {
    'none' => '^You are not currently assigned a task\.',

	#HELP
    'help_bandit'    => 'It appears they have a bandit problem',
    'help_creature'  => 'It appears they have a creature problem they\'d like you to solve\.',
    'help_resident'  => 'It appears that a local resident urgently needs our help in some matter\.',
    'help_heirloom'  => 'It appears they need your help in tracking down some kind of lost heirloom\.',
    'help_gemdealer' => 'The local gem dealer, .*, has an order to fill and wants our help\.',
    'help_herbalist' => 'local herbalist|local healer|local alchemist',
    'help_furrier'   => 'The local furrier',

    # in progress
    'task_bandit'    => '^You have been tasked to suppress bandit activity (?:in|on|near) (?:the )?(.*)\s(?:near|between|under|\.)',
    'task_dangerous' => 'You have been tasked to hunt down and kill a particularly dangerous (.*) that has established a territory (?:in|on|near) (?:the )?(.*)(?:\s(?:near|between|under)|\.)\s+You can',
    'task_provoked'  => 'You have been tasked to hunt down and kill a particularly dangerous (.*) that has established a territory (?:in|on|near) (?:the )?(.*)(?:\s(?:near|between|under)|\.)\s+You have provoked',
    'task_rescue'    => 'A local divinist has had visions of the child fleeing from (?:a|an) (.*) (?:in|on) (?:the )?(.*) (?:near|between|under)',
    'task_escort'    => '^You have made contact with the child',
    'task_cull'      => 'You have been tasked to(?: help \w*)?(?: (?:retrieve an heirloom|kill a dangerous creature|rescue a missing child) by)? suppress(?:ing)? (.*) activity (?:in|on) (?:the )?(.*)(?:\s(?:near|between|under)|\.)',

	'task_search'    => 'unfortunate citizen lost after being attacked by (?:a|an) (.*?) (?:in|on|near) (?:the )?(.*?)\s?(?:near|between|under|\.  The).*SEARCH',
#	'task_search'    => 'unfortunate citizen lost after being attacked by (?:a|an) (.*) (?:in|on|near) (.*\'.*).  The',
#	'task_search'    => 'unfortunate citizen lost after being attacked by (?:a|an) (.*) (?:in|on|near) (?:the )?(.?)\s?(?:near|between|under|.  The).*SEARCH',

	'task_heirloom'  => 'unfortunate citizen lost after being attacked by (?:a|an) (.*?) (?:in|on|near) (?:the )?(.*?)\s?(?:near|between|under|\.  The).*LOOT',
#	'task_heirloom'  => 'unfortunate citizen lost after being attacked by (?:a|an) (?<creature>.*?) (?:in|on|around|near|by) (?<area>.*?)(| near (?<real>.*?))\.*LOOT',

    'task_found'     => 'You have located .* and should bring it back',

    'task_dealer'    => '^The(?: local)? gem dealer',
    'task_forage'    => 'concoction that requires (?:a|an|some) (.*) found (?:in|on|near) (?:the )?(.*?)(?: near| between| under|\.).*These samples must be in pristine condition\.\s+You have been tasked to retrieve (\d+) (?:more )?samples?\.',
    'task_skin'      => '^You have been tasked to retrieve (\d+|\w+)s? (.*) of at least .*\.  You can SKIN them off the corpse of (?:a|an) (.*) or ',

    # fail
    'fail_child' => 'The child you were tasked to rescue is gone and your task is failed\.',

    # success
    'success'          => '^You have succeeded in your task and can return',
    'success_guard'    => '^You succeeded in your task and should report back to',
    'success_heirloom' => '^You have located (?:a|an|some) (.*) and should bring it back .*\.$'
   #'success_heirloom' => '^You have located an? (.*) and should bring it back .*\.$',
}

setup = proc {
    script_name = script.name

    action   = nil
    window   = nil
    notebook = nil

    locations = CharSettings[:locations].dup
    location  = nil

    error = proc { |msg|
        dlg = Gtk::Dialog.new(
            'Error!',
            window,
            Gtk::Dialog::DESTROY_WITH_PARENT,
            [ Gtk::Stock::OK, Gtk::Dialog::RESPONSE_NONE ]
        )
        dlg.resize 200,100
        dlg.signal_connect 'response' do dlg.destroy end
        dlg.vbox.add(Gtk::Label.new(msg))
        dlg.show_all
    }

    widgets = {
        :gui_widgets => {
            # buttons
            :close  => Gtk::Button.new('Close'),
            :create => Gtk::Button.new('Create'),
            :delete => Gtk::Button.new('Delete'),
            :save   => Gtk::Button.new('Save & Close'),

            # combos
            :locations => Gtk::ComboBox.new,

            # entries
            :new_name => Gtk::Entry.new,
        },

        :location_widgets => {
            # check buttons
            :enable_bounty_only      => Gtk::CheckButton.new('Only attack bouny critters'),
            :enable_hunting_rotation => Gtk::CheckButton.new('In hunting rotation'),
            :enable_search_only      => Gtk::CheckButton.new('Only search here (no hunting)'),

            #entries
            :location   => Gtk::Entry.new,
            :skins      => Gtk::Entry.new,
            :targets    => Gtk::Entry.new,
            :room       => Gtk::Entry.new,
            :boundaries => Gtk::Entry.new,
        },

        # check buttons
        :enable_cull          => Gtk::CheckButton.new('Cull critters').set_active(CharSettings[:enable_cull]),
        :enable_dangerous     => Gtk::CheckButton.new('Dangerous critter').set_active(CharSettings[:enable_dangerous]),
        :enable_forage        => Gtk::CheckButton.new('Forage herbs').set_active(CharSettings[:enable_forage]),
        :enable_loot          => Gtk::CheckButton.new('Loot heirloom').set_active(CharSettings[:enable_loot]),
        :enable_rescue        => Gtk::CheckButton.new('Rescue child').set_active(CharSettings[:enable_rescue]),
        :enable_search        => Gtk::CheckButton.new('Search heirloom').set_active(CharSettings[:enable_search]),
        :enable_bandit        => Gtk::CheckButton.new('Bandits').set_active(CharSettings[:enable_bandit]),
        :enable_skin          => Gtk::CheckButton.new('Skin critters').set_active(CharSettings[:enable_skin]),
        :enable_expedite      => Gtk::CheckButton.new('Expedite bounties').set_active(CharSettings[:enable_expedite]),
        :enable_bandit_script => Gtk::CheckButton.new('Use bandit script').set_active(CharSettings[:enable_bandit_script]),
        :enable_hunt_complete => Gtk::CheckButton.new('Hunt until complete?').set_active(CharSettings[:enable_hunt_complete]),
        :enable_turn_in_bounty => Gtk::CheckButton.new('Force turn in if new bounty').set_active(CharSettings[:enable_turn_in_bounty]),

        # entries
        :hunting_scripts      => Gtk::Entry.new.set_text(CharSettings[:hunting_scripts].collect { |a| a.strip }.join(',')),
        :bandit_script        => Gtk::Entry.new.set_text(CharSettings[:bandit_script]),
        :pre_search_commands  => Gtk::Entry.new.set_text(CharSettings[:pre_search_commands].collect { |a| a.strip }.join(',')),
        :post_search_commands => Gtk::Entry.new.set_text(CharSettings[:post_search_commands].collect { |a| a.strip }.join(',')),
        :forage_retry_delay   => Gtk::Entry.new.set_text(CharSettings[:forage_retry_delay].to_s),
        :loot_script          => Gtk::Entry.new.set_text(CharSettings[:loot_script].to_s),
        :turn_in_percent      => Gtk::Entry.new.set_text(CharSettings[:turn_in_percent].to_s),

        :should_hunt_mind   => Gtk::Entry.new.set_text(CharSettings[:should_hunt_mind].to_s),
        :should_hunt_mana   => Gtk::Entry.new.set_text(CharSettings[:should_hunt_mana].to_s),
        :should_hunt_spirit => Gtk::Entry.new.set_text(CharSettings[:should_hunt_spirit].to_s),

        :hunt_pre_commands => Gtk::Entry.new.set_text(CharSettings[:hunt_pre_commands].collect { |a| a.strip }.join(',')),
        :hunt_commands_a   => Gtk::Entry.new.set_text(CharSettings[:hunt_commands_a].collect { |a| a.strip }.join(',')),
        :hunt_commands_b   => Gtk::Entry.new.set_text(CharSettings[:hunt_commands_b].collect { |a| a.strip }.join(',')),
        :hunt_commands_c   => Gtk::Entry.new.set_text(CharSettings[:hunt_commands_c].collect { |a| a.strip }.join(',')),

        :should_rest_mana    => Gtk::Entry.new.set_text(CharSettings[:should_rest_mana].to_s),
        :should_rest_mind    => Gtk::Entry.new.set_text(CharSettings[:should_rest_mind].to_s),
        :should_rest_encum   => Gtk::Entry.new.set_text(CharSettings[:should_rest_encum].to_s),
        :should_rest_wounded => Gtk::Entry.new.set_text(CharSettings[:should_rest_wounded]._dump),

        :rest_in_commands  => Gtk::Entry.new.set_text(CharSettings[:rest_in_commands].collect { |a| a.strip }.join(',')),
        :rest_out_commands => Gtk::Entry.new.set_text(CharSettings[:rest_out_commands].collect { |a| a.strip }.join(',')),
        :rest_pre_commands => Gtk::Entry.new.set_text(CharSettings[:rest_pre_commands].collect { |a| a.strip }.join(',')),
        :rest_room         => Gtk::Entry.new.set_text(CharSettings[:rest_room]),
        :rest_scripts      => Gtk::Entry.new.set_text(CharSettings[:rest_scripts].collect { |a| a.strip }.join(','))
    }

    Gtk.queue {
        update_disabled = proc {
            widgets[:location_widgets].each { |key, widget|
                if location.nil?
                    widget.set_sensitive(false)
                else
                    widget.set_sensitive(true)
                end
            }
        }

        populate_locations = proc {
            loop {
                break if not widgets[:gui_widgets][:locations].model.iter_first
                widgets[:gui_widgets][:locations].remove_text(0)
            }

            locations.keys.sort.each { |text|
                widgets[:gui_widgets][:locations].append_text(text)
            }
        }

        save_location = proc {
            widgets[:location_widgets].each { |key, widget|
                if widget.class == Gtk::CheckButton
                    value = widget.active?
                elsif [:skins, :targets, :boundaries].include?(key)
                    value = widget.text.strip.split(',').collect { |item| item.strip }
                else
                    value = widget.text.strip
                end

                locations[location][key] = value
            }
        }

        attach_signals = proc {
            widgets[:gui_widgets][:close].signal_connect 'clicked' do action = :close end
            widgets[:gui_widgets][:save].signal_connect 'clicked' do action = :save; save_location.call end

            widgets[:gui_widgets][:create].signal_connect 'clicked' do
                name = widgets[:gui_widgets][:new_name].text.strip

                if name.nil? or name.empty? or name.length < 3
                    error.call 'You need to enter a name!'
                elsif locations.keys.find { |n| n.downcase.strip == name.downcase.strip }
                    error.call 'A location with that name already exists!'
                else
                    locations[name] = {}

                    widgets[:gui_widgets][:new_name].set_text ""

                    populate_locations.call
                    update_disabled.call
                end
            end

            widgets[:gui_widgets][:delete].signal_connect 'clicked' do
                Gtk.queue {
                    if widgets[:gui_widgets][:locations].active == -1
                        error.call 'You do not have a location selected!'
                    else
                        locations.delete(widgets[:gui_widgets][:locations].active_text)
                        widgets[:gui_widgets][:locations].remove_text(widgets[:gui_widgets][:locations].active)

                        widgets[:location_widgets].each { |key, widget|
                            if widget.class == Gtk::CheckButton
                                widget.set_active(false)
                            else
                                widget.set_text("")
                            end
                        }
                    end
                }
            end

            widgets[:gui_widgets][:locations].signal_connect 'changed' do
                Gtk.queue {
                    save_location.call

                    location = widgets[:gui_widgets][:locations].active_text

                    if locations[location]
                        widgets[:location_widgets].each { |key, widget|
                            if widget.class == Gtk::CheckButton
                                widget.set_active(!!locations[location][key])
                            elsif [:skins, :targets, :boundaries].include?(key)
                                widget.set_text(locations[location][key].join(','))
                            else
                                widget.set_text(locations[location][key].strip)
                            end
                        }
                    end

                    update_disabled.call
                }
            end
        }

        # main window
        window = Gtk::Window.new
        window.border_width = 5
        window.keep_above = true
        window.resizable = true
        window.resize 500, 300
        window.set_window_position Gtk::Window::POS_CENTER

        # main notebook (tabs)
        notebook = Gtk::Notebook.new
        notebook.show_border = true

        vbox_main = Gtk::VBox.new
        vbox_main.pack_start notebook

        # sbounty options
        vbox = Gtk::VBox.new

        frm = Gtk::Frame.new('Locations').set_border_width(3)
        tbl = Gtk::Table.new(7, 4, true).set_border_width(3)

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('New name: ')), 0, 1, 0, 1
        tbl.attach widgets[:gui_widgets][:new_name], 1, 3, 0, 1
        tbl.attach widgets[:gui_widgets][:create], 3, 4, 0, 1

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Locations: ')), 0, 1, 1, 2
        tbl.attach widgets[:gui_widgets][:locations], 1, 3, 1, 2
        tbl.attach widgets[:gui_widgets][:delete], 3, 4, 1, 2

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Location: ')), 0, 1, 3, 4
        tbl.attach widgets[:location_widgets][:location], 1, 2, 3, 4
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Skins: ')), 2, 3, 3, 4
        tbl.attach widgets[:location_widgets][:skins], 3, 4, 3, 4

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Targets: ')), 0, 1, 4, 5
        tbl.attach widgets[:location_widgets][:targets], 1, 2, 4, 5

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Room #: ')), 0, 1, 5, 6
        tbl.attach widgets[:location_widgets][:room], 1, 2, 5, 6
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Boundaries: ')), 2, 3, 5, 6
        tbl.attach widgets[:location_widgets][:boundaries], 3, 4, 5, 6

        tbl.attach widgets[:location_widgets][:enable_hunting_rotation], 0, 1, 6, 7
        tbl.attach widgets[:location_widgets][:enable_bounty_only], 1, 2, 6, 7
        tbl.attach widgets[:location_widgets][:enable_search_only], 2, 3, 6, 7

        frm.add(tbl)
        vbox.pack_start(frm)

        frm = Gtk::Frame.new('Bounties').set_border_width(3)
        tbl = Gtk::Table.new(5, 4, true).set_border_width(3)

        tbl.attach widgets[:enable_cull], 0, 1, 0, 1
        tbl.attach widgets[:enable_dangerous], 1, 2, 0, 1
        tbl.attach widgets[:enable_rescue], 2, 3, 0, 1
        tbl.attach widgets[:enable_skin], 3, 4, 0, 1

        tbl.attach widgets[:enable_loot], 0, 1, 1, 2
        tbl.attach widgets[:enable_search], 1, 2, 1, 2
        tbl.attach widgets[:enable_forage], 2, 3, 1, 2
        tbl.attach widgets[:enable_bandit], 3, 4, 1, 2

        tbl.attach widgets[:enable_bandit_script], 1, 2, 2, 3
        tbl.attach widgets[:enable_expedite], 2, 3, 2, 3
        tbl.attach widgets[:enable_hunt_complete], 3, 4, 2, 3

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('turn in when mind >= ')), 0, 1, 3, 4
        tbl.attach widgets[:turn_in_percent], 1, 2, 3, 4
        tbl.attach widgets[:enable_turn_in_bounty], 3, 4, 3, 4

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('hunting scripts:')), 2, 3, 4, 5
        tbl.attach widgets[:hunting_scripts], 3, 4, 4, 5
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('bandit script:')), 0, 1, 4, 5
        tbl.attach widgets[:bandit_script], 1, 2, 4, 5

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('pre-search commands: ')), 0, 1, 5, 6
        tbl.attach widgets[:pre_search_commands], 1, 2, 5, 6
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('post-search commands: ')), 2, 3, 5, 6
        tbl.attach widgets[:post_search_commands], 3, 4, 5, 6

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('forage retry delay: ')), 0, 1, 6, 7
        tbl.attach widgets[:forage_retry_delay], 1, 2, 6, 7
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('loot script: ')), 2, 3, 6, 7
        tbl.attach widgets[:loot_script], 3, 4, 6, 7

        frm.add(tbl)
        vbox.pack_start(frm)

        notebook.append_page vbox, Gtk::Label.new('Locations / Options')

        # default options
        vbox = Gtk::VBox.new

        frm = Gtk::Frame.new('Should Rest').set_border_width(3)
        tbl = Gtk::Table.new(3, 4, true).set_border_width(3)

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('when mind % >= ')), 0, 1, 0, 1
        tbl.attach widgets[:should_rest_mind], 1, 2, 0, 1
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('or mana <= ')), 2, 3, 0, 1
        tbl.attach widgets[:should_rest_mana], 3, 4, 0, 1

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('or encumbrance % >= ')), 0, 1, 1, 2
        tbl.attach widgets[:should_rest_encum], 1, 2, 1, 2

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('or wounded eval: ')), 0, 1, 2, 3
        tbl.attach widgets[:should_rest_wounded], 1, 4, 2, 3

        frm.add(tbl)
        vbox.pack_start(frm)

        frm = Gtk::Frame.new('Resting').set_border_width(3)
        tbl = Gtk::Table.new(2, 4, true).set_border_width(3)

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('room #: ')), 0, 1, 0, 1
        tbl.attach widgets[:rest_room], 1, 2, 0, 1
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('pre-rest commands: ')), 2, 3, 0, 1
        tbl.attach widgets[:rest_pre_commands], 3, 4, 0, 1

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('enter commands: ')), 0, 1, 1, 2
        tbl.attach widgets[:rest_in_commands], 1, 2, 1, 2
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('exit commands: ')), 2, 3, 1, 2
        tbl.attach widgets[:rest_out_commands], 3, 4, 1, 2

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('scripts: ')), 0, 1, 2, 3
        tbl.attach widgets[:rest_scripts], 1, 4, 2, 3

        frm.add(tbl)
        vbox.pack_start(frm)

        frm = Gtk::Frame.new('Should Hunt').set_border_width(3)
        tbl = Gtk::Table.new(2, 4, true).set_border_width(3)

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('when mind % <= ')), 0, 1, 0, 1
        tbl.attach widgets[:should_hunt_mind], 1, 2, 0, 1
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('and mana >= ')), 2, 3, 0, 1
        tbl.attach widgets[:should_hunt_mana], 3, 4, 0, 1

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('and spirit >= ')), 0, 1, 1, 2
        tbl.attach widgets[:should_hunt_spirit], 1, 2, 1, 2

        frm.add(tbl)
        vbox.pack_start(frm)

        frm = Gtk::Frame.new('Hunting').set_border_width(3)
        tbl = Gtk::Table.new(2, 4, true).set_border_width(3)

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Pre-hunt commands: ')), 0, 1, 0, 1
        tbl.attach widgets[:hunt_pre_commands], 1, 2, 0, 1
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Commands (a): ')), 2, 3, 0, 1
        tbl.attach widgets[:hunt_commands_a], 3, 4, 0, 1

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Commands (b): ')), 0, 1, 1, 2
        tbl.attach widgets[:hunt_commands_b], 1, 2, 1, 2
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Commands (c): ')), 2, 3, 1, 2
        tbl.attach widgets[:hunt_commands_c], 3, 4, 1, 2

        frm.add(tbl)
        vbox.pack_start(frm)

        notebook.append_page vbox, Gtk::Label.new('Resting / Hunting')

        # main window widgets
        vbox = Gtk::VBox.new
        vbox.pack_start Gtk::Alignment.new(0, 1, 0, 0), false

        hbox = Gtk::HBox.new
        hbox.add widgets[:gui_widgets][:save]
        hbox.add widgets[:gui_widgets][:close]

        halign = Gtk::Alignment.new 1, 0, 0, 0
        halign.add hbox

        vbox.pack_start halign
        vbox_main.pack_start vbox

        # create the window
        attach_signals.call
        update_disabled.call
        populate_locations.call

        window.add vbox_main
        window.show_all
    }

    before_dying { Gtk.queue { window.destroy unless window.nil? } }

    sleep 0.10 while action.nil?

    case action
        when :save
            CharSettings[:locations] = locations

            widgets.each { |key, widget|
                next if [:location_widgets, :gui_widgets].include?(key)

                if widget.class == Gtk::CheckButton
                    value = widget.active?
                elsif [:hunting_scripts, :pre_search_commands, :post_search_commands, :hunt_pre_commands, :hunt_commands_a, :hunt_commands_b, :hunt_commands_c, :rest_in_commands, :rest_out_commands, :rest_pre_commands, :rest_scripts].include?(key)
                    value = widget.text.strip.split(',').collect { |item| item.strip }
                elsif key == :should_rest_wounded
                    value = StringProc.new widget.text.strip
                else
                    value = widget.text.strip
                end

                CharSettings[key] = value
            }
    end
}

error = proc { |msg|
    echo "** #{msg}"
    exit
}

print = proc { |msg|
    echo "-- #{msg}"
}

clean_skin = proc { |name|
    name.strip.downcase.gsub(/s$/, '').gsub(/teeth/, 'tooth').gsub(/hooves?/, 'hoof')
}

has_skins = proc {
    if bounty? =~ /#{bounty_patterns['task_skin']}/
        count = $1.to_i
        skin  = $2.downcase

        skinsack.contents.find_all { |item| item.name =~ /#{clean_skin.call(skin)}/i }.size >= (count + 3)
    else
        false
    end
}

is_bounty = proc { |types|
    result = []
	if types.class != Array
		types = [types]
	end
    types.each { |type| result.push(bounty_patterns[type]) if not bounty_patterns[type].nil? }

    !(bounty? =~ /#{result.join('|')}/).nil?
}

get_bounty_location = proc { |location,target|
    if location.nil?
        location = target = nil

        # remove search only locations for hunting areas
        locations = CharSettings[:locations].dup
        if is_bounty.call ['task_skin', 'task_heirloom', 'task_dangerous', 'task_cull', 'task_rescue']
            locations.delete_if { |name, data| data[:enable_search_only] }
        end

        if bounty? =~ /#{bounty_patterns['task_skin']}/
            # remember: don't swap the order or the global $ vars are lost!
            target   = $3.strip.downcase
            skin     = clean_skin.call($2)
            location = locations.find { |name, data| $SBOUNTY_CLEAN_TARGETS.call(data[:targets]).find { |t| target =~ /#{t}/i } and data[:skins].find { |s| skin =~ /#{s.strip.downcase}/i }}
        else
            bounty_patterns.each { |key,value|
                if bounty? =~ /#{value}/i
                    target   = $1
                    location = $2
                    #echo "#{$1} - #{$2}" #if key == "task_provoked"
                    break
                end
            }

            location = location.downcase.strip
            location = locations.find { |name, data|
                cleaned = $SBOUNTY_CLEAN_TARGETS.call(data[:targets])
                location =~ /#{data[:location].strip}/i and cleaned.find {
                    |t| target =~ /#{t}/i
                }
            }
        end
    end

    if location
        name = location[0].dup
        data = location[1].to_hash.dup

        if target
            targets = data[:targets].dup
            cleaned = $SBOUNTY_CLEAN_TARGETS.call(data[:targets])
            target_key = nil

            # see if they have a provoked ancient/grizzled line
            if is_bounty.call 'task_provoked'
                target_key = cleaned.find { |t|
                    t =~ /ancient|grizzled/ and (
                        "ancient #{target}" =~ /#{t}/i or
                        "grizzled #{target}" =~ /#{t}/i
                    )
                }
            end

            # regular bounties
            if target_key.nil?
                target_key = cleaned.find { |t| target =~ /#{t}/i }
            end

            index = cleaned.index(target_key)
            target = targets[index]

            if is_bounty.call 'task_provoked'
                # add the ancient|grizzled for them
                if target !~ /ancient|grizzled/i
                    new_target = target.gsub(cleaned[index], "(?:ancient|grizzled).*#{cleaned[index]}")
                    targets[target.index(target)] = new_target
                    target = new_target
                end
            end
        end

        if data[:enable_bounty_only]
            targets = [ target ]
        end

        data[:targets] = targets

        [name, data]
    else
        print.call 'could not find bounty location'
        nil
    end
}

get_herb_rooms = proc { |location, herb|
    target_list = Array.new
    names = [herb]

    if herb == 'ayana leaf'
        names = [herb, 'ayana leaf', 'ayana lichen', 'ayana weed', 'ayana berry', 'ayana root']
    elsif herb == "ayana'al leaf"
        names = [herb, 'ayana\'al leaf', 'ayana\'al lichen', 'ayana\'al weed', 'ayana\'al berry', 'ayana\'al root']
	elsif herb == "small primrose"
		names = [herb, 'small primrose']
    end

    Room.list.each { |room|
		if room.tags.find { |tag| names.find { |name| name =~ /#{Regexp.escape(tag)}/i } }
        #if room.tags.find { |tag| names.find { |name| name =~ /#{tag}/i } }
            target_list.push(room.id)
        end
    }
    previous, shortest_distances = Map.dijkstra(Room.current.id)

    if location
        # delete the room if it's not the correct location
        target_list.delete_if { |room_num|
            if Room[room_num].location.nil?
                Room[room_num].title[0] !~ /#{location}/i
            elsif not Room[room_num].location.nil?
                Room[room_num].location !~ /#{location}/i
            else
                false
            end
        }
    end

    if target_list.length == 0
        similar = Room.tags.find_all { |tag| tag =~ /#{herb}/i }

        if not similar.empty?
            herb = similar.join(', ')
            Room.list.each { |room| target_list.push(room.id) if room.tags.include?(herb) }

            previous, shortest_distances = Map.dijkstra(Room.current.id)

            if location
                target_list.delete_if { |room_num| (Room[room_num].location == nil && Room[room_num].title[0] !~ /#{location}/i) }
                target_list.delete_if { |room_num| (Room[room_num].location != nil && Room[room_num].location !~ /#{location}/i) }
            end
        end
    end

    previous, shortest_distances = Map.dijkstra(CharSettings[:rest_room])
    target_list.delete_if { |room| shortest_distances[room].nil? or shortest_distances[room] > 600 }
}

can_turn_in = proc {
    is_bounty.call ['success', 'success_guard', 'success_heirloom'] and (
        CharSettings[:turn_in_percent].nil? or
        CharSettings[:enable_turn_in_bounty] and not Spell['Next Bounty'].active? or
        percentmind >= CharSettings[:turn_in_percent].to_i and checkmind !~ /saturated/
    )
}

can_do_bounty = proc {
    if not can_do_bounty_cache.nil?
        ; # intentionally left blank
    elsif is_bounty.call ['success', 'success_heirloom', 'success_guard']
        can_do_bounty_cache = true
    elsif is_bounty.call ['task_bandit'] and CharSettings[:enable_bandit]
        can_do_bounty_cache = true
    elsif ((is_bounty.call 'task_search' and CharSettings[:enable_search] and get_bounty_location.call) or (is_bounty.call 'task_heirloom' and CharSettings[:enable_loot] and get_bounty_location.call))
        can_do_bounty_cache = true
    elsif bounty? =~ /#{bounty_patterns['task_forage']}/ and CharSettings[:enable_forage] and not get_herb_rooms.call($2, $1).empty?
        can_do_bounty_cache = true
        # and bounty? !~ /exceptional|outstanding|superb|magnificent/
    elsif is_bounty.call 'task_skin' and CharSettings[:enable_skin] and get_bounty_location.call
        can_do_bounty_cache = true
    elsif is_bounty.call ['task_provoked', 'task_dangerous'] and CharSettings[:enable_dangerous] and get_bounty_location.call
        can_do_bounty_cache = true
    elsif is_bounty.call 'task_cull' and CharSettings[:enable_cull] and get_bounty_location.call
        can_do_bounty_cache = true
    elsif (is_bounty.call 'task_escort' and CharSettings[:enable_rescue]) or (is_bounty.call 'task_rescue' and CharSettings[:enable_rescue] and get_bounty_location.call)
        can_do_bounty_cache = true
    else
        can_do_bounty_cache = false
    end

    $sbounty_can_do_bounty = can_do_bounty_cache

    can_do_bounty_cache
}

should_hunt = proc {
	res = false

	if is_bounty.call ['success', 'success_heirloom', 'success_guard'] and not can_turn_in.call
		res = true
    # on start if less than numb then always try to do bounty
	#ADDED-CURRENT-START
	#elsif (can_do_bounty.call and not fried? and not saturated? and first_run)
	#ADDED-CURRENT-END
	elsif (can_do_bounty.call and percentmind > CharSettings[:should_hunt_mind].to_i and not saturated? and first_run)
        res = true
    elsif (not can_do_bounty.call or is_bounty.call ['success', 'success_heirloom', 'success_guard'] or not CharSettings[:enable_hunt_complete]) and percentmind > CharSettings[:should_hunt_mind].to_i
        hunt_reason = 'mind not clear enough'
        ;
    elsif not checkmana(CharSettings[:should_hunt_mana].to_i)
        hunt_reason = 'out of mana'
        ;
    elsif not checkspirit(CharSettings[:should_hunt_spirit].to_i)
        hunt_reason = 'low spirit'
        ;
    else
        res = true
    end

	res
}

should_rest = proc {
    if CharSettings[:should_rest_wounded].call
        rest_reason = 'wounded'
        true
    elsif $sbounty_rest
        if $sbounty_rest_reason
            rest_reason = $sbounty_rest_reason
        else
            rest_reason = '$sbounty_rest was set'
        end

        if $sbounty_rest_until and Time.now.to_i > $sbounty_rest_until
            $sbounty_rest        = false
            $sbounty_rest_reason = nil
            $sbounty_rest_until  = nil
        end

        true
    elsif not checkmana(CharSettings[:should_rest_mana].to_i)
        rest_reason = 'out of mana'
        true
    elsif checkencumbrance(CharSettings[:should_rest_encum].to_i)
        rest_reason = 'encumbered'
        true
    elsif is_bounty.call 'task_provoked'
        false
    elsif is_bounty.call 'task_forage' and can_do_bounty.call and Time.now.to_i < last_forage_attempt + last_forage_delay and percentmind >= CharSettings[:should_rest_mind].to_i
        rest_reason = 'mind is full (waiting on foraging cooldown)'
        true
    elsif ((not can_turn_in.call and is_bounty.call ['success', 'success_guard', 'success_heirloom']) or not can_do_bounty.call or not CharSettings[:enable_hunt_complete]) and percentmind >= CharSettings[:should_rest_mind].to_i
        rest_reason = 'mind is full'
        true
    else
        rest_reason = nil
        false
    end
}

wander = proc { |boundaries|
	room = Room.current
	next_room_options = room.wayto.keys - boundaries
	next_room_options.delete_if { |room_id| (room.timeto[room_id].class == Proc) and room.timeto[room_id].call.nil? }
	next_room = next_room_options.find_all { |r| not $sbounty_wander_rooms.include?(r) }
	if next_room.empty?
		next_room = $sbounty_wander_rooms.find { |r| next_room_options.include?(r) }
	else
		next_room = next_room[rand(next_room.length)]
	end
	$sbounty_wander_rooms.delete(next_room)
	$sbounty_wander_rooms.push(next_room)
	way = room.wayto[next_room]
	if way.class == String
		move(way)
	else
		way.call
	end
}






######################################################################################

#My personal additions to add in teleportation.

def teleport_to_willow
	pause_script("go2") if Script.running?("go2")
	if Char.name =~ /Alastir/
		waitrt?
		fput "twist my #{Vars.teleporter} to 0"
		fput "rub my #{Vars.teleporter}"
		sleep 0.1
	elsif Char.name =~ /Erykk/
		waitrt?
		fput "twist my #{Vars.teleporter} to 0"
		fput "rub my #{Vars.teleporter}"
		sleep 0.1
	elsif Char.name =~ /Devereux/
		waitrt?
		sleep 0.1
	end
	kill_script("go2") if Script.running?("go2")
end

def leave_OTF
	pause_script("go2") if Script.running?("go2")
	if Char.name =~ /Alastir/
		if $mount_active == true
			start_script "go2", ['11968']
			wait_while { running? 'go2' }
				fput "store all"
				fput "get my reins"
				fput "wave my reins"
				mount_count = 0
				loop {
					result = dothistimeout "mount stallion", 15, /You cannot do that while you're in combat.|You affix your reins to a muscular white stallion's bit/
					if result =~ /You cannot do that while you're in combat./
						sleep 1
						mount_count += 1
						#fput "mount stallion"
					elsif result =~ /You affix your reins to a muscular white stallion's bit/
#						respond "#{mount_count}"
						break
					end
				}
				fput "mount travel return"
				fput "mount travel return"
				waitfor "You ease the reins of your white stallion as you canter toward your destination."
				fput "dismount"
				fput "dismiss stallion"
				fput "put my reins in my #{Vars.keepsack}"
				$mount_active = false
		else
			waitrt?
			fput "twist my #{Vars.teleporter} to 3"
			fput "rub my #{Vars.teleporter}"
			waitfor "Ta'Faendryl Approach"
				kill_script("go2") if Script.running?("go2")
				wait_while { running? 'go2' }
				start_script "go2", ['10835']
					waitfor "Gyldemar Road, Sentinels"
					teleport_to_willow
		end
	elsif Char.name =~ /Erykk|Gromsph/
		waitrt?
		fput "twist my #{Vars.teleporter} to 3"
		fput "rub my #{Vars.teleporter}"
		waitfor "Ta'Faendryl Approach"
			kill_script("go2") if Script.running?("go2")
			wait_while { running? 'go2' }
			start_script "go2", ['10835']
				waitfor "Gyldemar Road, Sentinels"
				teleport_to_willow
	elsif Char.name =~ /Devereux/
		waitrt?
		sleep 0.1
	end
	kill_script("go2") if Script.running?("go2")
end

def go2_willow
	if Char.name =~ /Alastir|Devereux|Erykk/
		if checkarea =~ /Old Ta'Faendryl|Tiny Cottage|Cottage Garden|Lake/
			leave_OTF
		elsif checkarea =~ /Whistler's Pass|Sylvarraend Road|Gyldemar Road/
			teleport_to_willow
		end
	end
end

def go2_willow_rest
	if Char.name =~ /Alastir/
		#							#Bank					   #Gemshop				  	 #Furrier				   #Herbalist
		if checkarea =~ /Ta'Illistim|United Bank of City-States|Tanzania's Gems & Jewelry|Gaedrein's Furs and Pelts|Valina's Herbs and Tinctures/i
			teleport_to_willow
		elsif checkarea =~ /Old Ta'Faendryl|Tiny Cottage|Cottage Garden|Lake/
			leave_OTF
		elsif checkarea =~ /Whistler's Pass|Sylvarraend Road|Gyldemr Road/
			teleport_to_willow
		end
	elsif Char.name =~ /Erykk/
	#							#Bank					   #Gemshop				  	 #Furrier				   #Herbalist
		if checkarea =~ /Ta'Illistim|United Bank of City-States|Tanzania's Gems & Jewelry|Gaedrein's Furs and Pelts|Valina's Herbs and Tinctures/i
			teleport_to_willow
		elsif checkarea =~ /Old Ta'Faendryl|Basilica|Aqueduct/
			leave_OTF
		elsif checkarea =~ /Whistler's Pass|Sylvarraend Road|Gyldemar Road/
			teleport_to_willow
		end
	end
end

#Personal addition to use urchin guides to teleport between locations.

urchin_guide = proc { |tag|
		start_script "go2", ['26906'] if checkarea =~ /Journey's End/i
		wait_while { running? 'go2' }
			fput "urchin guide #{tag}" if checkarea =~ /Ta'Illistim|Journey's End|United Bank of City-States|Tanzania's Gems & Jewelry|Gaedrein's Furs and Pelts|Valina's Herbs and Tinctures/i
		sleep 0.1
	}

#Personal addition to check the status of a hurled weapon.

def hurl_status
	if $frontend == 'stormfront'
		fam_window_begin = "<pushStream id=\"death\" ifClosedStyle=\"watching\"/>"
		fam_window_end   = "<popStream/>\r\n"
	end
	if Char.prof == /Warrior/
		if $weapon_lost == true
			wait_while {$weapon_lost == true}
			puts("#{fam_window_begin} *!* Recovered Weapon *!*\r\n #{fam_window_end}")
		elsif $weapon_lost == false
			nil
		end
	end	
end

######################################################################################





go2 = proc { |room|
    next if Room.current.id.to_s == room.to_s

	if room.to_s == 25987
		go2_willow_rest
	end

	if room.to_s == 26833
		go2_willow_rest
	end

    if checkarea =~ /Table/
		if room.to_s == CharSettings[:rest_room].to_s
			next
		end

        fput 'stand' until standing?
        move 'out'
    end

    wait_while { running? 'go2' }
    start_script('go2', [ room.to_s, '_disable_confirm_', '--typeahead=3' ], h={:quiet=>true});
    wait_while { running? 'go2' }
}

go2_nearest = proc { |list|
    room = Room[CharSettings[:rest_room]].find_nearest(list)
    if room.nil?
        error.call "failed to find nearest room"
    end

    go2.call(room)
}

go2_nearest_tag = proc { |tag|
    if checkarea =~ /Table/i
        fput 'stand' until standing?
        fput 'out'
    end
	
	#HACK
	go2_willow unless Room.current.id == 13048 or 1439 or 4019 or 37 or checkarea =~ /Ta'Illistim/

    town = Room[CharSettings[:rest_room]].find_nearest_by_tag('town')
    room = Room[town].find_nearest_by_tag(tag)
    if room.nil?
        error.call "failed to find room by tag: #{tag}"
    end

	#HACK 11/2/2020
	urchin_guide.call('room')

    go2.call(room)
}

run_commands = proc { |commands|
    next if commands.empty?

    if commands.class != Array
        error.call "run_commands expects an input Array"
    end

    commands.each { |command|
        if command =~ /;/
            scriptname = command.sub(/;/,'')
            start_script scriptname
            wait_while { running? scriptname }
        else
            fput command
        end
    }
}

run_scripts = proc { |scripts|
    scripts.each { |script|
        args   = script.split(' ')
        script = args.shift

        start_script(script, args, true)
        wait_while { running? script }
    }
}

run_loot_script = proc {
    wait_while { running? CharSettings[:loot_script] }
    start_script(CharSettings[:loot_script], [], true)
    wait_while { running? CharSettings[:loot_script] }
}

hunt_prepare = proc {
    run_commands.call(CharSettings[:hunt_pre_commands])	#Pre-hunt commands
}

start_hunting_scripts = proc {
    CharSettings[:hunting_scripts].each { |script|
        start_script(script, [], h={:quiet=>true}) if not running?(script)
    }
}

kill_hunting_scripts = proc {
    CharSettings[:hunting_scripts].each { |script|
        stop_script(script) if running?(script)
    }
}

rest_goto = proc {
    next if in_rest_area

	#HACK - Attempts to teleport back.
	go2_willow_rest
	
    go2.call(CharSettings[:rest_room])
}

rest_exit = proc {
    next unless in_rest_area
    if Room.current.id != CharSettings[:rest_room] and Room.current.path_to(CharSettings[:rest_room]).nil?
		run_commands.call(CharSettings[:rest_out_commands])  #Exit Commands
    end
    in_rest_area = false
}

rest_enter = proc {
    next if in_rest_area
    if Room.current.id != CharSettings[:rest_room] and Room.current.path_to(CharSettings[:rest_room]).nil?
        run_commands.call(CharSettings[:rest_in_commands])	#Enter Commands
    end
    in_rest_area = true
}

rest_run_scripts = proc {
    rest_exit.call
    run_scripts.call(CharSettings[:rest_scripts])
}

reload_hunter = proc {
	#HACK
	hurl_status
	
    $SBOUNTY_HUNTER_SETUP.call(CharSettings.to_hash.dup, get_bounty_location.call)
    $SBOUNTY_HUNTER_RELOAD.call
}

start_hunter = proc { |location|
    $SBOUNTY_HUNTER_SETUP.call(CharSettings.to_hash.dup, location)
#	echo 'BOUNTYHUNTER IS CALLING EXPLORER'
#	echo 'BOUNTYHUNTER IS CALLING EXPLORER'
#	echo 'BOUNTYHUNTER IS CALLING EXPLORER'
#	echo 'BOUNTYHUNTER IS CALLING EXPLORER'
#	echo 'BOUNTYHUNTER IS CALLING EXPLORER'
    start_script($SBOUNTY_HUNTER_NAME, [], false)
}

def change_stance( new_stance, force = true )
	return if Spell[1617].active? || Spell[216].active? || dead?
 
	if( stance() =~ /#{new_stance}/ )
		return
	elsif( checkcastrt() > 0 && new_stance =~ /def/ )
		return if stance() == 'guarded'
	end
 
	if(force)
		result = dothistimeout( "stance #{new_stance}", 3, /You are now in an?|Cast Round Time in effect|You are unable to change/ )
	else
		fput "stance #{new_stance}"
	end
end

finish_hunt = proc {
    if running? $SBOUNTY_HUNTER_NAME
		#HACK
		hurl_status
		
        stop_script($SBOUNTY_HUNTER_NAME)
        wait_while { running? $SBOUNTY_HUNTER_NAME }
    end

    stop_script 'go2' if running? 'go2'
	change_stance('defensive')

	#HACK
	if $frontend == 'stormfront'
		fam_window_begin = "<pushStream id=\"death\" ifClosedStyle=\"watching\"/>"
		fam_window_end   = "<popStream/>\r\n"
	end
	if Char.prof == /Warrior/
		if $weapon_lost == true
			wait_while {$weapon_lost == true}
			puts("#{fam_window_begin} *!* Recovered Weapon *!*\r\n #{fam_window_end}")
		elsif $weapon_lost == false
			nil
		end
	end
	
    # pause to make sure looter isn't running
    wait_while { running? CharSettings[:loot_script] }

    # run loot script in case the hunter wasn't able to clean up
    if GameObj.npcs.find { |npc| npc.status =~ /dead/ } or is_bounty.call 'success_heirloom'
		#HACK
		if $frontend == 'stormfront'
			fam_window_begin = "<pushStream id=\"death\" ifClosedStyle=\"watching\"/>"
			fam_window_end   = "<popStream/>\r\n"
		end
		if Char.prof == /Warrior/
			if $weapon_lost == true
				wait_while {$weapon_lost == true}
				puts("#{fam_window_begin} *!* Recovered Weapon *!*\r\n #{fam_window_end}")
			elsif $weapon_lost == false
				nil
			end
		end	
	
        run_loot_script.call
    end
}

remove_bounty = proc {
    next if (not CharSettings[:enable_expedite] and Spell['Next Bounty'].active?) or is_bounty.call 'none'

    rest_exit.call

    kill_script 'go2' if running? 'go2'

	#HACK
	go2_willow
	urchin_guide.call('bounty') unless Room.current.id == 13048
	sleep 0.3


    go2_nearest_tag.call('advguild') unless Room.current.id == 13048

    print.call 'removing bounty, you have five seconds to kill me'
    sleep 5.00

    npc = GameObj.npcs.find { |t| t.name =~ /taskmaster/i }
    if npc.nil?
        error.call 'failed to find taskmaster'
    end

	#Fail-safe so you don't turn in a completed bounty.
    fput "ask #{npc} about bounty"

    res = dothistimeout "ask #{npc} about remove", 5, /^#{npc}.*?want to be removed|Trying to sneak/
    if res =~ /Trying to sneak/
        fput "ask #{npc} about bounty"
    else
        dothistimeout "ask #{npc} about remove", 5, /^#{npc}.*?have removed you/
    end

    can_do_bounty_cache = nil
}

expedite_bounty = proc {
    print.call 'expediting bounty, you have five seconds to kill me'
    sleep 5.00

    remove_bounty.call

    rest_exit.call

	#HACK
	go2_willow
	urchin_guide.call('bounty') unless Room.current.id == 13048
	sleep 0.3

    go2_nearest_tag.call('advguild') unless Room.current.id == 13048

    npc = GameObj.npcs.find { |t| t.name =~ /taskmaster/i }
    if npc.nil?
        error.call 'failed to find taskmaster'
    end

    res = dothistimeout "ask #{npc} about expedite", 5, /I'll expedite|You don't seem to have any expedited task reassignment|I still need to complete/
    if res =~ /expedited/
        expedite_left = false
    end

    can_do_bounty_cache = nil
}

get_bounty = proc {
    rest_exit.call

	#HACK
	go2_willow
	urchin_guide.call('bounty') unless Room.current.id == 13048
	sleep 0.3

    go2_nearest_tag.call('advguild') unless Room.current.id == 13048

    npc = GameObj.npcs.find { |t| t.name =~ /taskmaster/i }
    res = dothistimeout "ask ##{npc.id} for bounty", 2, /(?:protective escort|creature problem|local gem dealer|local furrier|lost heirloom|local healer|local herbalist|local alchemist|local resident|bandit problem|I'm kind of busy right now)/

    if res.nil?
        error.call 'invalid response from taskmaster'
    elsif res =~ /in about (\d+) minutes|in about a minute/
        time = $1.nil? ? 1 : $1.to_i

        Spell['Next Bounty'].putup
        Spell['Next Bounty'].timeleft = time
    elsif res =~ /bandit/
		#HACK
#		remove_bounty.call - Original
        remove_bounty.call unless CharSettings[:enable_bandit]
    end

    can_do_bounty_cache = nil
}

talk_to_herbalist = proc {

	#HACK
	go2_willow
	urchin_guide.call('healer')
	sleep 0.3

    go2_nearest.call([ 3824, 1851, 10396, 640, 5722, 2406, 11002, 9505 ]) unless Room.current.id == 640

    if Room.current.id == 10396
        npc = 'maraene'
    else
        npc = GameObj.npcs.find { |t| t.name =~ /brother Barnstel|scarred Agarnil kris|healer|herbalist|merchant Kelph|famed baker Leaftoe|Akrash|old Mistress Lomara/i }
    end

    if is_bounty.call 'help_herbalist'
        res = dothistimeout "ask #{npc} about bounty", 5, /Yes, I do have a task for you/
        if res =~ /I've recently received an order for ([0-9]+) (.*?)\./
            print.call "received bounty from herbalist [#{$1} #{$2}]"
        end
    elsif bounty? =~ /#{bounty_patterns['task_forage']}/
        herb_name = $1.gsub(/s?$/,'')
        herbs     = lootsack.contents.find_all { |item| item.name =~ /#{herb_name}/ }

        if herbs.empty?
            error.call 'no herbs to turn in, why are you here?'
        end

        prev_item = nil
        if GameObj.right_hand
            prev_item = GameObj.right_hand

            fput 'store right' if checkright
            fput 'stow right' if checkright
        end

        herbs.each { |herb|
            fput "get ##{herb.id} from ##{lootsack.id}"
            result = dothistimeout "give ##{herb.id} to #{npc}", 3, /This looks perfect|That looks like it has been partially used up/

            if result !~ /perfect/
                fput "drop ##{herb.id}"
			#Fail-safe so you don't have an extra herb in your hands.
			elsif result =~ /You've collected all the samples I asked for/
				empty_hands
            end
        }

        if prev_item
            fput "get ##{prev_item.id}"
        end
    else
        error.call 'why are you at the herbalist?'
    end
}

talk_to_gemdealer = proc {
    if bounty? =~ /Tanzania/
		if checkarea =~ /Cysaegir/
			go2.call(1439) #this fixes gem bounties in Illistim when your rest room is set in Cysaegir
		else
			#HACK
			go2_willow
			urchin_guide.call('gemshop')
			sleep 0.1

			go2_nearest_tag.call('gemshop') unless Room.current.id == 1439
		end
	end

    if Room.current.id == 10327
        npc = 'areacne'
    else
        npc = GameObj.npcs.find { |t| t.name =~ /dwarven clerk|gem dealer|jeweler|Zirconia/i }
    end

    res = dothistimeout "ask #{npc} about bounty", 5, /Yes, I do have a task for you/
    if res =~ /interested in purchasing an? (.*?)\. .* go round up ([0-9]+) of them/
        name  = $1
        count = $2.to_i

        print.call "-- received bounty from gem dealer [#{count} #{name}]"
    end
}

talk_to_furrier = proc {
    if bounty? =~ /Gaedrein/
		if checkarea =~ /Cysaegir/
			go2.call(4019) #this fixes skin bounties in Illistim when your rest room is set in Cysaegir
		else
			#HACK
			go2_willow
			urchin_guide.call('furrier')
			sleep 0.1
			
			go2_nearest_tag.call('furrier') unless Room.current.id == 4019
		end
	end

    if Room.current.id == 10327
        npc 'areacne'
    else
        npc = GameObj.npcs.find { |t| t.name =~ /dwarven clerk|furrier/i }
    end

    res = dothistimeout "ask #{npc} about bounty", 5, /Yes, I do have a task for you/
    if res =~ /I've recently received an order for ([0-9]+) (.*?)\./
        print.call "received bounty from furrier [#{$1} #{$2}]"
    end
}

get_guard_npc = proc {
    if Room.current.id == 10915
        'purser'
	elsif Room.current.id == 28978
		'Luthrek'
    else
        GameObj.npcs.find { |npc| npc.name =~ /guard|sergeant|guardsman|purser|Belle|Luthrek/i }
    end
}

find_guard = proc {

	#HACK
	go2_willow
	
	if Room.current.id == 13048 #Ta'Illistim, Alearyl Hall - Ta'Illistim Adventurer's Guild
		urchin_guide.call('guard')
		sleep 0.1
	end
	
	if Room.current.id == 26906 #Journey's End, Willow
		urchin_guide.call('guard')
		sleep 0.1
	end

    go2_nearest_tag.call('advguard') unless Room.current.id == 37
    npc = get_guard_npc.call

    if npc.nil?
        go2_nearest_tag.call('advguard2') unless Room.current.id == 37
        npc = get_guard_npc.call
    end

    if npc.nil?
        error.call "failed to locate guard"
    end

    npc
}

talk_to_guard = proc {
    npc = find_guard.call

    res = dothistimeout "ask #{npc} about bounty", 5, /Yes, we do have a task for you|Ah, so you have returned/
    if res.nil?
        print.call "unknown response from guard: #{res}"
    end
}

get_random_location = proc {
    keys = []
    CharSettings[:locations].each { |key, data|
        if data[:enable_hunting_rotation]
            keys.push(key)
        end
    }
    name = keys[rand(keys.size)]

    if name.nil?
        error.call 'failed to find a hunting area'
    end

    [ name, CharSettings[:locations][name] ]
}

task_escort = proc { |target|

    print.call "escorting child to nearest dropoff"
    dropoff_points = Room.current.find_all_nearest_by_tag("advguard") + Room.current.find_all_nearest_by_tag("advguard2") + [2777, 2778, 2782, 2779, 2780, 2781, 2783, 2784, 2785, 2786, 2787]

    1.times {
        path  = []
        step2 = proc { |destination_room|
            unless path and (s = path.index(Room.current.id)) and (d = path.index(destination_room)) and (s < d)
                previous, shortest_distances = Map.dijkstra(Room.current.id, destination_room)
                unless previous[destination_room]
                    echo "error: failed to find a path between your current room (#{Room.current.id}) and destination room (#{destination_room})"
                    exit
                end
                path = [ destination_room ]
                path.push(previous[path[-1]]) until previous[path[-1]].nil?
                path.reverse!
                previous = shortest_distances = nil
            end

            nextroom = path[path.index(Room.current.id)+1].to_s
            if nextroom =~ /9734/
                #we are trying to get out of Maaghara's Tower and need special script
            end

            way = Room.current.wayto[nextroom]

            if way.class == String
                move way
            elsif way.class == Proc
                way.call
            end
        }

        waitrt?
        fput 'stance defensive' unless checkstance('guarded')

        #destination = Room[CharSettings[:rest_room]].find_nearest_by_tag(target)
        place = Room.current.find_nearest(dropoff_points)
        destination = place
        while Room.current.id != destination and is_bounty.call 'task_escort'
            if GameObj.npcs.find { |n| n.name =~ /child/i }
                step2.call(destination)
            end
            sleep 0.25
        end
        if is_bounty.call 'fail_child'
            print.call 'failed to escort child or child was killed'
        elsif npc = get_guard_npc.call
            print.call 'waiting for child to arrive'
            wait_until { GameObj.npcs.find { |n| n.name =~ /child/ } }

            if npc.class == String
                fput "ask #{npc} for bounty"
            else
                fput "ask ##{npc.id} for bounty"
            end
        else
            #no guard is here
            dropoff_points.delete(place)
            redo
        end
    }
}

task_search = proc {
    if bounty? !~ /#{bounty_patterns['task_search']}/
        error.call 'you are not on a search bounty'
    end

    print.call 'searching for heirloom'

    name, location = get_bounty_location.call
    song_of_peace  = false
    invalid_rooms  = []
    last_room      = nil

    hunt_prepare.call
    rest_exit.call

#HACK - Add a proc to use teleporter?

    go2.call location[:room]

    start_hunting_scripts.call

    while is_bounty.call 'task_search' and not CharSettings[:should_rest_wounded].call
        if Spell[1011].known? and Spell[1011].affordable? and not song_of_peace
            Spell[1011].cast
            song_of_peace = true
		elsif Spell[506].known? and Spell[506].affordable? and not Spell[506].active?
			Spell[506].cast
        end

        wander.call location[:boundaries]

        fput 'stand' until standing?
        fput 'stance defensive' until checkstance 'defensive' or checkstance 'guarded'

        if (GameObj.npcs.empty? or GameObj.npcs.nil?) and Room.current.location =~ /#{location[:location].downcase.strip}/i and not invalid_rooms.include?(Room.current.id) and Room.current.id != last_room
            run_commands.call(CharSettings[:pre_search_commands])

            fput 'kneel' until kneeling?

            res = dothistimeout 'search', 1, /You intently search the area|You put your head to the/
            if res =~ /You intently search the area|You put your head to the/
                last_room = Room.current.id
            else
                print.call 'invalid room, skipping in the future'
                invalid_rooms.push Room.current.id
            end

            waitrt?

            run_commands.call CharSettings[:post_search_commands]

            while not checkstance 'offensive' and (song_of_peace or GameObj.npcs.find_all { |npc| npc.status !~ /dead/ }.nil?)
                fput 'stance offensive'
				sleep 0.10
            end

            fput 'stand' until standing?

            fput 'stance defensive' until checkstance 'defensive' or checkstance 'guarded'

            if is_bounty.call 'task_found'
                run_loot_script.call
                break
            end
        end
    end

    waitrt?

    if song_of_peace
        fput "stop 1011"
    end

    kill_hunting_scripts.call
}

#HACK
def bandit_spells
#Rapid Fire
	Spell[515].cast if !Spell[515].active? && Spell[515].affordable? && Spell[515].known?
#Celerity
	Spell[506].cast if !Spell[506].active? && Spell[506].affordable? && Spell[506].known?
end

task_bandit = proc {
    if bounty? !~ /#{bounty_patterns['task_bandit']}/
        error.call('you are not on a bandits bounty')
    end

    print.call('culling bandits')

    my_ambush = false
    ambush_room_count = XMLData.room_count

    location = $1.strip.downcase

	#needs to be lower case
	if location =~ /Gyldemar Road|gyldemar road/
		rooms = Array[ "4611", "4708", "4709", "4710", "10762", "4711", "4712", "4713", "4715", "10781", "4716", "4717", "10782", "10783", "4718", "4719", "4720", "10784", "4721", "4722", "10807", "10808", "10809", "4783", "4784", "10810", "4785", "4786", "4787", "4788", "4789", "4790", "4791", "4792", "4793", "10812", "4795", "4796", "4797", "10813", "10814", "10815"]
	elsif location =~ /Sylvarraend Road|sylvarraend road/
		rooms = Array[ "645", "646", "647", "648", "649", "650", "651", "652", "653", "654", "655", "656", "657", "658", "659", "660", "661", "662", "663", "664", "665", "666", "667", "668", "669", "670", "671", "672", "10083", "10084", "10085", "10086", "10087", "10088", "10089", "10098", "10099", "1433", "10105", "10106", "10107", "10108", "10109", "10110", "10111", "1770", "1774", "3545" ]
	elsif location =~ /Widowmaker's Road|widowmaker's road/
		rooms = Array [ "29021", "29022", "29023", "29024", "29025", "29026", "29027", "29028", "29029", "29030", "29050", "29051", "29053", "29054", "29055" ]
	elsif location =~ /Muddy Village|muddy village/
		rooms = Array [ "29047", "29049", "29060", "29066", "29065", "29063", "29071", "29059", "29060", "29072", "29076", "29075", "29074", "29068", "29060", "29049" ]
	elsif location =~ /Black Weald|black weald/
		rooms = Array [ "29227", "29228", "29227", "29230", "29231", "29232", "29233", "29232", "29231", "29240", "29239", "29238", "29237", "29236", "29235", "29229", "29227" ]
	elsif location =~ /Cliffwalk|cliffwalk/
		rooms = Array [ "29124", "29120", "29124", "29128", "29129", "29131", "29220", "29221", "29222", "29223", "29219", "29217", "29134", "29133", "29129" ]
	else
		print.call('No rooms set for this location')
	    rooms = Room.list.find_all { |r| r.location =~ /#{location}/i }.collect { |r| r.id }
	end

    if CharSettings[:enable_bandit_script] and not Script.exists?(CharSettings[:bandit_script])
        error.call('bandit script is enabled could not be found')
    end

	#HACK
	hunt_prepare.call
	start_hunting_scripts.call

    while not CharSettings[:should_rest_wounded].call and is_bounty.call('task_bandit')
        rooms.each { |room|
					bandit_spells
					print.call 'moving to room ' + room.to_s
					if Spell[9609].active?
						fput 'stance forward' unless checkstance == 'forward'
					else
						fput 'stance defensive' unless checkstance == 'defensive'
					end
					go2.call(room)
					print.call('waiting for attack')

            start = Time.now.to_i
            while true
				if GameObj.pcs.any?
					print.call('There is someone here')		
					break
				end
				
                if Time.now.to_i - start > 1
                    break
                end

                if GameObj.npcs.find { |npc| npc.type =~ /bandit/ }
					print.call('Found bandits!')		
                    break
                end

                sleep 0.1
            end

            while not CharSettings[:should_rest_wounded].call()
                npcs = GameObj.npcs.to_a.find_all { |npc| npc.type =~ /bandit/ and npc.status !~ /dead/ }
                dead = GameObj.npcs.to_a.find_all { |npc| npc.type =~ /bandit/ and npc.status =~ /dead/ }

				#HACK
                #if npcs.empty? -- Original
				if GameObj.pcs.any?
					break
                elsif npcs.empty?
                    break
                elsif CharSettings[:enable_bandit_script]
                    waitrt?
                    waitcastrt?

                    if not dead.empty?
                        run_loot_script.call()
                    else
                        start_script(CharSettings[:bandit_script], npcs.collect { |n| n.id }, h={:quiet=>true})
                        wait_while { running?(CharSettings[:bandit_script]) }
                    end
                else
                    print.call('kill them all then unpause me!')
                    script.pause
                end

                sleep 0.1
            end

            break if CharSettings[:should_rest_wounded].call or not is_bounty.call('task_bandit')
        }

        rooms.reverse!

        sleep 0.1
    end

	#ADDED-BEGIN
#	kill_script(CharSettings[:bandit_script]
	#ADDED-END
    kill_hunting_scripts.call
}

task_forage = proc {
    if bounty? !~ /#{bounty_patterns['task_forage']}/
        error.call 'you are not on a forage bounty'
    end

    herb     = $1
    location = $2
    count    = $3.to_i

    print.call("foraging for #{count} #{herb} at #{location}")

    herb = herb.downcase

	#HACK
	start_hunting_scripts.call

    refresh_spells = proc {
        [506, 604, 9704].each { |spell|
            if Spell[spell].known? and not Spell[spell].active? and Spell[spell].affordable?
                waitrt?
                waitcastrt?

                Spell[spell].cast
            end
        }

        yierka          = Spell['AA: Yierka']
        yierka_cooldown = Spell['AA: Yierka Cooldown']

        if yierka.known? and yierka.affordable? and not yierka_cooldown.active?
            yierka.cast
        end
    }

    get_herb_count = proc {
        lootsack.contents.find_all { |item| item.name =~ /#{herb.gsub(/s?$/,'')}/i }.size
    }

    last_forage_attempt = Time.now.to_i

    if get_herb_count.call < count
        hunt_prepare.call
		#HACK
		start_hunting_scripts.call

        rest_exit.call

        rooms = get_herb_rooms.call(location, herb)
        bright_rooms = []

        cur_room  = 0
        num_tries = 0

        song_of_peace = false

        while get_herb_count.call < count and not CharSettings[:should_rest_wounded].call and num_tries < 3
            sanct_cast = false
            light_cast = false

			#HACK
			#ADD teleport to OTF.
			
            go2.call(rooms[cur_room])
            cur_room = cur_room + 1

            if cur_room >= rooms.length
                cur_room  = 0
                num_tries = num_tries + 1
            end

            while get_herb_count.call < count and rooms.length > 0 and not CharSettings[:should_rest_wounded].call
                if Spell[1011].known? and Spell[1011].affordable? and not song_of_peace
                    Spell[1011].cast
                    song_of_peace = true
                end

                waitrt?
                fput 'stance defensive' until ['defensive', 'guarded'].include?(checkstance)

                refresh_spells.call

                if not song_of_peace and not GameObj.npcs.find_all { |npc| npc.type =~ /aggressive/ && npc.status !~ /dead|gone/ }.nil?
                    break
                end

                if not kneeling?
                    run_commands.call(CharSettings[:pre_search_commands])
                    fput "kneel" until kneeling?
                end

                if Spell[213].known? and Spell[213].affordable? and not sanct_cast
                    sanct_cast = true
                    fput "incant 213"
                    waitcastrt?
                end

                if Spell[205].known? and Spell[205].affordable? and not bright_rooms.include?(cur_room) and not light_cast
                    light_cast = true
                    fput "incant 205"
                    bright_rooms.push(cur_room)
                    waitcastrt?
                end

				#HACK - Removed small
                res = dothistimeout "forage #{herb.gsub(/(?:(?:handful|bunch|sprig|layer|stem) of|fragrant|fetid|dark)\s+/, '') }", 1, /not even positive|it could be|it could even be found|and manage to find|Roundtime|In order to forage|foraging here recently/
                #res = dothistimeout "forage #{herb.gsub(/(?:(?:handful|bunch|sprig|layer|stem) of|fragrant|fetid|dark|small)\s+/, '') }", 1, /not even positive|it could be|it could even be found|and manage to find|Roundtime|In order to forage|foraging here recently/

			    if res =~ /it could be|it could even be found|not even positive/
                    rooms.delete_at(cur_room)
				    break
			    elsif res =~ /and manage to find/
                    fput "put #{checkleft} in ##{lootsack.id}" while checkleft =~ /#{herb}/ || (!checkleft.nil? && herb =~ /#{checkleft}/)
                    fput "put #{checkright} in ##{lootsack.id}" while checkright =~ /#{herb}/ || (!checkright.nil? && herb =~ /#{checkright}/)

				    print.call "-- success, found #{get_herb_count.call} of #{count} #{herb}"
			    elsif res =~ /In order to forage/
				    fput "stow all"
			    elsif res =~ /foraging here recently/
                    print.call 'herb can not be found here, skipping room...'
                    rooms.delete_at(cur_room)
				    break
			    else
			        print.call "failure, found #{get_herb_count.call} of #{count} #{herb}"
			    end
            end

            # Sanity check, cleanup any remaining herbs
            fput "put #{checkleft} in ##{lootsack.id}" while checkleft =~ /#{herb}/ || (!checkleft.nil? && herb =~ /#{checkleft}/)
            fput "put #{checkright} in ##{lootsack.id}" while checkright =~ /#{herb}/ || (!checkright.nil? && herb =~ /#{checkright}/)

            if not standing?
                run_commands.call(CharSettings[:post_search_commands])

                while not checkstance 'offensive' and (song_of_peace or GameObj.npcs.find_all { |npc| npc.type =~ /aggressive/ && npc.status !~ /dead/ }.nil?)
                    fput 'stance offensive'
					sleep 0.10
                end

                fput "stand" until standing?
                fput 'stance defensive' until checkstance 'defensive' or checkstance 'guarded'
            end
        end
    end

    if song_of_peace
        fput "stop 1011"
    end

    if get_herb_count.call >= count
        talk_to_herbalist.call
        last_forage_attempt = 0
    end

    kill_hunting_scripts.call
}

success_heirloom = proc {
    print.call 'turning in heirloom'

    npc = find_guard.call

    empty_hands

    close = false
    if lootsack.contents.nil?
        open_result = dothistimeout "open ##{lootsack.id}", 5, /^You open|^That is already open\.$/
        if open_result =~ /^You open/
            close = true
        else
            dothistimeout "look in ##{lootsack.id}", 5, /In .*? you see/
        end
    end

    found = false
    bounty? =~ /#{bounty_patterns['success_heirloom']}/
    heirloom_name = $1
    echo "Looking for #{heirloom_name}"
    lootsack.contents.each { |item|
        if item.name =~ /#{heirloom_name}/
            res = dothistimeout "look ##{item.id}", 2, /^Engraved .* initials|^You see nothing unusual\.$|^The ring appears|^It takes you a moment|^It is difficult to see/
            if res =~ /^Engraved .* initials/
                fput "get ##{item.id}"
                fput "give ##{item.id} to #{npc}"
                found = true

                break
            end
        end
    }

    fput "close ##{lootsack.id}" if close

    if not found
        error.call 'failed to find heirloom for guard'
    end

    fill_hands
}

turn_in = proc {
    rest_exit.call

    if is_bounty.call 'success_guard'
        talk_to_guard.call
    elsif is_bounty.call 'success_heirloom'
        success_heirloom.call
    end

	#HACK
	go2_willow
	urchin_guide.call('bounty')
	sleep 0.1

    go2_nearest_tag.call('advguild') unless Room.current.id == 13048

    npc = GameObj.npcs.find { |t| t.name =~ /taskmaster/i }
    res = dothistimeout "ask #{npc} about bounty", 5, /^#{npc}.*?done with that assignment/
    10.times {
        if line = get? and line =~ /You have earned ([0-9]+) bounty points?, ([0-9]+) experience points, and ([0-9]+) silver\./
            print.call "finished task (#{$1} points, #{$2} exp, #{$3} silver)"
            break
        end

        sleep 0.1
    }

    run_loot_script.call
    can_do_bounty_cache = nil
    $sbounty_can_do_bounty = nil
}

talk_to_npc = proc {
    if is_bounty.call ['help_creature', 'help_resident', 'help_heirloom', 'success_guard']
        talk_to_guard.call
    # separate bandits so we don't trigger them on accident while walking
    elsif is_bounty.call ['help_bandit'] and CharSettings[:enable_bandit]
        talk_to_guard.call
    elsif is_bounty.call 'help_furrier'
        talk_to_furrier.call
    elsif is_bounty.call 'help_herbalist'
        talk_to_herbalist.call
    elsif is_bounty.call 'help_gemdealer'
        talk_to_gemdealer.call
    end
}

hunter        = CharSettings[:hunter]
task_accepted = false
resting       = false

start_script(hunter, nil, true)
wait_while { running? hunter }

if script.vars[1] =~ /^setup$/i
    setup.call
    exit
elsif script.vars[1] =~ /^forage$/i
    task_forage.call
    exit
elsif script.vars[1] =~ /^bandits?$/i
    task_bandit.call
    exit
elsif script.vars[1] =~ /^npc$/i
    talk_to_npc.call
    exit
elsif script.vars[1] =~ /^load$/i
    location = nil
    if script.vars[2]
        target = script.vars[2]
        locations = CharSettings[:locations].dup
        location = locations.find { |name, data| $SBOUNTY_CLEAN_TARGETS.call(data[:targets]).find { |t| target =~ /#{t}/i } }
    end
    $SBOUNTY_HUNTER_SETUP.call(CharSettings.to_hash.dup, get_bounty_location.call(location,target))
    exit
elsif script.vars[1] =~ /^check$/i
    can_do_bounty.call
    exit
elsif script.vars[1]
    CharSettings[:hunter] = "bountyhunter-#{script.vars[1]}"
end


if not defined? $SBOUNTY_HUNTER_SETUP
    error.call 'hunter setup was not defined'
elsif not defined? $SBOUNTY_HUNTER_NAME
    error.call 'hunter name was not defined'
elsif not defined? $SBOUNTY_HUNTER_RELOAD
    error.call 'hunter reload was not defined'
end

before_dying {
	#HACK
	if Char.prof == /Warrior/
		if $weapon_lost == true
			wait_while {$weapon_lost == true}
		elsif $weapon_lost == false
			nil
		end
	end
	
    kill_script($SBOUNTY_HUNTER_NAME) if running?($SBOUNTY_HUNTER_NAME)
    kill_hunting_scripts.call
}

Thread.new {
    wait_until { dead? }
    exit
}

while true
    talk_to_npc.call

    if can_do_bounty.call and not CharSettings[:should_rest_wounded].call
        if is_bounty.call 'task_search'
            task_search.call
        elsif is_bounty.call 'task_forage' and Time.now.to_i >= last_forage_attempt + last_forage_delay
            task_forage.call
        end
    elsif Spell['Next Bounty'].active? and (expedite_left and not is_bounty.call 'none' and not can_do_bounty.call and CharSettings[:enable_expedite])
        expedite_bounty.call
        next
    end

    if is_bounty.call 'task_escort' and GameObj.npcs.find { |npc| npc.name =~ /child/ }
        task_escort.call 'advguard'
    elsif is_bounty.call 'task_fail'
        can_do_bounty_cache = nil
    elsif is_bounty.call 'success_heirloom'
        success_heirloom.call
    end

    exit if dead?

    if can_turn_in.call
        turn_in.call
        resting = false
    else
        if not can_do_bounty.call and not Spell['Next Bounty'].active?
			#HACK
            remove_bounty.call unless is_bounty.call ['success']

            get_bounty.call

			#HACK
			if is_bounty.call ['help_creature', 'help_resident', 'help_heirloom', 'help_gemdealer', 'help_herbalist', 'help_furrier']
				talk_to_npc.call
			end

		elsif should_hunt.call and not should_rest.call and not has_skins.call and percentmind < CharSettings[:should_hunt_mind].to_i
            resting   = false
            provoked  = false
            success   = false
            first_run = false
            bounty    = bounty?
            
			rest_exit.call	#Exit Commands
            hunt_prepare.call	#Pre-hunt commands

            # default hunter location
            if can_do_bounty.call
                # order is important here - bandits and regular culling look similar
                if is_bounty.call ['task_bandit']
                    task_bandit.call
                elsif is_bounty.call ['task_cull', 'task_dangerous', 'task_heirloom', 'task_rescue', 'task_skin']
					#ADDED 2/25/20
					#hunt_prepare.call	#Pre-hunt commands
					#END
                    start_hunter.call(get_bounty_location.call)
                else
					#ADDED 2/25/20
					#hunt_prepare.call	#Pre-hunt commands
					#END
                    start_hunter.call(get_random_location.call)
                end
            else
				#ADDED 2/25/20
				#hunt_prepare.call	#Pre-hunt commands
				#END
                start_hunter.call(get_random_location.call)
            end

            while not should_rest.call and running? $SBOUNTY_HUNTER_NAME
                if bounty? =~ /#{bounty_patterns['task_provoked']}/ and not provoked
                    reload_hunter.call
                    provoked = true
                elsif is_bounty.call 'task_escort'
                    break
                elsif has_skins.call
                    break
                elsif not success and (bounty? != bounty and (is_bounty.call [ 'success', 'success_heirloom' ] or (provoked and is_bounty.call 'success_guard')))
					#POSSIBLE EDIT HERE TO REMOVE FINISH_HUNT.call
					#finish_hunt.call

					#HACK
					if Char.prof == /Warrior/
						if $weapon_lost == true
							wait_while {$weapon_lost == true}
						elsif $weapon_lost == false
							nil
						end
					end

					kill_script($SBOUNTY_HUNTER_NAME) if running?($SBOUNTY_HUNTER_NAME)
                    #start_hunter.call(get_random_location.call)

                    success = true
                elsif can_turn_in.call
                    break
                #elsif not can_do_bounty.call and not Spell['Next Bounty'].active?
                #    break
                end

                sleep 0.10
            end

            finish_hunt.call
        elsif not can_turn_in.call
            rest_goto.call
            rest_enter.call

            if not resting or CharSettings[:should_rest_wounded].call
                rest_run_scripts.call
                rest_goto.call
                rest_enter.call

                sleep 1
            end

            while should_rest.call or not should_hunt.call
                if can_turn_in.call
                    break
                elsif CharSettings[:should_rest_wounded].call
                    break
                elsif not can_do_bounty.call and not Spell['Next Bounty'].active?
                    break
                end

                fput 'exp'

                if rest_reason.nil?
                    rest_reason = hunt_reason
                end
                print.call "still resting because: #{rest_reason}"

                sleep CharSettings[:rest_sleep_interval]
            end

            resting = true
            rest_exit.call
        end
    end

    sleep 0.10
end
