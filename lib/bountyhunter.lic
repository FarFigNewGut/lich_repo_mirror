#bountyhunter.lic
=begin

Author: Alastir
BOUNTYHUNTER Fork by Alastir (GS4Alastir@gmail.com)

=end

# Vaalor guards
Room[5827].tags.push('advguard2') unless Room[5827].tags.include?('advguard2')

$BOUNTYHUNTER = CharSettings.to_hash

$BOUNTYHUNTER_HUNTER_NAME  = 'explorer'
$BOUNTYHUNTER[:hunter] ||= 'bountyhunter-explorer'

$BOUNTYHUNTER[:enable_cull]      = $BOUNTYHUNTER[:enable_cull].nil? ? true : $BOUNTYHUNTER[:enable_cull]
$BOUNTYHUNTER[:enable_dangerous] = $BOUNTYHUNTER[:enable_dangerous].nil? ? true : $BOUNTYHUNTER[:enable_dangerous]
$BOUNTYHUNTER[:enable_forage]    = $BOUNTYHUNTER[:enable_forage].nil? ? true : $BOUNTYHUNTER[:enable_forage]
$BOUNTYHUNTER[:enable_loot]      = $BOUNTYHUNTER[:enable_loot].nil? ? true : $BOUNTYHUNTER[:enable_loot]
$BOUNTYHUNTER[:enable_rescue]    = $BOUNTYHUNTER[:enable_rescue].nil? ? true : $BOUNTYHUNTER[:enable_rescue]
$BOUNTYHUNTER[:enable_search]    = $BOUNTYHUNTER[:enable_search].nil? ? true : $BOUNTYHUNTER[:enable_search]
$BOUNTYHUNTER[:enable_bandit]    = $BOUNTYHUNTER[:enable_bandit].nil? ? false : $BOUNTYHUNTER[:enable_bandit]
$BOUNTYHUNTER[:enable_skin]      = $BOUNTYHUNTER[:enable_skin].nil? ? true : $BOUNTYHUNTER[:enable_skin]
$BOUNTYHUNTER[:enable_expedite]  = $BOUNTYHUNTER[:enable_expedite].nil? ? true : $BOUNTYHUNTER[:enable_expedite]

$BOUNTYHUNTER[:enable_hunt_complete] = $BOUNTYHUNTER[:enable_hunt_complete].nil? ? true : $BOUNTYHUNTER[:enable_hunt_complete]

$BOUNTYHUNTER[:hunting_scripts]       ||= ['spellactive']
$BOUNTYHUNTER[:enable_bandit_script]  ||= false
$BOUNTYHUNTER[:bandit_script]         ||= 'bountyhunter-bandit-example'
$BOUNTYHUNTER[:pre_search_commands]   ||= ['store all']
$BOUNTYHUNTER[:post_search_commands]  ||= ['gird']
$BOUNTYHUNTER[:pre_forage_commands]   ||= ['store all']
$BOUNTYHUNTER[:post_forage_commands]  ||= ['gird']
$BOUNTYHUNTER[:forage_retry_delay]    ||= 300
$BOUNTYHUNTER[:loot_script]           ||= 'eloot'
$BOUNTYHUNTER[:turn_in_percent]       ||= 95
$BOUNTYHUNTER[:enable_turn_in_bounty] ||= $BOUNTYHUNTER[:enable_turn_in_bounty].nil? ? true : $BOUNTYHUNTER[:enable_turn_in_bounty]

$BOUNTYHUNTER[:should_hunt_mind]    ||= 75
$BOUNTYHUNTER[:should_hunt_mana]    ||= 0
$BOUNTYHUNTER[:should_hunt_spirit]  ||= 7
$BOUNTYHUNTER[:hunt_pre_commands]   ||= ['gird']
$BOUNTYHUNTER[:should_rest_mind]    ||= 100
$BOUNTYHUNTER[:should_rest_mana]    ||= 0
$BOUNTYHUNTER[:should_rest_encum]   ||= 20
$BOUNTYHUNTER[:should_rest_wounded] ||= StringProc.new('bleeding? || XMLData.injuries.any?{|key,value| value["wound"] > 1} || percenthealth <= 50')

$BOUNTYHUNTER[:rest_room]       	||= ''
$BOUNTYHUNTER[:boundaries]     		||= ''
$BOUNTYHUNTER[:rest_in_commands]    ||= ['']
$BOUNTYHUNTER[:rest_out_commands]   ||= ['']
$BOUNTYHUNTER[:rest_pre_commands]   ||= ['store all']
$BOUNTYHUNTER[:rest_scripts]        ||= ['waggle']
$BOUNTYHUNTER[:rest_sleep_interval] ||= 30

$BOUNTYHUNTER[:locations] ||= {}

$BOUNTYHUNTER_rest        = false
$BOUNTYHUNTER_rest_reason = nil
in_rest_area         = false
rest_reason          = nil
hunt_reason          = nil
can_do_bounty_cache  = nil
expedite_left        = true
last_forage_attempt  = 0
last_forage_delay    = 300
first_run            = true

if UserVars.lootsack.nil? or UserVars.lootsack.empty?
    echo '** lootsack has not been set, set it with ;set change lootsack [container]'
    exit
end

if $BOUNTYHUNTER[:enable_skin] and (UserVars.skinsack.nil? or UserVars.skinsack.empty?)
    echo '** skinsack has not been set, set it with ;set change skinsack [container]'
    exit
end

lootsack = GameObj.inv.find { |i| i.noun =~ /#{UserVars.lootsack}/ } or GameObj.inv.find { |i| i.name =~ /#{UserVars.lootsack}/ }
skinsack = GameObj.inv.find { |i| i.noun =~ /#{UserVars.skinsack}/ } or GameObj.inv.find { |i| i.name =~ /#{UserVars.lootsack}/ }

if lootsack.nil?
    echo '** failed to find your lootsack, set it with ;set change lootsack [container]'
    exit
end

if $BOUNTYHUNTER[:enable_skin] and skinsack.nil?
    echo '** failed to find your skinsack, set it with ;set change skinsack [container]'
    exit
end

# You have been tasked to recover a peridot-inset pewter ring that an unfortunate citizen lost after being attacked by a storm giant in the Upper Trollfang near Wehnimer's Landing.  The heirloom can be identified by the initials MG engraved upon it.  Hunt down the creature and LOOT the item from its corpse.

bounty_patterns = {
    'none' => '^You are not currently assigned a task\.',

    # help
    'help_bandit'    => 'It appears they have a bandit problem',
    'help_creature'  => 'It appears they have a creature problem they\'d like you to solve\.',
    'help_resident'  => 'It appears that a local resident urgently needs our help in some matter\.',
    'help_heirloom'  => 'It appears they need your help in tracking down some kind of lost heirloom\.',
    'help_gemdealer' => 'The local gem dealer, .*, has an order to fill and wants our help\.',
    'help_herbalist' => 'local herbalist|local healer|local alchemist|local halfling alchemist',
    'help_furrier'   => 'The local furrier|The local furrier Bramblefist',

    # in progress
    'task_bandit'    => '^You have been tasked to suppress bandit activity (?:in|on|near) (?:the )?(.*)\s(?:near|between|under|\.)',
    'task_escort'    => '^You have made contact with the child',
    'task_dangerous' => 'You have been tasked to hunt down and kill a particularly dangerous (.*) that has established a territory (?:in|on|near) (?:the )?(.*)(?:\s(?:near|between|under)|\.)\s+You can',
    'task_provoked'  => 'You have been tasked to hunt down and kill a particularly dangerous (.*) that has established a territory (?:in|on|near) (?:the )?(.*)(?:\s(?:near|between|under)|\.)\s+You have provoked',
    'task_dealer'    => '^The(?: local)? gem dealer',
    'task_forage'    => 'concoction that requires (?:a|an|some) (.*) found (?:in|on|near) (?:the )?(.*?)(?: near| between| under|\.).*These samples must be in pristine condition\.\s+You have been tasked to retrieve (\d+) (?:more )?samples?\.',
    'task_cull'      => 'You have been tasked to(?: help \w*)?(?: (?:retrieve an heirloom|kill a dangerous creature|rescue a missing child) by)? suppress(?:ing)? (.*) activity (?:in|on) (?:the )?(.*)(?:\s(?:near|between|under)|\.)',
    'task_search'    => 'unfortunate citizen lost after being attacked by (?:a|an) (.*?) (?:in|on|near) (?:the )?(.*?)\s?(?:near|between|under|\.  The).*SEARCH',
    'task_heirloom'  => 'unfortunate citizen lost after being attacked by (?:a|an) (.*?) (?:in|on|near) (?:the )?(.*?)\s?(?:near|between|under|\.  The).*LOOT',
    'task_found'     => 'You have located .* and should bring it back',
    'task_skin'      => '^You have been tasked to retrieve (\d+|\w+)s? (.*) of at least .*\.  You can SKIN them off the corpse of (?:a|an) (.*) or ',
    'task_rescue'    => 'A local divinist has had visions of the child fleeing from (?:a|an) (.*) (?:in|on) (?:the )?(.*) (?:near|between|under)',

    # fail
    'fail_child' => 'The child you were tasked to rescue is gone and your task is failed\.',

    # success
    'success'          => '^You have succeeded in your task and can return',
    'success_guard'    => '^You succeeded in your task and should report back to',
    'success_heirloom' => '^You have located (?:a|an|the|some) (.*) and should bring it back .*\.$'
}

setup = proc {
    script_name = script.name

    action   = nil
    @window   = nil
    notebook = nil

   nil

    locations = $BOUNTYHUNTER[:locations].dup
    location  = nil

    error = proc { |msg|

        dlg = Gtk::MessageDialog.new(
            :parent => @window,
            :flags => [:modal, :destroy_with_parent],
      :type => :info,
            :buttons => :ok,
      :message => msg
        )
    dlg.run
    dlg.destroy
  }

    widgets = {
        :gui_widgets => {
            # buttons
            :close  => Gtk::Button.new(:label => 'Close'),
            :create => Gtk::Button.new(:label => 'Create'),
            :delete => Gtk::Button.new(:label => 'Delete'),
            :save   => Gtk::Button.new(:label => 'Save & Close'),

            # combos
            :locations => Gtk::ComboBoxText.new,

            # entries
            :new_name => Gtk::Entry.new,
        },

        :location_widgets => {
            # check buttons
            :enable_bounty_only      => Gtk::CheckButton.new('Only attack bounty critters'),
            :enable_hunting_rotation => Gtk::CheckButton.new('In hunting rotation'),
            :enable_search_only      => Gtk::CheckButton.new('Only search here (no hunting)'),

            #entries
            :location   => Gtk::Entry.new,
            :skins      => Gtk::Entry.new,
            :targets    => Gtk::Entry.new,
            :room       => Gtk::Entry.new,
            :boundaries => Gtk::Entry.new,
        },

        # check buttons
        :enable_cull          => Gtk::CheckButton.new('Cull critters'),
        :enable_dangerous     => Gtk::CheckButton.new('Dangerous critter'),
        :enable_forage        => Gtk::CheckButton.new('Forage herbs'),
        :enable_loot          => Gtk::CheckButton.new('Loot heirloom'),
        :enable_rescue        => Gtk::CheckButton.new('Rescue child'),
        :enable_search        => Gtk::CheckButton.new('Search heirloom'),
        :enable_bandit        => Gtk::CheckButton.new('Bandits'),
        :enable_skin          => Gtk::CheckButton.new('Skin critters'),
        :enable_expedite      => Gtk::CheckButton.new('Expedite bounties'),
        :enable_bandit_script => Gtk::CheckButton.new('Use bandit script'),
        :enable_hunt_complete => Gtk::CheckButton.new('Hunt until complete?'),
        :enable_turn_in_bounty => Gtk::CheckButton.new('Force turn in if new bounty'),

        # entries
        :hunting_scripts      => Gtk::Entry.new,
        :bandit_script        => Gtk::Entry.new,
        :pre_search_commands  => Gtk::Entry.new,
        :post_search_commands => Gtk::Entry.new,
        :pre_forage_commands  => Gtk::Entry.new,
        :post_forage_commands => Gtk::Entry.new,
        :forage_retry_delay   => Gtk::Entry.new,
        :loot_script          => Gtk::Entry.new,
        :turn_in_percent      => Gtk::Entry.new,

        :should_hunt_mind   => Gtk::Entry.new,
        :should_hunt_mana   => Gtk::Entry.new,
        :should_hunt_spirit => Gtk::Entry.new,

        :hunt_pre_commands => Gtk::Entry.new,
        :hunt_commands_a   => Gtk::Entry.new,
        :hunt_commands_b   => Gtk::Entry.new,
        :hunt_commands_c   => Gtk::Entry.new,
        :hunt_commands_d   => Gtk::Entry.new,
        :hunt_commands_e   => Gtk::Entry.new,

        :should_rest_mana    => Gtk::Entry.new,
        :should_rest_mind    => Gtk::Entry.new,
        :should_rest_encum   => Gtk::Entry.new,
        :should_rest_wounded => Gtk::Entry.new,

        :rest_in_commands  => Gtk::Entry.new,
        :rest_out_commands => Gtk::Entry.new,
        :rest_pre_commands => Gtk::Entry.new,
        :rest_room         => Gtk::Entry.new,
        :rest_scripts      => Gtk::Entry.new
    }

    Gtk.queue {
        update_disabled = proc {
            widgets[:location_widgets].each { |key, widget|
        if location.nil?
                    widget.set_sensitive(false)
                else
                    widget.set_sensitive(true)
                end
            }
        }

        populate_locations = proc {
            loop {
        break if not widgets[:gui_widgets][:locations].model.iter_first
                #widgets[:gui_widgets][:locations].remove_text(0)
        widgets[:gui_widgets][:locations].remove(0)
            }

            locations.keys.sort.each { |text|
        widgets[:gui_widgets][:locations].append_text(text)
            }

        }

        save_location = proc {
            widgets[:location_widgets].each { |key, widget|
                if widget.class == Gtk::CheckButton
                    value = widget.active?
                elsif [:skins, :targets, :boundaries].include?(key)
                    value = widget.text.strip.split(',').collect { |item| item.strip }
                else
                    value = widget.text.strip
                end

                locations[location][key] = value
            }
        }

        attach_signals = proc {
            widgets[:gui_widgets][:close].signal_connect 'clicked' do action = :close end
            widgets[:gui_widgets][:save].signal_connect 'clicked' do action = :save; save_location.call end
      @window.signal_connect('destroy') do action = :close end

###
### Something in here when clicking create kills the connection/exits the game
###

            widgets[:gui_widgets][:create].signal_connect 'clicked' do
                name = widgets[:gui_widgets][:new_name].text.strip

                if name.nil? or name.empty? or name == '' or name.length < 3
                    error.call('You need to enter a name!')
                elsif locations.keys.find { |n| n.downcase.strip == name.downcase.strip }
                    error.call 'A location with that name already exists!'
                else
                    locations[name] = {}
                    widgets[:gui_widgets][:new_name].text = ''
                    populate_locations.call
                    update_disabled.call
                end
            end

###
### Creation script end...
###

            widgets[:gui_widgets][:delete].signal_connect 'clicked' do
                Gtk.queue {
                    if widgets[:gui_widgets][:locations].active == -1
                        error.call 'You do not have a location selected!'
                    else
                        locations.delete(widgets[:gui_widgets][:locations].active_text)
                        widgets[:gui_widgets][:locations].remove(widgets[:gui_widgets][:locations].active)

                        widgets[:location_widgets].each { |key, widget|
                            if widget.class == Gtk::CheckButton
                                widget.active = (false)
                            else
                                widget.text = ("")
                            end
                        }
                    end
                }
            end

            widgets[:gui_widgets][:locations].signal_connect 'changed' do
                Gtk.queue {
                    save_location.call
                    location = widgets[:gui_widgets][:locations].active_text
                    if locations[location]
                        widgets[:location_widgets].each { |key, widget|
                            if widget.class == Gtk::CheckButton
                                widget.active = (!!locations[location][key])
                            elsif [:skins, :targets, :boundaries].include?(key)
                                widget.text = (locations[location][key].join(',')) if not (locations[location][key].nil?)
                            else
                                widget.text = (locations[location][key].strip)
                            end
                        }
                    end

                    update_disabled.call
                }
            end
        }

        # main window
        @window = Gtk::Window.new
        @window.border_width = 5
#        @window.keep_above = true  ## this setting prevents the modal ERROR dialog from appearing over it
        @window.resizable = true
        @window.resize 500, 300
        @window.set_window_position(:center)

        # main notebook (tabs)
        notebook = Gtk::Notebook.new
        notebook.show_border = true

        vbox_main = Gtk::Box.new(:vertical)
        vbox_main.pack_start notebook

        # BOUNTYHUNTER options
        vbox = Gtk::Box.new(:vertical)

        frm = Gtk::Frame.new('Locations').set_border_width(3)
        tbl = Gtk::Table.new(7, 4, true).set_border_width(3)

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('New name: ')), 0, 1, 0, 1
        tbl.attach widgets[:gui_widgets][:new_name], 1, 3, 0, 1
        tbl.attach widgets[:gui_widgets][:create], 3, 4, 0, 1

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Locations: ')), 0, 1, 1, 2
        tbl.attach widgets[:gui_widgets][:locations], 1, 3, 1, 2
        tbl.attach widgets[:gui_widgets][:delete], 3, 4, 1, 2

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Location: ')), 0, 1, 3, 4
        tbl.attach widgets[:location_widgets][:location], 1, 2, 3, 4
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Skins: ')), 2, 3, 3, 4
        tbl.attach widgets[:location_widgets][:skins], 3, 4, 3, 4

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Targets: ')), 0, 1, 4, 5
        tbl.attach widgets[:location_widgets][:targets], 1, 2, 4, 5

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Room #: ')), 0, 1, 5, 6
        tbl.attach widgets[:location_widgets][:room], 1, 2, 5, 6
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Boundaries: ')), 2, 3, 5, 6
        tbl.attach widgets[:location_widgets][:boundaries], 3, 4, 5, 6

        tbl.attach widgets[:location_widgets][:enable_hunting_rotation], 0, 1, 6, 7
        tbl.attach widgets[:location_widgets][:enable_bounty_only], 1, 2, 6, 7
        tbl.attach widgets[:location_widgets][:enable_search_only], 2, 3, 6, 7

        frm.add(tbl)
        vbox.pack_start(frm)

        frm = Gtk::Frame.new('Bounties').set_border_width(3)
        tbl = Gtk::Table.new(5, 4, true).set_border_width(3)

        tbl.attach widgets[:enable_cull], 0, 1, 0, 1; widgets[:enable_cull].active = $BOUNTYHUNTER[:enable_cull]
        tbl.attach widgets[:enable_dangerous], 1, 2, 0, 1; widgets[:enable_dangerous].active = $BOUNTYHUNTER[:enable_dangerous]
        tbl.attach widgets[:enable_rescue], 2, 3, 0, 1; widgets[:enable_rescue].active = $BOUNTYHUNTER[:enable_rescue]
        tbl.attach widgets[:enable_skin], 3, 4, 0, 1; widgets[:enable_skin].active = $BOUNTYHUNTER[:enable_skin]

        tbl.attach widgets[:enable_loot], 0, 1, 1, 2; widgets[:enable_loot].active = $BOUNTYHUNTER[:enable_loot]
        tbl.attach widgets[:enable_search], 1, 2, 1, 2; widgets[:enable_search].active = $BOUNTYHUNTER[:enable_search]
        tbl.attach widgets[:enable_forage], 2, 3, 1, 2; widgets[:enable_forage].active = $BOUNTYHUNTER[:enable_forage]
        tbl.attach widgets[:enable_bandit], 3, 4, 1, 2; widgets[:enable_bandit].active = $BOUNTYHUNTER[:enable_bandit]

        tbl.attach widgets[:enable_bandit_script], 1, 2, 2, 3; widgets[:enable_bandit_script].active = $BOUNTYHUNTER[:enable_bandit_script]
        tbl.attach widgets[:enable_expedite], 2, 3, 2, 3; widgets[:enable_expedite].active = $BOUNTYHUNTER[:enable_expedite]
        tbl.attach widgets[:enable_hunt_complete], 3, 4, 2, 3; widgets[:enable_hunt_complete].active = $BOUNTYHUNTER[:enable_hunt_complete]

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('turn in when mind >= ')), 0, 1, 3, 4
        tbl.attach widgets[:turn_in_percent], 1, 2, 3, 4; widgets[:turn_in_percent].text = ($BOUNTYHUNTER[:turn_in_percent].to_s)
        tbl.attach widgets[:enable_turn_in_bounty], 3, 4, 3, 4; widgets[:enable_turn_in_bounty].active = $BOUNTYHUNTER[:enable_turn_in_bounty]

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('hunting scripts:')), 2, 3, 4, 5
        tbl.attach widgets[:hunting_scripts], 3, 4, 4, 5; widgets[:hunting_scripts].text = ($BOUNTYHUNTER[:hunting_scripts].collect { |a| a.strip }.join(','))
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('bandit script:')), 0, 1, 4, 5
        tbl.attach widgets[:bandit_script], 1, 2, 4, 5; widgets[:bandit_script].text = ($BOUNTYHUNTER[:bandit_script])

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('pre-search commands: ')), 0, 1, 5, 6
        tbl.attach widgets[:pre_search_commands], 1, 2, 5, 6; widgets[:pre_search_commands].text = ($BOUNTYHUNTER[:pre_search_commands].collect { |a| a.strip }.join(','))
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('post-search commands: ')), 2, 3, 5, 6
        tbl.attach widgets[:post_search_commands], 3, 4, 5, 6; widgets[:post_search_commands].text = ($BOUNTYHUNTER[:post_search_commands].collect { |a| a.strip }.join(','))

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('pre-forage commands: ')), 0, 1, 6, 7
        tbl.attach widgets[:pre_forage_commands], 1, 2, 6, 7; widgets[:pre_forage_commands].text = ($BOUNTYHUNTER[:pre_forage_commands].collect { |a| a.strip }.join(','))
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('post-forage commands: ')), 2, 3, 6, 7
        tbl.attach widgets[:post_forage_commands], 3, 4, 6, 7; widgets[:post_forage_commands].text = ($BOUNTYHUNTER[:post_forage_commands].collect { |a| a.strip }.join(','))

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('forage retry delay: ')), 0, 1, 7, 8
        tbl.attach widgets[:forage_retry_delay], 1, 2, 7, 8; widgets[:forage_retry_delay].text = ($BOUNTYHUNTER[:forage_retry_delay].to_s)
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('loot script: ')), 2, 3, 7, 8
        tbl.attach widgets[:loot_script], 3, 4, 7, 8; widgets[:loot_script].text = ($BOUNTYHUNTER[:loot_script].to_s)

        frm.add(tbl)
        vbox.pack_start(frm)

        notebook.append_page vbox, Gtk::Label.new('Locations / Options')

        # default options
        vbox = Gtk::Box.new(:vertical)

        frm = Gtk::Frame.new('Should Rest').set_border_width(3)
        tbl = Gtk::Table.new(3, 4, true).set_border_width(3)

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('when mind % >= ')), 0, 1, 0, 1
        tbl.attach widgets[:should_rest_mind], 1, 2, 0, 1; widgets[:should_rest_mind].text = ($BOUNTYHUNTER[:should_rest_mind].to_s)
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('or mana <= ')), 2, 3, 0, 1
        tbl.attach widgets[:should_rest_mana], 3, 4, 0, 1; widgets[:should_rest_mana].text = ($BOUNTYHUNTER[:should_rest_mana].to_s)

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('or encumbrance % >= ')), 0, 1, 1, 2
        tbl.attach widgets[:should_rest_encum], 1, 2, 1, 2; widgets[:should_rest_encum].text = ($BOUNTYHUNTER[:should_rest_encum].to_s)

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('or wounded eval: ')), 0, 1, 2, 3
        tbl.attach widgets[:should_rest_wounded], 1, 4, 2, 3; widgets[:should_rest_wounded].text = ($BOUNTYHUNTER[:should_rest_wounded]._dump)

        frm.add(tbl)
        vbox.pack_start(frm)

        frm = Gtk::Frame.new('Resting').set_border_width(3)
        tbl = Gtk::Table.new(2, 4, true).set_border_width(3)

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('room #: ')), 0, 1, 0, 1
        tbl.attach widgets[:rest_room], 1, 2, 0, 1; widgets[:rest_room].text = ($BOUNTYHUNTER[:rest_room].to_s)
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('pre-rest commands: ')), 2, 3, 0, 1
        tbl.attach widgets[:rest_pre_commands], 3, 4, 0, 1; widgets[:rest_pre_commands].text = ($BOUNTYHUNTER[:rest_pre_commands].collect { |a| a.strip }.join(','))

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('enter commands: ')), 0, 1, 1, 2
        tbl.attach widgets[:rest_in_commands], 1, 2, 1, 2; widgets[:rest_in_commands].text = ($BOUNTYHUNTER[:rest_in_commands].collect { |a| a.strip }.join(','))
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('exit commands: ')), 2, 3, 1, 2
        tbl.attach widgets[:rest_out_commands], 3, 4, 1, 2; widgets[:rest_out_commands].text = ($BOUNTYHUNTER[:rest_out_commands].collect { |a| a.strip }.join(','))

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('scripts: ')), 0, 1, 2, 3
        tbl.attach widgets[:rest_scripts], 1, 4, 2, 3; widgets[:rest_scripts].text = ($BOUNTYHUNTER[:rest_scripts].collect { |a| a.strip }.join(','))

        frm.add(tbl)
        vbox.pack_start(frm)

        frm = Gtk::Frame.new('Should Hunt').set_border_width(3)
        tbl = Gtk::Table.new(2, 4, true).set_border_width(3)

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('when mind % <= ')), 0, 1, 0, 1
        tbl.attach widgets[:should_hunt_mind], 1, 2, 0, 1; widgets[:should_hunt_mind].text = ($BOUNTYHUNTER[:should_hunt_mind].to_s)
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('and mana >= ')), 2, 3, 0, 1
        tbl.attach widgets[:should_hunt_mana], 3, 4, 0, 1; widgets[:should_hunt_mana].text = ($BOUNTYHUNTER[:should_hunt_mana].to_s)

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('and spirit >= ')), 0, 1, 1, 2
        tbl.attach widgets[:should_hunt_spirit], 1, 2, 1, 2; widgets[:should_hunt_spirit].text = ($BOUNTYHUNTER[:should_hunt_spirit].to_s)

        frm.add(tbl)
        vbox.pack_start(frm)

        frm = Gtk::Frame.new('Hunting').set_border_width(3)
        tbl = Gtk::Table.new(2, 4, true).set_border_width(3)

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Pre-hunt commands: ')), 0, 1, 0, 1
        tbl.attach widgets[:hunt_pre_commands], 1, 2, 0, 1; widgets[:hunt_pre_commands].text = ($BOUNTYHUNTER[:hunt_pre_commands].collect { |a| a.strip }.join(','))

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Commands (a): ')), 2, 3, 0, 1
        tbl.attach widgets[:hunt_commands_a], 3, 4, 0, 1; widgets[:hunt_commands_a].text = ($BOUNTYHUNTER[:hunt_commands_a].collect { |a| a.strip }.join(',')).to_s

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Commands (b): ')), 0, 1, 1, 2
        tbl.attach widgets[:hunt_commands_b], 1, 2, 1, 2; widgets[:hunt_commands_b].text = ($BOUNTYHUNTER[:hunt_commands_b].collect { |a| a.strip }.join(',')).to_s

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Commands (c): ')), 2, 3, 1, 2
        tbl.attach widgets[:hunt_commands_c], 3, 4, 1, 2; widgets[:hunt_commands_c].text = ($BOUNTYHUNTER[:hunt_commands_c].collect { |a| a.strip }.join(',')).to_s

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Commands (d): ')), 0, 1, 2, 3
        tbl.attach widgets[:hunt_commands_d], 1, 2, 2, 3; widgets[:hunt_commands_d].text = ($BOUNTYHUNTER[:hunt_commands_d].collect { |a| a.strip }.join(',')).to_s

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Commands (e): ')), 2, 3, 2, 3
        tbl.attach widgets[:hunt_commands_e], 3, 4, 2, 3; widgets[:hunt_commands_e].text = ($BOUNTYHUNTER[:hunt_commands_e].collect { |a| a.strip }.join(',')).to_s
	
		
        frm.add(tbl)
        vbox.pack_start(frm)

        notebook.append_page vbox, Gtk::Label.new('Resting / Hunting')

        # main window widgets
        vbox = Gtk::Box.new(:vertical)
    valign = Gtk::Alignment.new(0, 1, 0, 0)
        vbox.pack_start(valign, :expand => false, :fill => false, :padding => 0)

        hbox = Gtk::Box.new(:horizontal)
        hbox.add widgets[:gui_widgets][:save]
        hbox.add widgets[:gui_widgets][:close]

        halign = Gtk::Alignment.new 1, 0, 0, 0
        halign.add hbox

        vbox.pack_start halign
        vbox_main.pack_start vbox

        # create the window
        attach_signals.call
        update_disabled.call
        populate_locations.call

        @window.add vbox_main
        @window.show_all
    }

###
### This line prevents the top right corner "X" from properly closing the gui
###

    before_dying { Gtk.queue { @window.destroy unless @window.destroyed? } }

###
### Why? I don't know...
###

    sleep 0.10 while action.nil?

    case action
        when :save
            $BOUNTYHUNTER[:locations] = locations

            widgets.each { |key, widget|
                next if [:location_widgets, :gui_widgets].include?(key)
                if widget.class == Gtk::CheckButton
                    value = widget.active?
                elsif [:hunting_scripts, :pre_forage_commands, :post_forage_commands, :pre_search_commands, :post_search_commands, :hunt_pre_commands, :hunt_commands_a, :hunt_commands_b, :hunt_commands_c, :hunt_commands_d, :hunt_commands_e, :rest_in_commands, :rest_out_commands, :rest_pre_commands, :rest_scripts].include?(key)
                    value = widget.text.strip.split(',').collect { |item| item.strip }
                elsif key == :should_rest_wounded
                    value = StringProc.new widget.text.strip
                else
                    value = widget.text.strip
                end

                $BOUNTYHUNTER[key] = value
            }
    end
}

change_stance = proc { |stance|
    return if Spell['Zealot'].active? or Spell['Frenzy'].active? or dead?

    while (cur_stance = checkstance) != stance
        res = dothistimeout "stance #{stance}", 2, /You are now|Roundtime|Wait|wait|Your rage causes you/
        if res =~ /Roundtime: (\d+)|wait (\d+)/i
            d = ($1 || $2).strip.to_f - 1
            if d > 0
                sleep (d)
            end
        elsif res =~ /Your rage causes you/
            Spell['Frenzy'].putup
            Spell['Frenzy'].timeleft = 30
        elsif cur_stance == 'guarded' and stance == 'defensive'
            break
        end
    end
}

kneel = proc {
    while true
        break if kneeling?
        waitrt?
        put 'kneel'
        sleep 0.50
    end
}

stand = proc {
    while true
        break if standing?
        waitrt?
        put 'stand'
        sleep 0.50
    end
}

error = proc { |msg|
    echo "** #{msg}"
    exit
}

print = proc { |msg|
    echo "-- #{msg}"
}

clean_skin = proc { |name|
    name.strip.downcase.gsub(/s$/, '').gsub(/teeth/, 'tooth').gsub(/hooves?/, 'hoof')
}

has_skins = proc {
    if bounty? =~ /#{bounty_patterns['task_skin']}/
        count = $1.to_i
        skin  = $2.downcase

        skinsack.contents.find_all { |item| item.name =~ /#{clean_skin.call(skin)}/i }.size >= (count + 3)
    else
        false
    end
}

is_bounty = proc { |types|
    result = []
  if types.class != Array
    types = [types]
  end
    types.each { |type| result.push(bounty_patterns[type]) if not bounty_patterns[type].nil? }

    !(bounty? =~ /#{result.join('|')}/).nil?
}

get_bounty_location = proc { |location, target|
    if location.nil?
        # remove search only locations for hunting areas
        locations = $BOUNTYHUNTER[:locations].dup
        if is_bounty.call ['task_skin', 'task_heirloom', 'task_dangerous', 'task_cull', 'task_rescue']
            locations.delete_if { |name, data| data[:enable_search_only] }
        end

        if bounty? =~ /#{bounty_patterns['task_skin']}/
            # remember: don't swap the order or the global $ vars are lost!
            target   = $3.strip.downcase
            skin     = clean_skin.call($2)
            location = locations.find { |name, data| $BOUNTYHUNTER_CLEAN_TARGETS.call(data[:targets]).find { |t| target =~ /#{t}/i } and data[:skins].find { |s| skin =~ /#{s.strip.downcase}/i }}
        else
            bounty_patterns.each { |key,value|
                if bounty? =~ /#{value}/i
                    target   = $1
                    location = $2

                    break
                end
            }

            location = location.downcase.strip
            location = locations.find { |name, data|
                cleaned = $BOUNTYHUNTER_CLEAN_TARGETS.call(data[:targets])
                location =~ /#{data[:location].strip}/i and cleaned.find {
                    |t| target =~ /#{t}/i
                }
            }
        end
    end

    if location
        name = location[0].dup
        data = location[1].to_hash.dup

        if target
            targets = data[:targets].dup
            cleaned = $BOUNTYHUNTER_CLEAN_TARGETS.call(data[:targets])
            target_key = nil

            # see if they have a provoked ancient/grizzled line
            if is_bounty.call 'task_provoked'
                target_key = cleaned.find { |t|
                    t =~ /ancient|grizzled/ and (
                        "ancient #{target}" =~ /#{t}/i or
                        "grizzled #{target}" =~ /#{t}/i
                    )
                }
            end

            # regular bounties
            if target_key.nil?
                target_key = cleaned.find { |t| target =~ /#{t}/i }
            end

            index = cleaned.index(target_key)
            target = targets[index]

            if is_bounty.call 'task_provoked'
                # add the ancient|grizzled for them
                if target !~ /ancient|grizzled/i
                    new_target = target.gsub(cleaned[index], "(?:ancient|grizzled).*#{cleaned[index]}")
                    targets[target.index(target)] = new_target
                    target = new_target
                end
            end
        end

        if data[:enable_bounty_only]
            targets = [ target ]
        end

        data[:targets] = targets

        [name, data]
    else
        print.call 'could not find bounty location'
        nil
    end
}

get_herb_rooms = proc { |location, herb|
    target_list = Array.new
    names = [herb]

    if herb == 'ayana leaf'
        names = [herb, 'ayana leaf', 'ayana lichen', 'ayana weed', 'ayana berry', 'ayana root']
    elsif herb == "ayana'al leaf"
        names = [herb, 'ayana\'al leaf', 'ayana\'al lichen', 'ayana\'al weed', 'ayana\'al berry', 'ayana\'al root']
	elsif herb == "small primrose"
		names = [herb, 'small primrose']
    end

    Room.list.each { |room|
        if room.tags.find { |tag| names.find { |name| tag =~ /#{name}/i } }
            target_list.push(room.id)
        end
    }

    previous, shortest_distances = Map.dijkstra(Room.current.id)

    if location
        # delete the room if it's not the correct location
        target_list.delete_if { |room_num|
            if Room[room_num].location.nil?
                Room[room_num].title[0] !~ /#{location}/i
            elsif not Room[room_num].location.nil?
                Room[room_num].location !~ /#{location}/i
            else
                false
            end
        }
    end

    if target_list.length == 0
        similar = Room.tags.find_all { |tag| tag =~ /#{herb}/i }

        if not similar.empty?
            herb = similar.join(', ')
            Room.list.each { |room| target_list.push(room.id) if room.tags.include?(herb) }

            previous, shortest_distances = Map.dijkstra(Room.current.id)

            if location
                target_list.delete_if { |room_num| (Room[room_num].location == nil && Room[room_num].title[0] !~ /#{location}/i) }
                target_list.delete_if { |room_num| (Room[room_num].location != nil && Room[room_num].location !~ /#{location}/i) }
            end
        end
    end

    previous, shortest_distances = Map.dijkstra($BOUNTYHUNTER[:rest_room])
    target_list.delete_if { |room| shortest_distances[room].nil? or shortest_distances[room] > 600 }
}

can_turn_in = proc {
    is_bounty.call ['success', 'success_guard', 'success_heirloom'] and (
        $BOUNTYHUNTER[:turn_in_percent].nil? or
        $BOUNTYHUNTER[:enable_turn_in_bounty] and not Spell['Next Bounty'].active? or
        percentmind >= $BOUNTYHUNTER[:turn_in_percent].to_i and checkmind !~ /saturated/
    )
}

can_do_bounty = proc {
    if not can_do_bounty_cache.nil?
        ; # intentionally left blank
    elsif is_bounty.call ['success', 'success_heirloom', 'success_guard']
        can_do_bounty_cache = true
    elsif is_bounty.call ['task_bandit'] and $BOUNTYHUNTER[:enable_bandit] and bounty? !~ /Locksmehr Trail/
        can_do_bounty_cache = true
    elsif ((is_bounty.call 'task_search' and $BOUNTYHUNTER[:enable_search] and get_bounty_location.call) or (is_bounty.call 'task_heirloom' and $BOUNTYHUNTER[:enable_loot] and get_bounty_location.call))
        can_do_bounty_cache = true
    elsif bounty? =~ /#{bounty_patterns['task_forage']}/ and $BOUNTYHUNTER[:enable_forage] and not get_herb_rooms.call($2, $1).empty? and bounty? !~ /green fleshbulb/
        can_do_bounty_cache = true
        # and bounty? !~ /exceptional|outstanding|superb|magnificent/
    elsif is_bounty.call 'task_skin' and $BOUNTYHUNTER[:enable_skin] and get_bounty_location.call
        can_do_bounty_cache = true
    elsif is_bounty.call ['task_provoked', 'task_dangerous'] and $BOUNTYHUNTER[:enable_dangerous] and get_bounty_location.call
        can_do_bounty_cache = true
    elsif is_bounty.call 'task_cull' and $BOUNTYHUNTER[:enable_cull] and get_bounty_location.call
        can_do_bounty_cache = true
    elsif (is_bounty.call 'task_escort' and $BOUNTYHUNTER[:enable_rescue]) or (is_bounty.call 'task_rescue' and $BOUNTYHUNTER[:enable_rescue] and get_bounty_location.call)
        can_do_bounty_cache = true
    else
        can_do_bounty_cache = false
    end

    $BOUNTYHUNTER_can_do_bounty = can_do_bounty_cache

    can_do_bounty_cache
}

should_hunt = proc {
  res = false

  if is_bounty.call ['success', 'success_heirloom', 'success_guard'] and not can_turn_in.call
    res = true
    # on start if less than numb then always try to do bounty
	#HACK
	elsif (can_do_bounty.call and percentmind > $BOUNTYHUNTER[:should_hunt_mind].to_i and not saturated? and first_run)
		echo percentmind
		echo $BOUNTYHUNTER[:should_hunt_mind].to_i
		echo saturated?
		echo first_run
#    elsif (can_do_bounty.call and not fried? and not saturated? and first_run)
        res = true
    elsif (not can_do_bounty.call or is_bounty.call ['success', 'success_heirloom', 'success_guard'] or not $BOUNTYHUNTER[:enable_hunt_complete]) and percentmind > $BOUNTYHUNTER[:should_hunt_mind].to_i
        hunt_reason = 'mind not clear enough'
        ;
    elsif not checkmana($BOUNTYHUNTER[:should_hunt_mana].to_i)
        hunt_reason = 'out of mana'
        ;
    elsif not checkspirit($BOUNTYHUNTER[:should_hunt_spirit].to_i)
        hunt_reason = 'low spirit'
        ;
    else
        res = true
    end

  res
}

should_rest = proc {
    if $BOUNTYHUNTER[:should_rest_wounded].call
        rest_reason = 'wounded'
        true
    elsif $BOUNTYHUNTER_rest
        if $BOUNTYHUNTER_rest_reason
            rest_reason = $BOUNTYHUNTER_rest_reason
        else
            rest_reason = '$BOUNTYHUNTER_rest was set'
        end

        if $BOUNTYHUNTER_rest_until
            if Time.now.to_i > $BOUNTYHUNTER_rest_until
                $BOUNTYHUNTER_rest = false
                $BOUNTYHUNTER_rest_reason = nil
                $BOUNTYHUNTER_rest_until = nil
            end
        else
            $BOUNTYHUNTER_rest = false
            $BOUNTYHUNTER_rest_reason = nil
        end

        true
    elsif not checkmana($BOUNTYHUNTER[:should_rest_mana].to_i)
        rest_reason = 'out of mana'
        true
    elsif checkencumbrance($BOUNTYHUNTER[:should_rest_encum].to_i)
        rest_reason = 'encumbered'
        true
    elsif is_bounty.call 'task_provoked'
        false
    elsif is_bounty.call 'task_forage' and can_do_bounty.call and Time.now.to_i < last_forage_attempt + last_forage_delay and percentmind >= $BOUNTYHUNTER[:should_rest_mind].to_i
        rest_reason = 'mind is full (waiting on foraging cooldown)'
        true
    elsif ((not can_turn_in.call and is_bounty.call ['success', 'success_guard', 'success_heirloom']) or not can_do_bounty.call or not $BOUNTYHUNTER[:enable_hunt_complete]) and percentmind >= $BOUNTYHUNTER[:should_rest_mind].to_i
        rest_reason = 'mind is full'
        true
    else
        rest_reason = nil
        false
    end
}

wander = proc { |boundaries|
  room = Room.current
  next_room_options = room.wayto.keys - boundaries
  next_room_options.delete_if { |room_id| (room.timeto[room_id].class == Proc) and room.timeto[room_id].call.nil? }
  next_room = next_room_options.find_all { |r| not $BOUNTYHUNTER_wander_rooms.include?(r) }
  if next_room.empty?
    next_room = $BOUNTYHUNTER_wander_rooms.find { |r| next_room_options.include?(r) }
  else
    next_room = next_room[rand(next_room.length)]
  end
  $BOUNTYHUNTER_wander_rooms.delete(next_room)
  $BOUNTYHUNTER_wander_rooms.push(next_room)
  way = room.wayto[next_room]
  if way.class == String
    move(way)
  else
    way.call
  end
}


######################################################################################

#My personal additions to add in teleportation.

def activate_teleporter
		result = dothistimeout "rub my #{Vars.teleporter}", 2, /Suddenly, your (.*) spouts thick clouds of fog./
		if result =~ /Suddenly, your (.*) spouts thick clouds of fog./
		end
end

def teleport_to_willow
	pause_script("go2") if Script.running?("go2")
	if Char.name =~ /Alastir/
		waitrt?
		multifput 'get veil amulet from my harness','wear my veil amulet'
		fput "twist my #{Vars.teleporter} to 0" #Willow
		activate_teleporter
		multifput 'remove my veil amulet','put my veil amulet in my harness'
		sleep 0.1
	end
	kill_script("go2") if Script.running?("go2")
end

def leave_OTF
	pause_script("go2") if Script.running?("go2")
	if Char.name =~ /Alastir/
		if $mount_active == true
			start_script "go2", ['11968']
			wait_while { running? 'go2' }
				fput "store all"
				fput "get my reins"
				fput "wave my reins"
				mount_count = 0
				loop {
					result = dothistimeout "mount stallion", 15, /You cannot do that while you're in combat.|You affix your reins/
					if result =~ /You cannot do that while you're in combat./
						sleep 1
						mount_count += 1
						#fput "mount stallion"
					elsif result =~ /You affix your reins/
#						respond "#{mount_count}"
						break
					end
				}
				fput "mount travel return"
				fput "mount travel return"
				waitfor "You ease the reins of your white stallion as you canter toward your destination.","You ease the reins as your white stallion canters toward your destination."
				fput "dismount"
				fput "dismiss stallion"
				fput "put my reins in my harness"
				$mount_active = false
		else
			waitrt?
			multifput 'get my veil amulet','wear my veil amulet'
			fput "twist my #{Vars.teleporter} to 3" #Ta'Faendryl Approach
			activate_teleporter
			multifput 'remove my veil amulet','put my veil amulet in my harness'
			sleep 0.1
			#waitfor "Ta'Faendryl Approach"
				kill_script("go2") if Script.running?("go2")
				wait_while { running? 'go2' }
				start_script "go2", ['10835']
					waitfor "Gyldemar Road, Sentinels"
					teleport_to_willow
		end
	end
	kill_script("go2") if Script.running?("go2")
end

def go2_willow
	if Char.name =~ /Alastir/
		if checkarea =~ /Old Ta'Faendryl|Tiny Cottage|Cottage Garden|Lake|Aqueduct|Basilica|Dry Ring Pool/
			leave_OTF
		elsif checkarea =~ /Whistler's Pass|Sylvarraend Road|Gyldemar Road/
			teleport_to_willow
		end
	end
end

def go2_willow_rest
	if Char.name =~ /Alastir/
		#							#Bank					   #Gemshop				  	 #Furrier				   #Herbalist
		if checkarea =~ /Ta'Illistim|United Bank of City-States|Tanzania's Gems & Jewelry|Gaedrein's Furs and Pelts|Valina's Herbs and Tinctures/i
			teleport_to_willow
		elsif checkarea =~ /Old Ta'Faendryl|Tiny Cottage|Cottage Garden|Lake/
			leave_OTF
		elsif checkarea =~ /Whistler's Pass|Sylvarraend Road|Gyldemr Road/
			teleport_to_willow
		end
	end
end

#Personal addition to use urchin guides to teleport between locations.

urchin_guide = proc { |tag|
		start_script "go2", ['26906'] if checkarea =~ /Journey's End/i
		wait_while { running? 'go2' }
			fput "urchin guide #{tag}" if checkarea =~ /Ta'Illistim|Journey's End|United Bank of City-States|Tanzania's Gems & Jewelry|Gaedrein's Furs and Pelts|Valina's Herbs and Tinctures/i
		sleep 0.1
	}

#Personal addition to check the status of a hurled weapon.

def hurl_status
	if $frontend == 'stormfront'
		fam_window_begin = "<pushStream id=\"death\" ifClosedStyle=\"watching\"/>"
		fam_window_end   = "<popStream/>\r\n"
	end
	if Char.prof == 'Warrior'
		if $weapon_lost == true
			wait_while {$weapon_lost == true}
			puts("#{fam_window_begin} *!* Recovered Weapon *!*\r\n #{fam_window_end}")
		elsif $weapon_lost == false
			nil
		end
	end	
end

######################################################################################

=begin Original
go2 = proc { |room|
    next if Room.current.id.to_s == room.to_s

    if checkarea =~ /Table/
    if room.to_s == $BOUNTYHUNTER[:rest_room].to_s
      next
    end

        stand.call()
        move 'out'
    end

    wait_while { running? 'go2' }
    start_script('go2', [ room.to_s, '_disable_confirm_' ], h={:quiet=>true});
    wait_while { running? 'go2' }
}
=end

go2 = proc { |room|
    next if Room.current.id.to_s == room.to_s

	if room.to_s == 25987
		go2_willow_rest
	end

	if room.to_s == 26833
		go2_willow_rest
	end

    if checkarea =~ /Table/
		if room.to_s == CharSettings[:rest_room].to_s
			next
		end

        fput 'stand' until standing?
        move 'out'
    end

    Script.run('go2',room.to_s)
}

go2_nearest = proc { |list|
    room = Room[$BOUNTYHUNTER[:rest_room]].find_nearest(list)
    if room.nil?
        error.call "failed to find nearest room"
    end

    go2.call(room)
}

=begin Original
go2_nearest_tag = proc { |tag|
    if checkarea =~ /Table/i
        stand.call()
        fput 'out'
    end

    town = Room[$BOUNTYHUNTER[:rest_room]].find_nearest_by_tag('town')
    room = Room[town].find_nearest_by_tag(tag)

    if room.nil?
        error.call "failed to find room by tag: #{tag}"
    end

    go2.call(room)
}
=end

go2_nearest_tag = proc { |tag|
    if checkarea =~ /Table/i
        fput 'stand' until standing?
        fput 'out'
    end
	
	#HACK
	go2_willow unless Room.current.id == 13048 or 1439 or 4019 or 37 or checkarea =~ /Ta'Illistim/

    town = Room[CharSettings[:rest_room]].find_nearest_by_tag('town')
    room = Room[town].find_nearest_by_tag(tag)
    if room.nil?
        error.call "failed to find room by tag: #{tag}"
    end

	#HACK 11/2/2020
	urchin_guide.call('room')

    go2.call(room)
}

run_commands = proc { |commands|
    next if commands.empty?

    if commands.class != Array
        error.call "run_commands expects an input Array"
    end

    commands.each { |command|
        if command[0] == ';'
            scriptname = command[1..-1]
            start_script scriptname
            wait_while { running? scriptname }
        else
            fput command
        end
    }
}

run_scripts = proc { |scripts|
    scripts.each { |script|
        args   = script.split(' ')
        script = args.shift

        start_script(script, args, true)
        wait_while { running? script }
    }
}

run_loot_script = proc {
    wait_while { running? $BOUNTYHUNTER[:loot_script] }
    start_script($BOUNTYHUNTER[:loot_script], [], true)
    wait_while { running? $BOUNTYHUNTER[:loot_script] }
}

hunt_prepare = proc {
    run_commands.call($BOUNTYHUNTER[:hunt_pre_commands]) 	#Pre-hunt commands
}

start_hunting_scripts = proc {
    $BOUNTYHUNTER[:hunting_scripts].each { |script|
        start_script(script, [], h={:quiet=>true}) if not running?(script)
    }
}

kill_hunting_scripts = proc {
    $BOUNTYHUNTER[:hunting_scripts].each { |script|
        stop_script(script) if running?(script)
    }
}

=begin Original
rest_goto = proc {
    next if in_rest_area
    go2.call($BOUNTYHUNTER[:rest_room])
}
=end

rest_goto = proc {
    next if in_rest_area

	#HACK - Attempts to teleport back.
	go2_willow_rest
	
    go2.call(CharSettings[:rest_room])
}

rest_exit = proc {
    next unless in_rest_area
    if Room.current.id != $BOUNTYHUNTER[:rest_room] and Room.current.path_to($BOUNTYHUNTER[:rest_room]).nil?
    run_commands.call($BOUNTYHUNTER[:rest_out_commands])  	 #Exit Commands
    end
    in_rest_area = false
}

rest_enter = proc {
    next if in_rest_area
    if Room.current.id != $BOUNTYHUNTER[:rest_room] and Room.current.path_to($BOUNTYHUNTER[:rest_room]).nil?
        run_commands.call($BOUNTYHUNTER[:rest_in_commands]) 	#Enter Commands
    end
    in_rest_area = true
}

rest_run_scripts = proc {
    rest_exit.call
    run_scripts.call($BOUNTYHUNTER[:rest_scripts])
}

=begin Original
reload_hunter = proc {
    $BOUNTYHUNTER_HUNTER_SETUP.call($BOUNTYHUNTER.to_hash.dup, get_bounty_location.call)
    $BOUNTYHUNTER_HUNTER_RELOAD.call
}

start_hunter = proc { |location|
    $BOUNTYHUNTER_HUNTER_SETUP.call($BOUNTYHUNTER.to_hash.dup, location)
    $BOUNTYHUNTER_CURRENT_LOCATION = location
    start_script($BOUNTYHUNTER_HUNTER_NAME, [], false)
}
=end

reload_hunter = proc {
	#HACK
	hurl_status
	
    $BOUNTYHUNTER_HUNTER_SETUP.call(CharSettings.to_hash.dup, get_bounty_location.call)
    $BOUNTYHUNTER_HUNTER_RELOAD.call
}

start_hunter = proc { |location|
    $BOUNTYHUNTER_HUNTER_SETUP.call(CharSettings.to_hash.dup, location)
#	echo 'BOUNTYHUNTER IS CALLING EXPLORER'
#	echo 'BOUNTYHUNTER IS CALLING EXPLORER'
#	echo 'BOUNTYHUNTER IS CALLING EXPLORER'
#	echo 'BOUNTYHUNTER IS CALLING EXPLORER'
#	echo 'BOUNTYHUNTER IS CALLING EXPLORER'
    start_script($BOUNTYHUNTER_HUNTER_NAME, [], false)
}

######################################################################

def change_stance( new_stance, force = true )
	return if Spell[1617].active? || Spell[216].active? || dead?
 
	if( stance() =~ /#{new_stance}/ )
		return
	elsif( checkcastrt() > 0 && new_stance =~ /def/ )
		return if stance() == 'guarded'
	end
 
	if(force)
		result = dothistimeout( "stance #{new_stance}", 3, /You are now in an?|Cast Round Time in effect|You are unable to change/ )
	else
		fput "stance #{new_stance}"
	end
end

######################################################################

=begin Original
finish_hunt = proc {
    if running? $BOUNTYHUNTER_HUNTER_NAME
        stop_script($BOUNTYHUNTER_HUNTER_NAME)
        wait_while { running? $BOUNTYHUNTER_HUNTER_NAME }
    end

    stop_script 'go2' if running? 'go2'
    change_stance.call('defensive')

    # pause to make sure looter isn't running
    wait_while { running? $BOUNTYHUNTER[:loot_script] }

    # run loot script in case the hunter wasn't able to clean up
    if GameObj.npcs.find { |npc| npc.status =~ /dead/ } or is_bounty.call 'success_heirloom'
        run_loot_script.call
    end
}

remove_bounty = proc {
    next if (not $BOUNTYHUNTER[:enable_expedite] and Spell['Next Bounty'].active?) or is_bounty.call 'none'

    rest_exit.call

    kill_script 'go2' if running? 'go2'

    go2_nearest_tag.call('advguild')

    print.call 'removing bounty, you have five seconds to kill me'
    sleep 5.00

    npc = GameObj.npcs.find { |t| t.name =~ /taskmaster/i }
    if npc.nil?
        error.call 'failed to find taskmaster'
    end

    res = dothistimeout "ask #{npc} about remove", 5, /^#{npc}.*?want to be removed|Trying to sneak/
    if res =~ /Trying to sneak/
        fput "ask #{npc} about bounty"
    else
        dothistimeout "ask #{npc} about remove", 5, /^#{npc}.*?have removed you/
    end

    can_do_bounty_cache = nil
}

expedite_bounty = proc {
    print.call 'expediting bounty, you have five seconds to kill me'
    sleep 5.00

    remove_bounty.call

    rest_exit.call
    go2_nearest_tag.call('advguild')

    npc = GameObj.npcs.find { |t| t.name =~ /taskmaster/i }
    if npc.nil?
        error.call 'failed to find taskmaster'
    end

    res = dothistimeout "ask #{npc} about expedite", 5, /I'll expedite|You don't seem to have any expedited task reassignment|I still need to complete/
    if res =~ /expedited/
        expedite_left = false
    end

    can_do_bounty_cache = nil
}

get_bounty = proc {
    rest_exit.call

    go2_nearest_tag.call('advguild')

    npc = GameObj.npcs.find { |t| t.name =~ /taskmaster/i }
    res = dothistimeout "ask ##{npc.id} for bounty", 2, /(?:protective escort|creature problem|local gem dealer|local furrier|lost heirloom|local healer|local herbalist|local alchemist|local resident|bandit problem|I'm kind of busy right now|I don't seem to have any)/

    if res.nil?
        error.call 'invalid response from taskmaster'
    elsif res =~ /in about (\d+) minutes|in about a minute/
        time = $1.nil? ? 1 : $1.to_i

        Spell['Next Bounty'].putup
        Spell['Next Bounty'].timeleft = time
    elsif res =~ /but I don't seem to have/
        Spell['Next Bounty'].putup
        Spell['Next Bounty'].timeleft = 9999
    elsif res =~ /bandit/
        remove_bounty.call
    end

    can_do_bounty_cache = nil
}

talk_to_herbalist = proc {
    go2_nearest.call([ 3824, 1851, 10396, 640, 5722, 2406, 11002, 9505 ])

    if Room.current.id == 10396
        npc = 'maraene'
    else
        npc = GameObj.npcs.find { |t| t.name =~ /brother Barnstel|scarred Agarnil kris|healer|herbalist|merchant Kelph|famed baker Leaftoe|Akrash|old Mistress Lomara/i }
    end

    if is_bounty.call 'help_herbalist'
        res = dothistimeout "ask #{npc} about bounty", 5, /Yes, I do have a task for you/
        if res =~ /I've recently received an order for ([0-9]+) (.*?)\./
            print.call "received bounty from herbalist [#{$1} #{$2}]"
        end
    elsif bounty? =~ /#{bounty_patterns['task_forage']}/
        herb_name = $1.gsub(/s?$/,'')
        herbs     = lootsack.contents.find_all { |item| item.name =~ /#{herb_name}/ }

        if herbs.empty?
            error.call 'no herbs to turn in, why are you here?'
        end

        prev_item = nil
        if GameObj.right_hand
            prev_item = GameObj.right_hand

            fput 'store right' if checkright
            fput 'stow right' if checkright
        end

        herbs.each { |herb|
            fput "get ##{herb.id} from ##{lootsack.id}"
            result = dothistimeout "give ##{herb.id} to #{npc}", 3, /This looks perfect|That looks like it has been partially used up/

            if result !~ /perfect/
                fput "drop ##{herb.id}"
            end
        }

        if prev_item
            fput "get ##{prev_item.id}"
        end
    else
        error.call 'why are you at the herbalist?'
    end
}

talk_to_gemdealer = proc {
    go2_nearest_tag.call('gemshop')

    if Room.current.id == 10327
        npc = 'areacne'
    else
        npc = GameObj.npcs.find { |t| t.name =~ /dwarven clerk|gem dealer|jeweler|Zirconia/i }
    end

    res = dothistimeout "ask #{npc} about bounty", 5, /Yes, I do have a task for you/
    if res =~ /interested in purchasing an? (.*?)\. .* go round up ([0-9]+) of them/
        name  = $1
        count = $2.to_i

        print.call "-- received bounty from gem dealer [#{count} #{name}]"
    end
}

talk_to_furrier = proc {
    go2_nearest_tag.call('furrier')

    if Room.current.id == 10327
        npc 'areacne'
    else
        npc = GameObj.npcs.find { |t| t.name =~ /dwarven clerk|furrier/i }
    end

    res = dothistimeout "ask #{npc} about bounty", 5, /Yes, I do have a task for you/
    if res =~ /I've recently received an order for ([0-9]+) (.*?)\./
        print.call "received bounty from furrier [#{$1} #{$2}]"
    end
}

get_guard_npc = proc {
    if Room.current.id == 10915
        'purser'
    else
        GameObj.npcs.find { |npc| npc.name =~ /guard|sergeant|guardsman|purser|Belle/i }
    end
}

find_guard = proc {
    go2_nearest_tag.call('advguard')
    npc = get_guard_npc.call

    if npc.nil?
        go2_nearest_tag.call('advguard2')
        npc = get_guard_npc.call
    end

    if npc.nil?
        error.call "failed to locate guard"
    end

    npc
}
=end

finish_hunt = proc {
    if running? $BOUNTYHUNTER_HUNTER_NAME
		#HACK
		hurl_status
		
        stop_script($BOUNTYHUNTER_HUNTER_NAME)
        wait_while { running? $BOUNTYHUNTER_HUNTER_NAME }
    end

    stop_script 'go2' if running? 'go2'
	change_stance('defensive')

    # pause to make sure looter isn't running
    wait_while { running? $BOUNTYHUNTER[:loot_script] }

    # run loot script in case the hunter wasn't able to clean up
    if GameObj.npcs.find { |npc| npc.status =~ /dead/ } or is_bounty.call 'success_heirloom'
        run_loot_script.call
    end

	#HACK
	if $frontend == 'stormfront'
		fam_window_begin = "<pushStream id=\"death\" ifClosedStyle=\"watching\"/>"
		fam_window_end   = "<popStream/>\r\n"
	end
	if Char.prof == /Warrior/
		if $weapon_lost == true
			wait_while {$weapon_lost == true}
			puts("#{fam_window_begin} *!* Recovered Weapon *!*\r\n #{fam_window_end}")
		elsif $weapon_lost == false
			nil
		end
	end
	
    # pause to make sure looter isn't running
    wait_while { running? CharSettings[:loot_script] }

    # run loot script in case the hunter wasn't able to clean up
    if GameObj.npcs.find { |npc| npc.status =~ /dead/ } or is_bounty.call 'success_heirloom'
		#HACK
		if $frontend == 'stormfront'
			fam_window_begin = "<pushStream id=\"death\" ifClosedStyle=\"watching\"/>"
			fam_window_end   = "<popStream/>\r\n"
		end
		if Char.prof == /Warrior/
			if $weapon_lost == true
				wait_while {$weapon_lost == true}
				puts("#{fam_window_begin} *!* Recovered Weapon *!*\r\n #{fam_window_end}")
			elsif $weapon_lost == false
				nil
			end
		end	
	
        run_loot_script.call
    end
}

remove_bounty = proc {
    next if (not CharSettings[:enable_expedite] and Spell['Next Bounty'].active?) or is_bounty.call 'none'

    rest_exit.call

    kill_script 'go2' if running? 'go2'

	#HACK
	go2_willow
	urchin_guide.call('bounty') unless Room.current.id == 13048
	sleep 0.3


    go2_nearest_tag.call('advguild') unless Room.current.id == 13048

    print.call 'removing bounty, you have five seconds to kill me'
    sleep 5.00

    npc = GameObj.npcs.find { |t| t.name =~ /taskmaster/i }
    if npc.nil?
        error.call 'failed to find taskmaster'
    end

	#Fail-safe so you don't turn in a completed bounty.
    fput "ask #{npc} about bounty"

    res = dothistimeout "ask #{npc} about remove", 5, /^#{npc}.*?want to be removed|Trying to sneak/
    if res =~ /Trying to sneak/
        fput "ask #{npc} about bounty"
    else
        dothistimeout "ask #{npc} about remove", 5, /^#{npc}.*?have removed you/
    end

    can_do_bounty_cache = nil
}

expedite_bounty = proc {
    print.call 'expediting bounty, you have five seconds to kill me'
    sleep 5.00

    remove_bounty.call

    rest_exit.call

	#HACK
	go2_willow
	urchin_guide.call('bounty') unless Room.current.id == 13048
	sleep 0.3

    go2_nearest_tag.call('advguild') unless Room.current.id == 13048

    npc = GameObj.npcs.find { |t| t.name =~ /taskmaster/i }
    if npc.nil?
        error.call 'failed to find taskmaster'
    end

    res = dothistimeout "ask #{npc} about expedite", 5, /I'll expedite|You don't seem to have any expedited task reassignment|I still need to complete/
    if res =~ /expedited/
        expedite_left = false
    end

    can_do_bounty_cache = nil
}

get_bounty = proc {
    rest_exit.call

	#HACK
	go2_willow
	urchin_guide.call('bounty') unless Room.current.id == 13048
	sleep 0.3

    go2_nearest_tag.call('advguild') unless Room.current.id == 13048

    npc = GameObj.npcs.find { |t| t.name =~ /taskmaster|Halfwhistle/i }
    res = dothistimeout "ask ##{npc.id} for bounty", 2, /(?:local halfling alchemist|protective escort|creature problem|local gem dealer|local furrier|lost heirloom|local healer|local herbalist|local alchemist|local resident|bandit problem|I'm kind of busy right now)/

    if res.nil?
        error.call 'invalid response from taskmaster'
    elsif res =~ /in about (\d+) minutes|in about a minute/
        time = $1.nil? ? 1 : $1.to_i

        Spell['Next Bounty'].putup
        Spell['Next Bounty'].timeleft = time
    elsif res =~ /bandit/
		#HACK
#		remove_bounty.call - Original
        remove_bounty.call unless CharSettings[:enable_bandit]
    end

    can_do_bounty_cache = nil
}

talk_to_herbalist = proc {

	#HACK
	go2_willow
	urchin_guide.call('healer')
	sleep 0.3

    go2_nearest.call([ 29876, 3824, 1851, 10396, 640, 5722, 2406, 11002, 9505 ]) unless Room.current.id == 640

    if Room.current.id == 10396
        npc = 'maraene'
    else
        npc = GameObj.npcs.find { |t| t.name =~ /balding halfling alchemist|brother Barnstel|scarred Agarnil kris|healer|herbalist|merchant Kelph|famed baker Leaftoe|Akrash|old Mistress Lomara/i }
    end

    if is_bounty.call 'help_herbalist'
        res = dothistimeout "ask #{npc} about bounty", 5, /Yes, I do have a task for you/
        if res =~ /I've recently received an order for ([0-9]+) (.*?)\./
            print.call "received bounty from herbalist [#{$1} #{$2}]"
        end
    elsif bounty? =~ /#{bounty_patterns['task_forage']}/
        herb_name = $1.gsub(/s?$/,'')
        herbs     = lootsack.contents.find_all { |item| item.name =~ /#{herb_name}/ }

        if herbs.empty?
            error.call 'no herbs to turn in, why are you here?'
        end

        prev_item = nil
        if GameObj.right_hand
            prev_item = GameObj.right_hand

            fput 'store right' if checkright
            fput 'stow right' if checkright
        end

        herbs.each { |herb|
            fput "get ##{herb.id} from ##{lootsack.id}"
            result = dothistimeout "give ##{herb.id} to #{npc}", 3, /This looks perfect|That looks like it has been partially used up/

            if result !~ /perfect/
                fput "drop ##{herb.id}"
			#Fail-safe so you don't have an extra herb in your hands.
			elsif result =~ /You've collected all the samples I asked for/
				empty_hands
            end
        }

        if prev_item
            fput "get ##{prev_item.id}"
        end
    else
        error.call 'why are you at the herbalist?'
    end
}

talk_to_gemdealer = proc {
    if bounty? =~ /Tanzania/
		if checkarea =~ /Cysaegir/
			go2.call(1439) #this fixes gem bounties in Illistim when your rest room is set in Cysaegir
		end
	end
	
	#HACK
	go2_willow
	urchin_guide.call('gemshop')
	sleep 0.1
	go2_nearest_tag.call('gemshop') unless Room.current.id == 1439
	
    if Room.current.id == 10327
        npc = 'areacne'
    else
        npc = GameObj.npcs.find { |t| t.name =~ /dwarven clerk|gem dealer|jeweler|Zirconia/i }
    end

    res = dothistimeout "ask #{npc} about bounty", 5, /Yes, I do have a task for you/
    if res =~ /interested in purchasing an? (.*?)\. .* go round up ([0-9]+) of them/
        name  = $1
        count = $2.to_i

        print.call "-- received bounty from gem dealer [#{count} #{name}]"
    end
}

talk_to_furrier = proc {
    if bounty? =~ /Gaedrein/
		if checkarea =~ /Cysaegir/
			go2.call(4019) #this fixes skin bounties in Illistim when your rest room is set in Cysaegir
		end
	end
	
	#HACK
	go2_willow
	urchin_guide.call('furrier')
	sleep 0.1

	go2_nearest_tag.call('furrier') unless Room.current.id == 4019

    if Room.current.id == 10327
        npc 'areacne'
    else
        npc = GameObj.npcs.find { |t| t.name =~ /dwarven clerk|furrier|Bramblefist/i }
    end

=begin
#Original
    res = dothistimeout "ask #{npc} about bounty", 5, /Yes, I do have a task for you/
    if res =~ /I've recently received an order for ([0-9]+) (.*?)\./
        print.call "received bounty from furrier [#{$1} #{$2}]"
    end
=end

    if is_bounty.call 'help_furrier'
		res = dothistimeout "ask #{npc} about bounty", 5, /Yes, I do have a task for you/
		if res =~ /I've recently received an order for ([0-9]+) (.*?)\./
			print.call "received bounty from furrier [#{$1} #{$2}]"
		end
    elsif bounty? =~ /#{bounty_patterns['task_skin']}/
        skin_name = $1.gsub(/s?$/,'')
		echo "#{skin_name}"
        skins     = lootsack.contents.find_all { |item| item.name =~ /#{skin_name}/ }

        if skins.empty?
            error.call 'no skins to turn in, why are you here?'
        end	

        prev_item = nil
        if GameObj.right_hand
            prev_item = GameObj.right_hand

            fput 'store right' if checkright
            fput 'stow right' if checkright
        end

        skins.each { |skin|
		
		if bounty? =~ /#{bounty_patterns['task_skin']}/
            fput "get ##{skin.id} from ##{lootsack.id}"
            result = dothistimeout "give ##{skin.id} to #{npc}", 3, /The furrier takes/
		else
			break
		end
        }
        
		if prev_item
            fput "get ##{prev_item.id}"
        end
    else
        error.call 'why are you at the furrier?'
    end	
	
}

get_guard_npc = proc {
    if Room.current.id == 10915
        'purser'
	elsif Room.current.id == 28978
		'Luthrek'
    else
        GameObj.npcs.find { |npc| npc.name =~ /guard|sergeant|guardsman|purser|Belle|Luthrek|tavernkeeper/i }
    end
}

find_guard = proc {

	#HACK
	go2_willow
	
	if Room.current.id == 13048 #Ta'Illistim, Alearyl Hall - Ta'Illistim Adventurer's Guild
		urchin_guide.call('guard')
		sleep 0.1
	end
	
	if Room.current.id == 26906 #Journey's End, Willow
		urchin_guide.call('guard')
		sleep 0.1
	end

    go2_nearest_tag.call('advguard') unless Room.current.id == 37
    npc = get_guard_npc.call

    if npc.nil?
        go2_nearest_tag.call('advguard2') unless Room.current.id == 37
        npc = get_guard_npc.call
    end

    if npc.nil?
        error.call "failed to locate guard"
    end

    npc
}

talk_to_guard = proc {
    npc = find_guard.call

    res = dothistimeout "ask #{npc} about bounty", 5, /Yes, we do have a task for you|Ah, so you have returned/
    if res.nil?
        print.call "unknown response from guard: #{res}"
    end
}

get_random_location = proc {
    keys = []
    $BOUNTYHUNTER[:locations].each { |key, data|
        if data[:enable_hunting_rotation]
            keys.push(key)
        end
    }
    name = keys[rand(keys.size)]

    if name.nil?
        error.call 'failed to find a hunting area'
    end

    [ name, $BOUNTYHUNTER[:locations][name] ]
}

task_escort = proc { |target|
    print.call "escorting child to #{target}"

    path  = []
    step2 = proc { |destination_room|
        unless path and (s = path.index(Room.current.id)) and (d = path.index(destination_room)) and (s < d)
            previous, shortest_distances = Map.dijkstra(Room.current.id, destination_room)
            unless previous[destination_room]
                echo "error: failed to find a path between your current room (#{Room.current.id}) and destination room (#{destination_room})"
                exit
            end
            path = [ destination_room ]
            path.push(previous[path[-1]]) until previous[path[-1]].nil?
            path.reverse!
            previous = shortest_distances = nil
        end

        way = Room.current.wayto[path[path.index(Room.current.id)+1].to_s]

        if way.class == String
            move way
        elsif way.class == Proc
            way.call
        end
    }

    waitrt?
    fput 'stance defensive' unless checkstance('guarded')

	#HACK - Not pulling from BOUNTYHUNTER yet to test if this works correctly.
    destination = Room[$BOUNTYHUNTER[:rest_room]].find_nearest_by_tag(target)
    while Room.current.id != destination and is_bounty.call 'task_escort'
        if GameObj.npcs.find { |n| n.name =~ /child/i }
            step2.call(destination)
        end
        sleep 0.25
    end

    if is_bounty.call 'fail_child'
        print.call 'failed to escort child or child was killed'
    elsif npc = get_guard_npc.call
        print.call 'waiting for child to arrive'
        wait_until { GameObj.npcs.find { |n| n.name =~ /child/ } }

    if npc.class == String
      fput "ask #{npc} for bounty"
    else
      fput "ask ##{npc.id} for bounty"
    end
    elsif target == 'advguard'
        task_escort.call 'advguard2'
    else
        error.call 'failed to find guard for escort'
    end
}

task_search = proc {
    if bounty? !~ /#{bounty_patterns['task_search']}/
        error.call 'you are not on a search bounty'
    end

    print.call 'searching for heirloom'

    name, location = get_bounty_location.call
    song_of_peace  = false
    invalid_rooms  = []
    last_room      = nil

    hunt_prepare.call
    rest_exit.call

    go2.call location[:room]

    start_hunting_scripts.call

    while is_bounty.call 'task_search' and not $BOUNTYHUNTER[:should_rest_wounded].call
        if Spell[1011].known? and Spell[1011].affordable? and not song_of_peace
            Spell[1011].cast
            song_of_peace = true
    elsif Spell[506].known? and Spell[506].affordable? and not Spell[506].active?
      Spell[506].cast
        end

        wander.call location[:boundaries]

        stand.call()
        change_stance.call('defensive')

        if (GameObj.npcs.empty? or GameObj.npcs.nil?) and Room.current.location =~ /#{location[:location].downcase.strip}/i and not invalid_rooms.include?(Room.current.id) and Room.current.id != last_room
            run_commands.call($BOUNTYHUNTER[:pre_search_commands])

            kneel.call()

            res = dothistimeout 'search', 1, /You intently search the area|You put your head to the/
            if res =~ /You intently search the area|You put your head to the/
                last_room = Room.current.id
            else
                print.call 'invalid room, skipping in the future'
                invalid_rooms.push Room.current.id
            end

            waitrt?

            run_commands.call $BOUNTYHUNTER[:post_search_commands]

            while not checkstance 'offensive' and (song_of_peace or GameObj.npcs.find_all { |npc| npc.type =~ /aggressive/ && npc.status !~ /dead|gone/ }.nil?)
                fput 'stance offensive'
        sleep 0.10
            end

            stand.call()
            change_stance.call('defensive')

            if is_bounty.call 'task_found'
                run_loot_script.call
                break
            end
        end
    end

    waitrt?

    if song_of_peace
        fput "stop 1011"
    end

    kill_hunting_scripts.call
}

task_bandit = proc {
    # You have been tasked to suppress bandit activity on the Icemule Trail between Wehnimer's Landing
    # and Icemule Trace.  You need to kill 4 more of them to complete your task.

    if $BOUNTYHUNTER[:enable_bandit_script] and not Script.exists?($BOUNTYHUNTER[:bandit_script])
        error.call('bandit script is enabled and could not be found')
    end

    if bounty? !~ /#{bounty_patterns['task_bandit']}/
        error.call('you are not on a bandits bounty')
    end

    location = $1.strip.downcase

 	if location =~ /Gyldemar Road|gyldemar road/
		rooms = Array[ '4611', '4708', '4709', '4710' ]
	elsif location =~ /Sylvarraend Road|sylvarraend road/
		rooms = Array[ '645', '646', '647', '648' ]
	elsif location =~ /Widowmaker's Road|widowmaker's road/
		rooms = Array [ '29021', '29022', '29023', '29024' ]
	elsif location =~ /Muddy Village|muddy village/
		rooms = Array [ '29047', '29049', '29060', '29066' ]
	elsif location =~ /Black Weald|black weald/
		rooms = Array [ '29227', '29228', '29227', '29230']
	elsif location =~ /Cliffwalk|cliffwalk/
		rooms = Array [ '29124', '29120', '29124', '29128']
	elsif location =~ /Whistler's Pass|whistler's pass/
		rooms = Array [ '44','45','46','47' ]
	else
		print.call('No rooms set for this location')
	    rooms = Room.list.find_all { |r| r.location =~ /#{location}/i }.collect { |r| r.id }
	end

    print.call('culling bandits')

    my_ambush = false
    ambush_room_count = XMLData.room_count
    start_hunting_scripts.call

	#HACK
	hunt_prepare.call
	start_hunting_scripts.call

    while not $BOUNTYHUNTER[:should_rest_wounded].call and is_bounty.call('task_bandit')
		rooms.each { |room|
        #get_rooms.call.each { |room|
            waitrt?
            waitcastrt?
			
            print.call 'moving to room ' + room.to_s
            go2.call(room)

			#HACK
			if Effects::Spells.to_h.include?('Tortoise Stance')
				fput 'stance forward' unless checkstance == 'forward'
			else
				fput 'stance defensive' unless checkstance == 'defensive'
			end

            print.call('waiting for attack')

            start = Time.now.to_i
            while true
				if GameObj.pcs.any?
					print.call('room occupied')
					break
				end

                if Time.now.to_i - start > 2
					print.call('bandits not found')
                    break
                end

                if GameObj.npcs.find { |npc| npc.type =~ /bandit/ }
					print.call('bandits found')
                    break
                end

                sleep 0.25
            end

            while not $BOUNTYHUNTER[:should_rest_wounded].call()
                npcs = GameObj.npcs.to_a.find_all { |npc| npc.type =~ /bandit/ and npc.status !~ /dead/ }
                dead = GameObj.npcs.to_a.find_all { |npc| npc.type =~ /bandit/ and npc.status =~ /dead/ }

				#HACK
				if GameObj.pcs.any?
					break
				end
				
                if npcs.empty?
                    break
                elsif $BOUNTYHUNTER[:enable_bandit_script]
                    waitrt?
                    waitcastrt?

                    if not dead.empty?
                        run_loot_script.call()
                    else
                        start_script($BOUNTYHUNTER[:bandit_script], npcs.collect { |n| n.id }, h={:quiet=>true})
                        wait_while { running?($BOUNTYHUNTER[:bandit_script]) }
                    end
                else
                    print.call('kill them all!')
                    script.pause
                end

                sleep 0.25
            end

			break if checkencumbrance.to_i >= ($BOUNTYHUNTER[:should_rest_encum].to_i)
            break if $BOUNTYHUNTER[:should_rest_wounded].call or not is_bounty.call('task_bandit')
        }

        sleep 0.1
    end

    kill_hunting_scripts.call
}

task_forage = proc {
    if bounty? !~ /#{bounty_patterns['task_forage']}/
        error.call 'you are not on a forage bounty'
    end

    herb     = $1
    location = $2
    count    = $3.to_i

    print.call("foraging for #{count} #{herb} at #{location}")

    herb = herb.downcase

	#HACK
	go2_willow_rest
	start_hunting_scripts.call
	
    refresh_spells = proc {
        [506, 604, 9704, 'Sigil of Resolve'].each { |spell|
            if Spell[spell].known? and not Spell[spell].active? and Spell[spell].affordable?
                waitrt?
                waitcastrt?

                Spell[spell].cast
                sleep 0.50
            end
        }

        yierka          = Spell['AA: Yierka']
        yierka_cooldown = Spell['AA: Yierka Cooldown']

        if yierka.known? and yierka.affordable? and not yierka_cooldown.active?
            yierka.cast
        end
    }

    get_herb_count = proc {
        lootsack.contents.find_all { |item| item.name =~ /#{herb.gsub(/s?$/,'')}/i }.size
    }

    last_forage_attempt = Time.now.to_i
    if get_herb_count.call < count
		hunt_prepare.call
		#HACK
		start_hunting_scripts.call

        rest_exit.call

        rooms = get_herb_rooms.call(location, herb)
        bright_rooms = []

        cur_room  = 0
        num_tries = 0

        song_of_peace = false

        start_hunting_scripts.call
        while get_herb_count.call < count and not $BOUNTYHUNTER[:should_rest_wounded].call and num_tries < 3
            sanct_cast = false
            light_cast = false

            go2.call(rooms[cur_room])
            cur_room = cur_room + 1

            if cur_room >= rooms.length
                cur_room  = 0
                num_tries = num_tries + 1
            end

            while get_herb_count.call < count and rooms.length > 0 and not $BOUNTYHUNTER[:should_rest_wounded].call
                if not kneeling? and GameObj.pcs.any?
                    break
                end

                if Spell[1011].known? and Spell[1011].affordable? and not song_of_peace
                    Spell[1011].cast
                    song_of_peace = true
                end

                waitrt?
                change_stance.call('defensive')

                refresh_spells.call

                if not song_of_peace and not GameObj.npcs.find_all { |npc| npc.type =~ /aggressive/ && npc.status !~ /dead|gone/ }.nil?
                    break
                end

                if not kneeling?
                    run_commands.call($BOUNTYHUNTER[:pre_forage_commands])
                    kneel.call()
                end

                if Spell[213].known? and Spell[213].affordable? and not sanct_cast
                    sanct_cast = true
                    fput "incant 213"
                    waitcastrt?
                end

                if Spell[205].known? and Spell[205].affordable? and not bright_rooms.include?(cur_room) and not light_cast
                    light_cast = true
                    fput "incant 205"
                    bright_rooms.push(cur_room)
                    waitcastrt?
                end

                if Skills.stalkingandhiding >= 50
                    fput 'hide' until hidden?
                end

                herb = herb.gsub(/(?:(?:handful|bunch|sprig) of|fragrant|fetid)\s+/, '')
                herb = herb.gsub(/dark pink\s+/, '')
                herb = herb.gsub('mass of ', '')
                herb = herb.gsub('slime-covered ', '')
                herb = herb.gsub('layer of ', '')
				herb = herb.gsub('stem of ', '')
				herb = herb.gsub('large', '')

                res = dothistimeout "forage #{herb}", 1, /find no trace of what|not even positive|it could be|it could even be found|and manage to find|Roundtime|In order to forage|foraging here recently/

          if res =~ /it could be|it could even be found|not even positive|find no trace of what/
                    rooms.delete_at(cur_room)
            break
                elsif res =~ /and manage to find/
                    while checkleft && (checkleft =~ /#{herb}/ || herb =~ /#{checkleft}/)
                        fput "put #{checkleft} in ##{lootsack.id}"
                    end
                    while checkright && (checkright =~ /#{herb}/ || herb =~ /#{checkright}/)
                        fput "put #{checkright} in ##{lootsack.id}"
                    end

            print.call "-- success, found #{get_herb_count.call} of #{count} #{herb}"
          elsif res =~ /In order to forage/
            fput "stow all"
          elsif res =~ /foraging here recently/
                    print.call 'herb can not be found here, skipping room...'
                    rooms.delete_at(cur_room)
            break
          else
              print.call "failure, found #{get_herb_count.call} of #{count} #{herb}"
          end
            end

            # Sanity check, cleanup any remaining herbs
            while checkleft && (checkleft =~ /#{herb}/ || herb =~ /#{checkleft}/)
                fput "put #{checkleft} in ##{lootsack.id}"
            end
            while checkright && (checkright =~ /#{herb}/ || herb =~ /#{checkright}/)
                fput "put #{checkright} in ##{lootsack.id}"
            end

            if not standing?
                run_commands.call($BOUNTYHUNTER[:post_forage_commands])

                while not checkstance 'offensive' and (song_of_peace or GameObj.npcs.find_all { |npc| npc.type =~ /aggressive/ && npc.status !~ /dead/ }.nil?)
                    fput 'stance offensive'
          sleep 0.10
                end

                stand.call()
                change_stance.call('defensive')
            end
        end
    end

    if song_of_peace
        fput "stop 1011"
    end

    if get_herb_count.call >= count
        talk_to_herbalist.call
        last_forage_attempt = 0
    end

    kill_hunting_scripts.call
}

success_heirloom = proc {
    print.call 'turning in heirloom'

    npc = find_guard.call

    empty_hands

    close = false
    if lootsack.contents.nil?
        open_result = dothistimeout "open ##{lootsack.id}", 5, /^You open|^That is already open\.$/
        if open_result =~ /^You open/
            close = true
        else
            dothistimeout "look in ##{lootsack.id}", 5, /In .*? you see/
        end
    end

    found = false
    bounty? =~ /#{bounty_patterns['success_heirloom']}/
    heirloom = $1
    print.call "looking for #{$1}"

    lootsack.contents.each { |item|
        if item.name !~ /#{heirloom}/
            next
        end

        res = dothistimeout "look ##{item.id}", 2, /^Engraved .* initials|^You see nothing unusual\.$|^The ring appears|^It takes you a moment|^It is difficult to see/
        if res =~ /^Engraved .* initials/
            fput "get ##{item.id}"
            fput "give ##{item.id} to #{npc}"
            found = true

            break
        end
    }

    fput "close ##{lootsack.id}" if close

    if not found
        error.call 'failed to find heirloom for guard'
    end

    fill_hands
}

turn_in = proc {
    rest_exit.call

    if is_bounty.call 'success_guard'
        talk_to_guard.call
    elsif is_bounty.call 'success_heirloom'
        success_heirloom.call
    end

	#HACK
	go2_willow
	urchin_guide.call('bounty')
	sleep 0.1

    go2_nearest_tag.call('advguild')

    npc = GameObj.npcs.find { |t| t.name =~ /taskmaster|adventurer Halfwhistle/i }
    res = dothistimeout "ask #{npc} about bounty", 5, /^#{npc}.*?done with that assignment/
    10.times {
        if line = get? and line =~ /You have earned ([0-9]+) bounty points?, ([0-9]+) experience points, and ([0-9]+) silver\./
            print.call "finished task (#{$1} points, #{$2} exp, #{$3} silver)"
            break
        end

        sleep 0.1
    }

    run_loot_script.call
    can_do_bounty_cache = nil
    $BOUNTYHUNTER_can_do_bounty = nil
}

talk_to_npc = proc {
    if is_bounty.call ['help_creature', 'help_resident', 'help_heirloom', 'success_guard']
        talk_to_guard.call
    # separate bandits so we don't trigger them on accident while walking
    elsif is_bounty.call ['help_bandit'] and $BOUNTYHUNTER[:enable_bandit]
        talk_to_guard.call
    elsif is_bounty.call 'help_furrier'
        talk_to_furrier.call
    elsif is_bounty.call 'help_herbalist'
        talk_to_herbalist.call
    elsif is_bounty.call 'help_gemdealer'
        talk_to_gemdealer.call
    end
}

help = proc {
    respond
    respond 'BOUNTYHUNTER by Alastir (gs4Alastir@gmail.com)'
	respond 'Original credit to Spiffy'
    respond 'usage: ;BOUNTYHUNTER [hunter=explorer]'
    respond
}

if script.vars[1] =~ /^setup$/i
    setup.call
    exit
elsif script.vars[1] =~ /^help$/i
    help.call
    exit
elsif script.vars[1] =~ /^forage$/i
    task_forage.call
    exit
elsif script.vars[1] =~ /^bandits?$/i
    task_bandit.call
    exit
elsif script.vars[1] =~ /^npc$/i
    talk_to_npc.call
    exit
elsif script.vars[1] =~ /^load$/i
    start_script($BOUNTYHUNTER[:hunter], nil, true)
    wait_while { running? $BOUNTYHUNTER[:hunter] }

    location = nil
    if script.vars[2]
        target = script.vars[2]
        locations = $BOUNTYHUNTER[:locations].dup
        location = locations.find { |name, data| $BOUNTYHUNTER_CLEAN_TARGETS.call(data[:targets]).find { |t| target =~ /#{t}/i } }
    end
    $BOUNTYHUNTER_HUNTER_SETUP.call($BOUNTYHUNTER.to_hash.dup, get_bounty_location.call(location, target))
    exit
elsif script.vars[1] =~ /^check$/i
    can_do_bounty.call
    exit
elsif script.vars[1]
    $BOUNTYHUNTER[:hunter] = "BOUNTYHUNTER-#{script.vars[1]}"
end

hunter        = $BOUNTYHUNTER[:hunter]
task_accepted = false
resting       = false

#HACK
if fried?
else
	start_script(hunter, nil, true)
	wait_while { running? hunter }
end

if not defined? $BOUNTYHUNTER_HUNTER_SETUP
    error.call 'hunter setup was not defined'
	echo 'Type in: ;bountyhunter-explorer'
elsif not defined? $BOUNTYHUNTER_HUNTER_NAME
    error.call 'hunter name was not defined'
elsif not defined? $BOUNTYHUNTER_HUNTER_RELOAD
    error.call 'hunter reload was not defined'
end

before_dying {
	#HACK
	if Char.prof == /Warrior/
		if $weapon_lost == true
			wait_while {$weapon_lost == true}
		elsif $weapon_lost == false
			nil
		end
	end
	
    kill_script($BOUNTYHUNTER_HUNTER_NAME) if running?($BOUNTYHUNTER_HUNTER_NAME)
    kill_hunting_scripts.call
}

Thread.new {
    wait_until { dead? }
    #exit
}

while true
    talk_to_npc.call

    if can_do_bounty.call and not $BOUNTYHUNTER[:should_rest_wounded].call
        if is_bounty.call 'task_search'
            task_search.call
        elsif is_bounty.call 'task_forage' and Time.now.to_i >= last_forage_attempt + last_forage_delay
            task_forage.call
        end
    elsif Spell['Next Bounty'].active? and (expedite_left and not is_bounty.call 'none' and not can_do_bounty.call and $BOUNTYHUNTER[:enable_expedite]) and not is_bounty.call ['success']
        expedite_bounty.call
        next
    end

    if is_bounty.call 'task_escort' and GameObj.npcs.find { |npc| npc.name =~ /child/ }
        task_escort.call 'advguard'
    elsif is_bounty.call 'task_fail'
        can_do_bounty_cache = nil
    elsif is_bounty.call 'success_heirloom'
        success_heirloom.call
    end

    exit if dead?

    if can_turn_in.call
        turn_in.call
        resting = false
    else
        if not can_do_bounty.call and not Spell['Next Bounty'].active? and not is_bounty.call ['success']
=begin Original
			remove_bounty.call
            get_bounty.call
=end
			#HACK
            remove_bounty.call unless is_bounty.call ['success']
            get_bounty.call
			if is_bounty.call ['help_creature', 'help_resident', 'help_heirloom', 'help_gemdealer', 'help_herbalist', 'help_furrier']
				talk_to_npc.call
			end

        elsif should_hunt.call and not should_rest.call and not has_skins.call
            resting   = false
            provoked  = false
            success   = false
            first_run = false
            bounty    = bounty?

            rest_exit.call				#Exit Commands
            hunt_prepare.call			#Pre-hunt commands

            # default hunter location
            if can_do_bounty.call
                # order is important here - bandits and regular culling look similar
                if is_bounty.call ['task_bandit']
                    task_bandit.call
                elsif is_bounty.call ['task_cull', 'task_dangerous', 'task_heirloom', 'task_rescue', 'task_skin']
                    start_hunter.call(get_bounty_location.call)
                else
                    start_hunter.call(get_random_location.call)
                end
            else
                start_hunter.call(get_random_location.call)
            end

            while not should_rest.call and running? $BOUNTYHUNTER_HUNTER_NAME
                if bounty? =~ /#{bounty_patterns['task_provoked']}/ and not provoked
                    reload_hunter.call
                    provoked = true
                elsif is_bounty.call 'task_escort'
                    break
                elsif has_skins.call
                    break
                elsif not success and (bounty? != bounty and (is_bounty.call [ 'success', 'success_heirloom' ] or (provoked and is_bounty.call 'success_guard')))
=begin Original
                    finish_hunt.call
                    start_hunter.call(get_random_location.call)
=end
					#HACK
					if Char.prof == /Warrior/
						if $weapon_lost == true
							wait_while {$weapon_lost == true}
						elsif $weapon_lost == false
							nil
						end
					end
					kill_script($BOUNTYHUNTER_HUNTER_NAME) if running?($BOUNTYHUNTER_HUNTER_NAME)

                    success = true
                elsif can_turn_in.call
                    break
                #elsif not can_do_bounty.call and not Spell['Next Bounty'].active?
                #    break
                #elsif true and percentmind >= 100 and not is_bounty.call ['success', 'success_heirloom']
                    # use long term boost
                end

                sleep 0.10
            end

            finish_hunt.call
        elsif not can_turn_in.call
            rest_goto.call

            if not resting or $BOUNTYHUNTER[:should_rest_wounded].call
                rest_run_scripts.call
                rest_goto.call
            end

            rest_enter.call

            while should_rest.call or not should_hunt.call
                if can_turn_in.call
                    break
                elsif $BOUNTYHUNTER[:should_rest_wounded].call
                    break
                elsif not can_do_bounty.call and not Spell['Next Bounty'].active?
                    break
                end

                fput 'exp'

                if rest_reason.nil?
                    rest_reason = hunt_reason
                end
                print.call "still resting because: #{rest_reason}"

                sleep $BOUNTYHUNTER[:rest_sleep_interval]
            end

            resting = true
            rest_exit.call
        end
    end

    sleep 0.10
end