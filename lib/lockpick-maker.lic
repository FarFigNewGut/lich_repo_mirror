def message(text)
  string = ''
  if $fake_stormfront 
    string << "\034GSL\r\n " 
  else 
    string << "<pushBold/>"
  end

  if text.include?("\n")
    text.split("\n").each { |line| string << "#{line}" }
  else
    string << text
  end

  if $fake_stormfront 
    string << "\034GSM\r\n " 
  else 
    string << "<popBold/>"
  end
  
  puts string
end

####################################################################################################################################### 
=begin

**** Lockpick Maker! NOW WITH A GUI! ****
 looks for broken lockpicks, makes new ones
 or just make new lockpicks!
 exceptional qulaity only!
 tracks and reports number of attempts and silver spent
 
 author: Timbalt
 updates:
 added support for putting new lockpicks on a keyring instead of in a container
 added report for how many broken picks you have, and what material they are
 added picks made per material tracking 
 added attempt per material tracking
 added tracking for silver spent per material, and total spent
 added tracking for time spent per exceptional pick, and total time
 added support for customizing dye, edging, and inset options
 added GUI for script


DM Timbalt on Discord with any issues you come across, or suggestions!

=end



AUTHOR = "Timbalt"
#######################################################################################################################################

# --- Helper for Lich compatibility ---
# unless defined?(Vars)
#   class Vars
#     def self.method_missing(name, *args)
#       var = name.to_s
#       if var[-1] == '='
#         ENV[var.chop.upcase] = args.first
#       else
#         ENV[var.upcase]
#       end
#     end
#   end
# end

# unless defined?(dothis)
#   def dothis(cmd, regex = nil)
#     puts "DEBUG: Would run: #{cmd}"
#     "exceptional" # stub for testing
#   end
# end

# unless defined?(fput)
#   def fput(cmd)
#     puts "DEBUG: Would fput: #{cmd}"
#   end
# end

# unless defined?(multifput)
#   def multifput(*cmds)
#     cmds.each { |cmd| fput(cmd) }
#   end
# end

# unless defined?(waitrt?)
#   def waitrt?; end
# end

##################################################################################################################
message("Lockpick Maker Script Initializing...")
sleep 0.5
message("Building Inventory Summary For GUI, May take a moment...")
sleep 0.2
fput "look in #{Vars.broken_sack}" if Vars.broken_sack
sleep 0.2
fput "look in #{Vars.gem_sack}" if Vars.gem_sack
sleep 0.2
fput "look in #{Vars.inset_sack}" if Vars.inset_sack
sleep 1

begin
  inventory_summary = []

  # List of container names to check (update as needed)
  container_names = [Vars.inset_sack, Vars.gem_sack].map(&:to_s)

  container_names.each do |container_name|
    container = GameObj.inv.find { |cont| cont.noun.to_s =~ /#{Regexp.escape(container_name)}/ }
    unless container
      inventory_summary << "~ Error: Container '#{container_name}' not found."
      next
    end

    gem_list = container.contents.find_all { |obj| obj.type =~ /gem/ }
    crystal_list = container.contents.find_all { |obj| obj.name.downcase =~ /(small (.*?) crystal|tiny (.*?) sphere)/ }
    # crystal_list = container.contents.find_all { |obj| obj.name.downcase.include?('small dark crystal|tiny wavering sphere') }
    scarab_list = container.contents.find_all { |obj| obj.name.downcase.include?('scarab') }
    bug_list = container.contents.find_all { |obj| obj.type =~ /bug/ || obj.name.downcase =~ /\b(bug|beetle|spider|fly|ant|bee|wasp|roach|caterpillar|worm|larva|moth|firefly|cricket|grasshopper|mantis|dragonfly|ladybug|weevil|gnat|mosquito|flea|tick|centipede|millipede|scorpion)\b/ }
    aquatic_list = container.contents.find_all { |obj| obj.type =~ /fish/ || obj.name.downcase =~ /\b(fish|clam|oyster|crab|lobster|shrimp|starfish|urchin|jellyfish|seahorse|eel|octopus|squid|mussel|snail|shell|conch|scallop|barnacle|anemone|coral)\b/ }
    bird_list = container.contents.find_all { |obj| obj.name.downcase =~ /\b(bird|raven|hawk|eagle|owl|falcon|parrot|crow|dove|pigeon|sparrow|finch|swallow|magpie|jay|heron|crane|vulture|osprey|condor|gull|tern|ibis|stork|pelican|albatross|robin|wren|lark|oriole|woodpecker|kingfisher|loon|duck|goose|swan|turkey|pheasant|quail|grouse|ptarmigan|partridge|cockatoo|macaw|canary|starling|blackbird|thrush|warbler|pipit|bunting|shrike|tit|nuthatch|swift|nightjar|cuckoo|cormorant|bittern|rail|coot|grebe|penguin|kiwi|emu|cassowary|ostrich)\b/ }

    if gem_list.empty? && crystal_list.empty? && scarab_list.empty?
      inventory_summary << "Error: No insets found"
      next
    end

    gem_counts = Hash.new(0)
    gem_list.each { |gem| gem_counts[gem.name] += 1 }
    crystal_counts = Hash.new(0)
    crystal_list.each { |crystal| crystal_counts[crystal.name] += 1 }
    scarab_counts = Hash.new(0)
    scarab_list.each { |scarab| scarab_counts[scarab.name] += 1 }
    bug_counts = Hash.new(0)
    bug_list.each { |bug| bug_counts[bug.name] += 1 }
    aquatic_counts = Hash.new(0)
    aquatic_list.each { |aq| aquatic_counts[aq.name] += 1 }
    bird_counts = Hash.new(0)
    bird_list.each { |bird| bird_counts[bird.name] += 1 }

    # Optionally add a header for each container
    inventory_summary << "~ Contents of #{container.noun}:"
    gem_counts.each { |gem, count| inventory_summary << "#{gem.capitalize}: #{count}" }
    crystal_counts.each { |crystal, count| inventory_summary << "#{crystal.capitalize}: #{count}" }
    scarab_counts.each { |scarab, count| inventory_summary << "#{scarab.capitalize}: #{count}" }
    bug_counts.each { |bug, count| inventory_summary << "#{bug.capitalize}: #{count}" }
    aquatic_counts.each { |aq, count| inventory_summary << "#{aq.capitalize}: #{count}" }
    bird_counts.each { |bird, count| inventory_summary << "#{bird.capitalize}: #{count}" }
  end

  # If you want to print the summary as well:
  inventory_summary.each { |line| message(line) }
  # Now you can use inventory_summary in your GUI dropdown

rescue => e
  message("Error: #{e.message}")
end
##########################################################################################################

# GUI selection results will be stored here if use_gui is enabled
$selected_materials = nil
$selected_materials2 = nil
$exit_script = nil

def test(broken_picks, inventory_summary)
  require 'gtk3'
  require 'json'

  # --- Load previous selections if available ---
  selections_path = File.expand_path("lockpick_gui_selections.json", File.dirname(__FILE__))
  prev = {}
  if File.exist?(selections_path)
    begin
      prev = JSON.parse(File.read(selections_path))
    rescue
      prev = {}
    end
  end

  # --- Use pick_numbers for new lockpick info ---
  pick_numbers = {
    "silver" => 30,
    "gold"   => 29,
    "steel"  => 28,
    "copper" => 26,
    "brass"  => 27,
    "ora"    => 31,
    "mithril"=> 32,
    "laje"   => 33,
    "alum"   => 34,
    "vultite"=> 35,
    "rolaren"=> 36,
    "veniom" => 37,
    "kelyn"  => 38,
    "invar"  => 39,
    "golvern"=> 40,
    "vaalin" => 41
  }
  pick_costs = {
    "silver" => 2000,
    "gold"   => 1600,
    "steel"  => 400,
    "copper" => 80,
    "brass"  => 200,
    "ora"    => 4000,
    "mithril"=> 4800,
    "laje"   => 13600,
    "alum"   => 18400,
    "vultite"=> 24000,
    "rolaren"=> 28800,
    "veniom" => 40000,
    "kelyn"  => 49600,
    "invar"  => 60000,
    "golvern"=> 76000,
    "vaalin" => 100000
  }

  Gtk.queue {
    window = Gtk::Window.new(:toplevel)
    window.set_title("Lockpick Maker v2.3")
    window.set_default_size(500, 400)
    window.set_border_width(10)

    notebook = Gtk::Notebook.new

    # --- Tab 1: Customization ---
    vbox1 = Gtk::Box.new(:vertical, 10)
    hbox = Gtk::Box.new(:horizontal, 10)

    # Use static lists for GUI
    colors = [
      "ale brown", "alabaster", "amber", "amaranth pink", "amethyst", "amethyst purple", "apricot", "apple green", "ashen", "ash grey", "auburn", "azure",
      "azure blue", "azure green", "azure mist", "azure violet", "baby blue", "banana yellow", "berry red", "bile green", "black", "black cherry",
      "black opal", "black pearl", "blue", "blue-black", "blue-green", "blue-grey", "blue-violet", "blush", "blush pink", "bone", "bone white", "brick red",
      "bright golden", "bright green", "bright pink", "bright red", "bright white", "brilliant white", "bronze", "bronze brown", "brown", "brown camouflage",
      "burgundy", "burnished gold", "burnt umber", "caramel-hued", "cardinal red", "carrot orange", "celadon", "celestial blue", "cerise", "cerulean",
      "champagne", "charcoal", "charcoal black", "chartreuse", "cherry red", "chestnut brown", "chrome", "cinereous", "cobalt", "cobalt blue", "coal black",
      "copper", "coppery brown", "coppery gold", "coral", "coral pink", "coral red", "cream", "creamy white", "crimson", "crimson red", "cucumber green",
      "cyan", "dapple grey", "dappled", "dark", "dark azure", "dark blue", "dark brown", "dark cerulean", "dark crimson", "dark cyan", "dark green",
      "dark grey", "dark purple", "dark red", "deep black", "deep blue", "deep brown", "deep chrome", "deep cordovan", "deep crimson", "deep ebony",
      "deep pink", "deep purple", "deep red", "deep violet", "denim", "dingy grey", "dove-colored", "drab grey", "dull black", "dull grey", "dun",
      "dusky black", "dusky blue", "dusky rose", "dusty rose", "earthen brown", "ebon", "ebon black", "ebony", "ecru", "emerald", "emerald green",
      "fiery orange", "fiery red", "flame red", "flaxen", "forest green", "fuschia", "ghostly white", "ginger", "glacial blue", "glacial white",
      "gleaming white", "glossy black", "glossy blue", "golden", "goldenrod", "grape", "grass green",
      "green", "green camouflage", "green-layered camouflage", "grey", "grey-blue", "grey-green", "greyish blue", "hazel", "hazel-brown", "hemlock green",
      "henna", "honey gold", "honey-colored", "hot pink", "hunter green", "ice", "ice blue", "ice green", "ice white", "icy blue", "indigo",
      "inky black", "iron grey", "iridescent black", "ivory", "ivory white", "ivy green", "jade", "jade green", "jet black", "kelp", "lavender",
      "lemon", "lemon yellow", "light blue", "light brown", "light green", "light grey", "light orange", "light pink", "light purple", "light red", "lilac",
      "lily white", "linen", "magenta", "mahogany", "mahogany brown", "malachite green", "maroon", "matte black", "midnight", "midnight black",
      "midnight blue", "midnight ebon", "mint", "mint green", "mist", "misty grey", "moonlight silver", "moonshade black", "moss", "moss green",
      "mottled black", "mottled green", "mulberry", "murky black", "murky indigo", "mushroom grey", "navy", "navy blue", "nightshade purple", "nut brown",
      "oak brown", "obsidian", "obsidian black", "ochre", "ocher", "ocean", "ocean blue", "olive", "olive green", "onyx", "onyx black", "opal", "opaline",
      "orange", "orchid", "orchid pink", "pale blue", "pale golden", "pale green", "pale grey", "pale jade", "pale pink", "pale violet", "pale white",
      "pale yellow", "peach", "peach-colored", "peacock", "peacock blue", "pearlescent", "pearl", "pearl grey", "pearly white", "periwinkle", "persimmon",
      "pink", "pink-layered camouflage", "pitch black", "platinum", "platinum grey", "plum", "plum-colored", "powder blue", "pristine white", "puce",
      "pure white", "pumpkin", "pumpkin orange", "radiant white", "rainbow", "raspberry", "raspberry red", "raven black", "red", "red-orange",
      "red-speckled black", "red-tinged", "rich cream", "roan", "rose", "rose pink", "rose red", "rose-colored", "roseate", "rosy pink",
      "rosy red", "royal blue", "royal purple", "ruby", "ruby red", "ruddy crimson", "rust", "rust-colored", "russet", "sable", "sage", "sage green",
      "salmon", "salmon pink", "sand", "sand-colored", "sandstone", "sanguine", "sapphire", "sapphire blue", "scarlet", "scorched black", "sea",
      "sea blue", "sea green", "seaweed green", "shadow", "shadowy", "shadowy black", "shamrock", "shamrock green", "shell", "silvery", "silvery blue",
      "silvery green", "silvery white", "sky", "sky blue", "slate", "slate-colored", "smalt blue", "smoke", "smoky", "smoky grey", "snow",
      "snow white", "sooty black", "sorrel", "spring green", "spruce", "stark white", "steel blue", "steel grey", "stone", "stone grey",
      "storm", "storm grey", "stormy blue", "stormy grey", "straw", "sun", "sun yellow", "sunset", "sunset orange", "sunshine", "tan", "tan brown",
      "tangerine", "taupe", "taupe grey", "tawny", "tawny sable", "tawny yellow", "teal", "teal blue", "thistle", "tomato", "twilight", "twilight black",
      "twilight blue", "twilight grey", "ultramarine", "umber", "verdant", "verdant green", "veridian", "vermilion", "vermilion red",
      "violet", "violet blue", "violet red", "viridian", "viridian green", "void black", "wheat", "white", "white gold",
      "wine", "wine red", "winter", "wisteria", "woodland camouflage", "yellow", "yellow-green", "yellow orange"
    ]
edge_materials = [
      "copper",
      "brass",
      "bronze",
      "iron",
      "steel",
      "silver",
      "gold",
      "mithril",
      "ora",
      "alum",
      "imflass",
      "vultite",
      "vaalorn",
      "mithglin",
      "invar",
      "veniom",
      "laje",
      "rhimar"
    ]
    edge_materials_costs = {
      "copper" => 20,
      "brass" => 100,
      "bronze" => 250,
      "iron" => 300, 
      "steel" => 400,
      "silver" => 500,
      "gold" => 1000,
      "mithril" => 1400,
      "ora" => 1600,
      "alum" => 2000,
      "imflass" => 2000,
      "vultite" => 3000,
      "vaalorn" => 5000,
      "mithglin" => 5000,
      "invar" => 5000,
      "veniom" => 5000,
      "laje" => 5000,
      "rhimar" => 5000
  }
    # Build a list of gems/crystals/scarabs for insets from inventory_summary
    gem_items = inventory_summary.map do |line|
      if line =~ /^(.+?):\s*(\d+)/
        name = $1.strip.downcase
        count = $2.strip
        "#{name}: #{count}"
      end
    end.compact.uniq

    color_combo = Gtk::ComboBoxText.new
    colors.each { |c| color_combo.append_text(c) }
    # Set previous color if available
    if prev["color"] && colors.include?(prev["color"])
      color_combo.active = colors.index(prev["color"])
    else
      color_combo.active = 0
    end

    material_combo = Gtk::ComboBoxText.new
    edge_materials.each { |m| material_combo.append_text(m) }
    if prev["material"] && edge_materials.include?(prev["material"])
      material_combo.active = edge_materials.index(prev["material"])
    else
      material_combo.active = 0
    end

    gem_combo = Gtk::ComboBoxText.new
    gem_items.each { |g| gem_combo.append_text(g) }
    if prev["gem"] && !prev["gem"].to_s.empty?
      idx = gem_items.index(prev["gem"])
      gem_combo.active = idx if idx
    else
      gem_combo.active = 0
    end

    hbox.pack_start(color_combo, expand: true, fill: true, padding: 5)
    hbox.pack_start(material_combo, expand: true, fill: true, padding: 5)
    hbox.pack_start(gem_combo, expand: true, fill: true, padding: 5)

    vbox1.pack_start(hbox, expand: false, fill: true, padding: 0)

    enable_dye_cb = Gtk::CheckButton.new("Enable Dye")
    enable_dye_cb.active = !!prev["customizing_dye"]
    enable_edge_cb = Gtk::CheckButton.new("Enable Edging")
    enable_edge_cb.active = !!prev["customizing_edge"]
    enable_inset_cb = Gtk::CheckButton.new("Enable Inset")
    enable_inset_cb.active = !!prev["customizing_inset"]

    vbox1.pack_start(enable_dye_cb, expand: false, fill: true, padding: 5)
    vbox1.pack_start(enable_edge_cb, expand: false, fill: true, padding: 5)
    vbox1.pack_start(enable_inset_cb, expand: false, fill: true, padding: 5)

    # --- Keyring Mode Checkbox ---
    enable_keyring_cb = Gtk::CheckButton.new("Enable Keyring Mode (put exceptional lockpicks on keyring)")
    enable_keyring_cb.active = !!prev["use_keyring"]
    vbox1.pack_start(enable_keyring_cb, expand: false, fill: true, padding: 5)

    # Add checkbox to enable withdrawing the bank note
    enable_withdraw_note_cb = Gtk::CheckButton.new("Withdraw bank note")
    enable_withdraw_note_cb.active = !!prev["enable_withdraw_note"]
    vbox1.pack_start(enable_withdraw_note_cb, expand: false, fill: true, padding: 2)

    # Add bank note amount field
    bank_note_hbox = Gtk::Box.new(:horizontal, 5)
    bank_note_label = Gtk::Label.new("Bank Note Amount:")
    bank_note_entry = Gtk::Entry.new
    bank_note_entry.set_width_chars(20)
    # Set previous value if available
    if prev["bank_note_amount"]
      bank_note_entry.text = prev["bank_note_amount"].to_s
    else
      bank_note_entry.text = ""
    end
    bank_note_hbox.pack_start(bank_note_label, expand: false, fill: false, padding: 2)
    bank_note_hbox.pack_start(bank_note_entry, expand: false, fill: false, padding: 2)
    vbox1.pack_start(bank_note_hbox, expand: false, fill: true, padding: 5)

    # Add explanatory label under the field
    bank_note_info_label = Gtk::Label.new("note is used for buying bars (lockpick material).")
    vbox1.pack_start(bank_note_info_label, expand: false, fill: true, padding: 2)

    result_label = Gtk::Label.new("Selected values will appear here")
    # warning label for edge material
    edge_warning_label = Gtk::Label.new("")
    edge_warning_label.visible = false

    # show_button = Gtk::Button.new(label: "Save Selected")
    # show_button.signal_connect("clicked") do
    #   selected_color = color_combo.active_text
    #   selected_material = material_combo.active_text
    #   selected_gem = gem_combo.active_text
    #   customizing_dye = enable_dye_cb.active?
    #   customizing_edge = enable_edge_cb.active?
    #   customizing_inset = enable_inset_cb.active?
    #   use_keyring = enable_keyring_cb.active?
    #   # Save to global variables
    #   $custom_color = selected_color
    #   $custom_material = selected_material
    #   $custom_gem = selected_gem
    #   $customizing_dye = customizing_dye
    #   $customizing_edge = customizing_edge
    #   $customizing_inset = customizing_inset
    #   $use_keyring = use_keyring
    #   # Show "none" for color, edging, inset if their checkboxes arent checked
    #   label_color = customizing_dye ? selected_color : "none"
    #   label_material = customizing_edge ? selected_material : "none"
    #   label_gem = customizing_inset ? (selected_gem ? selected_gem.split(':').first.strip : "none") : "none"
    #   result_label.set_text("Color: #{label_color}, Edging: #{label_material}, Inset: #{label_gem}, Keyring: #{use_keyring ? 'Enabled' : 'Disabled'} | Saved!")
    #   # edge warnings
    #   warning = case label_material.downcase
    #     when "veniom"
    #       "**Warning: Veniom Edging Material Only Available In Wehnimer's Landing Guild!**"
    #     when "mithglin"
    #       "**Warning: Mithglin Edging Material Only Available In Ta'Illistim Guild!**"
    #     when "invar"
    #       "**Warning: Invar Edging Material Only Available In Zul Logoth Guild!**"
    #     when "laje"
    #       "**Warning: Laje Edging Material Only Available In Solhaven Guild!**"
    #     when "rhimar"
    #       "**Warning: Rhimar Edging Material Only Available In Icemule Trace Guild!**"
    #     when "vaalorn"
    #       "**Warning: Vaalorn Edging Material Only Available In Ta'Vaalor Guild!**"
    #     else
    #       ""
    #   end
    #   edge_warning_label.set_text(warning)
    #   edge_warning_label.visible = !warning.empty?
    #   selections = {
    #     color: $custom_color,
    #     material: $custom_material,
    #     gem: $custom_gem,
    #     customizing_dye: $customizing_dye,
    #     customizing_edge: $customizing_edge,
    #     customizing_inset: $customizing_inset,
    #     selected_materials: $selected_materials,
    #     selected_materials2: $selected_materials2,
    #     use_keyring: $use_keyring,
    #    # container values
    #     gem_sack_val: container_entries["gem_sack"].text,
    #     inset_sack_val: container_entries["inset_sack"].text,
    #     broken_sack_val: container_entries["broken_sack"].text,
    #     average_sack_val: container_entries["average_sack"].text,
    #     exceptional_sack_val: container_entries["exceptional_sack"].text
    #   }
    #   File.open(selections_path, "w") do |f|
    #     f.write(JSON.pretty_generate(selections))
    #   end
    # end
    
    show_button = Gtk::Button.new(label: "Save Selected")
    vbox1.pack_start(show_button, expand: false, fill: true, padding: 5)
    vbox1.pack_start(result_label, expand: false, fill: true, padding: 5)
    vbox1.pack_start(edge_warning_label, expand: false, fill: true, padding: 5)

    notebook.append_page(vbox1, Gtk::Label.new("Customization"))

    # --- Tab 2: Broken Lockpicks ---
    vbox2 = Gtk::Box.new(:vertical, 10)
    label2 = Gtk::Label.new("Select which broken lockpicks to remake:")
    vbox2.pack_start(label2, expand: false, fill: true, padding: 5)

    checkboxes = {}
    broken_picks.each do |material, count|
      cb = Gtk::CheckButton.new("#{count} broken #{material} lockpick")
      vbox2.pack_start(cb, expand: false, fill: true, padding: 2)
      checkboxes[material] = cb
    end

    continue_button = Gtk::Button.new(label: "Start Remaking")
    continue_button.signal_connect("clicked") do
      $selected_materials = checkboxes.select { |mat, cb| cb.active? }.keys
      Script.run("go2", "rogue guild toolbench") if Room.current.title[0] !~ /toolbench/i
      window.destroy
      Gtk.main_quit
    end
    vbox2.pack_start(continue_button, expand: false, fill: true, padding: 10)

    notebook.append_page(vbox2, Gtk::Label.new("Broken Lockpicks"))

    # --- Tab 3: Make New Lockpicks ---
    vbox3 = Gtk::Box.new(:vertical, 10)
    label3 = Gtk::Label.new("Select which new lockpicks to make (not from broken):")
    vbox3.pack_start(label3, expand: false, fill: true, padding: 5)

    new_pick_checkboxes = {}
    all_materials = [
      "silver", "gold", "steel", "copper", "brass", "ora", "mithril", "laje",
      "alum", "vultite", "rolaren", "veniom", "kelyn", "invar", "golvern", "vaalin"
    ]

    # Splits the list in half for two columns
    half = (all_materials.size / 2.0).ceil
    left_materials = all_materials[0...half]
    right_materials = all_materials[half..-1]

    hbox_lists = Gtk::Box.new(:horizontal, 20)

    left_vbox = Gtk::Box.new(:vertical, 5)
    left_materials.each do |material|
      cb = Gtk::CheckButton.new("Make #{material} lockpick")
      if prev["selected_materials"].is_a?(Array) && prev["selected_materials"].include?(material)
        cb.active = true
      end
      left_vbox.pack_start(cb, expand: false, fill: true, padding: 2)
      new_pick_checkboxes[material] = cb
    end

    right_vbox = Gtk::Box.new(:vertical, 5)
    right_materials.each do |material|
      cb = Gtk::CheckButton.new("Make #{material} lockpick")
      if prev["selected_materials"].is_a?(Array) && prev["selected_materials"].include?(material)
        cb.active = true
      end
      right_vbox.pack_start(cb, expand: false, fill: true, padding: 2)
      new_pick_checkboxes[material] = cb
    end

    hbox_lists.pack_start(left_vbox, expand: true, fill: true, padding: 5)
    hbox_lists.pack_start(right_vbox, expand: true, fill: true, padding: 5)

    vbox3.pack_start(hbox_lists, expand: true, fill: true, padding: 5)

    # Use $selected_materials2 for new picks
    continue_new_button = Gtk::Button.new(label: "Start Making New")
    continue_new_button.signal_connect("clicked") do
      Script.run("go2", "rogue guild toolbench") if Room.current.title[0] !~ /toolbench/i
      window.destroy
      Gtk.main_quit
    end
    vbox3.pack_start(continue_new_button, expand: false, fill: true, padding: 10)

    notebook.append_page(vbox3, Gtk::Label.new("Make New Lockpicks"))

    # --- Tab 4: Containers ---
    vbox4 = Gtk::Box.new(:vertical, 10)
    label4 = Gtk::Label.new("Set your container variables for the script:")
    vbox4.pack_start(label4, expand: false, fill: true, padding: 5)

    # Define container variable names and labels
    container_vars = {
      "gem_sack" => "Gem Sack",
      "inset_sack" => "Inset Sack",
      "broken_sack" => "Broken Sack",
      "average_sack" => "Average Sack",
      "exceptional_sack" => "Exceptional Sack"
    }
    container_entries = {}

    container_vars.each do |var, label|
      h = Gtk::Box.new(:horizontal, 5)
      h.pack_start(Gtk::Label.new("#{label}:"), expand: false, fill: false, padding: 5)
      entry = Gtk::Entry.new
      entry.set_width_chars(20)
      # Always use the latest Vars value if set, otherwise use previous value from JSON
      val = (Vars.respond_to?(var) && Vars.send(var) && !Vars.send(var).to_s.strip.empty? && Vars.send(var).to_s != "nil") ? Vars.send(var).to_s : (prev[var] || "")
      entry.text = val
      h.pack_start(entry, expand: false, fill: false, padding: 2)
      vbox4.pack_start(h, expand: false, fill: true, padding: 2)
      container_entries[var] = entry
    end

    # Always show the restart label
    restart_label = Gtk::Label.new("After saving, please press 'Close and Exit' and restart the script.")
    restart_label.visible = true
    vbox4.pack_start(restart_label, expand: false, fill: true, padding: 5)

    save_containers_button = Gtk::Button.new(label: "Save Containers")
    save_containers_button.signal_connect("clicked") do
      # Show "nil" if any variable is empty or nil
      gem_val = container_entries["gem_sack"].text.nil? || container_entries["gem_sack"].text.strip.empty? ? "nil" : container_entries["gem_sack"].text.strip
      inset_val = container_entries["inset_sack"].text.nil? || container_entries["inset_sack"].text.strip.empty? ? "nil" : container_entries["inset_sack"].text.strip
      broken_val = container_entries["broken_sack"].text.nil? || container_entries["broken_sack"].text.strip.empty? ? "nil" : container_entries["broken_sack"].text.strip
      average_val = container_entries["average_sack"].text.nil? || container_entries["average_sack"].text.strip.empty? ? "nil" : container_entries["average_sack"].text.strip
      exceptional_val = container_entries["exceptional_sack"].text.nil? || container_entries["exceptional_sack"].text.strip.empty? ? "nil" : container_entries["exceptional_sack"].text.strip
      # Save variables to Lich vars so they persist between runs
      Vars.gem_sack = gem_val
      Vars.inset_sack = inset_val
      Vars.broken_sack = broken_val
      Vars.average_sack = average_val
      Vars.exceptional_sack = exceptional_val
      # Update the label to show the saved settings only when Save is clicked
      label4.set_text(
        "***** Your Current Container Settings *****\n" +
        "            Gem Sack Saved As: #{Vars.gem_sack.nil? || Vars.gem_sack.strip.empty? || Vars.gem_sack == 'nil' ? 'nil' : Vars.gem_sack}\n" +
        "          Inset Sack Saved As: #{Vars.inset_sack.nil? || Vars.inset_sack.strip.empty? || Vars.inset_sack == 'nil' ? 'nil' : Vars.inset_sack}\n" +
        "         Broken Sack Saved As: #{Vars.broken_sack.nil? || Vars.broken_sack.strip.empty? || Vars.broken_sack == 'nil' ? 'nil' : Vars.broken_sack}\n" +
        "        Average Sack Saved As: #{Vars.average_sack.nil? || Vars.average_sack.strip.empty? || Vars.average_sack == 'nil' ? 'nil' : Vars.average_sack}\n" +
        "       Exceptional Sack Saved As: #{Vars.exceptional_sack.nil? || Vars.exceptional_sack.strip.empty? || Vars.exceptional_sack == 'nil' ? 'nil' : Vars.exceptional_sack}"
      )
      # restart_label.visible = true # No longer needed, always visible
    end
    vbox4.pack_start(save_containers_button, expand: false, fill: true, padding: 10)

    notebook.append_page(vbox4, Gtk::Label.new("Containers"))
    show_button.signal_connect("clicked") do
      selected_color = color_combo.active_text
      selected_material = material_combo.active_text
      selected_gem = gem_combo.active_text
      customizing_dye = enable_dye_cb.active?
      customizing_edge = enable_edge_cb.active?
      customizing_inset = enable_inset_cb.active?
      use_keyring = enable_keyring_cb.active?
      # Save to global variables
      $custom_color = selected_color
      $custom_material = selected_material
      $custom_gem = selected_gem
      $customizing_dye = customizing_dye
      $customizing_edge = customizing_edge
      $customizing_inset = customizing_inset
      $use_keyring = use_keyring
      $bank_note_amount = bank_note_entry.text.strip
      $enable_withdraw_note = enable_withdraw_note_cb.active?
      # Show "none" for color, edging, inset if their checkboxes arent checked
      label_color = customizing_dye ? selected_color : "none"
      label_material = customizing_edge ? selected_material : "none"
      label_gem = customizing_inset ? (selected_gem ? selected_gem.split(':').first.strip : "none") : "none"
      # Add bank note info to result label if enabled
      bank_note_status = $enable_withdraw_note ? "Bank Note: Enabled (#{$bank_note_amount.empty? ? 'No Amount Set' : $bank_note_amount})" : "Bank Note: Disabled"
      result_label.set_text("Color: #{label_color}, Edging: #{label_material}, Inset: #{label_gem}, Keyring: #{use_keyring ? 'Enabled' : 'Disabled'}, #{bank_note_status} | Saved!")
      # edge warnings
      warning = case label_material.downcase
        when "veniom"
          "**Warning: Veniom Edging Material Only Available In Wehnimer's Landing Guild!**"
        when "mithglin"
          "**Warning: Mithglin Edging Material Only Available In Ta'Illistim Guild!**"
        when "invar"
          "**Warning: Invar Edging Material Only Available In Zul Logoth Guild!**"
        when "laje"
          "**Warning: Laje Edging Material Only Available In Solhaven Guild!**"
        when "rhimar"
          "**Warning: Rhimar Edging Material Only Available In Icemule Trace Guild!**"
        when "vaalorn"
          "**Warning: Vaalorn Edging Material Only Available In Ta'Vaalor Guild!**"
        else
          ""
      end
      edge_warning_label.set_text(warning)
      edge_warning_label.visible = !warning.empty?
      selections = {
        color: $custom_color,
        material: $custom_material,
        gem: $custom_gem,
        customizing_dye: $customizing_dye,
        customizing_edge: $customizing_edge,
        customizing_inset: $customizing_inset,
        selected_materials: $selected_materials,
        selected_materials2: $selected_materials2,
        use_keyring: $use_keyring,
        bank_note_amount: $bank_note_amount,
        enable_withdraw_note: $enable_withdraw_note,
       # container values
        gem_sack: container_entries["gem_sack"].text,
        inset_sack: container_entries["inset_sack"].text,
        broken_sack: container_entries["broken_sack"].text,
        average_sack: container_entries["average_sack"].text,
        exceptional_sack: container_entries["exceptional_sack"].text
      }
      File.open(selections_path, "w") do |f|
        f.write(JSON.pretty_generate(selections))
      end
    end

    # Add Close button to bottom of the GUI (define it here)
    close_button = Gtk::Button.new(label: "Close and Exit")
    close_button.signal_connect("clicked") do
      # Save all selections to JSON
      selections = {
        color: $custom_color,
        material: $custom_material,
        gem: $custom_gem,
        customizing_dye: $customizing_dye,
        customizing_edge: $customizing_edge,
        customizing_inset: $customizing_inset,
        selected_materials: $selected_materials,
        selected_materials2: $selected_materials2,
        use_keyring: $use_keyring,
        bank_note_amount: bank_note_entry.text.strip,
        enable_withdraw_note: enable_withdraw_note_cb.active?,
        # Save container values
        gem_sack: container_entries["gem_sack"].text,
        inset_sack: container_entries["inset_sack"].text,
        broken_sack: container_entries["broken_sack"].text,
        average_sack: container_entries["average_sack"].text,
        exceptional_sack: container_entries["exceptional_sack"].text
      }
      File.open(selections_path, "w") do |f|
        f.write(JSON.pretty_generate(selections))
      end
      window.destroy
      Gtk.main_quit
      $exit_script = true
      # Set a global flag to indicate user wants to exit the script
    end

    vbox_main = Gtk::Box.new(:vertical, 10)
    vbox_main.pack_start(notebook, expand: true, fill: true, padding: 0)
    vbox_main.pack_start(close_button, expand: false, fill: true, padding: 10)

    window.add(vbox_main)
    window.show_all
    Gtk.main
  }
end

require 'time'

materials_to_craft = {}
broken_picks = Hash.new(0)
log_data = []
total_picks_created = Hash.new(0)
silver_spent = Hash.new(0)
total_silver_spent = 0
pick_attempt_times = Hash.new { |hash, key| hash[key] = [] }
exceptional_pick_completion = {}
start_time = Time.now

# --- Container check ---
if Vars.broken_sack.nil? || Vars.broken_sack.empty? || Vars.average_sack.nil? || Vars.average_sack.empty? || Vars.exceptional_sack.nil? || Vars.exceptional_sack.empty? || Vars.gem_sack.nil? || Vars.gem_sack.empty? || Vars.inset_sack.nil? || Vars.inset_sack.empty?
  message("*** You need to set your container variables! please enter them in the GUI! ***")
  end

if $use_keyring
  sleep 1
  message("*** Keyring Mode Activated!, All exceptional lockpicks will be added to your keyring.")
  sleep 5
end

# --- Inventory scan using GameObj.inv ---
broken_picks = Hash.new(0)
materials = %w[silver gold steel copper brass ora mithril laje alum vultite rolaren veniom kelyn invar golvern vaalin]

# Find the broken sack container object
broken_sack_obj = GameObj.inv.find { |cont| cont.noun =~ /\b#{Vars.broken_sack}\b/i }
if broken_sack_obj && broken_sack_obj.contents
  broken_sack_obj.contents.each do |lockpick|
    # Match "<material> lockpick"
    if lockpick.name =~ /\b(#{materials.join('|')}) lockpick\b/i
      material = $1.downcase
      broken_picks[material] += 1
    end
  end
else
  message("*** Could not find your broken sack or it is empty!")
end

# --- GUI logic ---
test(broken_picks, inventory_summary)

# Wait for GUI to finish and $selected_materials/$selected_materials2 to be set or exit requested
while $selected_materials.nil? && $selected_materials2.nil? && !$exit_script
  sleep 0.1
end

# Exit script if user requested exit from GUI
if defined?($exit_script) && $exit_script
  exit
end

if ($selected_materials.nil? || $selected_materials.empty?) && ($selected_materials2.nil? || $selected_materials2.empty?)
  message("No lockpick materials selected in GUI. Exiting.")
  exit
end


materials_to_craft = {}
if $selected_materials && !$selected_materials.empty?
  $selected_materials.each { |mat| materials_to_craft[mat] = { remake: true } }
end
if $selected_materials2 && !$selected_materials2.empty?
  $selected_materials2.each { |mat| materials_to_craft[mat] = { remake: false } }
end

# --- This block only prints broken picks, it does not force remake ---
if broken_picks.empty?
  message("No broken lockpicks found.")
else
  broken_picks.each { |material, count| message("#{count} broken #{material}") }
end

  # Edge materials and costs
  edge_materials = [
      "copper",
      "brass",
      "bronze",
      "iron",
      "steel",
      "silver",
      "gold",
      "mithril",
      "ora",
      "alum",
      "imflass",
      "vultite",
      "vaalorn",
      "mithglin",
      "invar",
      "veniom",
      "laje",
      "rhimar"
    ]
    edge_materials_costs = {
      "copper" => 20,
      "brass" => 100,
      "bronze" => 250,
      "iron" => 300, 
      "steel" => 400,
      "silver" => 500,
      "gold" => 1000,
      "mithril" => 1400,
      "ora" => 1600,
      "alum" => 2000,
      "imflass" => 2000,
      "vultite" => 3000,
      "vaalorn" => 5000,
      "mithglin" => 5000,
      "invar" => 5000,
      "veniom" => 5000,
      "laje" => 5000,
      "rhimar" => 5000
  }

# --- Pick numbers and costs ---
pick_numbers = {
  "silver" => 30,
  "gold"   => 29,
  "steel"   => 28,
  "copper" => 26,
  "brass"  => 27,
  "ora"    => 31,
  "mithril"=> 32,
  "laje"   => 33,
  "alum"   => 34,
  "vultite"=> 35,
  "rolaren"=> 36,
  "veniom" => 37,
  "kelyn"  => 38,
  "invar"  => 39,
  "golvern"=> 40,
  "vaalin" => 41
}
pick_costs = {
  "silver" => 2000,
  "gold"   => 1600,
  "steel"  => 400,
  "copper" => 80,
  "brass"  => 200,
  "ora"    => 4000,
  "mithril"=> 4800,
  "laje"   => 13600,
  "alum"   => 18400,
  "vultite"=> 24000,
  "rolaren"=> 28800,
  "veniom" => 40000,
  "kelyn"  => 49600,
  "invar"  => 60000,
  "golvern"=> 76000,
  "vaalin" => 100000
}

materials_to_craft.keys.each do |material|
  unless pick_numbers.key?(material)
    message("Warning: No item number or cost found for #{material}")
    pick_costs[material] = 0
  end
end

attempts = Hash.new(0)

materials_to_craft.each do |material, data|
  # --- Withdraw bank note for bars if enabled and not yet done ---
  if $enable_withdraw_note && $bank_note_amount && !$bank_note_amount.strip.empty? && !$bank_note_withdrawn
    Script.run('go2', 'bank')
    waitrt?
    fput "deposit all"
    sleep 0.5
    fput "withdraw #{$bank_note_amount} note"
    sleep 0.5
    fput "stow note"
    waitrt?
    $bank_note_withdrawn = true
    Script.run('go2', 'rogue guild toolbench')
    waitrt?
  end

  loop do
    attempt_start = Time.now
    attempts[material] += 1

    elapsed_time = Time.now - start_time
    message("Total time spent so far: #{(elapsed_time / 60).floor} min, #{(elapsed_time % 60).round} sec")

    order_response = dothis("order #{pick_numbers[material]}", /A workshop attendant/)
    silver_cost = pick_costs[material] || 0

    silver_spent[material] += silver_cost
    total_silver_spent += silver_cost

    fput "get note"
    sleep 1
    fput "buy"
    sleep 1
    fput "stow right"
    sleep 1
    fput "swap" if checkright != /#{material}/
    sleep 1

    result = dothis("lm create", /.+/)

    rt = 0
    if result =~ /Roundtime: (\d+) sec/i
    rt = $1.to_i
    end

    total_picks_created[material] += 1
    attempt_duration = rt
    pick_attempt_times[material] << "#{(attempt_duration / 60).floor} min, #{(attempt_duration % 60).round} sec"

    # total_picks_created[material] += 1
    # attempt_duration = Time.now - attempt_start
    # pick_attempt_times[material] << "#{(attempt_duration / 60).floor} min, #{(attempt_duration % 60).round} sec"

    log_entry = {
      time: Time.now.strftime("%Y-%m-%d %H:%M:%S"),
      material: material,
      quality: result.include?("exceptional") ? "Exceptional" : "Average",
      attempts: attempts[material],
      silver_spent: silver_spent[material],
      attempt_time: pick_attempt_times[material].last
    }
    log_data << log_entry

    message("Attempt #{attempts[material]} - #{material} lockpick crafted: #{log_entry[:quality]}")
    message("Time Spent on This Attempt: #{log_entry[:attempt_time]}")
    message("Silver Spent on #{material} so far: #{silver_spent[material]}")

    if result.include?("average")
      waitrt?
      message("**********************************")
      message("Low Pick Quality, Making Another")
      message("**********************************")
      sleep 1
      fput "put my lockpick in my #{Vars.average_sack}"
      next
    elsif result.include?("You carefully slice the ruined part of the bar")
        waitrt?
        message("**********************************")
        message("Ruined The Bar, Re-Attempting")
        message("**********************************")
        sleep 1
        # RETURN TO RESULT = DOTHIS("lm create", /.+/)
        redo
    elsif result.include?("exceptional")
      waitrt?
      exceptional_pick_completion[material] = Time.now.strftime("%Y-%m-%d %H:%M:%S")

      message("*********************************************************")
      message("Best Pick Quality for #{material}, Marking as Done")
      message("Time Spent Crafting: #{(attempt_duration / 60).floor} min, #{(attempt_duration % 60).round} sec")
      message("Attempts: #{attempts[material]} on Material: #{material}")
      message("Completion Time: #{exceptional_pick_completion[material]}")
      message("*********************************************************")
      sleep 1
      # --- Use GUI selections for customizing ---
      if $customizing_dye && $custom_color
        Script.run('go2', 'bank')
          waitrt?
          fput "withdraw 500 silver"
          waitrt?
          Script.run('go2', 'rogue guild toolbench')
          waitrt?
          fput "swap" unless checkright =~ /lockpick/i
          sleep 1
        fput "lmas cust dye #{$custom_color}"
        waitrt?
        sleep 1
        fput "lmas cust dye #{$custom_color}"
        waitrt?
        sleep 3
      end
      if $customizing_edge && $custom_material
        # Check cost for selected edging material
        edge_mat = $custom_material.downcase.strip
        edge_cost = edge_materials_costs[edge_mat] || 0
        if edge_cost > 0
          message("Withdrawing #{edge_cost} silver for edging material: #{$custom_material}")
          # Go to bank, withdraw, return to toolbench
          Script.run('go2', 'bank')
          waitrt?
          fput "withdraw #{edge_cost} silver"
          waitrt?
          Script.run('go2', 'rogue guild toolbench')
          waitrt?
          fput "swap" unless checkright =~ /lockpick/i
          sleep 1
        end
        fput "lmas cust edge #{$custom_material}"
        waitrt?
        sleep 1
        fput "lmas cust edge #{$custom_material}"
        waitrt?
        sleep 3
      end
       if $customizing_inset && $custom_gem && !$custom_gem.strip.empty?
        gem_name = $custom_gem.split(':').first.strip
        # Find the gem object by name in inventory_summary or GameObj.inv
        # gem_obj = nil
        # gem_obj = GameObj.inv.find { |obj| obj.name.downcase.include?(gem_name.downcase) }
        gem_obj = nil
        [inset_sack = Vars.inset_sack, gem_sack = Vars.gem_sack].each do |sack_name|
        next unless sack_name && !sack_name.strip.empty?
        sack_obj = GameObj.inv.find { |cont| cont.noun =~ /\b#{sack_name}\b/i }
        if sack_obj && sack_obj.contents
          gem_obj = sack_obj.contents.find { |obj| obj.name.downcase.include?(gem_name.downcase) }
          break if gem_obj
        end
      end
        if gem_obj
          # Uses the gem's unique id to get and inset the correct gem
          sleep 0.5
          waitrt?
          fput "swap" unless checkright =~ /lockpick/i
          sleep 0.5
          fput "get ##{gem_obj.id}"
          sleep 1
          fput "lmas cust inset ##{gem_obj.id}"
          waitrt?
          sleep 1
          fput "lmas cust inset ##{gem_obj.id}"
          waitrt?
          sleep 3
        else
          # fallback to old behavior if not found
          sleep 0.5
          waitrt?
          fput "swap" unless checkright =~ /lockpick/i
          sleep 0.5
          fput "get my ##{gem_name}"
          sleep 1
          fput "lmas cust inset ##{gem_name}"
          waitrt?
          sleep 1
          fput "lmas cust inset ##{gem_name}"
          waitrt?
          sleep 3
        end
       end
      if $use_keyring
        waitrt?
        fput "put my lockpick on my keyring"
      else
        waitrt?
        fput "put lockpick in my #{Vars.exceptional_sack}"
      end
      data[:exceptional] = true
      break
    end
  end
end

message("***************************************")
message("All Lockpicks Are Exceptional Quality!")
message("***************************************")

message("***** Lockpick Maker Crafting Summary *****")
log_data.each { |entry| message("** Material: #{entry[:material]}, Attempts: #{attempts[entry[:material]]}, Total Silver Spent: #{entry[:silver_spent]}, Time Spent: #{entry[:attempt_time]}") }

# message("*** Total Picks Crafted:")
# total_picks_created.each { |material, count| message("** #{material}: #{count} picks") }

# message("*** Silver Spent Per Material:")
# silver_spent.each { |material, amount| message("** #{material}: #{amount} silver") }

# message("*** Time Spent Per Lockpick Attempt:")
# pick_attempt_times.each { |material, times| message("** #{material}: #{times.join(', ')}") }

# message("*** Completion Time for Each Exceptional Lockpick:")
# exceptional_pick_completion.each { |material, timestamp| message("** #{material}: Completed at #{timestamp}") }

message("** Total Silver Spent Across All Materials: #{total_silver_spent}")

total_crafting_time = Time.now - start_time
message("** Total Crafting Time: #{(total_crafting_time / 60).floor} min, #{(total_crafting_time % 60).round} sec")
message("***** Lockpick Maker script complete. Happy picking! *****")

message("***** Detailed Per-Material Summary *****")
materials_to_craft.each do |material, data|
  attempts_count = attempts[material]
  silver = silver_spent[material]
  picks = total_picks_created[material]
  times = pick_attempt_times[material]
  message("** Material: #{material}, Attempts: #{attempts_count}, Total Silver Spent: #{silver}, Picks Created: #{picks}, Time Spent: #{times.join(', ')}")
end

message("Thank you for using Lockpick Maker!")
