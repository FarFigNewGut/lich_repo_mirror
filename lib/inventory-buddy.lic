=begin

	This script tracks the inventory and locker contents of all of your characters. You can then bring up the window and look through the containers on different characters to see what is in each container, you can also see what is in their lockers.
	
	There is also a search feature where you can search through the inventory and lockers of all of your characters to find what you are looking for.
	
	Leave the script running in the background to keep the database up to date.
	To bring up the ;inventory-buddy window: while script is running enter ;send inv
	The database will update your character's inventory whenever you enter INV FULL.
	The database will update your character's locker contents whenever you LOOK in your locker.
	The database will also update your character's locker contents whenever you look at your locker manifest.
	
	Future planned updates:
	;send scan will LOOK in every item in your locker to track the contents of any containers in your locker. Right now the script just tracks what is in your locker.
	Locker contents will be updated when an item is put in your locker or taken out of your locker. Right now the only way to update your locker is to LOOK in it.

	########################################################
	Ways to contact me:
	In game: Dreaven
	Player's Corner: Tgo01
	Discord: Dreaven#6436
	Email: LordDreaven@gmail.com
	If you like my scripts feel free to send me a tip via Paypal at: LordDreaven@gmail.com
	########################################################
	
	Version 1: Initial release!
	Version 2: Script now updates the database whenever you look at your locker manifest.
	Version 2: Script should no longer show (marked) or (registered) on items in a locker.
	
	Author: Dreaven
	Version: 2

=end

require 'gtk3'
require 'json'

toggle_upstream

class InventoryBuddyMain
	@scanning_inventory = nil
	@person_deleted = nil
	@character_menu = nil
	@main_window = nil
	@search_entry = nil
	@tooltips ={
		"Character Menu" => "Select character from this menu.",
		"Container Menu" => "Select container to see what its contents are. \"All Inventory\" shows all items on this character, it does not show the contents of their locker.",
		"Search" => "Enter the name of the item you want to find. Note this searches through the inventory and lockers of ALL characters.",
		"Delete Character" => "If you wish to remove a character and all of their saved data from the database, then enter their name in the box and click the \"Delete\" button.",
	}
	
	def self.create_window
		@main_window = Gtk::Window.new(:toplevel)
		@main_window.set_keep_above(true)
		@main_window.set_title("Inventory Buddy")
		
		load_all_info("inventory-buddy.json")
		
		@parent_grid = Gtk::Grid.new
		@drop_down_grid = Gtk::Grid.new
		@inv_grid = Gtk::Grid.new
		@search_grid = Gtk::Grid.new
		
		@scroll_window = Gtk::ScrolledWindow.new
		@scroll_window.set_policy(Gtk::PolicyType::AUTOMATIC, Gtk::PolicyType::AUTOMATIC)
		
		@parent_grid.attach(@drop_down_grid, 0, 0, 1, 1)
		@parent_grid.attach(@search_grid, 0, 1, 1, 1)
		@parent_grid.attach(@inv_grid, 0, 2, 1, 1)
		
		@search_entry = Gtk::Entry.new
		@delete_button = Gtk::Button.new(:label => "Delete")
		@delete_entry = Gtk::Entry.new
		@search_grid.attach(Gtk::Label.new("Search:"), 0, 0, 1, 1)
		@search_grid.attach(@search_entry, 0, 1, 1, 1)
		@search_grid.attach(Gtk::Label.new("Delete Character Info:"), 1, 0, 1, 1)
		@search_grid.attach(@delete_entry, 1, 1, 1, 1)
		@search_grid.attach(@delete_button, 2, 1, 1, 1)
		
		@search_grid.set_tooltip_text(@tooltips["Search"])
		@delete_button.set_tooltip_text(@tooltips["Delete Character"])
		@delete_entry.set_tooltip_text(@tooltips["Delete Character"])
		
		@main_window.signal_connect("destroy") do
			@main_window.close
			@main_window = nil
			@character_menu = nil
			Gtk.main_quit
		end
		
		@character_menu = Gtk::ComboBoxText.new
		@container_menu = Gtk::ComboBoxText.new
		@character_menu.set_tooltip_text(@tooltips["Character Menu"])
		@container_menu.set_tooltip_text(@tooltips["Container Menu"])
		@all_inv_data.each{ |name, containers| @character_menu.append_text(name) }
		
		@drop_down_grid.attach(@character_menu, 0, 0, 1, 1)
		@drop_down_grid.attach(@container_menu, 1, 0, 1, 1)
		
		@inv_label = Gtk::Label.new
		@inv_grid.attach(@scroll_window, 0, 0, 1, 1)
		@scroll_window.add(@inv_label)
		@inv_label.set_xalign(0)
		@inv_label.set_yalign(0)
		
		@search_entry.signal_connect('changed') { search_items if @search_entry.text.length > 0 }
		@delete_button.signal_connect('clicked') { delete_character }
		
		@character_menu.signal_connect("changed") do
			name = @character_menu.active_text
			@search_entry.text = ""
			@container_menu.remove_all
			@container_menu.append_text("All Inventory")
			@container_menu.append_text("Locker") if @all_inv_data[name].keys.any?{ |i| i == "Locker" }
			@all_inv_data[name].each{ |container,contents| @container_menu.append_text(container) if container !~ /^(All Inventory|Locker)$/}
			@container_menu.active = 0
		end
		
		@container_menu.signal_connect("changed") do
			name = @character_menu.active_text
			container = @container_menu.active_text
			@search_entry.text = ""
			text = ""
			@all_inv_data[name][container].each{ |item|
				if @all_inv_data[name].keys.any?{ |i| i == item.strip } && container == "All Inventory"
					text += "<span foreground='green'>#{item}</span>\n"
				else
					text += "#{item}\n"
				end
			}
			@inv_label.set_markup(text)
		end
		
		@scroll_window.set_size_request(500, 500)
		@main_window.resize(600, 600)
		
		@main_window.add(@parent_grid)
		@main_window.show_all
	end
	
	def self.delete_character
		name = @delete_entry.text.strip.capitalize

		if !name.empty? && @all_inv_data.key?(name)
			@person_deleted = true
			save_and_load
			@character_menu.remove_all
			@all_containers = {}
			@all_inv_data.each{ |name, containers| @character_menu.append_text(name) }
			respond "#{name} has been deleted."
		elsif name.empty?
			respond "Enter the name of the character you want to delete."
		else
			respond "#{name} not found."
		end
		@delete_entry.text = ""
	end
	
	def self.search_items
		query = @search_entry.text.downcase
		results = []

		search_inv_hash(@all_inv_data, query, results)
		
		text = ""
		number = 0
		results.each{ |item|
			if item !~ /On a weapon rack\:|On an armor stand\:|In a clothing wardrobe\:|In a magical item bin\:|In a deep chest\:/ && item.length > 0
				text += "#{item}\n"
				number += 1
			end
		}
		text += "#{number} items found\n"
		@inv_label.set_markup(text)
	end
	
	def self.search_inv_hash(data, query, results, person = nil, container = nil)
		data.each do |item, value|
			if value.is_a?(Hash)
				search_inv_hash(value, query, results, item, container)
			elsif value.is_a?(Array)
				search_inv_array(value, query, results, person, item)
			elsif value.to_s.downcase.include?(query)
				results << "#{item} - #{person} (#{container})" if person && container && container != "All Inventory"
			end
		end
	end
	
	def self.search_inv_array(array, query, results, person, container)
		array.each do |item|
			if item.is_a?(Hash)
				search_in_hash(item, query, results, person, container)
			elsif item.to_s.downcase.include?(query)
				results << "#{item} - #{person} (#{container})" if person && container && container != "All Inventory"
			end
		end
	end
	
	def self.save_data(name, file_path)
		all_characters_data = {} unless File.exist?(file_path)

		if File.exist?(file_path)
			data = File.read(file_path)
			all_characters_data = JSON.parse(data)
		end

		if @person_deleted
			all_characters_data.delete(name)
		else
			all_characters_data[name] = @all_containers
		end

		data = JSON.dump(all_characters_data)

		File.open(file_path, 'w') do |file|
			file.puts(data)
		end
		check_in_list
	end

	def self.load_all_info(file_path)
		return unless File.exist?(file_path)

		serialized_data = File.read(file_path)
		@all_inv_data = JSON.parse(serialized_data)
		if @person_deleted
			@character_menu.active = -1
		else
			if @character_menu
				current_menu_option = @character_menu.active
				@character_menu.active = -1
				@character_menu.active = current_menu_option
			end
		end
		@search_entry.text = "" if @search_entry
		@person_deleted = nil
	end
	
	def self.check_in_list
		model = @character_menu.model
		name_found = nil
		if model
			model.each do |model, path, iter|
				item_text = iter[0]
				if item_text == checkname
					name_found = true
					break
				end
			end
		end
		@character_menu.append_text(checkname) if name_found.nil?
	end
	
	def self.start_container_hash
		if @all_containers.nil?
			@all_containers = {}
		else
			@all_containers = @all_containers.select { |key, _| key == "Locker" }
		end
		@all_containers["All Inventory"] = []
		@all_containers["Worn"] = []
		@scanning_inventory = true
	end
	
	def self.save_and_load
		save_data(checkname, "inventory-buddy.json")
		load_all_info("inventory-buddy.json")
	end
	
	def self.watching
		before_dying{
			@main_window.close if @main_window
		}
		
		put "inv full"

		while line = get
			#Inventory management
			if line =~ /^You are currently wearing\:/
				start_container_hash
			elsif line =~ /^(\s{2})([a-zA-Z]+ .*)/ && @scanning_inventory
				item_name = $2
				@all_containers["All Inventory"].push($1 + item_name.gsub(/ \((marked|registered)\)/, ""))
				item_name.gsub!(" (marked)", "")
				item_name.gsub!(" (registered)", "")
				@all_containers["Worn"].push(item_name)
				containers = []
				last_container_index = 0
			elsif line =~ /^(\s{6,})([a-zA-Z]+ .*)/ && @scanning_inventory
				spaces = $1.length
				item_name = $2
				@all_containers["All Inventory"].push($1 + item_name.gsub(/ \((marked|registered)\)/, ""))
				item_name.gsub!(" (marked)", "")
				item_name.gsub!(" (registered)", "")
				container_index = (spaces - 6) / 4
				if last_container_index != container_index
					(last_container_index - container_index).times{ containers.pop } if (last_container_index - container_index) > 0
					last_container_index = container_index
				end

				if containers[container_index].nil?
					if container_index == 0
						containers[container_index] = @all_containers["Worn"].last
					else
						containers[container_index] = @all_containers[containers[container_index - 1]].last
					end
					container_count = @all_containers.keys.find_all{ |i| i =~ /#{containers[container_index]}/ }
					containers[container_index] = "#{containers[container_index]} #{(container_count.count + 1).to_s}" if container_count.count > 0
				end
				
				container = containers[container_index]
				unless @all_containers[container].count > 0
					@all_containers[container] = []
					@all_containers[container].push("This container is inside of #{containers[container_index - 1]}") unless container_index - 1 < 0
				end
				@all_containers[container].push(item_name)
			elsif line =~ /^\(Items\: .*\)/ && @scanning_inventory
				put "glance"
			elsif line =~ /^You are carrying nothing at this time./
				start_container_hash
				@all_containers["Worn"].push("NOTHING")
				put "glance"
			elsif line =~ /You glance down to see (.*) in your right hand and (.*) in your left hand./ && @scanning_inventory
				@all_containers["Held"] = []
				right_hand = $1
				left_hand = $2
				if right_hand != "nothing"
					@all_containers["Held"].push(right_hand)
					@all_containers["All Inventory"].push("#{right_hand} (Held)")
				end
				if left_hand != "nothing"
					@all_containers["Held"].push(left_hand)
					@all_containers["All Inventory"].push("#{left_hand} (Held)")
				end
				@scanning_inventory = nil
				save_and_load
				@finished_with_scan = true
			elsif line =~ /You glance down at your empty hands./ && @scanning_inventory
				save_and_load
				@scanning_inventory = nil
				@finished_with_scan = true
			#Locker management
			elsif line =~ /^In the locker\:/
				@all_containers = {} if @all_containers.nil?
				@all_containers["Locker"] = []
				while line = get
					if line =~ /.* \[\d+\]\: /
						items = line.split(/.* \[\d+\]\: |, /)
						items.each{ |i|
							if i.length > 0
								matches = i.scan(/\((\d+)\)/)
								if matches.any?
									number = matches[0][0].to_i
									i = i.split(/ \(\d+\)/)
									number.times{ @all_containers["Locker"].push(i.join(", ").gsub(/ \((marked|registered)\)/, "")) }
								else
									@all_containers["Locker"].push(i.gsub(/ \((marked|registered)\)/, ""))
								end
							end
						}
					elsif line =~ /Total items:/
						save_and_load
						break
					end
				end
			elsif line =~ /^In the locker you see /
				@all_containers = {} if @all_containers.nil?
				@all_containers["Locker"] = []
				line.chop!
				items = line.split(/In the locker you see |, | and /)
				items.each{ |i| @all_containers["Locker"].push(i.gsub(/ \((marked|registered)\)/, "")) if i.length > 0 }
				save_and_load
			elsif line =~ /^Looking in front of you, you see the contents of your locker in|^Thinking back, you recall the contents of your locker in/
				@all_containers = {} if @all_containers.nil?
				@all_containers["Locker"] = []
				while line = get
					if line !~ /Obvious items\:/
						@all_containers["Locker"].push(line.gsub(/ \((marked|registered)\)/, ""))
					elsif line =~ /Obvious items\:/
						save_and_load
						break
					end
				end
			#Commands
			elsif line == "inv"
				if @main_window.nil?
					Gtk.queue {
						InventoryBuddyMain.create_window
						Gtk.main
					}
				end
			end
		end		
	end
end

3.times{ respond "############################################################################################################" }
respond "Message from ;inventory-buddy"
respond "Leave the script running in the background to keep the database up to date."
respond "To bring up the ;inventory-buddy window: while script is running enter ;send inv"
respond "The database will update your character's inventory whenever you enter INV FULL."
respond "The database will update your character's locker contents whenever you LOOK in your locker."
3.times{ respond "############################################################################################################" }

InventoryBuddyMain.watching