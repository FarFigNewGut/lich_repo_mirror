=begin
  poisoncraft automation for Gemstone IV

  ;poisoncraft --poison dreamer --limit 300

  changelog:
    1.0.0 - initial version with poison charge calculations from GSWiki
    1.0.1 - updated calculate_applications with correct poison charges

  version: 1.0.1
  required: Lich 4.3.12
  author: Ondreian
  tags: rogue, poisoncraft, automation
  
=end

module Poisoncraft
  @poisons = {
    :disabling => {
      "dreamer" => "Dreamer's Milk",
      "merrybud" => "Merrybud",
      "snailspace" => "Snailspace Poison",
      "dullard" => "Dullard's Folly",
      "jester" => "Jester's Bane"
    },
    :deadly => {
      "ravager" => "Ravager's Revenge",
      "ophidian" => "Ophidian Kiss",
      "shatterlimb" => "Shatterlimb Poison",
      "fools" => "Fool's Deathwort",
      "arachne" => "Arachne's Bite"
    }
  }

  ValidDeadlyPoisons = @poisons[:deadly].keys
  ValidDisablingPoisons = @poisons[:disabling].keys
  ValidPoisonsString = "\tdeadly: " + ValidDeadlyPoisons.join(", ") + "\n" + "\tdisabling: " + ValidDisablingPoisons.join(", ")

  def self.calculate_applications(charges)
    # Poison charges per creation based on GSWiki data
    poison_charges = {
      "dreamer" => 150,     # Dreamer's Milk
      "merrybud" => 100,    # Merrybud
      "snailspace" => 75,   # Snailspace Poison
      "dullard" => 50,      # Dullard's Folly
      "jester" => 50,       # Jester's Bane
      "ravager" => 150,     # Ravager's Revenge
      "ophidian" => 150,    # Ophidian Kiss
      "shatterlimb" => 100, # Shatterlimb Poison
      "fools" => 50,        # Fool's Deathwort
      "arachne" => 50       # Arachne's Bite
    }

    poison = Opts["poison"]
    charges_per_creation = poison_charges[poison] || 50 # default to 50 if unknown

    # Calculate how many applications needed to reach the limit
    limit = (Opts["limit"] || 300).to_i
    remaining_charges = limit - charges

    return 1 if remaining_charges <= 0

    # Calculate applications needed, rounding up
    applications = (remaining_charges.to_f / charges_per_creation).ceil

    # Cap at reasonable maximum to avoid excessive purchases
    [applications, 10].min
  end

  # It is coated with 50 charges of Fool's Deathwort poison.
  def self.recall(item)
    recall = Lich::Util.issue_command("recall ##{item.id}", /As you recall|You are unable/,
      silent: Opts["verbose"] || true,
      quiet: Opts["verbose"] || true,
    )
    match = recall.join("\n").match(/^It is coated with (?<charges>\d+) charges/)
    return match.nil? ? 0 : match[:charges].to_i
  end

  # 1. <d cmd=\"order 1 color 0 material 0\">a black silk climbing pack</d>
  def self.order_apothecary_kit()
    output = Lich::Util.issue_command("order", /^\s+Catalog$/,
      silent: Opts["verbose"] || true,
      quiet: Opts["verbose"] || true,
    )

    menu = output.join("\n").scan(/(\d+)\. <d cmd="order \d+ color 0 material 0">(.*?)<\/d>/).map { |id, name| [name, id.to_i] }.to_h
    menu["an unremarkable apothecary kit"] or fail "failed to find apothecary kit in rogue guild shop"
    fput "order %s" % menu["an unremarkable apothecary kit"]
    fput "buy"
  end

  def self.travel(item, poison, applications)
    @start = Room.current.id
    Script.run("go2","bank")
    fput "withdraw %s silver" % (10_000 * applications)
    Script.run("go2", "rogue guild shop")
    applications.times do
      self.order_apothecary_kit()
      fput "feat poisoncraft create #{poison}"
      2.times { fput "feat poisoncraft apply" }
    end
  end

  def self.main()
    poison = Opts["poison"] or fail "please pass --poison"
    limit  = (Opts["limit"] or 300).to_i

    unless @poisons[:deadly].include?(poison) or @poisons[:disabling].include?(poison)
      fail "invalid poison: #{poison}, valid poisons are:\n#{ValidPoisonsString}"
    end

    fail "please hold the item you want to poison in your right hand" if Char.right.nil?

    if @poisons[:deadly].include?(poison) and !Char.right.type.include?("weapon")
      fail "invalid poison: #{poison}, you can only poison weapons with deadly poisons"
    end

    charges = self.recall(Char.right).to_i
    applications = self.calculate_applications(charges)
    #Log.out("applications=%s" % applications, label: %i(applications))
    self.travel(Char.right, poison, applications)
    charges = self.recall(Char.right).to_i
    Log.out("#{Char.right.name} has #{charges} charges")
  end

  self.main() unless Opts["test"]
end