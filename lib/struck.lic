=begin

	This is the "client" script of the ;thunder and ;struck script duo. This script doesn't do anything without ;thunder so be sure to download ;thunder first and read the information for that script on how to use both ;thunder and ;struck.

	Version 1: Initial release!
	Version 2: Sending a command from ;thunder that starts with either 'script' or ';' will start a lich script.
	Version 2: Example: script go2 400 and ;go2 400 would both work.
	Version 3: Script now tracks more status conditions and will now track multiple status conditions. You can now see if a character is bleeding AND stunned. Or even bleeding, stunned, and sleeping!
	Version 3: Script can now track the field experience of all characters.
	Version 3: Script can now track the encumbrance of all characters.
	Version 3: You can now send commands to clients via ;send, because clicking buttons is too much work.
		To send a command to everyone do: ;send t all <command> || example: ;send t all wave
		To send a command to a specific character do: ;send t <name> <command> || example ;send t dreaven wave
		Works for scripts too! ;send t Dreaven ;go2 bank
		You can also partially match a character's name. Example: ;send t dre wave
	Version 4: The Settings tab is now scrollable, so be sure to scroll to the bottom if you don't see the "Save" button. Now without the Settings stretching out the window it means you can make the Main window smaller now if you want.
	Version 4: You now have the option of having the Stats tab and the Logs tab in their own separate windows, or hiding the tab/window altogether.
	Version 4: Added a Monitor tab which can monitor the game lines of a client as well as the scripts that client is currently running. Monitor also has the option of being a tab, being in its own window, or being hidden.
	Version 4: Added option to hide the Settings tab. If tab is hidden then start script as ;thunder set to show the tab again.
	Version 5: Fixed regex issue with gem bounties.

	########################################################
	Ways to contact me:
	In game: Dreaven
	Player's Corner: Tgo01
	Discord: Dreaven#6436
	Email: LordDreaven@gmail.com
	If you like my scripts feel free to send me a tip via Paypal at: LordDreaven@gmail.com
	########################################################
	
	Author: Dreaven
	Version: 5

=end

require 'socket'

hide_me

UserVars.struck_port_number = $1 if script.vars[1] =~ /(\d+)/

if UserVars.struck_port_number
	port = UserVars.struck_port_number.to_i
else
	port = 4000
end

respond "#################################################################################################################"
respond "Message from ;struck:"
respond "You are currently set to connect to port #{port}."
respond "By default the port each character tries to connect to is port 4000."
respond "If you want to change this then stop this script and start it as ;struck <number_here>"
respond "For example: ;struck 3000"
respond "After you have set the port number on this character you can start script as: ;struck"
respond "You only have to specify the port number if you want to change it again."
respond "#################################################################################################################"

@client = TCPSocket.new('localhost', port)
@needed_values = {}
$send_the_game_lines = nil

exit_reason = nil

@silence = proc{
	started = false
	hook_proc = proc { |s|
		if started
			if s =~ /<prompt/
				DownstreamHook.remove("struck_silence")
				nil
			elsif s =~ /<output/
				s
			else
				nil
			end
		elsif s =~ /Level:/
			started = true
			nil
		else
			s
		end
	}
	DownstreamHook.add("struck_silence", hook_proc)
}

def send_message(message)
	echo "Message sent: #{message}" if @needed_values["Debug Mode"] == "Yes"
	@client.puts(message)
end
def receive_message
	message = @client.gets.chomp
	echo "Message from server: #{message}"
	if message.length < 1
		exit_reason = "Disconnecting: Server appears to be closed."
		exit
	elsif message == "Shut down."
		exit_reason = "Disconnecting: Server told me to disconnect."
		exit
	elsif message =~ /Requests\: (.*)/
		list = $1.split(", ")
		list.each{ |info|
			data = info.split(": ")
			@needed_values[data[0]] = data[1]
		}
	elsif message == "Respond now."
		send_message("#{checkname}: I am responding.")
	elsif message == "Send game lines."
		$send_the_game_lines = true
	elsif message == "Stop sending game lines."
		$send_the_game_lines = nil
	elsif message =~ /Action\: (.*)/
		action = $1
		if action =~ /^script|^;/i
			vars = action.split(/script |\s|;/i)
			vars.shift
			script_name = vars.shift
			Script.run(script_name, "#{vars.join(" ")}")
		else
			put action
		end
	end
end

def update_stat_values(stat_name, current_number, max_number)
	if (current_number != @current_stats[stat_name]) && (@needed_values[stat_name] == "Yes")
		@current_stats[stat_name] = current_number
		send_message("#{checkname}: #{stat_name}: #{current_number}/#{max_number}")
	end
end

def update_status
	all_wounds = Wounds.head, Wounds.neck, Wounds.abs, Wounds.lhand, Wounds.rhand, Wounds.larm, Wounds.rarm, Wounds.chest, Wounds.back, Wounds.rleg, Wounds.lleg, Wounds.nerves, Wounds.leye, Wounds.reye, Scars.head, Scars.neck, Scars.abs, Scars.lhand, Scars.rhand, Scars.larm, Scars.rarm, Scars.chest, Scars.back, Scars.rleg, Scars.lleg, Scars.nerves, Scars.leye, Scars.reye
	info = []
	info.push("Injured") if all_wounds.any?{ |i| i > 0 }
	info.push("Prone") if checkprone
	info.push("Poisoned") if checkpoison
	info.push("Diseased") if checkdisease
	info.push("Bleeding") if checkbleeding
	info.push("Stunned") if checkstunned
	info.push("Webbed") if checkwebbed
	info.push("Bound") if checkbound
	info.push("Calmed") if checkcalmed
	info.push("Cut Throat") if checkcutthroat
	info.push("Silenced") if checksilenced
	info.push("Sleeping") if checksleeping
	info = "GREAT!" if info.empty?
	info = "DEAD" if checkdead
	
	info = info.join(", ") if info.is_a?(Array)
	
	stat_name = "Status"
	if info != @current_stats[stat_name]
		@current_stats[stat_name] = info
		send_message("#{checkname}: #{stat_name}: #{info}")
	end
end

def update_bounty
	if checkbounty =~ /The local gem dealer, .*, has an order to fill and wants our help./
		info = "Gem NPC"
	elsif checkbounty =~ /received orders from multiple customers requesting [a-zA-Z]+ (.*)\.  You have been tasked to retrieve (\d+) of them./
		info = "#{$2} #{$1}"
	elsif checkbounty =~ /WAIT for [a-zA-Z]+ to meet you there.  You must guarantee [a-zA-Z]+ safety to (.*) as soon as you can/
		info = "Escort #{$1}"
	elsif checkbounty =~ /The local healer, .*, has asked for our aid./
		info = "Herb NPC"
	elsif checkbounty =~ /working on a concoction that requires [a-zA-Z]+ (.*) found (?:on|in|near) (.*).  These samples must be in .* condition.  You have been tasked to retrieve (\d+) samples/
		info = "#{$3} #{$1} #{$2}"
	elsif checkbounty =~ /The local furrier .* has an order to fill and wants our help/
		info = "Skin NPC"
	elsif checkbounty =~ /You have been tasked to retrieve (\d+) (.*) of at least (.*) quality .* You can SKIN them off the corpse of [a-zA-Z]+ (.*) or purchase them from another adventurer./
		info = "#{$1} #{$2}"
	elsif checkbounty =~ /It appears they need your help in tracking down some kind of lost heirloom/
		info = "Heirloom NPC"
	elsif checkbounty =~ /You have been tasked to recover (.*) that an unfortunate citizen lost after being attacked by [a-zA-Z]+ (.*?) (?:on|in|near) (.*)\.  The heirloom .*SEARCH the area until you find it/
		info = "Heirloom Search #{$3}"
	elsif checkbounty =~ /You have been tasked to recover (.*) that an unfortunate citizen lost after being attacked by [a-zA-Z]+ (.*?) (?:on|in|near) (.*)\.  The heirloom .*Hunt down the creature and LOOT the item from its corpse./
		info = "Heirloom #{$1} #{$2} #{$3}"
	elsif checkbounty =~ /You have located .* and should bring it back to/
		info = "Heirloom FOUND"
	elsif checkbounty =~ /It appears that a local resident urgently needs our help in some matter./
		info = "Child NPC"
	elsif checkbounty =~ /A local divinist has had visions of the child fleeing from an? (.*?) (?:on|in|near) (.*)\.  Find the area/
		info = "Find Child #{$1} #{$2}"
	elsif checkbounty =~ /You have made contact with the child/
		info = "Return Child"
	elsif checkbounty =~ /child you were tasked to rescue is gone and your task is failed/
		info = "Child FAILED"
	elsif checkbounty =~ /It appears they have a bandit problem they'd like you to solve.|order to help [a-zA-Z]+ take care of a bandit problem./
		info = "Bandits NPC"
	elsif checkbounty =~ /You have been tasked to suppress bandit activity (?:on|in|near) (.*)\.  You need to kill (\d+).*of them to complete your task./ || checkbounty =~ /You have been tasked to help [a-zA-Z]+ suppress bandit activity (?:on|in|near) (.*)\.  You need to kill (\d+).*of them to complete your task./
		info = "#{$2} Bandits"
	elsif checkbounty =~ /It appears they have a creature problem they'd like you to solve/
		info = "Creatures NPC"
	elsif checkbounty =~ /You have been tasked to suppress (.*) activity (?:on|in|near) (.*)\.  You need to kill (\d+) of them to complete your task./ || checkbounty =~ /suppressing (.*) activity (?:on|in|near) (.*) during .*\.  You need to kill (\d+).*of them to complete your task./ || checkbounty =~ /suppress (.*) activity (?:on|in|near) (.*)\.  You need to kill (\d+).*of them to complete your task./
		info = "#{$3} #{$1}"
	elsif checkbounty =~ /You have been tasked to hunt down and kill a particularly dangerous (.*) that has established a territory (?:on|in|near) (.*)\.  You can get its attention by killing other creatures of the same type in its territory./
		info = "Dangerous #{$1}"
	elsif checkbounty =~ /You have been tasked to hunt down and kill a particularly dangerous (.*) that has established a territory (?:on|in|near) (.*)\.  You have provoked .* attention/
		info = "Dangerous #{$1}"
	elsif checkbounty =~ /to help [a-zA-Z]+ take care of an urgent matter.|to help [a-zA-Z]+ retrieve a lost heirloom|to help [a-zA-Z]+ take care of a creature problem./
		info = "Help NPC"
	elsif checkbounty =~ /You have succeeded in your task and can return to the Adventurer's Guild to receive your reward./
		info = "Finished Guild"
	elsif checkbounty =~ /You succeeded in your task and should report back/
		info = "Finished Guard"
	elsif checkbounty =~ /You are not currently assigned a task./
		info = "None"
	end
	
	stat_name = "Bounty"
	if info != @current_stats[stat_name]
		@current_stats[stat_name] = info
		send_message("#{checkname}: #{stat_name}: #{info}")
	end
end

def update_exp
	$current_field_exp = nil
	$max_field_exp = nil
	silence_me
	put "exp"
	silence_me
	@silence.call
	wait_until{ $max_field_exp }
	update_stat_values("Field Exp", $current_field_exp, $max_field_exp)
end

def update_room
	info = Room.current.id

	stat_name = "Room #"
	if info != @current_stats[stat_name]
		@current_stats[stat_name] = info
		send_message("#{checkname}: #{stat_name}: #{info}")
	end
end

before_dying{
	DownstreamHook.remove("struck_silence")
	exit_reason = "Disconnecting: Script was stopped." if exit_reason.nil?
	echo exit_reason
	send_message("#{checkname}: #{exit_reason}")
	@client.close
}

send_message(checkname)

@current_stats = {}

Thread.new{
	wait_until{ @needed_values.count > 0 }
	if @needed_values["Stats"] != "Hide"
		if @needed_values["Field Exp"] == "Yes"
			@needed_values["Update Exp"] = @needed_values["Update Exp"].to_i
			loop{
				@last_mind_state = checkmind.dup
				update_exp
				seconds_remaining = @needed_values["Update Exp"].dup
				@needed_values["Update Exp"].times{
					sleep 1
					seconds_remaining -= 1
					break if seconds_remaining < 1
					break if @last_mind_state != checkmind
				}
			}
		end
	end
}

Thread.new{
	wait_until{ @needed_values.count > 0 }
	if @needed_values["Stats"] != "Hide"
		if @needed_values["Room #"] == "Yes"
			update_room
			loop{
				update_room
				sleep @needed_values["Update Room"].to_f
			}
		end
	end
}

Thread.new{
	wait_until{ @needed_values.count > 0 }
	if @needed_values["Stats"] != "Hide"
		loop{
			update_stat_values("Health", health, maxhealth)
			update_stat_values("Mana", mana, maxmana)
			update_stat_values("Stamina", stamina, maxstamina)
			update_stat_values("Spirit", spirit, maxspirit)
			update_stat_values("Encumbrance", percentencumbrance, 100)
			update_status if (@needed_values["Status"] == "Yes")
			update_bounty if (@needed_values["Bounty"] == "Yes")
			sleep @needed_values["Update Info"].to_f
		}
	end
}

Thread.new{
	wait_until{ @needed_values.count > 0 }
	game_lines = {}
	@needed_values["Seen Lines"] = @needed_values["Seen Lines"].to_i
	@needed_values["Monitor Entries"] = @needed_values["Monitor Entries"].to_i
	while line = get
		if line =~ /Field Exp: ([\d,]+)\/([\d,]+)/ && $max_field_exp.nil?
			$current_field_exp = $1.delete(",").to_i
			$max_field_exp = $2.delete(",").to_i
		else
			if @needed_values["Monitor Entries"] > 0
				if @needed_values["Seen Lines"] > 0
					game_lines[line] += 1 if ((game_lines[line]) && ((@needed_values["Seen Lines"] + 1) > game_lines[line])) || (game_lines[line].nil?)
				end
				if $send_the_game_lines
					send_msg = nil
					send_msg = true if game_lines[line].nil? || ((game_lines[line]) && (@needed_values["Seen Lines"] >= game_lines[line])) || (@needed_values["Seen Lines"] == 0)
					send_message("#{checkname}: Game Line: #{line}") if send_msg
				end
				
			end
		end
	end
}

Thread.new{
	loop{
		wait_until{ $send_the_game_lines }
		old_scripts = nil
		loop{
			running_scripts = []
			Script.running.each{ |script_name| running_scripts.push(script_name.name) }
			break if $send_the_game_lines.nil?
			if running_scripts != old_scripts
				old_scripts = running_scripts.dup
				send_message("#{checkname}: Running Scripts: #{running_scripts.join(", ")}")
			end
			sleep 2
		}
	}
}

loop{
	receive_message
}