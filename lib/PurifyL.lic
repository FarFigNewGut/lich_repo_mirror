=begin

~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~

 Title:  PurifyL
 Date:   May 28, 2018
 Author: Leafiara; previous versions by Aethor, Gibreficul, Shaelun

 How to use:
 Have both hands empty and a supply of gems in your unsungcontainer,
 then start the script with:
 ;PurifyL
 
 Variables:
 ;vars set unsungcontainer = container where you keep unsung gems
 ;vars set orbcontainer = container where your orbs go
 ;vars set sungcontainer = container where your other sung gems go

 Details:
 Purifies gems in your unsungcontainer, then puts orbs in your
 orbcontainer and non-orbs in your sungcontainer.

 Notes:
 Compared to purify2, I added some things and took out others, so I
 can't really call it purify3 since the old one will still be better
 for some needs!
 - Added: explains how to set up the variables
 - Added: more comments in the script for clarity
 - Added: a running tally of how much you're increasing the value
 - Added: separate counts of how many orbs you made vs. how many were
 already orbs
 - Fixed: no longer tries to purify things like direbear fangs
 - Changed: no longer purifies gems that cap out below 5k+
 (The script shows which gems aren't included, so you can add back
 any you want.)
 - Took out: hiding and using Sign of Wracking
 - Took out: singing to orbs and sorting them by value
 (I preferred to do this after purifying, not in the middle.
 Especially after RT for appraising gems was removed!)
 
 If you find any missing gem nouns, let me know! I aim to list
 all gems for completeness, whether they're to be purified or not.
 
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~

=end



VERSION = "1.3"

AUTHOR = "Leafiara Autumnwind"

silence_me



# These are gem nouns that you think it's worth your time and mana to purify! I drew the line at gems that can usually be purified to at least 1.75k or more, but if you'd like a higher cutoff, you can take them out and paste them in the $notwastingtime list down below. Or just delete them, but I like keeping them for reference--a level 15 bard might not be able to get enough extra value out of a mid-range gem, but a level 50 bard might, so it'll be good to be able to add it back in later.

	$gemnouns = ["aetherstone", "auboraline", "blazestar", "bloodjewel", "bluerock", "caederine", "cinderstone", "despanal", "diamond", "doomstone", "^egg$", "emerald", "eostone", "faenor", "feystone", "firestone", "galena", "glimaerstone", "goldstone", "heliotrope", "jacinth", "jade", "mekret", "obsidian", "pearl", "prehnite", "rhimar", "riftshard", "riftstone", "rivertear", "roestone", "rosepar", "sandruby", "saewehna", "shadowglass", "smoldereye", "spherine", "tanzanite", "thunderstone", "turquoise", "waterweb", "wraithaline", "wyrdshard"]


	
# These are gem nouns or names that you *don't* think it's worth your time and mana to purify!

	$notwastingtime = ["agate", "amber", "ambergris", "amethyst", "azurite", "bismuth", "bloodstone", "burnished sepia moonsnail shell", "carbuncle", "chalcedony", "chrysoprase", "coral", "cordierite", "crescent", "dark grey dreamstone fragment", "deathstone", "diopside", "dreamstone", "faenor\-bloom", "fluorite", "fossilized thrak tooth", "fragment", "garnet", "^gem$", "geode", "gypsum", "heliodor", "hematite", "honey-washed violet water sapphire", "hyacinth", "idocrase", "jasper", "lapis", "lazuli", "onyx", "peridot", "pyrite", "quartz", "quartz crystal", "rainbow-hued oval abalone shell", "rock crystal", "rust-speckled ivory slipper shell", "scarlet-shot lustrous black bloodstone", "spinel", "^stone$", "starstone", "teardrop of murky sanguine ruby", "topaz", "tourmaline", "viridine", "wyrmwood", "zircon"]



# These are individual gem names that you think it's worth your time and mana to purify, but can't be put in $gemnouns because either:
# 1 - Their nouns conflict with other things, e.g. if you put "fang" in $gemnouns instead of "gold fang" and "platinum fang" here, you'd be trying to purify direbear fangs and faeroth fangs.
# 2 - They share nouns with other gems that you might not consider worth it (e.g. black opals, blue sky opals, and moonglae opals are much higher value than white opals) or that are definitely not worth it (e.g. a tangerine wulfenite crystal is good but a quartz crystal isn't).

	$gemnames = ["aster opal", "black opal", "black-cored emerald orb", "blackened feystone core", "blue sapphire", "blue shimmarglin sapphire", "blue sky opal", "brilliant red firebird stone", "brilliant wyrm's-tooth amethyst", "cloudy alexandrite shard", "dark blue tempest stone", "deep blue mermaid's-tear sapphire", "dragon's-fang quartz", "dragon's-tear ruby", "dragonfire opal", "dragonsbreath sapphire", "dragonseye sapphire", "droplet of honey amber", "fossilized bessho lizard spur", "glaes dust", "gold dust", "gold fang", "green alexandrite stone", "grooved burnt orange sea star", "Kezmonian honey beryl", "lavender shimmarglin sapphire", "misty silver crystalline spiral", "moonglae opal", "opaline moonstone", "pale green moonstone", "pearly grey ice stone", "petrified tiger tooth", "Phoen's eye topaz", "pink sapphire", "platinum dust", "platinum fang", "prismatic rose-gold fire agate", "red sunstone", "rich cerulean mermaid's-tear sapphire", "rough-edged matte white soulstone", "shadow amethyst", "shard of rainbow quartz", "silver-cored vortex stone", "silvery moonstone", "sylvarraend ruby", "tangerine wulfenite crystal", "thin blade of verdant sea glass", "tigerfang crystal", "uncut ruby", "uncut sunstone", "white sunstone", "yellow sunstone"]



# Initializing variables and stuff

    time_total = 0
    mytime = Time.now.to_f
    mygems = []
    purified = 0
    orbs = 0
    shattered = 0
	alreadyorbs = 0

	UserVars.PurifyL ||= {}
	UserVars.PurifyL[:unsungcontainer] = nil if UserVars.PurifyL[:unsungcontainer].nil?
	UserVars.PurifyL[:sungcontainer] = nil if UserVars.PurifyL[:sungcontainer].nil?
	UserVars.PurifyL[:orbcontainer] = nil if UserVars.PurifyL[:orbcontainer].nil?

if UserVars.PurifyL[:unsungcontainer].nil? || UserVars.PurifyL[:sungcontainer].nil? || UserVars.PurifyL[:orbcontainer].nil?
	respond "\n
First time running the script? Here's how to set it up!

;e echo UserVars.PurifyL[:unsungcontainer] = \"pouch\"
;e echo UserVars.PurifyL[:sungcontainer] = \"sack\"
;e echo UserVars.PurifyL[:orbcontainer] = \"case\"

(Or whichever containers will hold your unsung, sung non-orb, and sung orb gems respectively.)

Just set those, make sure your containers are open and right hand is empty, and then we can get started!
	"
	exit
end

if script.vars[1] =~ /transfer/
    GameObj.inv.find{|cont| cont.noun =~ /#{script.vars[2]}/}.contents.each{|gem|
if gem.noun =~ /#{$gemnouns.join('|')}/ || gem.name =~ /#{$gemnames.join('|')}/
    put "_drag ##{gem.id} ##{GameObj.inv.find{|targ| targ.noun =~ /#{script.vars[3]}/}.id}" unless gem.name =~ /smooth stone/
    matchtimeout(1, "You put")
    end
    }
    exit
    end
    
def wait_rt
    wait_while { checkrt > 0 or checkcastrt > 0 }
    sleep 0.7
end

script.vars[0]
pct_boost = 0
totalboost = 0



# The actual script

unless GameObj.right_hand.name =~ /empty/i
    echo "Ya got something in your right hand. Please put that away and then run this script again!"
    exit
    end
    GameObj.inv.find{|cont| cont.noun =~ /#{UserVars.PurifyL[:unsungcontainer]}/}.contents.each{|gem| mygems.push(gem.id.to_i) if (gem.noun =~ /#{$gemnouns.join('|')}/ || gem.name =~ /#{$gemnames.join('|')}/) && gem.name !~ /smooth stone/}
    howmany = mygems.length
	
if howmany == 0
	respond "Looks like you have no gems of high value to purify!\n
	(You might have some gems, but by default this script is set up to only purify gems that a capped bard would generally be able to take to at least 3000 silvers. Alternatively, if you're sure you have gems worth purifying, try looking in your #{UserVars.PurifyL[:unsungcontainer]} and then run this script again.)"
	exit
	end
	
mygems.each{|gem|
if purified + shattered + orbs + alreadyorbs == 0
    respond "~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~"
    respond "~ PurifyL by Leafiara"
    respond "~ Looks like there are #{mygems.length} gems in your #{UserVars.PurifyL[:unsungcontainer]}!"
	respond "~ (Not counting junky ones we're not purifying.)"
    respond "~ Purified gems will go into your #{UserVars.PurifyL[:sungcontainer]}..."
    respond "~ And orbs will go into your #{UserVars.PurifyL[:orbcontainer]}!"
    respond "~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~"
    start_time = Time.now.to_i
    else
    runtime = Time.now.to_f - mytime
    remaining = howmany - (purified + shattered + orbs + alreadyorbs)
    avgtime = runtime.round / (purified + shattered + orbs + alreadyorbs)
    respond "~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~"
    respond "~ PurifyL by Leafiara"
    respond "~ Purified #{purified}, orbified #{orbs}, shattered #{shattered}!"
	respond "~ Sorted #{alreadyorbs} gems that were already orbs."
    respond "~ #{remaining} gems to go!"
    respond "~ Total time #{ "%02d" %((runtime)/60)}:#{ "%02d" % ((runtime)%60)} / #{avgtime} seconds per gem"
    respond "~ Estimated time left: #{ "%02d" %((remaining * avgtime)/60)}:#{ "%02d" % ((remaining * avgtime)%60)}"
	respond "~ #{totalboost}% Total Boost / #{totalboost/(purified + orbs)}% Average Boost" if (purified + orbs) > 0
    respond "~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~"
    end
    wait_rt
    orbed = false
	preorbed = false
    result = false
unless Wounds.rhand == 3
    put "_drag ##{gem} right"
    else
		start_script("useherbs")
		wait_while{running? "useherbs"}
		put "_drag ##{gem} right"
    end
until result =~ /what were you|cannot|must be holding|shatter|song misfires/i
    wait_until('Need some mana!') { mana(20) }
    wait_while{muckled?}
    wait_while('Need some healing!') {[Wounds.head, Scars.head, Wounds.nerves, Scars.nerves].max >= 2 || ([Wounds.rightHand, Wounds.rightArm, Scars.rightHand, Scars.rightArm].max >= 2 && [Wounds.leftHand, Wounds.leftArm, Scars.leftHand, Scars.leftArm].max >= 2) || ([Wounds.rightHand, Wounds.rightArm, Scars.rightHand, Scars.rightArm].max >= 2 && [Wounds.leftHand, Wounds.leftArm, Scars.leftHand, Scars.leftArm].max >= 2) || [Wounds.rightArm, Wounds.leftArm, Wounds.rightHand, Wounds.leftHand, Scars.rightArm, Scars.leftArm, Scars.rightHand, Scars.leftHand].max == 3}
    wait_rt
    multifput("prep 1004","sing ##{gem}")
    result = matchwait("turn as the very essence","gem becomes more perfect","shatter","crack","must be holding","what were you","appearing smoother and more pure", "improves somewhat","cannot be", "Sing Roundtime",'Spell Hindrance',"song misfires")
	
	
	
# Below is the message if a gem was already an orb before you sang to it.

if result =~ /As the gem resonates in response to your voice, you sense that it cannot be purified any further./
	preorbed = true
	break
	
	
	
# Below is the message when a gem gets to the maximum value as you sing to it.
# Note: If a gem was already at the max value--in other words, if a very experienced bard had *already* sung to it--then you'd get the same message as the one for already-orbed gems and it would end up in your orbcontainer even if it's not an orb. So be careful to put only unsung gems into your unsungcontainer.

elsif result =~ /As the gem vibrates slightly in your hand, you sense that it cannot be purified any further./
	purified += 1
    break
	
	
	
# Below are the other messages you can get as you purify.
# It shows the value increase of the gem as you go, with a once-per-gem reminder that
# the percentage is based on max value, not starting value. e.g. if you have a diamond
# that starts at 5000 and maxes at 10000, that would show as a 50% bonus... if you can
# get that far, anyway. A lower level bard who could only get it to 7500 before the
# script stops it as being too risky would see a 25% bonus.

elsif result =~ /more perfect|what were you|improves somewhat|crack|shatter|must be holding|smoother and more pure in color/
	pct_boost += 5
	totalboost += 5
	if pct_boost == 5
		respond " Bonus: +#{pct_boost}% of max value"
	else
		respond " Bonus: +#{pct_boost}%"
	end
	nextline = get
    (orbed = true;break) if nextline =~ /very essence/ 					# Turned a gem into an orb.

	

# When a gem shatters, subtract its value increase back out of the total boost in the summary.
	
if result =~ /shatter/
	respond " ...if it hadn't blown up, anyway. So close!"
	shattered += 1
	totalboost -= pct_boost
	pct_boost = 0
	wait_while{stunned?}
	break
	
	
	
# It stops singing if you aren't holding a gem or run into a message that means it's very risky to keep singing. Usually this means stopping on the "improves somewhat" message, at least until high level when you'll instead see the maximum value message.
	
elsif result =~ /crack|improves somewhat|What were|cannot|must be holding|song misfires/
    purified += 1
	pct_boost = 0
    break
    end
    end
    end
	
if orbed
    fput "put ##{gem} in my #{UserVars.PurifyL[:orbcontainer]}"
    orbs += 1
	pct_boost = 0
    end
	
if preorbed
    fput "put ##{gem} in my #{UserVars.PurifyL[:orbcontainer]}"
	alreadyorbs += 1
	pct_boost = 0
    end
	
unless GameObj.right_hand.name =~ /empty/i
    fput "put ##{gem} in my #{UserVars.PurifyL[:sungcontainer]}"
	pct_boost = 0
    end
    gems = howmany - (purified + shattered + orbs + alreadyorbs)
    wait_while{stunned?}
    }
    runtime = Time.now.to_f - mytime
    remaining = howmany - (purified + shattered + orbs + alreadyorbs)
	
unless (purified + shattered + orbs + alreadyorbs) == 0
    avgtime = runtime.round / (purified + shattered + orbs + alreadyorbs)
    end
	
if purified + shattered + orbs + alreadyorbs == 0
    respond "~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~"
    else
    runtime = Time.now.to_f - mytime
    remaining = howmany - (purified + shattered + orbs + alreadyorbs)
    avgtime = runtime.round / (purified + shattered + orbs + alreadyorbs)
    respond "~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~"
    respond "~ PurifyL by Leafiara"
    respond "~ Purified #{purified}, orbified #{orbs}, shattered #{shattered}!"
        respond "~ Sorted #{alreadyorbs} gems that were already orbs."
    respond "~ Total time #{ "%02d" %((runtime)/60)}:#{ "%02d" % ((runtime)%60)} / #{avgtime} seconds per gem"
    respond "~ Estimated time left: #{ "%02d" %((remaining * avgtime)/60)}:#{ "%02d" % ((remaining * avgtime)%60)}"
        respond "~ Total Boost / Average Boost: #{totalboost}% / #{totalboost/(purified + orbs)}%" if (purified + orbs) > 0
    respond "~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~"
end