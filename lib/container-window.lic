=begin

	A window for all of your container needs!
	
	This script creates a window that tracks all containers and their contents. Whenever this script notices a container with things inside of it (whether you are wearing the container or it's in the room), it will add that container and its contents to the window. Each container can be double clicked to open up their contents in a new tab. Double click the contents to GET that item from the container. Double click something you are wearing to REMOVE it.
	
	The window itself is highly customizable, start script as ;container-window settings to change the look of the window.
	
	Right click container tabs to close them. Right click containers on the Main tab to remove that container from the Main tab.
	
	Middle click a container's tab to LOOK IN that container.
	
	This script makes use of the Sorted View in game setting. With Sorted View on, this script will also list items in their categories such as Weapons, Armor, Magic, etc. Note that the game doesn't always give Sorted View information, so when non-sorted view information is sent to the script it will overwrite the Sorted View list.
	
	Whenever you move to a new room all containers that you are not wearing will be automatically removed from the Main list. Why do you need to know what the contents are of a container if you're no longer in the room with said container?
	
	Box information will also be automatically removed once the box is empty.
	
	Script has limited search functionality. With the window as the focus you can start typing to search through that container for an item. The search begins with the first word though, so if you enter "vultite" it will find any items that start with the word "vultite", but not items with "vultite" as the second word.
	
	Commands when the script is running:
	scan room: Script will LOOK IN, ON, UNDER, and BEHIND everything in the room and update the window with all of the containers and their contents it found.
	scan inv: Script will OPEN and LOOK IN everything you are wearing and update the window with all of your worn containers and their contents.
	
	Future planned updates:
	Tabs of containers will have multiple rows instead of all of the tabs being on just one row.

	########################################################
	Ways to contact me:
	In game: Dreaven
	Player's Corner: Tgo01
	Discord: Dreaven.
	Email: LordDreaven@gmail.com
	If you like my scripts feel free to send me a tip via Paypal at: LordDreaven@gmail.com
	########################################################
	
	Version 1: Initial release!
	Version 2: The title of the window and the header of the Main tab now both show the character's name.
	
	Author: Dreaven
	Version: 2

=end

require 'gtk3'
require 'json'

class ContainerWindowMain
	@all_tab_contents = {}
	@all_scroll_windows = {}
	@all_event_boxes = {}
	@all_container_tabs_open = []
	@all_main_containers = []
	@character_load_data = nil
	@fake_ids = 0
	@location_container_hash = {}
	@text_colors = {}
	$container_window_scanning_room = nil
	@all_color_options = [ "Red", "Green", "Blue" ]
	$container_window_all_scan_commands = [ "in", "on", "behind", "under" ]
	
	@save_file = "container-window.json"
	@lock_file = "#{@save_file}.lock"
	
	def self.load_the_data(name)
		begin
			File.open(@lock_file, File::RDWR | File::CREAT){ |lock_file|
				lock_file.flock(File::LOCK_EX)
				
				return unless File.exist?(@save_file)
				
				loaded_data = JSON.parse(File.read(@save_file))
				@character_load_data = loaded_data[name]
			}
		rescue StandardError => e
			respond "Error message from ;container-window: #{e.message}"
		ensure
			File.open(@lock_file, File::RDWR | File::CREAT){ |lock_file| lock_file.flock(File::LOCK_UN) }
		end
	end
	
	load_the_data(checkname)
	
	data = @character_load_data
	@all_settings = {}
	@all_settings["Horizontal"] = data["Horizontal"] ? data["Horizontal"].to_i : 0
	@all_settings["Vertical"] = data["Vertical"] ? data["Vertical"].to_i : 0
	@all_settings["Height"] = data["Height"] ? data["Height"].to_i : 400
	@all_settings["Width"] = data["Width"] ? data["Width"].to_i : 400
	@all_settings["Max Tabs"] = data["Max Tabs"] ? data["Max Tabs"].to_i : 5
	@all_settings["Show Title"] = data["Show Title"] ? data["Show Title"] : "Yes"
	@all_settings["Entire Name"] = data["Entire Name"] ? data["Entire Name"] : "Yes"
	@all_settings["Show Header"] = data["Show Header"] ? data["Show Header"] : "Yes"
	
	@settings_colors = [ "Regular Text", "Category Text", "Tab Text", "Tab Color", "Window Color", "Selected Color" ]

	@settings_colors.each{ |setting|
		red = data["#{setting} Red"]
		green = data["#{setting} Green"]
		blue = data["#{setting} Blue"]
		if setting == "Regular Text" || setting == "Tab Text"
			@all_settings["#{setting} Red"] = red ? red : 0
			@all_settings["#{setting} Green"] = green ? green : 0
			@all_settings["#{setting} Blue"] = blue ? blue : 0
			
			@text_colors["#{setting} Red"] = red ? red : 0
			@text_colors["#{setting} Green"] = green ? green : 0
			@text_colors["#{setting} Blue"] = blue ? blue : 0
		elsif setting == "Category Text"
			@all_settings["#{setting} Red"] = red ? red : 255
			@all_settings["#{setting} Green"] = green ? green : 0
			@all_settings["#{setting} Blue"] = blue ? blue : 165
			
			@text_colors["#{setting} Red"] = red ? red : 255
			@text_colors["#{setting} Green"] = green ? green : 0
			@text_colors["#{setting} Blue"] = blue ? blue : 165
		elsif setting == "Tab Color" || setting == "Window Color"
			@all_settings["#{setting} Red"] = red ? red : 255
			@all_settings["#{setting} Green"] = green ? green : 255
			@all_settings["#{setting} Blue"] = blue ? blue : 255
		elsif setting == "Selected Color"
			@all_settings["#{setting} Red"] = red ? red : 0
			@all_settings["#{setting} Green"] = green ? green : 0
			@all_settings["#{setting} Blue"] = blue ? blue : 255
		end
	}
	
	text = "\n\nYou can change the number by entering a number manually then pushing enter, using your mouse's scrollwheel, using the up/down arrow keys, or clicking the +/- buttons."
	text2 = "\n\nThe first value is for Red, second is for Green, third is for Blue."
	@tooltips = {
		"Horizontal" => "Set the horizontal position you want the window to be at.#{text}",
		"Vertical" => "Set the vertical position you want the window to be at.#{text}",
		"Height" => "Set the height you want the window to be.#{text}",
		"Width" => "Set the width you want the window to be.#{text}",
		"Max Tabs" => "Enter the maximum number of container tabs you want open at a time. If you open a tab while at the max number of tabs then the most recently opened container tab will be removed and the new container tab will be opened.\n\nFor example: if you set this value to 2, then you open up a backpack container tab then a sack container tab, then you open a pouch container tab, the sack tab will be removed and will be replaced by the pouch container tab.",
		"Save" => "Click to save the current settings for this character.\n\nClicking this button will close the main window and the settings window, the script will then need to be restarted.",
		"Default Save" => "Click this button to save all of the current settings to a default profile. You can then use the \"Default Load\" button to load those settings. This is useful if you want to use the same settings across different characters.",
		"Default Load" => "Click this button to load all default settings. Keep in mind you still have to click the \"Save\" button in order to save the settings for this character.",
		"Show Title" => "NOTE: This setting doesn't take effect until you restart the script.\n\nCheck this box to show the window's title bar. This bar is where the window's name, minimize, maximize, and close buttons are located.\n\nUncheck this box to hide the title bar for a cleaner look.",
		"Entire Name" => "Check this box to display a container's entire name in its tab title.\n\nUncheck this box to display only the container's noun in its tab title.",
		"Tab Color" => "Change the color of the tabs with these options.#{text2}",
		"Window Color" => "Change the color of the main window with these options. Note: When changing these values in the Settings window, only the Main window will change colors, but when restaring the script all windows should have the same color.#{text2}",
		"Regular Text" => "Change the color of the regular text with these options. Regular text refers to items listed in a tab.\n\nHover your cursor over an item to update the color change.#{text2}",
		"Category Text" => "Change the color of the category text with these options. Category text refers to listed categories such as \"Weapons\" or \"Armor\".\n\nHover your cursor over an item to update the color change.#{text2}",
		"Tab Text" => "Change the color of the tab text with these options. Note: When changing these values in the Settings window, only the Main tab will change colors, but when restaring the script all tab text should have the same color.#{text2}",
		"Selected Color" => "Change the color of the highlight when an item is selected. When changing these values in the Settings window, only highlights in the Main tab will change colors (you will have to click on an item to see the new color), but when restarting the script all tabs should have their highlights changed.#{text2}",
		"Show Header" => "NOTE: This setting doesn't take effect until you restart the script.\n\nThe header is at the top of each tab, showing the full name of the container.\n\nCheck this to show the header, uncheck to hide the header.",
	}

	def self.create_main_window
		@main_window = Gtk::Window.new(:toplevel)
		@main_window.set_keep_above(true)
		@main_window.set_title("#{checkname} Containers")
		
		@notebook = Gtk::Notebook.new

		change_color_values(@all_settings["Tab Color Red"], @all_settings["Tab Color Green"], @all_settings["Tab Color Blue"])
		@notebook.override_background_color(:normal, Gdk::RGBA.new(@color_red, @color_green, @color_blue, 1.0))
		
		@main_window.signal_connect("delete-event") do
			if @main_window
				@main_window.close
				@main_window = nil
			end
			if @settings_window
				@settings_window.close
				@settings_window = nil
			end
			false
		end
		
		if @all_settings["Show Title"] == "Yes"
			@main_window.set_decorated(true)
		else
			@main_window.set_decorated(false)
		end
		
		@main_window.signal_connect("destroy"){
			Gtk.main_quit
			kill_script "container-window" if running? "container-window"
		}

		@main_window.resize(@all_settings["Width"], @all_settings["Height"])
		@main_window.move(@all_settings["Horizontal"], @all_settings["Vertical"])
		
		@main_scroll_window = Gtk::ScrolledWindow.new
		@main_scroll_window.set_policy(Gtk::PolicyType::AUTOMATIC, Gtk::PolicyType::AUTOMATIC)
		@main_scroll_window.set_size_request(@all_settings["Width"], @all_settings["Height"])
		
		@main_list_store = Gtk::ListStore.new(String, String)
		@main_contents_tree = Gtk::TreeView.new(@main_list_store)
		
		change_color_values(@all_settings["Window Color Red"], @all_settings["Window Color Green"], @all_settings["Window Color Blue"])
		@main_contents_tree.override_background_color(:normal, Gdk::RGBA.new(@color_red, @color_green, @color_blue, 1.0))
		
		renderer = Gtk::CellRendererText.new
		column = Gtk::TreeViewColumn.new("#{checkname} Containers", renderer, text: 0)
		
		column.set_cell_data_func(renderer){ |_column, _renderer, model, iter|
			name = model.get_value(iter, 0)
				
			red = @text_colors["Regular Text Red"] / 255.0
			green = @text_colors["Regular Text Green"] / 255.0
			blue = @text_colors["Regular Text Blue"] / 255.0
				
			color = Gdk::RGBA.new(red, green, blue, 1.0)
				
			renderer.text = name
			renderer.foreground_rgba = color
		}

		@main_contents_tree.set_headers_visible(false) if @all_settings["Show Header"] == "No"
		@main_contents_tree.append_column(column)
		
		tree_selection = @main_contents_tree.selection
		tree_selection.set_select_function { |path, column| true }

		change_color_values(@all_settings["Selected Color Red"], @all_settings["Selected Color Green"], @all_settings["Selected Color Blue"])
		@main_contents_tree.override_background_color(:selected, Gdk::RGBA.new(@color_red, @color_green, @color_blue, 1.0))


		@main_contents_tree.signal_connect('row-activated'){ |_treeview, path, _column|
			iter = @main_list_store.get_iter(path)
			container_name = iter[0]
			container_id = iter[1]
			unless @all_container_tabs_open.include?(container_id)
				number_of_tabs = @notebook.n_pages
				remove_tab(@all_container_tabs_open[-1]) if number_of_tabs > @all_settings["Max Tabs"]
				@notebook.append_page(@all_scroll_windows[container_id], @all_event_boxes[container_id])
				@all_container_tabs_open.push(container_id)
				@main_window.show_all
				@notebook.set_current_page(@notebook.n_pages - 1)
			end
		}

		@main_contents_tree.signal_connect('button-press-event') { |treeview, event|
			if event.button == Gdk::BUTTON_SECONDARY
				path = treeview.get_path_at_pos(event.x, event.y)&.first
				if path
					iter = @main_list_store.get_iter(path)
					container_name = iter[0]
					container_id = iter[1]
					if container_name != "worn items"
						@all_main_containers.delete(container_id)
						@main_list_store.remove(iter)
						remove_tab(container_id)
					end
				end
			end
		}
		
		@main_scroll_window.add(@main_contents_tree)
		
		@main_label = Gtk::Label.new("Main")

		change_color_values(@all_settings["Tab Text Red"], @all_settings["Tab Text Green"], @all_settings["Tab Text Blue"])
		@main_label.override_color(:normal, Gdk::RGBA.new(@color_red, @color_green, @color_blue, 1.0))
		@notebook.append_page(@main_scroll_window, @main_label)	

		@main_window.add(@notebook)
		@main_window.show_all
	end
	
	def self.save_settings(name)
		File.open(@lock_file, File::RDWR | File::CREAT){ |lock|
			lock.flock(File::LOCK_EX)
				
			if File.exist?(@save_file)
				all_data = JSON.parse(File.read(@save_file))
			else
				all_data = {}
			end
				
			@character_data = all_data[name] || {}
			@all_spin_settings.each{ |setting| @character_data[setting] = @spin_buttons[setting].value.to_i }
			@all_checkbox_settings.each{ |setting,checkbox| @character_data[setting] = checkbox.active? ? "Yes" : "No" }
			@settings_colors.each{ |setting,value|
				@all_color_options.each{ |color|
					full_setting = "#{setting} #{color}"
					@character_data[full_setting] = @spin_buttons[full_setting].value.to_i
				}
			}
			
			all_data[name] = @character_data
				
			File.open(@save_file, 'w'){ |file| file.write(JSON.pretty_generate(all_data)) }
			respond ";container-window: Data saved."
		}
	end
	
	def self.change_settings_values(name)
		@all_checkbox_settings.each{ |setting,checkbox|
			if @character_load_data[setting] == "Yes" || @character_load_data[setting].nil?
				checkbox.active = true
			else
				checkbox.active = false
			end
		}
		
		@all_spin_settings.each{ |setting| @spin_buttons[setting].value = @character_load_data[setting].to_i } if @character_load_data
		
		if @character_load_data
			@settings_colors.each{ |setting,value|
				@all_color_options.each{ |color|
					full_setting = "#{setting} #{color}"
					@spin_buttons[full_setting].value = @character_load_data[full_setting].to_i
				}
			}
		end
	end
	
	def self.create_settings_window
		@settings_window = Gtk::Window.new(:toplevel)
		@settings_window.set_keep_above(true)
		@settings_window.set_title("Settings")
		
		@parent_grid = Gtk::Grid.new
		spin_grid = Gtk::Grid.new
		checkbox_grid = Gtk::Grid.new
		save_grid = Gtk::Grid.new
		
		row = -1
		@parent_grid.attach(spin_grid, 0, row += 1, 1, 1)
		@parent_grid.attach(checkbox_grid, 0, row += 1, 1, 1)
		@parent_grid.attach(save_grid, 0, row += 1, 1, 1)

		@spin_buttons = {}
		@all_spin_settings = []
		@all_checkbox_settings = {}

		row = -1
		buttons = [ "Horizontal", "Vertical" ]
		buttons.each{ |name|
			@all_spin_settings.push(name)
			@spin_buttons[name] = Gtk::SpinButton.new(-1000, 5000, 1)
			@spin_buttons[name].signal_connect("value-changed"){ @main_window.move(@spin_buttons["Horizontal"].value, @spin_buttons["Vertical"].value) }
			label = Gtk::Label.new("#{name}          ")
			@spin_buttons[name].set_tooltip_text(@tooltips[name])
			label.set_tooltip_text(@tooltips[name])
			spin_grid.attach(label, 0, row += 1, 1, 1)
			spin_grid.attach(@spin_buttons[name], 1, row, 1, 1)
		}
		
		buttons = [ "Width", "Height" ]
		buttons.each{ |name|
			@all_spin_settings.push(name)
			@spin_buttons[name] = Gtk::SpinButton.new(70, 5000, 1)
			@spin_buttons[name].signal_connect("value-changed"){ 
				width = @spin_buttons["Width"].value
				height = @spin_buttons["Height"].value
				@main_window.resize(width, height)
				@main_scroll_window.set_size_request(width, height)
				@all_scroll_windows.each{ |id, scroll_window| @all_scroll_windows[id].set_size_request(width,height) }
			}
			label = Gtk::Label.new("#{name}          ")
			@spin_buttons[name].set_tooltip_text(@tooltips[name])
			label.set_tooltip_text(@tooltips[name])
			spin_grid.attach(label, 0, row += 1, 1, 1)
			spin_grid.attach(@spin_buttons[name], 1, row, 1, 1)
		}
		
		buttons = [ "Max Tabs" ]
		buttons.each{ |name|
			@all_spin_settings.push(name)
			@spin_buttons[name] = Gtk::SpinButton.new(1, 100, 1)
			label = Gtk::Label.new("#{name}          ")
			@spin_buttons[name].set_tooltip_text(@tooltips[name])
			label.set_tooltip_text(@tooltips[name])
			spin_grid.attach(label, 0, row += 1, 1, 1)
			spin_grid.attach(@spin_buttons[name], 1, row, 1, 1)
		}

		@settings_colors.each{ |name|
			column = -1
			label = Gtk::Label.new("#{name}          ")
			label.set_tooltip_text(@tooltips[name])
			spin_grid.attach(label, column += 1, row += 1, 1, 1)
			@all_color_options.each{ |color|
				@spin_buttons["#{name} #{color}"] = Gtk::SpinButton.new(0, 255, 1)
				spin_grid.attach(@spin_buttons["#{name} #{color}"], column += 1, row, 1, 1)
				@spin_buttons["#{name} #{color}"].set_tooltip_text(@tooltips[name])
				
				@spin_buttons["#{name} #{color}"].signal_connect("value-changed"){
					red = @spin_buttons["#{name} Red"].value
					green = @spin_buttons["#{name} Green"].value
					blue = @spin_buttons["#{name} Blue"].value
					@text_colors["#{name} Red"] = red
					@text_colors["#{name} Green"] = green
					@text_colors["#{name} Blue"] = blue
					change_color_values(red, green, blue)
					if name == "Tab Color"
						@notebook.override_background_color(:normal, Gdk::RGBA.new(@color_red, @color_green, @color_blue, 1.0))
					elsif name == "Window Color"
						@main_contents_tree.override_background_color(:normal, Gdk::RGBA.new(@color_red, @color_green, @color_blue, 1.0))
					elsif name == "Tab Text"
						@main_label.override_color(:normal, Gdk::RGBA.new(@color_red, @color_green, @color_blue, 1.0))
					elsif name == "Selected Color"
						@main_contents_tree.override_background_color(:selected, Gdk::RGBA.new(@color_red, @color_green, @color_blue, 1.0))
					end
				}
			}
		}

		@spin_buttons.each{ |name,_| @spin_buttons[name].set_value(@all_settings[name]) }

		column = -1
		checkboxes = [ "Show Title", "Entire Name", "Show Header" ]
		checkboxes.each{ |name|
			@all_checkbox_settings[name] = Gtk::CheckButton.new(name)
			@all_checkbox_settings[name].set_tooltip_text(@tooltips[name])			
			checkbox_grid.attach(@all_checkbox_settings[name], column += 1, 0, 1, 1)
		}
		
		change_settings_values(checkname)
		
		@save_button = Gtk::Button.new(:label => "Save")
		@save_button.set_tooltip_text(@tooltips["Save"])
		@save_button.signal_connect('clicked') {
			save_settings(checkname)
			@settings_window.close
		}
		
		@save_default_button = Gtk::Button.new(:label => "Default Save")
		@save_default_button.set_tooltip_text(@tooltips["Default Save"])
		@save_default_button.signal_connect('clicked') { save_settings("Default Settings") }
		
		@load_default_button = Gtk::Button.new(:label => "Default Load")
		@load_default_button.set_tooltip_text(@tooltips["Default Load"])
		@load_default_button.signal_connect('clicked') {
			name = "Default Settings"
			load_the_data(name)
			change_settings_values(name)
		}
		
		save_grid.attach(@save_button, 0, 0, 1, 1)
		save_grid.attach(@save_default_button, 0, 1, 1, 1)
		save_grid.attach(@load_default_button, 1, 1, 1, 1)
		
		@settings_window.signal_connect("delete-event") do
			if @main_window
				@main_window.close
				@main_window = nil
			end
			if @settings_window
				@settings_window.close
				@settings_window = nil
			end
			false
		end
		
		@settings_window.add(@parent_grid)
		@settings_window.resize(100, 100)
		@settings_window.show_all
	end
	
	def self.change_color_values(red, green, blue)
		@color_red = (red / 255.0)
		@color_green = (green / 255.0)
		@color_blue = (blue / 255.0)
	end
	
	def self.remove_tab(id)
		@notebook.children.each_with_index{ |tab, index|
			if tab.is_a?(Gtk::ScrolledWindow) && tab == @all_scroll_windows[id]
				@notebook.remove_page(index)
				@all_tab_contents[id] = nil
				@all_container_tabs_open.delete(id)
				break
			end
		}
		@main_window.resize(@all_settings["Width"], @all_settings["Height"])
	end
	
	def self.create_tab(id, noun, name)
		if @all_tab_contents[id].nil?
			@all_scroll_windows[id] = Gtk::ScrolledWindow.new
			@all_scroll_windows[id].set_policy(Gtk::PolicyType::AUTOMATIC, Gtk::PolicyType::AUTOMATIC)
			@all_scroll_windows[id].set_size_request(@all_settings["Width"], @all_settings["Height"])

			@all_tab_contents[id] = Gtk::ListStore.new(String, String)
			contents_tree = Gtk::TreeView.new(@all_tab_contents[id])
			
			renderer = Gtk::CellRendererText.new
			column = Gtk::TreeViewColumn.new(name, renderer, text: 0)
			
			column.set_cell_data_func(renderer){ |_column, _renderer, model, iter|
				name = model.get_value(iter, 0)
				item_id = model.get_value(iter, 1)

				if item_id == "Nothing"
					red = @text_colors["Category Text Red"] / 255.0
					green = @text_colors["Category Text Green"] / 255.0
					blue = @text_colors["Category Text Blue"] / 255.0
				else					
					red = @text_colors["Regular Text Red"] / 255.0
					green = @text_colors["Regular Text Green"] / 255.0
					blue = @text_colors["Regular Text Blue"] / 255.0
				end
				
				color = Gdk::RGBA.new(red, green, blue, 1.0)
				
				renderer.text = name
				renderer.foreground_rgba = color
			}
			
			contents_tree.append_column(column)
			
			tree_selection = contents_tree.selection
			tree_selection.set_select_function { |path, column| true }

			change_color_values(@all_settings["Selected Color Red"], @all_settings["Selected Color Green"], @all_settings["Selected Color Blue"])
			contents_tree.override_background_color(:selected, Gdk::RGBA.new(@color_red, @color_green, @color_blue, 1.0))

			contents_tree.selection.mode = Gtk::SelectionMode::BROWSE
			contents_tree.signal_connect('row-activated') do |_treeview, path, _column|
				iter = @all_tab_contents[id].get_iter(path)
				item_name = iter[0]
				item_id = iter[1]
				if id == "-1"
					put "remove ##{item_id}" if item_id && item_id != "Nothing"
				else
					put "get ##{item_id}" if item_id && item_id != "Nothing"
				end
			end
			
			@all_scroll_windows[id].add(contents_tree)
			contents_tree.set_headers_visible(false) if @all_settings["Show Header"] == "No"
			
			change_color_values(@all_settings["Window Color Red"], @all_settings["Window Color Green"], @all_settings["Window Color Blue"])
			contents_tree.override_background_color(:normal, Gdk::RGBA.new(@color_red, @color_green, @color_blue, 1.0))
			
			label = @all_settings["Entire Name"] == "Yes" ? Gtk::Label.new(name) : Gtk::Label.new(noun)
			change_color_values(@all_settings["Tab Text Red"], @all_settings["Tab Text Green"], @all_settings["Tab Text Blue"])
			label.override_color(:normal, Gdk::RGBA.new(@color_red, @color_green, @color_blue, 1.0))
			@all_event_boxes[id] = Gtk::EventBox.new
			@all_event_boxes[id].add(label)
			label.visible = true
			
			@all_event_boxes[id].signal_connect('button-press-event'){ |widget, event|
				this_id = id
				if event.event_type == Gdk::EventType::BUTTON_PRESS
					if event.button == 2
						put "look in ##{this_id}" if this_id != "-1"
					elsif event.button == 3
						remove_tab(this_id)
					end
				end
			}
		end
	end
	
	def self.container_information(container_id, container_noun, container_contents, container_name, contents_location)
		contents_location = contents_location.upcase
		create_tab(container_id, container_noun, container_name)
		pattern = /exist="(\d+)" noun="([^"]+)">([^<]+)(?:<\/a>)?( \(\d+\))?/
		category_pattern = /<pushBold\/>(.* \[\d+\]:)<popBold\/>/
		contents_hash = {}
		@worn_items_ids = [] if container_name == "worn items"
		if container_contents.is_a?(Array)
			container_contents.each{ |line|
				line.scan(category_pattern){ |category|
					@fake_ids += 1
					id = @fake_ids
					contents_hash[id] = {}
					contents_hash[id]["ID"] = "Nothing"
					contents_hash[id]["Noun"] = category.join(", ")
					contents_hash[id]["Full Name"] = category.join(", ")
				}
				
				line.scan(pattern){ |id, noun, full_name, amount|
					contents_hash[id] = {}
					contents_hash[id]["ID"] = id
					contents_hash[id]["Noun"] = noun
					contents_hash[id]["Full Name"] = full_name
					contents_hash[id]["Amount"] = amount
					@worn_items_ids.push(id) if container_name == "worn items"
				}
			}
		else
			container_contents.scan(pattern){ |id, noun, full_name, amount|
				contents_hash[id] = {}
				contents_hash[id]["ID"] = id
				contents_hash[id]["Noun"] = noun
				contents_hash[id]["Full Name"] = full_name
				contents_hash[id]["Amount"] = amount
			}
		end

		@location_container_hash[container_id] ||= {}
		@location_container_hash[container_id][contents_location] = contents_hash
		
		@all_tab_contents[container_id].clear
		add_to_main_container = true

		first_location = true
		@location_container_hash[container_id].each{ |contents_location,_|
			iter = @all_tab_contents[container_id].append if container_name != "worn items"
			iter[0] = first_location ? contents_location : "\n#{contents_location}"
			first_location = nil
			if @location_container_hash[container_id][contents_location].count == 0
				iter = @all_tab_contents[container_id].append
				iter[0] = "Nothing"
				iter[1] = "Nothing"
				if container_noun =~ /^(box|trunk|chest|strongbox|coffer)$/ && contents_location == "IN"
					@main_list_store.each{ |model, path, iter|
						id = iter[1]
						if id == container_id
							@main_list_store.remove(iter)
							@all_main_containers.delete(container_id)
							remove_tab(container_id)
							add_to_main_container = nil
							break
						end
					}
				end
			else
				@location_container_hash[container_id][contents_location].each{ |item_id,value|
					iter = @all_tab_contents[container_id].append
					if value["Amount"]
						iter[0] = "#{value["Full Name"]} #{value["Amount"]}"
					else
						iter[0] = "#{value["Full Name"]}"
					end
					iter[1] = value["ID"]
				}
			end
		}
		
		if $container_window_scanning_room
			@location_container_hash[container_id].each{ |key,value|
				next if @location_container_hash[container_id].count < $container_window_all_scan_commands.count
				delete_entry = true
				$container_window_all_scan_commands.each{ |command|
					command = command.upcase
					if @location_container_hash[container_id][command].count > 0
						delete_entry = nil
						break
					end
				}
				if delete_entry
					@main_list_store.each{ |model, path, iter|
						id = iter[1]
						if id == container_id
							@main_list_store.remove(iter)
							@all_main_containers.delete(container_id)
							remove_tab(container_id)
							add_to_main_container = nil
							break
						end
					}
				end
			}
		end
		
		if !@all_main_containers.include?(container_id) && add_to_main_container
			@all_main_containers.push(container_id)
			iter = @main_list_store.append
			iter[0] = @worn_items_ids.include?(container_id) ? iter[0] = "#{container_name} (worn)" : container_name
			iter[1] = container_id
		end

		@main_list_store.each{ |model, path, iter|
			text = iter[0].gsub(" (worn)", "")
			iter[0] = @worn_items_ids.include?(iter[1]) ? "#{text} (worn)" : text
		}
	end
	
	def self.moved_room_check
		delete_ids = []
		@all_main_containers.each{ |id|
			if !@worn_items_ids.include?(id) && id != "-1"
				@all_tab_contents[id] = nil
				delete_ids.push(id)
				@main_list_store.each{ |model, path, iter|
					container_id = iter[1]
					if id == container_id
						@main_list_store.remove(iter)
						remove_tab(container_id)
					end
				}
			end
		}
		delete_ids.each{ |container_id| @all_main_containers.delete(container_id) }
	end
	
	def self.watching
		before_dying{
			@main_window.close if @main_window
		}

		status_tags
		toggle_upstream
		
		@current_room_number = Room.current.id
		Thread.new{
			loop{
				wait_until{ @current_room_number != Room.current.id }
				@current_room_number = Room.current.id
				moved_room_check
			}
		}

		put "inv"

		while line = get
			if line =~ /(?:In|On|Under|Behind) the \<a exist\=\"(.*?)\" noun\=\"(.*?)\".*?\/inv\>\<inv id\=\'.*?\'\>.*\<\/inv\>(?:(In|On|Under|Behind) the|You open an?).*? \<a exist=".*?\" noun\=\".*?\"\>(.*?)\<\/a\> you see .*? (.*)/
				container_id = $1
				container_noun = $2
				contents_location = $3
				container_name = $4
				container_contents = $5
				container_information(container_id, container_noun, container_contents, container_name, contents_location)
			elsif (line =~ /(?:In|On|Under|Behind) the \<a exist\=\"(.*?)\" noun\=\"(.*?)\".*?\/inv\>\<inv id\=\'.*?\'\>(.*)\<\/inv\>.*? (?:puts?|removes?|gather the remaining .*?) .* (in|on|inside|behind|underneath) .*? noun=\".*\"\>(.*)\<\/a\>/) || (line =~ /(?:In|On|Under|Behind) the \<a exist\=\"(.*?)\" noun\=\"(.*?)\".*?\/inv\>\<inv id\=\'.*?\'\>(.*)\<\/inv\>(?:(In|On|Under|Behind) the|You open an?).*? \<a exist=".*?\" noun\=\".*?\"\>(.*?)\<\/a\>/)
				container_id = $1
				container_noun = $2
				container_contents = $3
				contents_location = $4
				container_name = $5
				contents_location = "in" if contents_location == "inside" || line =~ /You open/
				while line = get
					if line =~ /<pushBold\/>/
						container_contents = [] unless container_contents.is_a?(Array)
						container_contents.push(line)
					elsif line =~ /<prompt/
						break
					end
				end
				container_information(container_id, container_noun, container_contents, container_name, contents_location)
			elsif line =~ /(?:In|On|Under|Behind) the <a exist="(.*)" noun="(.*?)">(.*?)<\/a>:<\/inv><inv id='.*?'> nothing<\/inv>(There is nothing (in|on) the)/
				container_id = $1
				container_noun = $2
				container_name = $3
				container_contents = $4
				contents_location = $5
				container_information(container_id, container_noun, container_contents, container_name, contents_location)
			elsif line =~ /(There is nothing) (in|on|behind|under) the <a exist="(.*?)" noun="(.*?)">(.*?)<\/a>/
				container_contents = $1
				contents_location = $2
				container_id = $3
				container_noun = $4
				container_name = $5
				container_information(container_id, container_noun, container_contents, container_name, contents_location)
			elsif line =~ /Looking (.*?) the <a exist="(.*?)" noun="(.*)?">(.*?)<\/a>, (you see nothing)./
				contents_location = $1
				container_id = $2
				container_noun = $3
				container_name = $4
				container_contents = $5
				container_information(container_id, container_noun, container_contents, container_name, contents_location)
			elsif line =~ /(In|On|Under|Behind) the \<a exist\=\"(.*?)\" noun\=\"(.*?)\">(.*?)<\/a>\:$/
				contents_location = $1
				container_id = $2
				container_noun = $3
				container_name = $4
				container_contents = $5
				while line = get
					if line =~ /<pushBold\/>/
						container_contents = [] unless container_contents.is_a?(Array)
						container_contents.push(line)
					elsif line =~ /<prompt/
						break
					end
				end
				container_information(container_id, container_noun, container_contents, container_name, contents_location)
			elsif line =~ /<\/inv><inv id=.*?> (.*?)(?:<\/a>)?<\/inv>.*? (?:put|remove) .*? (in|on|under|behind) .*? exist="(.*?)" noun="(.*?)">(.*?)<\/a>./
				container_contents = $1
				contents_location = $2
				container_id = $3
				container_noun = $4
				container_name = $5
				if contents_location =~ /behind|under/i
					put "look #{contents_location} ##{container_id}"
				else
					while line = get
						if line =~ /<pushBold\/>/
							container_contents = [] unless container_contents.is_a?(Array)
							container_contents.push(line)
						elsif line =~ /<prompt/
							break
						end
					end
					container_information(container_id, container_noun, container_contents, container_name, contents_location)
				end
			elsif line =~ />Your worn items are:/
				container_contents = []
				container_id = "-1"
				container_noun = "worn items"
				container_name = "worn items"
				contents_location = ""
				while line = get
					if line =~ /<a exist="(.*?)" noun="(.*?)">(.*?)<\/a>/
						container_contents.push(line)
					elsif line =~ /<popStream/
						break
					end
				end
				container_information(container_id, container_noun, container_contents, container_name, contents_location)
			end
		end
	end
end

respond
3.times{ respond "############################################################################################################" }
respond "Message from ;container-window"
respond "Script works best with the setting SortedView ON, but it should also work with it off."
respond "To access the settings window start script as ;container-window settings"
respond "To see help information and features of this script, start script as ;container-window help"
respond "Commands:"
respond "To scan a room for containers and all of their contents, enter: scan room"
respond "To OPEN and LOOK in all items that you are wearing to get their contents, enter: scan inv"
3.times{ respond "############################################################################################################" }
respond

Gtk.queue {
	ContainerWindowMain.create_main_window
	if script.vars[1] =~ /set/i
		ContainerWindowMain.create_settings_window
	elsif script.vars[1] =~ /help/i
		respond
		3.times{ respond "############################################################################################################" }
		respond "Help menu of ;container-window"
		respond
		respond "Main Tab:"
		respond "The Main tab lists all containers. It also shows all of your worn items. This list is automatically updated whenever the game tells the script about the contents of containers (mostly by LOOKing IN a container or by PUTting/GETting an item from a container.)"
		respond "If you double click a container it will create a new tab showing all of the contents of that container."
		respond "You can right click a container and it will remove that container from the Main tab. Note: You cannot remove the \"worn items\" container from the Main tab"
		respond
		respond "Container tabs:"
		respond "You can right click the container's tab to close it."
		respond "You can double click an item to GET that item, if you double click an item from the \"worn items\" tab it will instead REMOVE that item."
		respond "You can middle click the container's tab name to LOOK IN that container."
		respond
		respond "Sorted view:"
		respond "The script makes use of the game's \"Sorted View\" which separates items into categories. So whenever you LOOK IN a container the items will be listed in categories. Unfortunately whenever you remove an item or place an item into a container the game doesn't provide this sorted view and instead the items will revert back to just listing every item without categories."
		respond
		respond "Moving to a new room:"
		respond "Whenever you move to another room the script will automatically remove any references to containers that you aren't wearing."
		respond
		respond "Treasure box tabs:"
		respond "The script will automatically remove references to any treasure boxes after the contents of said box have been emptied out."
		respond
		respond "Searching:"
		respond "With the main window as the focus, you can start typing to search through the current tab to look for an item. Note this doesn't do partial searches, it searches from the beginning of the item name. So if a name starts with the word \"vultite\" you can enter that search to find items starting with vultite, if however the second word of the name is \"vultite\" it won't find those items. You can use the mouse wheel to cycle through different items found via this search. Hit the ESCAPE key to exit out of search mode."
		3.times{ respond "############################################################################################################" }
		respond
	end
	Gtk.main
}

Thread.new{
	loop{
		command = upstream_get
		if command =~ /^\<c\>scan room/i
			$container_window_scanning_room = true
			3.times{ respond "############################################################################################################" }
			respond ";container-window: scanning room. I'll let you know when I'm finished."
			3.times{ respond "############################################################################################################" }
			GameObj.loot.each{ |item| 
				$container_window_all_scan_commands.each{ |command|
					if item.noun !~ /disk|coffin/
						put "look #{command} #{item}"
						sleep 0.1
					end
				}
				sleep 0.5 if item.noun !~ /disk|coffin/
			}
			
			GameObj.room_desc.each{ |item| 
				$container_window_all_scan_commands.each{ |command|
					if item.noun !~ /disk|coffin/
						put "look #{command} #{item}"
						sleep 0.1
					end
				}
				sleep 0.5
			}
			
			3.times{ respond "############################################################################################################" }
			respond ";container-window: scan finished."
			3.times{ respond "############################################################################################################" }
			$container_window_scanning_room = nil
		elsif command =~ /^\<c\>scan inv/i
			3.times{ respond "############################################################################################################" }
			respond ";container-window: scanning your worn items. I'll let you know when I'm finished."
			3.times{ respond "############################################################################################################" }
			GameObj.inv.each{ |item|
				put "open ##{item.id}"
				sleep 0.1
				put "look in ##{item.id}"
				sleep 0.2
			}
			3.times{ respond "############################################################################################################" }
			respond ";container-window: scan finished."
			3.times{ respond "############################################################################################################" }
		end
	}
}

ContainerWindowMain.watching