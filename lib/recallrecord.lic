require 'yaml'
require 'thread'

=begin

	Instructions:
	Your items need to be loresung. 
	Start ;recallrecord
	Execute ;foreach in worn; inspect item; sleep 1; recall item; sleep 1;
	Let the ;foreach command complete. You'll see recallrecord logging items as it executes. 
	It's important for ;foreach to have some sleeps to slow it down for accuracy.
	Kill ;recallrecord
	Start ;recallrecord again and you'll see a similar output to the one below.
	The output is saved to a item_boosts.yaml in your Lich5 main directory as well.

	Example of Output:

	Current Item Boosts:
	rusalkoren platemail:
	  - boost of 40 to Agility Base.
	  - boost of 40 to Dexterity Base.
	  - boost of 40 to Logic Base.
	  - boost of 15 to Stamina Recovery.
	  - boost of 15 to Strength Base.
	fireleaf badge:
	  - boost of 5 to Wisdom Bonus.
	  - boost of 10 to Mental Lore - Telepathy Bonus.
	  - boost of 5 to Constitution Bonus.
	wrotwood finger talon:
	  - boost of 3 to Spirit Recovery.
	  - boost of 2 to Max Spirit.
	  - boost of 1 to Dispel Magic.
	  - boost of 1 to Absorb Magic.
	pale grey steel censer:
	  - boost of 3 to Mental Lore - Transformation Bonus.
	  - boost of 5 to Wisdom Base.
	scarlet red socks:
	  - boost of 2 to Strength Bonus.
	gilded locus:
	  - boost of 6 to Max Health.
	  - boost of 5 to Max Health.
	  - boost of 10 to Constitution Base.
	wyrwood wrist-cuff:
	  - boost of 8 to Elemental Lore - Air Bonus.
	  - boost of 6 to Strength Base.
	  - boost of 6 to Elemental Lore - Air Bonus.
 
=end

# Constants for file path
ITEM_BOOSTS_FILE_PATH = 'item_boosts.yaml'

# Load existing item boosts data from a YAML file
def load_existing_data(file_path)
  File.exist?(file_path) ? YAML.load_file(file_path) : {}
end

# Save item boosts data to a YAML file
def save_to_yaml(data, file_path)
  File.open(file_path, 'w') { |file| file.write(data.to_yaml) }
end

# Display the contents of the YAML file in a readable format
def display_yaml_contents(data)
  puts "Current Item Boosts:"
  if data.empty?
    puts "No boosts recorded."
  else
    data.each do |item_name, boosts|
      puts "#{item_name}:"
      boosts.each do |boost|
        puts "  - #{boost}"
      end
    end
  end
end

# Initialize a hash to store boosts
@item_boosts = load_existing_data(ITEM_BOOSTS_FILE_PATH)
@current_item_name = nil # Variable to store the current item name being processed

# Display the contents of the YAML file on startup
display_yaml_contents(@item_boosts)

# Method to process lines related to item inspection to extract the item name
def extract_item_name(line)
  if line =~ /You carefully inspect your (.+)\./
    @current_item_name = line.match(/You carefully inspect your (.+)\./)[1]
    puts "Captured item name: #{@current_item_name}"
  end
end

# Method to extract and store boosts from recall lines
def process_recall_line(line)
  if line =~ /(boost of \d+ to .+?\.)/ && @current_item_name
    boost = line.match(/(boost of \d+ to .+?\.)/)[1]

    # Initialize the item entry if it doesn't exist
    @item_boosts[@current_item_name] ||= []

    # Add boost if it's not already recorded
    unless @item_boosts[@current_item_name].include?(boost)
      @item_boosts[@current_item_name] << boost
      save_to_yaml(@item_boosts, ITEM_BOOSTS_FILE_PATH)
      puts "Recorded boost for #{@current_item_name}: #{boost}"
    end
  end
end

# Thread to monitor game lines for recall information
Thread.new do
  loop do
    line = get # Capture the game line

    # Check for item inspection lines to capture the item name
    extract_item_name(line) if line.include?("You carefully inspect your")

    # Process only lines related to item boosts
    process_recall_line(line) if line.include?("boost of")

    sleep 0.1 # Prevent high CPU usage
  end
end

# Main loop to keep the script running
loop do
  # Add any additional logic here if needed
  sleep 1 # Keep the script alive
end
