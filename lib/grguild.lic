=begin
	Gib's rogue guild script
	REQUIRED: grgvars.lic (probably)

	NOTE:  Script will NOT get you the first rank in any skill.

	INCOMPLETE:
			Lockmastery: Ranks 54-63.
			Sweep, almost in its entirety.
			Cheapshots, partner reps, plus multitown hop for watering flowers.
			Gambits in its entirety.
			Ta'Vaalor tasks may be subject to errors, and considered under construction.
			Ta'Vaalor, currently working patchs in place for most tasks.

	COMPLETE:
			Stun Maneuvers.
			Subdue's in-guild reps.
			Lockmastery through rank 53.

	NOTES:
			logic for the script is provided by the get_task method, which returns an array of your tasks and reps and whatnot.
			Use of get_task within other scripts can aid automation of critter/partner/picking reps.
			Custom variables are all dealt with by the grgvars.lic script.  This is to simplify YOUR life when I update.
			Instructions are provided withing grgvars for setting it up.
			Script will do all known and permitted tasks it can before leaving the guild
			$stun_move_room variable seems to have taken precidence as the "resting room" of choice for grguild.

	UPDATE:
			LOCKMASTERY UP TO RANK 53 WORKING.

	UNDER CONSTRUCTION:
			Lockmastery ranks 54+
			Sweep master reps, currently under construction.
			Ta'Vaalor rogue guild.  Cause whomever mapped it sucks.  Not guaranteed quite yet.
			Partner reps.
			multitown hop for watering plants.
	ERRORS:
			(A log, UNEDITED, is always helpful when you find a bug, and I'll try to squish em ASAP.)
			For help, check the PC thread in the ROGUE folder, or find me on AIM at Lord Gibreficul.  Please make sure you've read the PC thread and the script notes (;grguild notes and ;grguild help) before contacting me directly.  I'm busy writing scripts!

	version: 0.4
	 author: Kalros
	   tags: rogue

	changelog:
		0.3 (2015-02-13):
			removed .to_a from strings for Ruby 2.0 compatibility (Tillmen)
		0.4 (3.25.2017)
			Original author changed from Gibreficul to Kalros for repository reasons
			Uploaded due to removal. (possibly by SpiffyJr)
			Minor tweaks, can use ;grguild enter to enter the guild
			Minor updates to stun maneuvers, may not work!
			May not work in general!

=end
#silence_me
#hide_me
#quiet_exit
no_kill_all
no_pause_all
$rgmethods = []
$do_lfm = false unless Skills.pickinglocks >= 30
$landtime = 0 unless $landtime >= 0
$soltime = 0 unless $soltime >= 0
$icetime = 0 unless $icetime >= 0
unless $rgpassword
	start_script("grgvars")
	wait_while("Loading password and custom settings."){running? 'grgvars'}
	echo "CHECK TO MAKE SURE YOU HAVE grgvars.lic downloaded, MODIFIED FOR YOU (open the damn script) and trusted, then try again." unless $rgpassword
	exit unless $rgpassword
end
if Char.name !~ /Gibreficul/ && $rgpassword == ["kick","pull","kick","knock","pull","pull"]
	respond ""
	respond "SCRIPT HAS DETERMINED THAT YOU HAVE THE SAME PASSWORD AS GIBREFICUL"
	respond "THIS PROBABLY INDICATES THAT YOU HAVE NOT CHANGED grgvars.lic TO USE YOUR PASSWORD"
	respond "PLEASE OPEN grgvars.lic AND MODIFY THE COMMANDS IN THE $rgpassword ARRAY."
	respond "EXITING"
	$rgpassword = nil
	exit
elsif $rgpassword.length > 7 || $rgpassword.length < 5
	respond ""
	respond "SCRIPT HAS DETERMINED THAT YOU HAVE AN INVALID GUILD PASSWORD SET"
	respond "PLEASE MODIFY THE grgvars.lic SCRIPT AND MAKE SURE YOUR PASSWORD IS WHAT IS SHOWN IN THE $rgpassword ARRAY."
	respond "EXITING"
	$rgpassword = nil
	exit
end
################

$rogues = ["Nightcrawler", "Teef", "Kayous", "Clio", "Dashar", 'Sexy', 'Zan','Gibreficul', 'Swerr', 'Katze', 'Dan', 'Dagger', 'Veska','Locksmith','Baswab','Matt','Smeagol','Yollia','Morphion','Zishra','Seran','Dart','Stickyfingers','Rinn', 'Bhaal','Fiddlesticks','Ledru']
$rgdoors = [16393, 16838, 13350, 18348, 13243, 15694, 17984, 12421]
$rgidoor = [16394, 17897, 17838, 17806, 17932, 17964, 17985, 14089]
$vaalor_badrooms = [17829, 17830, 17831, 17832, 17833, 17834, 17835, 17836, 18347]
$lock_list = [["a primitive lock", 35],["a rudimentary lock", 75],["an extremely easy lock", 115],["a very easy lock", 155],["an easy lock", 195],["a very basic lock", 235],["a fairly easy lock", 275],["a simple lock", 315],["a fairly simple lock", 355],["a fairly plain lock", 395],["a moderately well\-crafted lock", 435],["a well-crafted lock", 475],["a tricky lock", 515],["a somewhat difficult lock", 555],["a moderately difficult lock", 595],["a very well\-crafted lock", 635],["a difficult lock", 675],["an extremely well\-crafted lock", 715],["a very difficult lock", 755],["a fairly complicated lock", 795],["an intricate lock", 835],["an amazingly well\-crafted lock", 875],["a very complex lock", 915],["an impressively complicated lock", 955],["an amazingly intricate lock", 995],["an extremely difficult lock", 1035],["an extremely complex lock", 1075],["a masterfully well\-crafted lock", 1115],["an amazingly complicated lock", 1155],["an astoundingly complex lock", 1195],["an incredibly intricate lock", 1235],["an absurdly well\-crafted lock", 1275],["an exceedingly complex lock", 1315],["an absurdly difficult lock", 1355],["a masterfully intricate lock", 1395],["an unbelievably complicated lock", 1435],["an impossibly complex lock", 1485]]
$trap_list = ["an easy trap","a rudimentary trap","a very basic trap","a simple trap","a fairly simple trap","a somewhat difficult trap","a moderately difficult trap","a difficult trap","a very difficult trap","an extremely difficult trap","an intricate trap","a very complex trap","an incredibly hard trap","an amazingly difficult trap","an astonishingly difficult trap","an absurdly difficult trap","a masterfully difficult trap"]
$grgshield = ["aegis", "buckler","greatshield","mantlet","parma","pavis", "scutum","shield","targe"]
$rgfindjaws = false
$rgfindacid = false
$rgfindcloud = false
$rgfindmagic = false
unless $rogues.include?(Char.name)
	$rogues.push(Char.name) if XMLData.game =~ /GSF/
end
$rogues.push(Char.name)

###################
#  ASSIGN SETUP METHODS #
###################

#$rgmethods.push("rg_hands_checker") unless $rgmethods.include?("hands_checker")
def rg_hands_checker
	gweaps = ["achlais", "adze", "angon", "awl\-pike", "axe", "backsword", "baculus", "badelaire", "balestarius", "breastplate","chain", "ball\-and\-chain", "ball", "balta", "bardiche", "baselard", "battle\-axe", "battlesword", "bidenhander", "bilbo", "bill", "binnol", "bisacuta", "blackjack", "bodkin", "bola", "^bow$", "brandestoc", "braquemar", "broadsword", "bulawa", "bullwhip", "cat\-o'\-nine\-tails", "cateia", "cestus", "chakram", "chereb", "cinquedea", "claidhmore", "claw", "cleaver", "club", "colichemarde", "contus", "craquemarte", "croc", "crook", "crosier", "crossbow", "crowbill", "cudgel", "cutlass", "dagger", "dart", "dhara", "dirk", "discus", "doloire", "dubh", "epee", "espadon", "estoc", "falarica", "falcastra", "falchion", "falx", "fang", "fauchard", "fist\-scythe", "flail", "flamberge", "fleuret", "flyssa", "foil", "fork", "framea", "francisca", "fuscina", "gaesum", "gauche", "gauntlet\-sword", "gladius", "glaive", "godendag", "goliah", "goupillon", "greataxe", "greatsword", "guisarme", "halberd", "half\-moon", "hammer of kai", "hammer", "handaxe", "harpoon", "hatchet", "hippe", "hook\-knife", "hoolurge", "jackblade", "jaculum", "javelin", "jeddart\-axe", "jitte", "kai", "kama", "kaskara", "katana", "katar", "katzbalger", "kheten", "khopesh", "kilij", "knife", "knuckle\-blade", "knuckle\-duster", "korseke", "kozuka", "kris", "lance", "lisan", "longbow", "longsword", "mace", "machera", "machete", "magari\-yari", "mail", "manople", "massuelle", "mattina", "mattock", "maul", "misericord", "^moon$", "nagimaki", "naginata", "^net$", "oncin", "paingrip", "palache", "parazonium", "partisan", "pavade", "pelta", "periperiu", "pernat", "^pick", "pike", "pill", "pilum", "poignard", "pugio", "quadrelle", "quoit", "ranseur", "rapier", "razorpaw", "runestaff", "runka", "sabar", "sabre", "^sai$", "^sap$", "sapara", "sarissa", "scepter", "schiavona", "schlager", "scimitar", "scorpion", "scramasax", "scythe", "seax", "shail", "shillelagh", "sica", "sledgehammer", "spadroon", "sparte", "spatha", "spear", "spetum", "spiculum", "spontoon", "sprinkler", "staff", "^star$", "^stick$", "stiletto", "sudis", "sword", "taavish", "tabar", "tails", "takouba", "tambara", "tanto", "taper", "tetsubo", "tock", "tocke", "tongue", "toporok", "trident", "troll\-claw", "truncheon", "tuck", "verdun", "voulge", "wakizashi", "waraxe", "whip", "whip\-blade", "xiphos", "yataghan", "yierka\-spur", "yoribo", "zinnor", "zweihander"]
	fput "store weapon" if GameObj.right_hand.noun =~ /#{gweaps.join('|')}/
	fput "store shield" if GameObj.left_hand.noun =~ /shield|buckler|targe|parma|aegis|scutum|greatshield|mantlet|pavis/
	fput "store ranged" if GameObj.left_hand.noun =~ /bow|yumi/i
	fput "stow left" if GameObj.left_hand.noun =~ /lockpick/i
	fput "wear keyring" if GameObj.left_hand.noun =~ /keyring/i || GameObj.left_hand.noun =~ /keyring/i
	$container.flatten.each{|cont|
		break if GameObj.right_hand.name =~ /Empty|\brag\b|broom|\bbag\b|\bcan\b/ && GameObj.left_hand.name =~ /Empty|\brag\b|broom|\bbag\b|\bcan\b/i
		fput "_drag ##{GameObj.right_hand.id} ##{cont}" unless GameObj.right_hand.name =~ /Empty|\brag\b|broom|\bbag\b|\bcan\b/i
		fput "_drag ##{GameObj.left_hand.id} ##{cont}" unless GameObj.left_hand.name =~ /Empty|\brag\b|broom|\bbag\b|\bcan\b/i
	}
	if GameObj.right_hand.noun =~ /\b(can|rag|broom|bag)\b/ || GameObj.left_hand.noun =~ /\b(can|rag|broom|bag)\b/
		mymove $rgtoolrack
		fput "put ##{GameObj.right_hand.id} on rack" if GameObj.right_hand.noun =~ /\b(can|rag|broom|bag)\b/
		fput "put ##{GameObj.left_hand.id} on rack" if GameObj.left_hand.noun =~ /\b(can|rag|broom|bag)\b/
	end
end
$rgmethods.push("gld_pw") unless $rgmethods.include?("gld_pw")
def gld_pw
#	return(go_guild) unless [$rgdoor, $rgdoors].flatten.include?(Room.current.id)
	fput "lean door"
	$rgpassword.each{|action|
		fput "#{action} door"
	}
	fput "go door"
end
#$rgmethods.push("find_nearest") unless $rgmethods.include?("find_nearest")
def find_nearest(target_list)
	#You probably have this method somewhere already, it's recycled in a ton of scripts, but it's here if you don't.
	start_room = Room.current
	least_time = nil
	least_target = nil
	previous, shortest_distances = Map.dijkstra(start_room.id)
	for target in target_list
		return target if start_room.id == target
		est_time = shortest_distances[target]
		if !est_time.nil? and (least_time.nil? or least_time > est_time)
			least_target = target
			least_time = est_time
		end
	end
	least_target = nil unless least_target
	return least_target
end
$rgmethods.push("wait_rt") unless $rgmethods.include?("wait_rt")
def wait_rt
	wait_while { checkrt > 0 or checkcastrt > 0 }
	sleep 0.25
end
$rgmethods.push("mymove") unless $rgmethods.include?("mymove")
def mymove(room = false)
	fput "out" if checkroom =~ /table|dark alcove|Locksmithing Workshop|dark corner/i || (Room.current.id == 4 && checkpaths.include?('out'))
	if $vaalor_badrooms.include?(Room.current.id)
		rguild(18348)
		respond "YOU ARE IN THE VAALOR GUILD, PATCHING GO2 ERRORS"
		if Room.current.id == 18347
			walk
		else
			start_script("go2",[17833, '_disable_confirm_']) unless Room.current.id == 17833
			wait_while{running?("go2")}
			fput "go panel"
			walk
		end
	end
	if room
		if hiding?
			start_script("go2",['typeahead=0', room, '_disable_confirm_'])
			wait_while{running?("go2")}
		else
			start_script("go2",[room, '_disable_confirm_'])
			wait_while{running?("go2")}
		end
	else
		echo "NO TARGET FOR MOVEMENT"
	end
end

######################
## MOVE AROUND THE GUILD ##
######################

#########
### CUSTOM CODE BY KALROS.  USER ;grguild enter to enter the guild.
#########

	testvar =
	if script.vars[1] == 'enter'
		go_guild 
		if script.vars[2].nil?
			mymove $rgadmin
		else
			eval ("testvar = $#{script.vars[2]}")
			if testvar.nil?
				echo "No room found"
				exit
			end
			start_script "go2", ["#{testvar}"]
		end	
	exit
	end

$rgmethods.push("get_rank") unless $rgmethods.include?("get_rank")
def get_rank(task)
	mymove $rgmaster
	fput "ask ##{GameObj.npcs.find{|npc| npc.name =~ /master/i}.id} about next #{task}"
	mymove $rgadmin
	fput "ask ##{GameObj.npcs.find{|npc| npc.name =~ /training/i}.id} about train #{task}"
end
$rgmethods.push("go_admin") unless $rgmethods.include?("go_admin")
def go_admin
	go_guild
	mymove $rgadmin
end
$rgmethods.push("go_master") unless $rgmethods.include?("go_master")
def go_master
	go_guild
	mymove $rgmaster
end
def find_something(thisitem)
	thisitem = [ thisitem ] unless thisitem.type == 'Array'
	findthis = false
	GameObj.inv.each{|sack|
		findthis = GameObj.right_hand.id if GameObj.right_hand.noun =~ /#{thisitem.join('|')}/
		findthis = GameObj.left_hand.id if GameObj.left_hand.noun =~ /#{thisitem.join('|')}/
		next if sack.contents == nil
		if thisitem.include?('lockpick')
			findthis = sack.contents.find{|pick| pick.noun == "lockpick" && pick.name =~ /silver |mithril |ora |glaes |laje |vultite |rolaren |veniom |invar |alum |golvern |kelyn |vaalin /i}.id
		else

		end
		if findthis != 4 && findthis
			fput "get ##{findthis}"
			break
		else
			findthis = false
		end
	}
end
def grg_checkin
	mymove 'bank'
	fput "with 15000 silver"
	go_master
	3.times{fput "ask ##{GameObj.npcs.find{|npc| npc.name =~ /master/i}.id} about checkin"}
	mymove 'bank'
	fput "depo all"
	go_admin
end
def grg_initiation
	mymove 'bank'
	fput "withdraw 15000 silver"
	go_master
	fput "ask ##{GameObj.npcs.find{|npc| npc.name =~ /master/i}.id} about initiat"
end
$rgmethods.push("go_guild") unless $rgmethods.include?("go_guild")
def go_guild
	respond "Rogue Guild Grandmaster Gibreficul will now determine the closest guild, this may take a moment."
	x = find_nearest([$rgdoors, $rgidoor, $vaalor_badrooms].flatten)
	if $rgdoors.include?(x)
		rguild(x)
		respond "Rogue Guild Grandmaster Gibreficul has determined you are nearest the #{$guildname} Guild"
		if $rgdoor == 17984
			### THIS SHOULD BE FIXED ###
			mymove 10957
			fput "go small door"
		elsif $rgdoor == 17837
			### THIS SHOULD BE FIXED ###
			mymove 13350
			fput "go gold door"
		elsif $rgdoor == 17931
			mymove 13243
			fput "go narrow step"
		elsif $rgdoor == 18348
			respond "**** Ta'Vaalor smart patch because go2 needs to be fixed."
			rg_hands_checker
			if Skills.pickinglocks >= 30
				echo "PASSED PICK CHECK, SCANNING FOR LOCKPICK"
				findpick = false
				GameObj.inv.each{|sack|
					findpick = GameObj.right_hand.id if GameObj.right_hand.noun == 'lockpick'
					findpick = GameObj.left_hand.id if GameObj.left_hand.noun == 'lockpick'
					next if sack.contents == nil
					findpick = sack.contents.find{|pick| pick.noun == "lockpick" && pick.name =~ /silver |mithril |ora |glaes |laje |vultite |rolaren |veniom |invar |alum |golvern |kelyn |vaalin /i}.id
					if findpick != 4 && findpick
						@stashsack = sack.id
						fput "get ripper from toolkit"
						break
					else
						findpick = false
					end
				}
				if findpick
					pickshed
					fput "_drag ripper toolkit"
				else
					asklocksmith
				end
			else
				echo "MOVE TO THE LOCKSMITH AND MAKE THAT BITCH LET YOU IN"
				asklocksmith
			end
		else
		end
		mymove $rgdoor unless Room.current.id == $rgdoor
		echo "GUILD PASSWORD HERE"
		gld_pw
		matchtimeout(1, "Obvious")
		fput "climb shaft" if Room.current.id == 17985
	elsif $rgidoor.include?(x)
		case x
			when 16394
				rguild(16393)
			when 17897
				rguild(16838)
			when 17838
				rguild(17837)
			when 17806
				rguild(18348)
			when 17932
				rguild(13243)
			when 17964
				rguild(15694)
			when 17985
				rguild(17984)
			when 14089
				rguild(12421)
		end
		respond "Rogue Guild Grandmaster Gibreficul has determined you are inside the #{$guildname} Guild"
		return
	elsif $vaalor_badrooms.include?(x)
		rguild(18348)
		respond "YOU ARE IN THE VAALOR GUILD, PATCHING GO2 ERRORS"
		if Room.current.id == 18347
			walk
		else
			mymove 17833 unless Room.current.id == 17833
			fput "go panel"
			walk
		end
	else
		echo "NO FUCKING CLUE"
		echo "EXITING, 308"
		exit
	end
end
def pickshed
	mymove 3509 unless Room.current.id == 3509
	Spell[403].cast if Spell[403].known? && !Spell[403].active?
	clear
	fput "picklock shed"
	x = matchwait /You make|does not appear to be locked|broken lockpick.|mention what you want to pick|Um, but it's open/
	if x =~ /not appear|Um, but it's open/
		fput "open shed" unless x =~ /open/
		multifput("go shed", "_drag ripper toolkit")
		shedpuzzle
	elsif x =~ /broken|mention what you want to pick/
		respond "********* Broken lockpick" if x =~ /broken/
		fput "put my ripper in my toolkit"
		return(asklocksmith)
	else
		y = matchwait /\.\.\.CLICK|not appear to be locked|using a broken|Roundtime/i
		if y =~ /within your abilities|but you get a sense that it has|are not able to|Roundtime/
			waitrt?
			return(pickshed)
		elsif y =~ /are not able to|stuck/
			waitrt?
			fput "put my ripper in my toolkit"
			return(asklocksmith)
		elsif y =~ /not appear to be locked|\.\.\.CLICK/
			waitrt?
			fput "put my ripper in my toolkit"
			multifput("open shed","go shed")
			return(shedpuzzle)
		elsif y =~ /broken/
			respond "********* Broken lockpick"
			waitrt?
			fput "put my ripper in my toolkit"
			return(asklocksmith)
		else
			echo "maybe error?"
			return(go_guild)
		end
	end
end
def asklocksmith
	mymove 'locksmith'
	fput "ask shind about guild"
	matchwait /just went and picked the shed, so you ought to be able to get that far/
	mymove 3509
	fput "open shed"
	fput "go shed"
	shedpuzzle
end
def shedpuzzle
	if Room.current.id.to_s =~ /17805|20020/
		fput "pull hoe"
		waitrt?
		sleep 1
		fput "pull rake"
		waitrt?
		sleep 1
		fput "pull shovel"
		waitrt?
		sleep 1
		fput "go panel"
	else
		go_guild
	end
end
#$rgmethods.push("rguild") unless $rgmethods.include?("rguild")
def rguild(town)
	case town
		when 16393
			### ROOM NUMBERS FOR W-LANDING PULLED FROM slib.lic.  Thanks Spiffy.
			$guildname = "Wehnimer's Landing"
			$rgdoor = 16393
			$rgindoor = 16394
			$rgadmin = 16504
			$rgfootpads = 16540
			$rgmaster = 16485
			$rgtoolrack = 16581
			$rgwindows = [16557, 16555, 16491, 16490, 16517]
			$rgdirt = [16517, 16490, 16438, 16492, 16534, 16540]
			$rgshop = 16421
			$rgbar = 16423
			$rgwildflowers = [16504, 16438, 16517, 16534, 16545]
			$rgkitchen = 16433
			$rgtable = 16427
			$rgworkshop = 16574
			$rgdummy = 16509
			$rgmannequin = 16509
			$rglockroom = 8686
			$rgtownsmith = 'locksmith'
			$rghardlock = 'door'
			$rgbuypick = 2
			$rgwirenum = 4
		when 16838
			$guildname = "Zul Logoth"
			$rgdoor = 16838
			$rgindoor = 17897
			$rgadmin = 17915
			$rgfootpads = 17917
			$rgmaster = 17904
			$rgdummy = 17918
			$rgmannequin = 17916
			$rgtoolrack = 17894
			$rgwildflowers = [17921, 17914, 17922, 17923, 17919]
			$rgwindows = [17909, 17905, 17895, 17893, 17891]
			$rgdirt = [17914, 17917, 17916, 17923, 17922, 17920, 17919, 17918]
			$rgkitchen = 17890
			$rgtable = 17901
			$rgshop = 17906
			$rgworkshop = 17911
			$rgbar = 17899
			$rgtownsmith = 'locksmith'
			$rglockroom = 1011
			$rghardlock = 'tent'
			$rgbuypick = 2
			$rgwirenum = 5
		when 18348
			echo "TA VAALOR GRGUILD SETTING VARS"
			$guildname = "Ta'Vaalor"
			$rgdoor = 18348
			$rgindoor = 17806
			$rgadmin = 17836
			$rgfootpads = 18345
			$rgmaster = 17831
			$rgdummy = 17819
			$rgmannequin = 17822
			$rgtoolrack = 17817
			$rgwildflowers = [17834, 17833, 17836, 17835, 17829]
			$rgwindows = [17806, 17807, 17808, 17809, 17812, 17825, 17826]
			$rgdirt = [17820, 17816, 17818, 17819, 17822, 17823, 17824]
			$rgkitchen = 17830
			$rgtable = 17828
			$rgshop = 17821
			$rgworkshop = 17827
			$rgbar = 10386
			$rgexit = [17825, "go chute", 10434]
			$vaalor_locksmith = 10434
			$rglockroom = 17829
			$rgtownsmith = 'locksmith'
			$rghardlock = 'door'
			$rgbuypick = 2
			$rgwirenum = 4
			echo "Ta'Vaalor's map is buggy, I have done what I can to patch it, hopefully a remapping is in order shortly."
		when 13350
			$guildname = "Ta'Illistim"
			$rgdoor = 17837
			$rgindoor = 17838
			$rgadmin = 17883
			$rgfootpads = 17864
			$rgmaster = 17886
			$rgdummy = 17862
			$rgmannequin = 17861
			$rgtoolrack = 17861
			$rgwildflowers = [17855, 17851, 17871, 17870, 17869 ]
			$rgwindows = [17856, 17853, 17872, 17871, 17885, 17869, 17860]
			$rgdirt = [17840, 17876, 17877, 17878, 17879]
			$rgkitchen = 17889
			$rgtable = 17838
			$rgshop = 17880
			$rgworkshop = 17881
			$rgbar = 17867
			$rglockroom = 17873
			$rgtownsmith = 'locksmith'
			$rghardlock = 'case'
			$rgbuypick = 3
			$rgwirenum = 4
			$rgshieldroom = 4012
			$rgshieldnum = 1
			$rgshieldcost = 100
			$rgdagshop = 602
			$rgdagnum = 1
			$rgdagcost = 100
		when 13243
			$guildname = "Solhaven"
			$rgdoor = 17931
			$rgindoor = 17932
			$rgadmin = 17948
			$rgfootpads = 17951
			$rgmaster = 17956
			$rgdummy = 17950
			$rgmannequin = 17949
			$rgtoolrack = 17941
			$rgwildflowers = [17942, 17946, 17944, 17950, 17953]
			$rgwindows = [17963, 17946, 17944, 17948, 17950]
			$rgdirt = [17942, 17946, 17945, 17944, 17947, 17948, 17949]
			$rgkitchen = 17940
			$rgtable = 17962
			$rgshop = 17935
			$rgbuyer = 17958
			$rgworkshop = 17960
			$rgbar = 17937
			$rglockroom = 1530
			$rgtownsmith = 5725
			$rghardlock = 'door'
			$rgbuypick = 3
			$rgwirenum = 6
		when 15694
			$guildname = "Icemule Trace"
			$rgdoor = 15694
			$rgindoor = 17964
			$rgadmin = 17967
			$rgfootpads = 17965
			$rgmaster = 17975
			$rgdummy = 17976
			$rgmannequin = 17965
			$rgtoolrack = 17969
			$rgwildflowers = [17967, 17976, 17964, 17965, 17974]
			$rgwindows = [17976, 17964, 17965, 17966, 17975]
			$rgdirt = [17967, 17976, 17965]
			$rgkitchen = 17969
			$rgtable = 17981
			$rgshop = 17970
			$rgbuyer = 17971
			$rgworkshop = 17978
			$rgbar = 17980
			$rglockroom = 2303
			$rgtownsmith = 'locksmith'
			$rghardlock = 'door'
			$rgbuypick = 2
			$rgwirenum = 4
		when 17984
			$guildname = "River's Rest"
			$rgdoor = 17984
			$rgindoor = 17985
			$rgadmin = 18007
			$rgfootpads = 18010
			$rgmaster = 17991
			$rgdummy = 18008
			$rgmannequin = 18008
			$rgtoolrack = 18003
			$rgwildflowers = [18000, 18005, 18006, 18009, 17999]
			$rgwindows = [18004, 18002, 18001, 17999, 17989, 17988]
			$rgdirt = [17999, 18000, 18005, 18007, 18008, 18009 ]
			$rgkitchen = 18001
			$rgtable = 17995
			$rgshop = 17992
			$rgbuyer = false
			$rgworkshop = 18004
			$rgbar = 17995
			$rglockroom = 10887
			$rgtownsmith = 'locksmith'
			$rghardlock = 'hatchway'
			$rgbuypick = 2
			$rgwirenum = 4
		when 12421
			$guildname = "Teras Isle"
			$rgdoor = 12421
			$rgindoor = 14089
			$rgadmin = 17798
			$rgfootpads = 17419
			$rgmaster = 17432
			$rgdummy = 17797
			$rgmannequin = 17802
			$rgtoolrack = 17396
			$rgwildflowers = [17396, 17432, 17433, 17803, 17800]
			$rgwindows = [17396, 17804, 14089, 17421, 17800]
			$rgdirt = [17421, 17433, 17796, 17799, 17800]
			$rgkitchen = 17420
			$rgtable = 17801
			$rgshop = 17434
			$rgbuyer = 17796
			$rgworkshop = 17387
			$rgbar = 17800
			$rglockroom = 1860
			$rgtownsmith = 'locksmith'
			$rghardlock = 'gate'
			$rgbuypick = 2
			$rgwirenum = 4
	end
end

######### MULTIPLE SKILL TASKS ###########

############### SWEEP COURTYARD
$rgmethods.push("sweep_courtyard") unless $rgmethods.include?("sweep_courtyard")
def sweep_courtyard(again = false)
	unless again
		go_guild
		mymove $rgtoolrack
		fput "store weapon" if checkright
		fput "store shield" if checkleft
		fput "stow right" unless GameObj.right_hand.name =~ /broom|empty/i
		fput "stow left" unless GameObj.left_hand.name =~ /bag|empty/i
	end
	multifput("get broom from rack","get bag from rack") unless GameObj.right_hand.noun =~ /broom/ && GameObj.left_hand.noun =~ /bag/i
	fput "put bag in bin"
	$rgdirt.each{|room|
		mymove room
		while GameObj.loot.find{|newdirt| newdirt.noun =~ /dirt/i}
			sleep 1
			fput "push broom"
			wait_rt
		end
		sleep 1
		fput "get pile"
		fput 'look in my bag'
		x = matchwait /room for more|full|empty/
		break if x =~ /full/
	}
	mymove $rgtoolrack
	fput "put bag in bin"
	y = matchwait /isn't full|repetition| have completed/
	if y =~ /completed/
		fput "put broom on rack"
		fput "put bag on rack"
		mymove $rgadmin
	else
		sweep_courtyard(true)
	end
end
############## WINDOWS
#$rgmethods.push("wintime") unless $rgmethods.include?("wintime")
def wintime
	echo Time.now.to_i - $windows_time
end
$rgmethods.push("windows") unless $rgmethods.include?("windows")
def windows
	go_guild
	get_rag unless GameObj.right_hand.noun =~ /rag/i || GameObj.left_hand.noun =~ /rag/i
	$windows_time = Time.now.to_i unless $windows_time
	$windows_time = Time.now.to_i if  Time.now.to_i - $windows_time > 620
	$landtime = $windows_time if $guildname =~ /Wehnimer/
	$soltime = $windows_time if $guildname =~ /Solhaven/
	$icetime = $windows_time if $guildname =~ /Icemule/
	$rgwindows.each{|win|
		wait_rt
		sleep 1
		mymove win
		fput "rub ##{GameObj.loot.find{|window| window.noun =~ /window/i}.id}" if GameObj.loot.find{|window| window.noun =~ /window/i}
		fput "rub ##{GameObj.room_desc.find{|thing| thing.noun =~ /window/i}.id}" if GameObj.room_desc.find{|thing| thing.noun =~ /window/i} && !GameObj.loot.find{|window| window.noun =~ /window/i}
		x = matchwait /repetition|completed|enough cleaning for|need to do that/
		wait_rt
		walk if win == 17885
		if x =~ /completed|need to do that/
			$done = true
			break
		else
			$done = false
		end
	}
	sleep 1
	put_rag if GameObj.right_hand.noun =~ /rag/i || GameObj.left_hand.noun =~ /rag/i
end
#$rgmethods.push("put_rag") unless $rgmethods.include?("put_rag")
def put_rag
	mymove $rgtoolrack
	return put_rag unless Room.current.id == $rgtoolrack
	fput "put rag on rack"
	$windows_time = 0 if get_task.find{|skil, task, rep| task =~ /clean the windows in the guild/ && rep =~ /no/i}
end
#$rgmethods.push("get_rag") unless $rgmethods.include?("get_rag")
def get_rag
	rg_hands_checker
	mymove $rgtoolrack
	return get_rag unless Room.current.id == $rgtoolrack
	fput "get rag from rack"
end
def do_windows(backroom = false)
	unless $windows_time
		windows
		return(smart_task)
	end
	if Time.now.to_i - $windows_time > 620
		echo "HELLO NURSE"
		windows
		return(smart_task)
	else
#		echo "ELSE GOODBYE NURSE"
		respond " **** ONE MOMENT, CALCULATING WINDOWS TO WASH IN WHAT GUILD AND WHATNOT ****"
		x = find_nearest([$rgdoors, $rgidoor, $vaalor_badrooms].flatten)
		rguild(x)
		if $wait_for_windows
			mymove $stun_move_room
			wait_until("Waiting on dirty windows, change setting to $wait_for_windows = false in grgvars to toggle this off"){Time.now.to_i - $windows_time > 620}
			windows
		elsif $guildname =~ /Wehnimer/
			if Time.now.to_i - $landtime > 620 && $landtime != 0
				windows
				return(smart_task)
			elsif Time.now.to_i - $soltime > 590
				mymove 'bank'
				returnhome = Room.current.id
				fput "depo all"
				fput "with 100 silver"
				fput "gird"
				mymove 13243
				$landtime = $windows_time
				windows
				mymove returnhome if $done
				return(smart_task)
			else
				mymove 'bank'
				returnhome = Room.current.id
				fput "depo all"
				fput "with 100 silver"
				fput "gird"
				$landtime = $windows_time
				mymove 2300
				windows
				mymove returnhome if $done
				return(smart_task)
			end
		elsif $guildname =~ /Solhaven/
			if Time.now.to_i - $soltime > 620 && $soltime != 0
				windows
				return(smart_task)
			elsif Time.now.to_i - $landtime > 590
				mymove 'bank'
				returnhome = Room.current.id
				fput "depo all"
				fput "with 100 silver"
				fput "gird"
				$soltime = $windows_time
				mymove 13243
				windows
				mymove returnhome if $done
				return(smart_task)
			else
				mymove 'bank'
				returnhome = Room.current.id
				fput "depo all"
				fput "with 100 silver"
				fput "gird"
				$soltime = $windows_time
				mymove 2300
				windows
				mymove returnhome if $done
				return(smart_task)
			end
		elsif $guildname =~ /Icemule/
			if Time.now.to_i - $icetime > 620 && $icetime != 0
				windows
				return(smart_task)
			elsif Time.now.to_i - $soltime > 590
				mymove 'bank'
				returnhome = Room.current.id
				fput "depo all"
				fput "with 100 silver"
				fput "gird"
				$icetime = $windows_time
				mymove 13243
				windows
				mymove returnhome if $done
				return(smart_task)
			else
				mymove 'bank'
				returnhome = Room.current.id
				fput "depo all"
				fput "with 100 silver"
				fput "gird"
				$icetime = $windows_time
				mymove 228
				windows
				mymove returnhome if $done
				return(smart_task)
			end
		elsif $guildname =~ /Ta'(Vaalor|Illistim)/ && Char.level > 60 && Skills.climbing >= 50 && percentencumbrance <= 20
###
			if $guildname =~ /Ta'Illistim/
				$rg_en_shortcut = {	'backroom' => 188, 'goroom' => 3519}
				start_script('go2', ['shortcut=on'])
				wait_while{running?('go2')}
			elsif $guildname =~ /Ta'Vaalor/
				$rg_en_shortcut = {	'backroom' => 3519, 'goroom' => 188}
				start_script('go2', ['shortcut=on'])
				wait_while{running?('go2')}
				mymove $rgexit[0]
				fput "go chute"
			end
			$windows_time = 0
			mymove $rg_en_shortcut['goroom']
			windows
			if $guildname =~ /Ta'Vaalor/i
				mymove $rgexit[0]
				fput "go chute"
			end
			mymove $rg_en_shortcut['backroom']
			echo "smart_task 790, maybe? ending loop"
		else
			if $wait_for_windows
				mymove $stun_move_room
				wait_until("Waiting on dirty windows"){Time.now.to_i - $windows_time > 620}
				windows
			else
				if $guildname =~ /Ta'Vaalor/
					mymove $rgexit[0]
					fput "go chute"
				end
				mymove "town"
				echo "GRGUILD EXITING, Toggle $wait_for_windows = true to prevent this. "
				exit
			end
		end
	end
end
def do_thewindows
	if $windows_time
		if Time.now.to_i - $windows_time > 620
			windows
			return(smart_task)
		else
			if $guildname =~ /Wehnimer's Landing/
				mymove 'bank'
				fput "with 100 silver"
				$windows_time = 0
				fput "gird"
				returnhome = Room.current.id
				mymove 13243
				$landtime = $windows_time
				windows
				fput "gird"
				unless $done
					$soltime = $windows_time
					mymove 15694
					windows
				end
				fput "gird"
				mymove returnhome
				fput "depo all"
				go_guild
				$icetime = $windows_time
				$windows_time = 0
				return(smart_task)
			elsif $guildname =~ /Solhaven|Icemule Trace/
				mymove 'bank'
				fput "with 100 silver"
				$windows_time = 0
				fput "gird"
				returnhome = Room.current.id
				mymove 228
				go_guild
				windows
				fput "gird"
				mymove returnhome
				fput "depo all"
				go_guild
				$windows_time = 0
				return(smart_task)
			else
				if $wait_for_windows
					mymove $stun_move_room
					wait_until("Waiting on dirty windows"){Time.now.to_i - $windows_time > 620}
					windows
				else
					if $guildname =~ /Ta'Vaalor/
						mymove $rgexit[0]
						fput "go chute"
					end
	#					mymove $stun_move_room
	#				next
				end
			end
		end
	else
		echo "NO WINDOWS TIME SET"
		windows
	end
end
################ SPECIFIC SKILL TASKS #################

###### SUBDUE TASKS
######################## MELONS
$rgmethods.push("melons") unless $rgmethods.include?("melons")
def subdue_first_rank(inmaster = false)
	unless inmaster
		go_guild
		mymove $rgfootpads
		x = false
		until x
			fput "ask ##{GameObj.npcs.find{|npc| npc.name =~ /Master Footpad/}.id} about train subdue"
			x = matchtimeout(30, "pulls you aside for some instruction")
		end
		return(subdue_first_rank(true))
	end
	echo "EXITING, 891"
	matchwait /Type SUBDUE/
	target = GameObj.npcs.find{|npc| npc.noun == 'mannequin'}.id
	fput "stance off" unless percentstance < 20
	exit
end
def melons(inside = false)
	unless inside
		go_guild
		mymove $rgmannequin
		rg_hands_checker
		fput "ready weapon"
		fput "go mann"
	end
	fput "look on mann"
	x = matchwait /battered melon rests|gore cling to a wooden spike|ripe melon rests/
	if x =~ /battered melon|gore cling/
		fput "clean mann"
		sleep 1
		wait_rt
		fput "put melon on man"
		wait_rt
	end
	wait_rt
	fput "stance off" unless percentstance <= 20
	wait_until("LOW STAMINA"){checkstamina > 5}
	fput "subdue mann"
	z = false
	y = matchwait /causes a deep crack|a nice percussion noise|land a perfect blow|melon is now pulp|melon is obliterated|mannequin needs a head/
	if y =~ /land a perfect blow/
		z = matchwait /repetition|complete/
		wait_rt
	elsif y =~ /melon is obliterated/
		wait_rt
		fput "stand" until standing?
	end
	wait_rt
	if z =~ /complete/
		fput "store weapon"
		fput "out"
		mymove $rgadmin
	else
		melons(true)
	end
end

################ GARLIC
$rgmethods.push("garlic") unless $rgmethods.include?("garlic")
def garlic(inside = false)
	unless inside
		go_guild
		mymove $rgkitchen
		rg_hands_checker
		fput "ready weapon"
		fput "go kitchen"
	end
	fput "look on block"
	z = matchwait /ripe clove of garlic sits neatly in the middle|horribly mangled clove of garlic|perfectly smashed clove of garlic|pile of freshly peeled garlic cloves sits/
	wait_rt
	fput "put block in pot" if z =~ /perfectly smashed/
	fput "clean block" if z =~ /horribly mangled/
	wait_rt
	fput "put clove on block" unless z =~ /sits neatly/
	wait_until("LOW STAMINA"){checkstamina > 5}
	fput "subdue block"
	x = matchwait /Bellisimo|little softer next|manage to miss the clove|clove is obliterated|You must caress da garlic|Put it in the pot now/
	if x =~ /Bellisimo/
		y = matchwait /repetition|complete/
		wait_rt
		unless y =~ /complete/i
			garlic(true)
			return
		end
	elsif x =~ /softer|clove is obliterated|You must caress da garlic/
		wait_rt
		fput "clean block"
		garlic(true)
		return
	elsif x =~ /miss the clove/
		garlic(true)
		return
	elsif x =~ /in the pot now/
		fput "put block in pot"
		garlic(true)
		return
	end
	fput "out"
	fput "store weapon"
	mymove $rgadmin
end
def master_subdue
	go_guild
	rg_hands_checker
	mymove $rgfootpads
	x = false
	until x
		fput "ask ##{GameObj.npcs.find{|npc| npc.name =~ /Master Footpad/}.id} about train subdue"
		x = matchtimeout(30, "pulls you aside for some instruction")
	end
	matchwait /big secret of subdue/
	sleep 3
	fput "out"
end
############ CHEAPSHOTS TASKS
def cheapshot_first_rank(inmaster = false)
	unless inmaster
		go_guild
		rg_hands_checker
		mymove $rgfootpads
		fput "stance off" unless percentstance <= 20
		pause_script "stand" if running? 'stand'
		x = false
		until x
			fput "ask ##{GameObj.npcs.find{|npc| npc.name =~ /Master Footpad/}.id} about train cheapshot"
			x = matchtimeout(30, "pulls you aside for some instruction")
		end
		put "gld stance off"
		put "stance off"
		result = matchwait /Lemme show you how (FOOTSTOMP) is done/
		loop{
			task = get_task
			if cur_task = task.find{|a, b, c| a == 'Cheap Shot' && c =~ /\d+/i}
				wait_until("Stamina issues"){stamina? >= 10}
				fput "cheap foot ##{GameObj.npcs.find{|npc| npc.name =~ /Master Footpad/}.id}"
				waitrt?
			else
				break
			end
		}
		inmaster = true
	end
end
##################### WATER PLANTS
$rgmethods.push("water_plants") unless $rgmethods.include?("water_plants")
def water_plants
	go_guild
	#Watering plants
	unless GameObj.right_hand.name =~ /watering can/i || GameObj.left_hand.name =~ /watering can/i
		rg_hands_checker
		mymove $rgtoolrack
		fput "get can from rack"
	end
	$rgwildflowers.each{|flower|
		mymove flower
		fput "kneel" until kneeling?
		fput "water ##{GameObj.loot.find{|flow| flow.noun =~ /rose|begonia|dandelion|wisteria|flower|moss/}.id}"
		fput "water ##{GameObj.room_desc.find{|flow| flow.noun =~ /rose|begonia|dandelion|wisteria|flower|moss/}.id}"
		x = matchwait /water/
		y = false
		y = matchtimeout(1, "repetition|complete")
		sleep 1
		wait_rt
		fput "stand" until standing?
		sleep 1
		wait_rt
		break if y =~ /complete/
	}
	mymove $rgtoolrack
	fput "put can on rack"
	mymove $rgadmin
end

################# LOCK MASTERY SKILLS

########################### LM SENSE

$rgmethods.push("lmsense") unless $rgmethods.include?("lmsense")
def lmsense(inmaster = false)
	if XMLData.active_spells.keys.join('|') =~ /\d+/
		fput "set showspell on"
		$rgresetspells = true
	else
		$rgresetspells = false
	end
	unless inmaster
		go_guild
		rg_hands_checker
		mymove $rgfootpads
		z = false
		until z
			fput "ask ##{GameObj.npcs.find{|npc| npc.name =~ /Master Footpad/}.id} about train lock"
			z = matchtimeout(30, "pulls you aside for some instruction")
		end
		x = false
		x = matchtimeout(60, "LMASTER SENSE|Take the calipers from the table, LMASTER MEASURE box, then speak the box's difficulty aloud|LMASTER CALIBRATE the calipers to refine their tuning|lock may be blocked, or maybe you fused the tumblers|for each pick, and decide which is the best|still gonna break a pick|go ahead and lock up that box|sometimes people need a little extra|enough freelance lockmakers around|yank out poison needles|extract the vials of acid|extract are those pretty crystals|care what kind they are, but they'd better be fresh|throw burning goo on you and the shocking cloud ones|just because you can make your own lockpicks|time to exercise your creative side")
		return(lmmeasure) if x =~ /LMASTER MEASURE box, then speak the box's difficulty aloud/
		return(calicali) if x =~ /LMASTER CALIBRATE the calipers to refine their tuning/
		return(masterwedge) if x =~ /lock may be blocked, or maybe you fused the tumblers/
		return(applocks) if x =~ /for each pick, and decide which is the best/
		return(breakpicks) if x =~ /still gonna break a pick/
		return(relock) if x =~ /go ahead and lock up that box/i
		return(claspconts) if x =~ /sometimes people need a little extra/i
		return(makelocks) if x =~ /enough freelance lockmakers around/i
		return(trapreps(x)) if x =~ /yank out poison needles|extract the vials of acid|extract are those pretty crystals|care what kind they are, but they'd better be fresh|throw burning goo on you and the shocking cloud ones/
		return(makepicks) if x =~ /just because you can make your own lockpicks/i
		return(lmcustom) if x =~ /time to exercise your creative side/i
#		#Colvin says, "Waste not, want not, they say.  Well, sometimes parts used to make a trap can come in handy later on.  Several different kinds of traps have bits we can remove, if you've got the skill.  Another group of trap components I'm sure you're eagerly awaiting to learn how to extract are those pretty crystals.  The one kind sucks the box up, and the other emits an elemental wave to pummel the area.  You prolly know what I'm talkin' about.  Once you snag those, the spheres can be thrown on the ground to unleash their magic, or if you're feelin' particularly cruel, you can throw one of the dark crystals right at somebody and watch the fun.  That's my favorite."
		unless x
			respond "grguild doesn't know this task, cleanup and exit"
			respond "GRGUILD EXITING, EXITING, EXITING, AROUND LINE 1000"
			fput "out"
			mymove $stun_move_room
			$do_lfm = false
			return
		end
		wtf = false
		wtf = matchtimeout(1, 'then describe')
		if wtf
			vars = []
			if wtf =~ /best trap/ then vars.push('trap') end
			if wtf =~ /best lock/ then vars.push 'lock' end
			if wtf =~ /room conditions/ then vars.push 'room' end
			if wtf =~ /spell/ then vars.push 'spells' end
			return(lmsense2(vars))
		end
	end
	echo "LM sense, loop 1, *** DEBUG 981"
	fput "lm sense"
	s = false
	r = false
	spells = []
	spells = XMLData.active_spells.keys
	x = matchwait /you determine/i
	respond "IF you see this, it moved on, *** DEBUG 988"
	x2 = x.gsub("you determine","I determined")
	x3 = x2.gsub("you are","I am")
	x4 = x3.gsub("you can tell","I can tell")
	x5 = x4.gsub("around you","around me")
	s = matchtimeout(1, "Additionally|Unfortunately|Under the current conditions")
	if s =~ /Under the current conditions/
		r = s
		s = false
	else
		r = matchtimeout(1, "Under the current conditions")
	end
	r2 = r.gsub("you think you could","I think I can") if r
#	spells.push("crystal amulet") if s =~ /voices in your head/
	if r
		if s
			fput "say #{x5} I am wearing #{spells.uniq.join(', ')}. #{r2}"
		else
			fput "say #{x5}  #{r2}"
		end
	elsif s
		fput "say #{x}, and wearing #{spells.join(', ')}."
	else
		fput "say #{x5}"
	end
	y = matchwait /[^\s]+\s(says|exclaims),/
	z = false
	z = matchtimeout(1, "repetition|complete")
	spells = []
	return(lmsense(true)) unless z =~ /complete/
	return unless z =~ /complete/
	fput "set showspell off" if $gld_spell_reset
	$gld_spell_reset = nil
	fput "out"
	mymove $rgadmin
end
############# SECONDARY LM SENSE, UPPER REPS, auto-called by lmsense
#$rgmethods.push("lmsense2") unless $rgmethods.include?("lmsense2")
def lmsense2(lookfor)
	respond "LMSENSE 2 activated, #{lookfor.join(', ')} task"
	fput "lm sense"
	s = false
	r = false
	spells = []
	spells = XMLData.active_spells.keys
	x = matchwait /you determine/i
	x2 = x.gsub("you determine","I determined")
	x3 = x2.gsub("you are","I am")
	x4 = x3.gsub("you can tell","I can tell")
	x5 = x4.gsub("around you","around me")
	s = matchwait( "Additionally|Unfortunately|Under the current conditions")
	if s =~ /Under the current conditions/
		r = s
		s = false
	else
		r = false
		r = matchtimeout(1, "Under the current conditions")
	end
	if r then r2 = r.gsub("you think you could","I think I can") 	end
	spells.push("crystal amulet") if s =~ /voices in your head/
	hacked_line = []
	if lookfor.include?('lock')
		$lock_list.each{|word, val|
			if r2 =~ /#{word}/
				hacked_line.push(word)
				break
			end
		}
	end
	if lookfor.include?('trap')
		$trap_list.each{|word|
			if r2 =~ /#{word}/
				hacked_line.push(word)
				break
			end
		}
	end
	if lookfor.include?('room')
		hacked_line.push(x5)
		roomline = x5
	end
	if lookfor.include?('spells')
		hacked_line.push(spells.uniq.join(', '))
	end
	clear
	fput "say #{hacked_line.join(', ')}"
	y = matchwait /[^\s]+\s(says|exclaims),/
	z = false
	z = matchtimeout(1, "repetition|complete")
	spells = []
	if z =~ /repetition/i
		wtf = matchwait /[^\s]+\s(says|exclaims),/
		vars = []
		if wtf =~ /best trap/ then vars.push('trap') end
		if wtf =~ /best lock/ then vars.push 'lock' end
		if wtf =~ /room conditions/ then vars.push 'room' end
		if wtf =~ /spell/ then vars.push 'spells' end
		if wtf =~ /Try again/ && vars.empty?
			return(lmsense2(lookfor))
		else
			return(lmsense2(vars))
		end
	end
	return(lmsense2(lookfor)) unless z =~ /complete/
	fput "set showspell off" if $gld_spell_reset
	$gld_spell_reset = nil
	fput "out"
	mymove $rgadmin
end
def calicali(firstrun = false)
	$calirep = false
	table = GameObj.loot.find{|thing| thing.noun =~ /table/}
	fput "look on ##{table.id}"
	calipers = table.contents.find{|cali| cali.noun =~ /calipers/i}
	box = table.contents.find{|thing| thing.noun =~ /box/i}
	lockpick = table.contents.find{|thing| thing.noun =~ /lockpick/}
	fput "get ##{calipers.id}"
	unless firstrun
		fput "lm cali my cali"
		waitrt?
	end
	fput "lm measure ##{box.id}"
	waitrt?
	fput "put my cali on table"
	fput "_drag ##{lockpick.id} right"
	fput "picklock ##{box.id}"
	waitrt?
	sleep 1
	fput "get ##{calipers.id}"
	fput "lm cali my cali"
	sleep 1
	$calirep = true if checkrt > 0
	waitrt?
	sleep 1
	if $calirep
		fput "give cali to ##{GameObj.npcs.find{|npc| npc.name =~ /footpad/i}.id}"
		fput "put lockpick on table"
		if get_task.find{|a, b, c| a =~ /Lock Mastery/i && c =~ /no/i}
			fput "put cali on table"
			fput "out"
			return
		end
	else
		waitrt?
		echo "YOU PROBABLY FUMBLED THE LOCK PICK ATTEMPT, RECOVERING, I HOPE"
		fput "put lock on table"
		fput "put cali on table"
	end
	return(calicali(true))
end
def pickgame(inmaster = false)
	pickinglore = true
	if Spell[403].known? && Spell[403].affordable? && !Spell[403].active? && checkmana > 10 && pickinglore
		Spell[403].cast until Spell[403].active?
		pickinglore = true
	end
	unless inmaster
		go_guild
		rg_hands_checker
		mymove $rgfootpads
	end
	x = false
	until x
		fput "ask ##{GameObj.npcs.find{|npc| npc.name =~ /Master Footpad/}.id} about train lock"
		x = matchtimeout(30, "pulls you aside for some instruction")
	end
	matchwait /and just nod to me when yer/
	fput "nod"
	table = GameObj.loot.find{|thing| thing.noun =~ /table/i}
	fput "look on ##{table.id}"
	matchtimeout(3, "the wooden table")
	boxes = table.contents.find_all{|box| box.noun =~ /box/i}
	veniom = table.contents.find{|lock| lock.name =~ /veniom/i}
	vaalin = table.contents.find{|lock| lock.name =~ /vaalin/i}
	boxes.each{|box|
		trapped = false
		clear
		fput "disarm ##{box.id}"
		trap = matchwait /try to disarm|discover no traps|\.wait/i
		waitrt?
		redo if  trap =~ /wait/
		trapped = true if trap =~ /try to disarm/
		while trapped
			Spell[404].cast if Spell[404].known? && Spell[404].affordable? && pickinglore
			fput "disarm ##{box.id}"
			x = matchtimeout(5, "trap in your mind|are not able to disarm the trap|you have scored|Roundtime|\.\.\.wait")
			waitrt?
			trapped = false unless x =~ /trap in your mind|are not able to disarm the trap/
		end
		waitrt?
	}
	fput "_drag ##{veniom.id} right" until GameObj.right_hand.noun =~ /lockpick/i
	boxes.each{|box|
		Spell[403].cast until Spell[403].active? if Spell[403].known? && Spell[403].affordable? && !Spell[403].active?
		waitrt?
		clear
		fput "picklock ##{box.id}"
		lock = matchwait /\.wait|make a fumbling attempt|are not able to|lockpick gets stuck|\.\.\.CLICK|Roundtime|pick a lock on/i
		waitrt?
		redo if lock =~ /\.wait/
		if lock =~ /a fumbling/
			Spell[403].cast until Spell[403].active? if Spell[403].known? && Spell[403].affordable? && !Spell[403].active?
			waitrt?
			clear
			fput "picklock ##{box.id}"
			lock = matchwait /\.wait|make a fumbling attempt|are not able to|lockpick gets stuck|\.\.\.CLICK|Roundtime|pick a lock on/i
			redo if lock =~ /\.wait/
			waitrt?
		end
		break if lock =~ /pick a lock on/i
		unless lock =~ /CLICK/i
			fput "_drag ##{veniom.id} ##{table.id}" until GameObj.right_hand.name == "Empty"
			fput "_drag ##{vaalin.id} right"
			until lock =~ /CLICK|pick a lock on/i
				Spell[403].cast until Spell[403].active? if Spell[403].known? && Spell[403].affordable? && !Spell[403].active?
				waitrt?
				clear
				fput "picklock ##{box.id}"
				lock = matchwait /\.wait|make a fumbling attempt|are not able to|lockpick gets stuck|\.\.\.CLICK|Roundtime|pick a lock on/i
				redo if lock =~ /\.wait/
				break if lock =~ /pick a lock on/i
				waitrt?
			end
			unless GameObj.right_hand.name =~ /Empty/
				fput "_drag ##{vaalin.id} ##{table.id}" until GameObj.right_hand.name == "Empty"
				fput "_drag ##{veniom.id} right"
			end
		end
	}
	fput "_drag ##{veniom.id} ##{table.id}" unless GameObj.right_hand.name =~ /Empty/
	donewith = matchwait /Game|escorts you back/
	fput "out" if donewith =~ /Game/i
	fput "stop 404" if Spell[404].active?
	sleep 1
	return(pickgame(true)) if get_task.find{|a, b, c| a =~ /Lock Mastery/i && c !~ /no/i}
	respond "PICKGAME STALL??? " if Char.name =~ /Baswab/i
end
######################## LM MEASURE REPS, auto-called from lmsense
#$rgmethods.push("lmmeasure") unless $rgmethods.include?("lmmeasure")
def lmmeasure()
	echo "LM MEASURE"
	table = GameObj.loot.find{|thing| thing.noun == 'table'}.id
	fput "l on ##{table}"
	calipers = GameObj.loot.find{|thing| thing.noun == 'table'}.contents.find{|cali| cali.noun == 'calipers'}.id
	box = GameObj.loot.find{|thing| thing.noun == 'table'}.contents.find{|cali| cali.noun == 'box'}.id
	fput "_drag ##{calipers} left" unless GameObj.left_hand.noun == 'calipers'
	fput "lm measure ##{box}"
	lock_txt = matchwait /Measuring carefully/
	lock = $1 if lock_txt =~ /be (an?.*lock)/
	$lock_list.each{|word, val|
		echo "word: #{word}, val: #{val}"
		echo "lock variable inside locklist #{lock}"
		if word =~ /#{lock}/
			fput "say #{word}"
			break
		end
	}
	y = matchwait /[^\s]+\s(says|exclaims),/
	z = false
	z = matchtimeout(1, "repetition|complete")
	fput "_drag ##{calipers} ##{table}"
	if z =~ /complete/
		fput "out"
		return
	else
		lmmeasure
	end
end
def masterwedge
	mymove('bank')
	fput "depo all"
	fput "withdraw 5000 silver"
	go_guild
	until get_task.find{|a, b, c| a =~ /Lock Mastery/i && c =~ /no/i}
		mymove($rgworkshop)
		fput "go tool"
		fput "order 1"
		fput "buy"
		x = false
		x = matchtimeout(1, "But you don't have enough|attendant accepts your silvers")
		if x =~ /attendant accepts your silvers/
			makewedge
			fput "out"
			mymove $rgfootpads
			x = false
			until x
				fput "ask ##{GameObj.npcs.find{|npc| npc.name =~ /Master Footpad/}.id} about train lock"
				x = matchtimeout(30, "pulls you aside for some instruction")
			end
			matchwait /If you gots a wedge for me, hand it over/
			fput "give ##{GameObj.right_hand.id} to ##{GameObj.npcs.find{|npc| npc.name =~ /footpad/i}.id}"
			fput "stow right"
			fput "drop right" if GameObj.right_hand.noun =~ /wedge/i
			fput "out"
		else
			return(masterwedge)
		end
	end
end
def makewedge
	fput "glance"
	return unless GameObj.right_hand.noun =~ /block|wedge/i
	x = false
	until x =~ /wedge looks ready to polish/
		fput "carve ##{GameObj.right_hand.id}"
		x = matchtimeout(1, "wedge looks ready to polish")
		waitrt?
	end
	fput "rub ##{GameObj.right_hand.id}"
	waitrt?
end
def go_make_wedge
	mymove('bank')
	fput "depo all"
	fput "withdraw 500 silver"
	go_guild
	mymove($rgworkshop)
	fput "go tool"
	fput "order 1"
	fput "buy"
	x = false
	x = matchtimeout(1, "But you don't have enough|attendant accepts your silvers")
	if x =~ /attendant accepts your silvers/
		makewedge
		fput "out"
		stashright
	else
		return(go_make_wedge)
	end

end
def applocks
	conditions = ['broken', 'miserable', 'poor', 'damaged', 'neglected', 'good', 'excellent']
	precision = ['detrimental', 'ineffectual', 'very inaccurate', 'inaccurate', 'somewhat inaccurate', 'inefficient', 'unreliable', 'below average', 'average', 'above average', 'somewhat accurate', 'favorable', 'advantageous', 'accurate', 'highly accurate', 'excellent', 'incredible', 'unsurpassed']
	strength = ['flimsy', 'very weak', 'weak', 'below average strength', 'average strength', 'above average strength', 'strong', 'very strong', 'excellent strength', 'incredibly strong', 'astonishingly strong', 'unsurpassed strength']
	locklist = ['a primitive lock', 'a rudimentary lock', 'an extremely easy lock', 'a very easy lock', 'an easy lock', 'a very basic lock', 'a fairly easy lock', 'a simple lock', 'a fairly simple lock', 'a fairly plain lock', 'a moderately well-crafted lock', 'a well-crafted lock', 'a tricky lock', 'a somewhat difficult lock', 'a moderately difficult lock', 'a very well-crafted lock', 'a difficult lock', 'an extremely well-crafted lock', 'a very difficult lock', 'a fairly complicated lock', 'an intricate lock', 'an amazingly well-crafted lock', 'a very complex lock', 'an impressively complicated lock', 'an amazingly intricate lock', 'an extremely difficult lock', 'an extremely complex lock', 'a masterfully well-crafted lock', 'an amazingly complicated lock', 'an astoundingly complex lock', 'an incredibly intricate lock', 'an absurdly well-crafted lock', 'an exceedingly complex lock', 'an absurdly difficult lock', 'a masterfully intricate lock', 'an unbelievably complicated lock', 'an impossibly complex lock']
	thistime = []
	ranks = []
	pranks = []
	fput "look on table"
	GameObj.loot.find{|thing| thing.noun =~ /table/i}.contents.each{|lockpick|
		next if lockpick.id == $bestfuckinpick
		fput "_drag ##{lockpick.id} right" until GameObj.right_hand.id == lockpick.id
		fput "lm app ##{GameObj.right_hand.id}"
		result = matchwait /examine the .*? lockpick/
		cont = 0
		pcount = false
		scount = false
		difficulty = false
		conditions.each{|condition|
			break if result =~ /#{condition}/i
			cont += 1
		}
		if result =~ /could probably handle/
			difficulty = 0
			locklist.each{|lock|
				if result =~ /#{lock}/
					pranks.push(difficulty)
					break
				end
				difficulty += 1
			}
		end
		if result =~ /level of precision/i
			pcount = 0
			precision.each{|qual|
				if result =~ /an?\s#{qual}\slevel/i
					pranks.push(pcount)
					break
				end
				pcount += 1
			}
		end
		if result =~ /and (is|has)/
			scount = 0
			strength.each{|str|
				break if result =~ /and (is|has)\s#{str}\./
				scount += 1
			}
		end
		divisor = false
		if result =~ /As far as you can tell|Judging by the tip/i
			if result =~ /never been repaired/
				divisora = 0
				divisor = 0.5
			elsif result =~ /repaired about (\d+) time/
				div = $1
				divisor = div.to_i
				divisora = div.to_i
			end
		end
		if difficulty
			score = [(cont * (difficulty + pcount + scount - divisora)), 0].max
		elsif divisor
			score = [0, cont * (2 * pcount + scount - divisora)].max
# BAD LINE			#score = ((2.0 * cont * pcount) + (cont * scount)) / divisor.to_f
		elsif scount
			score = cont * (2 * pcount + scount)
		elsif pcount
			score = cont * pcount
		else
			score = cont
		end
		score = [10000, score].min
		respond "Grandmaster Gibreficul determined the score for that lockpick is  #{score}"
		ranks.push(score)
		thistime.push([score, GameObj.right_hand.id])
		waitrt?
		fput "_drag ##{GameObj.right_hand.id} ##{GameObj.loot.find{|thing| thing.noun =~ /table/i}.id}"
	}
	thistime.each{|bla, pick|
		next if bla.to_i < ranks.max
		fput "get ##{pick}"
		wait_until{GameObj.right_hand.id == pick}
		fput "give ##{GameObj.right_hand.id} to ##{GameObj.npcs.find{|npc| npc.name =~ /footpad/i}.id}"
		$bestfuckinpick = pick
		break
	}
	matchtimeout(3, "with a nod before looking over")
	return(applocks) if get_task.find{|a, b, c| a =~ /Lock Mastery/i && c !~ /no/i}
	fput "out"
end
def breakpicks(rerun = false, totruns = 0)
	fput "out"
	unless rerun
		empty_hands
		mymove 'bank'
		fput "with 10000 silver"
		mymove $rgtownsmith
		fput "order #{$rgbuypick}"
		fput "buy"
		sleep 1
		wait_until{GameObj.right_hand.name !~ /Empty/i}
	end
	go_guild if $rglockroom == 17873 || $rglockroom == 17829
	mymove $rglockroom
	fput "go gate" if $rglockroom == 2303
	x = false
	until x =~ /broken/i
		fput "picklock #{$rghardlock}"
		x = matchtimeout(20, "are not able to|lockpick gets stuck|\.\.\.CLICK|not appear to be locked|using a broken|Roundtime")
		waitrt?
		sleep 30 if x =~ /click/i
	end
	go_guild unless $rglockroom == 17873 || $rglockroom == 17829
	mymove $rgworkshop
	fput "go toolbench"
	fput "order #{$rgwirenum}"
	fput "buy"
	fput "lm rep lock"
	sleep 1
	waitrt?
	fput "out"
	mymove $rgfootpads
	x = false
	until x
		fput "ask ##{GameObj.npcs.find{|npc| npc.name =~ /Master Footpad/}.id} about train lock"
		x = matchtimeout(30, "pulls you aside for some instruction")
	end
	matchwait /gots lockpicks/
	fput "give ##{GameObj.right_hand.id} to ##{GameObj.npcs.find{|npc| npc.name =~ /footpad/i}.id}"
	sleep 3
	if get_task.find{|a, b, c|;a =~ /lock/i}[-1] =~ /no/
		fput "drop ##{GameObj.right_hand.id}"
		fput "out"
		mymove "bank"
		fput "depo all"
		fput "with 10"
	elsif get_task.find{|a, b, c|;a =~ /lock/i}[-1] =~ /\d/
		totruns += 1
		return(breakpicks(true, totruns)) if totruns < 6
		fput "drop ##{GameObj.right_hand.id}"
		return(breakpicks)
	end
end
def relock(rerun = false)
	fput "look on table"
	box = GameObj.loot.find{|it| it.noun =~ /box/i}.id
	unless rerun
		$container.flatten.each{|cont|
			next if Char.name =~ /Baswab/ && GameObj.inv.find{|sack| sack.id == cont && sack.noun == 'sack'}
			$rgpickcont = cont
			$rgfoundpick = GameObj.inv.find{|sack| sack.id.to_i == cont.to_i}.contents.find{|pick| pick.noun =~ /lockpick/ && pick.name =~ /veniom|invar|golvern|kelyn|vaalin/} || false
			break if $rgfoundpick
		}
		unless $rgfoundpick
			respond "Rogue Guild Grandmaster Gibreficul just searched for an adaquate lockpick and failed."
			respond "Please find yourself a veniom or better lockpick and try again."
			respond "Grguild is EXITING, if you want to ignore LFM in the future, set $do_lfm to false."
			respond "Failing to do so could result in a future run of grguild being an angry endless loop."
			exit
		end
		fput "get ##{$rgfoundpick.id}"
		wait_until{GameObj.left_hand.noun == 'lockpick' || GameObj.right_hand.noun == 'lockpick'}
	end
	fput "_drag ##{GameObj.loot.find{|box| box.noun =~ /box/i}.id} right"
	result = false
	until result
		fput "lm relock ##{GameObj.right_hand.id}"
		result = matchtimeout(10, 'Then...CLICK!  It locks!')
		waitrt?
	end
	fput "give ##{GameObj.right_hand.id} to ##{GameObj.npcs.find{|npc| npc.name =~ /Master Footpad/i}.id}"
	wait_until{GameObj.right_hand.name =~ /Empty/i}
	sleep 1
	return(relock(true)) if get_task.find{|a, b, c| a =~ /lock/i && c !~ /no/i}
	fput "_drag ##{GameObj.left_hand.id} ##{$rgpickcont}"
	fput "out"
end
def claspconts(rerun = false)
	#plain clasp, 18, 200 coins.
	unless rerun
		fput "out"
		if $guildname =~ /Ta'Vaalor/i
			mymove $rgexit[0]
			fput "go chute"
		end
		mymove "bank"
		fput "depo all"
		fput "with 10000 silver"
		go_guild
	end
	mymove $rgshop
	fput "order"
	line = matchwait /a plain sack/i
	if line =~ /\d+.*?(\d+).*?a plain sack/
		ordernum = $1
	end
	fput "order #{ordernum}"
	fput "buy"
	mymove $rgworkshop
	fput "go toolbench"
	fput "lm clasp ##{GameObj.right_hand.id}"
	matchtimeout(30, "you carefully put a hole")
	waitrt?
	multifput("order 18", "buy", "lm clasp ##{GameObj.right_hand.id}", "lm clasp ##{GameObj.right_hand.id}")
	matchtimeout(30, "secure it in place")
	waitrt?
	fput "out"
	mymove $rgfootpads
	x = false
	until x
		fput "ask ##{GameObj.npcs.find{|npc| npc.name =~ /Master Footpad/}.id} about train lock"
		x = matchtimeout(30, "pulls you aside for some instruction")
	end
	matchwait /got some containers for me/
	fput "give ##{GameObj.right_hand.id} to ##{GameObj.npcs.find{|npc| npc.name =~ /Master Footpad/i}.id}"
	matchtimeout(5, "Master Footpad.*accepts the")
	fput "drop ##{GameObj.right_hand.id}"
	fput "out"
 	return(claspconts(true)) if get_task.find{|a, b, c| a =~ /lock/i && c !~ /no/i}
 	mymove 'bank'
 	fput "depo all"
 	fput "with 10"
end
def claspconts2(rerun = false)
	unless rerun
		rg_hands_checker
		if $guildname =~ /Ta'Vaalor/i
			mymove $rgexit[0]
			fput "go chute"
		end
		mymove "bank"
		fput "depo all"
		fput "with 10000 silver"
		go_guild
	end
	mymove $rgshop
	fput "order"
	line = matchwait /a plain sack/i
	if line =~ /\d+.*?(\d+).*?a plain sack/
		ordernum = $1
	end
	fput "order #{ordernum}"
	fput "buy"
	mymove $rgworkshop
	fput "go toolbench"
	fput "lm clasp ##{GameObj.right_hand.id}"
	matchtimeout(30, "you carefully put a hole")
	waitrt?
	multifput("order 18", "buy", "lm clasp ##{GameObj.right_hand.id}", "lm clasp ##{GameObj.right_hand.id}")
	matchtimeout(30, "secure it in place")
	waitrt?
	fput "drop right"
	fput "out"
	return(claspconts2(true)) if get_task.find{|a, b, c| a =~ /lock/i && c !~ /no/i}
 	mymove 'bank'
 	fput "depo all"
 	fput "with 10"
end
def makelocks(rerun = false)
	unless rerun
		fput "out"
		rg_hands_checker
		if $guildname =~ /Ta'Vaalor/i
			mymove $rgexit[0]
			fput "go chute"
		end
		mymove "bank"
		fput "depo all"
		fput "with 10000 silver"
		go_guild
	end
	mymove $rgworkshop
	fput "go tool"
	fput "lm lock create -10"
	sleep 1
	fput "lm lock create -10"
	sleep 1
	waitrt?
	fput "out"
	mymove $rgfootpads
	x = false
	until x
		fput "ask ##{GameObj.npcs.find{|npc| npc.name =~ /Master Footpad/}.id} about train lock"
		x = matchtimeout(30, "pulls you aside for some instruction")
	end
	matchwait /Got some lock assemblies for me/i
	fput "give ##{GameObj.right_hand.id} to ##{GameObj.npcs.find{|npc| npc.name =~ /Master Footpad/i}.id}"
	fput "out"
	mymove $rgworkshop
	2.times{fput "give attendant"}
	return (makelocks(true)) if get_task.find{|a, b, c| a =~ /lock/i && c !~ /no/i}
	if $guildname =~ /Ta'Vaalor/i
		mymove $rgexit[0]
		fput "go chute"
	end
	mymove "bank"
	fput "depo all"
	fput "with 10"
end
def makelocks2(rerun = false)
	unless rerun
		fput "out" if checkpaths.include? 'out'
		rg_hands_checker
		if $guildname =~ /Ta'Vaalor/i
			mymove $rgexit[0]
			fput "go chute"
		end
		reps = get_task.find{|a, b, c| a =~ /lock/i}[-1]
		mymove "bank"
		fput "depo all"
		fput "with #{reps.to_i * 20000 + 10} silver"
		go_guild
	end
	mymove $rgworkshop
	fput "go tool"
	fput "lm lock create -#{((Skills.to_bonus(Skills.pickinglocks) + Stats.dex[1]) * 2.2).floor / 100 * 100}"
	sleep 1
	fput "lm lock create -#{((Skills.to_bonus(Skills.pickinglocks) + Stats.dex[1]) * 2.2).floor / 100 * 100}"
	sleep 1
	waitrt?
	fput "out"
	2.times{fput "give attendant"}
	return (makelocks2(true)) if get_task.find{|a, b, c| a =~ /lock/i && c !~ /no/i}
	if $guildname =~ /Ta'Vaalor/i
		mymove $rgexit[0]
		fput "go chute"
	end
	mymove "bank"
	fput "depo all"
	fput "with 10"
end
def cutkeys(rerun = false)
	unless rerun
		fput "out" if checkpaths.include? 'out'
		rg_hands_checker
		if $guildname =~ /Ta'Vaalor/i
			mymove $rgexit[0]
			fput "go chute"
		end
		reps = get_task.find{|a, b, c| a =~ /lock/i}[-1].to_i
		mymove "bank"
		fput "depo all"
		fput "with #{reps * 500 + 10} silver"
		go_guild
	end
	mymove $rgworkshop
	fput "go tool"
	fput "lm lock create -10"
	fput "lm lock create -10"
	waitrt?
	reps.times{
		fput "order 25"
		fput "buy"
		fput "lm cut assembly"
		waitrt?
		fput "drop key"
	}
	fput "out"
	2.times{fput "give ass to attend"}
	if $guildname =~ /Ta'Vaalor/i
		mymove $rgexit[0]
		fput "go chute"
	end
	mymove "bank"
	fput "depo all"
	fput "with 10"
end
def trapreps(x)
	fput "out"
	if x =~ /care what kind they are, but they'd better be fresh/
		respond "You are tasked to extract any trap, setting all vars to true"
		$rgfindjaws = true
		$rgfindacid = true
		$rgfindmagic = true
		$rgfindcloud = true
	elsif x =~ /yank out poison needles/i
		respond "YOU HAVE NEEDLES AND JAWS REPS"
		respond "applicable data is: #{x}"
		$rgfindjaws = true
	elsif x =~ /springs left in the box and the other's stuck in the tumblers to melt 'em/
		respond "YOU HAVE ACID VIALS TO EXTRACT"
		respond "APPLICABLE DATA IS: #{x}"
		$rgfindacid = true
		$rgfindjaws = true
	elsif x =~ /one kind sucks the box up, and the other emits an elemental wave to pummel the area/
		respond "YOU HAVE SPHERE AND DARK CRYSTALS TO EXTRACT"
		$rgfindjaws = true
		$rgfindacid = true
		$rgfindmagic = true
	elsif x =~ /throw burning goo on you and the shocking cloud ones/
		$rgfindjaws = true
		$rgfindacid = true
		$rgfindmagic = true
		$rgfindcloud = true
	else
		$rgfindjaws = true
		$rgfindacid = true
		$rgfindmagic = true
		$rgfindcloud = true
		respond "grguild trapreps, UNDNER CONSTRUCTION, assuming"
		respond "********************************"
		respond "applicable data is:  #{x}"
	end
	respond "UNFORTUNATELY, I have set $do_lfm to false at this point."
	respond "You can reset that manually with ;e $do_lfm = true or by rerunning grgvars"
	respond "NO LOGIC WITHIN grguild FOR THIS TASK."
	$do_lfm = false
end
def makepicks(rerun = false)
	fput "out"
	unless rerun
		reps = get_task.find{|a, b, c| a =~ /lock/i}[-1].to_i
		mymove "bank"
		put "depo all"
		put "withdraw #{80 * (reps + 2)} silver"
		go_guild
		rg_hands_checker
	end
	mymove $rgworkshop
	empty_hands
	fput "go tool"
	madepicks = []
	reps.times{
		fput "order 26"
		fput "buy"
		sleep 1
		if GameObj.right_hand.name =~ /Empty/i
			echo "SCRIPT THINKS YOU ARE BROKE, COULD BE A LOOP HERE IF YOU ARE."
			return(makepicks)
		end
		result = false
		until result || (GameObj.right_hand.name =~ /Empty/i && GameObj.left_hand.name =~ /Empty/i)
			fput "LM CREATE"
			result = matchtimeout(10, "lockpick from the toolbench")
			#exceptional quality, fairly average quality, quality is far below average
			waitrt?
		end
		if GameObj.left_hand.noun =~ /lockpick/i
			madepicks.push(GameObj.left_hand.id)
			fput "stow left"
			$container.each{|cont|
				break if GameObj.left_hand.name =~ /Empty/i
				fput "_drag ##{GameObj.left_hand.id} ##{cont}"
			}
		end
	}
	fput "out"
	fput "out"
	fput "out"
	sleep 5
	mymove $rgfootpads
	x = false
	until x
		fput "ask ##{GameObj.npcs.find{|npc| npc.name =~ /Master Footpad/}.id} about train lock"
		x = matchtimeout(30, "pulls you aside for some instruction")
	end
	matchwait /I assume you've got some lockpicks/
	madepicks.each{|lockpick|
		fput "_drag ##{lockpick} right"
		fput "give ##{GameObj.right_hand.id} to ##{GameObj.npcs.find{|npc| npc.name =~ /Master Footpad/i}.id}"
		if GameObj.right_hand.noun =~ /lockpick/i
			fput "stow right"
			$container.each{|cont|
				break if GameObj.right_hand.name =~ /Empty/i
				fput "_drag ##{GameObj.right_hand.id} ##{cont}"
			}
		end
	}
	fput "out"
	madepicks.each{|lockpick|
		fput "_drag ##{lockpick} drop"
	}
	return(makepicks(true)) if get_task.find{|a, b, c| a =~ /lock/i && c !~ /no/i}
end
def lmcustom(rerun = false)
	fput "out"
	unless rerun
		reps = get_task.find{|a, b, c| a =~ /lock/i}[-1].to_i
		mymove "bank"
		put "depo all"
		put "withdraw #{580 * (reps + 2)} silver"
		go_guild
		rg_hands_checker
	end
	mymove $rgworkshop
	empty_hands
	fput "go tool"
	madepicks = []
	reps.times{
		fput "order 26"
		fput "buy"
		sleep 1
		if GameObj.right_hand.name =~ /Empty/i
			echo "SCRIPT THINKS YOU ARE BROKE, COULD BE A LOOP HERE IF YOU ARE."
			return(lmcustom)
		end
		result = false
		until result || (GameObj.right_hand.name =~ /Empty/i && GameObj.left_hand.name =~ /Empty/i)
			fput "LM CREATE"
			result = matchtimeout(10, "lockpick from the toolbench")
			#exceptional quality, fairly average quality, quality is far below average
			waitrt?
		end
		fput "swap" if GameObj.left_hand.noun =~ /lockpick/i
		2.times{fput "lm custom dye red"}
		waitrt?
		madepicks.push(GameObj.right_hand.id)
		fput "stow right"
		$container.each{|cont|
			break if GameObj.right_hand.name =~ /Empty/i
			fput "_drag ##{GameObj.right_hand.id} ##{cont}"
		}
	}
	fput "out"
	mymove $rgfootpads
	x = false
	until x
		fput "ask ##{GameObj.npcs.find{|npc| npc.name =~ /Master Footpad/}.id} about train lock"
		x = matchtimeout(30, "pulls you aside for some instruction")
	end
	matchwait /I assume you've got some lockpicks/
	madepicks.each{|lockpick|
		fput "_drag ##{lockpick} right"
		fput "give ##{GameObj.right_hand.id} to ##{GameObj.npcs.find{|npc| npc.name =~ /Master Footpad/i}.id}"
		if GameObj.right_hand.noun =~ /lockpick/i
			fput "stow right"
			$container.each{|cont|
				break if GameObj.right_hand.name =~ /Empty/i
				fput "_drag ##{GameObj.right_hand.id} ##{cont}"
			}
		end
	}
	fput "out"
	madepicks.each{|lockpick|
		fput "_drag ##{lockpick} drop"
	}
	return(lmcustom) if get_task.find{|a, b, c| a =~ /lock/i && c !~ /no/i}
end
def lmcustom2(rerun = false)
	fput "out" if checkpaths.include?('out')
	unless rerun
		reps = get_task.find{|a, b, c| a =~ /lock/i}[-1].to_i
		mymove "bank"
		put "depo all"
		put "withdraw #{80 + 500 * (reps + 2)} silver"
		go_guild
		rg_hands_checker
	end
	mymove $rgworkshop
	empty_hands
	fput "go tool"
	fput "order 26"
	fput "buy"
	sleep 1
	if GameObj.right_hand.name =~ /Empty/i
		echo "SCRIPT THINKS YOU ARE BROKE, COULD BE A LOOP HERE IF YOU ARE."
		return(lmcustom2)
	end
	result = false
	until result || (GameObj.right_hand.name !~ /Empty/i && GameObj.left_hand.name !~ /Empty/i)
		fput "LM CREATE"
		result = matchtimeout(10, "lockpick from the toolbench")
		waitrt?
	end
	until get_task.find{|a, b, c| a =~ /lock/i && c =~ /no/i}
			echo "UNTIL, LMCUSTOM2"
			fput "swap" if GameObj.left_hand.noun =~ /lockpick/i
			2.times{fput "lm custom dye red";sleep 1}
			waitrt?
			2.times{fput "lm custom clean";sleep 1}
			waitrt?
	end
	fput "out"
	return(lmcustom2) if get_task.find{|a, b, c| a =~ /lock/i && c !~ /no/i}
end
############### STUNMANEUVERS
##################### STUNMAN FIRST RANK
$rgmethods.push('stunman_first_rank') unless $rgmethods.include?('stunman_first_rank')
def stunman_first_rank(inmaster = false)
	unless inmaster
		go_guild
		rg_hands_checker
		mymove $rgfootpads
		fput "stance off" unless percentstance <= 20
		pause_script "stand" if running? 'stand'
		x = false
		until x
			fput "ask ##{GameObj.npcs.find{|npc| npc.name =~ /Master Footpad/}.id} about train stun"
			x = matchtimeout(30, "pulls you aside for some instruction")
		end
		matchwait /is to dodge at least/
		inmaster = true
	end

end
##################### STUNMAN ARROWS

$rgmethods.push("arrows") unless $rgmethods.include?("arrows")
def arrows(newdir = "lean left", inmaster = false)
	unless inmaster
		go_guild
		rg_hands_checker
		mymove $rgfootpads
		fput "stance off" unless percentstance <= 20
		pause_script "stand" if running? 'stand'
		x = false
		until x
			fput "ask ##{GameObj.npcs.find{|npc| npc.name =~ /Master Footpad/}.id} about train stun"
			x = matchtimeout(30, "pulls you aside for some instruction")
		end
		matchwait /is to dodge at least/
		inmaster = true
	end
	directions = ["lean left","lean right","jump","duck"]
	if newdir
		newdir = (directions - [newdir].flatten)[rand(directions.length - 1)]
	else
		newdir = directions[rand(directions.length)]
	end
	wait_rt
	fput "stand" until standing?
	wait_rt
	fput newdir
	x = matchwait /You won this round|have to dodge|\.wait/
	if x =~ /won this/
		y = matchwait /You have (\d+) repetition|completed/
		if y =~ /completed/i
			fput "out"
			mymove $rgadmin
		else
			fput "out"
			arrows(newdir)
		end
	else
		arrows(newdir, true)
	end
end
################# SLAPPERS
$rgmethods.push("slappers") unless $rgmethods.include?("slappers")
def slappers(newdir = false, inmaster = false)
	unless inmaster
		pause_script 'monitor'
		go_guild
		rg_hands_checker
		mymove $rgfootpads
		fput "stance off" unless percentstance <= 20
		pause_script "stand" if running? 'stand'
		x = false
		until x
			fput "ask ##{GameObj.npcs.find{|npc| npc.name =~ /Master Footpad/}.id} about train stun"
			x = matchtimeout(30, "pulls you aside for some instruction")
		end
		matchwait /just put your hands on mine/
		inmaster = true
	end
	wait_rt
	fput "stand" until standing?
	directions = ["duck","slap","stop"]
	newdir = directions[rand(directions.length)]
	wait_rt
	fput newdir
	x = matchwait /[Pp]oint|looks as sheepish as you|both simultaneously slap each other|neither of you get points|escorts you back/i
	if x =~ /escorts you/i
		return(mymove $rgadmin)
	end
	wait_rt
	fput 'stand' until standing?
	wait_rt
	slappers(false, inmaster)
	unpause_script 'monitor'
end
################ STUN MASTERS
def check_for_shield
	if GameObj.inv.find{|item| ['aegis', 'buckler', 'greatshield', 'mantlet', 'parma', 'pavis', 'scutum', 'shield', 'targe'].include?(item.noun)}
		echo "SHIELD FOUND"
		fput " ready shield ##{GameObj.inv.find{|item| ['aegis', 'buckler', 'greatshield', 'mantlet', 'parma', 'pavis', 'scutum', 'shield', 'targe'].include?(item.noun)}.id}"
		return(true)
	else
		fput "ready shield list"
		x = matchtimeout(3, "No valid shields were found in your inventory")
		if x =~ /no valid shields/i
			echo "YOU HAVE NO SHIELD"
			mymove "bank"
			fput "with #{$rgshieldcost} silver"
			mymove $rgshieldroom
			fput "order #{$rgshieldnum}"
			fput "buy"
			fput "store shield"
			mymove "bank"
			fput "depo all"
			return(stunmasters)
		else
			fput "ready shield"
			if GameObj.left_hand.name !~ /empty/i
				fput "ready shield ##{GameObj.left_hand.id}"
			else
				x = matchtimeout(3, /Could not find|do not have a default shield set|No valid shields were found/)
				if x =~ /could not find/i
					fput "ready shield clear"
					return(check_for_shield)
				else
					echo " WHAT THE FUCK"
				end
			end
		end
		echo "EXITING"
		exit
	end
end
def check_for_weapon
	$gweaps ||= ["achlais", "adze", "angon", "awl\-pike", "axe", "backsword", "baculus", "badelaire", "balestarius", "breastplate","chain", "ball\-and\-chain", "ball", "balta", "bardiche", "baselard", "battle\-axe", "battlesword", "bidenhander", "bilbo", "bill", "binnol", "bisacuta", "blackjack", "bodkin", "bola", "^bow$", "brandestoc", "braquemar", "broadsword", "bulawa", "bullwhip", "cat\-o'\-nine\-tails", "cateia", "cestus", "chakram", "chereb", "chest\-ripper", "cinquedea", "claidhmore", "claw", "cleaver", "club", "colichemarde", "contus", "craquemarte", "croc", "crook", "crosier", "crossbow", "crowbill", "cudgel", "cutlass", "dagger", "dart", "dhara", "dirk", "discus", "doloire", "dubh", "epee", "espadon", "estoc", "falarica", "falcastra", "falchion", "falx", "fang", "fauchard", "fist\-scythe", "flail", "flamberge", "fleuret", "flyssa", "foil", "fork", "framea", "francisca", "fuscina", "gaesum", "gauche", "gauntlet\-sword", "gladius", "glaive", "godendag", "goliah", "goupillon", "greataxe", "greatsword", "guisarme", "halberd", "half\-moon", "hammer of kai", "hammer", "handaxe", "harpoon", "hatchet", "hippe", "hook\-knife", "hoolurge", "jackblade", "jaculum", "javelin", "jeddart\-axe", "jitte", "kai", "kama", "kaskara", "katana", "katar", "katzbalger", "kheten", "khopesh", "kilij", "knife", "knuckle\-blade", "knuckle\-duster", "korseke", "kozuka", "kris", "lance", "lisan", "longbow", "longsword", "mace", "machera", "machete", "magari\-yari", "mail", "manople", "massuelle", "mattina", "mattock", "maul", "misericord", "^moon$", "nagimaki", "naginata", "^net$", "oncin", "paingrip", "palache", "parazonium", "partisan", "pavade", "pelta", "periperiu", "pernat", "^pick", "pike", "pill", "pilum", "poignard", "pugio", "quadrelle", "quoit", "ranseur", "rapier", "razorpaw", "runestaff", "runka", "sabar", "sabre", "^sai$", "^sap$", "sapara", "sarissa", "scepter", "schiavona", "schlager", "scimitar", "scorpion", "scramasax", "scythe", "seax", "shail", "shillelagh", "sica", "sledgehammer", "spadroon", "sparte", "spatha", "spear", "spetum", "spiculum", "spontoon", "sprinkler", "staff", "^star$", "^stick$", "stiletto", "sudis", "sword", "taavish", "tabar", "tails", "takouba", "tambara", "tanto", "taper", "tetsubo", "tock", "tocke", "tongue", "toporok", "trident", "troll\-claw", "truncheon", "tuck", "verdun", "voulge", "wakizashi", "waraxe", "whip", "whip\-blade", "xiphos", "yataghan", "yierka\-spur", "yoribo", "zinnor", "zweihander"]
	fput "stunman weapon"
	result = matchtimeout(3, "Could not find", "You remove", "You're not stunned")
	return(true) if result =~ /remove|You're not/

end
$rgmethods.push("stunmasters") unless $rgmethods.include?("stunmasters")
def stunmasters()
	pause_script 'monitor'
	go_guild
	mymove $rgfootpads
	x = false
	until x
		fput "ask ##{GameObj.npcs.find{|npc| npc.name =~ /Master Footpad/}.id} about train stun"
		x = matchtimeout(30, "pulls you aside for some instruction")
	end
	rg_hands_checker
	fput "stance off" unless percentstance <= 20
	taskme = matchwait /shield back into|sword back into|reach down and pick up a small brick|knees and then trembles to a standing position|show you how STANCE(1|2) is done|suddenly launches an attack and swings right for you/
	if taskme =~ /shield/
		echo "SHIELD TASK"
		task = 'shield'
	elsif taskme =~ /sword/
		echo "WEAPON TASK"
		task = 'weapon'
	elsif taskme =~ /down and pick up a small brick/
		echo "STUNMAN GET TASK"
		task = 'get lockpick'
	elsif taskme =~ /knees and then trembles to a standing position/
		echo "STUNMAN STAND TASK"
		task = 'stand'
	elsif taskme =~ /show you how STANCE1 is done/
		echo "STUNMAN STANCE1 TASK"
		task = 'stance1'
	elsif taskme =~ /suddenly launches an attack and swings right for you/
		echo "STUNMAN ATTACK TASK"
		task = 'attack'
	elsif taskme =~ /show you how STANCE2 is done/
		echo "STUNMAN STANCE2 TASK"
		task = 'stance2'
	end
	stamcheck = 15
	stamcheck -= 7 if task =~ /weapon|shield/
	stamcheck -= 5 if task =~ /get/
	stamcheck -= 3 if task =~ /stand|stance1/i
	matchtimeout(15,  /NOD to begin, or UNSTUN/)
	if task == 'shield'
		wait_until{check_for_shield}
		echo "NEXT"
	end
	if task == 'weapon'
		wait_until{check_for_weapon}
		echo "NEXT"
	end
	loop{
		fput "stance off" unless percentstance < 20
		wait_until("Waiting on stamina"){checkstamina >= (stamcheck / 2).round}
		fput "nod"
		wait_until("Waiting to be stunned"){stunned?}
		respond "Rogue Guild Grandmaster Gibreficul knows what he's doing.  Pausing for higher success rate."
		clear
		sleep 20
		if task =~ /attack/i
			fput "stun attack ##{GameObj.npcs.find{|npc| npc.name =~ /Master Footpad/i}.id}"
		else
			fput "stun #{task}"
		end
		fput "unstun"
		wait_while("WAITING WHILE STUNNED"){stunned?}
		wait_rt
		sleep 1
		fput "store shield" if GameObj.left_hand.name !~ /empty/i && task == 'shield'
		fput "store weapon" if GameObj.right_hand.name !~ /empty/i && task == 'weapon'
		fput "stow right" if GameObj.right_hand.name !~ /empty/i unless task =~ /shield|weapon/i
		fput "stow left" if GameObj.left_hand.name !~ /empty/i unless task =~ /shield|weapon/i
		fput "stance off" unless percentstance(0)
		break if get_task.find{|skill, task2, reps| skill =~ /Stun Maneuvers/ && task2 =~ /visit the footpads for some lessons/ && reps =~ /no/i}
		echo "LOOPING"
	}
	fput "Stand" unless standing?
	fput "out"
	mymove $rgadmin
	unpause_script 'monitor'
end
############## SWEEP TASKS
################################ SWEEP MASTERS
$rgmethods.push("sweep_masters") unless $rgmethods.include?("sweep_masters")
def sweep_masters(inmaster = false)
	#echo "BETA, I KNOW IT PROBABLY IS BROKEN"
	unless inmaster
		go_guild
		mymove $rgfootpads
		x = false
		until x
			fput "ask ##{GameObj.npcs.find{|npc| npc.name =~ /Master Footpad/}.id} about train sweep"
			x = matchtimeout(30, "pulls you aside for some instruction")
		end
		return(sweep_masters(true))
	end
	x = matchwait /let me show/i
	if x =~ /let me show/
		multifput("stance off","gld stance off")
		loop{
			wait_until{stamina?(10)}
			wait_while{GameObj.npcs[-1].status != nil}
			fput "sweep ##{npcs[-1].id}"
			result = matchtimeout(1, "You crouch", "hasn't instructed you")
			if result =~ /hasn't instructed you/
				multifput("stance off","gld stance gua")
				y = false
				until y =~ /you try on me/
					echo "CHECK LOOP 2265"
					y = matchtimeout(10,  /Awright, now you try on me|Stand up, I'll show yas again/)
					until standing?
						waitrt?
						fput "stance off" unless percentstance < 20
						fput "stand"
						waitrt?
					end
					break unless y
					y = false
				end
				next
			elsif result =~ /You crouch/
				waitrt?
			else
				echo "BORK"
			end
			ttt = get_task
			if ttt.find{|a, b, c| a =~ /Sweep/ && c =~ /no/i}
				echo "DONE"
				waitrt?
				fput "gld stance off"
				fput "stance def"
				move "out"
				break
			else
				echo "YOU HAVE #{ttt.find{|a, b, c| a =~ /Sweep/}[-1]} reps left"
			end
		}
	end
end
def sweep_dummies(in_room = false)
	unless in_room
		go_guild
		mymove $rgdummy
		fput "go dumm"
	end
	result = false
	fput "look dummy"
	result = matchtimeout(1, /dummy is swinging|fallen off its post/)
	if result =~ /swinging/
		fput "push dumm"
	elsif result =~ /fallen off/
		fput "fix dummy"
		waitrt?
	end
	fput "Sweep dumm"
	waitrt?
	tasks = get_task.find{|a, b, c| a =~ /Sweep/}
	if tasks[-1] =~ /\d+/
		#echo "YOU HAVE #{tasks[-1]} reps to go"
		sweep_dummies(true)
	elsif tasks[-1] =~ /no/i
		echo "DONE"
		waitrt?
		move "out"
	end
end
#Stand up, I'll show yas again
#Awright, now you try on me
#Yidza splutters.  "Hmph!  Must not have cleaned da floors in here lately.  Awright, now you try on me."  Yidza readies herself.
############################### GAMBITS TASKS
################################ NONE SO FAR
def gambit_masters(inmaster = false)
	unless inmaster
		go_guild
		mymove $rgfootpads
		x = false
		until x
			fput "ask ##{GameObj.npcs.find{|npc| npc.name =~ /Master Footpad/}.id} about train gambit"
			x = matchtimeout(30, "pulls you aside for some instruction")
		end
		return(gambit_masters(true))
	end
	echo "EXITING"
	exit
end

#################### PARTNER TASKS ###################
##### CHEAPSHOTS STOMP SOMEONE ####
$rgmethods.push("stomp") unless $rgmethods.include?("stomp")
def stomp(partner = false)
	unless partner
		respond "YOU DIDN'T SPECIFY A PARTNER"
	end
	wait_until("waiting on partner"){GameObj.pcs.find{|pc| pc.noun =~ /#{partner}/i}}
	wait_until{checkstamina >= 5}
	fput "stance off" unless percentstance >= 10
	fput "stand" until standing?
	wait_rt
	fput "cheap foot ##{GameObj.pcs.find{|pc| pc.noun =~ /#{partner}/i}.id}"
	x = matchwait /repetition|complete|Roundtime|just fell for/
	if x =~ /repetition/
		wait_rt
		sleep 20
	elsif x =~ /complete/
		fput "say thank you, all done stompin"
		go_guild
		return
	else
		wait_rt
	end
	stomp partner
end
##### SWEEP AND GAMBITS TO COME AS I TRAIN IN THEM #####
###########################

############## AUTOMATION METHODS ###########

###############################################
########### THE FOLLOWING IS NOT MY CODE AT ALL #########
######### THE ENTIRE LOOPING PROCESS RELIES ON THIS #######
##### SHATTERED ROGUE DART PROVIDED THIS JUICY NUGGET #####
###### NONE OF THIS IS POSSIBLE WITHOUT THIS DONATION ######
################ CREDIT WHERE DUE #################
###############################################
$rgmethods.push("get_task") unless $rgmethods.include?("get_task")
def get_task
	$must_wedge = nil
	task = Hash.new
	done = false
	found = ""
	action = proc {|server_string|
		if server_string =~ /^You (are|need|currently have|have received)/ or server_string.strip.length == 0
#			task[found] = ["none"] if found and server_string =~ /not currently training/
			if server_string =~ /You are a Master of (.*?)\./
				task[$1] = ["mastered", "mastered"]
				nil
			elsif server_string =~ /month/i
				task['checkin'] = ['checkin'];nil
			elsif server_string =~ /inactive/
				task['inactive'] = ['inactive'];nil
			elsif found and server_string =~ /not currently training/
				task[found] = ["none"]
			else
				nil
			end
		elsif server_string =~ /You have earned enough/
			task[found] = ["promotion"]; nil
		elsif server_string =~ /You have (.+?) repetition/
			task[found] = [task[found][0], $1]; nil
		elsif server_string =~ /next rank/
			nil
		elsif server_string =~ /You have.*?the (.+?) skill/
			found = $1; nil
		elsif server_string =~ /The Training Administrator told you to (.+?)\./
			task[found] = [$1]; nil
		elsif server_string =~ /At least ([\d]+) more should have/
			$must_wedge = $1.to_i;nil
		elsif server_string =~ /you nor any training partners/
			$gld_norank = true
#			respond "NO TASK CREDIT ON NEXT SKILL"
			nil
		elsif server_string =~ /for additional commands./
			done = true; nil
		else
			server_string
		end
	}
	DownstreamHook.add('stunman_task', action)
#	$_SERVER_.puts "<c>gld\n"
	$_SERVER_.puts "gld"
	t=Time.now; wait_until {done or t+3<Time.now}
	DownstreamHook.remove('stunman_task')
	#task.inject([]) { |s,(sk,info)| s << ([sk] << info) }
	task.inject([]) { |s,(sk,info)| s << ([sk] + info) }
end

############## END VOODOO NINJA CODE #################

$rgmethods.push("smart_task") unless $rgmethods.include?("smart_task")
def smart_task(dothistask = false)
	grg_checkin if get_task.flatten.find{|thing| thing =~ /checkin/}
	grg_initiation if get_task.flatten.find{|thing| thing =~ /inactive/}
	mytasks = get_task
	dotaskcount = 0
	dotaskcount += 1 if $do_sweep
	dotaskcount += 1 if $do_subdue
	dotaskcount += 1 if $do_lfm
	dotaskcount += 1 if $do_cheapshots
	dotaskcount += 1 if $do_gambits
	dotaskcount += 1 if $do_stunmans
	if mytasks.empty? || mytasks.length < dotaskcount
		if $do_sweep && mytasks.find{|thing| !thing.include?('Sweep')}
			echo "WE NEED RANK 1 TASK IN SWEEP"
			go_admin
			fput "ask ##{GameObj.npcs.find{|npc| npc.name =~ /training/i}.id} about train sweep"
		end
		if $do_subdue && mytasks.find{|thing| !thing.include?('Subdue')}
			echo "WE NEED RANK 1 TASK IN SUBDUE"
			go_admin
			fput "ask ##{GameObj.npcs.find{|npc| npc.name =~ /training/i}.id} about train subdue"
		end
		if $do_lfm && mytasks.find{|thing| !thing.include?('Lock Mastery')}
			echo "WE NEED RANK 1 TASK IN LOCK MASTERY"
			go_admin
			fput "ask ##{GameObj.npcs.find{|npc| npc.name =~ /training/i}.id} about train lock"
		end
		if $do_cheapshots && mytasks.find{|thing| !thing.include?('Cheap Shot')}
			echo "WE NEED RANK 1 TASK IN CHEAPSHOTS"
			go_admin
			fput "ask ##{GameObj.npcs.find{|npc| npc.name =~ /training/i}.id} about train cheapshot"
		end
		if $do_gambits && mytasks.find{|thing| !thing.include?('Rogue Gambits')}
			echo "WE NEED RANK 1 TASK IN GAMBITS"
			go_admin
			fput "ask ##{GameObj.npcs.find{|npc| npc.name =~ /training/i}.id} about train gambit"
		end
		if $do_stunmans && mytasks.find{|thing| !thing.include?('Stun Maneuvers')}
			echo "WE NEED RANK 1 TASK IN STUNMANS"
			go_admin
			fput "ask ##{GameObj.npcs.find{|npc| npc.name =~ /training/i}.id} about train stun"
		end
		return(smart_task)
	end
	echo "EMPTY SHIT" if mytasks.empty?
	get_task.each{|skill|
		if (skill[0] =~ /Sweep/ && $do_sweep)
			task = skill
		elsif (skill[0] =~ /Subdue/ && $do_subdue)
			task = skill
		elsif (skill[0] =~ /Lock Mastery/ && $do_lfm)
			task = skill
		elsif (skill[0] =~ /Cheap Shot/ && $do_cheapshots)
			task = skill
		elsif (skill[0] =~ /Rogue Gambits/ && $do_gambits)
			task = skill
		elsif (skill[0] =~ /Stun Maneuvers/ && $do_stunmans)
			task = skill
		else
			respond "#{skill[0]} is currently being ignored."
			task = false
		end
			###### TASK HAS BEEN SET #######
		if task[-1] == 'no'
			respond "GET NEW TASK IN #{task[0]}"
			go_admin #until Room.current.id == $rgadmin
			2.times{fput "ask ##{GameObj.npcs.find{|npc| npc.name =~ /Training/i}.id} about train #{task[0]}"}
			return(smart_task)
		elsif task[-1] == 'none'
			go_admin
			fput "ask ##{GameObj.npcs.find{|npc| npc.name =~ /Training/i}.id} about train #{task[0]}"
			return(smart_task)
		elsif task[-1] == 'promotion'
			go_master
			fput "ask ##{GameObj.npcs.find{|npc| npc.name =~ /Master/i}.id} about next #{task[0]}"
			x = matchwait /diversify|completes the promotion ritual/
			if x =~ /diversify/
				$do_cheapshots = false if task[0] =~ /cheap/i
				$do_sweep = false if task[0] =~ /sweep/i
				$do_stunmans = false if task[0] =~ /stun/i
				$do_gambits = false if task[0] =~ /gambit/i
				$do_subdue = false if task[0] =~ /subdue/i
				$do_lfm = false if task[0] =~ /lock/i
				go_admin
				respond "You need to diversify your guild skills, can't get a promotion in #{task[0]}"
			else
				go_admin
				fput "ask ##{GameObj.npcs.find{|npc| npc.name =~ /Training/i}.id} about train #{task[0]}"
			end
			return(smart_task)
		elsif task[-1] =~ /\d+/
			if task[-2] =~ /practice defending against footstomps/
#				respond "GET SOMEONE TO STOMP YOU"
#### GET SWEEPS
			elsif task[-2] =~ /defend against a partner/
#				respond "GET SOMEONE TO SWEEP YOU"
			elsif task[-2] =~ /get some lessons from the footpads/ && task[0] == "Sweep"
				respond "MASTER SWEEP REPS UNDER CONSTRUCTION"
				sweep_masters
				return(smart_task)
			elsif task[-2] =~ /work out on the sweep dummies/ && task[0] == 'Sweep'
				sweep_dummies
				return(smart_task)
#				$do_sweep = false
#### GET GAMBITS
#
#### GAMBITS MASTERS
			elsif task[-2] =~ /visit the master footpads for a lesson/ && task[0] == /Rogue Gambits/
				echo "VISIT THE MASTERS, FIRST RANK MAYBE?"
				gambit_masters()
				return(smart_task)
			elsif task[-2] =~ /get a partner to teach you your latest trick/
#				respond "YOU HAVE TO BE TAUGHT YOUR CURRENT GAMBIT"
#				respond "YOU HAVE TO GET A PARTNER TO PRACTICE #{task[0]} AGAINST A ROGUE GUILD MEMBER"
#### CRITTERS AND BOXES, SCRIPT AVOIDS THESE
			elsif task[-2] =~ /creatures|boxes/
				if task[-2] =~ /pick some tough boxes from creatures/
					respond "Lock mastery, tough boxes reps"
					#$caliper = false
				elsif task[-2] =~ /use some decently challenging boxes to practice your latest trick for an audience/
					respond "Lock mastery, audience ptrick reps"
					#$caliper = false
					$rglmaudience = true
				elsif task[-2] =~ /measure some boxes, then pick 'em/
					respond "Lock mastery, measure and pick reps"
					$caliper = true
				else
#					respond "YOU HAVE TO DO #{task[0]} CRITTER REPS. #{task[-2]}"
				end
#### WINDOWS
			elsif task[-2] =~ /clean the windows in the guild|clean the guild windows/
				do_windows
				return(smart_task)
#### WATER_FLOWERS
			elsif task[-2] =~ /water the guild plants/
				water_plants
				return(smart_task)
#### ARROWS
			elsif task[-2] =~ /let a footpad shoot arrows at you/
				arrows
				return(smart_task)
#### SLAPPERS
			elsif task[-2] =~ /play a few rounds of slap hands/
				slappers
				return(smart_task)
#### STUNREPS, SHIELD
			elsif task[-2] =~ /practice readying your shield while stunned/
				stun_reps("shield")
				return(smart_task)
#### STUNREPS, WEAPON
			elsif task[-2] =~ /practice getting your weapon while stunned/
				stun_reps("weapon")
				return(smart_task)
#### STUNREPS, GET
			elsif task[-2] =~ /practice picking stuff up while stunned/
				stun_reps("get lockpick")
				return(smart_task)
#### STUNREPS STAND
			elsif task[-2] =~ /practice standing up while stunned/
				stun_reps('stand')
				return(smart_task)
#### STUNREPS STANCE1
			elsif task[-2] =~ /practice defending yourself a little more while stunned/
				stun_reps('stance1')
				return(smart_task)
#### STUNREPS ATTACK
			elsif task[-2] =~ /practice attacking while stunned/
				stun_reps('attack')
				return(smart_task)
#### STUNREPS STANCE2
			elsif task[-2] =~ /practice defending yourself a lot more while stunned/
				stun_reps('stance2')
				return(smart_task)
#### SUBDUE FIRST RANK
			elsif task[-2] =~ /get some lessons from the footpads/
				subdue_first_rank
				return(smart_task)
#### GARLIC
			elsif task[-2] =~ /crush up some garlic/
				garlic
				return(smart_task)
#### MELONS
			elsif task[-2] =~ /ding up a few melons at the subdue mannequins/
				melons
				return(smart_task)
#### SUBDUE MASTERY
			elsif task[-2] =~ /see one of the footpads to learn a secret/
				master_subdue
				return(smart_task)
#### LOCK MASTERY, MASTERS
			elsif task[-2] =~ /visit a master footpad for a talk/
				lmsense
				fput "set showspell off" if $rgresetspells
				return(smart_task)
			elsif task[-2] =~ /pit your skills against a footpad/
				echo "PICKING GAME"
				pickgame
				return(smart_task)
			elsif task[-2] =~ /put clasps on some containers/
				claspconts2
				return(smart_task)
			elsif task[-2] =~ /make some good locks/
				makelocks2
				return(smart_task)
			elsif task[-2] =~ /cut keys for some locks you make/
				cutkeys
				return(smart_task)
			elsif task[-2] =~ /customize some lockpicks and keys/
			echo "SMART TASK CUSTOMIZE PICKS AND KEYS"
				lmcustom2
				return(smart_task)
#### SWEEP COURTYARD
			elsif task[-2] =~ /sweep the guild courtyard/
				sweep_courtyard
				return(smart_task)
#### STUNMAN MASTER LESSONS
			elsif task[-2] =~ /visit the footpads for some lessons/ #&& task[0] =~ /Stun Manuevers/i
				stunmasters
				return(smart_task)
#### CHEAPSHOTS, FIRST RANK
			elsif task[-2] =~ /get lessons in Footstomp from a master footpad/
				cheapshot_first_rank
				return(smart_task)
			else
				respond "PROBABLY ABLE TO DO #{task[-2]}"
			end
		end
	}
	respond "ROGUE GUILD TASKS:"
	get_task.each{|skill, task, reps|
		unless task == 'mastered'
			respond "You have #{reps} reps of #{task} for the #{skill} skill"
		end
	}
	if $guildname =~ /Ta'Vaalor/
		x = find_nearest([3519, $rgexit[0]])
		 if x == $rgexit[0]
			mymove $rgexit[0]
			fput "go chute"
		end
	end
	mymove $stun_move_room
	respond "****** EXITING **********"
	return nil
end

###################### BELOW IS MY SELF STUN OPERATION ################

$rgmethods.push("stun_reps") unless $rgmethods.include?("stun_reps")
def stun_reps(task, delay = 5)
	stamcheck = 15
	stamcheck -=  7 if task =~ /weapon|shield/
	stamcheck -= 5 if task =~ /get/
	stamcheck -= 3 if task =~ /stand/i
	fput "stance off" unless percentstance <= 20
	wait_rt
	fput "store weapon" unless GameObj.right_hand.name =~ /empty|guildmaster's special|dragondraught|claidhmore/i
	fput "store shield" unless GameObj.left_hand.name =~ /empty|guildmaster's special|dragondraught|claidhmore/i
	fput "stow right" unless GameObj.right_hand.name =~ /empty|guildmaster's special|dragondraught|claidhmore/i
	fput "stow left" unless GameObj.left_hand.name =~ /empty|guildmaster's special|dragondraught|claidhmore/i
	wait_while("POPPED MUSCLES"){Spell[9699].active?}
	wait_until("Low stamina"){checkstamina >= stamcheck}
##### DO SOMETHING TO GET STUNNED HERE #####
	if task =~ /shield/i
		#use_special('right')
		stun_claid
	elsif task =~ /attack/
		if $guildname =~ /Ta'Vaalor/
			x = find_nearest([3519, $rgexit[0]])
			 if x == $rgexit[0]
				mymove $rgexit[0]
				fput "go chute"
			end
		end
		mymove $stun_move_room unless GameObj.pcs.find{|pcs| pcs.noun =~ /#{$stun_attack_person.join('|')}/}
		wait_until("WAITING FOR SOMEONE TO ATTACK"){GameObj.pcs.find{|pcs| pcs.noun =~ /#{$stun_attack_person.join('|')}/}}
		stun_claid
		#use_special
	else
		fput "stance off" if task =~ /stance/i && percentstance > 20
		#use_special
		stun_claid
	end
### NOW THAT YOU ARE STUNNED, HERE WE GO ###
	wait_until("WAITING FOR STUN, SCRIPT MAY HANG HERE IF YOUR STUN WORE OFF TOO FAST"){stunned?}
	sleep delay
	while stunned?
		wait_rt
		if task == 'attack'
			target = GameObj.pcs.find{|pc| pc.noun =~ /#{$stun_attack_person.join('|')}/}.id
			put "stun attack ##{target}"
		else
			put "stun #{task}"
		end
		y = matchtimeout(1, "You're not", "nothing seems", "repetition", "completed", "try to command")
		#ROUNDTIME REMOVED ABOVE
		if y =~ /completed/
			wait_while{stunned?}
			wait_rt
			rg_hands_checker
			fput "stand" until standing?
			wait_rt
			go_guild
			return
		elsif y =~ /repetition/
			wait_while{stunned?}
			wait_rt
		else
			wait_rt
			break if checkstamina <= 10
			if task =~ /shield|weapon|get|attack/ && (GameObj.right_hand.name =~ /empty/i || GameObj.left_hand.name =~ /empty/i) && stunned?
				next
			else
				break
			end
		end
	end
	stun_reps(task, delay)
end
### WUTAKI'S CONTRIBUTION ###
### FOR CoL members in Wehnimers.
### STUN TIME is 20 seconds, recommend an 18 second delay.
def use_temple()
	mymove(4039)
	fput "sit"
	fput "go dais"
end
##### BELOW IS THE OPERATION TO USE DRAGONSDRAUGHT, IT CAN BE REPLACED WITH OTHER METHODS OF GETTING STUNNED #####

#$rgmethods.push("use_special") unless $rgmethods.include?("use_special")
def stun_claid
	fput "get my claid" if righthand !~ /claidhmore/ && lefthand !~ /claidhmore/
	fput "poke my claid"
	return
end

def use_special(hand = 'left')
	unless GameObj.right_hand.noun =~ /special/ || GameObj.left_hand.noun =~ /special/i
		conts = GameObj.inv.find_all{|sack| sack.contents.length >= 1}
		conts.each{|cont|
			if cont.contents.find{|spec| spec.name =~ /Guildmaster's special/i}
				fput "_drag ##{cont.contents.find{|spec| spec.name =~ /Guildmaster's special/i}.id} #{hand}"
				break
			end
		}
	end
	if GameObj.left_hand.noun =~ /special/i || GameObj.right_hand.noun =~ /special/i
		if hand =~ /left/
			fput "swap" unless GameObj.left_hand.noun =~ /special/i
			fput "stow right" unless GameObj.right_hand.name =~ /Empty/i
			drink = GameObj.left_hand.id
		else
			fput "stow left" unless GameObj.left_hand.name =~ /Empty/i
			drink = GameObj.right_hand.id
		end
		fput "sit" if standing?
		fput "drink ##{drink}"
	else
		$rgdoubleback = false
		if $guildname == "Ta'Vaalor"
			$rgdoubleback = true
			echo "Ta'Vaalor may be buggy for stunreps"
			if find_nearest([$rgexit[0], $rgexit[-1]]) == $rgexit[-1]
			else
				mymove $rgexit[0]
				fput "go chute"
			end
			mymove 11
		else
			mymove 'bank'
		end
		fput 'depo all'
		if $rgdoubleback
			fput "withdraw 4500 silver"
		else
			fput "withdraw 900 silver"
		end
		go_guild
		mymove $rgbar
		sleep 1
		if $rgdoubleback
			5.times{fput "order 6";fput "stow my special"}
		else
			fput "order 6"
		end
		if $rgdoubleback && $stun_move_room == 'town'
			$rgdoubleback = nil
			mymove 3519
		else
			mymove $stun_move_room
		end
		stun_claid
		#use_special(hand)
	end
end
grghelp = proc{
	x = " *******************************"
	respond "   grguild.lic, current update version 11-04-10"
	respond "   Scripting the guild, because I can."
	respond "   "
	respond "   Variables are contained within grgvars.lic."
	respond ""
	sleep 2
	respond x
	respond ""
	respond "   variables are true or false to do or ignore those tasks"
	respond "   The variable names are as such:"
	respond ''
	respond x
	respond "
	$do_cheapshots = true,
	$do_stunmans = true,
	$do_gambits = true,
	$do_lfm = true,
	$do_sweep = true,
	$do_subdue = true"
	respond ""
	respond x
	sleep 4
	respond ''
	respond "   Set any of them to false to ignore that skill"
	respond "   This can be done a number of ways, best being physically modifying the grgvars.lic script SAVING and RUNNING it."
	respond "   It is normal for it to start and immediately exit."
	respond "   You can also have any trusted script set/change those variables for you, or do it with a command line script."
	respond "   "
	respond "   "
	respond "   NOTE: The script will loop until stunmans is mastered, or you need to diversify.  If you don't want to master stunmans, set its variable to false."
	respond ''
	respond x
	respond ""
	respond "  ;send next to override 30 second wait "
	respond ''
	respond x
	matchtimeout(30,  "next")
	respond "   "
	respond "   SCRIPT LOADS THE FOLLOWING METHODS"
	respond ""
	respond x
	sleep 2
	respond ""
	$rgmethods.each{|method|;respond method;sleep 0.1}
	respond ''
	respond x
	respond ''
	respond "  ;send next to override 30 second wait "
	respond ''
	respond x
	matchtimeout(30,  "next")
	respond "   "
	respond "   lockmastery is currently tested and working up to rank 32, except in Vaalor, Illistim, Teras, and Zul Logoth, where repair lockpicks tasks aren't coded yet.."
	respond "   "
	respond "   stun_reps('task command') will do your self-stun reps. stun_reps('shield'), stun_reps('get lockpick') are examples of how it's called"
	respond "   "
	respond "   If you'd like to have the script automatically do any (and all) of it's currently known tasks available to you:"
	respond "          restart the script with 'start' as the command variable."
	respond "   "
	respond "   Problems, suggestions, submissions for incomplete tasks(will be credited),  AIM @ Lord Gibreficul"
	respond "  For current update notes, use ;grguild notes"
	respond ""
	respond x
}
notes = proc{
	respond "RECENT UPDATE:"
	respond "Fixed bug with stalling when going to a master someone else requested help from."
	respond "Changed stun masters reps, lemme know if it's buggy"
	respond "Got to rank 33 in LFM, repair lockpicks for RR, Solhaven, Icemule, and Wehnimers, and relocking boxes finished."
	respond "Added picking game, if you WANT to use lore during the picking game, search for the string 'def pickgame' and uncomment the commented lines"
	respond "I use the lore in the contest to buff my profile's maxlock"
	respond "rg_hands_checker method replaced the hands clearing lines in any methods it was previously used within."
	respond "multitown hop tested on mainland, working for windows tasks"
	respond "63rd rank in Subdue added.  NEED FEEDBACK FOR IF IT REALLY WORKS."
	respond "Currently working:"
	respond "Stunmans, COMPLETE, except Ta'Vaalor... probably will run you to Illistim and run you back to Vaalor if you need guildmaster special."
	respond "Lockmastery master reps, up to measure, fixed a few bugs with the script hanging in the early ranks, and just fixed a bug with an unspecified re-do task.  Don't ask."
	respond "Subdue, all tasks working, windows on the mainland will hop to either of the three towns when more reps are needed and all windows in the current town are clean.  Should hop you back to starting town as well.  Possible errors for hopping more than once on the same task.."
	respond "Cheapshots, flowers .....  Will dub over the windows multitown hop logic when I get around to it.  Currently NOT implemented, still under old style which was inefficient."
	respond "Sweep masters, early reps MIGHT be working, feedback requested, as it might be a LONG time before I get to test it again."
	respond "*****"
	respond "On my plate:"
	respond "Lockmastery progression.  Partner reps, flowers townhop. "
	respond "Better weapon selection methods.  I understand the conflicts with people who don't have DAGGER as their READY WEAPON"
	respond "END NOTE"
}
if Char.name =~ /Baswab/i
	$stun_move_room = find_nearest([188, 228])
end
###
#### BELOW IS THE LINE THAT STARTS THE SCRIPT ####
###
if Char.name !~ /#{$rogues.join('|')}/ && XMLData.game =~ /GSF/i
	respond " "
	respond "Gibreficul KNOWS you're a shattered rogue who hasn't given your name to be added to the script."
	respond "Please let Gibreficul know who you are so you can be included in the AFK madness that is Shattered."
	respond " "
end

$container = [] unless $container
contruns = 0
until !$container.empty?
	break if contruns > 9
	done = false
	action = proc{ |grab_this|
		if grab_this =~ /You are wearing/i
			$container = grab_this.scan(/a exist\=\"([\d]+)[^\.|,]/)
			grab_this;nil
		elsif grab_this =~ /\<prompt time\=/
			grab_this
			done = true;nil
		end
	}
	waitrt?
	DownstreamHook.add('inv_cont', action)
	status_tags
	$_SERVER_.puts "inv cont"
	t=Time.now
	wait_until {done or t+3<Time.now}
	DownstreamHook.remove('inv_cont')
	status_tags
	contruns += 1
end
unless $i_have_run
	$i_have_run = true
	$container.each{|cont|;fput "look in ##{cont}"}
	respond ""
	respond "Sorry for that, just making sure the XML all loaded for your stuff shouldn't happen until your next login."
	sleep 2
end
if script.vars[1]
	x = script.vars[1]
	if x =~ /help/i
		grghelp.call
	elsif x =~ /start/i
		smart_task
	elsif x =~ /notes/i
		notes.call
	elsif x =~ /sweep/i
		y = get_task.find{|task| task[0] == "Sweep"}
		respond y.join(", ")
	else
		y = get_task.find{|task| x =~ /#{task.join('|')}/i}
		respond y.join(", ")
		respond "#{get_task.find{|skill, reps, task|;skill =~ /#{script.vars[1]}/i}.join(', ')} reps"
	end
else
	respond "****  GRGUILD.LIC  ****"
	respond ""
	respond "general methods loaded"
	respond "START SCRIPT USING ;grguild start, or ;grguild help."
	respond ""
end
