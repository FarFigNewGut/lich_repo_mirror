=begin
  high_type - Proof of concept for highlighting types with universal link coloring

  Item type-specific highlighting using GameObj data with universal link coloring functionality.
  Replaces linktothefast with comprehensive link color management and type-specific overrides.
  Shared configuration with other scripts via UserVars.

  Examples:
    ;high_type                     - Show current configuration
    ;high_type quiet               - Load silently with item count
    ;high_type reset               - Reset configuration to defaults
    ;high_type add gem thought     - Add or update type color assignment
    ;high_type colors              - Show color examples with actual formatting
    ;high_type help                - Show comprehensive help

  Revision History:
    v2.2.1 - 2025-09-18 - Fixed startup delay logic to only wait when session is recent (< 10 seconds)
    v2.2.0 - 2025-09-18 - Removed legacy maintenance commands (update, remove_styles) for cleaner code
    v2.1.1 - 2025-09-18 - Fixed version display consistency, removed duplicate bold color handling
    v2.1.0 - 2025-09-18 - Reduced defaults to 5 core types, fixed arg parsing, removed deprecated colors
    v2.0.3 - 2025-09-14 - Added help command with comprehensive usage information
    v2.0.2 - 2025-09-14 - Added remove_styles command to clean configuration (removed in v2.2.0)
    v2.0.1 - 2025-09-14 - Added 10-second startup delay for proper initialization timing
    v2.0.0 - 2025-09-14 - Added universal link coloring (replaces linktothefast functionality)
    v1.1.0 - 2025-09-14 - Removed redundant 'link' color assignments for magic items
    v1.0.0 - 2023-01-01 - Gift from Xanlin

          author: Ensayn
            game: GS
            tags: highlighting, colors, links, item_types
        required: Lich >= 4.6
         version: 2.2.1
=end
script.want_downstream_xml = true
script.want_downstream = false

#------------------------------------------------------------------------------#
# Format detection for different front-ends
#------------------------------------------------------------------------------#
@monsterbold_start = $fake_stormfront ? "\034GSL\r\n " : "<pushBold\/>"
@monsterbold_end   = $fake_stormfront ? "\034GSM\r\n " : "<popBold\/>"

#------------------------------------------------------------------------------#
# Color functions (unified from FSP)
#------------------------------------------------------------------------------#
def self.xml_encode(msg)
  return msg.encode(:xml => :text)
end

def self.color(msg, color_type, skip_encoding=false)
  # If msg already contains XML tags (like <a> tags), don't encode
  encoded_msg = skip_encoding || msg.include?('<a ') ? msg : self.xml_encode(msg)

  case color_type.downcase
  when "monsterbold"
    return "#{@monsterbold_start}#{encoded_msg}#{@monsterbold_end}"
  when "speech"
    return "<preset id=\"speech\">#{encoded_msg}</preset>"
  when "whisper"
    return "<preset id=\"whisper\">#{encoded_msg}</preset>"
  when "thought"
    return "<preset id=\"thought\">#{encoded_msg}</preset>"
  when "link"
    return "<preset id=\"link\">#{encoded_msg}</preset>"
  when "selectedlink", "selected"
    return "<preset id=\"selectedLink\">#{encoded_msg}</preset>"
  when "bold"
    return "<preset id=\"bold\">#{encoded_msg}</preset>"
  else
    echo "Unknown color type: #{color_type}. Valid colors:"
    echo "  speech, whisper, thought, link, selectedlink, bold, monsterbold"
    return encoded_msg
  end
end

#------------------------------------------------------------------------------#
# Legacy helper functions (for compatibility)
#------------------------------------------------------------------------------#
def self.format_preset(msg, preset="speech")
  return self.color(msg, preset)
end

def self.format_style(msg, style="roomName")
  return self.color(msg, style)
end

def self.ts()
  return "#{Time.now.strftime('%Y-%m-%d_%H:%M:%S')}"
end

def self.sendto_familiar(msg, stamp=self.ts)
  _respond "<pushStream id=\"familiar\" ifClosedStyle=\"watching\"/>#{stamp};#{msg}\n<popStream/>\n"
end

#------------------------------------------------------------------------------#
# Configuration display and testing
#------------------------------------------------------------------------------#
def self.show_config
  echo "=== High Type Configuration ==="
  echo "Item types configured for highlighting: #{UserVars.types_to_color.keys.size}"
  UserVars.types_to_color.each { |type, color|
    echo "  #{type.ljust(12)} -> #{color}"
  }
  echo ""
  echo "Universal link coloring: #{UserVars.color_all_links ? 'enabled' : 'disabled'}"
  echo "  - Colors ALL links with 'link' preset when enabled"
  echo "  - Item types override with specific colors"
  echo "  - Replaces linktothefast functionality"
  echo ""
  echo "Available colors: #{%w[speech whisper thought link selectedlink bold monsterbold].join(', ')}"
  echo ""
  echo "Configuration stored in UserVars (shared with other scripts)"
  echo "=== End Configuration ==="
end

# Handle command line arguments - parse manually since Lich may pass as single string
if script.vars[0]
  # Split the arguments manually if they come as a single string
  args = script.vars[0].split(/\s+/)

  case args[0].downcase
  when "quiet"
    echo "High Type loaded silently - #{UserVars.types_to_color.keys.size} item types configured"
  when "reset"
    echo "Resetting types_to_color configuration to defaults..."
    UserVars.types_to_color = nil
    self.initialize_color_config
    echo "Configuration reset complete!"
    self.show_config
    exit
  when "add"
    if args[1] && args[2]
      type_name = args[1].gsub(/["']/, '')  # Remove quotes if present
      color_name = args[2].gsub(/["']/, '') # Remove quotes if present
      UserVars.types_to_color[type_name] = color_name
      UserVars.save
      echo "Added: #{type_name} => #{color_name}"
      self.show_config
    else
      echo "Usage: ;high_type add <type> <color>"
      echo "Example: ;high_type add boatcrate whisper"
    end
    exit
  when "debug"
    echo "=== High Type Debug Info ==="
    echo "Configured types: #{UserVars.types_to_color.keys.join(', ')}"
    echo ""
    echo "GameObj type data loaded for:"
    @high_type_data.each { |type, data|
      echo "  #{type}: name=#{data[:name].inspect}, noun=#{data[:noun].inspect}"
    }
    echo ""
    echo "Testing 'salvage crate' items:"
    test_names = ["a cheap salvage crate", "a shoddy salvage crate", "a silver salvage crate"]
    test_names.each { |name|
      type = self.get_item_type(name, "crate")
      echo "  '#{name}' => type: #{type || 'nil (no match)'}"
    }
    echo "=== End Debug ==="
    exit
  when "colors", "examples"
    echo "=== High Type Color Examples ==="
    echo ""
    echo "Available colors with examples:"
    echo ""

    sample_text = "Sample Item Text"

    # Show each color with actual formatting using _respond to render colors
    echo "  monsterbold:   (see below)"
    _respond "  #{self.color(sample_text, 'monsterbold')}\n"
    echo "  speech:        (see below)"
    _respond "  #{self.color(sample_text, 'speech')}\n"
    echo "  whisper:       (see below)"
    _respond "  #{self.color(sample_text, 'whisper')}\n"
    echo "  thought:       (see below)"
    _respond "  #{self.color(sample_text, 'thought')}\n"
    echo "  link:          (see below)"
    _respond "  #{self.color(sample_text, 'link')}\n"
    echo "  selectedlink:  (see below)"
    _respond "  #{self.color(sample_text, 'selectedlink')}\n"
    echo "  bold:          (see below)"
    _respond "  #{self.color(sample_text, 'bold')}\n"
    echo ""
    echo "NOTE: If all colors look the same, your client presets may"
    echo "      be configured to use the same 'skin' color for all presets."
    echo "=== End Color Examples ==="
    exit
  when "help"
    echo "=== High Type v2.2.1 Help ==="
    echo ""
    echo "USAGE: ;high_type [command]"
    echo ""
    echo "COMMANDS:"
    echo "  (no args)         Show current configuration"
    echo "  quiet             Load silently with item count"
    echo "  reset             Reset configuration to defaults"
    echo "  add <type> <color> Add or update a type color assignment"
    echo "  colors|examples   Show color examples with actual formatting"
    echo "  debug             Show debug information and test cases"
    echo "  help              Show this help message"
    echo ""
    echo "FEATURES:"
    echo "  - Universal link coloring (replaces linktothefast functionality)"
    echo "  - Item type-specific highlighting using GameObj data"
    echo "  - Shared configuration with other scripts via UserVars"
    echo "  - 7 available colors: speech, whisper, thought, link, selectedlink, bold, monsterbold"
    echo ""
    echo "EXAMPLES:"
    echo "  ;high_type add gem thought      # Gems use purple color"
    echo "  ;high_type colors               # Show color examples"
    echo "  ;high_type add weapon speech    # Weapons use speech color"
    echo "=== End Help ==="
    exit
  else
    echo "Unknown command: #{args[0]}"
    echo "Commands: quiet, reset, add <type> <color>, colors, debug, help"
    exit
  end
else
  self.show_config
end

#------------------------------------------------------------------------------#
# Item type to color mapping configuration in UserVars for shared access
#------------------------------------------------------------------------------#
def self.initialize_color_config
  # Initialize UserVars with default color mappings if not already set
  UserVars.types_to_color ||= {}
  UserVars.color_all_links ||= true  # Enable universal link coloring

  # Set defaults if UserVars is empty
  if UserVars.types_to_color.empty?
    default_colors = {
      # Valuable items
      'gem'         => 'thought',      # Purple/magenta for gems
      'jewelry'     => 'thought',      # Same color family as gems
      'valuable'    => 'thought',      # Consistent with gems

      # Containers and boxes
      'box'         => 'speech',       # Speech color for lockboxes
      'boatcrate'   => 'whisper'       # Subdued for boat crates
    }
    UserVars.types_to_color = default_colors
    UserVars.save
  end
end

# Initialize configuration on script load
self.initialize_color_config


#------------------------------------------------------------------------------#
# Load only the type data we need for comparisons
#------------------------------------------------------------------------------#
@high_type_data = GameObj.type_data.select{ |k,v| k if UserVars.types_to_color.keys.include?(k) }

def self.get_item_type(name,noun)
    list = @high_type_data.keys.find_all { |t| (name =~ @high_type_data[t][:name] or noun =~ @high_type_data[t][:noun]) and (@high_type_data[t][:exclude].nil? or name !~ @high_type_data[t][:exclude]) }
    return nil if list.empty?
    type = list.include?('collectible') ? 'collectible' : list.join(',');
    return type
end
#------------------------------------------------------------------------------#
# hook proc
#------------------------------------------------------------------------------#
@patterns = Hash.new
@patterns[:link_basic] = /<a exist="(?<id>-?\d+)" noun="(?<noun>[^"]+)">(?<name>[^<]+)<\/a>/;

type_highlight = proc {|server_string|
  # First Pass: Color ALL links with generic link color (if enabled)
  if UserVars.color_all_links && server_string =~ /<[ad](?: [^>]*)?>.*?<\/[ad]>/
    server_string = server_string.gsub(/(<[ad](?: [^>]*)?>.*?<\/[ad]>)/, "<preset id='link'>\\1</preset>")

    # Handle bold text exclusions - remove link presets from bold sections
    server_string = server_string.gsub(/<pushBold\s*\/>.*?<popBold\s*\/>/) do |bold_section|
      bold_section.gsub(/<preset id='link'>(.*?)<\/preset>/, "\\1")
    end

    # Handle <b> tags too
    server_string = server_string.gsub(/<b\s*>.*?<\/b\s*>/) do |bold_section|
      bold_section.gsub(/<preset id='link'>(.*?)<\/preset>/, "\\1")
    end
  end

  # Second Pass: Override with type-specific colors for items
  if server_string =~ /<a exist="(?:-?\d+)" noun="(?:[^"]+)">(?:[^<]+)<\/a>/
    tosub = []
    server_string.scan(@patterns[:link_basic]).each { |id,noun,name|
      type = self.get_item_type(name,noun)
      UserVars.types_to_color.each { |k,v|
        if type =~ /#{k}/
          tosub << [id,v]
          break
        end
      }
    }
    if tosub.size > 0
      tosub.each { |id,color_type|
        # Remove any existing preset wrapper and apply type-specific color
        item_pattern = /(<preset id='link'>)?(<a exist="#{id}".*?<\/a>)(<\/preset>)?/
        server_string.gsub!(item_pattern, self.color('\\2', color_type, true))
      }
    end
  end

  server_string
}

#------------------------------------------------------------------------------#
# Startup delay to ensure proper initialization before other scripts depend on it
#------------------------------------------------------------------------------#
startup_delay = ((Time.now - $login_time) < 10 ? (10 - (Time.now - $login_time)).ceil : 0)
if startup_delay > 0
  echo "High Type v2.2.1 starting - waiting #{startup_delay} seconds for session stabilization..."
  sleep startup_delay
else
  echo "High Type v2.2.1 starting - session already stable, no delay needed..."
end

#------------------------------------------------------------------------------#
# hook it
#------------------------------------------------------------------------------#
DownstreamHook.add('high_type', type_highlight)
before_dying{DownstreamHook.remove('high_type')}
echo "High Type v2.2.1 fully active - link coloring and type highlighting enabled"
while true;sleep 1;end
