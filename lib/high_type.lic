=begin
  high_type - Highlighting types with universal link coloring.  Download HTSORTER for highlights while looking in bags.

  Item type-specific highlighting using GameObj data with universal link coloring functionality.
  Replaces linktothefast with comprehensive link color management and type-specific overrides.
  Shared configuration with other scripts via UserVars.

  Examples:
    ;high_type                     - Show current configuration
    ;high_type quiet               - Load silently with item count
    ;high_type reset               - Reset configuration to defaults
    ;high_type add gem thought     - Add or update type color assignment
    ;high_type colors              - Show color examples with actual formatting
    ;high_type help                - Show comprehensive help

  Revision History:
    v2.5.0 - 2025-09-20 - Added character default color feature (setcharcolor/clearcharcolor commands)
    v2.4.1 - 2025-09-20 - Internal refactoring
    v2.4.0 - 2025-09-20 - Added showconfig, remove commands and HT alias for runtime processing
    v2.3.0 - 2025-09-19 - Added runtime command processing for inline configuration
    v2.2.1 - 2025-09-18 - Fixed startup delay logic to only wait when session is recent (< 10 seconds)
    v2.2.0 - 2025-09-18 - Removed legacy maintenance commands (update, remove_styles) for cleaner code
    v2.1.1 - 2025-09-18 - Fixed version display consistency, removed duplicate bold color handling
    v2.1.0 - 2025-09-18 - Reduced defaults to 5 core types, fixed arg parsing, removed deprecated colors
    v2.0.3 - 2025-09-14 - Added help command with comprehensive usage information
    v2.0.2 - 2025-09-14 - Added remove_styles command to clean configuration (removed in v2.2.0)
    v2.0.1 - 2025-09-14 - Added 10-second startup delay for proper initialization timing
    v2.0.0 - 2025-09-14 - Added universal link coloring (replaces linktothefast functionality)
    v1.1.0 - 2025-09-14 - Removed redundant 'link' color assignments for magic items
    v1.0.0 - 2023-01-01 - Gift from Xanlin

          author: Ensayn
            game: GS
            tags: highlighting, colors, links, item_types
        required: Lich >= 4.6
         version: 2.5.0
=end
script.want_downstream_xml = true
script.want_downstream = false

#------------------------------------------------------------------------------#
# Format detection for different front-ends
#------------------------------------------------------------------------------#
@monsterbold_start = $fake_stormfront ? "\034GSL\r\n " : "<pushBold\/>"
@monsterbold_end   = $fake_stormfront ? "\034GSM\r\n " : "<popBold\/>"

#------------------------------------------------------------------------------#
# Color functions (unified from FSP)
#------------------------------------------------------------------------------#
def self.xml_encode(msg)
  return msg.encode(:xml => :text)
end

def self.color(msg, color_type, skip_encoding=false)
  # If msg already contains XML tags (like <a> tags), don't encode
  encoded_msg = skip_encoding || msg.include?('<a ') ? msg : self.xml_encode(msg)

  case color_type.downcase
  when "monsterbold"
    return "#{@monsterbold_start}#{encoded_msg}#{@monsterbold_end}"
  when "speech"
    return "<preset id=\"speech\">#{encoded_msg}</preset>"
  when "whisper"
    return "<preset id=\"whisper\">#{encoded_msg}</preset>"
  when "thought"
    return "<preset id=\"thought\">#{encoded_msg}</preset>"
  when "link"
    return "<preset id=\"link\">#{encoded_msg}</preset>"
  when "selectedlink", "selected"
    return "<preset id=\"selectedLink\">#{encoded_msg}</preset>"
  when "bold"
    return "<preset id=\"bold\">#{encoded_msg}</preset>"
  else
    echo "Unknown color type: #{color_type}. Valid colors:"
    echo "  speech, whisper, thought, link, selectedlink, bold, monsterbold"
    return encoded_msg
  end
end

#------------------------------------------------------------------------------#
# Legacy helper functions (for compatibility)
#------------------------------------------------------------------------------#
def self.format_preset(msg, preset="speech")
  return self.color(msg, preset)
end

def self.format_style(msg, style="roomName")
  return self.color(msg, style)
end

def self.ts()
  return "#{Time.now.strftime('%Y-%m-%d_%H:%M:%S')}"
end

def self.sendto_familiar(msg, stamp=self.ts)
  _respond "<pushStream id=\"familiar\" ifClosedStyle=\"watching\"/>#{stamp};#{msg}\n<popStream/>\n"
end

#------------------------------------------------------------------------------#
# Configuration display and testing
#------------------------------------------------------------------------------#
def self.display_configuration
  echo "=== High Type Configuration ==="
  echo "Item types configured for highlighting: #{UserVars.types_to_color.keys.size}"
  UserVars.types_to_color.each { |type, color|
    echo "  #{type.ljust(12)} -> #{color}"
  }
  echo ""
  echo "Universal link coloring: #{UserVars.color_all_links ? 'enabled' : 'disabled'}"
  echo "  - Colors ALL links with 'link' preset when enabled"
  echo "  - Item types override with specific colors"
  echo "  - Replaces linktothefast functionality"

  if UserVars.character_default_color
    echo "Character default color: #{UserVars.character_default_color}"
    echo "  - All character names use this color instead of link default"
  else
    echo "Character default color: not set (using link default)"
  end
  echo ""
  echo "Available colors: #{%w[speech whisper thought link selectedlink bold monsterbold].join(', ')}"
  echo ""
  echo "Configuration stored in UserVars (shared with other scripts)"
  echo "=== End Configuration ==="
end


# Handle initial startup arguments - parse manually since Lich may pass as single string
if script.vars[0]
  # Split the arguments manually if they come as a single string
  args = script.vars[0].split(/\s+/)

  case args[0].downcase
  when "quiet"
    echo "High Type loaded silently - #{UserVars.types_to_color.keys.size} item types configured"
  when "reset"
    echo "Resetting types_to_color configuration to defaults..."
    UserVars.types_to_color = nil
    self.setup_color_defaults
    echo "Configuration reset complete!"
    self.display_configuration
    exit
  when "add"
    if args[1] && args[2]
      type_name = args[1].gsub(/["']/, '')  # Remove quotes if present
      color_name = args[2].gsub(/["']/, '') # Remove quotes if present
      UserVars.types_to_color[type_name] = color_name
      UserVars.save
      echo "Added: #{type_name} => #{color_name}"
      self.display_configuration
    else
      echo "Usage: ;high_type add <type> <color>"
      echo "Example: ;high_type add boatcrate whisper"
    end
    exit
  when "debug"
    echo "=== High Type Debug Info ==="
    echo "Configured types: #{UserVars.types_to_color.keys.join(', ')}"
    echo ""
    echo "GameObj type data loaded for:"
    @high_type_data.each { |type, data|
      echo "  #{type}: name=#{data[:name].inspect}, noun=#{data[:noun].inspect}"
    }
    echo ""
    echo "Testing 'salvage crate' items:"
    test_names = ["a cheap salvage crate", "a shoddy salvage crate", "a silver salvage crate"]
    test_names.each { |name|
      type = self.identify_item_category(name, "crate")
      echo "  '#{name}' => type: #{type || 'nil (no match)'}"
    }
    echo "=== End Debug ==="
    exit
  when "colors", "examples"
    echo "=== High Type Color Examples ==="
    echo ""
    echo "Available colors with examples:"
    echo ""

    sample_text = "Sample Item Text"

    # Show each color with actual formatting using _respond to render colors
    echo "  monsterbold:   (see below)"
    _respond "  #{self.color(sample_text, 'monsterbold')}\n"
    echo "  speech:        (see below)"
    _respond "  #{self.color(sample_text, 'speech')}\n"
    echo "  whisper:       (see below)"
    _respond "  #{self.color(sample_text, 'whisper')}\n"
    echo "  thought:       (see below)"
    _respond "  #{self.color(sample_text, 'thought')}\n"
    echo "  link:          (see below)"
    _respond "  #{self.color(sample_text, 'link')}\n"
    echo "  selectedlink:  (see below)"
    _respond "  #{self.color(sample_text, 'selectedlink')}\n"
    echo "  bold:          (see below)"
    _respond "  #{self.color(sample_text, 'bold')}\n"
    echo ""
    echo "NOTE: If all colors look the same, your client presets may"
    echo "      be configured to use the same 'skin' color for all presets."
    echo "=== End Color Examples ==="
    exit
  when "help"
    echo "=== High Type v2.5.0 Help ==="
    echo ""
    echo "USAGE: ;high_type [command]"
    echo ""
    echo "STARTUP COMMANDS (exits after execution):"
    echo "  quiet             Load silently with item count"
    echo "  debug             Show debug information and test cases"
    echo ""
    echo "RUNTIME COMMANDS (script continues running):"
    echo "  ;high_type        Show current configuration"
    echo "  ;high_type help   Show this help message"
    echo "  ;high_type add <type> <color> Add or update type color"
    echo "  ;high_type reset  Reset configuration to defaults"
    echo "  ;high_type colors Show color examples"
    echo "  ;high_type setcharcolor <color> Set default color for all characters"
    echo "  ;high_type clearcharcolor    Clear character color (use link default)"
    echo ""
    echo "FEATURES:"
    echo "  - Runtime command processing for dynamic configuration"
    echo "  - Universal link coloring (replaces linktothefast)"
    echo "  - Item type-specific highlighting using GameObj data"
    echo "  - Shared configuration with other scripts via UserVars"
    echo "  - 7 available colors: speech, whisper, thought, link, selectedlink, bold, monsterbold"
    echo ""
    echo "EXAMPLES:"
    echo "  ;high_type add gem thought      # Gems use purple color"
    echo "  ;high_type colors               # Show color examples"
    echo "  ;high_type add weapon speech    # Weapons use speech color"
    echo "=== End Help ==="
    exit
  else
    echo "Unknown startup command: #{args[0]}"
    echo "Commands: quiet, debug, help"
    echo "For runtime commands, start the script first."
    exit
  end
else
  self.display_configuration
end

#------------------------------------------------------------------------------#
# Item type to color mapping configuration in UserVars for shared access
#------------------------------------------------------------------------------#
def self.setup_color_defaults
  # Initialize UserVars with default color mappings if not already set
  UserVars.types_to_color ||= {}
  UserVars.color_all_links ||= true  # Enable universal link coloring
  UserVars.character_default_color ||= nil  # Default color for all character names (negative exist IDs)

  # Set defaults if UserVars is empty
  if UserVars.types_to_color.empty?
    default_colors = {
      # Valuable items
      'gem'         => 'thought',      # Purple/magenta for gems
      'jewelry'     => 'thought',      # Same color family as gems
      'valuable'    => 'thought',      # Consistent with gems

      # Containers and boxes
      'box'         => 'speech',       # Speech color for lockboxes
      'boatcrate'   => 'whisper'       # Subdued for boat crates
    }
    UserVars.types_to_color = default_colors
    UserVars.save
  end
end

# Initialize configuration on script load
self.setup_color_defaults


#------------------------------------------------------------------------------#
# Load only the type data we need for comparisons
#------------------------------------------------------------------------------#
@high_type_data = GameObj.type_data.select{ |k,v| k if UserVars.types_to_color.keys.include?(k) }

def self.identify_item_category(name,noun)
    list = @high_type_data.keys.find_all { |t| (name =~ @high_type_data[t][:name] or noun =~ @high_type_data[t][:noun]) and (@high_type_data[t][:exclude].nil? or name !~ @high_type_data[t][:exclude]) }
    return nil if list.empty?
    type = list.include?('collectible') ? 'collectible' : list.join(',');
    return type
end
#------------------------------------------------------------------------------#
# hook proc
#------------------------------------------------------------------------------#
@match_patterns = Hash.new
@match_patterns[:item_link] = /<a exist="(?<id>-?\d+)" noun="(?<noun>[^"]+)">(?<name>[^<]+)<\/a>/;

# Main processing pipeline for game output colorization
# Applies multi-phase enhancement to links and items based on configuration
apply_type_colors = proc {|game_output|
  # Phase 1: Universal link enhancement - Apply base coloring to all link elements
  if UserVars.color_all_links && game_output =~ /<[ad](?: [^>]*)?>.*?<\/[ad]>/
    game_output = game_output.gsub(/(<[ad](?: [^>]*)?>.*?<\/[ad]>)/, "<preset id='link'>\\1</preset>")

    # Bold text exclusion: Remove link coloring from bold sections to prevent conflicts
    game_output = game_output.gsub(/<pushBold\s*\/>.*?<popBold\s*\/>/) do |bold_content|
      bold_content.gsub(/<preset id='link'>(.*?)<\/preset>/, "\\1")
    end

    # Additional bold tag handling for compatibility
    game_output = game_output.gsub(/<b\s*>.*?<\/b\s*>/) do |bold_content|
      bold_content.gsub(/<preset id='link'>(.*?)<\/preset>/, "\\1")
    end
  end

  # Phase 2: Character default color - Apply color to all character names (negative exist IDs)
  if UserVars.character_default_color && game_output =~ /<[ad] exist="-\d+"/
    game_output = game_output.gsub(/<([ad]) exist="(-\d+)"([^>]*)>([^<]+)<\/\1>/) do |match|
      tag_type = $1
      exist_id = $2
      attributes = $3
      name = $4
      # Apply character color to negative exist IDs
      "<preset id='#{UserVars.character_default_color}'><#{tag_type} exist=\"#{exist_id}\"#{attributes}>#{name}</#{tag_type}></preset>"
    end
  end

  # Phase 3: Type-specific colorization - Override colors based on GameObj classification
  if game_output =~ /<a exist="(?:-?\d+)" noun="(?:[^"]+)">(?:[^<]+)<\/a>/
    color_queue = []
    game_output.scan(@match_patterns[:item_link]).each { |id,noun,name|
      type = self.identify_item_category(name,noun)
      UserVars.types_to_color.each { |k,v|
        if type =~ /#{k}/
          color_queue << [id,v]
          break
        end
      }
    }
    if color_queue.size > 0
      color_queue.each { |id,color_type|
        # Remove any existing preset wrapper and apply type-specific color
        item_pattern = /(<preset id='link'>)?(<a exist="#{id}".*?<\/a>)(<\/preset>)?/
        game_output.gsub!(item_pattern, self.color('\\2', color_type, true))
      }
    end
  end

  game_output
}

#------------------------------------------------------------------------------#
# Startup delay to ensure proper initialization before other scripts depend on it
#------------------------------------------------------------------------------#
startup_delay = ((Time.now - $login_time) < 10 ? (10 - (Time.now - $login_time)).ceil : 0)
if startup_delay > 0
  echo "High Type v2.4.0 starting - waiting #{startup_delay} seconds for session stabilization..."
  sleep startup_delay
else
  echo "High Type v2.4.0 starting - session already stable, no delay needed..."
end

#------------------------------------------------------------------------------#
# Runtime command processing hook (using recolor.lic proven pattern)
#------------------------------------------------------------------------------#
def self.handle_runtime_command(args, running=true)
  return unless args

  # Parse the arguments if they come as a single string
  args = args.strip.split(/\s+/) if args.is_a?(String)
  return if args.empty?

  case args[0].downcase
  when "help"
    _respond "[high_type: === High Type v2.5.0 Runtime Commands ===]"
    _respond "[high_type: ]"
    _respond "[high_type: While script is running, use:]"
    _respond "[high_type:   ;high_type (or ;ht)         - Show current configuration]"
    _respond "[high_type:   ;high_type help (or ;ht help) - Show this help]"
    _respond "[high_type:   ;high_type add <type> <color> - Add/update type color]"
    _respond "[high_type:   ;high_type remove <type>     - Remove type color]"
    _respond "[high_type:   ;high_type showconfig        - Show current configuration]"
    _respond "[high_type:   ;high_type reset            - Reset to defaults]"
    _respond "[high_type:   ;high_type colors           - Show color examples]"
    _respond "[high_type:   ;high_type setcharcolor <color> - Set default color for all characters]"
    _respond "[high_type:   ;high_type clearcharcolor  - Clear character color (use link default)]"
    _respond "[high_type: ]"
    _respond "[high_type: Script continues running after commands.]"
    _respond "[high_type: === End Runtime Help ===]"

  when "add"
    if args[1] && args[2]
      type_name = args[1].gsub(/[\"']/, '')
      color_name = args[2].gsub(/[\"']/, '')
      UserVars.types_to_color[type_name] = color_name
      UserVars.save
      echo "Added: #{type_name} => #{color_name}"
      # Reload type data for the new type
      @high_type_data = GameObj.type_data.select{ |k,v| k if UserVars.types_to_color.keys.include?(k) }
      echo "Configuration updated (script continues running)"
    else
      echo "Usage: ;high_type add <type> <color>"
      echo "Example: ;high_type add weapon speech"
    end

  when "reset"
    echo "Resetting types_to_color configuration to defaults..."
    UserVars.types_to_color = nil
    self.setup_color_defaults
    # Reload type data after reset
    @high_type_data = GameObj.type_data.select{ |k,v| k if UserVars.types_to_color.keys.include?(k) }
    echo "Configuration reset complete! (script continues running)"
    self.display_configuration

  when "colors", "examples"
    echo "=== High Type Color Examples ==="
    echo ""
    sample_text = "Sample Item Text"
    echo "  monsterbold:   (see below)"
    _respond "  #{self.color(sample_text, 'monsterbold')}\n"
    echo "  speech:        (see below)"
    _respond "  #{self.color(sample_text, 'speech')}\n"
    echo "  whisper:       (see below)"
    _respond "  #{self.color(sample_text, 'whisper')}\n"
    echo "  thought:       (see below)"
    _respond "  #{self.color(sample_text, 'thought')}\n"
    echo "  link:          (see below)"
    _respond "  #{self.color(sample_text, 'link')}\n"
    echo "  selectedlink:  (see below)"
    _respond "  #{self.color(sample_text, 'selectedlink')}\n"
    echo "  bold:          (see below)"
    _respond "  #{self.color(sample_text, 'bold')}\n"
    echo ""
    echo "=== End Color Examples ==="

  when "showconfig", "config", "show"
    self.display_configuration

  when "remove"
    if args[1]
      type_name = args[1].gsub(/[\"']/, '')
      if UserVars.types_to_color.key?(type_name)
        UserVars.types_to_color.delete(type_name)
        UserVars.save
        echo "Removed: #{type_name}"
        # Reload type data after removal
        @high_type_data = GameObj.type_data.select{ |k,v| k if UserVars.types_to_color.keys.include?(k) }
        echo "Configuration updated (script continues running)"
      else
        echo "Type '#{type_name}' not found in configuration"
      end
    else
      echo "Usage: ;high_type remove <type>"
      echo "Example: ;high_type remove weapon"
    end

  when "setcharcolor"
    if args[1]
      color_name = args[1].gsub(/[\"']/, '')
      valid_colors = %w[speech whisper thought link selectedlink bold monsterbold]
      if valid_colors.include?(color_name)
        UserVars.character_default_color = color_name
        UserVars.save
        echo "Character default color set to: #{color_name}"
        echo "All character names will now use #{color_name} color"
      else
        echo "Invalid color: #{color_name}"
        echo "Valid colors: #{valid_colors.join(', ')}"
      end
    else
      echo "Usage: ;high_type setcharcolor <color>"
      echo "Example: ;high_type setcharcolor whisper"
    end

  when "clearcharcolor"
    UserVars.character_default_color = nil
    UserVars.save
    echo "Character default color cleared - characters will use link default"

  else
    # Default to showing configuration
    self.display_configuration
  end
end

#------------------------------------------------------------------------------#
# hook it (using recolor.lic proven pattern)
#------------------------------------------------------------------------------#
runtime_pattern = /^(?:<c>)?\s*#{Regexp.escape($lich_char)}(?:#{Regexp.escape(script.name)}|ht)(\s+.*)?$/

DownstreamHook.add('high_type', apply_type_colors)
UpstreamHook.add('high_type_commands', proc { |cmd|
  if cmd =~ runtime_pattern
    if $1
      self.handle_runtime_command($1, true)
    else
      _respond "[#{script.name} is already running. Type ;#{script.name} help for runtime commands.]"
    end
    nil  # Prevent command from going to game
  else
    cmd  # Pass other commands through
  end
})

before_dying{
  DownstreamHook.remove('high_type')
  UpstreamHook.remove('high_type_commands')
}

echo "High Type v2.4.0 fully active - link coloring and type highlighting enabled"
echo "Runtime commands available: ;high_type (or ;ht) help, ;high_type add <type> <color>, ;high_type reset, etc."

while true;sleep 1;end
