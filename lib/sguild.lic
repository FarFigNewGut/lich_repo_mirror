#     SGuild by SpiffyJr (spiffyjr@gmail.com)
#
#     Does guild stuff.
#
#      author: spiffyjr
#        name: SpiffyGuild
#        tags: guild rogue warrior
#
#     Batter: in progress
#     Berserk: complete
#     Disarm: complete
#     Tackle: complete
#     Tricks: complete
#     Warcries: complete
#
#     Cheapshots: complete
#     Gambits: complete
#     Lock Mastery: complete
#     Subude: complete
#     Stun Maneuvers: complete
#     Sweep: in progress
#
CharSettings['audience-room'] ||= 228
CharSettings['audience-weapon'] ||= ''
CharSettings['audience-weapon-small'] ||= ''

CharSettings['batter-trade'] ||= false
CharSettings['batter-weapon'] ||= ''

CharSettings['clasp-container'] ||= ''

CharSettings['field-prepare'] ||= %w[gird]
CharSettings['field-finish'] ||= ['store all']
CharSettings['field-scripts'] ||= []
CharSettings['field-targets'] ||= []
CharSettings['field-trade'] ||= false
CharSettings['field-room'] ||= ''

CharSettings['fried'] ||= false

CharSettings['loop'] ||= false
CharSettings['loop-mind'] ||= 0
CharSettings['loop-bounty'] ||= false
CharSettings['loop-no-reset'] ||= false
CharSettings['loop-no-vocal'] ||= false

CharSettings['loot-script'] ||= 'sloot'

CharSettings['pool-audience-room'] ||= 3807
CharSettings['pool-room'] ||= 3807

CharSettings['partner-name'] ||= nil
CharSettings['partner-room'] ||= nil

CharSettings['rest-enter'] ||= ''
CharSettings['rest-exit'] ||= ''
CharSettings['rest-room'] ||= 228
CharSettings['rest-scripts'] ||= ['useherbs --buy-missing=on', 'sloot sell']

CharSettings['sheath'] ||= ''

CharSettings['travel'] ||= false
CharSettings['trade-audience'] ||= false
CharSettings['trade-extract'] ||= false
CharSettings['trade-footpad'] ||= false
CharSettings['trade-partner'] ||= false
CharSettings['trade-wedge'] ||= false

CharSettings['weapon-brawling'] ||= ''
CharSettings['weapon-polearm'] ||= ''
CharSettings['weapon-edged'] ||= ''

CharSettings['wounded'] ||= StringProc.new('
  bleeding? ||
  percenthealth <= 75 ||
  [Wounds.head, Scars.head].max >= 2 ||
  [Wounds.nsys, Scars.nsys].max >= 2 ||
  [
    Wounds.leftArm,
    Wounds.leftHand,
    Wounds.rightArm,
    Wounds.rightHand,
    Scars.leftArm,
    Scars.leftHand,
    Scars.rightArm,
    Scars.rightHand
  ].max >= 3 ||
    [Wounds.leftArm, Wounds.leftHand, Scars.leftArm, Scars.leftHand].max >= 2 ||
    [Wounds.rightArm, Wounds.rightHand, Scars.leftArm, Scars.leftHand].max >= 2
')

resting = false
lootsack = GameObj[UserVars.lootsack]

if lootsack.nil?
  echo '** failed to find lootsack, set it with ;set change lootsack [container]'
  exit
end

skill_short_to_long = {
  'batter' => 'Batter Barriers',
  'berserk' => 'Berserk',
  'disarm' => 'Disarm Weapon',
  'tackle' => 'Tackle',
  'tricks' => 'Warrior Tricks',
  'warcries' => 'War Cries',
  'cheapshots' => 'Cheap Shot',
  'gambits' => 'Rogue Gambits',
  'lmas' => 'Lock Mastery',
  'stunman' => 'Stun Maneuvers',
  'subdue' => 'Subdue',
  'sweep' => 'Sweep'
}

error = proc do |msg|
  echo "** #{msg}"
  exit
end

print = proc { |msg| echo "-- #{msg}" }

run_looter = proc do
  next if GameObj.npcs.find_all { |npc| npc.status =~ /dead/ }.nil?

  wait_while { running? CharSettings['loot-script'] }
  start_script CharSettings['loot-script']
  wait_while { running? CharSettings['loot-script'] }
end

go2 = proc do |room|
  fput XMLData.room_exits.first if checkarea =~ /dark corner|workbench/i

  next if Room.current.id.to_s == room.to_s
  next if Room.current.tags.include?(room)

  CharSettings['rest-exit'].split(',').each { |cmd| fput cmd.to_s } if checkarea =~ /table/i

  until standing?
    waitrt?
    fput 'stand'
    sleep 0.25
  end
  fput 'out' if Room.current.title =~ /Table/i

  if CharSettings['travel']
    room = Room.current.find_nearest_by_tag(room) if room.class.instance_of?(String)

    check = Room.current.dijkstra(room)[1][room]

    if check > 30
      loc = room.instance_of?(Map) ? room.location : Room[room].location

      error.call "failed to find speed2 location for #{room.inspect}; message SpiffyJr" if loc.nil? || loc.empty?
      print.call "running speed2 with #{loc} from #{room.inspect}"
      Script.run('speed2', loc)
    end
  end

  Script.run('go2', room.to_s, quiet: true)
end

go2_nearest_tag = proc do |tag|
  if Room.current.nil? && checkarea =~ /table/i
    until standing?
      waitrt?
      fput 'stand'
      sleep 0.25
    end
    fput 'out'
  end

  room = Room.current.find_nearest_by_tag(tag)
  error.call "failed to find room by tag: #{tag}" if room.nil?

  go2.call(room)
end

get_nearest_rooms_by_tag = proc do |tag|
  rooms = Room.list.find_all { |room| room.tags.find { |t| t == tag } }
  rooms = rooms.collect(&:id)

  rest_room = Room[CharSettings['rest-room']]
  _, shortest_distances = Map.dijkstra(rest_room)

  # used to set the max distance to allow travel to
  distance = 10

  # leaves don't need other guilds
  distance = rest_room.location =~ /Ta'/ ? 400 : 600 if tag !~ /leaves/ && CharSettings['travel']

  rooms.delete_if { |room| shortest_distances[room].nil? || shortest_distances[room] > distance }
  rooms.sort! { |a, b| shortest_distances[a] < shortest_distances[b] ? -1 : 1 }
  rooms
end

visit_locker = proc do |action, item|
  locker = CharSettings['locker']

  error.call 'locker is not set' if locker.nil? || !locker

  go2.call 'bank'
  fput 'withdraw 1000'
  go2.call locker

  CharSettings['locker-in'].each { |x| move x } unless CharSettings['locker-in'].empty?

  if (entrance = ((GameObj.loot.to_a + GameObj.room_desc.to_a).find { |obj| obj.noun =~ /^(?:opening|curtain)$/ }))
    move "go ##{entrance.id}"
  else
    erorr.call 'failed to find locker entrance'
  end

  fput 'open locker'

  if action == 'put'
    fput "put #{item} in locker"
  elsif action == 'get'
    fput "get #{item} from locker"
    # premium, brute force
    fput "get #{item}" if checkleft !~ /#{item}/ && checkright !~ /#{item}/
  else
    fput cmd
  end

  fput 'close locker'

  if (entrance = ((GameObj.loot.to_a + GameObj.room_desc.to_a).find { |obj| obj.noun =~ /^(?:opening|curtain)$/ }))
    move "go ##{entrance.id}"
  else
    erorr.call 'failed to find locker exit'
  end

  CharSettings['locker-out'].each { |x| move x } unless CharSettings['locker-out'].empty?

  go2.call 'bank'
  fput 'deposit all'
end

rest = proc do |run_scripts|
  go2.call CharSettings['rest-room']

  if run_scripts.nil? || (run_scripts == true)
    CharSettings['rest-scripts'].each do |s|
      args = s.split(' ')
      s = args.shift

      start_script(s, args, true)
      wait_while { running? s }
    end
  end

  CharSettings['rest-enter'].split(',').each { |cmd| fput cmd.to_s }
  resting = true
end

rest_exit = proc do
  next unless resting

  CharSettings['rest-exit'].split(',').each { |cmd| fput cmd.to_s }
  resting = false
end

prepare_field = proc do
  error.call 'missing field-room' if CharSettings['field-room'].to_s.empty?

  CharSettings['field-prepare'].each { |cmd| fput cmd }
  CharSettings['field-scripts'].each { |s| Script.start(s) unless Script.running?(s) }
  go2.call CharSettings['field-room']
end

finish_field = proc do
  go2.call CharSettings['rest-room']
  CharSettings['field-finish'].each { |cmd| fput cmd }
  CharSettings['field-scripts'].each { |s| Script.kill(s) if Script.running?(s) }

  rest.call
end

get_weapon = proc do |weapon|
  next if GameObj.right_hand.name =~ /#{weapon}/ || GameObj.left_hand.name =~ /#{weapon}/

  fput 'stow right' if checkright && checkright !~ /#{weapon}/
  fput "get #{weapon} from my #{CharSettings['sheath']}"
  sleep 1

  if checkright !~ /#{weapon}/i
    finish_field.call
    error.call "failed to find #{weapon} in your #{CharSettings['sheath']}"
  end
end

get_field_targets = proc {
  GameObj.targets.find_all { |npc| CharSettings['field-targets'].find { |target| npc.name =~ /#{target}/ } }
}

wander = proc do
  until checkstance('guarded') || checkstance('defensive')
    fput 'stance defensive'
    sleep 0.25
  end
  start_script 'wander', CharSettings['field-targets'] unless running? 'wander'
  wait_while { running? 'wander' }
end

wait_for_stamina = proc do
  print.call 'waiting for stamina'
  print.call 'no input is required'
  wait_until { percentstamina 80 }
end

get_promoted = proc do |skill|
  print.call 'going to get promoted'

  if Char.prof == 'Rogue'
    go2_nearest_tag.call 'rogue guild master'
  else
    go2_nearest_tag.call 'warrior guild guildmaster'
  end

  npc = GameObj.npcs.find { |obj| obj.name =~ /Guild Master/ }

  error.call 'failed to find guildmaster for promotion' if npc.nil?

  res = dothistimeout("ask ##{npc.id} for next #{skill}", 1, /Congratulations|train a little|before you can be/i)
  error.call "you must diversify your skills to continue in #{skill}" if res =~ /To rise to the top/
end

get_skill_full = proc do |skill|
  error.call 'error, no skill given' if skill.nil?
  error.call "skill #{skill} could not be found" unless skill_short_to_long.include? skill

  skill_short_to_long[skill]
end

find_administrator = proc do
  npc = GameObj.npcs.find { |n| n.name =~ /Training Administrator/ }

  error.call 'failed to find training administrator' if npc.nil?

  npc
end

trade_in = proc do |skill|
  until Room.current.id
    move(XMLData.room_exits.sample)
    sleep(1)
  end
  print.call "trading in task for #{skill}"
  print.call 'you have 5 seconds to kill me'

  sleep 5

  if Char.prof == 'Rogue'
    go2_nearest_tag.call 'rogue guild administrator'
  else
    go2_nearest_tag.call 'warrior guild administrator'
  end

  npc = find_administrator.call

  multifput "ask ##{npc.id} for trade #{skill}", "ask ##{npc.id} for train #{skill}"
end

turn_in = proc do |skill|
  if !(CharSettings['fried']) && checkmind('saturated')
    rest.call(false)
    print.call 'resting your mind before turning in'
    wait_while { percentmind(100) }
    rest_exit.call
  end

  print.call "turning in task for #{get_skill_full.call skill}"

  if Char.prof == 'Rogue'
    go2_nearest_tag.call 'rogue guild administrator'
  else
    go2_nearest_tag.call 'warrior guild administrator'
  end

  npc = find_administrator.call

  multifput "ask ##{npc.id} for train #{skill}", "ask ##{npc.id} for train #{skill}"
end

get_skill_info = proc do |skill|
  done = false
  read = false
  info = {}

  print.call "collecting #{get_skill_full.call(skill)} task information"

  action = proc do |server_string|
    if server_string =~ /You have (no|\d+) ranks? in the #{get_skill_full.call(skill)} skill\./i
      read = true
      info['ranks'] = Regexp.last_match(1).to_i
    end

    # rubocop:disable Layout/LineLength
    if read
      # General stuff
      if server_string =~ /^You need (\d+) training points/
        info['points'] = Regexp.last_match(1).to_i
      elsif server_string =~ /You have earned enough training points/
        info['promoted'] = true
        read = false
      elsif server_string =~ /You have no repetitions|You are not currently training|You have not yet been/
        info['reps'] = 0
        read = false
      elsif server_string =~ /You have (\d+) repetitions? remaining/
        info['reps'] = Regexp.last_match(1).to_i
        read = false
        # Cheapshots
      elsif server_string =~ /The Training Administrator told you to clean the guild windows\./
        info['task'] = 'windows'
      elsif server_string =~ /The Training Administrator told you to stomp some creatures' feet/
        info['task'] = 'footstomp'
      elsif server_string =~ /The Training Administrator told you to tweak some creatures' noses\./
        info['task'] = 'nosetweak'
      elsif server_string =~ /The Training Administrator told you to practice templeshot on some creatures\./
        info['task'] = 'templeshot'
      elsif server_string =~ /The Training Administrator told you to kneecap some creatures\./
        info['task'] = 'kneebash'
      elsif server_string =~ /The Training Administrator told you to poke some creatures in the eyes\./
        info['task'] = 'eyepoke'
      elsif server_string =~ /The Training Administrator told you to practice throatchop on creatures./
        info['task'] = 'throatchop'
      elsif server_string =~ /told you to water the guild plants/
        info['task'] = 'water'
      elsif server_string =~ /The Training Administrator told you to practice defending against footstomps\.|The Training Administrator told you to get lessons in Nosetweak from a master footpad\./
        info['task'] = 'defend'
      elsif server_string =~ /The Training Administrator told you to practice footstomping a partner\./
        info['task'] = 'partner'
      elsif server_string =~ /The Training Administrator told you to sweep the guild courtyard\./
        info['task'] = 'sweep'
        # Gambits
      elsif server_string =~ /The Training Administrator told you to practice your latest trick in front of an audience\./
        info['task'] = 'audience'
      elsif server_string =~ /The Training Administrator told you to visit the master footpads for a lesson\./
        info['task'] = 'footpads'
      elsif server_string =~ /The Training Administrator told you to teach a fellow guildmember something about rogue gambits\./
        info['task'] = 'teach'
      elsif server_string =~ /The Training Administrator told you to get a partner to teach you your latest trick\./
        info['task'] = 'learn'
      elsif server_string =~ /The Training Administrator told you to see how many times you can do your current gambit in one minute\./
        info['task'] = 'speed'
        # Sweep
      elsif server_string =~ /The Training Administrator told you to practice sweeping a partner\./
        info['task'] = 'partner'
      elsif server_string =~ /The Training Administrator told you to practice sweeping creatures\./
        info['task'] = 'creatures'
      elsif server_string =~ /The Training Administrator told you to work out on the sweep dummies\./
        info['task'] = 'dummies'
      elsif server_string =~ /The Training Administrator told you to defend against a partner\./
        info['task'] = 'defend'
      elsif server_string =~ /The Training Administrator told you to get some lessons from the footpads\./
        info['task'] = 'footpads'
        # Lock Mastery
      elsif server_string =~ /The Training Administrator told you to use some decently challenging boxes to practice your latest trick for an audience\./
        info['task'] = 'audience'
      elsif server_string =~ /The Training Administrator told you to calibrate your calipers out in the field\./
        info['task'] = 'calibrate'
      elsif server_string =~ /The Training Administrator told you to put clasps on some containers\./
        info['task'] = 'clasp'
      elsif server_string =~ /The Training Administrator told you to pit your skills against a footpad\./
        info['task'] = 'contest'
      elsif server_string =~ /The Training Administrator told you to customize some lockpicks and keys\./
        info['task'] = 'customize'
      elsif server_string =~ /The Training Administrator told you to cut keys for some locks you make\./
        info['task'] = 'cut'
      elsif server_string =~ /The Training Administrator told you to extract/
        info['task'] = 'extract'
      elsif server_string =~ /The Training Administrator told you to make some good locks\./
        info['task'] = 'lock'
      elsif server_string =~ /The Training Administrator told you to visit a master footpad for a talk./
        info['task'] = 'master'
      elsif server_string =~ /The Training Administrator told you to measure some tough boxes, then pick 'em\./
        info['task'] = 'measure'
      elsif server_string =~ /The Training Administrator told you to melt open some plated boxes\./
        info['task'] = 'melt'
      elsif server_string =~ /The Training Administrator told you to relock some tough boxes\./
        info['task'] = 'relock'
      elsif server_string =~ /The Training Administrator told you to pick some tough boxes from creatures\./
        info['task'] = 'tough'
      elsif server_string =~ /The Training Administrator told you to wedge open some boxes\./
        info['task'] = 'wedge'
        # Stun Maneuvers
      elsif server_string =~ /The Training Administrator told you to let a footpad shoot arrows at you\./
        info['task'] = 'arrows'
      elsif server_string =~ /The Training Administrator told you to visit the footpads for some lessons\./
        info['task'] = 'footpads'
      elsif server_string =~ /The Training Administrator told you to practice (?:defending yourself a little more while stunned|attacking while stunned)\./
        info['task'] = 'practice'
      elsif server_string =~ /The Training Administrator told you to play a few rounds of slap hands with a footpad\./
        info['task'] = 'slaphands'
      elsif server_string =~ /The Training Administrator told you to sweep the guild courtyard\./
        info['task'] = 'sweep'
      elsif server_string =~ /The Training Administrator told you to clean the windows in the guild\./
        info['task'] = 'windows'
        # Subdue
      elsif server_string =~ /The Training Administrator told you to try and subdue some creatures\./
        info['task'] = 'creatures'
      elsif server_string =~ /The Training Administrator told you to ding up a few melons at the subdue mannequins\./
        info['task'] = 'mannequins'
      elsif server_string =~ /The Training Administrator told you to crush up some garlic\./
        info['task'] = 'garlic'
        # Tricks / Warcries
      elsif server_string =~ /The Training Administrator told you to (?:(?:get a)\s)?((?:spiff up|rake|skilled master|scrub|polish))(?:\s(?:the shrubbery|the guild floors|to teach some war cry techniques|the armor in the guild|the guild yard))?\./
        info['task'] = Regexp.last_match(1).to_s.strip
      elsif server_string =~ /The Training Administrator told you to practice (.*) on creatures\./
        info['task'] = 'creatures'
        info['warcry'] = Regexp.last_match(1).to_s.strip
        # Berserk
      elsif server_string =~ /The Training Administrator told you to (?:(?:practice|go practice in the|go visit the|go out and practice Berserk against|get a partner to)\s)?(breaking (?:paralysis|stuns|webs)|saunas|ice tubs|creatures|Balancing|Draw|Spin|Drop-n-Roll|Kick-n-Sheath|Twirl-n-Sheath|Sheath Catch|Weapon Hop|Initial|Weapon Flip|Guzzle|polish|prune|scrub|Spin Attack|Spit|Feint|Juggling|skilled masters|rake|Backflip|Haircut|Toss-n-Slice|teach)(?:\s(?:some shrubbery|some war cry techniques|the floors|the guild yard|the armor around the guild|in the Dark Chamber|for an audience|on a suitable creature))?\./
        info['task'] = Regexp.last_match(1).to_s.strip
        # Disarm
      elsif server_string =~ /The Training Administrator told you to let a partner/
        info['task'] = 'defend'
      elsif server_string =~ /The Training Administrator told you to take a practice (twohanded) weapon and visit the skilled masters./
        info['task'] = 'skilled masters'
        info['type'] = Regexp.last_match(1)
      elsif server_string =~ /The Training Administrator told you to (?:(?:practice disarming(?: a)?|get a lesson from the|let a)\s)?(creatures|skilled masters|partner(?: disarm)?)(?:\s(?:with an?|on disarming|an?) (\w+)(?: weapons?)?)?(?: from you)?\./
        info['task'] = Regexp.last_match(1).to_s.strip
        info['type'] = Regexp.last_match(2).to_s.strip
      elsif server_string =~ /The Training Administrator told you to use a practice (\w+) weapons? with the Wheel\./
        info['task'] = 'wheel'
        info['type'] = Regexp.last_match(1).to_s
      elsif server_string =~ /The Training Administrator told you to practice disarming a partner/
        info['task'] = 'partner'
        # Batter
      elsif server_string =~ /The Training Administrator told you to (?:go )?break (?:up|down) some (old boards|branches|sheet metal)/
        info['task'] = Regexp.last_match(1).to_s
      elsif server_string =~ /The Training Administrator told you to practice on the ((?:wooden|metal) (?:stage door)) in the guild(?: with (?:a|your) (shoulder|weapon))?\./
        info['task'] = Regexp.last_match(1).to_s
        info['weapon'] = Regexp.last_match(2).to_s
      elsif server_string =~ /The Training Administrator told you to bash open some boxes from creatures\./
        info['task'] = 'creatures'
      elsif server_string =~ /The Training Administrator told you to bash some cheap practice boxes\./
        info['task'] = 'practice boxes'
        # Tackle
      elsif server_string =~ /The Training Administrator told you to practice tackling .*(partner|creatures)\./
        info['task'] = Regexp.last_match(1).to_s
      elsif server_string =~ /The Training Administrator told you to practice defending against tackles\./
        info['task'] = 'defend'
      elsif server_string =~ /The Training Administrator told you to work with the skilled masters\./
        info['task'] = 'skilled masters'
      elsif server_string =~ /The Training Administrator told you to work with the tackling dummies\./
        info['task'] = 'dummies'
      elsif server_string =~ /The Training Administrator told you to practice tackling a partner\./
        info['task'] = 'partner'
      end
    end

    if server_string =~ /^You are a (?:member|master)|^You are current with your dues|You currently have \d+|You are not currently training|You have \d+ ranks? in the|You need \d+ training points|The Training Administrator told you|You have \d+ repetitions remaining|You are a Master of|You will need to do/
      nil
    elsif server_string =~ /^Click .*GLD MENU.* for additional commands./
      done = true
      nil
    elsif !server_string.nil? && !server_string.empty? && server_string !~ /\r\n||&gt;/
      server_string
    end
    # rubocop:enable Layout/LineLength
  end

  DownstreamHook.add 'sguild_get_task', action
  $_SERVER_.puts "#{$cmd_prefix}gld\n"
  start = Time.now.to_f
  wait_until { done || (Time.now.to_f - start >= 3.0) }
  DownstreamHook.remove 'sguild_get_task'

  if info['promoted']
    get_promoted.call skill
    get_skill_info.call skill
  elsif info['reps'].zero?
    turn_in.call skill
    get_skill_info.call skill
  else
    info
  end
end

get_tool = proc do |tool|
  next if (checkleft == tool) || (checkright == tool)

  if Char.prof == 'Warrior'
    go2_nearest_tag.call 'warrior guild cleaning supplies'
  else
    go2_nearest_tag.call 'rogue guild tools'
  end

  res = dothistimeout "get #{tool}", 1, /You pick out|You have not been instructed/
  next if res =~ /You have not been instructed/

  error.call "failed to get tool #{tool}" if (checkleft != tool) && (checkright != tool)
end

store_tool = proc do |tool, _room|
  next if (checkleft != tool) && (checkright != tool)

  if Char.prof == 'Warrior'
    go2_nearest_tag.call 'warrior guild cleaning supplies'
  else
    go2_nearest_tag.call 'rogue guild tools'
  end

  dothistimeout "put #{tool} on rack", 1, /You put|You return/

  error.call "failed to store tool #{tool}" if (checkleft == tool) || (checkright == tool)
end

clear_hands = proc do
  tools = %w[bag rake duster brush shears rag broom can]
  weapons = ['two-handed sword']

  next if checkleft.nil? && checkright.nil?

  store_tool.call(checkleft) if tools.include?(checkleft)

  store_tool.call(checkright) if tools.include?(checkright)

  if weapons.include?(checkleft)
    # fput "drop #{checkleft}"
  end

  if weapons.include?(checkright)
    # fput "drop #{checkright}"
  end

  fput 'store all' if checkleft || checkright
  fput 'stow all' if checkleft || checkright
  empty_hands if checkleft || checkright
end

clear_locker = proc do
  next unless CharSettings['locker']

  batter_weapon = CharSettings['batter-weapon']

  if batter_weapon
    waitrt?

    fput "get my #{batter_weapon}" if checkleft !~ /#{batter_weapon}/ && checkright !~ /#{batter_weapon}/

    sleep 0.25
    if checkright =~ /#{batter_weapon}/ || checkleft =~ /#{batter_weapon}/
      visit_locker.call('put', CharSettings['batter-weapon'])
    end
  end
end

get_snack = proc do |type, count|
  error.call 'invalid type: expected drink or food' if type !~ /drink|food/

  snacks = { 'drink' => /lemonade|ale|piledriver|wine|stout|lager/i, 'food' => /sandwich|tart/ }

  snack = snacks[type]
  my_snacks = lootsack.contents.find_all { |i| i.name =~ snack }

  # clear_hands.call

  if count.nil?
    next if checkleft =~ snack || checkright =~ snack

    error.call "your out of snack: #{snack}" if my_snacks.empty?

    fput "get ##{my_snacks.shift.id}"
    next
  end

  go2_nearest_tag.call('warrior guild snacks')

  bar = GameObj.loot.find { |l| l.noun =~ /bar|table|counter/i }

  error.call 'failed to find bar with snacks' if bar.nil?

  fput("look on ##{bar.id}") if bar.contents.nil?

  item = bar.contents.find { |l| l.noun =~ snack }

  error.call "failed to find #{type}" if item.nil?

  (count - lootsack.contents.find_all { |i| i.name == item.name }.length).times do
    done = false
    until done
      res = dothistimeout "get #{item} from ##{bar.id}",
                          1,
                          /You just poured yourself|You just grabbed|You pour yourself|Greedy, greedy/
      if res =~ /Greedy/i
        sleep 5
      else
        done = true
      end
    end
    fput "stow my #{item}"
  end
end

do_task_command = proc do |cmd, extra|
  matches = [
    'You should wait',
    'You have \d+ repetition',
    'have completed',
    'You have already',
    'You have not been instructed'
  ]
  extra = [] if extra.nil?

  res = dothistimeout(cmd, 3, /#{(matches + extra).join('|')}/i)
  res = 'have completed' if res =~ /You have already|You have not been instructed/
  waitrt?
  res
end

partner_do_it = proc do |skill, target|
  fput 'gld stance advance'
  fput 'stance offensive'

  if skill == 'disarm'
    fput('ready weapon')
    wait_while { GameObj.right_hand.id.nil? }
  end

  fput("whisper #{target.name} I am ready.")

  ready = false

  100.times do
    if reget.reverse[0..10].any? { |l| l =~ /#{target.name} whispers, "I am ready\."/i }
      ready = true
      break
    end

    sleep(0.10)
  end

  unless ready
    print.call "failed to find ready status for #{target.name}"
    next
  end

  partner_regex = Regexp.union(
    /#{target.name}[^,]+, "All finished\. Thank you!"/,
    /#{target.name}[^,]+, "I need to give my throat a rest\."/
  )

  start = Time.now.to_i

  while get
    break if target.status =~ /gone/
    break if reget.reverse[0..10].any? { |l| l =~ /have completed/ }

    if reget.reverse[0..10].any? { |l| l =~ partner_regex }
      print.call('partner signaled a change')
      break
    elsif Time.now.to_i - start > 300
      print.call('timeout hit, aborting...')
      break
    end

    waitrt?
    until standing?
      waitrt?
      fput 'stand'
      sleep(0.25)
    end

    case skill
    when 'disarm'
      res = nil
      while res !~ /to the ground/
        wait_for_stamina.call unless checkstamina(7)
        res = do_task_command.call("disarm ##{target.id}", ['to the ground', 'fail to knock', 'is not holding'])
        break if res !~ /is not holding/

        50.times do
          break if get? =~ /#{target.name} picks up|recovers|rises out of the shadows/

          sleep(0.10)
        end
      end
      break if res =~ /completed/
    when 'tackle'
      until target.status !~ /prone/
        fput("pull ##{target.id}")
        sleep(1)
      end

      unless target.status.nil?
        print.call "waiting for #{target.name} status to be cleared"
        wait_until { target.status.nil? }
        next
      end
      wait_for_stamina.call unless checkstamina(7)
      res = do_task_command.call("tackle ##{target.id}")
      break if res =~ /completed/
    end
  end

  put("whisper #{target.name} All finished. Thank you!")
  waitrt?

  clear_hands.call
  fput('gld stance offensive')
  fput('stance defensive')
end

partner_do = proc do |skill|
  if CharSettings['trade-partner']
    print.call "skipping #{skill} because partner trading is enabled"
    trade_in.call(skill)
    next
  end

  partner = CharSettings['partner-name'].strip
  room = CharSettings['partner-room'].to_s.strip

  error.call('You need to setup a partner name first.') if partner.empty?
  error.call('You need to setup a partner room first.') if room.empty?

  unless (target = GameObj.pcs.find { |pc| pc.name == partner })
    print.call "running to #{partner} in room #{room}"
    go2.call CharSettings['partner-room']
    unless (target = GameObj.pcs.find { |pc| pc.name == partner })
      error.call 'failed to find partner'
    end
  end

  print.call "asking #{target.name} for training in #{skill}"
  print.call 'waiting for partner to acknowledge; NOD to skip'

  partner_regex = /^(#{partner} whispers, "Yes\."|You nod\.)$/i

  loop do
    result = dothistimeout "whisper #{target.name} Can you teach me #{skill}?", 10, partner_regex
    break unless result.nil?

    print.call "#{target.name} did not respond, asking again in 5 seconds."
  end

  partner_do_it.call(skill, target)
end

partner_receive_it = proc do |skill, target|
  fput 'gld stance defensive'
  fput 'stance offensive'
  clear_hands.call

  if skill == 'disarm'
    fput('ready weapon')
    wait_while { GameObj.right_hand.id.nil? }
  end

  fput("whisper #{target.name} I am ready.")

  ready = false

  100.times do
    if reget.reverse[0..10].any? { |l| l =~ /#{target.name} whispers, "I am ready\."/i }
      ready = true
      break
    end

    sleep(0.10)
  end

  unless ready
    print.call "failed to find ready status for #{target.name}"
    next
  end

  partner_regex = Regexp.union(
    /#{target.name}[^,]+, "All finished\. Thank you!"/,
    /#{target.name}[^,]+, "I need to give my throat a rest\."/
  )

  start = Time.now.to_i

  while (line = get)
    break if target.status =~ /gone/
    break if reget.reverse[0..10].any? { |l| l =~ /have completed/ }

    if reget.reverse[0..10].any? { |l| l =~ partner_regex }
      print.call('partner signaled a change')
      break
    elsif Time.now.to_i - start > 300
      print.call('timeout hit, aborting...')
      break
    end

    waitrt?

    case skill
    when 'disarm'
      wait_until { GameObj.right_hand.id }
    when 'tackle'
      fput('stand') until standing?
    when 'warcries'
      if line =~ /#{target.name} whispers, "I need another lesson please\."/
        start = Time.now.to_i
        fput "#{cmd} teach ##{target.id}"
      elsif line =~ /#{target.name} is busy concentrating/
        fput("whisper #{target.name} You are currently already learning. Waiting 15 seconds and trying again.")
        sleep(15)
      elsif line =~ /You don't know enough about/
        fput("whisper #{target.name} Sorry I am unable to teach you.")
        break
      end
    end
  end

  put("whisper #{target.name} All finished. Thank you!")
  waitrt?

  until standing?
    waitrt?
    fput 'stand'
    sleep 0.25
  end

  wait_until { GameObj.right_hand.id } if skill == 'disarm'

  print.call "done teaching #{skill} to #{target.name}"
  clear_hands.call
  fput 'gld stance offensive'
  fput 'stance defensive'
end

partner_receive = proc do |skill|
  if CharSettings['trade-partner']
    print.call "skipping #{skill} because partner trading is enabled"
    trade_in.call(skill)
    next
  end

  partner = CharSettings['partner-name'].strip
  room = CharSettings['partner-room'].to_s.strip

  error.call('You need to setup a partner name first.') if partner.empty?
  error.call('You need to setup a partner room first.') if room.empty?

  unless (target = GameObj.pcs.find { |pc| pc.name == partner })
    print.call "running to #{partner} in room #{room}"
    go2.call CharSettings['partner-room']
    unless (target = GameObj.pcs.find { |pc| pc.name == partner })
      error.call 'failed to find partner'
    end
  end

  print.call "asking #{target.name} for training in #{skill}"
  print.call 'waiting for partner to acknowledge; NOD to skip'

  partner_regex = /^(#{partner} whispers, "Yes\."|You nod\.)$/i

  loop do
    result = dothistimeout "whisper #{target.name} Can I teach you #{skill}?", 10, partner_regex
    break unless result.nil?

    print.call "#{target.name} did not respond, asking again in 5 seconds."
  end

  partner_receive_it.call(skill, target)
end

partner_mode = proc do
  print.call 'partner mode activated'
  while (line = get)
    if line =~ /(\w+) whispers, "Can you teach me (\w+)\?"/i
      partner = Regexp.last_match(1).to_s
      skill = Regexp.last_match(2).to_s

      print.call("partner receive request from #{partner} for #{skill}")

      unless (target = GameObj.pcs.find { |pc| pc.name == partner })
        error.call('failed to find target')
      end

      fput "whisper #{target.name} Yes."

      partner_receive_it.call(skill, target)
      print.call 'partner mode resuming'
    elsif line =~ /(\w+) whispers, "Can I teach you (\w+)\?"/i
      partner = Regexp.last_match(1).to_s
      skill = Regexp.last_match(2).to_s

      print.call("partner do request from #{partner} for #{skill}")

      unless (target = GameObj.pcs.find { |pc| pc.name == partner })
        error.call('failed to find target')
      end

      fput "whisper #{target.name} Yes."

      partner_do_it.call(skill, target)
      print.call 'partner mode resuming'
    end
  end
end

do_path_task = proc do |task|
  res = tag = tools = action = nil

  case task
  when 'polish'
    delay = 300
    tools = %w[rag]
    tag = 'warrior guild armor'
    action = proc { do_task_command.call 'rub armor', nil }
  when /prune|spiff up/
    delay = 300
    tools = %w[shears]
    tag = 'warrior guild shrubbery'
    action = proc do
      if (obj = GameObj.loot.find { |l| l.name =~ /bush|hedge|shrub|topiar/i })
        do_task_command.call "prune ##{obj.id}", nil
      end
    end
  when 'rake'
    tag = 'warrior guild leaves'
    tools = %w[rake bag]
    action = proc do
      while GameObj.loot.find { |l| l.name =~ /leaves/i }
        fput 'pull my rake'
        waitrt?
      end
      pile = GameObj.loot.find { |l| l.name =~ /pile/i }
      next if pile.nil?

      res = dothistimeout "get ##{pile.id}", 5, /You gather a leaf pile/

      error.call "unknown leaf result: #{res}" if res !~ /You gather a leaf pile/

      res = dothistimeout 'look in my bag', 5, /The bag is full of leaves|nothing|more/
      if res =~ /The bag is full of leaves/
        print.call 'turning in leaves'
        go2_nearest_tag.call 'warrior guild cleaning supplies'
        res = do_task_command.call('put my bag in bin', nil)
      end

      res
    end
  when 'scrub'
    delay = 300
    tools = %w[brush]
    tag = 'warrior guild floor'
    action = proc do
      fput 'kneel'
      do_task_command.call 'clean floor', nil
    end
  when 'sweep'
    delay = 300
    tools = %w[bag broom]
    tag = 'rogue guild dirt'
    action = proc do
      while GameObj.loot.find { |l| l.name =~ /dirt/i }
        res = dothistimeout 'push my broom', 5, /You sweep up some dirt|There is no dirt here to sweep/
        break if res =~ /There is no dirt/

        waitrt?
      end
      pile = GameObj.loot.find { |l| l.name =~ /pile/i }
      next if pile.nil?

      res = dothistimeout "get ##{pile.id}", 5, /You gather a dirt pile|You don't see a dirt pile/

      error.call 'unknown dirt result' if res.nil?

      res = dothistimeout 'look in my bag', 5, /The bag is full of dirt|nothing|more/
      if res =~ /The bag is full of dirt/
        print.call 'turning in dirt'
        go2_nearest_tag.call 'rogue guild tools'
        res = do_task_command.call('put my bag in bin', nil)
      end

      res
    end
  when 'water'
    delay = 60
    tools = %w[can]
    tag = 'rogue guild plant'
    action = proc do
      if (obj = GameObj.loot.to_a.concat(GameObj.room_desc).find do |l|
            l.name =~ /begonias|rose|wildflower|irises|dandelions|iceflower/i
          end)
        fput('kneel') until kneeling?
        res = do_task_command.call("water ##{obj.id}", ["That's enough"])
        waitrt?
        fput('stand') until standing?
        res
      end
    end
  when 'windows'
    delay = 60
    tools = %w[rag]
    tag = 'rogue guild window'
    action = proc do
      if (obj = GameObj.loot.to_a.concat(GameObj.room_desc).find { |l| l.name =~ /window/i })
        res = do_task_command.call "rub ##{obj.id}",
                                   ["That's enough cleaning for this", 'You don\'t need to do that just now.']
      end
    end
  end

  error.call "path task #{task} not implemented" if action.nil?

  rooms = get_nearest_rooms_by_tag.call(tag)
  current = 0

  error.call "failed to find rooms for path task #{task}" if rooms.nil?

  while res !~ /completed|finished/
    room = rooms[current]
    current += 1
    need_tools = false

    tools.each { |tool| get_tool.call tool }

    waitrt?

    # need to store the tool to get in other location
    if Room.current.location != Room[room].location
      tools.each { |tool| store_tool.call tool }
      need_tools = true
    end

    go2.call(room)

    tools.each { |tool| get_tool.call tool } if need_tools

    res = action.call

    # for sweep/rake we just reset the loop
    if ((task == 'rake') || (task == 'sweep')) && (current >= rooms.length)
      if Char.prof == 'Warrior'
        go2_nearest_tag.call('warrior guild cleaning supplies')
      else
        go2_nearest_tag.call('rogue guild tools')
      end

      fput('put my bag in bin')
      current = 0
    end

    if res !~ /completed|finished/ && (current >= rooms.length)
      rest.call(false)

      if CharSettings['loop-no-reset']
        print.call 'exiting because loop-no-reset is true'
        exit
      end

      current = 0
      print.call "waiting #{delay} seconds for reset"
      print.call 'no input is required'

      start = delay
      loop do
        start -= 1
        break if start <= 0

        print.call "still waiting #{start} seconds for guild to reset" if (start % 30).zero?

        sleep(1)
      end
    end

    waitrt?
  end

  tools.each { |tool| store_tool.call tool }
end

do_berserk = proc do
  print.call 'running berserk routine'

  info = get_skill_info.call 'berserk'
  berserking = false
  done = false

  can_berserk = proc do
    !get_field_targets.call.empty? && GameObj.loot.find { |l| l.noun =~ /disk/ && l.name !~ /#{Char.name}/ }.nil?
  end

  go_berserk = proc do |field|
    loop do
      unless berserking
        while (!checkstance 'defensive') && (!checkstance 'guarded')
          result = dothistimeout 'stance defensive', 5, /You are now in a/

          break if result =~ /You are now in a/
        end

        while !field || can_berserk.call
          waitrt?

          unless checkstamina 20
            finish_field.call if field

            wait_for_stamina.call

            prepare_field.call if field
          end

          res = dothistimeout 'berserk', 1, /Everything around you|Roundtime|You scream with a maniacal/
          break if res =~ /Everything around you|You scream with a maniacal/

          sleep(Regexp.last_match(1).to_i - 1) if res =~ /Roundtime: (\d+) sec/
        end

        berserking = true
      end

      line = get

      if line =~ /You have completed/ || reget.find { |l| l =~ /You have completed/ } ||
         CharSettings['wounded'].call
        done = true
        break
      elsif line =~ /The redness fades from the world/
        berserking = false
        break if field
      end
    end

    sleep 3 while berserking && dothistimeout('stop berserk', 1, /You try to regain control/)

    run_looter.call

    berserking = false
  end

  do_field_berserk = proc do
    until done
      wander.call

      go_berserk.call true if can_berserk.call && !done

      sleep 0.25
    end

    finish_field.call
  end

  do_reps = proc do |cmd|
    loop do
      res = dothistimeout cmd, 1, /You try to|You splash|start berserking/
      break if res =~ /start berserking/

      waitrt?
    end

    go_berserk.call
    until standing?
      waitrt?
      fput 'stand'
      sleep 0.25
    end
    fput XMLData.room_exits.sample

    rest.call
  end

  unless percentstamina 80
    rest.call(false)
    wait_for_stamina.call
  end

  rest_exit.call

  case info['task']
  when 'creatures'
    print.call 'doing field reps'
    prepare_field.call
    do_field_berserk.call
    finish_field.call
  when 'ice tubs'
    print.call 'practicing in ice tubs'
    go2_nearest_tag.call 'warrior guild icetub'
    fput 'go tub'
    do_reps.call 'splash'
  when 'saunas'
    print.call 'practicing in sauna'
    go2_nearest_tag.call 'warrior guild sauna'

    room = (GameObj.room_desc + (GameObj.loot || [])).find { |l| l.noun =~ /sauna|spring/ }
    fput "go ##{room.id}"
    do_reps.call 'meditate'
  when /breaking (?:paralysis|stuns|webs)/
    print.call 'practicing breaking stuns'

    go2_nearest_tag.call 'warrior guild dark attendant'
    fput 'kneel'
    go_berserk.call
  else
    error.call "unknown task #{info['task']} for berserk"
  end
end

rest_vocal_cords = proc do
  if CharSettings['loop-no-vocal']
    print.call 'exiting because loop-no-vocal is true'
    exit
  end

  rest.call

  loop do
    if CharSettings['loop'] && (percentmind < CharSettings['loop-mind'].to_i)
      print.call 'exiting because mind is below loop threshold'
      exit
    end

    res = dothistimeout 'warcry', 5, /Your vocal cords are in perfect condition\./
    if res =~ /Your vocal cords/
      rest_exit.call
      break
    else
      print.call 'vocal cords are not ready yet'
    end

    sleep 30
  end
end

get_disarm_weapon = proc do
  info = get_skill_info.call 'disarm'

  type_to_user_weapon = { 'brawling' => 'brawling', 'polearms' => 'polearm', 'edged' => 'edged' }

  weapon = CharSettings["weapon-#{type_to_user_weapon[info['type']]}"]

  get_weapon.call(weapon)
end

do_field = proc do |cmd, req_stamina|
  target = nil
  started = false
  last_action = Time.now.to_i

  loop do
    # let creatures despawn in case of hangups
    if started && ((Time.now.to_i - last_action) > 60)
      finish_field.call
      print.call 'letting critter area despawn (5 minutes)'
      print.call 'no input is required'
      sleep 300
      prepare_field.call
      last_action = Time.now.to_i
    end

    unless checkstamina req_stamina
      finish_field.call
      wait_for_stamina.call
      prepare_field.call
    end

    wander.call if target.nil?

    started = true

    targets = get_field_targets.call
    if (targets.length > 1) || (GameObj.targets.length > 1)
      target = nil
      next
    end

    target = targets.first

    until standing?
      waitrt?
      fput('stand')
      sleep 0.25
    end

    # special subdue handling
    case cmd
    when /sweep/i
      sleep(0.25)
      next unless target.status !~ /prone/
    when /subdue/i
      loop do
        unless hidden?
          until checkstance('defensive')
            fput('stance defensive')
            sleep(0.25)
          end
          fput('hide')
        end
        break if hidden?

        waitrt?
      end
    when /stunman attack/
      # special stunman attack handling
      fput(CharSettings['stun-command']) unless stunned?
    end

    if cmd =~ /disarm|subdue|tackle|cheapshot|sweep/i
      until checkstance('offensive')
        fput('stance offensive')
        sleep(0.25)
      end
    end

    waitrt?

    if cmd =~ /stunman attack/
      put format(cmd, "##{target.id}")
    else
      fput format(cmd, "##{target.id}")
    end

    waitrt?

    done = false

    reget.reverse[0..25].each do |line|
      if line =~ /You have completed/ || CharSettings['wounded'].call
        done = true
        break
      elsif line =~ /Your mouth is too dry at the moment\./
        last_action = Time.now.to_i
        fput 'stance defensive' until checkstance('defensive')
        delay = 5
        print.call "waiting #{delay} seconds for mouth to moisten"
        print.call 'no input is required'

        sleep delay
      elsif line =~ /is not holding a weapon|is already prone/
        print.call('waiting for target to stand up')
        wait_until do
          (GameObj.npcs.find_all { |npc| npc.type =~ /aggressive/i }.length > 1) || target.status.nil? ||
            target.status !~ /prone/i
        end
      elsif line =~ /You need to give your vocal cords a bit of a rest!/
        rest_vocal_cords.call
        done = true
        break
      elsif line =~ /You haven't learned how to disarm without a weapon!/
        last_action = Time.now.to_i
        get_disarm_weapon.call
      else
        last_action = Time.now.to_i
      end

      if cmd =~ /warcry/
        print.call 'sleeping 10 seconds to rest vocal chords'
        sleep 10
      end
    end

    break if done
  end
  fput('stance defensive') until checkstance 'defensive'
end

do_disarm = proc do
  print.call 'running disarm routine'
  info = get_skill_info.call 'disarm'

  type_to_practice_weapon = { 'brawling' => 'club', 'polearms' => 'halberd', 'edged' => 'broadsword' }

  disarm = proc do |weapon, target, stamina|
    loop do
      if GameObj.loot.find { |l| l.name =~ /#{weapon}/i } && checkleft !~ /#{weapon}/ && checkright !~ /#{weapon}/
        waitrt?
        fput "get #{weapon}"
      end

      wait_for_stamina.call unless checkstamina(stamina)

      fput 'stance offensive' until checkstance('offensive')
      res = do_task_command.call("disarm #{target}", ['is not holding a weapon', 'broken workout wheel'])

      break if res =~ /completed/

      if res =~ /is not holding/
        waitrt?
        fput 'stance defensive' until checkstance('defensive')
        waitfor 'stoops and picks up', 'picks a'
      elsif res =~ /The broken workout wheel/
        waitrt?
        fput 'fix wheel'
      end

      waitrt?
      sleep 0.10
    end
  end

  case info['task']
  when 'defend'
    partner_receive.call('disarm')
  when 'partner'
    partner_do.call('disarm')
  when 'creatures'
    print.call "disarming creatures with #{info['type']}"
    if CharSettings['field-trade']
      trade_in.call('disarm')
      next
    end
    clear_hands.call

    prepare_field.call
    get_disarm_weapon.call

    do_field.call('disarm %s', 12)

    finish_field.call

    clear_hands.call
  when 'wheel'
    print.call 'disarm the wheel'
    go2.call 'warrior guild wheel'

    move 'go wheel'

    weapon = type_to_practice_weapon[info['type']]

    res = dothistimeout "get #{weapon}", 5, /You reach out and grab/
    error.call "failed to get #{weapon.inspect} for training: " + res.inspect if res !~ /You reach out/

    disarm.call(weapon, 'wheel', 12)

    waitrt?
    fput "drop #{weapon}"
    fput 'out'
  when 'skilled masters'
    print.call 'lessons from skilled masters'
    go2.call 'warrior guild masters'

    clear_hands.call
    wait_until { GameObj.npcs.length.positive? }
    npc = GameObj.npcs.first
    res = dothistimeout "ask ##{npc.id} for training disarm", 60, /Disarm Weapon/

    error.call 'unknown disarm result' if res.nil?

    weapon = type_to_practice_weapon[info['type']]

    res = dothistimeout "get #{weapon}", 5, /You reach out and grab/
    error.call "failed to get #{weapon.inspect} for training: #{res.inspect}" if res !~ /You reach out/

    disarm.call(weapon, "##{npc.id}", 12)

    waitrt?
    fput "drop #{weapon}"
    fput 'out'
  else
    error.call "task #{info['task']} not yet implemented"
  end
end

do_warcries = proc do
  print.call 'running warcries routine'
  info = get_skill_info.call 'warcries'

  warcry_map = {
    'Bertrandt\'s Bellow' => 'bellow',
    'Gerrelle\'s Growl' => 'growl',
    'Yertie\'s Yowlp' => 'yowlp',
    'Seanette\'s Shout' => 'shout',
    'Carn\'s Cry' => 'cry',
    'Horland\'s Holler' => 'holler'
  }

  case info['task']
  when /spiff up|polish|rake|scrub/
    print.call 'doing busy work'
    do_path_task.call(info['task'])
    next
  when 'creatures'
    print.call 'warcry creatures'

    prepare_field.call
    do_field.call("warcry #{warcry_map[info['warcry']]} %s", 0)
    finish_field.call
  when 'teach'
    # rubocop:disable Layout/LineLength
    wait_on_partner_confirmation.call(CharSettings['partner-name'], 'Can you teach me warcries?')
    while (line = get)
      if line =~ /#{CharSettings['partner-name']} pulls you aside and demonstrates how (.*) is done\./i
        warcry = Regexp.last_match(1).to_s
        break
      elsif line =~ /#{CharSettings['partner-name']} whispers, "Sorry I am unable to teach you\. You either have more skill ranks than I do or you have the same amount but are a higher level\."/i
        error.call 'partner is not experienced enough to teach you'
      end
    end
    # rubocop:enable Layout/LineLength

    error.call "failed to find #{warcry} in map" unless warcry_map[warcry]

    warcry = warcry_map[warcry]
    count = 0
    loop do
      waitrt?
      res = do_task_command.call("warcry #{warcry}", ['a bit of a rest'])

      if res =~ /completed/
        put("whisper #{CharSettings['partner-name']} All finished. Thank you!")
        break
      elsif res =~ /a bit of a rest/
        fput "whisper #{CharSettings['partner-name']} I need to give my throat a rest."
        rest_vocal_cords.call
        break
      end

      print.call 'waiting 10 seconds for vocal chords'
      sleep 10

      count += 1
      next unless count == 8

      fput "whisper #{CharSettings['partner-name']} I need another lesson please."
      count = 0
      sleep 2
    end

    waitrt?
  when 'skilled master'
    go2.call 'warrior guild masters'

    npc = GameObj.npcs.first
    npc_match = /Let me demonstrate|Let me show you|Now I show you|How about I show you/
    res = dothistimeout "ask ##{npc.id} for training warcries", 60, npc_match

    warcry = warcry_map[Regexp.last_match(1)] if res =~ /(#{warcry_map.keys.join('|')})/i

    error.call 'missing warcry command for: ' + Regexp.last_match(1).inspect if warcry.nil?

    loop do
      waitrt?
      res = do_task_command.call('warcry ' + warcry, ['a bit of a rest'])

      break if res =~ /completed/

      next unless res =~ /a bit of a rest/

      fput 'out'
      rest_vocal_cords.call
      break
    end

    waitrt?
    fput 'out'
  else
    error.call "task #{info['task']} not yet implemented"
  end
end

get_batter_weapon = proc do
  locker = CharSettings['locker']
  weapon = CharSettings['batter-weapon']

  next if checkright =~ /#{weapon}/

  if checkleft =~ /#{weapon}/
    waitrt?
    fput 'swap'
    next
  end

  fput "get my #{weapon}"
  sleep 0.25

  if checkright !~ /#{weapon}/ && checkleft !~ /#{weapon}/
    error.call "failed to find #{weapon} and locker is not set" if locker.nil? || !locker

    print.call "your batter weapon is not on you so let's go get it"
    print.call 'you have 3 seconds to kill me'
    sleep 3

    visit_locker.call('get', weapon)
  end

  error.call "failed to find #{weapon} in inventory or locker" if checkright !~ /#{weapon}/ && checkleft !~ /#{weapon}/

  if checkleft =~ /#{weapon}/
    waitrt?
    fput 'swap'
    next
  end

  weapon
end

do_batter_thing = proc do |thing|
  obj = nil
  holding = false

  if (thing == 'right') && checkright
    obj = GameObj.right_hand
    holding = true
  end

  if (thing == 'left') && checkleft
    obj = GameObj.left_hand
    holding = true
  end

  obj = GameObj.loot.find { |l| l.noun =~ /#{thing}/ || l.name =~ /#{thing}/ } if obj.nil?

  error.call "failed to find #{thing} to bash" if obj.nil?

  get_batter_weapon.call

  print.call "bashing #{obj.name}, you have 3 seconds to kill me"
  sleep 3

  if holding
    fput 'swap' if GameObj.right_hand.id == obj.id

    fput "drop ##{obj.id}"
  end

  loop do
    waitrt?

    if Spell['Surge of Strength'].known? && Spell['Surge of Strength'].affordable? &&
       !Spell['Surge of Strength'].active?
      fput 'cman surge'
      waitcastrt?
    end

    res = dothistimeout "batter ##{obj.id}", 5, /You bash at the|In a shower of splinters/
    break if res =~ /In a shower of splinters/
  end
end

do_tackle = proc do
  print.call 'running tackle routine'
  info = get_skill_info.call 'tackle'

  tackle = proc do |target|
    fput 'gird'

    loop do
      wait_until { checkstamina(9) }

      waitrt?

      until checkstance('defensive')
        fput 'stance defensive'
        sleep 0.25
      end

      wait_until { target.status !~ /prone/i } if target.instance_of?(GameObj)

      until standing?
        waitrt?
        fput 'stand'
        sleep(0.25)
      end

      until checkstance('offensive')
        fput 'stance offensive'
        sleep 0.25
      end

      results = ['is lying on the ground', 'dummy in motion', 'hasn\'t instructed']
      res = do_task_command.call("tackle #{target}", results)

      if res =~ /is lying on the ground/
        fput 'pull dummy'
      elsif res =~ /dummy in motion/
        fput 'push dummy'
      elsif res =~ /hasn't instructed/
        sleep(5)
      end

      break if res =~ /completed/

      sleep(0.25)
    end

    clear_hands.call
  end

  case info['task']
  when 'creatures'
    print.call 'doing field reps'
    if CharSettings['field-trade']
      trade_in.call('tackle')
      next
    end
    prepare_field.call
    do_field.call('tackle %s', 15)
    finish_field.call
  when 'dummies'
    go2.call 'warrior guild dummies'

    fput 'go dummies'
    tackle.call('dummy')
    until standing?
      waitrt?
      fput 'stand'
      sleep 0.25
    end
    fput 'out'
  when 'skilled masters'
    go2.call 'warrior guild masters'

    wait_until { GameObj.npcs.length.positive? }
    npc = GameObj.npcs.first
    npc_match = /let me demonschtrate|let me show you|now I show you|how about I show you|ready\?/i
    res = dothistimeout "ask ##{npc.id} for training tackle", 45, npc_match
    error.call('failed to find NPC response') if res.nil?

    # # get tackled and stand
    # loop do
    #   line = waitfor 'try on me', 'again', 'says'

    #   waitrt?
    #   fput 'stance defensive' until checkstance('defensive')
    #   until standing?
    #     waitrt?
    #     fput 'stand'
    #     sleep 0.25
    #   end

    #   break if line =~ /try on me/
    # end

    # do the tackling
    tackle.call(npc)
    fput 'out'
  when 'defend'
    partner_receive.call('tackle')
  when 'partner'
    partner_do.call('tackle')
  else
    error.call "task #{info['task']} not yet implemented"
  end
end

do_batter = proc do
  print.call 'running batter routine'

  sleep 1

  # format is [rooms (or tag), plural name, single name]
  types = {
    'old boards' => ['warrior guild boards', 'boards$', 'board$'],
    'branches' => ['warrior guild branches', 'branches$', 'branch$'],
    'sheet metal' => [%w[3455 4023 8615], 'stack of sheet metal', 'piece of sheet metal'],
    'practice boxes' => ['warrior guild wooden boxes', 'boxes', 'cheap wooden box'],
    'wooden stage door' => ['warrior guild wooden stage doors', 'wood door', 'wood door'],
    'metal stage door' => ['warrior guild metal stage doors', 'metal door', 'metal door']
  }

  info = get_skill_info.call 'batter'
  type = types[info['task']]

  if info['task'] == 'creatures'
    if CharSettings['batter-trade']
      trade_in.call('batter')
      next
    else
      error.call 'bashing creature boxes must be done manually'
    end
  end

  error.call "failed to find type for #{info['task']}" unless type

  weapon = get_batter_weapon.call

  case info['task']
  when /#{types.keys.join('|')}/
    if type[0].instance_of?(String)
      go2.call type[0]
    else
      room = Room.current.find_nearest(%w[3455 4023 8615])
      _, dist = Map.dijkstra(CharSettings['rest-room'])

      error.call 'room for your town is not yet implemented for batter sheet metal ' if dist[room] > 10

      go2.call room
    end

    action = proc do
      until standing?
        waitrt?
        fput 'stand'
        sleep 0.25
      end

      if type[1] =~ /door/
        clear_hands.call if info['weapon'] == 'shoulder'

        fput "go #{type[1]}" unless checkroom =~ /Door/
        next do_task_command.call "batter #{type[1]}", ['You need \d+ more hit']
      end

      if type[1] != 'boxes'
        stack = GameObj.loot.find { |l| l.name =~ /#{type[1]}/ }

        error.call "failed to find #{type[1]} to pull from" unless stack
      end

      single = GameObj.loot.find { |l| l.name =~ /\b#{type[2]}\b/ }
      unless single
        if type[1] == 'boxes'
          dothistimeout 'get boxes', 5, /You pull/
        else
          dothistimeout "get ##{stack.id}", 5, /You pull/
        end

        single = GameObj.loot.find { |l| l.name =~ /#{type[2]}/ }
      end

      error.call "failed to find #{type[2]} to batter" unless single

      do_task_command.call "batter ##{single.id}", ['You need \d+ more hit']
    end
  end

  loop do
    waitrt?

    if Spell['Surge of Strength'].known? && Spell['Surge of Strength'].affordable? &&
       !Spell['Surge of Strength'].active?
      fput 'cman surge'
      waitcastrt?
    end

    res = action.call

    if res.nil?
      error.call "unknown response for #{info['task']}: #{res}"
    elsif res =~ /completed/
      break
    end
  end

  fput "put my #{weapon} in my #{CharSettings['sheath']}"
  clear_hands.call
  fput 'out'
end

do_tricks = proc do
  print.call 'running tricks routine'

  # set via the masters
  master = false
  master_location = nil

  weapon = CharSettings['audience-weapon']
  sheath = CharSettings['sheath']

  info = get_skill_info.call 'tricks'
  prepare = proc do
    fput "get my #{weapon}"

    go2.call CharSettings['audience-room'] unless master
  end
  finish = proc do
    fput "put my #{weapon} in my #{sheath}"
    clear_hands.call
  end
  action = nil

  clear_hands.call

  do_trick = proc do |trick|
    case trick
    when /toss-n-slice|tslice/i
      print.call 'tossing and slicing'
      prepare = proc do
        unless master
          get_snack.call 'food', info['reps']
          go2.call CharSettings['audience-room']
        end
        fput "get my #{weapon} from my #{sheath}"
      end
      action = proc do
        if master
          fput 'get apple'
        else
          go2.call CharSettings['audience-room']
          get_snack.call 'food'
        end
        do_task_command.call 'wtrick tslice', nil
      end
    when /guzzle/i
      print.call 'guzzling some brew'

      prepare = proc { get_snack.call 'drink', info['reps'] }
      action = proc do
        go2.call CharSettings['audience-room']
        get_snack.call 'drink'
        do_task_command.call 'wtrick guzzle', nil
      end
      finish = proc { }
    when /weapon flip|wflip/i
      print.call 'flipping weapons'
      action = proc { do_task_command.call 'wtrick wflip', nil }
    when /backflip/i
      print.call 'doing backflips'
      action = proc { do_task_command.call 'wtrick backflip', nil }
      finish = proc { fput "put my #{weapon} in my #{sheath}" }
    when /weapon hop|whop/i
      print.call 'hopping weapon'
      action = proc { do_task_command.call 'wtrick whop', nil }
    when /spin attack|sattack/i
      print.call 'spin attack a creature'
      prepare_field.call
      do_field.call('wtrick sattack %s', 25)
      finish_field.call
      next
    when /spin/i
      print.call 'spinning weapon'
      prepare = proc do
        fput "get my #{weapon}"
        go2.call CharSettings['audience-room']
      end
      action = proc { do_task_command.call 'wtrick spin', nil }
    when /drop-n-roll|roll/i
      print.call 'rolling around'
      action = proc { do_task_command.call 'wtrick roll', nil }
    when /kick-n-sheath|ksheath/i
      print.call 'kick & sheath'
      action = proc do
        fput "get my #{weapon}"
        do_task_command.call 'wtrick ksheath', nil
      end
    when /twirl-n-sheath|tsheath/i
      print.call 'twirl & sheath'
      action = proc do
        fput "get my #{weapon}"
        do_task_command.call 'wtrick tsheath', nil
      end
    when /draw/i
      print.call 'draw weapon'
      prepare = proc { go2.call CharSettings['audience-room'] }
      action = proc do
        res = do_task_command.call "wtrick draw #{weapon}", nil

        fput "put my #{weapon} in my #{sheath}" if res !~ /pest/
        sleep 1
        res
      end
    when /balanc/i
      print.call 'balancing weapon'

      master_location = 'palm' if master_location.nil?

      action = proc do
        fput "get my #{weapon}"
        res = do_task_command.call "wtrick balance #{master_location}", nil

        fput 'stop balancing' if res !~ /You should wait/

        res
      end
    when /juggl/i
      print.call 'juggling weapons'

      master_location = '2' if (master_location == 'two') || master_location.nil?

      prepare = proc { go2.call CharSettings['audience-room'] unless master }
      action = proc do
        res = do_task_command.call "wtrick juggle #{master_location}", ["but can't quite get the rhythm"]

        if res =~ /but can't quite get the rhythm/ && GameObj.npcs.none? { |npc| npc.name =~ /^Master at/ }
          print.call 'sleeping 15 seconds so we don\'t cause too much noise'
          sleep 15
        elsif res !~ /pest/
          fput 'stop juggling'
        end

        res
      end
    when /initial/i
      print.call 'writing initials'
      weapon = CharSettings['audience-weapon-small']
      sheath = CharSettings['sheath']

      action = proc { do_task_command.call 'wtrick initial', nil }
    when /sheath catch|catchs/i
      print.call 'sheath catch'
      action = proc { do_task_command.call 'wtrick catchs', nil }
    when /polish|prune|rake|scrub/i
      do_path_task.call info['task']
      next
    when /spit/i
      unless master
        print.call 'spit on a creature'

        prepare_field.call
        do_field.call('wtrick spit %s shirt', 0)
        finish_field.call
        next
      end

      print.call 'spitting on training dummy'
      prepare = proc { }
      action = proc { do_task_command.call "wtrick spit dummy #{master_location}", nil }
      finish = proc { }
    when /feint/i
      unless master
        print.call 'feint a creature'
        prepare_field.call
        do_field.call('wtrick feint %s', 7)
        finish_field.call
        next
      end

      print.call 'feint a master'
      prepare = proc { }
      action = proc { do_task_command.call "wtrick feint ##{GameObj.npcs.first.id}" }
    when /haircut/i
      unless master
        print.call 'haircut a creature'
        prepare_field.call
        do_field.call('wtrick haircut %s', 7)
        finish_field.call
        next
      end

      print.call 'haircut training dummy'
      action = proc { do_task_command.call 'wtrick haircut dummy', nil }
    when /skilled masters/i
      go2.call 'warrior guild masters'

      master = true

      npc = GameObj.npcs.first
      npc_match = /Let me demonstrate|Let me show you|Now I show you|How about I show you/
      dothistimeout "ask ##{npc.id} for training tricks", 3, npc_match

      # check for task for 2 minutes
      1200.times do
        line = get?

        if line =~ /places the handle of .* on (his|her) (palm|finger|foot|chin|nose)/i
          master_location = Regexp.last_match(2)
        elsif line =~ /makes a wet gargling sound and spits .* (shirt|feet|foot|hand|face|eye)/
          master_location = Regexp.last_match(1)
          if master_location =~ /foot/
            master_location = 'left foot'
          elsif master_location =~ /hand/
            master_location = 'left hand'
          elsif master_location =~ /eye/
            master_location = 'left eye'
          end
        elsif line =~ /but just with (two)/
          master_location = Regexp.last_match(1)
        elsif line =~ /Type WTRICK (.*) to practice this trick\./
          do_trick.call(Regexp.last_match(1).to_s)
          break
        elsif line =~ /escorts you back/
          next
        end

        sleep 0.10
      end

      fput 'out'
      next
    else
      error.call "task #{info['task']} not yet implemented"
    end

    wait_pcs = proc do
      pcs = GameObj.pcs.find_all { |pc| pc.status !~ /dead/ }
      if pcs.nil? || (pcs.length < 5)
        print.call 'waiting for more pcs to show up'
        wait_until { GameObj.pcs.find_all { |pc| pc.status !~ /dead/ }.length > 4 }
      end
    end

    prepare.call

    while (res = action.call)
      waitrt?

      if res.nil?
        error.call "unknown response for #{info['task']}: #{res}"
      elsif reget.reverse[0..15].any? { |l| l =~ /completed/i }
        break
      elsif res =~ /You should wait (\d+)/
        time = Regexp.last_match(1).to_i
        go2.call(CharSettings['rest-room'])
        print.call "waiting #{time} seconds to perform trick"
        sleep(time)
        go2.call CharSettings['audience-room'] unless master
      end

      wait_pcs.call unless master
    end

    waitrt?
    finish.call
  end

  do_trick.call(info['task'])
end

do_cheapshots = proc do
  print.call 'running cheapshots routine'
  info = get_skill_info.call 'cheapshots'

  case info['task']
  when 'defend'
    partner_receive.call('cheapshots')
  when /footstomp|eyepoke|nosetweak|templeshot|kneebash|eyepoke|throatchop|swiftkick/
    print.call "doing #{info['task']} field reps"
    prepare_field.call
    do_field.call("cheapshot #{info['task']}", 10)
    finish_field.call
  when 'partner'
    partner_do.call('cheapshots')
  when 'sweep'
    print.call 'sweeping the courtyard'
    do_path_task.call 'sweep'
  when 'water'
    print.call 'watering plants'
    do_path_task.call 'water'
  when 'windows'
    print.call 'cleaning windows'
    do_path_task.call 'windows'
  else
    error.call "task #{info['task']} not yet implemented"
  end
end

do_lmas = proc do
  print.call 'running lock mastery routine'
  info = get_skill_info.call 'lmas'

  error.call 'you need the sbox companion script for lock mastery' unless Script.exists?('sbox')

  Script.run('sbox', 'load')

  get_ranks = proc do
    match = /You have (\d+) ranks? in the Lock Mastery skill\./
    res = dothistimeout('gld', 5, match)
    error.call('Failed to find Lock Mastery ranks') unless res

    res =~ match
    ranks = Regexp.last_match(1).to_i
    ranks >= 25 ? 25 : ranks + 1
  end

  run_sbox = proc do |room, settings|
    if info['task'] == 'wedge'
      get_ranks.call
      res = waitfor(['At least \d+', 'You have'])
      error.call('Failed to find wedge response') unless res

      if res =~ /At least (\d+)/
        plated = Regexp.last_match(1)
        left = Regexp.last_match(1) if waitfor('You have') =~ /You have (\d+)/
        settings[:tough_wedge_reps] = left > plated
      else
        settings[:tough_wedge_reps] = true
      end
    end

    until standing?
      waitrt?
      fput 'stand'
      sleep 0.25
    end

    go2.call(room)

    # SBox uses a global for single run overrides
    $sbox_settings = settings

    Script.start('sbox', 'pool')
    wait_until { Script.running?('sbox') }

    loop do
      break if reget.reverse[0..25].any? { |l| l =~ /\[You have completed/ }
      break if info['task'] == 'wedge' && reget.reverse[0..25].any? { |l| l =~ /\[You have \d repetition/ }

      error.call('picker crashed') unless Script.running?('sbox')
      sleep(1)
    end

    Script.kill('sbox') if Script.running?('sbox')
    wait_while { Script.running?('sbox') }
    waitrt?
    Room.current.tags.find { |t| t =~ /meta:boxpool:npc:(.*)/ }
    if (npc = GameObj.npcs.find { |n| n.name == Regexp.last_match(1) }).nil?
      error.call('Failed to find locksmith NPC')
    end

    fput "ask ##{npc.id} for check"
    fput "ask ##{npc.id} for check"
  end

  case info['task']
  when 'audience'
    if CharSettings['trade-audience']
      print.call 'skipping tough audience reps because audience trading is enabled'
      trade_in.call('lock mastery')
      next
    end
    print.call 'lock mastery trick in front of audience'

    dothistimeout('lmas', 5, /Where {trick} is one of the following/)
    line = reget.reverse[0..10].any? do |l|
      l =~ /(SPIN|TWIST|TURN|TWIRL|TOSS|BEND|FLIP)/
    end

    error.call('failed to find LMASTERY trick') if line.nil?

    run_sbox.call(
      CharSettings['pool-audience-room'],
      {
        command: "lmaster ptrick #{Regexp.last_match(1).downcase} $B",
        audience_reps: true
      }
    )
  when 'calibrate'
    run_sbox.call(CharSettings['pool-room'], { calibrate_count: 1 })
  when 'clasp'
    error.call 'you must set a clasp-container' unless CharSettings['clasp-container']
    cont = CharSettings['clasp-container']
    fput("get my #{cont}")

    unless [GameObj.left_hand.name, GameObj.right_hand.name].include?(cont)
      error.call 'failed to find your clasp-container'
    end

    SBox.load_menu
    clasp = $sbox_data.menu.find { |m| m[:name] =~ /#{name}/ }
    error.call "Unable to find clasp with descriptor #{name}" unless clasp

    SBox.withdraw(clasp[:price] * info['reps'])
    SBox.go2_toolbench

    loop do
      fput("get my #{cont}") unless [GameObj.left_hand.name, GameObj.right_hand.name].include?(cont)

      container = GameObj.right_hand
      container = GameObj.left_hand if GameObj.right_hand.id.nil?

      if container.id.nil?
        preset('You need to be holding the container to clasp in your hand.')
        return
      elsif GameObj.right_hand.id && GameObj.left_hand.id
        preset('You need at least one free hand available to clasp.')
        return
      end

      res = dothistimeout("lmas clasp check ##{container.id}", 3, /Clasp at will!|That already has a clasp/)
      if res.nil?
        preset("#{container.name} is not eligible for clasping.")
        return
      end

      if res =~ /That already has a clasp/
        res = dothistimeout("lmas clasp remove ##{container.id}", 3, /You carefully look over your/)
        error.call 'Unknown lmas clasp remove response' if res.nil?

        waitrt?

        res = dothistimeout("lmas clasp remove ##{container.id}", 3, /With some/)
        error.call 'Unknown lmas clasp remove response' if res.nil?

        waitrt?
      end

      # Add the hole
      res = dothistimeout("lmas clasp ##{container.id}", 3, /Picking up a punch|You've already/)
      error.call 'Unknown lmas clasp punch response' if res.nil?

      waitrt?

      # Order the item
      SBox.buy(clasp)

      res = dothistimeout("lmas clasp ##{container.id}", 3, /You are about to/)
      raise ScriptError, 'Unknown lmas clasp start response' if res.nil?

      waitrt?

      res = dothistimeout("lmas clasp ##{container.id}", 3, /Selecting a pair of grips/)
      raise ScriptError, 'Unknown lmas clasp confirm response' if res.nil?

      waitrt?

      break if reget.reverse[0..25].any? { |l| l =~ /\[You have completed/ }

      sleep(1)
    end

    waitrt?
    move(XMLData.room_exits.sample)
  when 'contest'
    print.call 'lock mastery picking contest'
    if CharSettings['trade-contest']
      print.call 'skipping because contest trading is enabled'
      trade_in.call('lock mastery')
      next
    end
    wait_while { Script.running?('sbox') }

    unless checkarea =~ /dark corner/i
      go2.call('rogue guild trainer')
      npc = GameObj.npcs.first
      res = dothistimeout "ask ##{npc.id} for training lock mastery", 60, /As an apprentice goes about setting up/
      error.call 'unknown lock mastery footpad result' unless res
    end

    fput("nod at ##{npc.id}")
    wait_until { GameObj.loot.length.positive? }
    Script.run('sbox', 'contest')
    waitrt?
    fput XMLData.room_exits.first if checkarea =~ /dark corner/i
  when 'customize'
    print.call 'customize a lockpick'
    fput("get my brass lockpick from ##{lootsack.id}")
    sleep(1)

    hands = [GameObj.left_hand.name, GameObj.right_hand.name]
    error.call('You need a brass lockpick to use.') unless hands.include?('brass lockpick')

    fput('mark my brass lockpick')

    SBox.withdraw(100 * info['reps'])
    SBox.go2_toolbench

    loop do
      res = dothistimeout('lmas customize clean', 3, /You are attempting to CLEAN/)
      raise ScriptError, 'Unknown clean result' if res.nil?

      waitrt?

      res = dothistimeout('lmas customize clean', 3, /You take a file from the workbench/)
      raise ScriptError, 'Unknown clean2 result' if res.nil?

      waitrt?

      res = dothistimeout('lmas customize edge copper', 3, /You are attempting to edge/)
      raise ScriptError, 'Unknown edge result' if res.nil?

      waitrt?

      res = dothistimeout('lmas customize edge copper', 3, /He wanders in with some copper/)
      raise ScriptError, 'Unknown edge2 result' if res.nil?

      waitrt?

      break if reget.reverse[0..25].any? { |l| l =~ /\[You have completed/ }

      sleep(1)
    end

    waitrt?
    fput("put my brass lockpick in ##{lootsack.id}")
    move(XMLData.room_exits.sample)
  when 'cut'
    print.call 'cutting some keys'
    fput('get my assembly')

    hands = [GameObj.left_hand.name, GameObj.right_hand.name]
    error.call('You need a lock assembly to use.') unless hands.include?('lock assembly')

    SBox.load_menu
    key = $sbox_data.menu.find { |m| m[:name] =~ /key blank/ }
    error.call 'failed to find key' if key.nil?

    SBox.withdraw(key[:price] * info['reps'])
    SBox.go2_toolbench

    loop do
      hands = [GameObj.left_hand.name, GameObj.right_hand.name]
      fput('get my assembly') unless hands.include?('lock assembly')

      assembly = GameObj.right_hand
      assembly = GameObj.left_hand if GameObj.right_hand.id.nil?

      if assembly.id.nil?
        error.call 'You need to be holding the lock assembly to key in your hand.'
      elsif GameObj.right_hand.id && GameObj.left_hand.id
        error.call 'You need at least one free hand available to create a key.'
      end

      SBox.buy(key)

      res = dothistimeout("lmas cut #{source}", 3, /carefully carve out a pattern that matches a/)
      error.call 'Failed to cut key' if res.nil?

      fput('drop my key')

      break if reget.reverse[0..25].any? { |l| l =~ /\[You have completed/ }

      sleep(1)
    end

    waitrt?
    move(XMLData.room_exits.sample)
  when 'extract'
    print.call 'lock mastery extract some components'
    if CharSettings['trade-extract']
      print.call 'skipping because extract trading is enabled'
      trade_in.call('lock mastery')
      next
    end
    run_sbox.call(CharSettings['pool-room'])
  when 'lock'
    base = SBox.tough_lock[:base]
    base_with_mod = (base + ((base * 130) / 100).floor)
    diff = (base_with_mod - 200)
    diff = (diff + ((info['ranks'] * 3) / 4).floor)
    min = ((base_with_mod * 3) / 4).floor

    diff = min if diff < min
    diff = ((diff / 5).floor + 1) * 5

    SBox.go2_toolbench

    # Clear out price just in case
    fput("lmas lock create #{diff * 2}")

    res = dothistimeout("lmas lock create #{diff}", 3, /Certainly sir, that will be ([\d,]+) silvers/)
    error.call 'invalid lock create command' if res.nil?

    res =~ /Certainly sir, that will be ([\d,]+) silvers/
    cost = Regexp.last_match(1).gsub(',', '').to_i

    SBox.withdraw(info['reps'] * cost)
    SBox.go2_toolbench

    # Clear out price just in case
    fput("lmas lock create #{diff * 2}")

    loop do
      waitrt?

      res = dothistimeout("lmas lock create #{diff}", 3, /Certainly sir, that will be ([\d,]+) silvers/)
      error.call 'invalid lock check command' if res.nil?

      res = dothistimeout("lmas lock create #{diff}", 3, /After a short time, you find yourself/)
      error.call 'invalid lock create command' if res.nil?

      waitrt?

      fput('drop my assembly')

      break if reget.reverse[0..25].any? { |l| l =~ /\[You have completed/ }

      sleep(1)
    end

    waitrt?
    move(XMLData.room_exits.sample)
  when 'master'
    relock = proc do
      Script.run('sbox', 'scan')

      lockpick = $sbox_data.lockpicks.max_by(&:mod)
      raise ScriptError, 'failed to find lockpick' unless lockpick

      table = GameObj.loot.find { |obj| obj.noun == 'table' }
      raise ScriptError, 'failed to find table' unless table

      npc = GameObj.npcs.first
      raise ScriptError, 'failed to find npc' unless npc

      loop do
        unless table.contents
          fput "look on ##{table.id}"
          sleep(1)
        end

        box = table.contents.find { |obj| obj.noun == 'box' }
        break unless box

        dothis("get ##{box.id}", /You remove/)
        lockpick.get
        dothis("lmas relock ##{box.id}", /It locks!/)
        waitrt?
        lockpick.store
        res = dothistimeout("give ##{box.id} to ##{npc.id}", 3, /completed|remaining/)
        raise ScriptError, 'failed to find give result' unless res

        break if res =~ /completed/
      end

      move(XMLData.room_exits.sample)
    end

    appraise = proc do
      conditions = %w[
        broken
        miserable
        poor
        damaged
        neglected
        good
        excellent
      ]
      precisions = [
        'detrimental',
        'ineffectual',
        'very inaccurate',
        'inaccurate',
        'somewhat inaccurate',
        'inefficient',
        'unreliable',
        'below average',
        'average',
        'above average',
        'somewhat accurate',
        'favorable',
        'advantageous',
        'accurate',
        'highly accurate',
        'excellent',
        'incredible',
        'unsurpassed'
      ]
      strengths = [
        'flimsy',
        'very weak',
        'weak',
        'below average strength',
        'average strength',
        'above average strength',
        'is strong',
        'is very strong',
        'excellent strength',
        'incredibly strong',
        'astonishingly strong',
        'unsurpassed strength'
      ]

      unless (table = GameObj.loot.find { |l| l.noun == 'table' })
        error.call 'Failed to find table'
      end

      unless table.contents
        res = dothistimeout("look on ##{table.id}", 5, /On the/)
        error.call 'Failed to look at table contents' unless res
      end

      best = nil
      best_score = -999

      table.contents.find_all { |obj| obj.name =~ /lockpick/ }.each do |lockpick|
        fput "get ##{lockpick.id}"
        match = /(#{conditions.join('|')})/i
        res = dothistimeout("lmas appraise ##{lockpick.id}", 5, match)
        error.call 'Failed to get appraise info' unless res

        waitrt?

        # Condition
        res =~ match
        condition_index = conditions.index(Regexp.last_match(1))
        precision_index = -1
        strength_index = -1
        repair_count = 0

        # Precision
        res =~ /(#{precisions.join('|')}).*level of precision/i && precision_index = precisions.index(Regexp.last_match(1))

        # Strength
        res =~ /(#{strengths.join('|')})/i && strength_index = strengths.index(Regexp.last_match(1))

        # Repair count
        res =~ /has never been repaired/ && repair_count = 0
        res =~ /has been repaired about (\d+)/i && repair_count = Regexp.last_match(1).to_i

        # We have 0-index so increment by 1 for math below
        condition_index += 1
        precision_index += 1
        strength_index += 1

        # Final score of the lockpick. Highest wins.
        score = 0

        if repair_count.positive?
          score = (((precision_index * strength_index) / (repair_count + 1)) * condition_index)
        elsif strength_index.positive?
          score = (strength_index * precision_index * condition_index)
        elsif precision_index.positive?
          score = (100 * precision_index * condition_index)
        else
          score = (100 * condition_index)
        end

        print.call("Score: #{score}, Precision: #{precision_index}, Strength: #{strength_index}, Condition: #{condition_index}, Repair: #{repair_count}")

        if score > best_score
          print.call('Found new best lockpick')
          best = lockpick
          best_score = score
        end

        waitrt?
        fput "put ##{lockpick.id} on ##{table.id}"
      end

      error.call('Failed to find best lockpick') if best.nil?

      fput "get ##{best.id}"
      res = dothistimeout("give ##{best.id} to ##{GameObj.npcs.first.id}", 5, /accepts the/)
      error.call 'unknown lockpick give response' unless res
    end

    calibrate = proc do
      dothis('get calipers', /You remove/)
      dothis('lmas calibrate my calipers', /You begin attuning|You make some|You're good/)
      waitrt?
      loop do
        dothis('get calipers', /You remove/) unless [checkright, checkleft].include?('calipers')
        dothis('lmas measure box', /Using your/)
        waitrt?
        dothis('put calipers on table', /You place your/)
        dothis('get lockpick', /You remove/)
        dothis('pick box', /You settle/)
        waitrt?
        dothis('put lockpick on table', /You place your/)
        dothis('get calipers', /You remove/)
        dothis('lmas calibrate my calipers', /You begin attuning|You make some|You're good/)
        waitrt?
        res = do_task_command.call("give calipers to ##{npc.id}", ['This still needs some'])
        next unless res =~ /completed/

        waitrt?
        fput XMLData.room_exits.sample
        break
      end
    end

    measure = proc do
      dothis('get calipers', /You remove/)
      loop do
        fput 'lmas measure box'

        if waitfor('Measuring carefully') =~ /Measuring carefully, it looks to be an? (.*) lock/
          res = do_task_command.call("'#{Regexp.last_match(1).downcase}", nil)
          break if res =~ /completed/
        end

        waitrt?
      end

      waitrt?
      fput XMLData.room_exits.sample
    end

    make_wedges = proc do
      waitrt?

      fput 'gld'
      waitfor('in the Lock Mastery')
      waitfor('told you to visit')
      res = waitfor('You have')
      error.call('Failed to find required reps') unless res =~ /You have (\d+) repetitions?/

      fput XMLData.room_exits.sample
      $sbox_settings = {
        wedge_amount: Regexp.last_match(1).to_i,
        wedge_quality: $sbox_data.guild_rank < 16 ? 'warped' : 'solid'
       }
      Script.run('sbox', 'makewedges')
      go2.call('rogue guild trainer')
      npc = GameObj.npcs.first
      res = dothistimeout "ask ##{npc.id} for training lock mastery", 60, /gots a wedge for me/
      error.call("Couldn't get NPC response") unless res
    end

    go2.call('rogue guild trainer')
    npc = GameObj.npcs.first
    footpad_regex = Regexp.union(
      /LMASTER APPRAISE/,
      /LMASTER CALIBRATE/,
      /LMASTER MEASURE/,
      /LMASTER RELOCK/,
      /make yourself one of these here wedges|gots a wedge for me/,
      /break a pick occasionally/,
      /attach some clasps to containers|keep your containers/,
      /customers locks himself out of his house/,
      /some trap components|property protection devices/,
      /The instructions for how to make lockpicks/,
      /make your own lockpicks/,
      /Now it's time to exercise your creative side/,
      /some lockpicks or keys to show me/
    )
    res = dothistimeout "ask ##{npc.id} for training lock mastery", 60, footpad_regex
    error.call 'unknown lock mastery footpad result' unless res

    # Measuring boxes and speaking aloud
    case res
    when /LMASTER CALIBRATE/
      calibrate.call
    when /LMASTER MEASURE/
      measure.call
    when /LMASTER APPRAISE/
      loop do
        appraise.call
        break if reget.reverse[0..10].any? { |l| l =~ /completed/ }
      end
      fput 'out'
    when /LMASTER RELOCK/
      relock.call
    when /some trap components|property protection devices/
      if CharSettings['trade-footpad']
        print.call 'footpad trading is enabled'
        trade_in.call('lock mastery')
        next
      end
      error.call 'you must fetch some trap components which this script does not handle'
    when /break a pick/
      if CharSettings['trade-footpad']
        print.call 'footpad trading is enabled'
        trade_in.call('lock mastery')
        next
      end
      error.call 'you must repair some broken lockpicks which this script does not handle'
    when /attach some clasps to containers|keep your containers/
      if CharSettings['trade-footpad']
        print.call 'footpad trading is enabled'
        trade_in.call('lock mastery')
        next
      end
      error.call 'you must clasp some containers which this script does not handle'
    when /make wedges/
      if CharSettings['trade-footpad']
        print.call 'footpad trading is enabled'
        trade_in.call('lock mastery')
        next
      end
      error.call 'you must make some wedges which this script does not handle'
    when /customers locks himself out of his house/
      if CharSettings['trade-footpad']
        print.call 'footpad trading is enabled'
        trade_in.call('lock mastery')
        next
      end
      error.call 'you must make some lock assemblies which this script does not handle'
    when /Now it's time to exercise your creative side|some lockpicks or keys to show me/
      if CharSettings['trade-footpad']
        print.call 'footpad trading is enabled'
        trade_in.call('lock mastery')
        next
      end
      error.call 'you must custom some keys or locks which this script does not handle'
    when /The instructions for how to make lockpicks|make your own lockpicks/
      lockpicks = lootsack.contents.find_all { |i| i.name =~ /copper lockpick/ }

      echo lockpicks.inspect

      unless lockpicks.length >= info['reps']
        SBox.load_menu
        bar = $sbox_data.menu.find { |m| m[:name] =~ /bar of copper/ }
        error.call 'Unable to find copper bar' unless bar

        SBox.withdraw(bar[:price] * info['reps'])
        SBox.go2_toolbench

        loop do
          SBox.buy(bar)

          res = dothistimeout('lmas create', 3, /you slowly begin to pare away/)
          raise ScriptError, 'Invalid creation response' if res.nil?

          waitrt?

          fput("put my copper lockpick in ##{lootsack.id}")
          sleep(1)

          lockpicks = lootsack.contents.find_all { |i| i.name =~ /copper lockpick/ }

          print.call("You have #{lockpicks.length} lockpicks created so far.")

          break if lockpicks.length >= info['reps']
        end
      end

      unless checkarea =~ /dark corner/i
        fput('out')
        go2.call('rogue guild trainer')
        npc = GameObj.npcs.first
        res = dothistimeout "ask ##{npc.id} for training lock mastery", 60, /make your own lockpicks/
        error.call 'unknown lock mastery footpad result' unless res
      end

      lockpicks.each do |pick|
        fput("get ##{pick.id}")
        fput("give ##{pick.id} to ##{npc.id}")
        fput("drop ##{pick.id}")
      end

      fput('out')
    when /wedge/
      wedges = lootsack.contents.find_all { |l| l.noun == 'wedge' }
      existing = wedges.collect(&:id)

      loop do
        wedges.each do |wedge|
          fput "get ##{wedge.id} from ##{lootsack.id}"
          res = dothistimeout("give ##{wedge.id} to ##{npc.id}", 5, /make a new one|accepts the|hang onto/)
          error.call('Unknown wedge give result') unless res

          break if reget.reverse[0..25].any? { |l| l =~ /\[You have completed/ }

          fput "put ##{wedge.id} in ##{lootsack.id}"
        end

        break if reget.reverse[0..25].any? { |l| l =~ /\[You have completed/ }

        make_wedges.call
        wedges = lootsack.contents.reject { |w| existing.include?(w.id) }.find_all { |l| l.noun == 'wedge' }
      end
    end
  when 'melt'
    trade_in.call('lock mastery')
  when 'measure', 'tough'
    run_sbox.call(CharSettings['pool-room'], { tough_pick_reps: true })
  when 'relock'
    run_sbox.call(CharSettings['pool-room'], { tough_pick_reps: true, relock: true })
  when 'wedge'
    if CharSettings['trade-wedge']
      print.call 'skipping wedge trading is enabled'
      trade_in.call('lock mastery')
      next
    end
    run_sbox.call(CharSettings['pool-room'], { wedge: true, wedge_quality: 'brittle' })
  else
    error.call "task #{info['task']} not yet implemented"
  end
end

do_gambits = proc do
  print.call 'running gambits routine'
  info = get_skill_info.call 'gambits'
  command = nil
  weapon = nil

  get_gambit = proc do
    error.call('failed to read gambits') if dothistimeout('rgam', 5, /TEACH/).nil?

    unless reget.reverse.any? { |l| l !~ /TEACH/ && l =~ /^\s+([A-Z]+)\s*(?:\[?([^\]]+)\]?)?/ }
      error.call('failed to find gambit command')
    end

    cmd = Regexp.last_match(1).downcase.strip unless Regexp.last_match(2)
    cmd = "#{Regexp.last_match(1).downcase.strip} #{Regexp.last_match(2).split(' | ').last}" if Regexp.last_match(2)

    weapon = CharSettings['audience-weapon-small']
    error.call('You must set your audience-weapon-small for gambits') unless weapon

    if cmd =~ /^dagger|^display/
      get_weapon.call(weapon)
      cmd = "#{cmd} #{weapon}" if cmd =~ /^display/
    end

    cmd = "#{cmd} #{weapon} from my #{CharSettings['sheath']}" if cmd =~ /^get/

    if cmd =~ /^vanish/
      get_weapon.call(weapon)
      cmd = "#{cmd} #{weapon} in my #{CharSettings['sheath']}"
    end

    cmd
  end

  do_gambit = proc do
    was_automatic = false
    if command =~ /^automatic/
      was_automatic = true
      if XMLData.room_title =~ /A Dark Corner/ && GameObj.loot.nil?
        fput("get my #{weapon} from my #{CharSettings['sheath']}")
        fput("drop my #{weapon}") if GameObj.right_hand.id
        command = "stealth get #{weapon}"
      else
        command = "stealth get ##{GameObj.loot.first.id}"
      end
    end

    if command =~ /^stealth/
      fput('stance offensive') unless checkstance('offensive')

      if command =~ /^stealth (?:sit|kneel)/ && !standing?
        until standing?
          fput('stand')
          waitrt?
        end
      end

      if command =~ /^stealth stand/ && !kneeling?
        until hidden?
          fput('hide')
          waitrt?
        end

        until kneeling?
          fput('rgambit stealth kneel')
          waitrt?
        end
      end

      until hidden?
        fput('hide')
        waitrt?
      end
    end

    res = do_task_command.call("rgam #{command}", nil)

    fput("drop ##{GameObj.right_hand.id}") if was_automatic && GameObj.right_hand.id

    if command =~ /stealth/ && !standing?
      until standing?
        fput('stand')
        waitrt?
      end
    end

    fput("put my #{weapon} in my #{CharSettings['sheath']}") if command =~ /^get/

    if res !~ /completed/
      get_weapon.call(weapon) if command =~ /^vanish/
    elsif res =~ /completed/ && was_automatic && XMLData.room_title =~ /A Dark Corner/
      fput("get #{weapon}")
      fput("put my #{weapon} in my #{CharSettings['sheath']}")
    end

    command = 'automatic' if was_automatic

    res
  end

  clear_hands.call

  case info['task']
  when 'audience'
    print.call 'gambits in front of audience'
    go2.call(CharSettings['audience-room'])
    command = get_gambit.call

    loop do
      wait_until { GameObj.pcs.find_all { |pc| pc.status.nil? }.length >= 4 }
      res = do_gambit.call
      break if res =~ /completed/

      sleep(15) if res =~ /remaining/
    end
  when 'footpads'
    print.call 'lessons from footpads'

    go2.call 'rogue guild trainer'

    npc = GameObj.npcs.first
    res = dothistimeout "ask ##{npc.id} for training gambits", 60, /RGAMBIT/
    error.call 'unknown gambits footpad result' if res !~ /RGAMBIT/

    command = get_gambit.call

    loop do
      res = do_gambit.call
      break if res =~ /completed/
    end

    fput('out') if XMLData.room_title =~ /A Dark Corner/
  when 'speed'
    command = get_gambit.call

    if command =~ /^stealth/
      Script.run('go2', 'weaponshop')
    else
      Script.run('go2', 'table')
      fput('go table')
    end

    if command =~ /^display person/
      if GameObj.pcs.nil? && GameObj.npcs.nil?
        print.call('Waiting for PC or NPC to target')
        wait_while { GameObj.pcs.nil? && GameObj.npcs.nil? }
      end

      if GameObj.pcs.nil?
        command = command.gsub('person', GameObj.npcs.first.noun.downcase)
      else
        command = command.gsub('person', GameObj.pcs.first.name.downcase)
      end
    end

    loop do
      until standing?
        waitrt?
        fput('stand')
        sleep(0.25)
      end

      res = do_gambit.call
      break if res =~ /completed/
    end
  when 'learn'
    partner_receive.call('gambits')
  when 'teach'
    partner_do.call('gambits')
  else
    error.call "task #{info['task']} not yet implemented"
  end

  waitrt?
  fput("put my #{CharSettings['audience-weapon-small']} in my #{CharSettings['sheath']}")
end

do_stunman = proc do
  print.call 'running stunman routine'
  info = get_skill_info.call 'stunman'

  get_stunman_command = proc do
    command = nil
    done = false

    action = proc do |server_string|
      next server_string if done

      if server_string =~ %r{[^>]+>(\w+)</a>\s+}
        if Regexp.last_match(1).to_s.downcase == 'automatic'
          done = true
        else
          command = Regexp.last_match(1).to_s.downcase
        end
        nil
      elsif server_string =~ /(\w+)\s+/
        if Regexp.last_match(1).to_s.downcase == 'automatic'
          done = true
        else
          command = Regexp.last_match(1).to_s.downcase
        end
        nil
      elsif !server_string.nil? && !server_string.empty? && server_string !~ /\r\n||&gt;/
        server_string
      end
    end

    DownstreamHook.add 'sguild_get_stunman', action
    $_SERVER_.puts "#{$cmd_prefix}stunman\n"
    start = Time.now.to_f
    wait_until { done || (Time.now.to_f - start >= 3.0) }
    DownstreamHook.remove 'sguild_get_stunman'

    next command.downcase
  end

  case info['task']
  when 'arrows'
    print.call 'doing arrows'
    go2.call 'rogue guild trainer'

    npc = GameObj.npcs.first
    res = dothistimeout "ask ##{npc.id} for training stunman", 60, /No points on these arrows/

    error.call 'unknown stunman result' if res.nil?

    print.call 'running dodge loop'

    last_cmd = nil
    cmd = nil

    fput 'stance offensive'

    loop do
      until standing?
        waitrt?
        fput 'stand'
        sleep 0.25
      end

      loop do
        cmd = ['lean left', 'lean right', 'duck', 'jump'].sample
        break if last_cmd != cmd
      end

      last_cmd = cmd
      res = dothistimeout cmd, 60, /You have to dodge|completed|repetition/
      break if res =~ /completed|repetition/

      waitrt?
    end

    waitrt?
    fput XMLData.room_exits.sample
  when 'footpads'
    print.call 'lessons from footpads'
    go2.call 'rogue guild trainer'

    command = get_stunman_command.call
    npc = GameObj.npcs.first
    res = dothistimeout "ask ##{npc.id} for training stunman", 60, /NOD/
    error.call 'unknown stunman footpad result' if res !~ /NOD/

    command = "attack ##{GameObj.npcs.first.id}" if command == 'attack'

    loop do
      unless stunned?
        fput 'stance offensive'
        fput 'nod'
        fput CharSettings['stun-command']
      end

      wait_until { stunned? }

      res = do_task_command.call("stun #{command}", nil)
      if res =~ /completed/
        put 'unstun'
        break
      end

      wait_for_stamina.call unless checkstamina(15)
    end

    wait_while { stunned? }
    fput XMLData.room_exits.sample
  when 'practice'
    print.call 'doing stun practice'
    clear_hands.call

    command = get_stunman_command.call

    # special case, have to attack something
    if command == 'attack'
      print.call 'doing attack in the field; make sure field settings and wander boundaries are set'
      sleep(3)
      prepare_field.call
      do_field.call('stunman attack %s', 15)
      finish_field.call

      next
    end

    loop do
      unless stunned?
        fput 'stance offensive'
        fput CharSettings['stun-command']
      end

      res = do_task_command.call("stun #{command}", nil)
      if res =~ /completed/
        wait_while { stunned? }
        waitrt?
        break
      elsif reget.find { |l| l =~ /You are already at/ }
        wait_while { stunned? }
        fput 'stance offensive'
      end

      unless checkstamina(15)
        go2.call CharSettings['rest-room']
        wait_for_stamina.call
      end
    end
  when 'slaphands'
    print.call 'doing slaphands'
    go2.call 'rogue guild trainer'

    npc = GameObj.npcs.first
    res =
      dothistimeout(
        "ask ##{npc.id} for training stunman",
        60,
        /just put your hands on mine by choosing SLAP, DUCK or STOP/
      )

    error.call 'unknown stunman result' if res.nil?

    print.call 'running slaphands loop'

    last_cmd = nil
    cmd = nil

    fput 'stance offensive'

    loop do
      until standing?
        waitrt?
        fput 'stand'
        sleep 0.25
      end

      loop do
        cmd = %w[slap duck stop].sample
        break if last_cmd != cmd
      end

      last_cmd = cmd
      dothistimeout cmd, 60, /Roundtime:/
      sleep(1)
      break if reget.reverse[0..15].any? { |l| l =~ /completed|repetition/i }

      waitrt?
    end

    waitrt?
    fput XMLData.room_exits.sample
  when 'sweep'
    print.call 'sweeping the courtyard'
    do_path_task.call 'sweep'
  when 'windows'
    print.call 'cleaning windows'
    do_path_task.call 'windows'
  else
    error.call "task #{info['task']} not yet implemented"
  end
end

do_subdue = proc do
  print.call 'running subdue routine'
  info = get_skill_info.call 'subdue'

  case info['task']
  when 'creatures'
    print.call 'doing field reps'
    prepare_field.call
    do_field.call('subdue %s', 10)
    finish_field.call
  when 'garlic'
    if XMLData.room_title !~ /Kitchen/
      go2_nearest_tag.call('rogue guild kitchen')
      fput('go kitchen')
    end
    fput("get my #{CharSettings['audience-weapon-small']} from my #{CharSettings['sheath']}")
    loop do
      waitrt?

      until standing?
        fput('stand')
        sleep(0.25)
      end

      until checkstance('offensive')
        fput('stance offensive')
        sleep(0.25)
      end

      res = dothistimeout('subdue block', 3,
                          /miss the clove|CLEAN the block|PUT BLOCK IN|have a clove of garlic|Put it in the pot|smashed beyond use|obliterated|done with this|little softer/)

      waitrt?

      case res
      when /CLEAN the block/
        fput('clean block')
      when /PUT BLOCK IN|Put it in the pot/
        fput('put block in pot')
      when /have a clove of garlic/
        res = dothistimeout('put clove on block', 3, /CLEAN|squarely in the middle/)
        case res
        when /CLEAN/
          fput('clean block')
        end
      when /smashed beyond use|miss the clove|little softer|obliterated/
        waitrt?
      when /done with this/
        break
      else
        error.call('Unknown garlic subdue response')
      end
    end
    fput("put my #{CharSettings['audience-weapon-small']} in my #{CharSettings['sheath']}")
    fput('out')
  when 'mannequins'
    if XMLData.room_title !~ /Subdue Training/
      go2_nearest_tag.call('rogue guild mannequin')
      fput('go mannequin')
    end
    fput("get my #{CharSettings['audience-weapon-small']} from my #{CharSettings['sheath']}")
    loop do
      waitrt?

      until standing?
        fput('stand')
        sleep(0.25)
      end

      until checkstance('offensive')
        fput('stance offensive')
        sleep(0.25)
      end

      res = dothistimeout('subdue mannequin', 3, /CLEAN|needs a head|and pounce|knocking you flat/)

      waitrt?

      case res
      when /CLEAN/
        fput('clean mannequin')
      when /needs a head/
        res = dothistimeout('put melon on mannequin', 3, /CLEAN|remaining melon bits/)
        case res
        when /CLEAN/
          fput('clean mannequin')
        end
      when /and pounce/
        sleep(1)
        break if reget.reverse[0..5].any? { |l| l =~ /have completed/ }
      when /knocking you flat/
        waitrt?
      else
        error.call('Unknown mannequin subdue response')
      end
    end
    fput("put my #{CharSettings['audience-weapon-small']} in my #{CharSettings['sheath']}")
    fput('out')
  when 'windows'
    print.call 'cleaning windows'
    do_path_task.call 'windows'
  else
    error.call "task #{info['task']} not yet implemented"
  end
end

do_sweep = proc do
  print.call 'running sweep routine'
  info = get_skill_info.call 'sweep'

  sweep = proc do |target|
    fput('gird')

    loop do
      wait_until { checkstamina(9) }

      waitrt?

      if target.instance_of?(GameObj)
        until checkstance('defensive')
          fput('stance defensive')
          sleep 0.25
        end

        wait_until { target.status !~ /prone/i }
      end

      until standing?
        waitrt?
        fput('stand')
        sleep(0.25)
      end

      until checkstance('offensive')
        fput('stance offensive')
        sleep 0.25
      end

      res = do_task_command.call("sweep #{target}",
                                 ['has fallen off its post', 'is swinging back and forth', 'swings back and forth', 'falls off its post',
                                  'done with this task for now'])

      case res
      when /has fallen off its post|falls off its post/
        fput('fix dummy')
      when /is swinging back and forth|swings back and forth/
        fput('pull dummy')
      end

      break if res =~ /completed|done with/

      sleep(0.25)
    end

    clear_hands.call
  end

  case info['task']
  when 'creatures'
    print.call 'doing field reps'
    prepare_field.call
    do_field.call('sweep', 10)
    finish_field.call
  when 'defend'
    partner_receive.call('sweep')
  when 'dummies'
    go2.call('rogue guild dummies')

    fput('go dummies')
    sweep.call('dummy')
    until standing?
      waitrt?
      fput('stand')
      sleep 0.25
    end
    fput 'out'
  when 'footpads'
    go2.call 'rogue guild trainer'

    npc = GameObj.npcs.first
    res = dothistimeout "ask ##{npc.id} for training sweep", 60, /sweep thing works/
    error.call 'unknown sweep footpad result' if res.nil?

    can_sweep = false

    loop do
      line = get?
      echo line.inspect if line
      break if reget.reverse[0..15].any? { |l| l =~ /have completed/i }
      break if line =~ /You have completed/

      wait_until { npc.status.nil?}

      can_sweep = true if line =~ /now you try on me/

      waitrt?

      until standing?
        fput('stand')
        sleep(0.25)
      end

      next unless can_sweep

      until checkstance('offensive')
        fput('stance offensive')
        sleep(0.25)
      end
      dothistimeout("sweep ##{npc.id}", 3, /You crouch and sweep/)

      sleep(0.25)
    end
  when 'partner'
    partner_do.call('sweep')
  when 'sweep'
    print.call 'sweeping the courtyard'
    do_path_task.call 'sweep'
  else
    error.call "task #{info['task']} not yet implemented"
  end
end

start = proc do |skill|
  rest.call if CharSettings['wounded'].call

  case skill
  when 'batter'
    error.call "you didn't set a batter weapon" if CharSettings['batter-weapon'].to_s.empty?
    do_batter.call
  when 'tackle'
    do_tackle.call
  when 'berserk'
    do_berserk.call
  when 'disarm'
    do_disarm.call
  when 'tricks'
    error.call "you didn't set an audience weapon" if CharSettings['audience-weapon'].to_s.empty?
    error.call "you didn't set a small audience weapon" if CharSettings['audience-weapon-small'].to_s.empty?
    do_tricks.call
  when 'warcries'
    do_warcries.call
  when 'cheapshots'
    do_cheapshots.call
  when 'lmas'
    do_lmas.call
  when 'gambits'
    do_gambits.call
  when 'stunman'
    do_stunman.call
  when 'subdue'
    do_subdue.call
  when 'sweep'
    do_sweep.call
  else
    error.call "unknown task type #{skill}"
  end
end

help = proc do
  help = <<~HELPTEXT
    SpiffyWar by SpiffyJr (theman@spiffyjr.me)

    Usage:
            ;#{script.name} <skill>                   run in normal mode using the skill provided
              ;#{script.name} clear-hands               clears hands, including stowing any tools you have
              ;#{script.name} clear-locker              lockers any items in use (like your batter maul)
              ;#{script.name} help                      show this help message
              ;#{script.name} list                      dump a list of the current settings

    Skills\:
            batter
            berserk
            disarm
            tackle
            tricks
            warcries

            cheapshots
            gambits
            lmas
            stunman
            subdue
            sweep

    Settings\:
            Change settings by using [setting] [value].
            For example, ;#{script.name} audience-room 228.

            fried [on|off]                            if true will turn in even when fried (default: false)

            loop [on|off]                             whether or not to run continuously (default: false)
            loop-mind [value]                         when loop mode is on stop running when mind reaches this value (default: 0)
            loop-bounty [on|off]                      will stop looping if you can do a bounty, overrides loop-mind (default: false)
            loop-no-reset [on|off]                    if enabled will exit instead of waiting on guild to reset (default: false)
            loop-no-vocal [on|off]                    if enabled will exit instead of waiting on vocal chords (default: false)

            travel [on|off]                           travel between guilds - uses speed2, so have it downloaded (default: false)
            rest-room                                 room to rest in while waiting (default: 228)
            rest-enter                                commands when entering the rest room (default: none)
            rest-exit                                 commands when exiting the rest room (default: none)
            rest-scripts                              scripts to run before resting (default: useherbs --buy-missing=on, sloot sell)
            loot-script                               script used to loot after field reps (default: sloot)

            audience-room                             audience room to perform tricks in (default: 228)
            audience-weapon                           weapon to use for audience reps (balance, draw, polish, etc)
            audience-weapon-small                     weapon used for small audience reps (initials)

            batter-weapon                             weapon used to batter barriers
            batter-trade                              will trade in bashing critter boxes

            locker                                    starting room to get locker contents
            locker-in                                 directions to get to locker room (for rooms that aren't mapped)
            locker-out                                directions to get out of locker room (for rooms that aren't mapped)

            field-prepare                             field prepare commands separated with comma (default: gird)
            field-finish                              field finish commands separated with comma (default: store all)
            field-room                                field room (;wander add <room> for boundaries)
            field-scripts                             scripts to use while in the field hunting
            field-targets                             targets accepted during field reps
            field-trade                               will trade in field tasks when you get them

            partner-name                              name of the partner to do reps with
            partner-room                              room your partner is parked in

            sheath                                    your weapon sheath for all weapons

            stun-command                              the command to use to stun yourself

            trade-audience                            will trade in audience reps
            trade-contest                             skip lock mastery contest reps
            trade-extract                             skip lock mastery extract trap reps
            trade-footpad                             skip certain lock mastery footpad reps
            trade-partner                             will trade in partner tasks when you get them
            trade-wedge                               skip lock mastery wedge reps

            weapon-brawling                           your brawling weapon
            weapon-polearm                            your polearm weapon
            weapon-edged                              your edged weapon
  HELPTEXT

  respond help
  exit
end

bools = %w[loop batter-trade field-trade trade-audience trade-contest trade-extract trade-footpad trade-partner trade-wedge travel loop-bounty loop-no-reset
           loop-no-vocal fried]
ints = %w[loop-mind audience-room partner-room field-room rest-room]
array = %w[field-prepare field-finish rest-scripts field-scripts field-targets locker-in locker-out]
procs = %w[wounded]

before_dying { DownstreamHook.remove 'sguild_get_task' }
if script.vars.empty?
  help.call
elsif script.vars[1] =~ /^(#{CharSettings.to_hash.keys.join('|')})$/i
  key = Regexp.last_match(1)
  script.vars.shift
  script.vars.shift
  value = script.vars.join(' ')

  if bools.include? key
    value = %w[on true yes].include?(value)
  elsif ints.include? key
    value = value.to_i
  elsif array.include? key
    value = value.split(',')
  end

  CharSettings[key] = value
  print.call "#{key} set to #{value.inspect}"
elsif script.vars[1] =~ /partner$/i
  partner_mode.call
elsif script.vars[1] =~ /clear-hands/i
  clear_hands.call
elsif script.vars[1] =~ /clear-locker/i
  clear_locker.call
elsif script.vars[1] =~ /list/i
  CharSettings.to_hash.sort.each do |key, value|
    if bools.include? key
      value = value ? 'on' : 'off'
    elsif array.include? key
      value = value.join(',')
    elsif procs.include? key
      next
    end

    print.call format '%25s: %s', key, value
  end
elsif (script.vars[1] == 'batter') && script.vars[2]
  do_batter_thing.call script.vars[2]
elsif script.vars[1] =~ /#{skill_short_to_long.keys.join('|')}/i
  clear_hands.call

  if CharSettings['loop']
    loop do
      rest.call if CharSettings['wounded'].call

      if CharSettings['loop-bounty'] && !Spell['Next Bounty'].active?
        print.call 'exiting because a bounty is available'
        break
      end

      if CharSettings['loop-mind'].positive? && (percentmind <= CharSettings['loop-mind'])
        print.call 'exiting because mind is below threshold'
        break
      end

      start.call script.vars[1]
      sleep 0.25
    end
  else
    start.call script.vars[1]
  end
else
  help.call
end
