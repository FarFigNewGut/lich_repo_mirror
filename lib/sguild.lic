#     SGuild by SpiffyJr (spiffyjr@gmail.com)
#
#     Does guild stuff.
#
#      author: spiffyjr
#        name: SpiffyGuild
#        tags: guild rogue warrior
#
#     Batter: in progress
#     Berserk: complete
#     Disarm: in progress
#         * masters: complete
#         * creatures: complete
#         * partner: n/a
#     Tackle: in progress
#     Tricks: complete
#     Warcries: complete
#
#     Cheapshots: n/a
#     Gambits: complete
#     Lock Mastery: in progress
#     Subude: n/a
#     Stun Maneuvers: complete
#     Sweep: n/a
#

CharSettings['loop'] ||= false
CharSettings['loop-mind'] ||= 0
CharSettings['loop-bounty'] ||= false
CharSettings['loop-no-reset'] ||= false
CharSettings['loop-no-vocal'] ||= false
CharSettings['fried'] ||= false
CharSettings['travel'] ||= false
CharSettings['rest-enter'] ||= ''
CharSettings['rest-exit'] ||= ''
CharSettings['rest-room'] ||= 228
CharSettings['rest-scripts'] ||= ['useherbs --buy-missing=on', 'slootbeta sell']
CharSettings['wounded'] ||= StringProc.new('
  bleeding? ||
  percenthealth <= 75 ||
  [Wounds.head, Scars.head].max >= 2 ||
  [Wounds.nsys, Scars.nsys].max >= 2 ||
  [
    Wounds.leftArm,
    Wounds.leftHand,
    Wounds.rightArm,
    Wounds.rightHand,
    Scars.leftArm,
    Scars.leftHand,
    Scars.rightArm,
    Scars.rightHand
  ].max >= 3 ||
    [Wounds.leftArm, Wounds.leftHand, Scars.leftArm, Scars.leftHand].max >= 2 ||
    [Wounds.rightArm, Wounds.rightHand, Scars.leftArm, Scars.leftHand].max >= 2
')
CharSettings['field-prepare'] ||= %w[gird]
CharSettings['field-finish'] ||= ['store all']
CharSettings['field-scripts'] ||= []
CharSettings['field-targets'] ||= []
CharSettings['field-room'] ||= ''
CharSettings['loot-script'] ||= 'slootbeta'
CharSettings['audience-room'] ||= 228
CharSettings['pool-audience-room'] ||= 3807
CharSettings['pool-room'] ||= 3807
CharSettings['batter-trade'] ||= false
CharSettings['partner-name'] ||= nil
CharSettings['partner-room'] ||= nil
CharSettings['partner-trade'] ||= false

resting = false
lootsack = GameObj[UserVars.lootsack]

if lootsack.nil?
  echo '** failed to find lootsack, set it with ;set change lootsack [container]'
  exit
end

skill_short_to_long = {
  'batter' => 'Batter Barriers',
  'berserk' => 'Berserk',
  'disarm' => 'Disarm Weapon',
  'tackle' => 'Tackle',
  'tricks' => 'Warrior Tricks',
  'warcries' => 'War Cries',
  'cheap' => 'Cheap Shot',
  'gambits' => 'Rogue Gambits',
  'lmas' => 'Lock Mastery',
  'stunman' => 'Stun Maneuvers',
  'subdue' => 'Subdue',
  'sweep' => 'Sweep'
}

error =
  proc do |msg|
    echo "** #{msg}"
    exit
  end

print = proc { |msg| echo "-- #{msg}" }

run_looter = proc do
  next if GameObj.npcs.find_all { |npc| npc.status =~ /dead/ }.nil?

  wait_while { running? CharSettings['loot-script'] }
  start_script CharSettings['loot-script']
  wait_while { running? CharSettings['loot-script'] }
end

go2 = proc do |room|
  if checkarea =~ /dark corner/i
    fput XMLData.room_exits.first
  end

  next if Room.current.id.to_s == room.to_s
  next if Room.current.tags.include?(room)

  CharSettings['rest-exit'].split(',').each { |cmd| fput cmd.to_s } if checkarea =~ /table/i

  fput 'stand' if sitting?
  fput 'out' if Room.current.title =~ /Table/i

  if CharSettings['travel']
    room = Room.current.find_nearest_by_tag(room) if room.class == String

    check = Room.current.dijkstra(room)[1][room]

    if check > 30
      loc = room.class != Map ? Room[room].location : room.location

      error.call "failed to find speed2 location for #{room.inspect}; message SpiffyJr" if loc.nil? || loc.empty?
      print.call "running speed2 with #{loc} from #{room.inspect}"
      Script.run('speed2', loc)
    end
  end

  wait_while { running? 'go2' }
  start_script('go2', [room.to_s, '_disable_confirm_'])
  wait_while { running? 'go2' }
end

go2_nearest_tag = proc do |tag|
  if Room.current.nil? && checkarea =~ /table/i
    fput 'stand' until standing?
    fput 'out'
  end

  room = Room.current.find_nearest_by_tag(tag)
  error.call "failed to find room by tag: #{tag}" if room.nil?

  go2.call(room)
end

get_nearest_rooms_by_tag = proc do |tag|
  rooms = Room.list.find_all { |room| room.tags.find { |t| t == tag } }
  rooms = rooms.collect(&:id)

  rest_room = Room[CharSettings['rest-room']]
  _, shortest_distances = Map.dijkstra(rest_room)

  # used to set the max distance to allow travel to
  distance = 10

  # leaves don't need other guilds
  distance = rest_room.location =~ /Ta'/ ? 400 : 600 if tag !~ /leaves/ && CharSettings['travel']

  rooms.delete_if { |room| shortest_distances[room].nil? || shortest_distances[room] > distance }
  rooms.sort! { |a, b| shortest_distances[a] < shortest_distances[b] ? -1 : 1 }
  rooms
end

visit_locker = proc do |action, item|
  locker = CharSettings['locker']

  error.call 'locker is not set' if locker.nil? || !locker

  go2.call 'bank'
  fput 'withdraw 1000'
  go2.call locker

  CharSettings['locker-in'].each { |x| move x } unless CharSettings['locker-in'].empty?

  if (entrance = ((GameObj.loot.to_a + GameObj.room_desc.to_a).find { |obj| obj.noun =~ /^(?:opening|curtain)$/ }))
    move "go ##{entrance.id}"
  else
    erorr.call 'failed to find locker entrance'
  end

  fput 'open locker'

  if action == 'put'
    fput "put #{item} in locker"
  elsif action == 'get'
    fput "get #{item} from locker"
    # premium, brute force
    fput "get #{item}" if checkleft !~ /#{item}/ && checkright !~ /#{item}/
  else
    fput cmd
  end

  fput 'close locker'

  if (entrance = ((GameObj.loot.to_a + GameObj.room_desc.to_a).find { |obj| obj.noun =~ /^(?:opening|curtain)$/ }))
    move "go ##{entrance.id}"
  else
    erorr.call 'failed to find locker exit'
  end

  CharSettings['locker-out'].each { |x| move x } unless CharSettings['locker-out'].empty?

  go2.call 'bank'
  fput 'deposit all'
end

rest = proc do |run_scripts|
  go2.call CharSettings['rest-room']

  if run_scripts.nil? || (run_scripts == true)
    CharSettings['rest-scripts'].each do |s|
      args = s.split(' ')
      s = args.shift

      start_script(s, args, true)
      wait_while { running? s }
    end
  end

  CharSettings['rest-enter'].split(',').each { |cmd| fput cmd.to_s }
  resting = true
end

rest_exit = proc do
  next unless resting

  CharSettings['rest-exit'].split(',').each { |cmd| fput cmd.to_s }
  resting = false
end

prepare_field = proc do
  error.call 'missing field-room' if CharSettings['field-room'].to_s.empty?

  CharSettings['field-prepare'].each { |cmd| fput cmd }
  CharSettings['field-scripts'].each { |s| Script.start(s) unless Script.running?(s) }
  go2.call CharSettings['field-room']
end

finish_field = proc do
  go2.call CharSettings['rest-room']
  CharSettings['field-finish'].each { |cmd| fput cmd }
  CharSettings['field-scripts'].each { |s| Script.kill(s) if Script.running?(s) }

  rest.call
end

get_field_targets = proc {
  GameObj.targets.find_all { |npc| CharSettings['field-targets'].find { |target| npc.name =~ /#{target}/ } }
}

wander = proc do
  until checkstance('guarded') || checkstance('defensive')
    fput 'stance defensive'
    sleep 0.25
  end
  start_script 'wander', CharSettings['field-targets'] unless running? 'wander'
  wait_while { running? 'wander' }
end

wait_for_stamina = proc do
  print.call 'waiting for stamina'
  print.call 'no input is required'
  wait_until { percentstamina 80 }
end

get_promoted = proc do |skill|
  print.call 'going to get promoted'

  if Char.prof == 'Rogue'
    go2_nearest_tag.call 'rogue guild master'
  else
    go2_nearest_tag.call 'warrior guild guildmaster'
  end

  npc = GameObj.npcs.find { |obj| obj.name =~ /Guild Master/ }

  error.call 'failed to find guildmaster for promotion' if npc.nil?

  res = dothistimeout("ask ##{npc.id} for next #{skill}", 1, /Congratulations|train a little|before you can be/i)
  error.call "you must diversify your skills to continue in #{skill}" if res =~ /To rise to the top/
end

get_skill_full = proc do |skill|
  error.call 'error, no skill given' if skill.nil?
  error.call "skill #{skill} could not be found" unless skill_short_to_long.include? skill

  skill_short_to_long[skill]
end

find_administrator = proc do
  npc = GameObj.npcs.find { |n| n.name =~ /Training Administrator/ }

  error.call 'failed to find training administrator' if npc.nil?

  npc
end

trade_in = proc do |skill|
  print.call "trading in partner task for #{skill}"
  print.call 'you have 5 seconds to kill me'

  sleep 5

  if Char.prof == 'Rogue'
    go2_nearest_tag.call 'rogue guild administrator'
  else
    go2_nearest_tag.call 'warrior guild administrator'
  end

  npc = find_administrator.call

  multifput "ask ##{npc.id} for trade #{skill}", "ask ##{npc.id} for train #{skill}"
end

turn_in = proc do |skill|
  if !(CharSettings['fried']) && checkmind('saturated')
    rest.call(false)
    print.call 'resting your mind before turning in'
    wait_while { percentmind(100) }
    rest_exit.call
  end

  print.call "turning in task for #{get_skill_full.call skill}"

  if Char.prof == 'Rogue'
    go2_nearest_tag.call 'rogue guild administrator'
  else
    go2_nearest_tag.call 'warrior guild administrator'
  end

  npc = find_administrator.call

  multifput "ask ##{npc.id} for train #{skill}", "ask ##{npc.id} for train #{skill}"
end

get_skill_info = proc do |skill|
  done = false
  read = false
  info = {}

  print.call "collecting #{get_skill_full.call(skill)} task information"

  action = proc do |server_string|
    if server_string =~ /You have (no|\d+) ranks? in the #{get_skill_full.call(skill)} skill\./i
      read = true
      info['ranks'] = Regexp.last_match(1).to_i
    end

    # rubocop:disable Layout/LineLength
    if read
      # General stuff
      if server_string =~ /^You need (\d+) training points/
        info['points'] = Regexp.last_match(1).to_i
      elsif server_string =~ /You have earned enough training points/
        info['promoted'] = true
        read = false
      elsif server_string =~ /You have no repetitions|You are not currently training/
        info['reps'] = 0
        read = false
      elsif server_string =~ /You have (\d+) repetitions? remaining/
        info['reps'] = Regexp.last_match(1).to_i
        read = false
        # Tricks / Warcries
      elsif server_string =~ /The Training Administrator told you to (?:(?:get a)\s)?((?:spiff up|rake|skilled master|scrub|polish))(?:\s(?:the shrubbery|the guild floors|to teach some war cry techniques|the armor in the guild|the guild yard))?\./
        info['task'] = Regexp.last_match(1).to_s.strip
      elsif server_string =~ /The Training Administrator told you to practice (.*) on creatures\./
        info['task'] = 'creatures'
        info['warcry'] = Regexp.last_match(1).to_s.strip
        # Berserk
      elsif server_string =~ /The Training Administrator told you to (?:(?:practice|go practice in the|go visit the|go out and practice Berserk against|get a partner to)\s)?(breaking (?:paralysis|stuns|webs)|saunas|ice tubs|creatures|Balancing|Draw|Spin|Drop-n-Roll|Kick-n-Sheath|Twirl-n-Sheath|Sheath Catch|Weapon Hop|Initial|Weapon Flip|Guzzle|polish|prune|scrub|Spin Attack|Spit|Feint|Juggling|skilled masters|rake|Backflip|Haircut|Toss-n-Slice|teach)(?:\s(?:some shrubbery|some war cry techniques|the floors|the guild yard|the armor around the guild|in the Dark Chamber|for an audience|on a suitable creature))?\./
        info['task'] = Regexp.last_match(1).to_s.strip
        # Disarm
      elsif server_string =~ /The Training Administrator told you to (?:(?:practice disarming(?: a)?|get a lesson from the|let a)\s)?(creatures|skilled masters|partner(?: disarm)?)(?:\s(?:with an?|on disarming|an?) (\w+)(?: weapons?)?)?(?: from you)?\./
        info['task'] = Regexp.last_match(1).to_s.strip
        info['type'] = Regexp.last_match(2).to_s.strip
      elsif server_string =~ /The Training Administrator told you to use a practice (\w+) weapons? with the Wheel\./
        info['task'] = 'wheel'
        info['type'] = Regexp.last_match(1).to_s
        # Batter
      elsif server_string =~ /The Training Administrator told you to (?:go )?break (?:up|down) some (old boards|branches|sheet metal)/
        info['task'] = Regexp.last_match(1).to_s
      elsif server_string =~ /The Training Administrator told you to practice on the ((?:wooden|metal) (?:stage door)) in the guild(?: with (?:a|your) (shoulder|weapon))?\./
        info['task'] = Regexp.last_match(1).to_s
        info['weapon'] = Regexp.last_match(2).to_s
      elsif server_string =~ /The Training Administrator told you to bash open some boxes from creatures\./
        info['task'] = 'creatures'
      elsif server_string =~ /The Training Administrator told you to bash some cheap practice boxes\./
        info['task'] = 'practice boxes'
        # Tackle
      elsif server_string =~ /The Training Administrator told you to practice tackling .*(partner|creatures)\./
        info['task'] = Regexp.last_match(1).to_s
      elsif server_string =~ /The Training Administrator told you to practice defending against tackles\./
        info['task'] = 'defend'
      elsif server_string =~ /The Training Administrator told you to work with the skilled masters\./
        info['task'] = 'skilled masters'
      elsif server_string =~ /The Training Administrator told you to work with the tackling dummies\./
        info['task'] = 'dummies'
        # Gambits
      elsif server_string =~ /The Training Administrator told you to practice your latest trick in front of an audience\./
        info['task'] = 'audience'
      elsif server_string =~ /The Training Administrator told you to visit the master footpads for a lesson\./
        info['task'] = 'footpads'
      elsif server_string =~ /The Training Administrator told you to teach a fellow guildmember something about rogue gambits\./
        info['task'] = 'teach'
      elsif server_string =~ /The Training Administrator told you to get a partner to teach you your latest trick\./
        info['task'] = 'learn'
      elsif server_string =~ /The Training Administrator told you to see how many times you can do your current gambit in one minute\./
        info['task'] = 'speed'
        # Lock Mastery
      elsif server_string =~ /The Training Administrator told you to use some decently challenging boxes to practice your latest trick for an audience\./
        info['task'] = 'audience'
      elsif server_string =~ /The Training Administrator told you to calibrate your calipers out in the field\./
        info['task'] = 'calibrate'
      elsif server_string =~ /The Training Administrator told you to pit your skills against a footpad\./
        info['task'] = 'contest'
      elsif server_string =~ /The Training Administrator told you to visit a master footpad for a talk./
        info['task'] = 'master'
      elsif server_string =~ /The Training Administrator told you to measure some tough boxes, then pick 'em\./
        info['task'] = 'measure'
      elsif server_string =~ /The Training Administrator told you to relock some tough boxes\./
        info['task'] = 'relock'
      elsif server_string =~ /The Training Administrator told you to pick some tough boxes from creatures\./
        info['task'] = 'tough'
      elsif server_string =~ /The Training Administrator told you to wedge open some boxes\./
        info['task'] = 'wedge'
        # Stun Maneuvers
      elsif server_string =~ /The Training Administrator told you to let a footpad shoot arrows at you\./
        info['task'] = 'arrows'
      elsif server_string =~ /The Training Administrator told you to visit the footpads for some lessons\./
        info['task'] = 'footpads'
      elsif server_string =~ /The Training Administrator told you to practice (?:defending yourself a little more while stunned|attacking while stunned)\./
        info['task'] = 'practice'
      elsif server_string =~ /The Training Administrator told you to play a few rounds of slap hands with a footpad\./
        info['task'] = 'slaphands'
      elsif server_string =~ /The Training Administrator told you to sweep the guild courtyard\./
        info['task'] = 'sweep'
      elsif server_string =~ /The Training Administrator told you to clean the windows in the guild\./
        info['task'] = 'windows'
        # Subdue
      elsif server_string =~ /The Training Administrator told you to try and subdue some creatures\./
        info['task'] = 'creatures'
      end
    end

    if server_string =~ /^You are a (?:member|master)|^You are current with your dues|You currently have \d+|You are not currently training|You have \d+ ranks? in the|You need \d+ training points|The Training Administrator told you|You have \d+ repetitions remaining|You are a Master of|You will need to do/
      nil
    elsif server_string =~ /^Click .*GLD MENU.* for additional commands./
      done = true
      nil
    elsif !server_string.nil? && !server_string.empty? && server_string !~ /\r\n||&gt;/
      server_string
    end
    # rubocop:enable Layout/LineLength
  end

  DownstreamHook.add 'sguild_get_task', action
  $_SERVER_.puts "#{$cmd_prefix}gld\n"
  start = Time.now.to_f
  wait_until { done || (Time.now.to_f - start >= 3.0) }
  DownstreamHook.remove 'sguild_get_task'

  if info['promoted']
    get_promoted.call skill
    get_skill_info.call skill
  elsif info['reps'].zero?
    turn_in.call skill
    get_skill_info.call skill
  else
    info
  end
end

wait_on_partner_confirmation = proc do |partner, question|
  print.call 'waiting for partner to acknowledge; NOD to skip'
  result = dothistimeout "whisper #{partner} #{question}", 10, /^(#{partner} whispers\, \"I am ready\.\"|You nod\.)$/i
  if result =~ /^(#{partner} whispers\, \"I am ready\.\"|You nod\.)$/
    nil
  elsif result.nil?
    print.call 'Partner did not respond, asking again.'
    next wait_on_partner_confirmation.call(partner, question)
  end
end

get_tool = proc do |tool|
  next if (checkleft == tool) || (checkright == tool)

  if Char.prof == 'Warrior'
    go2_nearest_tag.call 'warrior guild cleaning supplies'
  else
    go2_nearest_tag.call 'rogue guild tools'
  end

  dothistimeout "get #{tool}", 1, /You pick out/

  error.call "failed to get tool #{tool}" if (checkleft != tool) && (checkright != tool)
end

store_tool = proc do |tool, _room|
  next if (checkleft != tool) && (checkright != tool)

  if Char.prof == 'Warrior'
    go2_nearest_tag.call 'warrior guild cleaning supplies'
  else
    go2_nearest_tag.call 'rogue guild tools'
  end

  dothistimeout "put #{tool} on rack", 1, /You put|You return/

  error.call "failed to store tool #{tool}" if (checkleft == tool) || (checkright == tool)
end

clear_hands = proc do
  tools = %w[bag rake duster brush shears rag broom]
  weapons = ['two-handed sword']

  next if checkleft.nil? && checkright.nil?

  store_tool.call(checkleft) if tools.include?(checkleft)

  store_tool.call(checkright) if tools.include?(checkright)

  if weapons.include?(checkleft)
    # fput "drop #{checkleft}"
  end

  if weapons.include?(checkright)
    # fput "drop #{checkright}"
  end

  fput 'store all' if checkleft || checkright
  fput 'stow all' if checkleft || checkright
  empty_hands if checkleft || checkright
end

clear_locker = proc do
  next unless CharSettings['locker']

  batter_weapon = CharSettings['batter-weapon']

  if batter_weapon
    waitrt?

    fput "get my #{batter_weapon}" if checkleft !~ /#{batter_weapon}/ && checkright !~ /#{batter_weapon}/

    sleep 0.25
    if checkright =~ /#{batter_weapon}/ || checkleft =~ /#{batter_weapon}/
      visit_locker.call('put', CharSettings['batter-weapon'])
    end
  end
end

get_snack = proc do |type, count|
  error.call 'invalid type: expected drink or food' if type !~ /drink|food/

  snacks = { 'drink' => /lemonade|ale|piledriver|wine|stout|lager/i, 'food' => /sandwich|tart/ }

  snack = snacks[type]
  my_snacks = lootsack.contents.find_all { |i| i.name =~ snack }

  # clear_hands.call

  if count.nil?
    next if checkleft =~ snack || checkright =~ snack

    error.call 'your out of snack: ' + snack if my_snacks.empty?

    fput "get ##{my_snacks.shift.id}"
    next
  end

  go2_nearest_tag.call('warrior guild snacks')

  bar = GameObj.loot.find { |l| l.noun =~ /bar|table|counter/i }

  error.call 'failed to find bar with snacks' if bar.nil?

  fput "look on ##{bar.id}" if bar.contents.nil?

  item = bar.contents.find { |l| l.noun =~ snack }

  error.call "failed to find #{type}" if item.nil?

  (count - lootsack.contents.find_all { |i| i.name == item.name }.length).times do
    done = false
    until done
      res =
        dothistimeout "get #{item} from ##{bar.id}",
                      1,
                      /You just poured yourself|You just grabbed|You pour yourself|Greedy, greedy/
      if res =~ /Greedy/i
        sleep 5
      else
        done = true
      end
    end
    fput "stow my #{item}"
  end
end

do_task_command = proc do |cmd, extra|
  matches = ['You should wait', 'You have \d+ repetition', 'completed', 'You have already finished that task', 'Roundtime']
  extra = [] if extra.nil?

  res = dothistimeout cmd, 5, /#{(matches + extra).join('|')}/i
  waitrt?
  res
end

do_path_task = proc do |task|
  res = tag = tools = action = nil

  case task
  when 'polish'
    delay = 300
    tools = %w[rag]
    tag = 'warrior guild armor'
    action = proc { do_task_command.call 'rub armor', nil }
  when /prune|spiff up/
    delay = 300
    tools = %w[shears]
    tag = 'warrior guild shrubbery'
    action =
      proc do
        if (obj = GameObj.loot.find { |l| l.name =~ /bush|hedge|shrub|topiar/i })
          do_task_command.call "prune ##{obj.id}", nil
        end
      end
  when 'rake'
    tag = 'warrior guild leaves'
    tools = %w[rake bag]
    action =
      proc do
        while GameObj.loot.find { |l| l.name =~ /leaves/i }
          fput 'pull my rake'
          waitrt?
        end
        pile = GameObj.loot.find { |l| l.name =~ /pile/i }
        next if pile.nil?

        res = dothistimeout "get ##{pile.id}", 5, /You gather a leaf pile/

        error.call 'unknown leaf result: ' + res.to_s if res !~ /You gather a leaf pile/

        res = dothistimeout 'look in my bag', 5, /The bag is full of leaves|nothing|more/
        if res =~ /The bag is full of leaves/
          print.call 'turning in leaves'
          go2_nearest_tag.call 'warrior guild cleaning supplies'
          res = do_task_command.call('put my bag in bin', nil)
        end

        res
      end
  when 'scrub'
    delay = 300
    tools = %w[brush]
    tag = 'warrior guild floor'
    action =
      proc do
        fput 'kneel'
        do_task_command.call 'clean floor', nil
      end
  when 'sweep'
    delay = 300
    tools = %w[bag broom]
    tag = 'rogue guild dirt'
    action =
      proc do
        while GameObj.loot.find { |l| l.name =~ /dirt/i }
          res = dothistimeout 'push my broom', 5, /You sweep up some dirt|There is no dirt here to sweep/
          break if res =~ /There is no dirt/

          waitrt?
        end
        pile = GameObj.loot.find { |l| l.name =~ /pile/i }
        next if pile.nil?

        res = dothistimeout "get ##{pile.id}", 5, /You gather a dirt pile|You don't see a dirt pile/

        error.call 'unknown dirt result' if res.nil?

        res = dothistimeout 'look in my bag', 5, /The bag is full of dirt|nothing|more/
        if res =~ /The bag is full of dirt/
          print.call 'turning in dirt'
          go2_nearest_tag.call 'rogue guild tools'
          res = do_task_command.call('put my bag in bin', nil)
        end

        res
      end
  when 'windows'
    delay = 300
    tools = %w[rag]
    tag = 'rogue guild window'
    action =
      proc do
        if (obj = GameObj.loot.find { |l| l.name =~ /window/i })
          do_task_command.call "rub ##{obj.id}", ["That's enough cleaning for this"]
        end
      end
  end

  error.call "path task #{task} not implemented" if action.nil?

  rooms = get_nearest_rooms_by_tag.call tag
  current = 0

  error.call "failed to find rooms for path task #{task}" if rooms.nil?

  while res !~ /completed|finished/
    room = rooms[current]
    current += 1
    need_tools = false

    tools.each { |tool| get_tool.call tool }

    waitrt?

    # need to store the tool to get in other location
    if Room.current.location != Room[room].location
      tools.each { |tool| store_tool.call tool }
      need_tools = true
    end

    go2.call room

    tools.each { |tool| get_tool.call tool } if need_tools

    # for sweep/rake we just reset the loop
    current = -1 if ((task == 'rake') || (task == 'sweep')) && (current >= rooms.length)

    res = action.call

    if res !~ /completed|finished/ && (current >= rooms.length)
      rest.call(false)

      if CharSettings['loop-no-reset']
        print.call 'exiting because loop-no-reset is true'
        exit
      end

      current = 0
      print.call "waiting #{delay} seconds for reset"
      print.call 'no input is required'

      start = delay
      loop do
        start -= 1
        break if start <= 0

        print.call "still waiting #{start} seconds for guild to reset" if (start % 30).zero?

        sleep 1
      end
    end

    waitrt?
  end

  tools.each { |tool| store_tool.call tool }
end

do_berserk = proc do
  print.call 'running berserk routine'

  info = get_skill_info.call 'berserk'
  berserking = false
  done = false

  can_berserk =
    proc do
      !get_field_targets.call.empty? && GameObj.loot.find { |l| l.noun =~ /disk/ && l.name !~ /#{Char.name}/ }.nil?
    end

  go_berserk =
    proc do |field|
      loop do
        unless berserking
          while (!checkstance 'defensive') && (!checkstance 'guarded')
            result = dothistimeout 'stance defensive', 5, /You are now in a/

            break if result =~ /You are now in a/
          end

          while !field || can_berserk.call
            waitrt?

            unless checkstamina 20
              finish_field.call if field

              wait_for_stamina.call

              prepare_field.call if field
            end

            res = dothistimeout 'berserk', 1, /Everything around you|Roundtime|You scream with a maniacal/
            break if res =~ /Everything around you|You scream with a maniacal/

            sleep(Regexp.last_match(1).to_i - 1) if res =~ /Roundtime: (\d+) sec/
          end

          berserking = true
        end

        line = get

        if line =~ /You have completed/ || reget.find { |l| l =~ /You have completed/ } ||
           CharSettings['wounded'].call
          done = true
          break
        elsif line =~ /The redness fades from the world/
          berserking = false
          break if field
        end
      end

      sleep 3 while berserking && dothistimeout('stop berserk', 1, /You try to regain control/)

      run_looter.call

      berserking = false
    end

  do_field_berserk = proc do
    until done
      wander.call

      go_berserk.call true if can_berserk.call && !done

      sleep 0.25
    end

    finish_field.call
  end

  do_reps = proc do |cmd|
    loop do
      res = dothistimeout cmd, 1, /You try to|You splash|start berserking/
      break if res =~ /start berserking/

      waitrt?
    end

    go_berserk.call
    fput 'stand' until standing?
    fput XMLData.room_exits.sample

    rest.call
  end

  unless percentstamina 80
    rest.call(false)
    wait_for_stamina.call
  end

  rest_exit.call

  case info['task']
  when 'creatures'
    print.call 'doing field reps'
    prepare_field.call
    do_field_berserk.call
    finish_field.call
  when 'ice tubs'
    print.call 'practicing in ice tubs'
    go2_nearest_tag.call 'warrior guild icetub'
    fput 'go tub'
    do_reps.call 'splash'
  when 'saunas'
    print.call 'practicing in sauna'
    go2_nearest_tag.call 'warrior guild sauna'

    room = (GameObj.room_desc + (GameObj.loot || [])).find { |l| l.noun =~ /sauna|spring/ }
    fput "go ##{room.id}"
    do_reps.call 'meditate'
  when /breaking (?:paralysis|stuns|webs)/
    print.call 'practicing breaking stuns'

    go2_nearest_tag.call 'warrior guild dark attendant'
    fput 'kneel'
    go_berserk.call
  else
    error.call "unknown task #{info['task']} for berserk"
  end
end

rest_vocal_cords = proc do
  if CharSettings['loop-no-vocal']
    print.call 'exiting because loop-no-vocal is true'
    exit
  end

  rest.call

  loop do
    if CharSettings['loop'] && (percentmind < CharSettings['loop-mind'].to_i)
      print.call 'exiting because mind is below loop threshold'
      exit
    end

    res = dothistimeout 'warcry', 5, /Your vocal cords are in perfect condition\./
    if res =~ /Your vocal cords/
      rest_exit.call
      break
    else
      print.call 'vocal cords are not ready yet'
    end

    sleep 30
  end
end

get_disarm_weapon = proc do
  info = get_skill_info.call 'disarm'

  type_to_user_weapon = { 'brawling' => 'brawling', 'polearms' => 'polearm', 'edged' => 'edged' }

  weapon = CharSettings["weapon-#{type_to_user_weapon[info['type']]}"]

  fput 'stow right' if checkright && checkright !~ /#{weapon}/
  fput "get #{weapon} from my #{CharSettings['weapon-sheath']}"
  sleep 1

  if checkright !~ /#{weapon}/i
    finish_field.call
    error.call "failed to find #{weapon} in your #{CharSettings['weapon-sheath']}"
  end
end

do_field = proc do |cmd, req_stamina|
  target = nil
  started = false
  last_action = Time.now.to_i

  loop do
    # let creatures despawn in case of hangups
    if started && ((Time.now.to_i - last_action) > 60)
      finish_field.call
      print.call 'letting critter area despawn (5 minutes)'
      print.call 'no input is required'
      sleep 300
      prepare_field.call
      last_action = Time.now.to_i
    end

    unless checkstamina req_stamina
      finish_field.call
      wait_for_stamina.call
      prepare_field.call
    end

    wander.call if target.nil?

    started = true

    targets = get_field_targets.call
    if (targets.length > 1) || (GameObj.targets.length > 1)
      target = nil
      next
    end

    target = targets.first

    fput 'stand' until standing?

    # special subdue handling

    if cmd =~ /subdue/i
      loop do
        fput 'hide'
        break if hidden?

        waitrt?
      end
    elsif cmd =~ /stunman attack/
      # special stunman attack handling
      fput CharSettings['stun-command'] unless stunned?
    end

    if cmd =~ /disarm|subdue|tackle/i
      until checkstance('offensive')
        fput 'stance offensive'
        sleep 0.25
      end
    end

    waitrt?

    if cmd =~ /stunman attack/
      put format(cmd, '#' + target.id.to_s)
    else
      fput format(cmd, '#' + target.id.to_s)
    end

    waitrt?

    done = false

    reget.reverse[0..25].each do |line|
      if line =~ /You have completed/ || CharSettings['wounded'].call
        done = true
        break
      elsif line =~ /Your mouth is too dry at the moment\./
        last_action = Time.now.to_i
        fput 'stance defensive' until checkstance('defensive')
        delay = 5
        print.call "waiting #{delay} seconds for mouth to moisten"
        print.call 'no input is required'

        sleep delay
      elsif line =~ /is not holding a weapon|is already prone/
        print.call('waiting for target to stand up')
        wait_until do
          (GameObj.npcs.find_all { |npc| npc.type =~ /aggressive/i }.length > 1) || target.status.nil? ||
            target.status !~ /prone/i
        end
      elsif line =~ /You need to give your vocal cords a bit of a rest!/
        rest_vocal_cords.call
        done = true
        break
      elsif line =~ /You haven't learned how to disarm without a weapon!/
        last_action = Time.now.to_i
        get_disarm_weapon.call
      else
        last_action = Time.now.to_i
      end

      if cmd =~ /warcry/
        print.call 'sleeping 10 seconds to rest vocal chords'
        sleep 10
      else
        sleep 0.25
      end
    end

    break if done
  end
  fput 'stance defensive' until checkstance 'defensive'
end

do_disarm = proc do
  print.call 'running disarm routine'
  info = get_skill_info.call 'disarm'

  type_to_practice_weapon = { 'brawling' => 'club', 'polearms' => 'halberd', 'edged' => 'broadsword' }

  disarm =
    proc do |weapon, target, stamina|
      loop do
        if GameObj.loot.find { |l| l.name =~ /#{weapon}/i } && checkleft !~ /#{weapon}/ && checkright !~ /#{weapon}/
          waitrt?
          fput "get #{weapon}"
        end

        wait_for_stamina.call unless checkstamina(stamina)

        fput 'stance offensive' until checkstance('offensive')
        res = do_task_command.call("disarm #{target}", ['is not holding a weapon', 'broken workout wheel'])

        break if res =~ /completed/

        if res =~ /is not holding/
          waitrt?
          fput 'stance defensive' until checkstance('defensive')
          waitfor 'stoops and picks up', 'picks a'
        elsif res =~ /The broken workout wheel/
          waitrt?
          fput 'fix wheel'
        end

        waitrt?
        sleep 0.10
      end
    end

  case info['task']
  when 'creatures'
    print.call "disarming creatures with #{info['type']}"

    clear_hands.call

    prepare_field.call
    get_disarm_weapon.call

    do_field.call('disarm %s', 12)

    finish_field.call

    clear_hands.call
  when 'wheel'
    print.call 'disarm the wheel'
    go2.call 'warrior guild wheel'

    move 'go wheel'

    weapon = type_to_practice_weapon[info['type']]

    res = dothistimeout "get #{weapon}", 5, /You reach out and grab/
    error.call "failed to get #{weapon.inspect} for training: " + res.inspect if res !~ /You reach out/

    disarm.call(weapon, 'wheel', 12)

    waitrt?
    fput "drop #{weapon}"
    fput 'out'
  when 'partner'
    print.call 'disarming a partner'

    if CharSettings['partner-trade']
      trade_in.call('disarm')
    else
      error.call 'not yet implemented'
    end
  when 'partner disarm'
    print.call 'letting a partner you'

    if CharSettings['partner-trade']
      trade_in.call('disarm')
    else
      error.call 'not yet implemented'
    end
  when 'skilled masters'
    print.call 'lessons from skilled masters'
    go2.call 'warrior guild masters'

    npc = GameObj.npcs.first
    res = dothistimeout "ask ##{npc.id} for training disarm", 60, /Disarm Weapon/

    error.call 'unknown disarm result' if res.nil?

    weapon = type_to_practice_weapon[info['type']]

    res = dothistimeout "get #{weapon}", 5, /You reach out and grab/
    error.call "failed to get #{weapon.inspect} for training: #{res.inspect}" if res !~ /You reach out/

    disarm.call(weapon, "##{npc.id}", 12)

    waitrt?
    fput "drop #{weapon}"
    fput 'out'
  else
    error.call "task #{info['task']} not yet implemented"
  end
end

do_warcries = proc do
  print.call 'running warcries routine'
  info = get_skill_info.call 'warcries'

  warcry_map = {
    'Bertrandt\'s Bellow' => 'bellow',
    'Gerrelle\'s Growl' => 'growl',
    'Yertie\'s Yowlp' => 'yowlp',
    'Seanette\'s Shout' => 'shout',
    'Carn\'s Cry' => 'cry',
    'Horland\'s Holler' => 'holler'
  }

  case info['task']
  when /spiff up|polish|rake|scrub/
    print.call 'doing busy work'
    do_path_task.call(info['task'])
    next
  when 'creatures'
    print.call 'warcry creatures'

    prepare_field.call
    do_field.call("warcry #{warcry_map[info['warcry']]} %s", 0)
    finish_field.call
  when 'teach'
    print.call 'learn from partner'
    if CharSettings['partner-trade']
      trade_in.call('warcries')
      next
    end
    unless GameObj.pcs.find { |pc| pc.name == CharSettings['partner-name'] }
      print.call 'running to partner'
      go2.call CharSettings['partner-room']
    end

    # rubocop:disable Layout/LineLength
    wait_on_partner_confirmation.call(CharSettings['partner-name'], 'Can you teach me warcries?')
    while (line = get)
      if line =~ /#{CharSettings['partner-name']} pulls you aside and demonstrates how (.*) is done\./i
        warcry = Regexp.last_match(1).to_s
        break
      elsif line =~ /#{CharSettings['partner-name']} whispers\, \"Sorry I am unable to teach you\. You either have more skill ranks than I do or you have the same amount but are a higher level\.\"/i
        error.call 'partner is not experienced enough to teach you'
      end
    end
    # rubocop:enable Layout/LineLength

    error.call "failed to find #{warcry} in map" unless warcry_map[warcry]

    warcry = warcry_map[warcry]
    count = 0
    loop do
      waitrt?
      res = do_task_command.call('warcry ' + warcry, ['a bit of a rest'])

      if res =~ /completed/
        fput "whisper #{CharSettings['partner-name']} All finished. Thank you!"
        break
      elsif res =~ /a bit of a rest/
        fput "whisper #{CharSettings['partner-name']} I need to give my throat a rest."
        rest_vocal_cords.call
        break
      end

      print.call 'waiting 10 seconds for vocal chords'
      sleep 10

      count += 1
      next unless count == 8

      fput "whisper #{CharSettings['partner-name']} I need another lesson please."
      count = 0
      sleep 2
    end

    waitrt?
  when 'skilled master'
    go2.call 'warrior guild masters'

    npc = GameObj.npcs.first
    res =
      dothistimeout "ask ##{npc.id} for training warcries",
                    60,
                    /Let me demonstrate|Let me show you|Now I show you|How about I show you/

    warcry = warcry_map[Regexp.last_match(1)] if res =~ /(#{warcry_map.keys.join('|')})/i

    error.call 'missing warcry command for: ' + Regexp.last_match(1).inspect if warcry.nil?

    loop do
      waitrt?
      res = do_task_command.call('warcry ' + warcry, ['a bit of a rest'])

      break if res =~ /completed/

      if res =~ /a bit of a rest/
        fput 'out'
        rest_vocal_cords.call
        break
      end
    end

    waitrt?
    fput 'out'
  else
    error.call "task #{info['task']} not yet implemented"
  end
end

get_batter_weapon = proc do
  locker = CharSettings['locker']
  weapon = CharSettings['batter-weapon']

  next if checkright =~ /#{weapon}/

  if checkleft =~ /#{weapon}/
    waitrt?
    fput 'swap'
    next
  end

  fput "get my #{weapon}"
  sleep 0.25

  if checkright !~ /#{weapon}/ && checkleft !~ /#{weapon}/
    error.call "failed to find #{weapon} and locker is not set" if locker.nil? || !locker

    print.call "your batter weapon is not on you so let's go get it"
    print.call 'you have 3 seconds to kill me'
    sleep 3

    visit_locker.call('get', weapon)
  end

  error.call "failed to find #{weapon} in inventory or locker" if checkright !~ /#{weapon}/ && checkleft !~ /#{weapon}/

  if checkleft =~ /#{weapon}/
    waitrt?
    fput 'swap'
    next
  end

  weapon
end

do_batter_thing = proc do |thing|
  obj = nil
  holding = false

  if (thing == 'right') && checkright
    obj = GameObj.right_hand
    holding = true
  end

  if (thing == 'left') && checkleft
    obj = GameObj.left_hand
    holding = true
  end

  obj = GameObj.loot.find { |l| l.noun =~ /#{thing}/ || l.name =~ /#{thing}/ } if obj.nil?

  error.call "failed to find #{thing} to bash" if obj.nil?

  get_batter_weapon.call

  print.call "bashing #{obj.name}, you have 3 seconds to kill me"
  sleep 3

  if holding
    fput 'swap' if GameObj.right_hand.id == obj.id

    fput "drop ##{obj.id}"
  end

  loop do
    waitrt?

    if Spell['Surge of Strength'].known? && Spell['Surge of Strength'].affordable? &&
       !Spell['Surge of Strength'].active?
      fput 'cman surge'
      waitcastrt?
    end

    res = dothistimeout "batter ##{obj.id}", 5, /You bash at the|In a shower of splinters/
    break if res =~ /In a shower of splinters/
  end
end

do_tackle = proc do
  print.call 'running tackle routine'
  info = get_skill_info.call 'tackle'

  tackle = proc do |target|
    loop do
      wait_until { checkstamina(15) }

      until checkstance('offensive')
        fput 'stance offensive'
        sleep 0.25
      end

      until standing?
        fput 'stand'
        sleep 0.25
      end

      waitrt?

      wait_until { target.status !~ /prone/i } if target.class == GameObj

      res = do_task_command.call("tackle #{target}", ['is lying on the ground', 'dummy in motion'])

      if res =~ /is lying on the ground/
        fput 'pull dummy'
      elsif res =~ /dummy in motion/
        fput 'push dummy'
      end

      break if res =~ /completed/

      sleep 0.25
    end
  end

  case info['task']
  when 'defend'
    print.call 'defending against partner'

    if CharSettings['partner-trade']
      trade_in.call 'tackle'
    else
      error.call 'not yet implemented'
    end
  when 'partner'
    print.call 'tackling a partner'

    if CharSettings['partner-trade']
      trade_in.call 'tackle'
    else
      error.call 'not yet implemented'
    end
  when 'creatures'
    print.call 'doing field reps'
    prepare_field.call
    do_field.call('tackle %s', 15)
    finish_field.call
  when 'dummies'
    go2.call 'warrior guild dummies'

    fput 'go dummies'
    tackle.call('dummy')
    fput 'stand' until standing?
    fput 'out'
  when 'skilled masters'
    go2.call 'warrior guild masters'

    npc = GameObj.npcs.first
    dothistimeout "ask ##{npc.id} for training tackle",
                  3,
                  /Let me demonstrate|Let me show you|Now I show you|How about I show you/

    # get tackled and stand
    loop do
      break if reget.find { |l| l =~ /try on me|feints a lunge|circles around|you tackle me|Ready\?/ }

      waitrt?
      until checkstance('defensive')
        fput 'stance defensive'
        sleep 0.25
      end
      fput 'stand' unless standing?

      sleep 0.25
    end

    # do the tackling
    tackle.call(npc)
    fput 'out'
  else
    error.call "task #{info['task']} not yet implemented"
  end
end

do_batter = proc do
  print.call 'running batter routine'

  sleep 1

  # format is [rooms (or tag), plural name, single name]
  types = {
    'old boards' => ['warrior guild boards', 'boards$', 'board$'],
    'branches' => ['warrior guild branches', 'branches$', 'branch$'],
    'sheet metal' => [%w[3455 4023 8615], 'stack of sheet metal', 'piece of sheet metal'],
    'practice boxes' => ['warrior guild wooden boxes', 'boxes', 'cheap wooden box'],
    'wooden stage door' => ['warrior guild wooden stage doors', 'wood door', 'wood door'],
    'metal stage door' => ['warrior guild metal stage doors', 'metal door', 'metal door']
  }

  info = get_skill_info.call 'batter'
  type = types[info['task']]

  if info['task'] == 'creatures'
    if CharSettings['batter-trade']
      trade_in.call('batter')
      next
    else
      error.call 'bashing creature boxes must be done manually'
    end
  end

  error.call "failed to find type for #{info['task']}" unless type

  weapon = get_batter_weapon.call

  case info['task']
  when /#{types.keys.join('|')}/
    if type[0].class == String
      go2.call type[0]
    else
      room = Room.current.find_nearest(%w[3455 4023 8615])
      _, dist = Map.dijkstra(CharSettings['rest-room'])

      error.call 'room for your town is not yet implemented for batter sheet metal ' if dist[room] > 10

      go2.call room
    end

    action =
      proc do
        until standing?
          fput 'stand'
          sleep 0.25
        end

        if type[1] =~ /door/
          clear_hands.call if info['weapon'] == 'shoulder'

          fput "go #{type[1]}" unless checkroom =~ /Door/
          next do_task_command.call "batter #{type[1]}", ['You need \d+ more hit']
        end

        if type[1] != 'boxes'
          stack = GameObj.loot.find { |l| l.name =~ /#{type[1]}/ }

          error.call "failed to find #{type[1]} to pull from" unless stack
        end

        single = GameObj.loot.find { |l| l.name =~ /\b#{type[2]}\b/ }
        unless single
          if type[1] == 'boxes'
            dothistimeout 'get boxes', 5, /You pull/
          else
            dothistimeout "get ##{stack.id}", 5, /You pull/
          end

          single = GameObj.loot.find { |l| l.name =~ /#{type[2]}/ }
        end

        error.call "failed to find #{type[2]} to batter" unless single

        do_task_command.call "batter ##{single.id}", ['You need \d+ more hit']
      end
  end

  loop do
    waitrt?

    if Spell['Surge of Strength'].known? && Spell['Surge of Strength'].affordable? &&
       !Spell['Surge of Strength'].active?
      fput 'cman surge'
      waitcastrt?
    end

    res = action.call

    if res.nil?
      error.call "unknown response for #{info['task']}: #{res}"
    elsif res =~ /completed/
      break
    end
  end

  fput "put my #{weapon} in my #{CharSettings['batter-sheath']}"
  clear_hands.call
  fput 'out'
end

do_tricks = proc do
  print.call 'running tricks routine'

  # set via the masters
  master = false
  master_location = nil

  weapon = CharSettings['audience-weapon']
  sheath = CharSettings['audience-sheath']

  info = get_skill_info.call 'tricks'
  prepare = proc do
    fput "get my #{weapon}"

    go2.call CharSettings['audience-room'] unless master
  end
  finish = proc do
    fput "put my #{weapon} in my #{sheath}"
    clear_hands.call
  end
  action = nil

  clear_hands.call

  do_trick = proc do |trick|
    case trick
    when /toss-n-slice|tslice/i
      print.call 'tossing and slicing'
      prepare =
        proc do
          unless master
            get_snack.call 'food', info['reps']
            go2.call CharSettings['audience-room']
          end
          fput "get my #{weapon} from my #{sheath}"
        end
      action =
        proc do
          if master
            fput 'get apple'
          else
            go2.call CharSettings['audience-room']
            get_snack.call 'food'
          end
          do_task_command.call 'wtrick tslice', nil
        end
    when /guzzle/i
      print.call 'guzzling some brew'

      prepare = proc { get_snack.call 'drink', info['reps'] }
      action =
        proc do
          go2.call CharSettings['audience-room']
          get_snack.call 'drink'
          do_task_command.call 'wtrick guzzle', nil
        end
      finish = proc { }
    when /weapon flip|wflip/i
      print.call 'flipping weapons'
      action = proc { do_task_command.call 'wtrick wflip', nil }
    when /backflip/i
      print.call 'doing backflips'
      action = proc { do_task_command.call 'wtrick backflip', nil }
      finish = proc { fput "put my #{weapon} in my #{sheath}" }
    when /weapon hop|whop/i
      print.call 'hopping weapon'
      action = proc { do_task_command.call 'wtrick whop', nil }
    when /spin attack|sattack/i
      print.call 'spin attack a creature'
      prepare_field.call
      do_field.call('wtrick sattack %s', 25)
      finish_field.call
      next
    when /spin/i
      print.call 'spinning weapon'
      prepare =
        proc do
          fput "get my #{weapon}"
          go2.call CharSettings['audience-room']
        end
      action = proc { do_task_command.call 'wtrick spin', nil }
    when /drop-n-roll|roll/i
      print.call 'rolling around'
      action = proc { do_task_command.call 'wtrick roll', nil }
    when /kick-n-sheath|ksheath/i
      print.call 'kick & sheath'
      action =
        proc do
          fput "get my #{weapon}"
          do_task_command.call 'wtrick ksheath', nil
        end
    when /twirl-n-sheath|tsheath/i
      print.call 'twirl & sheath'
      action =
        proc do
          fput "get my #{weapon}"
          do_task_command.call 'wtrick tsheath', nil
        end
    when /draw/i
      print.call 'draw weapon'
      prepare = proc { go2.call CharSettings['audience-room'] }
      action =
        proc do
          res = do_task_command.call "wtrick draw #{weapon}", nil

          fput "put my #{weapon} in my #{sheath}" if res !~ /pest/
          sleep 1
          res
        end
    when /balanc/i
      print.call 'balancing weapon'

      master_location = 'palm' if master_location.nil?

      action =
        proc do
          fput "get my #{weapon}"
          res = do_task_command.call "wtrick balance #{master_location}", nil

          fput 'stop balancing' if res !~ /You should wait/

          res
        end
    when /juggl/i
      print.call 'juggling weapons'

      master_location = '2' if (master_location == 'two') || master_location.nil?

      prepare = proc { go2.call CharSettings['audience-room'] unless master }
      action =
        proc do
          res = do_task_command.call "wtrick juggle #{master_location}", ["but can't quite get the rhythm"]

          if res =~ /but can't quite get the rhythm/
            print.call 'sleeping 15 seconds so we don\'t cause too much noise'
            sleep 15
          elsif res !~ /pest/
            fput 'stop juggling'
          end

          res
        end
    when /initial/i
      print.call 'writing initials'
      weapon = CharSettings['audience-weapon-small']
      sheath = CharSettings['audience-sheath-small']

      action = proc { do_task_command.call 'wtrick initial', nil }
    when /sheath catch|catchs/i
      print.call 'sheath catch'
      action = proc { do_task_command.call 'wtrick catchs', nil }
    when /polish|prune|rake|scrub/i
      do_path_task.call info['task']
      next
    when /spit/i
      unless master
        print.call 'spit on a creature'

        prepare_field.call
        do_field.call('wtrick spit %s shirt', 0)
        finish_field.call
        next
      end

      print.call 'spitting on training dummy'
      prepare = proc { }
      action = proc { do_task_command.call "wtrick spit dummy #{master_location}", nil }
      finish = proc { }
    when /feint/i
      unless master
        print.call 'feint a creature'
        prepare_field.call
        do_field.call('wtrick feint %s', 7)
        finish_field.call
        next
      end

      print.call 'feint a master'
      prepare = proc { }
      action = proc { do_task_command.call "wtrick feint ##{GameObj.npcs.first.id}" }
    when /haircut/i
      unless master
        print.call 'haircut a creature'
        prepare_field.call
        do_field.call('wtrick haircut %s', 7)
        finish_field.call
        next
      end

      print.call 'haircut training dummy'
      action = proc { do_task_command.call 'wtrick haircut dummy', nil }
    when /skilled masters/i
      go2.call 'warrior guild masters'

      master = true

      npc = GameObj.npcs.first
      dothistimeout "ask ##{npc.id} for training tricks",
                    3,
                    /Let me demonstrate|Let me show you|Now I show you|How about I show you/

      # check for task for 2 minutes
      1200.times do
        line = get?

        if line =~ /places the handle of .* on (his|her) (palm|finger|foot|chin|nose)/i
          master_location = Regexp.last_match(2)
        elsif line =~ /makes a wet gargling sound and spits .* (shirt|feet|foot|hand|face|eye)/
          master_location = Regexp.last_match(1)
          if master_location =~ /foot/
            master_location = 'left foot'
          elsif master_location =~ /hand/
            master_location = 'left hand'
          elsif master_location =~ /eye/
            master_location = 'left eye'
          end
        elsif line =~ /but just with (two)/
          master_location = Regexp.last_match(1)
        elsif line =~ /Type WTRICK (.*) to practice this trick\./
          do_trick.call(Regexp.last_match(1).to_s)
          break
        elsif line =~ /escorts you back/
          next
        end

        sleep 0.10
      end

      fput 'out'
    else
      error.call "task #{info['task']} not yet implemented"
    end

    wait_pcs = proc do
      pcs = GameObj.pcs.find_all { |pc| pc.status !~ /dead/ }
      if pcs.nil? || (pcs.length < 5)
        print.call 'waiting for more pcs to show up'
        wait_until { GameObj.pcs.find_all { |pc| pc.status !~ /dead/ }.length > 4 }
      end
    end

    prepare.call

    while (res = action.call)
      waitrt?

      if res.nil?
        error.call "unknown response for #{info['task']}: #{res}"
      elsif res =~ /completed/
        break
      elsif res =~ /You should wait (\d+)/
        print.call 'waiting to perform trick'
        sleep(Regexp.last_match(1).to_i + 1)
      end

      wait_pcs.call unless master
    end

    waitrt?
    finish.call
  end

  do_trick.call(info['task'])
end

do_cheapshots = proc do
  print.call 'running subdue routine'
  info = get_skill_info.call 'subdue'

  case info['task']
  when 'creatures'
    print.call 'doing field reps'
    prepare_field.call
    do_field.call('subdue %s', 20)
    finish_field.call
  else
    error.call "task #{info['task']} not yet implemented"
  end
end

do_lmas = proc do
  print.call 'running lock mastery routine'
  info = get_skill_info.call 'lmas'

  get_ranks = proc do
    match = /You have (\d+) ranks? in the Lock Mastery skill\./
    res = dothistimeout('gld', 5, match)
    error.call('Failed to find Lock Mastery ranks') unless res

    res =~ match
    ranks = Regexp.last_match(1).to_i
    ranks >= 25 ? 25 : ranks + 1
  end

  run_sbox = proc do |room, settings|
    if info['task'] == 'wedge'
      get_ranks.call
      res = waitfor(['At least \d+', 'You have'])
      error.call('Failed to find wedge response') unless res

      if res =~ /At least (\d+)/
        plated = Regexp.last_match(1)
        left = Regexp.last_match(1) if waitfor('You have') =~ /You have (\d+)/
        settings[:wedge_always] = left > plated
      else
        settings[:wedge_always] = true
      end
    end

    fput 'stand' until standing?

    go2.call(room)

    # SBox uses a global for single run overrides
    $sbox_settings = settings

    Script.start('sbox', 'pool')
    wait_until { Script.running?('sbox') }

    loop do
      break if reget.reverse[0..25].any? { |l| l =~ /\[You have completed/ }
      break if info['task'] == 'wedge' && reget.reverse[0..25].any? { |l| l =~ /\[You have \d repetition/ }

      error.call('picker crashed') unless Script.running?('sbox')
      sleep(1)
    end

    Script.kill('sbox') if Script.running?('sbox')
    wait_while { Script.running?('sbox') }
    waitrt?
    Room.current.tags.find { |t| t =~ /meta:boxpool:npc:(.*)/ }
    if (npc = GameObj.npcs.find { |n| n.name == Regexp.last_match(1) }).nil?
      error.call('Failed to find locksmith NPC')
    end

    fput "ask ##{npc.id} for check"
    fput "ask ##{npc.id} for check"
  end

  case info['task']
  when 'audience'
    print.call 'lock mastery trick in front of audience'

    dothistimeout('lmas', 5, /Where {trick} is one of the following/)
    error.call('failed to find LMASTERY trick') unless reget.reverse[0..10].any? { |l| l =~ /(TWIST|SPIN|TURN)/ }

    run_sbox.call(
      CharSettings['pool-audience-room'],
      {
        command: "lmaster ptrick #{Regexp.last_match(1).downcase} $B",
        ranks: get_ranks.call
      }
    )
  when 'calibrate'
    run_sbox.call(CharSettings['pool-room'], { calibrate_count: 1 })
  when 'contest'
    print.call 'lock mastery picking contest'
    wait_while { Script.running?('sbox') }

    unless checkarea =~ /dark corner/i
      go2.call('rogue guild trainer')
      npc = GameObj.npcs.first
      res = dothistimeout "ask ##{npc.id} for training lock mastery", 60, /As an apprentice goes about setting up/
      error.call 'unknown lock mastery footpad result' unless res
    end

    fput "nod at ##{npc.id}"
    wait_until { GameObj.loot.length.positive? }
    Script.run('sbox', 'contest')
    waitrt?
    fput XMLData.room_exits.first if checkarea =~ /dark corner/i
  when 'master'
    relock = proc do
      Script.run('sbox', 'scan')

      lockpick = $sbox_data.lockpicks.max_by(&:mod)
      raise ScriptError, 'failed to find lockpick' unless lockpick

      table = GameObj.loot.find { |obj| obj.noun == 'table' }
      raise ScriptError, 'failed to find table' unless table

      npc = GameObj.npcs.first
      raise ScriptError, 'failed to find npc' unless npc

      loop do
        unless table.contents
          fput "look on ##{table.id}"
          sleep(1)
        end

        box = table.contents.find { |obj| obj.noun == 'box' }
        raise ScriptError, 'failed to find box' unless box

        dothis("get ##{box.id}", /You remove/)
        lockpick.get
        dothis("lmas relock ##{box.id}", /It locks!/)
        waitrt?
        lockpick.store
        res = dothistimeout("give ##{box.id} to ##{npc.id}", 3, /completed|remaining/)
        raise ScriptError, 'failed to find give result' unless res

        break if res =~ /completed/
      end
    end

    appraise = proc do
      conditions = %w[
        broken
        miserable\ condition
        poor\ condition
        noticeably\ damaged
        neglected\ state
        good\ condition
        excellent\ condition
      ]
      bonuses = %w[
        detrimental
        ineffectual
        very\ inaccurate
        inaccurate
        somewhat\ inaccurate
        inefficient
        unreliable
        below\ average
        average
        above\ average
        somewhat\ accurate
        favorable
        advantageous
        accurate
        highly\ accurate
        excellent
        incredible
        unsurpassed
      ]
      strengths = %w[
        flimsy
        very\ weak
        weak
        below\ average\ strength
        average\ strength
        above\ average\ strength
        is\ strong
        is\ very\ strong
        excellent\ strength
        incredibly\ strong
        astonishingly\ strong
        unsurpassed\ strength
      ]

      unless (table = GameObj.loot.find { |l| l.noun == 'table' })
        error.call 'Failed to find table'
      end

      unless table.contents
        res = dothistimeout("look on ##{table.id}", 5, /On the/)
        error.call 'Failed to look at table contents' unless res
      end

      best = nil
      best_condition_index = -999
      best_bonus_index = -999
      best_strength_index = -999
      best_repair_count = 999

      table.contents.find_all { |obj| obj.name =~ /lockpick/ }.each do |lockpick|
        fput "get ##{lockpick.id}"
        match = /(#{conditions.join('|')})/i
        res = dothistimeout("lmas appraise ##{lockpick.id}", 5, match)
        error.call 'Failed to get appraise info' unless res

        waitrt?

        # Condition
        res =~ match
        condition_index = conditions.index(Regexp.last_match(1))
        bonus_index = -1
        strength_index = -1
        repair_count = -1

        # Bonus
        res =~ /(#{bonuses.join('|')}).*level of precision/i && bonus_index = bonuses.index(Regexp.last_match(1))

        # Strength
        res =~ /(#{strengths.join('|')})/i && strength_index = strengths.index(Regexp.last_match(1))

        # Repair count
        res =~ /has never been repaired/ && repair_count = 0
        res =~ /has been repaired about (\d+)/i && repair_count = Regexp.last_match(1).to_i

        if (condition_index >= best_condition_index) &&
           bonus_index >= best_bonus_index &&
           strength_index >= best_strength_index &&
           repair_count <= best_repair_count
          best = lockpick
          best_condition_index = condition_index
          best_bonus_index = bonus_index if bonus_index > -1
          best_strength_index = strength_index if strength_index > -1
          best_repair_count = repair_count if repair_count > -1
          print.call("Found new best lockpick: #{best.inspect}")
        end

        fput "put ##{lockpick.id} on ##{table.id}"
      end

      error.call('Failed to find best lockpick') if best.nil?

      fput "get ##{best.id}"
      res = dothistimeout("give ##{best.id} to ##{GameObj.npcs.first.id}", 5, /accepts the/)
      error.call 'unknown lockpick give response' unless res
    end

    calibrate = proc do
      dothis('get calipers', /You remove/)
      dothis('lmas calibrate my calipers', /You begin attuning|You make some|You're good/)
      waitrt?
      loop do
        dothis('get calipers', /You remove/) unless [checkright, checkleft].include?('calipers')
        dothis('lmas measure box', /Using your/)
        waitrt?
        dothis('put calipers on table', /You place your/)
        dothis('get lockpick', /You remove/)
        dothis('pick box', /You settle/)
        waitrt?
        dothis('put lockpick on table', /You place your/)
        dothis('get calipers', /You remove/)
        dothis('lmas calibrate my calipers', /You begin attuning|You make some|You're good/)
        waitrt?
        res = do_task_command.call("give calipers to ##{npc.id}", ['This still needs some'])
        next unless res =~ /completed/

        waitrt?
        fput XMLData.room_exits.sample
        break
      end
    end

    measure = proc do
      dothis('get calipers', /You remove/)
      loop do
        fput 'lmas measure box'

        if waitfor('Measuring carefully') =~ /Measuring carefully, it looks to be an? (.*) lock/
          res = do_task_command.call("'#{Regexp.last_match(1).downcase}", nil)
          break if res =~ /completed/
        end

        waitrt?
      end

      waitrt?
      fput XMLData.room_exits.sample
    end

    make_wedges = proc do
      waitrt?

      fput 'gld'
      waitfor('in the Lock Mastery')
      waitfor('told you to visit')
      res = waitfor('You have')
      error.call('Failed to find required reps') unless res =~ /You have (\d+) repetitions?/

      fput XMLData.room_exits.sample
      $sbox_settings = { wedge_amount: Regexp.last_match(1).to_i, wedge_quality: 'warped' }
      Script.run('sbox', 'makewedges')
      go2.call('rogue guild trainer')
      npc = GameObj.npcs.first
      res = dothistimeout "ask ##{npc.id} for training lock mastery", 60, /gots a wedge for me/
      error.call("Couldn't get NPC response") unless res
    end

    go2.call('rogue guild trainer')
    npc = GameObj.npcs.first
    footpad_regex = Regexp.union(
      /LMASTER APPRAISE/,
      /LMASTER CALIBRATE/,
      /LMASTER MEASURE/,
      /LMASTER RELOCK/,
      /make yourself one of these here wedges|gots a wedge for me/,
      /break a pick occasionally/
    )
    res = dothistimeout "ask ##{npc.id} for training lock mastery", 60, footpad_regex
    error.call 'unknown lock mastery footpad result' unless res

    # Measuring boxes and speaking aloud
    if res =~ /LMASTER CALIBRATE/
      calibrate.call
    elsif res =~ /LMASTER MEASURE/
      measure.call
    elsif res =~ /LMASTER APPRAISE/
      loop do
        appraise.call
        break if reget.reverse[0..10].any? { |l| l =~ /completed/ }
      end
      fput 'out'
    elsif res =~ /LMASTER RELOCK/
      relock.call
    elsif res =~ /break a pick/
      error.call 'you must repair some broken lockpicks which this script does not handle'
    elsif res =~ /make wedges/
      waitfor 'escorts'
    elsif res =~ /wedge/
      wedges = lootsack.contents.find_all { |l| l.noun == 'wedge' }
      existing = wedges.collect(&:id)

      loop do
        wedges.each do |wedge|
          fput "get ##{wedge.id} from ##{lootsack.id}"
          res = dothistimeout("give ##{wedge.id} to ##{npc.id}", 5, /make a new one|accepts the|hang onto/)
          error.call('Unknown wedge give result') unless res

          break if reget.reverse[0..10] =~ /completed/

          fput "put ##{wedge.id} in ##{lootsack.id}"
        end

        break if reget.reverse[0..10] =~ /completed/

        make_wedges.call
        wedges = lootsack.contents.reject { |w| existing.include?(w.id) }.find_all { |l| l.noun == 'wedge' }
      end
    end
  when 'measure'
    run_sbox.call(CharSettings['pool-room'], { ranks: get_ranks.call })
  when 'relock'
    run_sbox.call(CharSettings['pool-room'], { ranks: get_ranks.call, relock: true })
  when 'tough'
    run_sbox.call(CharSettings['pool-room'], { ranks: get_ranks.call })
  when 'wedge'
    run_sbox.call(CharSettings['pool-room'], { wedge: true, wedge_quality: 'brittle' })
  else
    error.call "task #{info['task']} not yet implemented"
  end
end

do_gambits = proc do
  print.call 'running gambits routine'
  info = get_skill_info.call 'gambits'

  get_gambit = proc do
    error.call('failed to read gambits') if dothistimeout('rgam', 5, /TEACH/).nil?

    unless reget.reverse.any? { |l| l !~ /TEACH/ && l =~ /([A-Z]+)\s*(?:\[([^\]]+)\])?/ }
      error.call('failed to find gambit command')
    end

    next Regexp.last_match(1).downcase.strip unless Regexp.last_match(2)

    next "#{Regexp.last_match(1).downcase.strip} #{Regexp.last_match(2).split(' | ').last}" if Regexp.last_match(2)
  end

  clear_hands.call
  command = get_gambit.call

  case info['task']
  when 'audience'
    print.call 'gambits in front of audience'

    loop do
      go2.call(CharSettings['audience-room'])
      fput 'stand' until standing?
      res = do_task_command.call("rgam #{command}", nil)
      break if res =~ /completed/

      if res =~ /remaining/
        go2.call(CharSettings['rest-room'])
        sleep(32)
      end
    end
  when 'footpads'
    print.call 'lessons from footpads'
    go2.call 'rogue guild trainer'

    npc = GameObj.npcs.first
    res = dothistimeout "ask ##{npc.id} for training gambits", 60, /RGAMBIT/
    error.call 'unknown gambits footpad result' if res !~ /RGAMBIT/

    loop do
      fput 'stand' until standing?
      res = do_task_command.call("rgam #{command}", nil)
      break if res =~ /completed/
    end
  when 'learn'
    print.call 'gambits learn from a partner'

    if CharSettings['partner-trade']
      trade_in.call('gambits')
    else
      error.call 'not yet implemented'
    end
  when 'teach'
    print.call 'gambits teach a partner'

    if CharSettings['partner-trade']
      trade_in.call('gambits')
    else
      error.call 'not yet implemented'
    end
  when 'speed'
    Script.run('table') if Script.exists?('table')
    loop do
      fput 'stand' until standing?
      res = do_task_command.call("rgam #{command}", nil)
      break if res =~ /completed/
    end
  else
    error.call "task #{info['task']} not yet implemented"
  end
end

do_stunman = proc do
  print.call 'running stunman routine'
  info = get_skill_info.call 'stunman'

  get_stunman_command = proc do
    command = nil
    done = false

    action =
      proc do |server_string|
        next server_string if done

        if server_string =~ %r{[^>]+>(\w+)</a>\s+}
          if Regexp.last_match(1).to_s.downcase == 'automatic'
            done = true
          else
            command = Regexp.last_match(1).to_s.downcase
          end
          nil
        elsif server_string =~ /(\w+)\s+/
          if Regexp.last_match(1).to_s.downcase == 'automatic'
            done = true
          else
            command = Regexp.last_match(1).to_s.downcase
          end
          nil
        elsif !server_string.nil? && !server_string.empty? && server_string !~ /\r\n||&gt;/
          server_string
        end
      end

    DownstreamHook.add 'sguild_get_stunman', action
    $_SERVER_.puts "#{$cmd_prefix}stunman\n"
    start = Time.now.to_f
    wait_until { done || (Time.now.to_f - start >= 3.0) }
    DownstreamHook.remove 'sguild_get_stunman'

    next command.downcase
  end

  case info['task']
  when 'arrows'
    print.call 'doing arrows'
    go2.call 'rogue guild trainer'

    npc = GameObj.npcs.first
    res = dothistimeout "ask ##{npc.id} for training stunman", 60, /No points on these arrows/

    error.call 'unknown stunman result' if res.nil?

    print.call 'running dodge loop'

    last_cmd = nil
    cmd = nil

    fput 'stance offensive'

    loop do
      until standing?
        sleep(0.25)
        fput 'stand'
        waitrt?
      end

      loop do
        cmd = ['lean left', 'lean right', 'duck', 'jump'].sample
        break if last_cmd != cmd
      end

      last_cmd = cmd
      res = dothistimeout cmd, 60, /You have to dodge|completed|repetition/
      break if res =~ /completed|repetition/

      waitrt?
    end

    waitrt?
    fput XMLData.room_exits.sample
  when 'footpads'
    print.call 'lessons from footpads'
    go2.call 'rogue guild trainer'

    command = get_stunman_command.call
    npc = GameObj.npcs.first
    res = dothistimeout "ask ##{npc.id} for training stunman", 60, /NOD/
    error.call 'unknown stunman footpad result' if res !~ /NOD/

    command = "attack ##{GameObj.npcs.first.id}" if command == 'attack'

    loop do
      unless stunned?
        fput 'stance offensive'
        fput 'nod'
        fput CharSettings['stun-command']
      end

      wait_until { stunned? }

      res = do_task_command.call("stun #{command}", nil)
      if res =~ /completed/
        put 'unstun'
        break
      end

      wait_for_stamina.call unless checkstamina(15)
    end

    wait_while { stunned? }
    fput XMLData.room_exits.sample
  when 'practice'
    print.call 'doing stun practice'
    clear_hands.call

    command = get_stunman_command.call

    # special case, have to attack something
    if command == 'attack'
      print.call 'doing attack in the field; make sure field settings and wander boundaries are set'
      sleep(3)
      prepare_field.call
      do_field.call('stunman attack %s', 15)
      finish_field.call

      next
    end

    loop do
      unless stunned?
        fput 'stance offensive'
        fput CharSettings['stun-command']
      end

      res = do_task_command.call("stun #{command}", nil)
      if res =~ /completed/
        wait_while { stunned? }
        waitrt?
        break
      elsif reget.find { |l| l =~ /You are already at/ }
        wait_while { stunned? }
        fput 'stance offensive'
      end

      unless checkstamina(15)
        go2.call CharSettings['rest-room']
        wait_for_stamina.call
      end
    end
  when 'slaphands'
    print.call 'doing slaphands'
    go2.call 'rogue guild trainer'

    npc = GameObj.npcs.first
    res =
      dothistimeout(
        "ask ##{npc.id} for training stunman",
        60,
        /just put your hands on mine by choosing SLAP, DUCK or STOP/
      )

    error.call 'unknown stunman result' if res.nil?

    print.call 'running slaphands loop'

    last_cmd = nil
    cmd = nil

    fput 'stance offensive'

    loop do
      until standing?
        sleep(0.25)
        fput 'stand'
        waitrt?
      end

      loop do
        cmd = %w[slap duck stop].sample
        break if last_cmd != cmd
      end

      last_cmd = cmd
      dothistimeout cmd, 60, /Roundtime:/
      sleep(1)
      break if reget.reverse[0..15].any? { |l| l =~ /completed|repetition/i }

      waitrt?
    end

    waitrt?
    fput XMLData.room_exits.sample
  when 'sweep'
    print.call 'sweeping the courtyard'
    do_path_task.call 'sweep'
  when 'windows'
    print.call 'cleaning windows'
    do_path_task.call 'windows'
  else
    error.call "task #{info['task']} not yet implemented"
  end
end

do_subdue = proc do
  print.call 'running subdue routine'
  info = get_skill_info.call 'subdue'

  case info['task']
  when 'creatures'
    print.call 'doing field reps'
    prepare_field.call
    do_field.call('subdue %s', 20)
    finish_field.call
  else
    error.call "task #{info['task']} not yet implemented"
  end
end

do_sweep = proc do
  print.call 'running sweep routine'
  info = get_skill_info.call 'sweep'

  case info['task']
  when 'na'
    echo 'nope'
  else
    error.call "task #{info['task']} not yet implemented"
  end
end

start = proc do |skill|
  rest.call if CharSettings['wounded'].call

  case skill
  when 'batter'
    error.call "you didn't set a batter weapon sheath" if CharSettings['batter-sheath'].to_s.empty?
    error.call "you didn't set a batter weapon" if CharSettings['batter-weapon'].to_s.empty?
    do_batter.call
  when 'tackle'
    do_tackle.call
  when 'berserk'
    do_berserk.call
  when 'disarm'
    do_disarm.call
  when 'tricks'
    error.call "you didn't set an audience sheath" if CharSettings['audience-sheath'].to_s.empty?
    error.call "you didn't set an audience weapon" if CharSettings['audience-weapon'].to_s.empty?
    error.call "you didn't set a small audience weapon" if CharSettings['audience-weapon-small'].to_s.empty?
    do_tricks.call
  when 'warcries'
    do_warcries.call
  when 'cheapshots'
    do_cheapshots.call
  when 'lmas'
    do_lmas.call
  when 'gambits'
    do_gambits.call
  when 'stunman'
    do_stunman.call
  when 'subdue'
    do_subdue.call
  when 'sweep'
    do_sweep.call
  end
end

partner_warcry = proc do |partner|
  print.call "teaching warcries to #{partner}"
  fput "warcry teach #{partner}"

  partner_regex =
    Regexp.join(
      "#{partner} whispers, \"All finished\. Thank you\!\"",
      "#{partner} whispers\, \"I need to give my throat a rest\.\""
    )

  start = Time.now.to_i
  loop do
    line = get?

    break if line =~ partner_regex

    if line =~ /#{partner} whispers\, "I need another lesson please\.\"/
      start = Time.now.to_i
      fput "warcry teach #{partner}"
    elsif line =~ /#{partner} is busy concentrating on someone else\'s lessons at the moment\./
      fput "whisper #{partner} You are currently already learning. Waiting 15 seconds and trying again."
      sleep 15
      next partner_warcry.call(partner)
    elsif line =~ /You don\'t know enough about war cries to be much of a teacher to .*\./
      fput "whisper #{partner} Sorry I am unable to teach you. You either have more skill ranks than I do or you have the same amount but are a higher level."
      break
    end

    if Time.now.to_i - start > 300
      print.call 'timeout hit, aborting...'
      break
    end

    sleep 0.10
  end

  print.call "done teaching warcries to #{partner}"
end

partner = proc do
  loop do
    print.call 'waiting on partner request'
    while (line = get)
      next unless line =~ /(\w+) whispers, "Can you teach me (\w+)\?"/i

      partner = Regexp.last_match(1).to_s
      skill = Regexp.last_match(2).to_s
      break
    end

    fput "whisper #{partner} I am ready."
    case skill
    when 'warcries'
      partner_warcry.call(partner)
    else
      error.call "partnering for #{skill} is not written yet"
    end
  end
end

help = proc do
  help = <<~HELPTEXT
    SpiffyWar by SpiffyJr (theman@spiffyjr.me)

    Usage:
            ;#{script.name} <skill>                   run in normal mode using the skill provided
              ;#{script.name} clear-hands               clears hands, including stowing any tools you have
              ;#{script.name} clear-locker              lockers any items in use (like your batter maul)
              ;#{script.name} help                      show this help message
              ;#{script.name} list                      dump a list of the current settings

    Skills\:
            batter
            berserk
            disarm
            tackle
            tricks
            warcries

            cheap
            gambits
            lock
            stunman
            subdue
            sweep

    Settings\:
            Change settings by using [setting] [value].
            For example, ;#{script.name} audience-room 228.

            fried [on|off]                            if true will turn in even when fried (default: false)

            loop [on|off]                             whether or not to run continuously (default: false)
            loop-mind [value]                         when loop mode is on stop running when mind reaches this value (default: 0)
            loop-bounty [on|off]                      will stop looping if you can do a bounty, overrides loop-mind (default: false)
            loop-no-reset [on|off]                    if enabled will exit instead of waiting on guild to reset (default: false)
            loop-no-vocal [on|off]                    if enabled will exit instead of waiting on vocal chords (default: false)

            travel [on|off]                           travel between guilds - uses speed2, so have it downloaded (default: false)
            rest-room                                 room to rest in while waiting (default: 228)
            rest-enter                                commands when entering the rest room (default: none)
            rest-exit                                 commands when exiting the rest room (default: none)
            rest-scripts                              scripts to run before resting (default: useherbs --buy-missing=on, sloot sell)
            loot-script                               script used to loot after field reps (default: sloot)

            audience-room                             audience room to perform tricks in (default: 228)
            audience-weapon                           weapon to use for audience reps (balance, draw, polish, etc)
            audience-weapon-small                     weapon used for small audience reps (initials)
            audience-sheath                           sheath to store weapon in after audience reps
            audience-sheath-small                     sheath to store small weapon in after audience reps

            batter-weapon                             weapon used to batter barriers
            batter-sheath                             sheath that holds the batter weapon
            batter-trade                              will trade in bashing critter boxes
            locker                                    starting room to get locker contents
            locker-in                                 directions to get to locker room (for rooms that aren't mapped)
            locker-out                                directions to get out of locker room (for rooms that aren't mapped)

            field-prepare                             field prepare commands separated with comma (default: gird)
            field-finish                              field finish commands separated with comma (default: store all)
            field-room                                field room (;wander add <room> for boundaries)
            field-scripts                             scripts to use while in the field hunting
            field-targets                             targets accepted during field reps

            partner-trade                             will trade in partner tasks when you get them
            partner-name                              name of the partner to do reps with
            partner-room                              room your partner is parked in

            stun-command                              the command to use to stun yourself

            weapon-brawling                           your brawling weapon
            weapon-polearm                            your polearm weapon
            weapon-edged                              your edged weapon
            weapon-sheath                             your weapon sheath for all the weapons above
  HELPTEXT

  respond help
  exit
end

bools = %w[loop batter-trade partner-trade travel loop-bounty loop-no-reset loop-no-vocal fried]
ints = %w[loop-mind audience-room partner-room field-room rest-room]
array = %w[field-prepare field-finish rest-scripts field-scripts field-targets locker-in locker-out]
procs = %w[wounded]

if script.vars.empty?
  help.call
elsif script.vars[1] =~ /partner$/i
  partner.call
elsif script.vars[1] =~ /clear-hands/i
  clear_hands.call
elsif script.vars[1] =~ /clear-locker/i
  clear_locker.call
elsif script.vars[1] =~ /list/i
  CharSettings.to_hash.sort.each do |key, value|
    if bools.include? key
      value = value ? 'on' : 'off'
    elsif array.include? key
      value = value.join(',')
    elsif procs.include? key
      next
    end

    print.call format '%20s: %s', key, value
  end
elsif script.vars[1] =~ /^(fried|loop-no-reset|loop-no-vocal|loop-bounty|partner-room|partner-name|travel|field-prepare|field-finish|rest-scripts|field-scripts|field-room|field-targets|partner-trade|batter-trade|locker|locker-in|locker-out|batter-sheath|batter-weapon|audience-room|audience-weapon|audience-weapon-small|audience-sheath|audience-sheath-small|loop|loop-mind|rest-room|rest-exit|rest-enter|loot-script|weapon-sheath|weapon-polearm|weapon-brawling|weapon-edged|stun-command|pool-room|pool-audience-room)$/i
  key = Regexp.last_match(1)
  script.vars.shift
  script.vars.shift
  value = script.vars.join(' ')

  if bools.include? key
    value = value == 'on'
  elsif ints.include? key
    value = value.to_i
  elsif array.include? key
    value = value.split(',')
  end

  CharSettings[key] = value
  print.call "#{key} set to #{value.inspect}"
elsif (script.vars[1] == 'batter') && script.vars[2]
  do_batter_thing.call script.vars[2]
elsif script.vars[1] =~ /#{skill_short_to_long.keys.join('|')}/i
  clear_hands.call

  if CharSettings['loop']
    loop do
      rest.call if CharSettings['wounded'].call

      if CharSettings['loop-bounty'] && !Spell['Next Bounty'].active?
        print.call 'exiting because a bounty is available'
        break
      end

      if CharSettings['loop-mind'].positive? && (percentmind <= CharSettings['loop-mind'])
        print.call 'exiting because mind is below threshold'
        break
      end

      start.call script.vars[1]
      sleep 0.25
    end
  else
    start.call script.vars[1]
  end
else
  help.call
end
