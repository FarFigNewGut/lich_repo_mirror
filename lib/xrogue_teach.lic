=begin

  Thanks all the helpful testers their patience and contributions.
    ~ Xanlin

  Forked from Tgo01 (Dreaven)'s rogue script
  
  Automates many rogue guild tasks. Currently automates all solo sweep, gambit, cheap shot and subdue tasks. Can also automate critter sweep tasks.
  In order to automate sweep, gambit and cheap shot partner reps you and your partner must have both this script and the "task" script.

  Must do ;xrogue setup and fill out the settings before running this script.
  This shares settings with ;rogue, so if you have ;rogue setup you won't have to do it all over again

  Type ;xrogue for usage.

  ;xrogue cheap for solo cheap shot tasks. ;xrogue cheap <partnername> for partner tasks.
  ;xrogue gam   for solo gambit tasks.     ;xrogue gam <partnername>   for partner tasks.
  ;xrogue lmas  for lockmastery tasks.      Doesn't do all lockmastery tasks.
  ;xrogue sweep for solo sweep tasks.      ;xrogue sweep <partnername> for partner tasks.
  ;xrogue sub   for solo subdue tasks.
  ;xrogue stun  for stun maneuvers tasks.   some are not implemented and some have bugs. Let me know about bugs or if you want to help test.
    - for stun, this script expects you to have a stunning skull

  ;xrogue <cheap, gam, lmas, stun, sub, or sweep> will also turn in completed tasks to the NPC.
  ;xrogue cal             to calibrate your calipers.
  ;xrogue wedge <number>  to create specified number of wedges.

  Note: do not type GLD while script is running, it could make the script stop working.

  Remember afk scripting is a no no in prime/platinum so pay attention to your game screen while running this script.
  Kill this script if going afk.

  Author: Xanlin
  Version:  50

  changes: 
    - will try to have your partner promote you first
      _ need to add a check to see if they are a guildmaster though
    - changed audience rooms to my liking, should really be a setting instead
    - added rooms for Teras and River's Rest 
        (let me know if you find any bugs with rooms)
    - fixed some issues with partner procs, made some more issues (probably)
    - added some stun tasks (can't test anymore, need volunteers)
    - auto detect latest gambit 
        (still a wip, should be good through rank 45)
    - added more gambits 
        (up through vanish so far)
    - auto cheapshot critter tasks 
        (uses same settings as sweep critter tasks)
    - auto subsdue critter tasks 
        (uses same settings as sweep critter tasks)
        - todo: should probably run away if yer beaten up too bad
    
=end
if !UserVars.rogue_password
  respond "+---------------"
  respond "   You need to set your rogue guild password for things to run smoothly"
  respond "   e.g. ;vars set rogue_password=turn,pull,kiss,tap,kiss,turn"
  respond "   Use your password, not the example."
  respond "+---------------"
  sleep 5
  exit
end
  

#silence_me if Char.name !~ /Xanlin|Thyfaiin|Zakarius/i;
debug = false;
if XMLData.name =~ /Xanlin|Thyfaiin|Clairette/i; debug = true; end;
#if Char.name =~ /Xanlin|Thyfaiin/i; debug = true; end;
thyfaiin = XMLData.name. =~ /Thyfaiin/i ? true : false
version = 47
script_name  = script.name
current_proc = nil
respond "+--------------- #{script_name}: #{script.vars[0]}" if debug
#my_partner   = nil
my_partner = script.vars[2] =~ /teach/i ? script.vars[3] : script.vars[2];
echo "my_partner: #{my_partner}" if debug

task         = UserVars.rogue["task"] 

module Xmod
  monsterbold_start = $fake_stormfront ? "\034GSL\r\n " : "<pushBold\/>"
  monsterbold_end   = $fake_stormfront ? "\034GSM\r\n " : "<popBold\/>"
  def self.format_mono(msg) "<output class=\"mono\" />#{msg}<output class=\"\" />" end
  def self.format_monsterbold(msg) "#{monsterbold_start}#{msg}#{monsterbold_end}"end
  def self.format_whisper(msg) "<preset id=\"whisper\">#{msg}</preset>" end
  def self.sendto_familiar(msg) "<pushStream id=\"familiar\"/>#{msg}\n<popStream/>\n" end
  def self.sendto_thought(msg) "<pushStream id=\"thoughts\"/>#{msg}\n<popStream/>\n" end
  def self.gs_print(msg) 
    if $frontend =~ /stormfront/
      puts msg
    elsif $frontend =~ /profanity/
      # #echo msg.gsub(/<\/?(preset|output)[^>]*>/,"")
      _respond msg
    else #wizard fe needs to have the xml stuff stripped
      $stdout.puts msg.gsub!(/<.*?>/, '')
    end
    #lich.rb _respond 
  end
end

wander_rooms               = Array.new
weapon                     = UserVars.rogue["task_weapon"]
stow_container             = UserVars.rogue["stow_container"]
wedge_container            = UserVars.rogue["wedge_container"]
calipers_container         = UserVars.rogue["calipers_container"]
lockpick_container         = UserVars.rogue["lockpick_container"]
mainweapon                 = UserVars.rogue["mainweapon"]
shield                     = UserVars.rogue["shield"]
auto_promote               = UserVars.rogue["auto_promote"]
update_partner             = UserVars.rogue["update_partner"]
lock_create_number         = UserVars.rogue["lock_create_number"]
auto_run_after_partner_reps= UserVars.rogue["auto_run_after_partner_reps"]
do_other_guild_tasks       = UserVars.rogue["do_other_guild_tasks"]
lmas_lockpick              = UserVars.rogue["lmas_lockpick"]
do_critter_sweep_tasks     = UserVars.rogue["do_critter_sweep_tasks"]
$stealth_get_item          = UserVars.rogue["stealth_get_item"]
$stealth_get_item_container= UserVars.rogue["stealth_get_item_container"]
stealth_get_item           = UserVars.rogue["stealth_get_item"]
stealth_get_item_container = UserVars.rogue["stealth_get_item_container"]
#gam                        = UserVars.rogue["gambit"]
user_debug                 = UserVars.rogue["user_debug"] == "yes" ? true : false
gam = nil
flee_from_critters         = /#{UserVars.rogue["flee_from_critters"]}/i
valid_critter_targets      = /#{UserVars.rogue["valid_critter_targets"]}/i
flee_from_critters_count   = UserVars.rogue["flee_from_critters_count"].to_i
critter_task_rooms         = "#{UserVars.rogue["critter_task_rooms"]}".split(",")
partner_room_number        = UserVars.rogue["partner_room_number"]
lich_message_partner       = UserVars.rogue["lich_message_partner"]

numberoflockpicks          = nil
current_window_rooms       = nil
 first_run                 = true
 get_item_trick             = false
 stealth_get_item_trick     = false
 hide_before_trick          = false
 gam_retry                  = false
 no_whisper_wait           = false
 before_gambit              = nil
 after_gambit               = nil
 sleep_timer                = 30 
 do_timer                   = 5
 calling_proc               = nil
 test_gam                   = nil

auto_promote                = auto_promote                !~ /^n/i ? "on" : auto_promote
update_partner              = update_partner              !~ /^n/i ? "on" : update_partner
#auto_run_after_partner_reps = auto_run_after_partner_reps !~ /^n/i ? "yes" : auto_run_after_partner_reps
do_other_guild_tasks        = do_other_guild_tasks        !~ /^n/i ? "yes" : do_other_guild_tasks
#do_critter_sweep_tasks      = do_critter_sweep_tasks      == "no" ? "skip" : do_critter_sweep_tasks
#stealth_get_item            = stealth_get_item            == "" ? "smooth stone" : stealth_get_item
#stealth_get_item_container  = stealth_get_item_container  == "" ? "backpack" : stealth_get_item_container
flee_from_critters_count    = flee_from_critters_count    == "" ? "1" : flee_from_critters_count
#lich_message_partner        = lich_message_partner        !~ /^n/i ? "yes" : lich_message_partner
#CharSettings['setup_has_been_run'] = nil unless CharSettings['setup_has_been_run']
echo "lich_message_partner: #{lich_message_partner}" if debug

setup = proc{
  CharSettings['setup_has_been_run'] = true
  latest_gambit = nil
  latest_gambit.call
  Gtk.queue {
    $AAA_WINDOW = Gtk::Window.new
    $AAA_WINDOW.title = "rogue"
    $AAA_WINDOW.set_border_width(10)
    $AAA_BOX = Gtk::VBox.new(false)
    $AAA_BOX.set_border_width(5)

    $AAA_VERTICAL_BOX1 = Gtk::VBox.new(false, 0)
    $AAA_VERTICAL_BOX2 = Gtk::VBox.new(false, 0)
    $AAA_VERTICAL_BOX3 = Gtk::VBox.new(false, 0)
    $AAA_VERTICAL_BOX4 = Gtk::VBox.new(false, 0)
    $AAA_VERTICAL_BOX5 = Gtk::VBox.new(false, 0)

    $AAA_WINDOW.add($AAA_BOX)
    $AAA_NOTEBOOK = Gtk::Notebook.new
    $AAA_NOTEBOOK.set_show_border(true)
    $AAA_BOX.add($AAA_NOTEBOOK)
    $AAA_NOTEBOOK.append_page($AAA_VERTICAL_BOX1, Gtk::Label.new('Info'))
    $AAA_NOTEBOOK.append_page($AAA_VERTICAL_BOX2, Gtk::Label.new('More Info'))
    $AAA_NOTEBOOK.append_page($AAA_VERTICAL_BOX3, Gtk::Label.new('Gambits'))
    $AAA_NOTEBOOK.append_page($AAA_VERTICAL_BOX4, Gtk::Label.new('Sweep'))
    $AAA_NOTEBOOK.append_page($AAA_VERTICAL_BOX5, Gtk::Label.new('Partner Info'))
    $AAA_ENTRY = Hash.new
    $AAA_TABLE_SIZE = Hash.new
  }

  Gtk.queue {
    $AAA_TABLE1 = Gtk::Table.new(6, 3, false)
    $AAA_TABLE1.row_spacings=3
    $AAA_TABLE1.column_spacings=3
    $AAA_VERTICAL_BOX1.pack_start($AAA_TABLE1, false, false, 0)

    $AAA_TABLE2 = Gtk::Table.new(6, 3, false)
    $AAA_TABLE2.row_spacings=3
    $AAA_TABLE2.column_spacings=3
    $AAA_VERTICAL_BOX2.pack_start($AAA_TABLE2, false, false, 0)

    $AAA_TABLE3 = Gtk::Table.new(6, 3, false)
    $AAA_TABLE3.row_spacings=3
    $AAA_TABLE3.column_spacings=3
    $AAA_VERTICAL_BOX3.pack_start($AAA_TABLE3, false, false, 0)

    $AAA_TABLE4 = Gtk::Table.new(6, 3, false)
    $AAA_TABLE4.row_spacings=3
    $AAA_TABLE4.column_spacings=3
    $AAA_VERTICAL_BOX4.pack_start($AAA_TABLE4, false, false, 0)

    $AAA_TABLE5 = Gtk::Table.new(6, 3, false)
    $AAA_TABLE5.row_spacings=3
    $AAA_TABLE5.column_spacings=3
    $AAA_VERTICAL_BOX5.pack_start($AAA_TABLE5, false, false, 0)
  }

  def self.add_label_entry(table, label, variable)
    size = $AAA_TABLE_SIZE[table] || 0

    label = Gtk::Label.new(label)
    align = Gtk::Alignment.new 1, 0, 0, 0
    align.set_padding(4, 0, 3, 4)
    align.add(label)
    table.attach(align, 0, 1, size, size + 1)

    entry = Gtk::Entry.new
    entry.text = UserVars.rogue[variable].to_s
    entry.set_width_request(157)
    table.attach(entry, 1, 2, size, size + 1)

    $AAA_ENTRY[variable] = entry
    $AAA_TABLE_SIZE[table] += 1
  end

  Gtk.queue {
    $AAA_ENTRY = Hash.new
    add_label_entry($AAA_TABLE1, "Task weapon:", 'task_weapon')
    add_label_entry($AAA_TABLE1, "Stow container:", 'stow_container')
    add_label_entry($AAA_TABLE1, "Wedge container:", 'wedge_container')
    add_label_entry($AAA_TABLE1, "Calipers container:", 'calipers_container')
    add_label_entry($AAA_TABLE1, "Lockpick container:", 'lockpick_container')
    add_label_entry($AAA_TABLE1, "Main weapon:", 'mainweapon')
    add_label_entry($AAA_TABLE1, "Shield/offhand:", 'shield')
    add_label_entry($AAA_TABLE2, "Auto promote:", 'auto_promote')
    add_label_entry($AAA_TABLE2, "Update partner:", 'update_partner')
    add_label_entry($AAA_TABLE2, "Lock create number:", 'lock_create_number')
    add_label_entry($AAA_TABLE2, "Auto run after partner reps:", 'auto_run_after_partner_reps')
    add_label_entry($AAA_TABLE2, "Do other guild tasks:", 'do_other_guild_tasks')
    add_label_entry($AAA_TABLE2, "Lmas lockpick:", 'lmas_lockpick')
    add_label_entry($AAA_TABLE2, "Do critter sweep tasks", 'do_critter_sweep_tasks')
    add_label_entry($AAA_TABLE3, "Stealth get item:", 'stealth_get_item')
    add_label_entry($AAA_TABLE3, "Stealth get item container:", 'stealth_get_item_container')
    add_label_entry($AAA_TABLE3, "Gambit:", 'gambit')
    add_label_entry($AAA_TABLE3, "Debug:", 'user_debug')
    add_label_entry($AAA_TABLE4, "Flee from critters:", 'flee_from_critters')
    add_label_entry($AAA_TABLE4, "Valid critter targets:", 'valid_critter_targets')
    add_label_entry($AAA_TABLE4, "Flee from critters count:", 'flee_from_critters_count')
    add_label_entry($AAA_TABLE4, "Critter rooms:", 'critter_task_rooms')
    add_label_entry($AAA_TABLE5, "Partner room number:", 'partner_room_number')
    add_label_entry($AAA_TABLE5, "Lich message partner:", 'lich_message_partner')

  }

  def self.add_checkbox(table, x_pos, label, variable, default = false)
    size = $AAA_TABLE_SIZE[table] || 0
    checkbox = Gtk::CheckButton.new label
    value = UserVars.rogue[variable].nil? ? default : UserVars.rogue[variable]
    checkbox.set_active(value)
    table.attach(checkbox, x_pos, x_pos + 1, size, size + 1)
    $AAA_ENTRY[variable] = checkbox
    $AAA_TABLE_SIZE[table] += 1 if x_pos == 1
  end

  Gtk.queue {
    $AAA_WINDOW.signal_connect("delete_event") {
      $AAA_SETUP_COMPLETED = true
    }
  }

  Gtk.queue {
    $AAA_TOOLTIPS = Gtk::Tooltips.new
    $AAA_TOOLTIPS.enable

    label = Gtk::Label.new
    label.set_markup("Enter <b>nil</b> for any setting you don't want to use.\n<b>Task weapon:</b> Name of weapon you use for tasks.\n<b>Stow container:</b>  Container name for where you stow things. Do NOT use same container you keep your lockpicks in, this might end up throwing them away.\n<b>Wedge container:</b>  Name of container where your wedges are stored.\n<b>Calipers container:</b>  Name of container where your calipers are stored.\n<b>Lockpick container:</b>  Name of container where your lockpicks are stored.\n<b>Main weapon:</b>  Name of weapon you use for hunting/DS.\n<b>Shield/offhand:</b>  Name of shield/offhand weapon you use for hunting/DS.")
    align = Gtk::Alignment.new(1, 0, 0, 0)
    align.set_padding(50, 0, 0, 40)
    align.add(label)
    $AAA_TABLE1.attach(align, 1, 2, 8, 9)

    label = Gtk::Label.new
    label.set_markup("Enter <b>nil</b> for any setting you don't want to use.\n<b>Auto promote:</b>  Enter <b>on</b> to have script automatically receive promotions from NPC guildmaster.\n<b>Update partner:</b>  Enter <b>on</b> to whisper your partner how many reps you have left after each successful rep.\n<b>Lock create number:</b>  Difficulty level of locks to create for non master create lock reps.\n<b>Auto run after partner reps:</b>  Enter <b>yes</b> to automatically turn in partner tasks as soon as they are finished; or <b>pause</b> to pause the script, or leave blank to exit. \n<b>Do other guild tasks:</b>  Enter <b>yes</b> to automatically go to other guilds to finish window and water plants tasks.\n<b>Lmas lockpick:</b>  Name of your best lockpick, for example <b>vaalin lockpick</b>\n<b>Do critter sweep tasks:</b>  Enter <b>yes</b> if you want to do these tasks manually, <b>no</b> if you want the script to turn these tasks in and continue on, <b>auto</b> if you want the script to automatically finish these tasks.")
    align = Gtk::Alignment.new(1, 0, 0, 0)
    align.set_padding(50, 0, 0, 40)
    align.add(label)
    $AAA_TABLE2.attach(align, 1, 2, 8, 9)

    label = Gtk::Label.new
    label.set_markup("Enter <b>nil</b> for any setting you don't want to use.\n<b>Stealth get item:</b>  Name of item to use during <b>stealth get gambits.</b>  NOTE This item will be dropped on the ground, don't use an item you don't want to lose.\n<b>Stealth get item container:</b>  Container where your <b>stealth get item</b> is stored.\n<b>Gambit:</b>  Enter what you type to do your current gambit; do not include the word 'rgambit' and don't abbreviate any words.\nIf doing the stealth get gambit then the <b>Gambit</b> setting should be: stealth get # stealth_get_item (without the space between # and $)")
    align = Gtk::Alignment.new(1, 0, 0, 0)
    align.set_padding(50, 0, 0, 40)
    align.add(label)
    $AAA_TABLE3.attach(align, 1, 2, 8, 9)


    label = Gtk::Label.new
    label.set_markup("Enter <b>nil</b> for any setting you don't want to use.\n<b>These settings are only required if you're having the script automatically do sweep critter tasks.</b>\n<b>Flee from critters:</b>  Name of critters to always flee from. Seperate each name with a |. Example kobold|orc|rolton\n<b>Valid critter targets:</b>  Name of critters to sweep. Same as above for more than one critter.\n<b>Flee from critters count:</b>  Will flee from current room if number of critters is this amount of higher.\n<b>Critter rooms:</b>  List all rooms of area you want to look for critters in; example 1,2,3\nNo spaces after commas.\n")
    align = Gtk::Alignment.new(1, 0, 0, 0)
    align.set_padding(50, 0, 0, 40)
    align.add(label)
    $AAA_TABLE4.attach(align, 1, 2, 8, 9)

    label = Gtk::Label.new
    label.set_markup("Fill these settings out if you are running with a dedicated partner who is also running the <b>rogue</b> and <b>task</b> scripts and is going to help you automate through partner tasks.\nEnter <b>nil</b> for each setting if you are not running with such a partner or if you don't want to use a particular setting.\n<b>Partner room number:</b>  Room number where you and your partner will meet to do partner tasks.\n<b>Lich message partner:</b>  Enter <b>yes</b> to send a lnet message to your partner when you need them for a partner task.\nThe lnet message is just to inform your partner when you need their help in the room you specified for partner tasks, it does not make your partner move or run any scripts even if they are currently running <b>rogue</b> and <b>task</b>.")
    align = Gtk::Alignment.new(1, 0, 0, 0)
    align.set_padding(50, 0, 0, 40)
    align.add(label)
    $AAA_TABLE5.attach(align, 1, 2, 8, 9)

    $AAA_WINDOW.show_all
  }

  $AAA_SETUP_COMPLETED = false
  until($AAA_SETUP_COMPLETED)
    sleep 1
  end

  UserVars.rogue ||= Hash.new
  $AAA_ENTRY.keys.each { |key|
    if( $AAA_ENTRY[key].class.to_s =~ /CheckButton/ )
      value = $AAA_ENTRY[key].active?
      UserVars.rogue[key] = $AAA_ENTRY[key].active?
    else
      if(key == 'wounded_eval')
        UserVars.rogue[key] = $AAA_ENTRY[key].text
      else
        UserVars.rogue[key] = $AAA_ENTRY[key].text.strip.downcase
      end
    end
  }
  UserVars.save()
  do_client(";Xanlin: #{UserVars.rogue.to_s}") if thyfaiin
  Gtk.queue {
    $AAA_WINDOW.destroy
  }
}

flower                      = nil
ice_dirt_rooms              = [ '17972', '17966', '17965', '17976' ]
landing_dirt_rooms          = [ '16517', '16490', '16438', '16492', '16534', '16540' ]
sol_dirt_rooms              = [ '17949', '17948', '17947', '17946', '17942', '17944', '17945' ]
illistim_dirt_rooms         = [ '17840', '17876', '17877', '17879', '17878' ]
teras_dirt_rooms            = [ '17800', '17799', '17796', '17433', '17421' ]
rr_dirt_rooms               = [ '17999', '18000', '18005', '18007', '18008', '18009' ]

ice_window_rooms            = [ '17975', '17966', '17965', '17976', '17964' ]
landing_window_rooms        = [ '16557', '16555', '16491', '16490', '16517' ]
sol_window_rooms            = [ '17950', '17948', '17946', '17944', '17963' ]
illistim_window_rooms       = [ '17871', '17872', '17853', '17860', '17869' ]
teras_window_rooms          = [ '17800', '17421', '17804', '17396', '14089' ]
rr_window_rooms             = [ '17989', '17999', '18001', '18002', '18004' ]

ice_plant_rooms             = [ '17974', '17965', '17967', '17976', '17964' ]
landing_plant_rooms         = [ '16545', '16504', '16438', '16534', '16517' ]
sol_plant_rooms             = [ '17953', '17950', '17946', '17942', '17944' ]
illistim_plant_rooms        = [ '17871', '17851', '17855', '17869', '17870' ]
teras_plant_rooms           = [ '17800', '17803', '17433', '17432', '17396' ]
rr_plant_rooms              = [ '17989', '17999', '18001', '18002', '18004' ]

audience_rooms              = [ '3449' , '228'  , '1438' , '728'  , '1932' , '10861' ]
training_administrator_room = [ '17967', '16504', '17948', '17798', '17883', '18007' ]
toolbenches_room_number     = [ '17978', '16574', '17960', '17881', '17433', '18004' ]
guild_master_room_number    = [ '17975', '16485', '17956', '17886', '17432', '17991' ]
training_master_room_number = [ '17965', '16540', '17951', '17419', '17864', '18010' ]
sweeping_dummies_room_number= [ '17976', '16509', '17950', '17862', '17797', '18008' ]
kitchen_room_number         = [ '17969', '16433', '17940', '17889', '17420', '18001' ]
mannequin_room_number       = [ '17965', '16509', '17949', '17861', '17802', '18008' ]
tool_rack_room_number       = [ '17969', '16581', '17941', '17861', '17396', '18003' ]

training_administrator_names= /teagais|deluca|milgrew|runaire|boucher|maliq/i
guild_master_names          = /kuidich|dante|lindil|lydon|culsath|tafileh/i
#;e echo GameObj.npcs.collect{|i| i.noun}.join('|')
master_names                = /duchel|palder|meallan|miller|bean|reilly|varant|triaholly|sneck|jimik|herit|lagick|zardak|faldes|gludac|vigil|ritchie|colvin|purkhiser|selima|jafar|mubarak|harith/i
flower_names                = /wildflower|iceflower|dandelion|begonia|iris|rose|wisteria/i
(stand_up = nil;stamina_check = nil;my_room = nil;other_players = nil;other_players_disks = nil;wander = nil;auto_critter_sweep_tasks = nil;critter_target = nil;get_critter_target = nil;dangerous_critter_found = 0;npcs_alive = nil;critter_count = 0;get_critter_target = nil;dangerous_critter_found = 0;getpick = nil;checkin = nil;person = nil;help_sweep_partner_start = nil;help = nil;help_cheap_partner_start = nil;go_to_task = nil;stow = nil;gam_teach_help_start = nil;gam_learn_help_start = nil;gam_teach_help_start1 = nil;gam_learn_help_start2 = nil;gam_learn_help_start3 = nil;sweepstart = nil;
sweep_partner = nil;sweep_defend = nil;sweep_master = nil;sweep_dummies = nil;sweep_dirt = nil;sweep_critters = nil;promotion = nil;partner_room = nil;sweep_partner_start = nil;auto_run = nil;sweep_defend_start = nil;reps = nil;sweep_master_begin = nil;sweep_master_start = nil;promotion = nil;number = nil;sweep_dummy_start = nil;sweep_dirt_move = nil;sweep_dirt_sweep = nil;sweep_dirt_get = nil;sweep_dirt_full = nil;garlic_start = nil;mannequins_start = nil;windows_get_rag = nil;sub_critters = nil;get_garlic = nil;mannequins_subdue = nil;windows_move = nil;windows_clean = nil;go_to_room = nil;lmas_tough_boxes = nil;lmas_trick = nil;keys = nil;lmas_footpad_talk = nil;lmas_footpad_challenge = nil;customize = nil;lmas_footpad_lock_start = nil;lmas_lockpick_start = nil;customize_footpad_pre = nil;customize_create = nil;customize_footpad_create = nil;customize_footpad_finished = nil;customize_footpad_hand_in1 = nil;lmas_footpad_lock_start = nil;lmas_footpad_challenge_begin = nil;lmas_footpad_challenge_begin1 = nil;lmas_footpad_challenge_wait = nil;lmas_footpad_challenge_trap = nil;lmas_footpad_challenge_pick = nil;lmas_footpad_challenge1 = nil;cal = nil;cal_start = nil;carve_go = nil;buy_block = nil;carve_start = nil;carve = nil;carve_rub = nil;lock_pick_create = nil;lockpick_handin = nil;lockpick_handin1 = nil;gam_learn_start = nil;gam_audience_start = nil;gam_audience_begin = nil;gam_speed_start = nil;gam_teach_start = nil;gam_learn_start1 = nil;gam_learn_start2 = nil;gam_audience_begin = nil;gam_speed_begin = nil;gam_teach_start1 = nil;repair = nil;keys_1 = nil;footstomp_defend = nil;footstomp_partner = nil;cheap_critter = nil;cheap_plants = nil;foot_stomp_defend1 = nil;footstomp_partner_start = nil;cheap_plants_move = nil;cheap_plants_water = nil;cheapstart = nil;substart = nil;lmasstart = nil;gamstart = nil;master = nil;stunstart = nil; stun_start = nil;stun_arrows = nil;stun_shield = nil;stun_shield_trainer = nil;stun_weapon = nil;stun_weapon_trainer = nil;stun_slaphands = nil;stun_lesson = nil;stun_get_trainer = nil;stun_get = nil;stun_stand = nil;stun_stance1 = nil;stun_stance2 = nil;stun_attack = nil;cheap_task = nil;footstomp_critter = nil;latest_gambit = nil)
sub_critter = cheap_critter = auto_critter_sub_tasks = nil
(water_round = nil;gam_master = nil;gam_master_begin = nil;gam_master_start=nil;)
stealth_gambit              = false
target_room                 = nil
dirt_rooms                  = nil
talk_to_footpad_masters     = nil
current_plant_rooms         = nil

box = ["filler", "first box", "second box", "third box", "fourth box", "fifth box" ]
Pick = ["red lockpick", "steel lockpick", "gold lockpick", "silver lockpick", "ora lockpick", "mithril lockpick", "scrimshaw lockpick", "laje lockpick", "vultite lockpick", "rolaren lockpick", "veniom lockpick", "invar lockpick", "alum lockpick", "golvern lockpick", "kelyn lockpick", "vaalin lockpick", "cast"]

$lockpick_number = 0

gld_squelch_start = /You are.*Rogue Guild./i
#gld_squelch_stop = /Click |GLD MENU|<prompt|<popStream/
gld_squelch_stop = /<prompt|<popStream/
rgambit_squelch_start = /Usage:/i
rgambit_squelch_stop = /<prompt|<popStream/
squelch_status = false
@debug_hook = false

squelch = proc { |start_pattern,stop_pattern|
  DownstreamHook.remove('xrogue_squelch')
  respond "SquelchStart: #{gld_squelch_start}" if @debug_hook
  respond "SquelchStop:  #{gld_squelch_stop}" if @debug_hook
  hook_action = proc { |server_string|
    if server_string.strip.length == 0
      nil
      next
    end
    squelch_status = true  if server_string =~ start_pattern
    squelch_status = false if server_string =~ stop_pattern
    squelch_status ? nil : server_string
  }
    DownstreamHook.add("xrogue_squelch", hook_action)
};

before_dying { DownstreamHook.remove('xrogue_squelch'); }

fput_gld = proc {
  squelch.call(gld_squelch_start,gld_squelch_stop)
  sleep 0.1
  put "gld"
}
fput_rgambit = proc {
  squelch.call(rgambit_squelch_start,rgambit_squelch_stop)
  sleep 0.1
  put "rgambit"
}
stop_squelch = proc {
  DownstreamHook.remove("xrogue_squelch")
}
getpick = proc{
  exit if $lockpick_number >= 16
  multifput "get my #{Pick[$lockpick_number]} from my keyring", "lmas app my lock"
  while line = get
    if line =~ /It appears to be broken/
      wire = 2 if $lockpick_number == 0
      wire = 4 if $lockpick_number == 1
      wire = 5 if $lockpick_number == 2
      wire = 6 if $lockpick_number == 3
      wire = 7 if $lockpick_number == 4
      wire = 8 if $lockpick_number == 5
      wire = 9 if $lockpick_number == 7
      wire = 11 if $lockpick_number == 8
      wire = 12 if $lockpick_number == 9
      wire = 13 if $lockpick_number == 10
      wire = 15 if $lockpick_number == 11
      wire = 10 if $lockpick_number == 12
      wire = 16 if $lockpick_number == 13
      wire = 14 if $lockpick_number == 14
      wire = 17 if $lockpick_number == 15
      multifput "order #{wire}", "buy", "lmas repair my lock"
      waitrt?
      fput "lmas repair my lock"
      waitrt?
      fput "put my lockpick in my keyring"
      $lockpick_number = $lockpick_number + 1
      getpick.call
    elsif line =~ /You could probably handle/
      fput "lmas repair my lock"
      waitrt?
      fput "put my lockpick in my keyring"
      $lockpick_number = $lockpick_number + 1
      getpick.call
    end
  end
}

stand   = proc{ ((waitrt?;fput "stand" ;sleep 0.2;waitrt?) until  standing?) unless  standing? }
kneel   = proc{ ((waitrt?;fput "kneel" ;sleep 0.2;waitrt?) until  kneeling?) unless  kneeling? }
unhide  = proc{ ((waitrt?;fput "unhide";sleep 0.2;waitrt?) until !hidden? )  unless !hidden?   }
hide    = proc{ ((waitrt?;fput "hide"  ;sleep 0.2;waitrt?) until  hiding?  ) unless  hiding?   }
stow = proc{
  waitrt?;
  fput "put my #{stealth_get_item} in my #{stealth_get_item_container}" if (GameObj.left_hand.name =~ /#{stealth_get_item}/i || GameObj.right_hand.name =~ /#{stealth_get_item}/i )
  fput "store all" if checkleft || checkright
  fput "stow all"  if checkleft || checkright
}
get_stealth_item = proc {
  waitrt?;
  fput "get #{stealth_get_item}" if GameObj.loot.find{ |o| o.name =~ /#{stealth_get_item}/i}
  fput "get my #{stealth_get_item} from my #{stealth_get_item_container}" if GameObj.loot.find{ |o| o.name =~ /#{stealth_get_item}/i}.nil? &&  (GameObj.left_hand.name !~ /#{stealth_get_item}/i && GameObj.right_hand.name !~ /#{stealth_get_item}/i ) 
}
stow_stealth_item = proc {
  waitrt?;fput "put my #{stealth_get_item} in my #{stealth_get_item_container}" if GameObj.loot.find{ |o| o.name =~ /#{stealth_get_item}/i}.nil? &&  (GameObj.left_hand.name !~ /#{stealth_get_item}/i && GameObj.right_hand.name !~ /#{stealth_get_item}/i ) 
}
drop_stealth_item = proc {
  echo checkrt if checkrt > 0 && debug;
  sleep checkrt if checkrt > 0;
  if GameObj.loot.find{ |o| o.name =~ /#{stealth_get_item}/i}.nil? 
    get_stealth_item.call
    fput "drop my #{stealth_get_item}" if (GameObj.left_hand.name =~ /#{stealth_get_item}/i || GameObj.right_hand.name =~ /#{stealth_get_item}/i )
  end
}
get_weapon = proc {
  waitrt?;
  fput "get my #{weapon}" if GameObj.loot.find{ |o| o.name =~ /#{weapon}/i}.nil? &&  (GameObj.left_hand.name !~ /#{weapon}/i && GameObj.right_hand.name !~ /#{weapon}/i )
  fput "get #{weapon}" if GameObj.loot.find{ |o| o.name =~ /#{weapon}/i} &&  (GameObj.left_hand.name !~ /#{weapon}/i && GameObj.right_hand.name !~ /#{weapon}/i )
}
stow_weapon = proc {
  waitrt?;
  fput "store all" if (GameObj.left_hand.name =~ /#{weapon}/i || GameObj.right_hand.name =~ /#{weapon}/i )
  fput "stow all"  if (GameObj.left_hand.name =~ /#{weapon}/i || GameObj.right_hand.name =~ /#{weapon}/i )
}
stamina_check = proc{
  if checkstamina < 12
    echo "Waiting for stamina."
    wait_until{ checkstamina >= 12 }
  end
}


turnin = proc{
  unhide.call
  stand.call
  move 'out' if checkpaths 'out'
  target_room = Room.current.find_nearest(training_administrator_room)
  start_script 'go2', [ target_room.to_s ]
  wait_while{ running?('go2') }
  GameObj.npcs.find { |npc| person = npc if npc.name =~ training_administrator_names }
  multifput "ask #{person} about train #{script.vars[1]}", "ask #{person} about train #{script.vars[1]}"
  go_to_task.call
}

auto_run = proc{
  current_proc = "auto_run"
  respond "+------------------------------- proc_start: #{current_proc}" if debug
  respond "+---------------- auto_run_after_partner_reps = #{auto_run_after_partner_reps}" if debug  
  if auto_run_after_partner_reps == "yes"
    turnin.call  #this line was throwing --- Lich: error: undefined local variable or method `turnin' for -- ## moved it below turnin proc
  elsif auto_run_after_partner_reps == "pause"
    
    #respond "+---------------------------------------------+"
    Xmod.gs_print(Xmod.format_whisper("+--------| ;u xro           when ready |-------+"))
    #respond "+---------------------------------------------+"
    pause_script
    turnin.call  
  else
    exit
  end
}

promotion = proc{
  if my_partner
    partner_room.call
    wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{my_partner}(.*)/i } }
    fput "whisper #{my_partner} gld promote #{Char.name} in #{script.vars[1]}" if !no_whisper_wait
    if no_whisper_wait
      promo_skill = ''
      promo_skill = "cheapshots' " if script.vars[1] =~ /^ch/i
      promo_skill = "sweep" if script.vars[1] =~ /^sw/i
      promo_skill = "gambits" if script.vars[1] =~ /^g/i
      promo_skill = "subdue" if script.vars[1] =~ /^su/i
      fput "whisper #{my_partner} promote #{Char.name} in #{promo_skill}"
    end
    
    
    waitfor /offers to promote you to your next rank/i
    fput "gld accept"
    latest_gambit.call if script.vars[1] =~ /gam/
    pause_script if auto_run_after_partner_reps = "pause" && !no_whisper_wait
    go_to_task.call if auto_run_after_partner_reps = "yes"
  elsif auto_promote# == "on"
    move 'out' if checkpaths 'out'
    target_room = Room.current.find_nearest(guild_master_room_number)
    start_script 'go2', [ target_room.to_s ]
    wait_while{ running?('go2') }
    GameObj.npcs.find { |npc| person = npc if npc.name =~ guild_master_names }
    fput "ask #{person} about next #{script.vars[1]}"
    target_room = Room.current.find_nearest(training_administrator_room)
    start_script 'go2', [ target_room.to_s ]
    wait_while{ running?('go2') }
    GameObj.npcs.find { |npc| person = npc if npc.name =~ training_administrator_names }
    fput "ask #{person} about train #{script.vars[1]}"
    latest_gambit.call if script.vars[1] =~ /gam/  && script.name !~ /teach/i
    go_to_task.call
  else  
    exit
  end
}

wander = proc{
  sleep 0.1
  room = Room.current
  acceptable_adjacent_rooms = room.wayto.keys & critter_task_rooms
  not_visited_rooms = acceptable_adjacent_rooms.find_all { |r| not wander_rooms.include?(r) }
  if not_visited_rooms.empty?
    next_room = wander_rooms.find { |r| acceptable_adjacent_rooms.include?(r) }
  else
    next_room = not_visited_rooms[rand(not_visited_rooms.length)]
  end
  if next_room
    wander_rooms.delete(next_room)
    wander_rooms.push(next_room)
    way = room.wayto[next_room]
    if way.class == String
      move(way)
      my_room = nil
      critter_target = nil
      other_players = nil
      other_players_disks = nil
      other_players = checkpcs.each { |pc| i += 1; break if pc == Char.name }
      (wander.call) if other_players != nil
      other_players_disks = GameObj.loot.find { |obj| (obj.noun == 'disk') and (obj.name !~ /#{checkname}/) }
      (wander.call) if other_players_disks != nil
      my_room = Room.current.id
    else
      way.call
      my_room = nil
      critter_target = nil
      other_players = nil
      other_players_disks = nil
      other_players = checkpcs.each { |pc| i += 1; break if pc == Char.name }
      (wander.call) if other_players != nil
      other_players_disks = GameObj.loot.find { |obj| (obj.noun == 'disk') and (obj.name !~ /#{checkname}/) }
      (wander.call) if other_players_disks != nil
      my_room = Room.current.id
    end
  else
    start_script 'go2', [ Room.current.find_nearest(critter_task_rooms.collect { |id| id.to_i }).to_s ]
    wait_while { running?('go2') }
      my_room = nil
      critter_target = nil
      other_players = nil
      other_players_disks = nil
      other_players = checkpcs.each { |pc| i += 1; break if pc == Char.name }
      (wander.call) if other_players != nil
      other_players_disks = GameObj.loot.find { |obj| (obj.noun == 'disk') and (obj.name !~ /#{checkname}/) }
      (wander.call) if other_players_disks != nil
      my_room = Room.current.id
  end
}

partner_room = proc{
  (echo "No partner specificed (second parameter)";exit) if my_partner.nil?  && script.name !~ /teach/i
  if pc = GameObj.pcs.find { |pc| pc.noun =~ /^#{my_partner}/i }
    my_partner = pc.noun if pc.noun != my_partner 
    echo "They're already here" if debug
  else
    if partner_room_number != "nil"
      if Room.current.id != Integer(partner_room_number) && (script.vars[1] !~ /gam/i || gam !~ /dagger game/i)
        move 'out' if checkpaths 'out'
        start_script "go2", [partner_room_number]
        wait_while{ running?('go2') }
      end
      pc = GameObj.pcs.find { |pc| pc.noun =~ /^#{my_partner}/i } 
      if lich_message_partner == "yes" && !pc
        do_client(";#{my_partner}:I need your help with a guild task (in room# #{Room.current.id} )")
      end
    end
  end
}

get_critter_target = proc{
  critter_target = GameObj.npcs.find { |npc| npc.name =~ valid_critter_targets and npc.status !~ /dead|gone|prone|sit|kneel/ }
  if critter_target == nil
    wander.call
  end
}

auto_critter_sweep_tasks = proc{
  loop{
    if critter_target.status =~ /dead|gone|prone|sit|kneel/
      critter_target = nil
    end
    stand.call
    if checkstance != "defensive"
      waitrt?
      fput "stance def"
    end
    if checkstamina < 12
      echo "Waiting for stamina."
      wait_until{ checkstamina >= 12 }
    end
    if my_room != Room.current.id
      critter_target = nil
      my_room = nil
      wander.call
      redo
    end
    if critter_target == nil and my_room == Room.current.id
      critter_target = nil
      get_critter_target.call
      redo
    end
    npcs_alive = nil
    npcs_alive = GameObj.npcs.find_all { |i| i.status != 'dead' }
    npcs_alive.each { critter_count = critter_count + 1 }
    if critter_count > flee_from_critters_count
      (critter_count = 0;dangerous_critter_found = 0;npcs_alive = nil;wander.call;redo)
    end
    GameObj.npcs.each { |i| dangerous_critter_found = 1 if i.name =~ flee_from_critters and i.status != 'dead' }
    if dangerous_critter_found == 1
      (dangerous_critter_found = 0;critter_count = 0;wander.call;redo)
    end
    if critter_target != nil and critter_target.status !~ /dead|gone|prone|sit|kneel/ and my_room == Room.current.id
      #fork: seeing how ambush sweeping works out. 
      if checkstance != "defensive"
      waitrt?
      fput "stance def"
      end
      fput "hide"
      waitrt?
      fput "stance off"
      result = dothistimeout "sweep #{critter_target}", 3, /You have completed/i
      waitrt?
      fput "stance def"
      if result =~ /You have completed/i
        (turnin.call)
      elsif result.nil?
        redo
      end
    end
    sleep 0.1
  }
}

########todo
auto_critter_cheap_tasks = proc{
  fput "stow right" if cheap_task =~ /nose|eye/
  loop{
    if critter_target.status =~ /dead|gone|prone|sit|kneel|stunned/
      critter_target = nil
    end
    stand.call
    if checkstance != "defensive"
      waitrt?
      fput "stance def"
    end
    if checkstamina < 12
      echo "Waiting for stamina."
      wait_until{ checkstamina >= 12 }
    end
    if my_room != Room.current.id
      critter_target = nil
      my_room = nil
      wander.call
      redo
    end
    if critter_target == nil and my_room == Room.current.id
      critter_target = nil
      get_critter_target.call
      redo
    end
    npcs_alive = nil
    npcs_alive = GameObj.npcs.find_all { |i| i.status != 'dead' }
    npcs_alive.each { critter_count = critter_count + 1 }
    if critter_count > flee_from_critters_count
      (critter_count = 0;dangerous_critter_found = 0;npcs_alive = nil;wander.call;redo)
    end
    GameObj.npcs.each { |i| dangerous_critter_found = 1 if i.name =~ flee_from_critters and i.status != 'dead' }
    if dangerous_critter_found == 1
      (dangerous_critter_found = 0;critter_count = 0;wander.call;redo)
    end
    if critter_target != nil and critter_target.status !~ /dead|gone|prone|sit|kneel|stunned/ and my_room == Room.current.id
            #fork: seeing how ambush sweeping works out. 
      if checkstance != "defensive"
      waitrt?
      fput "stance def"
      end
      (fput "hide"; waitrt?) if Char.name !~ /Clairette/i
      fput "stance off"
      result = dothistimeout "cheap #{cheap_task} #{critter_target}", 3, /You have completed/i
      waitrt?
      fput "stance def"
      if result =~ /You have completed/i
        (turnin.call)
      elsif result.nil?
        redo
      end
    end
    sleep 0.1
  }
}
#######
auto_critter_sub_tasks = proc{
  loop{
    if critter_target.status =~ /dead|gone|prone|sit|kneel|stunned/
      critter_target = nil
    end
    stand.call
    if checkstance != "defensive"
      waitrt?
      fput "stance def"
    end
    if checkstamina < 12
      echo "Waiting for stamina."
      wait_until{ checkstamina >= 12 }
    end
    if my_room != Room.current.id
      critter_target = nil
      my_room = nil
      wander.call
      redo
    end
    if critter_target == nil and my_room == Room.current.id
      critter_target = nil
      get_critter_target.call
      redo
    end
    npcs_alive = nil
    npcs_alive = GameObj.npcs.find_all { |i| i.status != 'dead' }
    npcs_alive.each { critter_count = critter_count + 1 }
    if critter_count > flee_from_critters_count
      (critter_count = 0;dangerous_critter_found = 0;npcs_alive = nil;wander.call;redo)
    end
    GameObj.npcs.each { |i| dangerous_critter_found = 1 if i.name =~ flee_from_critters and i.status != 'dead' }
    if dangerous_critter_found == 1
      (dangerous_critter_found = 0;critter_count = 0;wander.call;redo)
    end
    if critter_target != nil and critter_target.status !~ /dead|gone|prone|sit|kneel|stunned/ and my_room == Room.current.id
            #fork: seeing how ambush sweeping works out. 
      if checkstance != "defensive"
      waitrt?
      fput "stance def"
      end
      while (!hidden) 
        fput "hide";
        sleep 1 
      end
      waitrt?
      fput "stance off"
      result = dothistimeout "subdue #{critter_target}", 3, /You have completed/i 
      waitrt?
      fput "stance def"
      if result =~ /You have completed/i
        (turnin.call)
      elsif result.nil?
        redo
      end
    end
    sleep 0.1
  }
}
#######


go_to_task = proc{
  if script.vars[1] =~ /swe/ # == "sweep"
    sweepstart.call
  elsif script.vars[1] =~ /gam/
    latest_gambit.call if script.name !~ /teach/i
    gamstart.call
  elsif script.vars[1] =~ /che/ # == "cheap"
    cheapstart.call
  elsif script.vars[1] =~ /lm/ # == "lmas"
    lmasstart.call
  elsif script.vars[1] =~ /sub/ #  == "sub"
    substart.call
  elsif script.vars[1] =~ /stu/ # == "stun"
    stun_start.call
  end
}

checkin = proc{
  move 'out' if checkpaths 'out'
  target_room = Room.current.find_nearest(guild_master_room_number)
  start_script 'go2', [ target_room.to_s ]
  wait_while{ running?('go2') }
  GameObj.npcs.find { |npc| person = npc if npc.name =~ guild_master_names }
  fput "ask #{person} about checkin"
  exit
}

help_sweep_partner_start = proc{
  stand.call
  stamina_check.call if checkstamina < 12
  waitrt?
  GameObj.pcs.each { |pc| fput "pull #{pc.noun}" if pc.status =~ /prone/ && pc.noun =~/#{script.vars[3]}/i}
  result = dothistimeout "sweep #{script.vars[3]}", 3, /is already prone|(You might want to stand up first.|Roundtime)/i
  if result =~ /is already prone/i
    fput "pull #{script.vars[3]}"
    help_sweep_partner_start.call
  elsif result =~ /(You might want to stand up first.|Roundtime)/i
  sleep 0.1
    help_sweep_partner_start.call
  elsif result.nil?
    sleep 0.1
    help_sweep_partner_start.call
  end
}

help_cheap_partner_start = proc{
  current_proc = "help_cheap_partner_start"
  respond "+------------------------------- proc_start: #{current_proc}" if debug
  stand.call
  stamina_check.call if checkstamina < 12
  waitrt?
  result = dothistimeout "cheap foot #{script.vars[3]}", 2, /just fell for a footstomp not long ago/i
  if result =~ /just fell for a footstomp not long ago/
    sleep 2
    help_cheap_partner_start.call
  elsif result.nil?
    sleep 11
    help_cheap_partner_start.call
  end
}

gam_teach_help_start = proc{
  current_proc = "gam_teach_help_start"
  respond "+------------------------------- proc_start: #{current_proc}" if debug
  respond "+---------------- task = #{UserVars.rogue["task"]}" if debug
  stow.call
  waitfor "I am ready to learn" if !no_whisper_wait
  gam_teach_help_start1.call
}
 
gam_teach_help_start1 = proc{
  current_proc = "gam_teach_help_start1"
  respond "+------------------------------- proc_start: #{current_proc}" if debug
  respond "+---------------- task = #{UserVars.rogue["task"]}" if debug
  
  before_gambit.call
  
  result = dothistimeout "#{task}", do_timer, /You place \w+'s hand on the|You need to have free hands to teach this gambit|You already have that|You should have a silver coin on you to teach this gambit|Wait a few seconds and try again|You need to be holding something first|Who are you trying to teach|You really ought to have some type of a dagger or such for that|is not a current member of your guild.|^You produce a silver./i
  if result =~ /You need to have free hands to teach this gambit/i
    stow.call
    gam_teach_help_start1.call
  elsif result =~/You place \w+'s hand on the/
    waitfor 'Suddenly, '
    gam_teach_help_start1.call
  elsif result =~ /Who are you trying to teach|You are already teaching/i
    echo "waiting for partner" if debug
    waitfor "#{my_partner}"
    #sleep 2
    gam_teach_help_start1.call
  elsif result =~/You really ought to have some type of a dagger or such for that/
    get_weapon.call
    gam_teach_help_start1.call
  elsif result =~ /You already have that/i
    fput "stow #{weapon}"
    gam_teach_help_start1.call
  elsif result =~ /You should have a silver coin on you to teach this gambit/i
    fput "whisper #{script.vars[3]} Need a coin, be right back."
    currentroom = Room.current.id
    start_script 'go2', [ 'bank', '--disable-confirm' ]
    wait_while{ running?('go2') }
    fput "withdraw 2 silvers"
    start_script "go2", [ "#{currentroom}" ]
    wait_while{ running?('go2') }
    gam_teach_help_start1.call
  elsif result =~ /Wait a few seconds and try again/i
    sleep 2
    gam_teach_help_start1.call
  elsif result =~ /You need to be holding something first/
    stow.call if checkright || checkleft
    if gam =~ /^(display|get|vanish|stealth)/i
      get_stealth_item.call
    else #dagger probably
      get_weapon.call
    end
    #get_weapon.call
    gam_teach_help_start1.call
  #elsif result =~ /Who are you trying to teach/
    #sleep 2
    #gam_teach_help_start1.call
  elsif result =~ /is not a current member of your guild/
    echo "Not a current member"
    exit
  elsif result.nil?
    gam_teach_help_start1.call
  else
    gam_teach_help_start1.call
  end
}

gam_learn_help_start = proc{
  current_proc = "gam_learn_help_start"
  respond "+------------------------------- proc_start: #{current_proc}" if debug
  sleep 3
  before_gambit.call
  gam_retry = true
  fput "whisper #{script.vars[3]} I am ready to learn" 
  
  gam_learn_help_start2.call
}

gam_learn_help_start2 = proc{
  current_proc = "gam_learn_help_start2"
  respond "+------------------------------- proc_start: #{current_proc}" if debug;

  gam_learn_help_start3.call
}

gam_learn_help_start3 = proc{
  current_proc = "gam_learn_help_start3"
  respond "+------------------------------- proc_start: #{current_proc}" if debug

  before_gambit.call if !gam_retry
  gam_retry = false
  #waitfor "#{my_partner} shows you" 
  
  hide.call if stealth_gambit

  result = dothistimeout "#{task}", 5, /You really ought to have some type of a dagger or such for that|You need to be holding something first|You already have that|Just how stealthy are you trying to be|but realize that doing so would reveal your location|suddenly become aware that your actions have revealed your location|Roundtime|You manage to move to|keeping your location hidden|but have revealed yourself from hiding in doing so|but realize that doing so would compromise your hidden position/i
  
  if result =~ /repetitions? remaining\.\]/
    gam_learn_help_start2.call
  elsif result =~ /You have completed your training task/i
    stow.call
    turnin.call
  elsif result =~ /You need to be holding something first/i
    respond "this shouldn't happen"
    pause_script
    stow.call
    get_weapon.call
    gam_learn_help_start2.call
  elsif result =~ /doing so would compromise|you remain in your current position/i
    gam_retry = true
    gam_learn_help_start2.call
  elsif result =~ /You really ought to have some type of a dagger or such for that/
    respond "this shouldn't happen"
    pause_script
    get_weapon.call
    gam_learn_help_start2.call
  elsif result =~ /You already have that/i
    respond "this shouldn't happen"
    pause_script
    gam_learn_help_start2.call
  elsif result =~ /suddenly become aware that your actions have revealed your location|but have revealed yourself from hiding in doing so/i
    sleep_timer = 1
    gam_learn_help_start2.call
  elsif script.vars[1] == "test" 
    echo "no match found | expected on success during test" if debug
    gam_learn_help_start2.call
  else 
    #echo "NO MATCH FOUND - DOING IT AGAIN" if debug 
    do_client(";Xanlin: #{current_proc}: #{gam}: no result") if thyfaiin
    sleep_timer = 1
    gam_learn_help_start2.call
    #exit
  end
#  if result =~ /You need to be holding something first/i
#    #get_weapon.call
#    if task =~ /^(display|get|vanish|stealth)/i
#      get_stealth_item.call
#    else #dagger probably
#      get_weapon.call
#    end
#    gam_learn_help_start2.call
#  elsif result =~ /You really ought to have some type of a dagger/
#    get_weapon.call
#    gam_learn_help_start2.call
#  elsif result =~ /You already have that/i
#    fput "stow #{weapon}" 
#    gam_learn_help_start2.call
#  elsif result =~ /Roundtime|You manage to move to|keeping your location hidden/i
#    gam_learn_help_start2.call
#  elsif result =~ /Just how stealthy are you trying to be/i
#    gam_learn_help_start3.call
#  elsif result =~ /suddenly become aware that your actions have revealed your location|but realize that doing so would reveal your location/i
#    gam_learn_help_start2.call
#  elsif result =~ /but have revealed yourself from hiding in doing so/i
#      #fput "drop my #{stealth_get_item}" if stealth_get_item_trick
#      gam_learn_help_start3.call
#  elsif result =~ /but realize that doing so would compromise your hidden position/i
#    gam_learn_help_start3.call
#  elsif result.nil?
#    gam_learn_help_start3.call
#  end
}

sweepstart = proc{
  stow.call
  #fput "gld"
  fput_gld.call
  waitfor "Sweep skill"
  while line = get
    (sweep_partner.call;break) if line =~ /The Training Administrator told you to practice sweeping a partner./i
    (sweep_defend.call;break) if line =~ /The Training Administrator told you to defend against a partner./i
    (sweep_master.call;break) if line =~ /The Training Administrator told you to get some lessons from the footpads./i
    (sweep_dummies.call;break) if line =~ /The Training Administrator told you to work out on the sweep dummies./i
    (sweep_dirt.call;break) if line =~ /The Training Administrator told you to sweep the guild courtyard./i
    (sweep_critters.call;break) if line =~ /The Training Administrator told you to practice sweeping creatures./i
    (promotion.call;break) if line =~ /(Congratulations, you've earned a rank|You need to get promoted to your next rank in Sweep|You have earned enough training points for your next rank.)/i
    (turnin.call;break) if line =~ /You are not currently training in this skill/i
  end
}
#stun_start = nil;stun_arrows = nil;stun_shield = nil;stun_shield_trainer = nil;stun_weapon = nil;stun_weapon_trainer = nil;stun_slaphands = nil)
stun_start = proc{
  stow.call
  #fput "gld"
  fput_gld.call
  waitfor "Stun Maneuvers skill"
  while line = get
    (sweep_dirt.call;break) if line =~ /The Training Administrator told you to sweep the guild courtyard\./i
    (windows_get_rag.call;break) if line =~ /The Training Administrator told you to clean the windows in the guild\.|The Training Administrator told you to clean the guild windows\./i
    (stun_arrows.call;break) if line =~ /The Training Administrator told you to let a footpad shoot arrows at you./i
    (stun_slaphands.call;break) if line =~ /The Training Administrator told you to play a few rounds of slap hands with a footpad./i
    (stun_shield.call;break) if line =~ /The Training Administrator told you to practice getting your shield while stunned./i
    (stun_weapon.call;break) if line =~ /The Training Administrator told you to practice getting your weapon while stunned./i
    (stun_get.call;break) if line =~ /The Training Administrator told you to practice picking stuff up while stunned./i
    (stun_stand.call;break) if line =~ /The Training Administrator told you to practice stand/i
    (stun_stance1.call;break) if line =~ /The Training Administrator told you to practice defending yourself a little more while stunned./i
    (stun_stance2.call;break) if line =~ /The Training Administrator told you to practice defending yourself a lot more while stunned./i
    (stun_lesson.call;break) if line =~ /The Training Administrator told you to visit the footpads for some lessons./i
    (promotion.call;break) if line =~ /(Congratulations, you've earned a rank|You need to get promoted to your next rank in Sweep|You have earned enough training points for your next rank.)/i
    (turnin.call;break) if line =~ /You are not currently training in this skill/i
  end
}

stun_arrows = proc {
  echo "stun_arrows starting" if debug
  arrows_commands = [ "lean left", "lean right", "duck", "jump" ]
  #prepare_footpad
  if (checkarea != /A Dark Corner/)
    echo checkarea if debug
    target_room = Room.current.find_nearest(training_master_room_number)
    start_script 'go2', [ target_room.to_s ]
    wait_while{ running?('go2') }
    fput "ask #{GameObj.npcs[-1].noun} for train stun"
    ask_results = matchtimeout(3, "gives you a strange look", "pulls you aside")
    if ask_results =~ /gives you a strange look/
      turnin.call
      break
    else
    loop {
      waitrt?
      stand.call
      guess = rand(arrows_commands.size)
      fput arrows_commands[guess]

      waitfor "fires an arrow!", "MOVE!", "How about you try", "see a snail", "is to dodge at least", "Do something!"
      stun_arrows_results = matchtimeout(3, "You have completed", "remaining")
      if stun_arrows_results =~ /You have completed/
        fput "out"
        turnin.call
      elsif stun_arrows_results =~ /remaining/
        fput "out"
        stun_arrows.call
      end
      }
    end
  end
}

stun_slaphands = proc {
  commands = [ "stop", "slap", "duck" ]
  if (checkarea != /A Dark Corner/)
    echo checkarea if debug
    target_room = Room.current.find_nearest(training_master_room_number)
    start_script 'go2', [ target_room.to_s ]
    wait_while{ running?('go2') }
    fput "ask #{GameObj.npcs[-1].noun} for train stun"
    ask_results = matchtimeout(3, "gives you a strange look", "pulls you aside")
    if ask_results =~ /gives you a strange look/
      turnin.call
      break
    else
      loop {
        waitrt?
        stand.call
        waitrt?
        guess = rand(commands.size)
        dothis commands[guess], /You place your/
        waitfor "You move", "You duck", "You steady", "Tension", "You stare", "You are knocked", "simultaneously slap"
        slaphandscomplete = matchtimeout(2, 'You have completed')
        (turnin.call;break) if slaphandscomplete =~ /You have completed/
      }
    end
  end
}

stun_shield = proc {
    loop {
    waitrt?
    fput "store shield" if checkleft
    fput "stow left"    if checkleft
    fput "get my skull", /You/ if !checkleft 'skull'
    dothis "swap", /You swap/  if checkright 'skull'
    loop {
      waitrt?
      wait_until { checkstamina 10 }
      dothis "stow right", /You put/ if checkright =~ /#{weapon}/i
      dothis "rub my skull", /You/ if checkleft 'skull'
      sleep 11 if stunned?
      fput "stunman shield" if stunned?
      stunmanmatch = matchtimeout(2, 'You have completed', 'not stunned', 'You are already holdin')
      if stunmanmatch =~ /You have completed/
        #fput "ready weapon clear"
        #fput "store #{weapon}"
        fput "put my skull in my #{stow_container}"
        fput "gird"
        turnin.call
        break
      end
      break if stunmanmatch =~ /not stunned|You are already holding/
      break if !stunned? || checkright
    }
  }
}

stun_lesson = proc {
  current_proc = "stun_lession"
  if (checkarea != /A Dark Corner/)
    echo checkarea if debug
    target_room = Room.current.find_nearest(training_master_room_number)
    start_script 'go2', [ target_room.to_s ]
    wait_while{ running?('go2') }
    fput "ask #{GameObj.npcs[-1].noun} for train stun"
    ask_results = matchtimeout(3, "gives you a strange look", "pulls you aside")
    if ask_results =~ /gives you a strange look/
      turnin.call
      break
    end
  end

  footpadtask = matchwait /shield back into|sword back into|reach down and pick up a small brick|knees and then trembles to a standing position|show you how STANCE(1|2) is done|suddenly launches an attack and swings right for you/i
  if footpadtask =~ /shield/i
    stunman_footpad_task = "shield"
  elsif footpadtask =~ /sword/i
    stunman_footpad_task = "weapon"
  elsif footpadtask =~ /down and pick up a small brick/i
    stunman_footpad_task = "get #{stealth_get_item}"
  elsif footpadtask =~ /knees and then trembles to a standing position/i
    stunman_footpad_task = "stand"
  elsif footpadtask =~ /show you how STANCE1 is done/
    stunman_footpad_task = "stance1"
  elsif footpadtask =~ /suddenly launches an attack and swings right for you/i
    stunman_footpad_task = "attack"
  elsif footpadtask =~ /show you how STANCE2 is done/i
    stunman_footpad_task = "stance2"
  end
  respond "+-------- #{current_proc}:stunman_footpad_task=#{stunman_footpad_task}"
  # stamcheck = 15
  # stamcheck -= 7 if stunman_footpad_task =~ /weapon|shield/
  # stamcheck -= 5 if stunman_footpad_task =~ /get/
  # stamcheck -= 3 if stunman_footpad_task =~ /stand|stance1/i
  matchwait /NOD to begin, or UNSTUN/
  fput "nod"
  stunmanmatch = nil
  loop{
    waitrt?
    loop {
      waitrt?
      respond "+-------- #{current_proc}:loop:loop:stow:start" if debug
      fput "store shield" if checkleft  && stunman_footpad_task =~ /shield/i
      fput "stow left"    if checkleft  && stunman_footpad_task =~ /shield|get/i
      fput "store weapon" if checkright && stunman_footpad_task =~ /weapon/i
      fput "stow right"   if checkright && stunman_footpad_task =~ /weapon|get/i
      fput "stance off"   if percentstance <= 20 && stunman_footpad_task =~ /stance/
      respond "+-------- #{current_proc}:loop:loop:stow:end" if debug
      wait_until { checkstamina 15 }
      sleep 11 if stunned?
      if stunman_footpad_task =~ /attack/i
        fput "stun attack ##{GameObj.npcs.find{|npc| npc.name =~ /Master Footpad/i}.id}" if stunned?
        stunmanmatch = matchtimeout(2, '[You have completed this task.]', 'You have completed', 'not stunned', 'You are already holdin')
        (turnin.call;break) if stunmanmatch =~ /.*You have completed.*/i
      else
        fput "stun #{stunman_footpad_task}" if stunned?
        stunmanmatch = matchtimeout(2, '[You have completed this task.]', 'You have completed', 'not stunned', 'You are already holdin')
        (turnin.call;break) if stunmanmatch =~ /.*You have completed.*/i
      end
      stunmanmatch = matchtimeout(2, '[You have completed this task.]', 'You have completed', 'not stunned', 'You are already holdin')
      if stunmanmatch =~ /.*You have completed.*/i
        waitrt?
        turnin.call
        break
      end
      #break if stunmanmatch =~ /not stunned|You are already holding/
      break if !stunned?
    }
  }
}

stun_weapon = proc {
    loop {
    waitrt?
    fput "store weapon" if checkright && stunman_footpad_task =~ /weapon/i
    fput "stow right"   if checkright && stunman_footpad_task =~ /weapon|get/i
    fput "get my skull", /You/ if !checkleft 'skull'
    dothis "swap", /You swap/  if checkright 'skull'
    loop {
      waitrt?
      wait_until { checkstamina 10 }
      dothis "stow right", /You put/ if checkright =~ /#{weapon}/i
      dothis "rub my skull", /You/ if checkleft 'skull'
      sleep 11 if stunned?
      fput "stunman weapon" if stunned?
      stunmanmatch = matchtimeout(2, 'You have completed', 'not stunned', 'You are already holdin')
      if stunmanmatch =~ /You have completed/
        #fput "ready weapon clear"
        #fput "store #{weapon}"
        fput "put my skull in my #{stow_container}"
        fput "gird"
        turnin.call
        break
      end
      break if stunmanmatch =~ /not stunned|You are already holding/
      break if !stunned? || checkright
    }
  }
}

stun_get = proc {
  loop {
    waitrt?
    dothis "stow #{stealth_get_item}", /You put/ if checkright =~ /#{stealth_get_item}/i
    dothis "get my skull", /You remove/ if !checkleft 'skull'
    dothis "swap", /You swap/ if checkright 'skull'
    loop {
      waitrt?
      wait_until { checkstamina 10 }
      fput "stow #{stealth_get_item}" if checkright =~ /#{stealth_get_item}/i
      dothis "rub my skull", /You/ if checkleft 'skull'
      sleep 11 if stunned?
      fput "stunman get #{stealth_get_item}" if stunned?
      stunmanmatch = matchtimeout(2, 'You have completed', 'not stunned', 'You are already holdin')
      if stunmanmatch =~ /You have completed/
        fput "put #{stealth_get_item} in my #{stow_container}"
        fput "put my skull in my #{stow_container}"
        turnin.call
        break
      end
      break if stunmanmatch =~ /not stunned|You are already holding/
      break if !stunned? || checkright
    }
  }
}

stun_stand = proc {
  echo "stun_stand starting" if debug
  waitrt?
  fput "stow right" if !checkright 'skull'
  dothis "get my skull", /You remove|You already have/ if !checkright 'skull'
  loop {
    echo "stun_stand loop start" if debug
    waitrt?
    loop {
      wait_until { checkstamina 13 }
      fput "lie" if standing?
      dothis "rub my skull", /You/ if checkright 'skull'
      sleep 10 if stunned?
      #fput "stunman stand" if stunned?
      dothis "stunman stand", /You/ if stunned?
      stunmanmatch = matchtimeout(5, 'You have completed', 'not stunned', 'You are already holdin')
      if stunmanmatch =~ /You have completed/
        echo "calling turnin after rt"
        waitrt?
        turnin.call
        echo "stun_stand breaking after turnin.call"
        break
      end
      break if stunmanmatch =~ /not stunned|You are already holding/
      break if !stunned? || standing?
    }
  }
}
stun_stance1 = proc {
  loop {
    waitrt?
    multifput "stow right","get my skull" if checkright !~ /skull/i
    loop {
      waitrt?
      wait_until { checkstamina 15 }
      multifput "stance adv","rub my skull" if checkright =~ /skull/
      (sleep 11;fput "stunman stance1") if stunned?
      stunmanmatch = matchtimeout(2, 'You have completed', 'not stunned', 'You are already holdin')
      if stunmanmatch =~ /You have completed/
        fput "put my skull in my #{stow_container}"
        turnin.call
        break
      end
      break if stunmanmatch =~ /not stunned|You are already holding/
      break if !stunned? || percentstance > 20
    }
  }
}

stun_stance2 = proc {
  loop {
    waitrt?
    multifput "stow right","get my skull" if checkright !~ /skull/i
    fput "stance off" if percentstance > 20
    loop {
      waitrt?
      wait_until { checkstamina 15 }
      multifput "stance adv","rub my skull" if checkright =~ /skull/
      (sleep 11;fput "stunman stance2") if stunned?
      stunmanmatch = matchtimeout(2, 'You have completed', 'not stunned', 'You are already holdin')
      if stunmanmatch =~ /You have completed/
        fput "put my skull in my #{stow_container}"
        turnin.call
        break
      end
      break if stunmanmatch =~ /not stunned|You are already holding/
      break if !stunned? || percentstance > 20
    }
  }
}

sweep_partner = proc{
  #fput "gld"
  fput_gld.call
  waitfor "The Training Administrator told you to practice sweeping a partner"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      partner_no_partner.call if script.vars[2].nil?
      multifput "gld stance off", "stance off"
      partner_room.call
      wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{my_partner}(.*)/i } }
      fput "whisper #{my_partner} I need to sweep you."
      waitfor "Ready to be swept"
      sweep_partner_start.call
      break
    end
  end
}

sweep_partner_start = proc{
  stand.call
  stamina_check.call if checkstamina < 12
  waitrt?
  GameObj.pcs.each { |pc| fput "pull #{pc.noun}" if pc.status =~ /prone/ && pc.noun =~/#{my_partner}/i}
  result = dothistimeout "sweep #{my_partner}", 3, /You have completed your training task.|is already prone|You might want to stand up first.|Sweep what\?|repetition|Roundtime/i
  if result =~ /You have completed your training task./i
    sleep 0.1
    waitrt?
    fput "pull #{my_partner}"
    fput "whisper #{my_partner} All done!"
    auto_run.call
  elsif result =~ /is already prone/i
    sleep 0.1
    waitrt?
    fput "pull #{my_partner}"
    sweep_partner_start.call
  elsif result =~ /You might want to stand up first./i
    sleep 0.1
    stand.call
    sweep_partner_start.call
  elsif result =~ /repetition|Roundtime/i
    sleep 0.1
    #GameObj.pcs.each { |pc| fput "pull #{pc.noun}" if pc.status =~ /prone/ && pc.noun =~/#{my_partner}/i}
    sweep_partner_start.call
  elsif result =~ /Sweep what\?/i
    exit
  elsif result.nil?
    sweep_partner_start.call
  end
}

sweep_defend = proc{
  #fput "gld"
  fput_gld.call
  waitfor "The Training Administrator told you to defend against a partner"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      stand.call
      waitrt?
      multifput "gld stance def", "stance off"
      partner_room.call
      wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{my_partner}(.*)/i } }
      fput "whisper #{my_partner} I need to be swept."
      sweep_defend_start.call
      break
    end
  end
}

sweep_defend_start = proc{
  waitfor my_partner
  while line = get
    if line =~ /You have (.*) repetition/i
      reps = $1
      fput "whisper #{my_partner} #{reps} more." if update_partner == "on"
    elsif line =~ /You have completed your training task/i
      fput "whisper #{my_partner} All done. Thank you!"
      auto_run.call
      break
    end
  end
}

sweep_master = proc{
  #fput "gld"
  fput_gld.call
  waitfor "The Training Administrator told you to get some lessons from the footpads"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      waitrt?
      multifput "gld stance off", "stance off"
      move 'out' if checkpaths 'out'
      target_room = Room.current.find_nearest(training_master_room_number)
      start_script 'go2', [ target_room.to_s ]
      wait_while{ running?('go2') }
      GameObj.npcs.find { |npc| master = npc if npc.name =~ master_names }
      sweep_master_begin.call
      break
    end
  end
}

sweep_master_begin = proc{
  fput "ask #{master} about training sweep"
  waitfor "pulls you aside for some instruction."
  waitfor "says"
  sweep_master_start.call
}

sweep_master_start = proc{
  stand.call
  stamina_check.call if checkstamina < 12
  waitrt?
  #master_status = GameObj.npcs.find {|npc| npc.status}
  result = dothistimeout "sweep #{master}", 3, /You have completed your training task|is already prone|You might want to stand up first.|Roundtime/i
  if result =~ /You have completed your training task/i
    turnin.call
  elsif result =~ /is already prone/i
    waitrt?
    hide.call
    waitfor "stands back up"
    sweep_master_start.call
  elsif result =~ /You might want to stand up first./i
    stand.call
    sweep_master_start.call
  elsif result =~ /Roundtime/i
    waitrt?
    stand.call
    fput "hide" if !hidden?
    sweep_master_start.call
  elsif result.nil?
  stand.call
    sweep_master_start.call
  end
}

sweep_dummies = proc{
  #fput "gld"
  fput_gld.call
  waitfor "The Training Administrator told you to work out on the sweep dummies"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      waitrt?
      move 'out' if checkpaths 'out'
      target_room = Room.current.find_nearest(sweeping_dummies_room_number)
      start_script 'go2', [ target_room.to_s ]
      wait_while{ running?('go2') }
      fput "go dummies"
      sweep_dummy_start.call
      break
    end
  end
}

sweep_dummy_start = proc{
  stand.call
  stamina_check.call if checkstamina < 12
  waitrt?
  result = dothistimeout "sweep dummy", 3, /You have completed your training task.|The dummy is swinging back and forth.|The dummy has fallen off its post, you'll need to FIX it.|repetition|fail to flip/i
  if result =~ /You have completed your training task./i
    turnin.call
  elsif result =~ /The dummy is swinging back and forth./i
    waitrt?
    fput "touch dummy"
    sweep_dummy_start.call
  elsif result =~ /The dummy has fallen off its post, you'll need to FIX it./i
    waitrt?
    fput "fix dummy"
    sweep_dummy_start.call
  elsif result =~ /repetition|fail to flip/i
    sweep_dummy_start.call
  elsif result.nil?
    sweep_dummy_start.call
  end
}

sweep_dirt = proc{
  #fput "gld"
  fput_gld.call
  waitfor "The Training Administrator told you to sweep the guild courtyard"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      number = 0
      target_room = Room.current.find_nearest(tool_rack_room_number)
      start_script 'go2', [ target_room.to_s ]
      wait_while{ running?('go2') }
      if Room.current.id == 17969
        dirt_rooms = ice_dirt_rooms
      elsif Room.current.id == 16581
        dirt_rooms = landing_dirt_rooms
      elsif Room.current.id == 17941
        dirt_rooms = sol_dirt_rooms
      elsif Room.current.id == 17861
        dirt_rooms = illistim_dirt_rooms
      elsif Room.current.id == 17396
        dirt_rooms = teras_dirt_rooms
      elsif Room.current.id == 18003
        dirt_rooms = rr_dirt_rooms
      else
        echo "Error! Stuck in sweep_dirt, try running script again and please inform author of this error."
      end
      fput "put my #{GameObj.right_hand.name} on rack" if checkright =~ /broom/i || checkleft =~ /broom/i
      fput "put my #{GameObj.left_hand.name} on rack" if checkright =~ /bag/i || checkleft =~ /bag/i
      stow.call
      fput "get broom from rack" unless checkright =~ /broom/i || checkleft =~ /broom/i
      fput "get bag from rack" unless checkright =~ /bag/i || checkleft =~ /bag/i
      sweep_dirt_move.call
      break
    end
  end
}

sweep_dirt_move = proc{
  if number > dirt_rooms.length - 1
    sweep_dirt_full.call
  else
    start_script "go2", [dirt_rooms.at(number)]
    wait_while{ running?('go2') }
    number += 1
    sweep_dirt_sweep.call
  end
}

sweep_dirt_sweep = proc{
  waitrt?
  result = dothistimeout "push broom", 3, /There is no dirt here to sweep|Get what|Round time/i
  if result =~ /There is no dirt here to sweep/i
    sweep_dirt_get.call
  elsif result =~ /Get what/i
    sweep_dirt_move.call
  elsif result =~ /Round time/i
    sweep_dirt_sweep.call
  elsif result.nil?
    sweep_dirt_sweep.call
  end
}

sweep_dirt_get = proc{
  waitrt?
  result = dothistimeout "get pile", 3, /Your bag is full\, time to go empty it out|You don't see a dirt pile that you have created here|You gather a dirt pile into your burlap bag.|Get what/i
  if result =~ /Your bag is full\, time to go empty it out|You don't see a dirt pile that you have created here/i
    sweep_dirt_full.call
  elsif result =~ /You gather a dirt pile into your burlap bag.|Get what/i
    sweep_dirt_move.call
  elsif result.nil?
    sweep_dirt_get.call
  end
}

sweep_dirt_full = proc{
  number = 0
  target_room = Room.current.find_nearest(tool_rack_room_number)
  start_script 'go2', [ target_room.to_s ]
  wait_while{ running?('go2') }
  waitrt?
  result = dothistimeout "put my burlap bag in bin", 3, /You have completed|Your burlap bag isn't full yet.|repetition/i
  if result =~ /You have completed/i
    target_room = Room.current.find_nearest(tool_rack_room_number)
    start_script 'go2', [ target_room.to_s ]
    wait_while{ running?('go2') }
    multifput "put my broom on rack", "put my burlap bag on rack"
    turnin.call
  elsif result =~ /Your burlap bag isn't full yet.|repetition/i
    sweep_dirt_move.call
  elsif result.nil?
    sweep_dirt_full.call
  end
}

sweep_critters = proc{
  #fput "gld"
  fput_gld.call
  waitfor "The Training Administrator told you to practice sweeping creatures"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      if do_critter_sweep_tasks == "yes"
        fput "gld stance off"
        echo "Go sweep some critters! Restart script when you have finished this task."
        exit
      elsif do_critter_sweep_tasks == "no"
        target_room = Room.current.find_nearest(training_administrator_room)
        start_script 'go2', [ target_room.to_s ]
        wait_while{ running?('go2') }
        GameObj.npcs.find { |npc| person = npc if npc.name =~ training_administrator_names }
        multifput "ask #{person} about trade sweep", "ask #{person} about train sweep"
        go_to_task.call
      elsif do_critter_sweep_tasks == "auto"
        stow.call
        multifput "gld stance off", "get my #{mainweapon}", "get my #{shield}"
        fput "remove my #{shield}" if checkleft == nil
        my_room = Room.current.id
        auto_critter_sweep_tasks.call
      end
      break
    end
  end
}

substart = proc{
  #fput "gld"
  fput_gld.call
  waitfor "Subdue skill"
  while line = get
    (garlic_start.call;break) if line =~ /The Training Administrator told you to crush up some/i
    (mannequins_start.call;break) if line =~ /The Training Administrator told you to ding up a few melons at the subdue mannequins./i
    (windows_get_rag.call;break) if line =~ /The Training Administrator told you to clean the windows in the guild./i
    (sub_critter.call;break) if line =~ /The Training Administrator told you to try and subdue some creatures/i
    (promotion.call;break) if line =~ /Congratulations\, you\'ve earned a rank|You need to get promoted to your next rank|You have earned enough training points for your next rank./i
    (turnin.call;break) if line =~ /You are not currently training in this skill|You have no repetitions remaining for this task./i
  end
}

#sub_critters = proc{
  #fput "gld stance off"
  #echo "Go subdue some critters! Restart script when you have finished this task."
  #exit
  #}
sub_critter = proc{
  #echo "------------sub_critter started" if debug
  #fput "gld"
  fput_gld.call
  waitfor /The Training Administrator told you to try and subdue some creatures/i
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      if do_critter_sweep_tasks == "yes"
        fput "gld stance off"
        echo "Go #{cheap_task} some critters! Restart script when you have finished this task."
        exit
      elsif do_critter_sweep_tasks == "no"
        echo "Go #{cheap_task} some critters! Restart script when you have finished this task."
        exit
        target_room = Room.current.find_nearest(training_administrator_room)
        start_script 'go2', [ target_room.to_s ]
        wait_while{ running?('go2') }
        GameObj.npcs.find { |npc| person = npc if npc.name =~ training_administrator_names }
        multifput "ask #{person} about trade subdue", "ask #{person} about train subdue"
        go_to_task.call
      elsif do_critter_sweep_tasks == "auto"
        stow.call
        fput "gird"
        #multifput "gld stance off", "get my #{mainweapon}", "get my #{shield}"
        #fput "remove my #{shield}" if checkleft == nil
        my_room = Room.current.id
        
        auto_critter_sub_tasks.call
      end
      break
    end
  end
}


garlic_start = proc{
  #fput "gld"
  fput_gld.call
  waitfor "The Training Administrator told you to crush up some"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      stow.call
      get_weapon.call
      target_room = Room.current.find_nearest(kitchen_room_number)
      start_script 'go2', [ target_room.to_s ]
      wait_while{ running?('go2') }
      move 'go kitchen'
      get_garlic.call
      break
    end
  end
}

get_garlic = proc{
  stand.call
  waitrt?
  fput "put clove on block"
  result = dothistimeout "subdue block", 3, /You have completed your training task|You\'re done with this task for now\, you should see the Training Administrator for what to do next|PUT BLOCK IN POT|Put it in the pot now|You\'ll need to have a clove of garlic on the block before trying to smash it properly|You\'re going to need to CLEAN the block before putting another clove on it|Roundtime/i
  if result =~ /You have completed your training task|You\'re done with this task for now\, you should see the Training Administrator for what to do next/i
    turnin.call
  elsif result =~ /PUT BLOCK IN POT|Put it in the pot now/i
    waitrt?
    fput "put block in pot"
    get_garlic.call
  elsif result =~ /You\'ll need to have a clove of garlic on the block before trying to smash it properly|You\'re going to need to CLEAN the block before putting another clove on it/i
    waitrt?
    fput "clean block"
    get_garlic.call
  elsif result =~ /Roundtime/i
    stand.call
    stamina_check.call if checkstamina < 12
    waitrt?
    fput "subdue block"
    get_garlic.call
  elsif result.nil?
    get_garlic.call
  end
}

mannequins_start = proc{
  #fput "gld"
  fput_gld.call
  waitfor "The Training Administrator told you to ding up a few melons at the subdue mannequins"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      waitrt?
      stow.call
      get_weapon.call
      target_room = Room.current.find_nearest(mannequin_room_number)
      start_script 'go2', [ target_room.to_s ]
      wait_while{ running?('go2') }
      move 'go mannequin'
      mannequins_subdue.call
      break
    end
  end
}

mannequins_subdue = proc{
  stand.call
  stamina_check.call if checkstamina < 12
  waitrt?
  result = dothistimeout "subdue mann", 3, /You have completed your training task|clean|needs a head|Round time|repetition|Roundtime/i
  if result =~ /You have completed your training task/i
    turnin.call
  elsif result =~ /Round time|repetition|Roundtime/i
    mannequins_subdue.call
  elsif result =~ /clean/i
    waitrt?
    fput "clean mann"
    mannequins_subdue.call
  elsif result =~ /needs a head/i
    waitrt?
    multifput "clean mann", "put melon on mann"
    mannequins_subdue.call
  elsif result.nil?
    mannequins_subdue.call
  end
}

windows_get_rag = proc{
  #fput "gld"
  fput_gld.call unless script.vars[1] == "test"
  waitfor "The Training Administrator told you to clean the windows in the guild", "The Training Administrator told you to clean the guild windows." unless script.vars[1] == "test"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i || script.vars[1] == "test"
      echo "testing" if script.vars[1] == "test"
      number = 0
      target_room = Room.current.find_nearest(tool_rack_room_number)
      (start_script 'go2', [ target_room.to_s ]) if target_room.to_s != Room.current.id.to_s
      wait_while{ running?('go2') }
      my_room = Room.current.id
      if Room.current.id == 17969
        current_window_rooms = ice_window_rooms
      elsif Room.current.id == 16581
        current_window_rooms = landing_window_rooms
      elsif Room.current.id == 17941
        current_window_rooms = sol_window_rooms
      elsif Room.current.id == 17861
        current_window_rooms = illistim_window_rooms
      elsif Room.current.id == 17396
        current_window_rooms = teras_window_rooms
      elsif Room.current.id == 18003
        current_window_rooms = rr_window_rooms
      else
        echo "Error! Stuck in windows_get_rag, try running script again and please inform author of this error."
      end
      fput "put my rag on rack" if checkright =~ /rag/i or checkleft =~ /rag/i
      stow.call
      fput "get rag from rack"
      windows_move.call
      break
    end
  end
}

windows_clean = proc{
  result = dothistimeout "rub window", 3, /You have completed this task|repetition|let someone else have a crack at it|You don't need to do that just now/i
  if result =~ /You have completed this task/i
    waitrt?
    target_room = Room.current.find_nearest(tool_rack_room_number)
    start_script 'go2', [ target_room.to_s ]
    wait_while{ running?('go2') }
    #multifput "put my rag on rack", "gird"
    fput "put my rag on rack"
    #fput "remove my #{shield}" if checkleft == nil
    #fput "stance def"
    start_script 'go2', [my_room]
    wait_while{ running?('go2') }
    turnin.call
  elsif result =~/You don't need to do that just now/i
    exit if script.vars[1] != "test"
    windows_move.call
  elsif result =~ /repetition|let someone else have a crack at it|/i
    windows_move.call
  elsif result.nil?
    windows_clean.call
  end
}

windows_move = proc{
  if number > current_window_rooms.length - 1
    if do_other_guild_tasks == "yes" 
      target_room = Room.current.find_nearest(tool_rack_room_number)
      (start_script 'go2', [ target_room.to_s ]) if target_room.to_s != Room.current.id.to_s
      wait_while{ running?('go2') }
      #multifput "put my rag on rack", "get my #{mainweapon}", "get my #{shield}"
      multifput "put my rag on rack", "gird"
      #fput "remove my #{shield}" if checkleft == nil
      fput "stance def"
      go_to_room = nil
      if Room.current.id == 17969
        go_to_room = 16581
      elsif Room.current.id == 16581
        go_to_room = 17941
      elsif Room.current.id == 17941
        go_to_room = 17969
      else go_to_room = nil
      end
      (start_script "go2", [go_to_room.to_s]) if go_to_room.to_s != Room.current.id.to_s && go_to_room.nil? == false
      wait_while{ running?('go2') }
      number = 0
      target_room = Room.current.find_nearest(tool_rack_room_number) 
      (start_script 'go2', [ target_room.to_s ]) if target_room.to_s != Room.current.id.to_s
      wait_while{ running?('go2') }
      if Room.current.id == 17969
        current_window_rooms = ice_window_rooms
      elsif Room.current.id == 16581
        current_window_rooms = landing_window_rooms
      elsif Room.current.id == 17941
        current_window_rooms = sol_window_rooms
      elsif Room.current.id == 17861
        current_window_rooms = illistim_window_rooms
      elsif Room.current.id == 17396
        current_window_rooms = teras_window_rooms
      elsif Room.current.id == 18003
        current_window_rooms = rr_window_rooms
      else
        echo "Error! Stuck in windows_move, try running script again and please inform author of this error."
      end
      fput "put my rag on rack" if checkright =~ /rag/i || checkleft =~ /rag/i
      stow.call
      fput "get rag from rack"
      windows_move.call
    else
      waitrt?
      target_room = Room.current.find_nearest(tool_rack_room_number)
      (start_script 'go2', [ target_room.to_s ]) if target_room.to_s != Room.current.id.to_s
      wait_while{ running?('go2') }
      #multifput "put my rag on rack", "get my #{mainweapon}", "get my #{shield}"
      #multifput "put my rag on rack", "gird"
      fput "put my rag on rack"
      #fput "remove my #{shield}" if checkleft == nil
      #fput "stance def"
      (start_script 'go2', [my_room] ) if my_room.nil? == false
      wait_while{ running?('go2') }
      #respond "Couldn't finish task, try starting script again in 20 minutes."
      #exit
      respond "Couldn't finish task, waiting 10 minutes."
      sleep 615
      pc = GameObj.pcs.find { |pc| pc.name =~ /Xanlin|Amaurn/i }
      if pc && XMLData.name =~ /Xanlin|Amaurn/
          Xmod.gs_print(Xmod.format_whisper("+--------| ;u xro           when ready |-------+"))
          pause_script
      end
      windows_get_rag.call
    end
  else
    (start_script "go2", [current_window_rooms.at(number)]) if current_window_rooms.at(number).nil? == false
    wait_while{ running?('go2') }
    number += 1
    windows_clean.call
  end
}

lmasstart = proc{
  #fput "gld"
  fput_gld.call
  waitfor "Lock Mastery skill"
  while line = get
    (lmas_tough_boxes.call;break) if line =~ /pick some tough boxes from creatures/i
    (lmas_trick.call;break) if line =~ /challenging boxes to practice your latest trick for an audience/i
    (keys.call;break) if line =~ /cut keys for some locks you make/i
    (lmas_footpad_talk.call;break) if line =~ /The Training Administrator told you to visit a master footpad for a talk/i
    (lmas_footpad_challenge.call;break) if line =~ /The Training Administrator told you to pit your skills against a footpad./i
    (customize.call;break) if line =~ /customize some lockpicks and keys/i
    (promotion.call;break) if line =~ /(Congratulations\, you\'ve earned a rank|You need to get promoted to your next rank|You have earned enough training points for your next rank.)/i
    (turnin.call;break) if line =~ /You are not currently training in this skill/i
  end
}

lmas_footpad_talk = proc{
  #fput "gld"
  fput_gld.call
  waitfor "The Training Administrator told you to visit a master footpad for a talk"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      target_room = Room.current.find_nearest(training_master_room_number)
      start_script 'go2', [ target_room.to_s ]
      wait_while{ running?('go2') }
      GameObj.npcs.find { |npc| master = npc if npc.name =~ master_names }
      talk_to_footpad_masters.call
      break
    end
  end
}

talk_to_footpad_masters = proc{
  fput "ask #{master} about train lmas"
  while line = get
    (lmas_footpad_lock_start.call;break) if line =~ /LMASTER RELOCK the box on the table/i
    (lmas_lockpick_start.call;break) if line =~ /just because you can make your own lockpicks/i
    (customize_footpad_pre.call;break) if line =~ /yer coming down the homestretch now/i
  end
}

lmas_tough_boxes = proc{
  #fput "gld"
  fput_gld.call
  waitfor "pick some tough boxes from creatures"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    (echo "Pick some tough boxes then restart script when finished with task.";exit) if line =~ /remaining to complete this task|remaining for this task/i
  end
}

lmas_trick = proc{
  #fput "gld"
  fput_gld.call
  waitfor "challenging boxes to practice your latest trick for an audience"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    (echo "Practice your latest trick for an audience then restart script when finished with task.";exit) if line =~ /remaining to complete this task|remaining for this task/i
  end
}

customize = proc{
  #fput "gld"
  fput_gld.call
  waitfor "customize some lockpicks and keys"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      #fput "gld"
  fput_gld.call
      waitfor "Lock Mastery skill"
      numberoflockpicks = matchfindword "You have ?"
      numberoflockpicks = Integer(numberoflockpicks)
      start_script 'go2', [ 'bank', '--disable-confirm' ]
      wait_while{ running?('go2') }
      multifput "depo all", "withdraw 5000 silvers"
      target_room = Room.current.find_nearest(toolbenches_room_number)
      start_script 'go2', [ target_room.to_s ]
      wait_while{ running?('go2') }
      fput "go tool"
      customize_create.call
    end
  end
}

customize_create = proc{
  if numberoflockpicks > 0
    waitrt?
    multifput "order 26", "buy"
    result = dothistimeout "lmas create", 3, /You carefully slice the ruined part of|As you remove the resulting/i
    if result =~ /You carefully slice the ruined part of/i
      waitrt?
      sleep 1
      fput "drop copper"
      customize_create.call
    elsif result =~ /As you remove the resulting/i
      waitrt?
      sleep 1
      fput "swap"
      multifput "lmas customize edge brass", "lmas customize edge brass"
      waitrt?
      sleep 1
      numberoflockpicks -= 1
      fput "drop my lockpick"
      sleep 1
      customize_create.call
    end
  else
    turnin.call
  end
}

customize_footpad_pre = proc{
  move 'out' if checkpaths 'out'
  #fput "gld"
  fput_gld.call
  waitfor "Lock Mastery skill"
  numberoflockpicks = matchfindword "You have ?"
  numberoflockpicks = Integer(numberoflockpicks)
  start_script 'go2', [ 'bank', '--disable-confirm' ]
  wait_while{ running?('go2') }
  multifput "depo all", "withdraw 5000 silvers"
  target_room = Room.current.find_nearest(toolbenches_room_number)
  start_script 'go2', [ target_room.to_s ]
  wait_while{ running?('go2') }
  fput "go tool"
  customize_footpad_create.call
}

customize_footpad_create = proc{
  if numberoflockpicks > 0
    waitrt?
    multifput "order 26", "buy"
    result = dothistimeout "lmas create", 3, /You carefully slice the ruined part of|As you remove the resulting/i
    if result =~ /You carefully slice the ruined part of/i
      waitrt?
      sleep 1
      fput "drop copper"
      customize_footpad_create.call
    elsif result =~ /As you remove the resulting/i
      waitrt?
      sleep 1
      fput "swap"
      sleep 1
      multifput "lmas customize edge brass", "lmas customize edge brass"
      sleep 1
      waitrt?
      sleep 1
      numberoflockpicks -= 1
      fput "stow my lockpick"
      customize_footpad_create.call
    end
  else
    move 'out' if checkpaths 'out'
    target_room = Room.current.find_nearest(training_master_room_number)
    start_script 'go2', [ target_room.to_s ]
    wait_while{ running?('go2') }
    GameObj.npcs.find { |npc| master = npc if npc.name =~ master_names }
    fput "ask #{master} about training lmas"
    waitfor "I assume you've got some lockpicks or keys to show me"
    customize_footpad_hand_in1.call
  end
}

customize_footpad_hand_in1 = proc{
  result = dothistimeout "get copper lockpick from my #{stow_container}", 3, /Get what|You remove/i
  if result =~ /Get what/i
    turnin.call
  elsif result =~ /You remove/i
    multifput "give my lockpick to #{master}", "drop my lockpick"
    customize_footpad_hand_in1.call
  end
}

lmas_footpad_lock_start = proc{
  waitrt?
  fput "get my #{lmas_lockpick}" if checkright !~ /#{lmas_lockpick}/
  multifput "get box", "lmas relock my box"
  result = dothistimeout "give my box to #{master}", 3, /You have completed your training task|repetition|roundtime/i
  if result =~ /You have completed your training task/i
    waitrt?
    fput "put my #{lmas_lockpick} in my #{lockpick_container}"
    turnin.call
  elsif result =~ /repetition|roundtime/i
    lmas_footpad_lock_start.call
  elsif result.nil?
    lmas_footpad_lock_start.call
  end
}

lmas_footpad_challenge = proc{
  #fput "gld"
  fput_gld.call
  waitfor "pit your skills against a footpad"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      stow.call
      move 'out' if checkpaths 'out'
      target_room = Room.current.find_nearest(training_master_room_number)
      start_script 'go2', [ target_room.to_s ]
      wait_while{ running?('go2') }
      lmas_footpad_challenge1.call
      break
    end
  end
}

lmas_footpad_challenge1 = proc{
  move 'out' if checkpaths 'out'
  GameObj.npcs.find { |npc| master = npc if npc.name =~ master_names }
  number = 0
  fput "ask #{master} about training lmas"
  while line = get
    (turnin.call;break) if line =~/gives you a strange look/i
    (fput "nod";lmas_footpad_challenge_begin.call;break) if line =~ /just nod to me when yer feelin/i
  end
}


lmas_footpad_challenge_begin = proc{
  waitrt?
  fput "put my lockpick on table" if checkright == "lockpick"
  number = number + 1
  if number <= 5
    lmas_footpad_challenge_begin1.call
  else
    lmas_footpad_challenge_wait.call
  end
}

lmas_footpad_challenge_begin1 = proc{
  waitrt?
  result = dothistimeout "disarm #{box[number]}", 3, /You can see what appears to be a tiny hole next to the lock plate which doesn't seem to belong there|You discover no traps.|You will need to have both hands free or be holding just the box for that./i
  if result =~ /You can see what appears to be a tiny hole next to the lock plate which doesn't seem to belong there/i
    lmas_footpad_challenge_trap.call
  elsif result =~ /You will need to have both hands free or be holding just the box for that./
    fput "put my lockpick on table" if checkright =~ /lockpick/i
  elsif result =~ /You discover no traps./i
    lmas_footpad_challenge_pick.call
  elsif result.nil?
    lmas_footpad_challenge_begin1.call
  end
}

lmas_footpad_challenge_trap = proc{
  waitrt?
  result = dothistimeout "disarm #{box[number]}", 3, /you nudge the end of the flag to one side|You can't seem to get the trap disarmed without setting it off by accident!/i
  if result =~ /you nudge the end of the flag to one side/i
    lmas_footpad_challenge_pick.call
  elsif result =~ /You can't seem to get the trap disarmed without setting it off by accident!/i
    lmas_footpad_challenge_trap.call
  elsif result.nil?
    lmas_footpad_challenge_trap.call
  end
}

lmas_footpad_challenge_pick = proc{
  waitrt?
  fput "get vaalin lockpick from table"
  result = dothistimeout "pick #{box[number]}", 3, /It opens|You are not able to pick the lock|Roundtime/i
  if result =~ /It opens/i
    lmas_footpad_challenge_begin.call
  elsif result =~ /You are not able to pick the lock|Roundtime/i
    lmas_footpad_challenge_pick.call
  elsif result.nil?
    lmas_footpad_challenge_pick.call.call
  end
}

lmas_footpad_challenge_wait = proc{
  while line = get
    (lmas_footpad_challenge1.call;break) if line =~ /escorts you back to the training area|Game\'s over/i
  end
}

cal = proc{
  stow.call
  target_room = Room.current.find_nearest(toolbenches_room_number)
  start_script 'go2', [ target_room.to_s ]
  wait_while{ running?('go2') }
  fput "go toolbench"
  waitfor "workshop instructions"
  fput "get my calipers"
  cal_start.call
}

cal_start = proc{
  waitrt?
  result = dothistimeout "lmaster cal my cal", 3, /Those calipers could not be more perfectly calibrated.|They practically glow with calibration!|need further tuning|Roundtime/i
  if result =~ /Those calipers could not be more perfectly calibrated.|They practically glow with calibration!/i
    fput "put my calipers in my #{calipers_container}"
    move 'out' if checkpaths 'out'
    exit
  elsif result =~ /need further tuning|Roundtime/i
    cal_start.call
  elsif result.nil?
    cal_start.call
  end
}

carve_go = proc{
  number_of_wedges = (script.vars[2].to_i)
  silvers_needed = number_of_wedges * 300
  if number_of_wedges == 1
    echo "Making 1 wedge"
  else
    echo "Making #{number_of_wedges} wedges."
  end
  stow.call
  start_script 'go2', [ 'bank', '--disable-confirm' ]
  wait_while{ running?('go2') }
  multifput "depo all", "withdraw #{silvers_needed} silvers"
  target_room = Room.current.find_nearest(toolbenches_room_number)
  start_script 'go2', [ target_room.to_s ]
  wait_while{ running?('go2') }
  fput "go toolbench"
  waitfor "workshop instructions"
  buy_block.call
}

buy_block = proc{
  fput "put my wedge in my #{wedge_container}" if checkleft == "wedge" or checkright == "wedge"
  fput "stow right" if checkright
  fput "stow left" if checkleft
  number_of_wedges -= 1
  if number_of_wedges <= 0
    echo "Done making wedges"
    move 'out' if checkpaths 'out'
    exit
  end
  waitrt?
  multifput "order 1", "buy"
  carve_start.call
}

carve_start = proc{
  waitrt?
  result = dothistimeout "carve my block", 3, /wedge|wooden block|You can\'t carve that\!/i
  if result =~ /wedge/i
    carve.call
  elsif result =~ /wooden block/i
    carve_start.call
  elsif result =~ /You can\'t carve that\!/
    echo "Done making wedges"
    move 'out' if checkpaths 'out'
    exit
  elsif result.nil?
    carve_start.call
  end
}

carve = proc{
  waitrt?
  result = dothistimeout "carve my wedge", 3, /You should RUB the wedge now.|Roundtime/i
  if result =~ /You should RUB the wedge now./i
    carve_rub.call
  elsif result =~ /Roundtime/i
    carve.call
  elsif result.nil?
    carve.call
  end
}

carve_rub = proc{
  waitrt?
  result = dothistimeout "rub my wedge", 3, /is ready for use!|Roundtime/i
  if result =~ /is ready for use!/i
    buy_block.call
  elsif result =~ /Roundtime/i
    carve_rub.call
  elsif result.nil?
    carve_rub.call
  end
}

lmas_lockpick_start = proc{
  move 'out' if checkpaths 'out'
  #fput "gld"
  fput_gld.call
  waitfor "Lock Mastery skill"
  numberoflockpicks = matchfindword "You have ?"
  numberoflockpicks = Integer(numberoflockpicks)
  echo "Making #{numberoflockpicks} lockpicks"
  start_script 'go2', [ 'bank', '--disable-confirm' ]
  wait_while{ running?('go2') }
  multifput "depo all", "withdraw 5000 silvers"
  target_room = Room.current.find_nearest(toolbenches_room_number)
  start_script 'go2', [ target_room.to_s ]
  wait_while{ running?('go2') }
  fput "go tool"
  lock_pick_create.call
}

lock_pick_create = proc{
  if numberoflockpicks > 0
    waitrt?
    multifput "order 26", "buy"
    result = dothistimeout "lmas create", 3, /You carefully slice the ruined part of|As you remove the resulting/i
    if result =~ /You carefully slice the ruined part of/i
      waitrt?
      fput "drop copper"
      lock_pick_create.call
    elsif result =~ /As you remove the resulting/i
      numberoflockpicks -= 1
      waitrt?
      fput "stow my lockpick"
      lock_pick_create.call
    end
  else
    move 'out' if checkpaths 'out'
    target_room = Room.current.find_nearest(training_master_room_number)
    start_script 'go2', [ target_room.to_s ]
    wait_while{ running?('go2') }
    GameObj.npcs.find { |npc| master = npc if npc.name =~ master_names }
    lockpick_handin.call
    fput "ask #{master} about train lmas"
    waitfor "got some lockpicks to show me"
    lockpick_handin1.call
  end
}

lockpick_handin1 = proc{
  result = dothistimeout "get copper lockpick from my #{stow_container}", 3, /Get what|You remove/i
  if result =~ /Get what/i
    move 'out' if checkpaths 'out'
    target_room = Room.current.find_nearest(training_administrator_room)
    start_script 'go2', [ target_room.to_s ]
    wait_while{ running?('go2') }
    GameObj.npcs.find { |npc| person = npc if npc.name =~ training_administrator_names }
    multifput "ask #{training_administrator_names} about train lock", "ask #{training_administrator_names} about train lock"
    lmasstart.call
  elsif result =~ /You remove/i
    multifput "give my lockpick to #{master}", "drop my lockpick"
    lockpick_handin1.call
  end
}

gamstart = proc{
  waitrt?
  stow.call
  ##fput "gld"
  fput_gld.call
  waitfor "Rogue Gambits skill"
  while line = get
    (gam_master.call;break) if line =~ /The Training Administrator told you to visit the master footpads for a lesson/i
    (gam_learn_start.call;break) if line =~ /partner to teach you your latest trick/i
    (gam_audience_start.call;break) if line =~ /The Training Administrator told you to practice your latest trick in front of an audience/i
    (gam_speed_start.call;break) if line =~ /one minute/i
    (gam_teach_start.call;break) if line =~ /teach a fellow guildmember something about rogue gambits/i
    (promotion.call;break) if line =~ /(Congratulations, you've earned a rank|You need to get promoted to your next rank|You have earned enough training points for your next rank.)/i
    (turnin.call;break) if line =~ /You are not currently training in this skill/i
  end
}

gam_master = proc{
  current_proc = "gam_master"
  respond "+------------------------------- proc_start: #{current_proc}" if debug
  #fput "gld"
  fput_gld.call
  waitfor /The Training Administrator told you to get some lessons from the footpads|The Training Administrator told you to visit the master footpads for a lesson/i
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /(\d+) repe\w+ remaining to complete this task|remaining for this task/i
      reps=$1
      waitrt?
      multifput "gld stance off", "stance off"
      move 'out' if checkpaths 'out'
      target_room = Room.current.find_nearest(training_master_room_number)
      start_script 'go2', [ target_room.to_s ]
      wait_while{ running?('go2') }
      GameObj.npcs.find { |npc| master = npc if npc.name =~ master_names }
      gam_master_begin.call
      #break
    end
  end
}

gam_master_begin = proc{
  current_proc = "gam_master_begin"
  respond "+------------------------------- proc_start: #{current_proc}" if debug
  fput "ask #{master} about training gam"
  waitfor "pulls you aside for some instruction."
  waitfor "RGAMBIT" 
  gam_master_start.call
}

gam_master_start = proc{
  current_proc = "gam_master_start"
  respond "+------------------------------- proc_start: #{current_proc}" if debug
  
  before_gambit.call
  
  result = dothistimeout "rgam #{gam}",do_timer, /You really ought to have some type of a dagger or such for that|You need to be holding something first|You already have that|You have completed your training|repetition|but realize that doing so would reveal your location|suddenly become aware that your actions have revealed your location|Just how stealthy are you trying to be|but have revealed yourself from hiding in doing so|you've injured yourself|you remain in your current position/i
  if result =~ /You need to be holding something first/i
    if gam =~ /^(display|get|vanish|stealth)/i
      get_stealth_item.call
    else #dagger probably, might've dropped it
      get_weapon.call
    end
    gam_master_start.call
  elsif result =~ /you remain in your current position/i
    gam_master_start.call
  elsif result =~ /You really ought to have some type of a dagger or such for that/
    get_weapon.call
    gam_master_start.call
  elsif result =~ /You already have that/i
    fput "stow #{weapon}"
    gam_master_start.call
  elsif result =~ /You have completed your training/i  #this isn't catching master gambits?
    fput "put my #{stealth_get_item} in my #{stealth_get_item_container}" if stealth_get_item_trick
    hide_before_trick = false
    stealth_get_item_trick = false
    turnin.call
  elsif result =~ /repetition/i
    (waitrt?;fput "unhide") until !hiding?
    gam_master_start.call
  elsif result =~ /suddenly become aware that your actions have revealed your location/i
    (waitrt?;fput "unhide") until !hiding?
    gam_master_start.call
  elsif result =~ /but have revealed yourself from hiding in doing so|but realize that doing so would compromise your hidden position|Just how stealthy are you trying to be/i
    gam_master_start.call
  #|Finally, you flick your wrist
  elsif result =~ /Suddenly you feel a sharp pain in your hand!/i  #dagger game
    Script.start('useherbs','--buy=off')
    gam_master_start.call
  #elsif result =~ /(Ta[pk][ta\.\-, ]*)\1/i
    #no keep waiting option
    #gam_master_start.call
  elsif result.nil?
    (waitrt?;fput "unhide") until !hiding?
    sleep 3
    #do_client(";Xanlin: #{current_proc}: #{gam}: no result") if thyfaiin
    gam_master_start.call
  end
}

partner_no_partner = proc {
  if script.vars[2] == nil
  respond "
  Partner tasks require a partner. 
  If you have a partner running ;xtask (with xrogue_teach downloaded)
  You should be running ;xrogue with your partner's name as the second parameter.
    e.g. ;xro #{script.vars[1]} Xanlin";
  exit;
  end
}

gam_learn_start = proc{
  current_proc = "gam_learn_start"
  respond "+------------------------------- proc_start: #{current_proc}" if debug
  #fput "gld"
  fput_gld.call
  waitfor "partner to teach you your latest trick"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      partner_no_partner.call if script.vars[2] == nil
      partner_room.call 
      
      wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{my_partner}(.*)/i } }
      
      before_gambit.call
      gam_retry = true
      
      fput "whisper #{my_partner} rgam teach #{checkname} #{gam}"  if !no_whisper_wait
      sleep 4 
      fput "whisper #{my_partner} I am ready to learn" if !no_whisper_wait
      #sleep 2
      #multifput "get my #{stealth_get_item} from my #{stealth_get_item_container}","drop my #{stealth_get_item}" if gam =~ /stealth get/i
      #drop_stealth_item.call if gam =~ /stealth get/i
      gam_learn_start1.call
      break
    end
  end
}

gam_learn_start1 = proc{
  current_proc = "gam_learn_start1"
  #respond "+------------------------------- proc_start: #{current_proc}" if debug
  gam_learn_start2.call
}

gam_learn_start2 = proc{
  current_proc = "gam_learn_start2"
  respond "+------------------------------- proc_start: #{current_proc}" if debug

  before_gambit.call if !gam_retry
  
  echo "whisper #{my_partner} #{Char.name} #{arr = gam.split(' ');arr[0..1].join('');}" if no_whisper_wait && debug
  sleep 2
  fput "whisper #{my_partner} #{Char.name} #{arr = gam.split(' ');arr[0..1].join('');}" if no_whisper_wait
  waitfor "shows you how " if gam =~ /stealth get/i && !gam_retry && !no_whisper_wait
  waitfor "gives you some pointers" if stealth_gambit && gam !~ /stealth get/i && !gam_retry  && !no_whisper_wait
  waitfor "#{my_partner} shows you" if !gam_retry && no_whisper_wait
  gam_retry = false
  
  hide.call if stealth_gambit
  
  result = dothistimeout "rgam #{gam =~ /person/i ? gam.gsub("person",GameObj.pcs[-1].noun) : gam}", 5, /places your hand on the nearby|You really ought|You need to be holding something first|You already have that|You have completed your training task|You have (.*) repetition|but realize that doing so would reveal your location|suddenly become aware that your actions have revealed your location|Just how stealthy are you trying to be|but have revealed yourself from hiding in doing so|but realize that doing so would compromise your hidden position/i
  
  if result =~ /You need to be holding something first|You really ought/i
    gam_learn_start1.call
  elsif result =~ /places your hand on the nearby/
    waitfor 'Finally, you flick your wrist'
    gam_learn_start1.call
  elsif result =~ /You have (.*) repetition/i
    reps = $1
    unhide.call
    fput "whisper #{my_partner} #{reps} more." if update_partner == "on"
    gam_learn_start1.call
  elsif result =~ /You have completed your training task/i
    fput "whisper #{my_partner} All done. Thank you!"
    unhide.call
    stow.call
    auto_run.call
  elsif result =~ /Just how stealthy are you trying to be|You already have that/i
    respond "this shouldn't happen -- pausing script"
    pause_script
    gam_learn_start1.call
  elsif result =~/but realize that doing so would (reveal|comp)|have revealed your/
    gam_retry = true
    gam_learn_start1.call
  elsif result.nil?
    do_client(";Xanlin: #{current_proc}: #{gam}: no result") if thyfaiin
    gam_learn_start1.call
  end
  respond "+---------------- #{current_proc}: result not identified" if debug
}

gam_audience_start = proc{
  current_proc = "gam_audience_start"
  respond "+------------------------------- proc_start: #{current_proc}" if debug
  #fput "gld"
  fput_gld.call
  waitfor "The Training Administrator told you to practice your latest trick in front of an audience"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      target_room = Room.current.find_nearest(audience_rooms)
      start_script 'go2', [ target_room.to_s ] if gam !~ /dagger game/i
      wait_while{ running?('go2') }
      sleep_timer = 0;
      gam_retry = false;
      gam_audience_begin.call
      break
    end
  end
}

gam_audience_begin = proc{
  current_proc = "gam_audience_begin"
  respond "+------------------------------- proc_start: #{current_proc}" if debug
  i = 0
  checkpcs.each { |pc| i += 1; break if pc == Char.name }
  (sleep 33;gam_audience_begin.call;break) if i < 2 
  #echo "#{i} people are here."
  
  sleep sleep_timer if !gam_retry;
  sleep_timer = 33
  
  before_gambit.call if !gam_retry;
  gam_retry = false
  waitrt?
  result = dothistimeout "rgam #{gam =~ /person/i ? gam.gsub("person",GameObj.pcs[-1].noun) : gam}", 5, /repetitions? remaining\.\]|some type of a dagger|You need to be holding something first|You already have that|You have completed your training task|reveal(ed)? your(self| location)|Just how stealthy are you trying to be|you remain in your current position|doing so would compromise|repetitions? remaining\.\]|have revealed your(self| location)/i
  
  if result =~ /repetitions? remaining\.\]/
    gam_audience_begin.call
  elsif result =~ /You have completed your training task/i
    stow.call
    turnin.call
  elsif result =~ /You need to be holding something first/i
    respond "this shouldn't happen"
    pause_script
    stow.call
    get_weapon.call
    gam_audience_begin.call
  elsif result =~ /you remain in your current position/i
    gam_retry = true
    gam_audience_begin.call
  elsif result =~ /You really ought to have some type of a dagger or such for that/
    respond "this shouldn't happen"
    pause_script
    get_weapon.call
    gam_audience_begin.call
  elsif result =~ /You already have that/i
    respond "this shouldn't happen"
    pause_script
    gam_audience_begin.call
  elsif result =~ /doing so would compromise/
    gam_retry = true
    gam_audience_begin.call
  elsif result =~ /suddenly become aware that your actions have revealed your location|but have revealed yourself from hiding in doing so|have revealed your(self| location)/i
    sleep_timer = 1
    gam_audience_begin.call
  elsif script.vars[1] == "test" 
    echo "not match found | expected on success during test"
    gam_audience_begin.call
  else 
    #echo "NO MATCH FOUND - DOING IT AGAIN" if debug 
    #do_client(";Xanlin: #{current_proc}: #{gam}: no result") if thyfaiin
    sleep_timer = 1
    gam_retry = true if gam !~ /get|vanish|display/
    gam_audience_begin.call
    #exit
  end
  
  #respond "+----------------  #{current_proc}: reached the end, shouldn't have, check regex above" if debug
}

gam_speed_start = proc{
  current_proc = "gam_speed_start"
  respond "+------------------------------- proc_start: #{current_proc}" if debug
  #fput "gld"
  fput_gld.call
  waitfor "one minute"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    (gam_speed_begin.call;break) if line =~ /remaining to complete this task|remaining for this task/i
  end
}

gam_speed_begin = proc{
  current_proc = "gam_speed_begin"
  respond "+------------------------------- proc_start: #{current_proc}" if debug
  before_gambit.call if !gam_retry
  gam_retry = false
  waitrt?
  result = dothistimeout "rgam #{gam =~ /person/i ? gam.gsub("person",GameObj.pcs[-1].noun) : gam}", 5, /You need to be holding something first|You already have that|You have completed your training task|(repetition|You must succeed)|but realize that doing so would reveal your location|suddenly become aware that your actions have revealed your location|Just how stealthy are you trying to be|but have revealed yourself from hiding in doing so|but realize that doing so would compromise your hidden position|You really ought to have some type of a dagger or such for that|your actions have revealed your location/i
  sleep 0.1
  if result =~ /have (\d+) repetitions?/i
    gam_speed_begin.call
  elsif result =~ /You have completed your training task/i
    after_gambit.call
    turnin.call
  elsif result =~ /You need to be holding something first|You really ought to have some type of a dagger or such for that/i
    respond "should not happen"
    pause_script
    if gam =~ /^(display|vanish|stealth)/i
      fput "get my #{stealth_get_item}" if checkright !~ /#{stealth_get_item}/i && checkleft !~ /#{stealth_get_item}/i
    else #dagger probably
      get_weapon.call
    end
    gam_speed_begin.call
  elsif result =~ /You already have that|Just how stealthy are you trying to be/i
    respond "should not happen"
    pause_script
    stow.call
    gam_speed_begin.call
  elsif result =~ /You must succeed|have revealed your(self| location)/i
    gam_speed_begin.call
  elsif result =~ /You manage to move to a sitting position while keeping your location hidden./
    gam_speed_begin.call
  elsif result =~/but realize that doing so/i
    gam_retry = true
    gam_speed_begin.call
  elsif result.nil?
    #echo "no match" if debug
    #do_client(";Xanlin: #{current_proc}: #{gam}: no result") if thyfaiin
    before_gambit.call
    gam_speed_begin.call
  end
}

gam_teach_start = proc{
  current_proc = "gam_teach_start"
  respond "+------------------------------- proc_start: #{current_proc}" if debug
  respond "+---------------- task = #{UserVars.rogue["task"]}" if debug
  #fput "gld"
  fput_gld.call
  waitfor "teach a fellow guildmember something about rogue gambits"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      exit if script.vars[2] == nil
      partner_room.call
      wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{my_partner}(.*)/i } }
      #fput "whisper #{my_partner} rgam #{gam}"
      fput "whisper #{my_partner} rgam tumble" if !no_whisper_wait
      waitfor "I am ready to learn" if !no_whisper_wait
      partner = GameObj.pcs.find { |pc| pc.name =~ /#{my_partner}(.*)/i }
      first_run = true
      gam_teach_start1.call
      break
    end
  end
}

gam_teach_start1 = proc{
  current_proc = "gam_teach_start1"
  respond "+------------------------------- proc_start: #{current_proc}" if debug
  if reget 10, "You have completed your training task"
    echo "You have completed your training task"
    wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{my_partner}/i } }
    fput "whisper #{my_partner} All done. Thank you!"
    auto_run.call
    break
  end
  respond "waiting for #{my_partner} nods" if no_whisper_wait && !first_run && debug
  waitfor "#{my_partner} nods" if no_whisper_wait && !first_run && debug
  before_gambit.call
  
  waitrt?
  first_run = false
  #result = dothistimeout "rgam teach #{my_partner} #{gam}", 5, /You really ought to have some type of a dagger or such for that|You need to have free hands to teach this gambit|You already have that|You should have a silver coin on you to teach this gambit|Wait a few seconds and try again|You have completed your training task|You have (.*) repetition|You need to be holding something first|Who are you trying to teach/i
  result = dothistimeout "rgam teach #{my_partner} tumble", 5, /You really ought to have some type of a dagger or such for that|You need to have free hands to teach this gambit|You already have that|You should have a silver coin on you to teach this gambit|Wait a few seconds and try again|You have completed your training task|You have (.*) repetition|You need to be holding something first|Who are you trying to teach/i
  if result =~ /You need to have free hands to teach this gambit/i
    stow.call
    gam_teach_start1.call
  elsif result =~ /You already have that/i
    fput "stow #{weapon}"
    gam_teach_start1.call
  elsif result =~ /You really ought to have some type of a dagger or such for that/i
    get_weapon.call
  elsif result =~ /You should have a silver coin on you to teach this gambit/i
    fput "whisper #{my_partner} Need a coin, be right back."
    currentroom = Room.current.id
    start_script 'go2', [ 'bank', '--disable-confirm' ]
    wait_while{ running?('go2') }
    fput "withdraw 2 silvers"
    start_script "go2", [ "#{currentroom}" ]
    wait_while{ running?('go2') }
    gam_teach_start1.call
  elsif result =~ /Wait a few seconds and try again/i
    sleep 2
    gam_teach_start1.call
  elsif result =~ /You have completed your training task/i
    wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{script.vars[3]}(.*)/i } }
    fput "whisper #{my_partner} All done. Thank you!"
    auto_run.call
  elsif result =~ /You have (.*) repetition/i
    reps = $1
    wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{script.vars[3]}(.*)/i } }
    fput "whisper #{my_partner} #{reps} more." if update_partner == "on"
    gam_teach_start1.call
  elsif result =~ /You need to be holding something first|You really ought/
    get_weapon.call
    gam_teach_start1.call
  elsif result =~ /Who are you trying to teach/
    sleep 5
    gam_teach_start1.call
  elsif result.nil?
    #do_client(";Xanlin: #{current_proc}: #{gam}: no result") if thyfaiin
    gam_teach_start1.call
  end
}

repair = proc{
  stow.call
  target_room = Room.current.find_nearest(toolbenches_room_number)
  start_script 'go2', [ target_room.to_s ]
  wait_while{ running?('go2') }
  fput "go toolbench"
  getpick.call
}

keys = proc{
  #fput "gld"
  fput_gld.call
  waitfor "cut keys for some locks you make"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      start_script 'go2', [ 'bank', '--disable-confirm' ]
      wait_while{ running?('go2') }
      multifput "depo all", "withdraw 5000 silvers"
      target_room = Room.current.find_nearest(toolbenches_room_number)
      start_script 'go2', [ target_room.to_s ]
      wait_while{ running?('go2') }
      fput "go tool"
      keys_1.call
      break
    end
  end
}

keys_1 = proc{
  waitrt?
  multifput "drop my key", "drop my assem"
  multifput "lmas lock create 25", "lmas lock create 25"
  waitrt?
  multifput "order 25", "buy"
  result = dothistimeout "lmas cut key", 5, /repetition|You have completed your training task/i
  if result =~ /repetition/i
    keys_1.call
  elsif result =~ /You have completed your training task/i
    waitrt?
    multifput "drop my key", "drop my assem", "out"
    turnin.call
  end
}

cheapstart = proc{
  #fput "gld"
  fput_gld.call
  waitfor "Cheap Shot skill"
  while line = get
    (footstomp_defend.call;break) if line =~ /The Training Administrator told you to practice defending against footstomps./i
    (footstomp_partner.call;break) if line =~ /The Training Administrator told you to practice footstomping a partner./i
    #(footstomp_critter.call;break) if line =~ /The Training Administrator told you to stomp some creatures' feet./i
    (cheap_task="footstomp";cheap_critter.call;break) if line =~ /The Training Administrator told you to stomp some creatures/i
    (cheap_task="nosetweak";cheap_critter.call;break) if line =~ /The Training Administrator told you to tweak some creature/i
    (cheap_task="templeshot";cheap_critter.call;break) if line =~ /The Training Administrator told you to practice templeshot on some creatures./i
    (cheap_task="eyepoke";cheap_critter.call;break) if line =~ /The Training Administrator told you to poke some creatures in the eyes/
    (cheap_task="throatchop";cheap_critter.call;break) if line =~ /The Training Administrator told you to practice throatchop on creatures/
    (cheap_task="knee";cheap_critter.call;break) if line =~ /The Training Administrator told you to kneecap some creatures./
    #(cheap_critter.call;break) if line =~ /The Training Administrator told you to tweak some creatures\' noses.|The Training Administrator told you to practice templeshot on some creatures./i
    (cheap_plants.call;break) if line =~ /The Training Administrator told you to water the guild plants./i
    (sweep_dirt.call;break) if line =~ /The Training Administrator told you to sweep the guild courtyard./i
    (windows_get_rag.call;break) if line =~ /The Training Administrator told you to clean the guild windows./i
    (windows_get_rag.call;break) if line =~ /The Training Administrator told you to clean the windows in the guild\.|The Training Administrator told you to clean the guild windows\./i
    (promotion.call;break) if line =~ /(Congratulations, you've earned a rank|You need to get promoted to your next rank|You have earned enough training points for your next rank.)/i
    (turnin.call;break) if line =~ /You are not currently training in this skill/i
  end
}

footstomp_defend = proc{
  #fput "gld"
  fput_gld.call
  waitfor "The Training Administrator told you to practice defending against footstomps."
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      exit if script.vars[2] == nil
      multifput "gld stance def", "stance off"
      partner_room.call
      wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{my_partner}(.*)/i } }
      fput "whisper #{my_partner} I need to be footstomped." if !no_whisper_wait
      fput "whisper #{my_partner} #{Char.name} winks" if no_whisper_wait
      foot_stomp_defend1.call
      break
    end
  end
}

foot_stomp_defend1 = proc{
  while line = get
    if line =~ /You have (.*) repetition/i
      reps = $1
      fput "whisper #{my_partner} #{reps} more." if update_partner == "on"
      if no_whisper_wait
        waitfor "no longer feel painfully distracted"
        sleep 1
        fput "whisper #{my_partner} #{Char.name} winks" if no_whisper_wait
      end
    elsif line =~ /You have completed your training task/i
      fput "whisper #{my_partner} All done. Thank you!"
      auto_run.call
      break
    end
  end
}


footstomp_partner = proc{
  #fput "gld"
  fput_gld.call
  waitfor "The Training Administrator told you to practice footstomping a partner"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      partner_no_partner.call if script.vars[2].nil?
      multifput "gld stance off", "stance off"
      partner_room.call
      wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{my_partner}(.*)/i } }
      fput "whisper #{my_partner} I need to footstomp you." if !no_whisper_wait
      waitfor "Ready to be footstomped" if !no_whisper_wait
      (fput "prod #{my_partner}";sleep 1) if no_whisper_wait
      footstomp_partner_start.call
      break
    end
  end
}

footstomp_partner_start = proc{
  stand.call
  stamina_check.call if checkstamina < 12
  waitrt?
  result = dothistimeout "cheap foot #{my_partner}", 2, /just fell for a footstomp not long ago|You have completed your training task|You have (.*) repetition/i
  if result =~ /just fell for a footstomp not long ago/
    sleep 5
    footstomp_partner_start.call
  elsif result =~ /You have (.*) repetition/
    reps = $1
    fput "whisper #{my_partner} #{reps} more." if update_partner == "on"
    sleep 11
    footstomp_partner_start.call
  elsif result =~ /You have completed your training task/
    fput "whisper #{my_partner} All done!"
    waitrt?
    auto_run.call
  elsif result.nil?
    sleep 2
    footstomp_partner_start.call
  end
}

footstomp_critter = proc{
  #fput "gld"
  fput_gld.call
  waitfor "The Training Administrator told you to stomp some creatures' feet"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      if do_critter_sweep_tasks == "yes"
        fput "gld stance off"
        echo "Go stomp some critters! Restart script when you have finished this task."
        exit
      elsif do_critter_sweep_tasks == "no"
        target_room = Room.current.find_nearest(training_administrator_room)
        start_script 'go2', [ target_room.to_s ]
        wait_while{ running?('go2') }
        GameObj.npcs.find { |npc| person = npc if npc.name =~ training_administrator_names }
        multifput "ask #{person} about trade cheap", "ask #{person} about train cheap"
        go_to_task.call
      elsif do_critter_sweep_tasks == "auto"
        stow.call
        multifput "gld stance off", "get my #{mainweapon}", "get my #{shield}"
        fput "remove my #{shield}" if checkleft == nil
        my_room = Room.current.id
        auto_critter_cheap_tasks.call
      end
      break
    end
  end
}

####todo
cheap_critter = proc{
  current_proc = "cheap_critter"
  respond "+------------------------------- proc_start: #{current_proc}" if debug
  #fput "gld"
  fput_gld.call
  waitfor /The Training Administrator told you to stomp some creatures|The Training Administrator told you to tweak some creatures|The Training Administrator told you to practice templeshot on some creatures|kneecap some creatures|The Training Administrator told you to poke some creatures in the eyes|The Training Administrator told you to practice throatchop on creatures/i
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      echo "do_critter_sweep_tasks: #{do_critter_sweep_tasks}" if debug
      if do_critter_sweep_tasks == "yes"
        fput "gld stance off"
        echo "Go #{cheap_task} some critters! Restart script when you have finished this task."
        exit
      elsif do_critter_sweep_tasks =~ /no/i
        #echo "Go #{cheap_task} some critters! Restart script when you have finished this task."
        #exit
        target_room = Room.current.find_nearest(training_administrator_room)
        start_script 'go2', [ target_room.to_s ]
        wait_while{ running?('go2') }
        GameObj.npcs.find { |npc| person = npc if npc.name =~ training_administrator_names }
        multifput "ask #{person} about trade cheap", "ask #{person} about train cheap"
        go_to_task.call
      elsif do_critter_sweep_tasks =~ /auto/i
        stow.call
        multifput "gld stance off", "get my #{mainweapon}", "get my #{shield}"
        fput "remove my #{shield}" if checkleft == nil
        my_room = Room.current.id
        auto_critter_cheap_tasks.call
      end
      break
    end
  end
}

cheap_plants = proc{
  #fput "gld"
  fput_gld.call
  waitfor "The Training Administrator told you to water the guild plants"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      number = 0
      target_room = Room.current.find_nearest(tool_rack_room_number)
      start_script 'go2', [ target_room.to_s ]
      wait_while{ running?('go2') }
      my_room = Room.current.id
      if Room.current.id == 17969
        current_plant_rooms = ice_plant_rooms
      elsif Room.current.id == 16581
        current_plant_rooms = landing_plant_rooms
      elsif Room.current.id == 17941
        current_plant_rooms = sol_plant_rooms
      elsif Room.current.id == 17861
        current_plant_rooms = illistim_plant_rooms
      elsif Room.current.id == 17396
        current_plant_rooms = teras_plantrooms
      elsif Room.current.id == 18003
        current_plant_rooms = rr_plant_rooms
      else
        echo "Error! Stuck in cheap_plants, try running script again and please inform author of this error."
      end
      fput "put my can in rack" if checkright =~ /can/i or checkleft =~ /can/i
      stow.call
      fput "get can"
      cheap_plants_move.call
    end
  end
}

cheap_plants_move = proc{
  if number > current_plant_rooms.length - 1
    if do_other_guild_tasks == "yes"
      target_room = Room.current.find_nearest(tool_rack_room_number)
      start_script 'go2', [ target_room.to_s ]
      wait_while{ running?('go2') }
      multifput "put my can in rack", "get my #{mainweapon}", "get my #{shield}"
      fput "remove my #{shield}" if checkleft == nil
      fput "stance def"
      if Room.current.id == 17969
        go_to_room = 16581
      elsif Room.current.id == 16581
        go_to_room = 17941
      elsif Room.current.id == 17941
        go_to_room = 17969
      end
      start_script "go2", [go_to_room] if go_to_room
      wait_while{ running?('go2') }
      number = 0
      target_room = Room.current.find_nearest(tool_rack_room_number)
      start_script 'go2', [ target_room.to_s ]
      wait_while{ running?('go2') }
      if Room.current.id == 17969
        current_plant_rooms = ice_plant_rooms
      elsif Room.current.id == 16581
        current_plant_rooms = landing_plant_rooms
      elsif Room.current.id == 17941
        current_plant_rooms = sol_plant_rooms
      elsif Room.current.id == 17861
        current_plant_rooms = illistim_plant_rooms
      elsif Room.current.id == 17396
        current_plant_rooms = teras_plant_rooms
      elsif Room.current.id == 18003
        current_window_rooms = rr_plant_rooms
      else
        echo "Error! Stuck in cheap_plants_move, try running script again and please inform author of this error."
      end
      fput "put my can in rack" if checkright =~ /can/i or checkleft =~ /can/i
      stow.call
      water_round += 1
      (echo "waiting a moment before starting round #{water_round}";sleep 60) if water_round > 1 
      fput "get can"
      cheap_plants_move.call
    else
      waitrt?
      target_room = Room.current.find_nearest(tool_rack_room_number)
      start_script 'go2', [ target_room.to_s ]
      wait_while{ running?('go2') }
      fput "put my can in rack"
      #multifput "get my #{mainweapon}", "get my #{shield}"
      #fput "remove my #{shield}" if checkleft == nil
      #fput "stance def"
      #start_script 'go2', [my_room]
      #wait_while{ running?('go2') }
      #respond "Couldn't finish task, try starting script again in 20 minutes."
      #exit
      echo "waiting for ten minutes, no idea how long it takes for the plants to dry"
      sleep 600
      pc =GameObj.pcs.find { |pc| pc.name =~ /Xanlin|Amaurn/i }
      if pc && XMLData.name =~ /Xanlin|Amaurn/
          Xmod.gs_print(Xmod.format_whisper("+--------| ;u xro           when ready |-------+"))
          pause_script
      end
      cheap_plants.call
      #break
    end
  else
    start_script "go2", [current_plant_rooms.at(number)]
    wait_while{ running?('go2') }
    number += 1
    cheap_plants_water.call
  end
}

cheap_plants_water = proc{
  waitrt?
  fput "kneel"
  GameObj.loot.find { |loot| flower = loot.name if loot.name =~ flower_names }
  if Room.current.id == 17871 or Room.current.id == 17851 or Room.current.id == 17855 or Room.current.id == 17869 or Room.current.id == 17870
    flower = "wildflower"
  end
  if flower =~ /rose/
    flower = "rose"
  end
  result = dothistimeout "water #{flower}", 2, /You have completed|let someone else have a crack at it|repetition/i
  if result =~ /You have completed/i
    water_round = 0
    target_room = Room.current.find_nearest(tool_rack_room_number)
    start_script 'go2', [ target_room.to_s ]
    wait_while{ running?('go2') }
    fput "put my can in rack"
    multifput "get my #{mainweapon}", "get my #{shield}"
    fput "remove my #{shield}" if checkleft == nil
    fput "stance def"
    start_script 'go2', [my_room]
    wait_while{ running?('go2') }
    turnin.call
  elsif result =~ /let someone else have a crack at it|repetition/i
    cheap_plants_move.call
  end
}

latest_gambit = proc{
  waitrt?
  #fput "rgambit"
  fput_rgambit.call
  while line = get
      if line =~ /  +teach.*/i
        break
      end
      if line =~ /   +(tumble|cartwheel|flip|dagger|display|get|vanish|stealth)$/i
        mod = ""
        gam = $1.downcase
        # respond "1 #{gam} #{mod}" if debug
      end
      if line =~ /   +(tumble|cartwheel|flip|dagger|display|get|vanish|stealth)(.*?\]$)/i
        gam  = $1.downcase
        mod = $2.to_str.gsub!(/[ \|\[\]]|\{item\}/,' ').split(' ').last.downcase
        # respond "2 #{gam} #{mod}" if debug
      end
      if line =~/   +(tumble|cartwheel|flip|dagger|display|get|vanish|stealth)(.*\})/i
        gam  = $1.downcase
        temp = $2
        mod = $2.to_str.gsub(/[\[\]]| +\{.*/,'').split(' | ').last.downcase
        mod += temp.to_str.gsub(/.*?\]/,'').downcase
        # respond "3 #{gam} #{mod}" if debug
      end
      if line =~/   +(vanish) +(\[[^\]]+\])/i
        gam  = $1.downcase
        temp = $2
        mod = $2.to_str.gsub(/\{.+\}/i,'').split(' | ').last.downcase
        mod += temp.to_str.gsub(/.*?\]/,'').downcase
        # respond "4 #{gam} #{mod}" if debug
      end
      if line =~/   +(vanish)(.*?)\{/i
        gam  = $1.downcase
        mod = $2.to_str.gsub(/[\[\]]|\{.*?\}/,'').split(' | ').last
        mod = "#{mod} #{stealth_get_item} in #{stealth_get_item_container}"
        # respond "5 #{gam} #{mod}" if debug
      end
      if line =~/^  +(\[.*)/
        #gam  = $1.downcase
        mod = $1.to_str.gsub(/\[FROM .*?\]|\[|\]/,'').downcase
        mod = "#{mod}"
        # respond "6 #{mod}" if debug
      end
      if line =~ /I don't understand what you typed./i
        break
      end
    end
  DownstreamHook.remove('xrogue_squelch')
  mod = mod.gsub(/\{?item\}?/i,stealth_get_item).gsub(/\{?container\}?/i,stealth_get_item_container)


  gam = "#{gam.strip} #{mod.strip} #{gam=~/display/i ? weapon.strip : ""}" 
  gam = test_gam if test_gam;
  respond "Latest gambit = #{gam}" if debug
  UserVars.rogue["gambit"] = "#{gam}"

  stealth_gambit = gam =~ /^stealth/ ? true : false
  get_item_trick = gam =~ /^get/i ? true : false
  stealth_get_item_trick = gam =~ /^stealth get/i ? true : false
  hide_before_trick = gam =~ /^stealth/ ? true : false
}

before_gambit = proc {
  calling_proc = current_proc
  teaching = calling_proc =~ /teach/i ? true : false
  learning = calling_proc =~ /learn/i ? true : false
  #gam = task if teaching || learning
  current_proc = "before_gambit"
  respond "+------------------------------- proc_start: #{current_proc}" if debug
  timer = gam =~ /dagger game/i ? 180 : 5 #change default timer for dagger game
  #-----#
  waitrt? 
  if script.vars[1] =~/test/i #|| Char.name == 'Xanlin'  
    respond "teaching = #{teaching}"
    respond "learning = #{learning}"
    respond "calling_proc = #{calling_proc}"
    respond "gam = #{gam}"
    respond "task = #{task}"
    respond "stealth_gambit = #{stealth_gambit}"
    respond "get_item_trick = #{get_item_trick}"
    respond "stealth_get_item_trick = #{stealth_get_item_trick}"
    respond "hide_before_trick = #{hide_before_trick}"
  end
  echo checkrt if checkrt > 0 && debug
  if teaching 
    if task =~ /dagger/i
      get_weapon.call
    else stow.call
    end
    if task =~ /stealth/i
      if task =~ /stand/i
        respond "checking if my_partner #{my_partner} is here and kneeling" if debug
        if GameObj.pcs.find { |pc| pc.name =~ /#{my_partner}/i and pc.status =~ /kneel/ }.nil? == false
          respond "waiting to find kneeling my_partner #{my_partner}" if debug
          wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{my_partner}/i and pc.status =~ /kneel/ } }
        end
      elsif task =~/get/i 
        waitfor "#{my_partner} drops"
      else
        respond "getting stuck here?" if debug
        wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{my_partner}/i and pc.status.nil? } }
        respond "nope" if debug
      end
    end
    stand.call
  else #not teaching
    #use shadow mastery for stealth speed rounds
    if calling_proc =~ /speed/i
      Spell[9603].cast if Spell[9603].known? && (Spell[9604].active? == false) && (Spell[9603].active? == false) && Spell[9603].affordable? && stealth_gambit 
    end
    #vanish puts items in your container, so get the item first
    #fput "get #{stealth_get_item} from my #{stealth_get_item_container}" if gam =~ /^vanish/i && (GameObj.left_hand.name =~ /#{stealth_get_item}/i || GameObj.right_hand.name =~ /#{stealth_get_item}/i )
    get_stealth_item.call if gam =~ /^vanish/i
    #get gets the item, so put it away first
    #fput "put #{stealth_get_item} in my #{stealth_get_item_container}" if get_item_trick  && (GameObj.left_hand.name =~ /#{stealth_get_item}/i || GameObj.right_hand.name =~ /#{stealth_get_item}/i ) 
    stow_stealth_item.call if get_item_trick 
    stow.call if gam =~ /get/
    #get your dagger for dagger tricks
    if gam =~ /dagger/i
      fput "stow left"  if checkleft  && GameObj.left_hand.name !~ /#{weapon}/i
      fput "stow right" if checkright && GameObj.right_hand.name !~ /#{weapon}/i 
      get_weapon.call
    end
    #get your dagger for display tricks if not teaching
    get_weapon.call if gam =~ /display/i && !teaching
    #get your stealth item for stealth get if it's not on the floor or in your hands already
    #drop your stealth item for stealth get if it's not on the floor already
    #unhide if not stealth gambits
    unhide.call if !stealth_gambit || stealth_get_item_trick || learning; 
    
    drop_stealth_item.call if gam =~/stealth get/i && !teaching
    
    kneel.call if gam =~ /stealth stand/i #kneel if stealth stand
    stand.call if gam !~ /stealth stand/i #stand if not stealth_stand
    
    #hide for stealth gambits if not learning (wait until being taught if learning)
    hide.call if stealth_gambit && !learning && !teaching;
    #get master name for person lessons
    if calling_proc =~ /master/i
      (master_name = GameObj.npcs[-1].noun;) 
      gam = gam.sub("person",master_name) if gam =~/person/i
    end
    #if person gambit, go to audience room for reps other than master
    if gam =~ /person/i && calling_proc !~ /master/i && !learning
        target_room = Room.current.find_nearest(audience_rooms)
        start_script 'go2', [ target_room.to_s ] if gam !~ /dagger game/i
        wait_while{ running?('go2') }
        gam = gam.sub("person",GameObj.pcs[-1].noun)
    end
    #rgam #{gam =~ /person/i ? gam.gsub("person",GameObj.pcs[-1].noun) : gam}


    end #end if teaching...else...
    current_proc = calling_proc
    respond "+------------------------------- proc_return: #{calling_proc}" if debug
}
after_gambit = proc {
  stow.call
  unhide.call if stealth_gambit
}

if Char.prof != "Rogue"
  echo  "This script only works for rogues."
  #exit
end
stow.call

(setup.call;exit) if script.vars[1] == "setup"
if (CharSettings['setup_has_been_run'] == nil || UserVars.rogue.nil?) and (script.vars[1] != 'setup')
  #echo "Setup is required, type ;xrogue setup and fill in all settings."
  #exit
end
no_whisper_wait = true if script.vars[0] =~ /--no_wait/i 
if script.vars[1] == nil
  help_txt = %{
  ;xrogue cheap for solo cheap shot tasks. 
    ;xrogue cheap <partnername> for partner tasks.
  ;xrogue gam   for solo gambit tasks.     
    ;xrogue gam <partnername>   for partner tasks.
  ;xrogue lmas  for lockmastery tasks.      Doesn't do all lockmastery tasks.
  ;xrogue sweep for solo sweep tasks.      
    ;xrogue sweep <partnername> for partner tasks.
  ;xrogue sub   for solo subdue tasks.
  ;xrogue stun  for stun maneuvers tasks.   some are not implemented and some have bugs. Let me know about bugs or if you want to help test.
    - for stun, this script expects you to have a stunning skull

  ;xrogue <cheap, gam, lmas, stun, sub, or sweep> will also turn in completed tasks to the NPC.
  ;xrogue cal             to calibrate your calipers.
  ;xrogue wedge <number>  to create specified number of wedges.

  Note: do not type GLD while script is running, it could make the script stop working.

  Remember afk scripting is a no no in prime/platinum so pay attention to your game screen while running this script.
  Kill this script if going afk.
  
  To assist in partner tasks, run ;xtask and have ;xrogue_teach downloaded
  }
  respond help_txt
  exit
elsif script.vars[2] == "help"
  multifput "gld stance off", "stance off"
  if script.vars[1] == "sweep"
    help_sweep_partner_start.call
  elsif script.vars[1] == "cheap"
    help_cheap_partner_start.call
  end
elsif script.vars[2] == "teach"
  gam_teach_help_start.call
elsif script.vars[2] == "learn"
  gam_learn_help_start.call
elsif script.vars[1] == "def"
  (multifput "gld stance def", "stance off";exit)
elsif script.vars[1] =~ /^cali?b?r?a?t?e?/
  cal.call
elsif script.vars[1] =~ /wedge|carve/
  carve_go.call
elsif script.vars[1] == "repair"
  repair.call
elsif script.vars[1] == "checkin"
  checkin.call
elsif script.vars[1] == "test"
  windows_get_rag.call if script.vars[2..-1] =~ /window/i
  test_gam = $1 if script.vars[0] =~ /;(.*)/
  gam = test_gam if test_gam;
  respond "test_gam: #{test_gam}"  
  latest_gambit.call if script.vars[0] =~ /gam/i;
  gam_speed_begin.call if script.vars[0] =~ /gam speed;/i
  gam_audience_begin.call if script.vars[0] =~ /gam audience;/i
  gam_learn_help_begin.call if script.vars[0] =~ /gam learn help;/i
  gam_learn_begin.call if script.vars[0] =~ /gam learn;/i
  gam_teach_help_begin.call if script.vars[0] =~ /gam teach help;/i
  gam_teach_begin.call if script.vars[0] =~ /gam teach;/i
else
  go_to_task.call
end

before_dying { DownstreamHook.remove('xrogue_squelch'); }

=begin 
[xrogue_teach]>Rgam teach Thyfaiin cartwheel backward
Thyfaiin cartwheels backward and lands back on his feet with a grin.
As Thyfaiin watches you closely, you carefully lean to one side, twisting your upper body to place one hand on the ground, then slowly bringing your legs up over your head and turning at the waist to plant them easily on the ground.
Roundtime: 18 sec.
=end