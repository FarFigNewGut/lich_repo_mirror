=begin
  Cross-character searching & tracking of characters, items, inventory, lockers, banks, tickets, 
  lumnis, resource, private property inventory, and more.

  If you have questions or need help, message me on lnet or discord.

  Thank you to those who help test and provide feedback:
    Soliere, Tawariell, Dirvy, Rovvigen, Veni, Selema, Shaelethe and more.

  Thank you to those on discord that help answer questions:
    Luxelle, Ondreian, LostRanger, Tillmen, Tysong, Rinualdo, and many others.

  This does not use hooks or watch your actions to update.

  To update the database, run ;inv, and/or add it to autostart, etc.

  Special thanks to Tysong for permission to include the bonus from ;resource

  Special thanks to LostRanger for permission for loglore, inspect, jarserve, and more.

          author: Xanlin (also Xanlin on discord)
            game: GS
            tags: inventory, utility, database
  requires_trust: true
        required: Lich >= 4.6.4
         version: 20251104
  sqlite_version: 3.8.3+
  +---------------------------------------------------------------+
  ;invdb help      > help text
  ;invdb menu      > basic starter menu
  ;invdb examples  > examples
  ;invdb changelog > changelog
=end
module Inv_db;
  @version = '20250606.1'
  start_time = Time.now;
  # skip test server
  # (respond "#{Script.current.name}: skipping test server"; exit;) if XMLData.game == 'GST' and (Script.current.vars[0] !~ /^[qcs]/ or Script.current.vars.size == 0);
  #------------------------------------------------------------------------------#
  # requires trust on Ruby < 2.5
  #------------------------------------------------------------------------------#
  if Gem::Version.new(RUBY_VERSION) < Gem::Version.new('2.5.0') and $SAFE != 0;
    _respond "
    #{$clean_lich_char}#{Script.current.name} requires trust to create and use a database file, to write files for export.\n
    <d cmd=\"#{$clean_lich_char}trust #{Script.current.name}\">#{$clean_lich_char}trust #{Script.current.name}</d>\n\n";
    exit;
  end;
  require 'ostruct'
  #------------------------------------------------------------------------------#
  # settings
  #------------------------------------------------------------------------------#
  # TODO: add character level settings to override globals
  default_settings = {
    # 'autofit'               => { :type => "boolean", :default_value => true,       :internal => false, :description => "table output will autofit columns" },
    'confirm_large_output'  => { :type => "integer", :default_value => 100,        :internal => false, :description => "require unpause script when number of rows to output is greater than this number" },
    'hide_legend'           => { :type => "boolean", :default_value => false,      :internal => false, :description => "when true, hides the list of abbrevation descriptions at the beginning of search results" },
    'jar'                   => { :type => "boolean", :default_value => true,       :internal => false, :description => "check contents of jars" },
    'stack'                 => { :type => "boolean", :default_value => false,      :internal => false, :description => "check number of stacked notes" },
    'silence_stack'         => { :type => "boolean", :default_value => true,       :internal => false, :description => "silences lines from checking jars, notes, etc." },
    'use_old_quiet_command' => { :type => "boolean", :default_value => false,      :internal => true, :description => "fallback to old quiet command for scanning issue, created for an isolated case that was repeatable for a single user." },
    'container_noopen'      => { :type => "Array",   :default_value => ['locket'], :internal => false, :description => "names or nouns of containers not to try to open." },
    'open_containers'       => { :type => "boolean", :default_value => true,       :internal => false, :description => "opens and closes containers for inventory check" },
    'boh'                   => { :type => "Array",   :default_value => ['large treasure sack with a blood crystal clasp'], :internal => false, :description => "names of bags of holding." },
    'last_vacuum'           => { :type => "Time",    :default_value => Time.now,   :internal => true, :description => "internal tracking of the last sqlite vacuum operation." },
    'date_format'           => { :type => "string",  :default_value => "%m/%d/%y", :internal => false, :description => "date format, e.g. %m/%d/%y  or %Y-%m-%d" },
    'lumnis'                => { :type => "boolean", :default_value => true,       :internal => false, :description => "includes lumnis tracking in 'refresh all'" },
    'resource'              => { :type => "boolean", :default_value => true,       :internal => false, :description => "includes resource tracking in 'refresh all'" },
    'move_rooms'            => { :type => "boolean", :default_value => false,      :internal => false, :description => "move rooms when encountering the 'Too many windows' error" },
    #'account '              => { :type => "boolean", :default_value => false,      :internal => false, :description => "includes account level simucoin and premium point tracking in 'refresh all'" },
  };

  Settings.load
  @settings_hash = Settings.to_hash;
  def self.settings_hash;return @settings_hash;end
  ns = (default_settings.keys - @settings_hash.keys);
  if ns.size > 0
    ns.each { |s|
      Settings[s]       = default_settings[s][:default_value];
      @settings_hash[s] = default_settings[s][:default_value];
    };
  end;

  if Script.current.vars[0] =~ /^--settings/i
    row_format = "  %-20s | %-8s | %s"
    row_size   = (row_format % ["", "", ""]).size - 2
    row_size  += default_settings.values.map { |v| v[:description] if v[:internal] == false }.compact.max_by { |d| d.size if d }.length
    output = []
    output <<  "  #{Script.current.name} (version: #{@version}) settings:"
    output <<  "  #{"-" * row_size}"
    output << row_format % ["setting", "value", "description"]
    default_settings.each { |s, d|
      next if d[:internal] == true
      v = @settings_hash[s]
      if v.class != Array
        output << row_format % [s, v, d[:description]]
      end
    }
    output << "  #{"-" * 45}"
    default_settings.each { |s, d|
      v = @settings_hash[s]
      if v.class == Array
        output << "  %s: %s" % [s, d[:description]]
        v.each_with_index { |i, x|
          output << "    #{x + 1}. #{i}"
        }
        output << "           add to this list using: ;#{Script.current.name} +#{s} thing to add"
        output << "      remove from this list using: ;#{Script.current.name} -#{s} thing to remove"
      end
    }
    output << "  #{"-" * 45}"
    respond output
    exit
  end

  boolean_settings_pattern = /--(#{default_settings.each_with_object([]) { |k, a| a << k[0] if k[1][:type] == "boolean"; }.join('|')})(?: ?[=: ] ?)(\w+)/i
  if Script.current.vars[0] =~ boolean_settings_pattern;
    Script.current.vars[0].scan(boolean_settings_pattern).each { |n, v|
      setting_name = n.downcase
      setting_value_string = v
      if setting_value_string =~ /true|false|on|off/i
        setting_value = setting_value_string =~ /true|on/i ? true : false;
        if @settings_hash[setting_name] != setting_value
          Settings[setting_name] = setting_value;
          Settings.save;
          _respond "#{Script.current.name}: #{setting_name} is now #{setting_value.inspect}"
        else
          _respond "#{Script.current.name}: #{setting_name} was already set to #{setting_value.inspect}"
        end
      else
        _respond "#{Script.current.name}: unknown value '#{setting_value_string}' for #{setting_name}. Try true, false, on, or off.";
      end;
    }
    exit;
  end

  string_settings_pattern = /--(#{default_settings.each_with_object([]) { |k, a| a << k[0] if k[1][:type] == "string"; }.join('|')})(?: ?[=: ] ?)(.*?)(?:$| +--)/i
  if Script.current.vars[0] =~ string_settings_pattern;
    Script.current.vars[0].scan(string_settings_pattern).each { |n, v|
      setting_name = n.downcase
      setting_value_string = v
      if setting_value_string.length > 0
        setting_value = setting_value_string
        if @settings_hash[setting_name] != setting_value
          Settings[setting_name] = setting_value;
          Settings.save;
          _respond "#{Script.current.name}: #{setting_name} is now #{setting_value.inspect}"
        else
          _respond "#{Script.current.name}: #{setting_name} was already set to #{setting_value.inspect}"
        end
      else
        _respond "#{Script.current.name}: unknown value '#{setting_value_string}' for #{setting_name}.";
      end;
    }
    exit;
  end

  if @settings_hash["confirm_large_output"].class.to_s =~ /True|False/i
    @settings_hash["confirm_large_output"] = @settings_hash["confirm_large_output"] ? 100 : 99999
  end
  
  integer_settings_pattern = /--(#{default_settings.each_with_object([]) { |k, a| a << k[0] if k[1][:type] == "string"; }.join('|')})(?: ?[=: ] ?)(.*?)(?:$| +--)/i
  if Script.current.vars[0] =~ string_settings_pattern;
    Script.current.vars[0].scan(string_settings_pattern).each { |n, v|
      setting_name = n.downcase
      setting_value = v.to_i
      if @settings_hash[setting_name] != setting_value
        Settings[setting_name] = setting_value;
        Settings.save;
        _respond "#{Script.current.name}: #{setting_name} is now #{setting_value.inspect}"
      else
        _respond "#{Script.current.name}: #{setting_name} was already set to #{setting_value.inspect}"
      end
    }
    exit;
  end
  
  array_settings_list = default_settings.each_with_object([]) { |k, a| a << k[0] if k[1][:type] == "Array"; }.join('|')
  if Script.current.vars[0] =~ /([\+-])+(#{array_settings_list})(.*)/;
    prefix = $1
    setting_name = $2
    entries = $3.split(/(?:\s*[,;|]\s*)+/);
    if entries.length > 0;
      if prefix == "+"
        entries.each { |c|;
          next if c.strip.length == 0;
          if !@settings_hash[setting_name].include?(c.strip);
            Settings[setting_name].push(c.strip);
            Settings.save;
            _respond "#{Script.current.name}: #{c.strip.inspect} added to the #{setting_name} list";
          else;
            _respond "#{Script.current.name}: #{c.strip.inspect} is already on the #{setting_name} list";
          end;
        };
      elsif prefix == "-"
        entries.each { |c|;
          next if c.strip.length == 0;
          if @settings_hash[setting_name].include?(c.strip);
            Settings[setting_name].delete(c.strip);
            Settings.save;
            _respond "#{Script.current.name}: #{c.strip.inspect} removed from the #{setting_name} list";
          else
            _respond "#{Script.current.name}: #{c.strip.inspect} is not on the #{setting_name} list";
          end;
        };
      end
    end;
    exit;
  end;

  if Script.current.vars[0] =~ /--noopen(.*)/;
    noopen = $1.split(/(?:\s*[,;|]\s*)+/);
    if noopen.length > 0;
      noopen.each { |c|;
        next if c.strip.length == 0;
        if !@settings_hash["container_noopen"].include?(c.strip);
          Settings["container_noopen"].push(c.strip);
          Settings.save;
          _respond "#{Script.current.name}: #{c.strip} added to the noopen list";
        else;
          _respond "#{Script.current.name}: #{c.strip} is already on the noopen list";
        end;
      };
    else
      _respond "#{Script.current.name}: noopen list:";
      Settings["container_noopen"].each_with_index { |c, i|;
        _respond "#{i + 1}: #{c}";
      };
    end;
    exit;
  end;

  if Script.current.vars[0] =~ /--open (.+)/;
    noopen = $1.split(/(?:\s*[,;|]\s*)+/);
    if noopen.length > 0;
      noopen.each { |c|;
        next if c.strip.length == 0;
        if @settings_hash["container_noopen"].include?(c.strip);
          Settings["container_noopen"].delete(c.strip);
          Settings.save;
          _respond "#{Script.current.name}: #{c.strip} removed from the noopen list";
        else
          _respond "#{Script.current.name}: #{c.strip} is not on the noopen list";
        end;
      };
    end;
    exit;
  end;

  #------------------------------------------------------------------------------#
  # basic db methods
  #------------------------------------------------------------------------------#
  @db_name = "inv.db3"
  @db_name = "invdb-test.db3" if Script.current.name=~ /invdb-(test_|beta)/

  def self.copy_existing_for_beta()
    default = "#{$lich_dir}data/inv.db3"
    beta    = "#{$lich_dir}data/invdb-test.db3"
    return if !File.exist?(default)
    return if File.exist?(beta)
    require 'fileutils'
    respond "Copying existing database for beta testing."
    FileUtils.copy_file(default,beta)
  end
  
  def self.open(db_name = nil);
    db_name = @db_name if db_name.nil?
    require 'sqlite3';
    self.copy_existing_for_beta if Script.current.name=~ /invdb-(test_|beta)/
    db = SQLite3::Database.open "#{$lich_dir}data/#{db_name}";
    db.execute('PRAGMA temp_store = MEMORY');
    db.create_function('regexp', 2) do |func, pattern, expression|
      regexp = Regexp.new(pattern.to_s, Regexp::IGNORECASE)
      if expression.to_s.match(regexp)
        func.result = 1
      else
        func.result = 0
      end
    end
    before_dying { db.close if db and !db.closed? }
    return db;
  end;

  def self.sqlite_version;
    require 'sqlite3';
    db = Inv_db.open;
    sqlite_version = db.get_first_value('select sqlite_version()');
    db.close;
    return sqlite_version;
  end;

  def self.pass_thru(sql, qargs = {}, db = nil, quiet = true);
    close_db = false
    (close_db = true; db = Inv_db.open) if db.nil?
    changes = nil
    rows = []
    begin
      if qargs.empty?
        rows = db.execute2(sql)
      else
        rows = db.execute2(sql, qargs)
      end
      passthru_changes = db.changes;
      respond "rows returned: #{rows.length}; changes: #{passthru_changes}" if !quiet
    rescue SQLite3::BusyException
      sleep 0.1
      retry
    rescue SQLite3::Exception => e
      # Inv_db.gs_print "Exception occured. Please contact Xanlin on discord with error details."
      Inv_db.gs_print "Exception: #{e}"
      Inv_db.gs_print "Version: #{@version}"
      Inv_db.gs_print "sql: #{sql}" if e.to_s =~ /syntax error|no such column/
      Inv_db.gs_print "qargs:#{qargs.inspect}" if e.to_s =~ /syntax error/
    ensure
      db.close if close_db;
    end
    exit if e
    return rows, changes
  end;

  def self.execute(sql, hash_args = {}, db = nil)
    close_db = false; changes = 0;
    (close_db = true; db = Inv_db.open) if db.nil?
    respond sql if @debug_sql
    respond "hash_args:#{hash_args.inspect}" if @debug_sql
    begin
      rows = db.execute(sql, hash_args)
      changes = db.changes
    rescue SQLite3::BusyException
      sleep 0.1
      retry
    rescue SQLite3::Exception => e
      Inv_db.gs_print("Exception occured.  Please contact #{self.format_monsterbold("Xanlin")} on discord with error details.")
      respond "Exception: #{e}"
      respond "Version: #{@version}"
      respond sql if e.to_s =~ /syntax error|no such|constraint/
      respond "hash_args:#{hash_args.inspect}" if e.to_s =~ /syntax error|no such bind|UNIQUE|NOT NULL/
      if e.to_s =~ /no such bind/
        missing_bindings = []
        hash_args.keys.each { |k| missing_bindings << k if sql !~ /:#{k}/ }
        respond "missing_bindings: #{missing_bindings.inspect}"
      end
      db.close
      exit
    ensure
      db.close if close_db
    end
    return rows.map(&:dup), changes
  end

  def self.execute2(sql, hash_args = {}, db = nil)
    close_db = false;
    (close_db = true; db = Inv_db.open) if db.nil?
    begin
      respond sql if @debug_sql
      respond "hash_args:#{hash_args.inspect}" if @debug_sql
      rows = db.execute2(sql, hash_args)
    rescue SQLite3::BusyException
      sleep 0.1
      retry
    rescue SQLite3::Exception => e
      Inv_db.gs_print "Exception occured.  Please contact #{self.format_monsterbold("Xanlin")} on discord with error details."
      respond "Exception: #{e}"
      respond "Version: #{@version}"
      respond sql if e.to_s =~ /syntax error|no such|constraint/
      respond "hash_args:#{hash_args.inspect}" if e.to_s =~ /syntax error|no such bind|UNIQUE/
      if e.to_s =~ /no such bind/
        missing_bindings = []
        hash_args.keys.each { |k| missing_bindings << k if sql !~ /:#{k}/ }
        respond "missing_bindings: #{missing_bindings.inspect}"
      end
      db.close
      exit
    ensure
      db.close if close_db
    end
    return rows.map(&:dup)
  end

  def self.fix_enc(db)
    close_db = false; changes = 0;
    (close_db = true; db = Inv_db.open) if db.nil?
    tbl_list = db.execute("select distinct tbl_name from sqlite_master where tbl_name not like 'sqlite%'").flatten;
    col_list = []; update = []; unique_update = [];
    tbl_list.each { |t| db.execute("pragma table_info('#{t}')").each { |r| col_list += [[t, r[1], r[2]]] } }
    unique_list = []
    tbl_list.each { |tbl_name|
      db.execute("PRAGMA index_list('#{tbl_name}')").each { |_seq, ix_name, unique, _origin, _partial|
        next if unique == 0
        db.execute("PRAGMA index_info('#{ix_name}')").each { |_seq, _cid, name|
          unique_list << [tbl_name, name]
        }
      }
    }
    col_list.each { |t, c, y|
      if y == 'text'
        rows = db.execute("select distinct #{c} from #{t}").flatten
        rows.each { |r|
          next if r.encoding.to_s == 'UTF-8'
          if unique_list.find { |tbl, col| tbl == t and col == c }.nil?
            update << [t, c, r]
          else
            unique_update << [t, c, r]
          end
        }
      end
    }
    Inv_db.gs_print("update.size:#{update.size}")
    self.array_print(update)
    Inv_db.gs_print("unique_update.size:#{unique_update.size}")
    self.array_print(unique_update)
    changes = Hash.new(0); unique_changes = Hash.new(0);

    update.each { |t, c, v|
      k = "#{t}_#{c}"
      sql = "update #{t} set #{c} = :utf8 where #{c} = :value"
      qargs = { :value => v, :utf8 => v.encode('UTF-8') }
      _r, g = self.execute(sql, qargs, db)
      changes[k] += g
    }
    Inv_db.gs_print("changes:")
    self.hash_print(changes)

    unique_update.each { |t, c, v|
      k = "#{t}_#{c}"
      sql = "select #{c} from #{t} where #{c} = :utf8 limit 1"
      r, _g = self.execute(sql, { :utf8 => v.encode('UTF-8') }, db)
      if r.size > 0
        echo "deleting from #{t} where #{c} = #{v.inspect} -- in conflict with utf conversion"
        sql = "delete from #{t} where #{c} = :value"
        _r, g = self.execute(sql, { :value => v }, db)
        unique_changes[k] += g
      elsif r.size == 0
        sql = "update #{t} set #{c} = :utf8 where #{c} = :value"
        _r, g = self.execute(sql, { :value => v, :utf8 => v.encode('UTF-8') }, db)
        unique_changes[k] += g
      end
    }
    Inv_db.gs_print("unique_changes:")
    self.hash_print(unique_changes)

    db.close if close_db and !db.closed?
  end
  #------------------------------------------------------------------------------#
  # instance variables - newbie debugging
  #------------------------------------------------------------------------------#
  @debug                 = false;
  @debug_sql             = false;
  @debug_hook            = false;
  @debug_input           = false;
  @debug_print           = false;
  @debug_traverse        = false;
  @benchmark             = false;
  @no_squelch            = false;
  @show_commands         = false;
  @quiet                 = true;
  @use_old_quiet_command = @settings_hash["use_old_quiet_command"]
  @slower                = ($frontend =~ /wizard|avalon/ ? true : false)
  @empty_string          = "".encode("UTF-8")
  @calling_proc          = nil;
  @current_proc          = nil;
  #------------------------------------------------------------------------------#
  # helpers
  #------------------------------------------------------------------------------#
  def self.db_timestamp_integer(); return Time.now.to_i; end
  def self.int_to_comma(var) return (var.is_a? Integer) ? var.to_s.reverse.scan(/(?:\d*\.)?\d{1,3}-?/).join(',').reverse.to_s : var; end;
  def self.int_to_time(var) return (var.is_a? Integer) ? Time.at(var.to_i).strftime("%Y-%m-%d %H:%M") : var; end;
  def self.int_to_ustime(var) return (var.is_a? Integer) ? Time.at(var.to_i).strftime("%x %I:%M%p") : var; end;
  def self.int_to_usdate(var) return (var.is_a? Integer) ? Time.at(var.to_i).strftime("%x") : var; end;

  def self.int_to_date(var, style = nil);
    style = "%x" if style.nil?;
    return (var.is_a? Integer) ? Time.at(var.to_i).strftime(style) : var;
  end;

  @mono_start = %{<output class="mono" />}; @mono_end = %{<output class="" />};
  def self.format_mono(msg) return "<output class=\"mono\" />\n#{msg}\n<output class=\"\" />"; end;

  @monsterbold_start = $fake_stormfront ? "\034GSL\r\n " : "<pushBold\/>";
  @monsterbold_end   = $fake_stormfront ? "\034GSM\r\n " : "<popBold\/>";
  def self.format_monsterbold(msg); return "#{@monsterbold_start}#{msg}#{@monsterbold_end}"; end;
  def self.format_whisper(msg); return "<preset id=\"whisper\">#{msg}</preset>"; end;
  
  def self.xml_encode(msg);return msg.encode(:xml => :text);end;
  def self.format_preset(msg,preset="speech");echo "preset #{preset} not found" if !["link", "speech","thought","whisper","watching","command", "selectedLink", "watching", "roomName"].include?(preset);return "<preset id=\"#{preset}\">#{self.xml_encode(msg)}</preset>";end;
  
  def self.gs_print(msg)
    if $frontend =~ /stormfront|wrayth/i
      puts msg # _respond will go to output, puts doesn't, reduces ;log of output
    elsif $frontend =~ /profanity/i
      _respond msg
    elsif $frontend =~ /wizard|avalon/i
      respond sf_to_wiz(msg)
    else
      _respond msg
    end
  end
  #------------------------------------------------------------------------------#
  # item scraping helpers
  #------------------------------------------------------------------------------#
  @deplural = {
    "blades" => "blade", "branches" => "branch", "cabochons" => "cabochon",
    "essences" => "essence", "fans" => "fan", "globes" => "globe", "motes" => "mote",
    "pieces" => "piece", "rose gold fire" => "rose-gold fire", "shards" => "shard",
    "slices" => "slice", "teeth" => "tooth",
  }

  def self.deplural(str)
    str = str.strip =~ /^(containing )?(.*?)(ies|(?<=onyx)es|(?<=z)es|(?<!mos|glas)s)?$/ ? "#{$2}#{$3 == 'ies' ? 'y' : ''}" : str;
    return str.gsub(/\b(#{@deplural.keys.join("|")})\b/, @deplural).encode('UTF-8');
  end

  def self.get_item_type(name, noun = nil)
    return (GameObj.type_cache[name].sub(/^uncommon,|,uncommon/, '') || '').encode('UTF-8') if defined?(GameObj.type_cache) and GameObj.type_cache.key?(name)
    return GameObj.new(0, noun, name).type.sub(/^uncommon,|,uncommon/, '').encode('UTF-8') if !noun.nil? and noun != ''
    noun = Inv_db.noun_test(name)
    list = GameObj.type_data.keys.find_all { |t|
      (name =~ GameObj.type_data[t][:name] or noun =~ GameObj.type_data[t][:noun]) and (GameObj.type_data[t][:exclude].nil? or name !~ GameObj.type_data[t][:exclude])
    }
    return "unknown".encode('UTF-8') if list.nil? or list.empty?
    return list.join(',').sub(/^uncommon,|,uncommon/, '').encode('UTF-8')
  end

  #------------------------------------------------------------------------------#
  # for a strange new issue for one user, including option to use old quiet_command
  #------------------------------------------------------------------------------#
  def self.old_quiet_command(command, start_pattern, end_pattern = /<prompt/, include_end = true, timeout = 5)
    hook = self.mask_output(start_pattern, end_pattern, include_end)
    xml = dothistimeout(command, timeout, start_pattern)
    unless xml
      DownstreamHook.remove(hook)
      return nil
    end
    result = [xml]
    while true
      xml = get
      if xml =~ end_pattern
        result << xml if include_end
        return result
      end
      result << xml
    end
  end

  def self.mask_output(start_pattern, end_pattern = /<prompt/, include_end = true)
    filter = false
    name = self.anon_hook
    DownstreamHook.add(name, proc { |xml|
      if filter
        if xml =~ end_pattern
          DownstreamHook.remove(name)
          filter = false
          next(include_end ? nil : xml)
        else
          next(nil)
        end
      elsif xml =~ start_pattern
        filter = true
        next(nil)
      else
        xml
      end
    })
    return name
  end
  #------------------------------------------------------------------------------#
  # @stack_type pattern should capture id, amount, optionally stack status (empty/partial/full)
  @stack_type = Hash.new
  @stack_type["jar"]    = { :command => "look in", :pattern => /Inside the <a exist="(?<id>\d+)" noun=".*?">.*?<\/a> you see (?<amount>\d+) portions? of .*?\.  It is (?<stack_status>.*?)\./ }
  # measuring bundles currently breaks hiding
  @stack_type["bundle"] = { :command => "measure", :pattern => /You glance through your bundle and count a total of (?<amount>\d+) <a exist="(?<id>\d+).*/ }
  @stack_type["stack"]  = { :command => "read", :pattern => /This <a exist="(?<id>\d+)" noun=".*?">.*?<\/a> has (?<amount>[\d,]+) uses?./ }
  @stack_type["pack"]   = { :command => "read", :pattern => /This <a exist="(?<id>\d+)" noun=".*?">.*?pack<\/a> entitles the presenter to (?<amount>\d+).*$/ }

  def self.peek_stack(id, path, stack_type = "jar")
    stack_amount = 0
    stack_status = @empty_string
    stack_status = "empty".encode('UTF-8') if stack_type == "jar"

    s = @stack_type[stack_type]
    return false if s[:command].nil?;

    command = "#{s[:command]} ##{id} #{path}"
    respond command if @debug
    start_pattern = /In the Common language, it reads:|^(?:The|This|Inside the|Your|There is.*?) <a exist=\"#{id}"|A quick peek|Constructed of.*?#{id}|You see nothing unusual|There is nothing|Try holding it first/
    quiet         = @settings_hash['silence_stack']
    end_pattern   = /^<output class=""\/>|(<popBold\/>)?<prompt/;
    timeout       = 5;
    peek_result   = self.client_command(command, start_pattern, end_pattern, quiet, timeout).join("\n")
    _respond "peek_result:#{peek_result.inspect}" if @debug
    return nil, nil if peek_result =~ /You see nothing unusual/
    m = s[:pattern].match(peek_result)
    if m
      # stack_id     = m[:id] if m[:id]
      stack_amount = m[:amount].to_i if m[:amount]
      stack_status = m[:stack_status].encode('UTF-8') if s[:pattern].to_s =~ /status/ and m[:stack_status]
    end
    return stack_amount, stack_status
  end

  def self.noun_type_check(str, _debug = nil); # TODO: remove after schema refactor
    sql = "
    select noun, type
    from item o
    where o.name = '#{str.strip.gsub("'", "''")}'
    limit 1"
    rows = Inv_db.execute2(sql)
    noun = rows[1][0]
    type = rows[1][1]
    return noun, type
  end;

  def self.noun_test(str, debug = nil);
    noun = nil;
    if str.length > 35
      respond "  pattern_long" if debug
      # pattern_long = /^(?:pair of)?([\w'\- ]{5})?.*? (?<noun>[^ \n]+(?<! of| and)(?! reed| casting))(?<post>(?: drawn by| of| set withi?n?| in| that| \(.*| [^ \n-]*?(?:ed with|-laced|ed|(?<!fletch|hunt|sl|drawstr|climb|smudg|fish)ing|[io]n an?|bound|held|hung|strung|strewn|caught|fraught|inset|inlaid|split|side-secured|aglisten|swept|woven|with ?a?n?|shot through)))(?: .*?)?$/;
      pattern_long = /^(?:pair of)?(?:[\w'\- ]{5})?.*? ([^ \n]+(?<! of| and)(?! reed| casting))((?: drawn by| of| set withi?n?| in| that| \(.*| [^ \n-]*?(?:ed (?:with|by)|-laced|ed|(?<!fletch|hunt|sl|drawstr|climb|smudg|fish)ing|[io]n an?|bound|held|hung|strung|strewn|caught|fraught|inset|inlaid|split|side-secured|aglisten|swept|woven|with ?a?n?|shot through|dripping|sporting)))(?: .*?)?$/;
      # respond pattern_long.match(str).inspect if @debug
      noun = str.scan(pattern_long).flatten[0];
      noun = nil if noun == '';
      if noun.nil?;
        pattern_medium = /^.*?(Hammer of Kai)$|^(?:[^ ]+[ \b])*([^ \b]*?)[ \b](?:with|an?|[io]n)[ \b]/;
        noun = str.scan(pattern_medium).flatten.join('');
      end;
    else
      respond "  pattern_short" if debug
      pattern_short = /^.*?(Hammer of Kai)$|^(?:.*?) ([^\s]+)$|^([^ ]+)$/;
      noun = str.strip.scan(pattern_short).flatten.join('');
      noun = "lapis" if str =~ /lapis lazuli$/;
    end
    noun = nil if noun == '';
    if noun.nil?;
      noun = str.split(' ')[-1];
    end;
    respond "  '#{str}' => noun:#{noun.inspect}" if debug;
    noun = noun =~ /lazuli/ ? "lapis" : noun;
    return noun;
  end;

  def self.peek_boh(id, location_id, level, path, id_path, boh_noun, verb = 'look in');
    command = "#{verb} ##{id} #{id_path}";
    respond command if @debug;
    start_pattern = Regexp.union(
      %r[This <a exist=\"#{id}" noun="[^"]*?">[^<]*?<\/a> has multiple pockets],
      %r[^Fashioned (?:from|of)],
      %r[^Crafted from],
      %r[^(?:<popBold\/>)?\d+\. +(?:an? )?(?<name>.*?)],
      %r[^There is nothing in there\.],
      %r[^You realize],
      %r[^Sifting through],
      %r[^Glancing over your],
    )
    end_pattern   = /^(?:<popBold\/>)?<prompt/;
    peek_result   = self.client_command(command, start_pattern, end_pattern);
    _respond "<popBold\/>" if peek_result.last =~ /popBold/
    respond "#{peek_result.join("\n")}" if @debug
    boh_general_pattern = %r[^(?:<popBold\/>)?\d+\. +(?:an? )?(?<name>.*?)(?:<pushBold/>)? \((?<amount>\d+|unlimited)(?<extra>.*?)$]
    oremonger_pattern = %r[^\d+\.(?<extra> +)(?<amount>\d+|unlimited) pieces? of (?<name>.*?)$]

    boh_items = [];
    if path.nil? or path == "";
      path = boh_noun;
    else
      path = "#{path} > #{boh_noun}";
    end;
    intro = peek_result[0]
    if intro =~ /ores you have stored/
      boh_item_pattern = oremonger_pattern
    else
      boh_item_pattern = boh_general_pattern
    end
    peek_result.each { |r|
      if (m = boh_item_pattern.match(r));
        name = m[:name].strip;
        noun, type = Inv_db.noun_type_check(name);
        noun      = Inv_db.noun_test(name) if noun.nil?;
        type      = Inv_db.get_item_type(name, noun) if type.nil?;
        type      = 'unknown' if type.nil?;
        if m[:extra] =~ /(fishing \w*)/
          type = $1.sub(/s$/, '')
        elsif m[:extra] =~ /specimen/
          type = 'specimen'
        elsif intro =~ /gemstones/
          type = 'gemstone'
        elsif intro =~/ores you have stored/
          type = 'ore'
        end
        amount = nil
        if m[:amount] =~ /doses/
          amount = 1
        else
          amount = m[:amount].to_i
        end
        boh_items << {
          :id           => nil,
          :location_id  => location_id.to_i,
          :level        => level + 1,
          :path         => path.encode('UTF-8'),
          :type         => type.encode('UTF-8'),
          :name         => name.encode('UTF-8'),
          :noun         => noun.encode('UTF-8'),
          :amount       => amount,
          :stack        => 'boh'.encode('UTF-8'),
          :stack_status => '',
          :marked       => '',
          :registered   => '',
          :hidden       => '',
          :link_name    => '',
          :containing   => '',
          :update_noun  => 0
        };
      end;
    };
    return boh_items;
  end;
  #------------------------------------------------------------------------------#
  # Inv_db.traverse_container
  #------------------------------------------------------------------------------#
  @sorted_view_saved = nil
  @sorted_view_status = nil
  def self.match_to_hash(match)
    (respond "#{match.inspect} is not match data"; return nil) unless match.class == MatchData;
    hash = Hash[match.names.map(&:to_sym).zip(match.captures.map(&:strip))]
    return hash;
  end

  @view_patterns = {
    :start                => /^<exposeContainer id='[^']+'|<container/,
    :adjective_noun       => /noun="(?<noun>[^"]+)">(?<adjective_noun>[^<]*?)<\/a>:$/,
    :closed               => /^That is closed./,
    :empty_sorted         => /There is nothing.*?<a exist="(?<id>-?\d+)"/,
    :empty_not_sorted     => /^There is nothing [^\d]+\./,
    :category             => /^<pushBold\/>(?<category>.*?) \[(?<category_amount>\d+)\]:<popBold\/>/,
    :category_item        => /(?<before_name>[^<]+)? ?<a exist="(?<id>-?\d+)" noun="(?<noun>[^"]*?)">(?<name>[^<]*?)<\/a>(?<after_name>[^\(\r\n]*)?(?: \((?<qty>\d+)\))?/,
    :total                => /^Total items: (?<total>\d+)/,
    :end                  => /^<prompt>/,
    :link_pattern         => /<a exist="(?<id>\-?\d+)" noun="(?<noun>[^"]+)">(?<name>[^<]+)<\/a>/,
    :split_inv            => /<\/inv>(?=(?:<inv[^>]+>)?(?:In|On|Under|Behind))/,
    :preposition_inv      => /<inv id='-?\d+'>(?<preposition>In|On|Under|Behind) .*? <a exist="(?<id>-?\d+)" noun="(?<noun>[^"]*?)">(?<name>[^<]*?)<\/a>:<\/inv>(?<contents>.*?)$/,
    :preposition_unsorted => /^(?<preposition>In|On|Under|Behind) .*? <a exist="(?<id>-?\d+)" noun="(?<noun>[^"]*?)">(?<name>[^<]*?)<\/a> you see (?<contents>.*?)$/,
    :preposition_sorted   => /(?<preposition>In|On|Under|Behind) [^<>]*? <a exist="(?<id>-?\d+)" noun="(?<noun>[^"]*?)">(?<name>[^<]*?)<\/a>:$/,
    :inv_item             => /<inv id='-?\d+'>(?<before_name>[^<]+)? ?<a exist="(?<id>-?\d+)" noun="(?<noun>[^"]*?)">(?<name>[^<]*?)<\/a>(?<after_name>[^\(\r\n<$]*)?/,
  }

  def self.sorted_view_status_update(status)
    @sorted_view_status = status
    # set saved status if not saved yet
    if @sorted_view_saved.nil?
      @sorted_view_saved = @sorted_view_status
      before_dying {
        Inv_db.client_command("flag sorted #{@sorted_view_saved}", /You will/) if @sorted_view_status != @sorted_view_saved
      }
    end
  end

  def self.object_contents(o, preposition, path = "", open_closed = true)
    preposition = preposition.downcase
    contents = []
    has_in = false
    has_on = false
    id, adjective, noun, item_categories, sorted_contents, sorted_lines = self.sorted_view(o, preposition, path, open_closed)
    # if preposition =~ /^(in|on)/
      # adjective, noun, item_categories, contents, sorted_lines = self.sorted_view(o, preposition, path, open_closed)
      # return adjective, noun, item_categories, contents if item_categories.empty?
      # only return preposition's contents
      # respond sorted_lines[0] if @debug
      sorted_lines[0].split(@view_patterns[:split_inv]).each { |s|
        if (m = @view_patterns[:preposition_inv].match(s))
          inv_preposition = m[:preposition].downcase
          has_in = true if inv_preposition == 'in'
          has_on = true if inv_preposition == 'on'
          next if inv_preposition != preposition
          items = m[:contents].split('</inv>')
          items.each { |item|
            if (i = @view_patterns[:inv_item].match(item))
              hash_item = self.match_to_hash(i)
              hash_item[:qty] = 1
              # respond hash_item
              contents << OpenStruct.new(hash_item)
            else
              respond "no match for #{item}" if @debug
            end
          }
          break
        end
      }
    if preposition =~ /behind|under/
      # adjective, noun, item_categories, sorted_contents, _sorted_lines = self.sorted_view(o, preposition, path, open_closed)
      if @sorted_view_status != 'off'
        Inv_db.client_command("flag sorted off", /You will/)
        self.sorted_view_status_update('off') 
      end
      unsorted_lines = Inv_db.object_look(o, preposition, path)
      unsorted_lines[0].split(@view_patterns[:split_inv]).each { |s|
        if (m = @view_patterns[:preposition_unsorted].match(s))
          m[:contents].scan(@view_patterns[:link_pattern]).each { |id, item_noun, name|
            before_name = sorted_contents.find { |i| i[:id] == id }[:before_name] || sorted_contents.find { |i| i[:name] == name }[:before_name] || ""
            after_name  = sorted_contents.find { |i| i[:id] == id }[:after_name]  || sorted_contents.find { |i| i[:name] == name }[:after_name]  || ""
            sorted_name = sorted_contents.find { |i| i[:id] == id }[:name]        || name
            contents << OpenStruct.new({ :before_name => before_name, :after_name => after_name, :id => id, :noun => item_noun, :name => sorted_name, :qty => 1 })
          }
          # respond s
        end
      }
      # respond unsorted_lines
    end
    @objects_looked += 1
    return id, adjective, noun, item_categories, contents, has_in, has_on
  end

  def self.sorted_view_parse(sorted_lines, preposition)
    id = nil
    adjective = nil;
    noun = nil;
    item_categories = Hash.new
    contents = []
    sorted_lines.each { |sorted_line|
      if (m = @view_patterns[:preposition_sorted].match(sorted_line))
        adjective = m[:name].split(' ').first if m[:name].split(' ').size > 1
        noun = m[:noun]
        id   = m[:id]
      elsif (c = @view_patterns[:category].match(sorted_line))
        category = c[:category]
        sorted_items = sorted_line.split(/(popBold\/> |, (?=[^,]*<a))/);
        sorted_items.each { |sorted_item|
          if (i = @view_patterns[:category_item].match(sorted_item))
            hash_obj = self.match_to_hash(i)
            hash_obj[:qty] = 1 if hash_obj[:qty] == ''
            contents << OpenStruct.new(hash_obj) if preposition !~ /^(?:in|on)/
            OpenStruct.new(self.match_to_hash(i))
            name = "#{i[:before_name] =~ /^(an |a |some )(.*)?/ ? $2 : i[:before_name]}#{i[:name] =~ /^(some )?(.*)/ ? $2 : i[:name]}#{i[:after_name] =~ /containing/ ? "" : i[:after_name]}".strip
            item_categories[name.encode('UTF-8')] = category.encode('UTF-8')
          end
        }
      end
    }
    return id, adjective, noun, item_categories, contents, sorted_lines
  end

  @too_many_windows = nil
  def self.sorted_view(o, preposition, path = "", open_closed = true)
    id = nil, adjective = nil; noun = nil; item_categories = {}; contents = [];
    if o.class != String
      id = o.id
      noun = o.noun
    end
    preposition = preposition.downcase
    sorted_lines = Inv_db.object_look(o, preposition, path)
    # too many windows
    if sorted_lines.first == "Too many container windows already open.  Unable to open more."
      if @too_many_windows == o or @settings_hash["move_rooms"] != true
        # failed second attempt
        _respond self.format_preset("#{Script.current.name}: encountered issue with 'Too many container windows already open'.  #{clean_lich_char}#{Script.current.name} --move_rooms=true   to enable moving rooms when encountering this error","watching")
        return id, adjective, noun, item_categories, contents, sorted_lines
      else
        # retry
        self.move_rooms
        @too_many_windows = 0
        @objects_looked = 0
        return self.sorted_view(o, preposition, path, open_closed) 
      end
    end
    # not found
    return id, adjective, noun, item_categories, contents, sorted_lines if sorted_lines.first =~ /I could not find what you were referring to/;
    # closed container
    if @view_patterns[:closed].match(sorted_lines.first)
      if open_closed == true
        Inv_db.object_open(o, path)
        sorted_lines = Inv_db.object_look(o, preposition, path)
      else
        return id, adjective, noun, item_categories, contents, sorted_lines
      end
    end
    # empty container
    if sorted_lines.first =~ /There is nothing/
      if (m = @view_patterns[:empty_sorted].match(sorted_lines.first))
        self.sorted_view_status_update('on') if @sorted_view_status != 'on'
        id = m[:id]
      else
        self.sorted_view_status_update('off') if @sorted_view_status != 'off'
      end
      return id, adjective, noun, item_categories, contents, sorted_lines
    end
    # not a container?
    return id, adjective, noun, item_categories, contents, sorted_lines if sorted_lines.first =~ /You see nothing unusual/;
    # handle unknown response, kinda
    return id, adjective, noun, item_categories, contents, sorted_lines if sorted_lines.first !~ /<a exist/
    # check current view
    if sorted_lines.any? { |sorted_line| @view_patterns[:category].match(sorted_line) }
      self.sorted_view_status_update('on') if @sorted_view_status != 'on'
    else
      self.sorted_view_status_update('off') if @sorted_view_status != 'off'
    end
    # set sorted view if not sorted view
    if @sorted_view_status != 'on'
      Inv_db.client_command('flag sorted on', /You will/)
      self.sorted_view_status_update('on')
      sorted_lines = Inv_db.object_look(o, preposition, path)
    end
    # parse and return
    return self.sorted_view_parse(sorted_lines, preposition)
  end

  @objects_looked = 0
  def self.move_rooms()
    _respond self.format_preset("@objects_looked:#{@objects_looked.inspect}","speech")
    _respond self.format_preset("#{Script.current.name}: moving rooms to clear inventory windows")
    start_room = Map.current.id
    wiggle_room = nil
    Map.current.wayto.each{ |k,v|
      next if Map[k.to_i].uid.first / 1000 != XMLData.room_id / 1000
      next if !Map[k.to_i].wayto.key?(start_room.to_s)
      wiggle_room = k
      break
    }
    [wiggle_room, start_room].each { |r| Script.run('go2',"#{r}")}
    @objects_looked = 0 # reset counter
  end

  # ;e respond Inv_db.traverse_container('', GameObj.loot.find{|o| o.noun == 'locker'}.contents.find{|i| i.noun =='sack'},  0,  'in locker', 'in', true )
  def self.traverse_container(child, preposition = 'in', path = '', id_path = '', level = -1, open_containers = true, max_depth = 9, swclose = false);
    respond "child: #{child.inspect}; prepostion: #{preposition.inspect}; path: #{path.inspect}; id_path:#{id_path}; level: #{level.inspect}, open_containers:#{open_containers}, max_depth:#{max_depth}, swclose:#{swclose.inspect}" if @debug_traverse
    preposition = preposition.downcase
    traverse_items = []
    empty_string = "".encode('UTF-8');
    level += 1;

    obj_id, obj_adjective, obj_noun, item_categories, contents, has_in, has_on = self.object_contents(child, preposition, id_path, open_containers)
    respond "obj_id, obj_adjective, obj_noun, item_categories, contents, has_in, has_on = Inv_db.object_contents(#{child.inspect}, #{preposition.inspect}, #{id_path.inspect}, #{open_containers.inspect})" if @debug_traverse
    respond "obj_id: #{obj_id.inspect}, obj_adjective: #{obj_adjective.inspect}, obj_noun:#{obj_noun.inspect}, item_categories.count:#{item_categories.count}, contents.count:#{contents.count}\n" if @debug_traverse 
    
    # return [], {} if contents.empty?
    # self.hash_print(item_categories)

    # respond item_categories.inspect #if @debug

    # this is the path style I need for looking in items while traversing;
    
    if level == 0
      path = "#{preposition} #{child}" if child.class == String
      path = "#{preposition} #{obj_noun}" if child.class != String
      id_path = "#{preposition} ##{obj_id} #{id_path}".rstrip if !obj_id.nil?
    #elsif child.class.to_s == 'String'
      #path = "#{"#{preposition} ".lstrip}#{"#{obj_adjective} ".lstrip}#{obj_noun} #{path}"
    #elsif child.class.to_s =~ /GameObj|OpenStruct/
      #path = "#{"#{preposition} ".lstrip}#{"#{obj_adjective} ".lstrip}#{obj_noun} #{path}"
    else
      path = "#{"#{preposition} ".lstrip}#{"#{obj_adjective} ".lstrip}#{obj_noun} #{path}"
      id_path = "#{preposition} ##{obj_id} #{id_path}".rstrip if !obj_id.nil?
    end
    #if @debug_traverse
    #  respond "child.class:#{child.class}"
    #  respond "path:#{path.inspect}"
    #  respond "\ncontents:"
    #  contents.each { |i| respond "  #{i.inspect}" }
    #end

    contents.clone.map(&:clone).each { |i|
      prename       = i.before_name;
      prename       = prename =~ /^(an |a |some )(.*)?/ ? $2.strip : prename.strip;
      prename       = "" if prename =~ /^(?:an?|some) ?$/
      id            = i.id;
      name          = i.name.encode('UTF-8');
      noun          = i.noun.strip.encode('UTF-8');
      type          = Inv_db.get_item_type(name, noun).encode('UTF-8')
      type          = "unknown".encode('UTF-8') if type.nil? or type.strip == '' 
      #postname      = i.after_name.encode('UTF-8');
      link_name     = i.name.encode('UTF-8');
      amount        = defined?(i.qty) ? i.qty : 1;
      stack         = empty_string;
      stack_name    = empty_string;
      stack_noun    = empty_string;
      stack_type    = empty_string;
      stack_amount  = 0;
      stack_status  = empty_string;

      containing    = /containing (.*?)(?:(?=\(\D|$))/.match(i.after_name).captures.first.strip.encode('UTF-8') || empty_string
      postname      = i.after_name.gsub(/ *containing.*$/,'').encode('UTF-8')
      #name          = "#{prename} #{name =~ /^(some )?(.*)/ ? $2 : name}#{(' ' + "#{postname}").rstrip}".strip;
      name          = "#{prename} #{name =~ /^(some )?(.*)/ ? $2.strip : name.strip}#{(" #{postname}").rstrip}".strip;

      stk           = /^(?<stack>jar)/i.match(type);
      stk           = /^(?<stack>stack) of .*? notes$/i.match(name) if stk.nil?
      if stk[:stack] =~ /jar/i and @settings_hash[stk[:stack].downcase] == true
        # respond "@settings_hash['#{stk[:stack].downcase}']: #{@settings_hash[stk[:stack].downcase]}" if @debug
        # stack_name      = Inv_db.deplural($6).strip
        stack_name      = Inv_db.deplural(postname).strip
        stack_noun      = stack_name =~ /(.*?) ([\w\-]+)$/ ? $2 : empty_string
        stack_noun      = stack_noun =~ /lazuli/ ? "lapis" : stack_noun
        stack_type      = (Inv_db.get_item_type(stack_name, stack_noun) || empty_string) if postname != ''
        stack_amount    = 0
        stack_status    = "empty".encode('UTF-8')
        stack_path      = path # (path.length > 0 ? "in #{id_path.reverse.join(" in ")}" : "") if postname =~ /containing/ or stk[:stack] !~ /jar/i
        stack_amount, stack_status = Inv_db.peek_stack(id, id_path, stk[:stack]) #if postname =~ /containing/
        stack_status    = stack_status =~ /^(full|empty)/ ? stack_status : "partial".encode('UTF-8')
        stack           = stk[:stack] if stack_amount > 0
      elsif @settings_hash[stk[:stack].downcase] == true
        # respond "@settings_hash['#{stk[:stack].downcase}']: #{@settings_hash[stk[:stack].downcase]}" if @debug
        stack_name      = Inv_db.deplural(name.gsub(/^(?:bundle|stack) of/, '')).strip
        stack_noun      = Inv_db.deplural(noun).strip
        stack_type      = (Inv_db.get_item_type(stack_name, stack_noun) || empty_string)
        stack_path      = path # (item_path.length > 0 ? "in #{item_path_ids.reverse.join(" in ")}" : "") if postname =~ /containing/ or stk[:stack] !~ /jar/i
        stack_amount, stack_status = Inv_db.peek_stack(id, id_path, stk[:stack])
        respond "stack_amount, stack_status: #{stack_amount}, #{stack_status}" if @debug
        stack           = stk[:stack] if stack_amount > 0
      end
      #if stk and item_categories[name] == 'Containers';
      #  stack           = empty_string;
      #  stack_name      = Inv_db.deplural(containing).strip;
      #  stack_noun      = empty_string;
      #  stack_type      = Inv_db.get_item_type(stack_name, nil) || empty_string;
      #  stack_amount, stack_status = Inv_db.peek_stack(id, id_path, "jar") # if postname =~ /containing/
      #  stack_status    = stack_status =~ /^(full|empty)/ ? stack_status : "partial".encode('UTF-8');
      #  stack           = stk[:stack] if stack_amount > 0;
      #  containing      = stack == empty_string ? empty_string : "(#{stack_name}) (#{stack_amount})"
      #end;
      traverse_items.push({
        :id           => id,
        :level        => level.to_i,
        :path         => path.gsub(/ *in locker *$/, '').encode('UTF-8'),
        :type         => type.encode('UTF-8'),
        :name         => name.encode('UTF-8'),
        :link_name    => link_name.encode('UTF-8'),
        :containing   => containing.encode('UTF-8'),
        :noun         => noun.encode('UTF-8'),
        :amount       => amount.to_i,
        :stack        => empty_string,
        :stack_status => stack_status.encode('UTF-8'),
        :update_noun  => 1
      });
      if stack != empty_string;
        traverse_items.push({
          :id           => id,
          :level        => level + 1,
          :path         => "#{path.gsub(/ *in locker *$/, '')} > #{noun}".encode('UTF-8'),
          :type         => stack_type ? stack_type : empty_string,
          :name         => stack_name,
          :link_name    => empty_string,
          :containing   => empty_string,
          :noun         => stack_noun,
          :amount       => stack_amount.to_i,
          :stack        => stack,
          :stack_status => empty_string,
          :update_noun  => 0
        });
      end;
        # respond i.inspect
        # respond "containing: #{containing.inspect}"
        # respond "    item_categories[#{name}]: #{item_categories[name]}"
        #_respond self.format_preset("name: #{name.inspect}") if name =~ /vasculum/
        #_respond self.format_preset("@settings_hash['boh']#{@settings_hash['boh'].inspect}") if name =~ /vasculum/
      if @settings_hash['boh'].include?(name)
        _respond self.format_preset("#{name} is a boh") if @debug
        verb = 'look in'
        if name =~ /tackle/
          verb = 'gaze'
        end
        respond "Inv_db.peek_boh(#{id.inspect},nil,#{level.inspect},#{path.inspect},#{id_path.inspect},#{noun.inspect},#{verb.inspect})" if @debug
        boh_items = Inv_db.peek_boh(id, nil, level, path, id_path, noun, verb)
        if boh_items.size > 1
          boh_items.each{|b| b.delete(:location_id)}
          traverse_items.concat(boh_items)
        end
      elsif item_categories[name].nil?
        respond "item_categories[#{name.inspect}]: #{item_categories[name].inspect}" 
      elsif item_categories[name] != 'Containers'
        #respond "item_categories[#{name.inspect}] != 'Containers'; category: #{item_categories[name].inspect}" 
      elsif item_categories[name] == 'Containers' #and stack != empty_string and type.to_s !~ /\bjar\b/i #and level < max_depth
        #respond "item_categories[#{name.inspect}] == 'Containers'" if @debug
        child_items, child_item_categories, has_in, has_on = self.traverse_container(i, 'in', path, id_path, level, open_containers, max_depth, swclose)
        respond "child_items.count:#{child_items.count}; child_item_categories.count:#{child_item_categories.count}; has_in:#{has_in.inspect}; has_on:#{has_on.inspect}" if @debug_traverse
        if child_item_categories.class != Hash
          respond "error: checking in #{i.inspect} #{id_path}"
          respond "error: child_item_categories.class:#{child_item_categories.class}"
          respond "child_item_categories: #{child_item_categories.inspect}"
        elsif !child_item_categories.empty?
          item_categories.merge!(child_item_categories) 
        end
        traverse_items = traverse_items + child_items 
        if has_on == true
          child_items, child_item_categories, has_in, has_on = self.traverse_container(i, 'on', path, id_path, level, open_containers, max_depth, swclose)
          if child_item_categories.class != Hash
            respond "error: checking on #{i.inspect} #{id_path}"
            respond "error: child_item_categories.class:#{child_item_categories.class}"
            respond "child_item_categories: #{child_item_categories.inspect}"
          elsif !child_item_categories.empty?
            item_categories.merge!(child_item_categories) 
          end
          traverse_items = traverse_items + child_items
        end
      end;
    };
    
    if swclose 
      if !obj_id.nil? and obj_id.class != Array
        put "_swclose c#{obj_id}" 
        #respond "swclosing c#{obj_id}" #if @debug
      elsif child.class == OpenStruct
        put "_swclose c#{child.id}" 
        #respond "swclosing c#{child.id}" #if @debug
      else
        respond "wanted to swclose but no obj_id for #{child}" if @debug
      end
    end
    
    return traverse_items, item_categories, has_in, has_on
  end;

  #------------------------------------------------------------------------------#
  # column and printing helpers
  #------------------------------------------------------------------------------#
  def self.check_output_size(row_size)
    #if row_size > 101 and @settings_hash['confirm_large_output'] == true
    if row_size > @settings_hash['confirm_large_output']
      Inv_db.gs_print("#{Script.current.name}: large output requires unpausing the script before printing more than #{@settings_hash['confirm_large_output']} rows.")
      Inv_db.gs_print("  You can change the number of rows to print without a confirmation by setting with <d>#{$clean_lich_char}#{Script.current.name} --confirm_large_output=99999</d>" )
      Inv_db.gs_print("  <d>#{$clean_lich_char}u #{Script.current.name}</d> to print the #{row_size} row result.")
      pause_script
    end
  end
  def self.hash_print(h, indent = '  ')
    h.each { |k, v|
      if v.class == Hash
        respond "#{indent}#{k}:"
        self.hash_print(v, indent + indent)
      else
        respond "#{indent}#{k}: #{v.inspect}"
      end
    }
  end

  def self.array_print(a, indent = '  ')
    a.each_with_index { |v, ix| respond "#{indent}#{ix}: #{v.inspect}" }
  end

  @abbrs = Hash.new;
  # q item;
  @abbrs["loc"]    = "location of the item (hands|inv|alongside|locker|town abbr if multi locker)";
  @abbrs["path"]   = "the path to an item, e.g. `backpack > box` is in a box, in a backpack";
  @abbrs["type"]   = "object type, per GameObj.type_data"; # , `;e _respond GameObj.type_data.keys` for your list of types"
  @abbrs["stk"]    = "stack, a non-standard container, e.g. jar|bundle|voucher pack";
  @abbrs["epf"]    = "stack status (empty|partial|full) for jars/stacks";
  @abbrs["m"]      = "marked (Y or blank)";
  @abbrs["r"]      = "registered (Y or blank)";
  @abbrs["h"]      = "hidden (Y or blank)";
  # q char;
  @abbrs["pro"]    = "profession";
  @abbrs["rc"]     = "race abbreviation";
  @abbrs["lvl"]    = "level";
  @abbrs["area"]   = "location character was when last updated";
  @abbrs["sub"]    = "account type (f2p|standard|premium)";
  @abbrs["locker"] = "town locker is in, multi if multiple";
  @abbrs["lockr"]  = "town locker is in, multi if multiple (will show starting town for f2p)";
  @abbrs["inv"]    = "item count for carried items";


  def self.output_table(rows, target = nil, iparams = nil, highlight = nil, regex_highlight = false, date_format = "%m/%d/%y")
    to_print    = [];
    date_format = @settings_hash['date_format'] if !@settings_hash.nil?;
    sum_qty = 0
    if rows.length > 1;
      rows.map!(&:dup)
      headers          = rows.shift;
      otimestamp       = headers.index("timestamp");
      oupdated         = headers.index("updated");
      ohighlight       = headers.index(highlight) if highlight;
      osum_qty         = headers.index("qty");
      filter_highlight = iparams[:search_filter].gsub(/(?!^)[\*|%](?!$)/, '.*').gsub('%', '') if iparams[:search_filter] && regex_highlight == false;
      filter_highlight = iparams[:search_filter] if iparams[:search_filter] && regex_highlight == true;
      rows.each do |row|;
        row.each_with_index { |col, x|
          next if [otimestamp, oupdated].include?(x)
          row[x] = Inv_db.int_to_comma(col) if col.class.to_s =~ /Fixnum|Integer/ and headers[x] !~ /_?id$/i
        }
        row[otimestamp] = Inv_db.int_to_date(row[otimestamp], date_format) if otimestamp;
        row[oupdated]   = Inv_db.int_to_date(row[oupdated], date_format) if oupdated;
        sum_qty += row[osum_qty].to_i if osum_qty;
      end;

      table_format, table_hl = Inv_db.format_table2(headers, rows);
      abbrs = @abbrs.clone;
      abbrs.keep_if { |k, _v| headers.include?(k) };
      to_print << @mono_start;
      abbrs.each { |k, v| to_print << "... %5s: %5s" % [k, v] } if abbrs.length > 0 and @settings_hash['hide_legend'] != true
      to_print << table_hl;
      to_print << table_format % headers;
      to_print << table_hl;
      rows.each do |row|;
        row[ohighlight] = row[ohighlight].sub(/(#{filter_highlight})/i, Inv_db.format_whisper($1)) if ohighlight && filter_highlight && row[ohighlight] =~ /(#{filter_highlight})/i;
        to_print << table_format % row;
      end;
      to_print << table_hl;
      if sum_qty > 0
        to_print << Inv_db.format_whisper("matched #{sum_qty} total items in #{rows.length} row#{rows.length > 1 ? "s" : ""} from #{target}.");
      else
        to_print << Inv_db.format_whisper("matched #{rows.length} row#{rows.length > 1 ? "s" : ""} from #{target}.");
      end
      to_print << @mono_end;
    else;
      to_print << Inv_db.format_whisper("no results found#{target.nil? ? '' : " in #{target}"}.");
    end;
    Inv_db.gs_print(to_print.join("\n"));
  end;

  def self.format_table2(headers, rows = [], column_delimiter = "|", column_padding_char = " ");
    table_border  = "";
    pad_char      = column_padding_char;
    table_format  = "";
    table_hl      = "";
    maxlen        = [];
    just          = [];
    if !rows.nil?;
      c = rows.clone.unshift(headers).transpose;
      c.each { |v|
        maxlen << v.max_by { |i| i.to_s.gsub(/<[^>]*?>/, '').length }.to_s.length || 1
        is_string = !v[1..-1].find { |i| i.to_s.match(/[a-zA-Z]/) }.nil?
        just << (is_string ? '-' : '').to_s
      };
    end;
    headers.each_with_index { |h, ix|
      if (ix == (headers.size - 1))
        i = { :pad => 1, :width => (h.to_s.length > maxlen[ix].to_s.length ? h.to_s.length : maxlen[ix].to_s.length), :justify => just[ix] };
        table_format += "#{pad_char * i[:pad]}%#{i[:justify]}#{i[:justify] == "" ? maxlen[ix] : ""}s";
        max_width = (i[:pad] + maxlen[ix] + column_delimiter.length)
        table_hl += "-" * (max_width > 20 ? 20 : max_width);
      else
        i = { :pad => 1, :width => (h.to_s.length > maxlen[ix].to_s.length ? h.to_s.length : maxlen[ix].to_s.length), :justify => just[ix] };
        table_format += "#{pad_char * i[:pad]}%#{i[:justify]}#{maxlen[ix]}s#{pad_char * i[:pad]}#{column_delimiter unless h == headers[-1]}";
        max_width = (i[:pad] + maxlen[ix] + i[:pad] + column_delimiter.length)
        table_hl += "-" * max_width
      end
    };
    table_format = "#{table_border}#{table_format}#{table_border}";
    return table_format, table_hl;
  end;

  #------------------------------------------------------------------------------#
  # external call helpers:
  #
  # Inv_db.pass_thru returns two variables, one is the array of arrays with the rows,
  #   and another with a change count.
  # Inv_db.to_table can be used to print rows, and assumes the first position in the array are headers
  #
  # e.g. >;e r,c=Inv_db.pass_thru("select * from character limit 1");Inv_db.to_table(r)
  # e.g. >;e r,c=Inv_db.pass_thru("select sql from sqlite_master where type='table'");Inv_db.to_table(r)
  # e.g. >;e r,c=Inv_db.pass_thru("select sql from sqlite_master where type='table'");r.each {|a| respond a[0]}
  #------------------------------------------------------------------------------#
  def self.to_table(rows)
    to_print = [];
    if rows.length > 1;
      headers = rows[0];
      table_format, table_hl = format_table2(headers, rows);
      to_print << @mono_start;
      to_print << table_hl;
      to_print << table_format % headers;
      to_print << table_hl;
      rows.shift;
      rows.each do |row|
        to_print << table_format % row;
      end;
      to_print << table_hl;
      to_print << @mono_end;
    else;
      to_print << " nothing to print.";
      return nil;
    end;
    Inv_db.gs_print(to_print.join("\n"));
  end;

  #------------------------------------------------------------------------------#
  # dynamic-ish sql
  #------------------------------------------------------------------------------#
  def self.query_bank_sql(params, style = "");
    respond "+---------------- proc_start: #{@current_proc}" if @debug_sql && !@debug;
    respond "+----params:#{params.inspect}" if @debug_sql && !@debug;
    respond "+----style:#{style.inspect}" if @debug_sql && !@debug;
    groupby = having = limit = "";
    where, qargs, extras = self.where_builder(params, 'bank')

    select = %{
    select
        c.name as character
      , b.name as bank
      , s.amount
      , s.timestamp as updated};
    from = %{
    from silver s
      inner join bank b on s.bank_id = b.id
      inner join character c on s.character_id = c.id};

    orderby = "\n    order by c.name, b.id"
    orderby = "\n    order by #{extras[:orderby]}" if extras.key?(:orderby);
    limit   = "\n    limit #{extras[:limit]}" if extras.key?(:limit);
    sql = "#{select} #{from} #{where} #{groupby} #{having} #{orderby} #{limit}";
    _respond sql if @debug_sql;
    return sql.encode('UTF-8'), qargs;
  end;

  def self.sum_bank_sql(params, style = "");
    respond "+---------------- proc_start: #{@current_proc}" if @debug_sql; # && !@debug
    respond "+----params:#{params.inspect}" if @debug_sql;
    respond "+----style:#{style.inspect}" if @debug_sql;

    having = limit = "";
    where, qargs, extras = self.where_builder(params, 'bank')

    select = %{
    select
        b.name as bank
      , sum(s.amount) as amount
      , replace(group_concat(distinct c.name),',',', ') as characters };
    from = %{
    from silver s
      inner join bank b on s.bank_id = b.id
      inner join character c on s.character_id = c.id};
    where  += "\n      and b.name <> 'Total'" if !qargs.key?(:search_filter);
    groupby = "\n    group by b.name";
    # groupby += extras[:groupby] if extras.key?(:groupby)
    orderby = "\n    order by bank"
    orderby = "\n    order by #{extras[:orderby]}" if extras.key?(:orderby);
    # limit   = "\n    limit #{extras[:limit]}" if extras.key?(:limit);
    sql = "#{select} #{from} #{where} #{groupby} #{having}";
    sql += "\n    union all #{select.gsub('b.name', '"grand total"')} #{from} #{where} " if !qargs.key?(:search_filter) and !extras.key?(:limit)
    sql += " #{orderby} #{limit}";
    return sql.encode('UTF-8'), qargs;
  end;

  def self.query_tickets_sql(params, style = "");
    respond "+---------------- proc_start: #{@current_proc}" if @debug_sql && !@debug;
    respond "+----params:#{params.inspect}" if @debug_sql
    respond "+----style:#{style.inspect}" if @debug_sql && !@debug;

    groupby = having = limit = "";
    where, qargs, extras = self.where_builder(params, 'tickets')

    select = %{
    select
        c.name as character
      , c.game
      , t.source
      , t.amount
      , t.currency
      , t.timestamp as updated};
    from = %{
    from tickets t
      inner join character c on t.character_id = c.id};
    orderby = "\n    order by t.source, c.name"
    orderby = "\n    order by #{extras[:orderby]}" if extras.key?(:orderby);
    limit   = "\n    limit #{extras[:limit]}" if extras.key?(:limit);
    sql = "#{select} #{from} #{where} #{groupby} #{having} #{orderby} #{limit}";
    _respond sql if @debug_sql;
    return sql.encode('UTF-8'), qargs;
  end;

  def self.sum_tickets_sql(params, style = "");
    respond "+---------------- proc_start: #{@current_proc}" if @debug_sql # && !@debug;
    respond "+----params:#{params.inspect}" if @debug_sql;
    respond "+----style:#{style.inspect}" if @debug_sql;

    having = limit = "";
    where, qargs, extras = self.where_builder(params, 'tickets')

    select = %{
    select
        t.source as source
      , sum(t.amount) as amount
      , t.currency as currency
      , replace(group_concat(distinct c.name),',',', ') as characters };
    from = %{
    from tickets t
      inner join character c on t.character_id = c.id};

    groupby = "\n    group by t.source, t.currency";
    orderby = "\n    order by source"
    orderby = "\n    order by #{extras[:orderby]}" if extras.key?(:orderby);
    limit   = "\n    limit #{extras[:limit]}" if extras.key?(:limit);
    sql = "#{select} #{from} #{where} #{groupby} #{having} #{orderby} #{limit}";
    _respond sql if @debug_sql;
    return sql.encode('UTF-8'), qargs;
  end;

  def self.query_char_sql(params, style = "");
    respond "+---------------- proc_start: #{@current_proc}" if @debug_sql # && !@debug;
    respond "+----params:#{params.inspect}" if @debug_sql;
    respond "+----style:#{style.inspect}" if @debug_sql;

    groupby = having = limit = "";
    where, qargs, extras = self.where_builder(params, 'character')

    select = %{
    select
        c.account
      , c.name as character
      , lower(c.game) as game
      , substr(c.prof,1,3) as pro
      , substr(replace(c.race,'alf-',''),1,2) as rc
      , c.level as lvl
      --, c.exp
      , c.area
      , substr(c.subscription,1,3) as sub
      --, coalesce(l.abbr,c.locker) as lockr
      , coalesce(l.locker_abbr,c.locker) as lockr
      , c.citizenship
      , c.society
      , c.society_rank as rank
      , c.timestamp as updated
      , i.inv
    };
    from = %{
    from character c
      left join ( select l.name as locker_name, l.abbr as locker_abbr from location l) as l
        on c.locker = l.locker_name
      left join (
        select
            i.character_id
          , sum(amount) as inv
        from char_inventory as i
        where i.stack=''
          and i.location_id < 3
        group by i.character_id
          ) i on c.id = i.character_id
    };

    where += "#{@where_prefix}c.name not like '%\\_' ESCAPE '\\'" if !qargs.key?(:character_filter)

    orderby = "\n    order by c.game, c.name"
    orderby = "\n    order by #{extras[:orderby]}" if extras.key?(:orderby);
    limit   = "\n    limit #{extras[:limit]}" if extras.key?(:limit);
    sql = "#{select} #{from} #{where} #{groupby} #{having} #{orderby} #{limit}";
    _respond sql if @debug_sql;
    return sql.encode('UTF-8'), qargs;
  end;

  def self.query_item_sql(params, style = "");
    respond "+---------------- proc_start: #{@current_proc}" if @debug_sql
    respond "+----params:#{params.inspect}" if @debug_sql;
    respond "+----style:#{style.inspect}" if @debug_sql;
    groupby = having = limit = "";
    where, qargs, extras = self.where_builder(params, 'char_inventory')

    select = %{
    select
        c.name
      , l.abbr as loc
      , v.path
      , v.amount as qty
      , i.type
      , i.category
      , substr(v.stack,1,3) as stk
      , ' ' || substr(v.stack_status,1,1) as epf
      , v.marked as m
      , v.registered as r
      , v.hidden as h};
    # select += "\n      , v.item_id"
    select += "\n      , i.noun" if qargs.any? { |_k, v| v =~ /i\.noun/ };
    select += "\n      , (i.name || rtrim(' ' || v.containing)) as item";

    export_select = %{
    select
        c.account, c.name, l.name as location, l.abbr as loc
      , v.level, v.path, v.amount as qty
      , i.type, i.category, v.stack, v.stack_status
      , i.name as item, i.noun
      , i.timestamp
      , d.*
    };
    select = export_select if style == 'export'

    from = %{
    from char_inventory v
      inner join item i on i.id = v.item_id
      inner join location l on l.id = v.location_id
      inner join character c on c.id = v.character_id
      left join item_detail d on d.item_id = v.item_id};

    orderby = "\n    order by c.name, l.type, l.name, v.level, v.path, i.noun, i.name"
    orderby = "\n    order by #{extras[:orderby]}" if extras.key?(:orderby);
    limit   = "\n    limit #{extras[:limit]}" if extras.key?(:limit);
    sql = "#{select} #{from} #{where} #{groupby} #{having} #{orderby} #{limit}";
    _respond sql if @debug_sql;
    return sql.encode('UTF-8'), qargs;
  end;

  def self.sum_item_sql(params, style = "");
    respond "+---------------- proc_start: #{@current_proc}" if @debug_sql; # && !@debug;
    respond "+----params:#{params.inspect}" if @debug_sql || @debug_input;
    respond "+----style:#{style.inspect}" if @debug_sql;

    having = orderby = limit = "";
    where, qargs, extras = self.where_builder(params, 'item')
    groupby = extras[:group_by]

    select = %{
    select
        i.type as type
      , sum(v.amount) as amount};
    select += "\n      , sum(case when stack='' then amount else 0 end) as loose" if qargs[:type_filter] =~ /gem|reagent/;
    select += "\n      , sum(case when stack='jar' then amount else 0 end) as jarred" if qargs[:type_filter] =~ /gem|reagent/;
    select += "\n      , c.name as name" if groupby =~ /char/;
    select += "\n      , l.abbr as loc"  if groupby =~ /loc/;
    select += "\n      , i.noun as noun" if groupby =~ /noun/ or orderby =~ /noun/;
    select += "\n      , i.name as item";

    from = %{
    from char_inventory v
      inner join item i on i.id = v.item_id
      inner join location l on l.id = v.location_id
      inner join character c on c.id = v.character_id
      left join item_detail d on d.item_id = v.item_id
      };
    default_groupby = "\n    group by i.type, i.name";
    default_groupby += ", c.name" if groupby =~ /char/;
    default_groupby += ", l.abbr" if groupby =~ /loc/;
    default_groupby += ", i.noun" if groupby =~ /noun/;
    groupby = default_groupby;

    orderby = "\n    order by i.type, amount"
    orderby = "\n    order by #{extras[:orderby]}" if extras.key?(:orderby);
    limit   = "\n    limit #{extras[:limit]}" if extras.key?(:limit);
    sql = "#{select} #{from} #{where} #{groupby} #{having}";
    sql += "\nunion all\n #{select.gsub(/[lic].(?:name|noun|abbr)/, "'total'")} #{from} #{where}\ngroup by i.type";
    sql += " #{orderby} #{limit}";
    _respond sql if @debug_sql;
    return sql.encode('UTF-8'), qargs;
  end;

  def self.count_item_sql(params, style = "");
    respond "+---------------- proc_start: #{@current_proc}" if @debug_sql;
    respond "+----params:#{params.inspect}" if @debug_sql || @debug_input;
    respond "+----style:#{style.inspect}" if @debug_sql;

    having = limit = "";
    where, qargs, extras = self.where_builder(params, 'item')
    where += "
      and c.subscription not like 'f%'
      and (
           (c.name like '%\\_' ESCAPE '\\' and l.abbr = 'fam')
        or (c.name not like '%\\_' ESCAPE '\\' and c.subscription like 'standard' and l.abbr = 'locker')
        or (c.name not like '%\\_' ESCAPE '\\' and c.subscription not like 'standard' and l.abbr not in ('fam','locker'))
        )
      "
    select = "
    select
        c.name as character
      , l.abbr as location
      , sum(case when v.stack='' then v.amount else 0 end) as count";
    select += "\n      , sum(case when i.type='box' then v.amount else 0 end) as boxes" if !qargs[:search_filter] && !qargs[:search_regex] && !qargs[:type_filter] && !qargs[:noun_filter];
    select += "\n      , i.name as item" if qargs.key?(:search_filter)
    from = %{
    from char_inventory v
      inner join item i on i.id = v.item_id
      inner join location l on l.id = v.location_id
      inner join character c on c.id = v.character_id
      left join item_detail d on d.item_id = v.item_id
      };
    default_groupby = "\n    group by c.name, l.id, l.abbr";
    default_groupby += ", i.name" if qargs.key?(:search_filter)
    groupby = default_groupby;

    orderby = "\n    order by c.name, l.id"
    orderby = "\n    order by #{extras[:orderby]}" if extras.key?(:orderby);
    limit   = "\n    limit #{extras[:limit]}" if extras.key?(:limit);
    sql = "#{select} #{from} #{where} #{groupby} #{having} #{orderby} #{limit}";
    return sql.encode('UTF-8'), qargs;
  end
  
  def self.count_room_inventory_sql(params, style = "");
    #fail "not implemented"
    respond "+---------------- count_room_sql:" if @debug_sql;
    respond "+----params:#{params.inspect}" if @debug_sql || @debug_input;
    respond "+----style:#{style.inspect}" if @debug_sql;

    groupby = having = limit = "";
    where, qargs, extras = self.where_builder(params, 'room_inventory', aggregate=true, action='count')
    respond h = {:where => where, :qargs => qargs, :extras => extras}.inspect if @debug_sql
    xgroupby = extras[:groupby].to_s if extras.key?(:groupby)
    select = "\n    select
        r.property
      , case when r.nickname = '' then r.title else r.nickname end as room"
    select += "\n      , r.uid"  if xgroupby =~ /uid/  
    select += "\n      , r.lich_id"  if xgroupby =~ /lich_id/  
    select += "\n      , ro.object"  if xgroupby =~ /object/
    select += "\n      , ri.path"    if xgroupby =~ /path/
    select += "\n      , i.type"     if xgroupby =~ /type/
    select += "\n      , i.category" if xgroupby =~ /category/
    select += "\n      , i.noun"     if xgroupby =~ /noun/
    select += "\n      , i.name as item" if xgroupby =~ /item|name/
    select += "\n      , sum(ri.amount) as qty"
    from = %{
    from room r 
      inner join room_object ro on r.id = ro.room_id
      inner join room_inventory ri on ro.id = ri.room_object_id
      inner join item i on i.id = ri.item_id 
      };
      # left join item_detail d on d.item_id = ri.item_id
    default_groupby = "\n    group by r.property, r.nickname, r.title";
    #default_groupby += ", i.name" if qargs.key?(:search_filter)
    default_groupby += ", r.uid"      if xgroupby =~ /uid/
    default_groupby += ", r.lich_id"  if xgroupby =~ /lich_id/
    default_groupby += ", ro.object"  if xgroupby =~ /object/
    default_groupby += ", ri.path"    if xgroupby =~ /path/
    default_groupby += ", i.type"     if xgroupby =~ /type/
    default_groupby += ", i.category" if xgroupby =~ /category/
    default_groupby += ", i.noun"     if xgroupby =~ /noun/
    default_groupby += ", i.name"     if xgroupby =~ /item|name/
    groupby = default_groupby
    
    orderby = "\n    order by r.property"
    orderby = "\n    order by #{extras[:orderby]}" if extras.key?(:orderby);
    limit   = "\n    limit #{extras[:limit]}" if extras.key?(:limit);
    sql = "#{select} #{from} #{where} #{groupby} #{having} #{orderby} #{limit}";
    return sql.encode('UTF-8'), qargs;
  end

  #------------------------------------------------------------------------------#
  # locations -- really should be pulled from the database
  #------------------------------------------------------------------------------#
  @locations       = Hash.new;
  @locations["1"]  = { :id => "1", :name => 'hands', :abbr => 'hands', :type => 'inv' };
  @locations["2"]  = { :id => "2", :name => 'inventory', :abbr => 'inv', :type => 'inv' };
  @locations["6"]  = { :id => "6", :name => 'alongside', :abbr => 'alongside', :type => 'inv' };
  @locations["10"] = { :id => "10", :name => 'locker', :abbr => 'lo', :type => 'locker' };
  @locations["11"] = { :id => "11", :name => 'Wehnimer\'s Landing', :abbr => 'wl', :type => 'locker' };
  @locations["12"] = { :id => "12", :name => 'Teras Isle', :abbr => 'teras', :type => 'locker' };
  @locations["13"] = { :id => "13", :name => 'Solhaven', :abbr => 'sol', :type => 'locker' };
  @locations["14"] = { :id => "14", :name => 'River\'s Rest', :abbr => 'rr', :type => 'locker' };
  @locations["15"] = { :id => "15", :name => 'Icemule Trace', :abbr => 'im', :type => 'locker' };
  @locations["16"] = { :id => "16", :name => 'Zul Logoth', :abbr => 'zul', :type => 'locker' };
  @locations["17"] = { :id => "17", :name => 'Ta\'Illistim', :abbr => 'ti', :type => 'locker' };
  @locations["18"] = { :id => "18", :name => 'Ta\'Vaalor', :abbr => 'tv', :type => 'locker' };
  @locations["19"] = { :id => "19", :name => 'Mist Harbor', :abbr => 'fwi', :type => 'locker' };
  @locations["20"] = { :id => "20", :name => 'Cysaegir', :abbr => 'cy', :type => 'locker' };
  @locations["21"] = { :id => "21", :name => 'Kraken\'s Fall', :abbr => 'kf', :type => 'locker' };
  @locations["30"] = { :id => "30", :name => 'Astral Vault', :abbr => 'av', :type => 'locker' };
  @locations["40"] = { :id => "40", :name => 'Family Vault', :abbr => 'fam', :type => 'locker' };

  #------------------------------------------------------------------------------#
  # instance variables
  #------------------------------------------------------------------------------#
  @sorted_view_saved    = nil;
  @sorted_view_status   = nil;
  @subscription         = nil;
  @character_id         = nil;
  @lumnis_status        = nil;
  @inventory_count      = 0;
  @manifest_count       = 0;
  @inv_retry            = 1;
  @manifest_retry       = 1;
  @containers_to_open   = [];
  @containers_noopen    = @settings_hash["container_noopen"];
  @containers_noopen_pattern = nil;
  @containers_noopen_pattern = /(#{@containers_noopen.join("|")})$/i if @containers_noopen.length > 0;
  @containers_to_close  = [];
  @empty_string         = ""; @empty_string = @empty_string.encode('UTF-8');
  @gui                  = false;
  @inv_items            = [];
  @inv_scan             = [];
  @locker_items         = [];

  @script                     = Script.current;
  @script.want_downstream     = false;
  @script.want_downstream_xml = true;
  #------------------------------------------------------------------------------#
  # thanks to LostRanger for this fix for missing lines in invfull:
  #------------------------------------------------------------------------------#
  @script.downstream_buffer.instance_variable_set(:@max_size, 4000)
  #------------------------------------------------------------------------------#
  # quiet_command by LostRanger, modded tiny bit by Xanlin
  #------------------------------------------------------------------------------#
  @script_name = Script.current.name;
  def self.anon_hook(prefix = '')
    now = Time.now
    return "#{@script_name}::#{prefix}_#{now.strftime("%Y-%m-%d_%H:%M:%S.%6N")}_#{Random.rand(10000)}";
  end

  def self.cleanup; [DownstreamHook, UpstreamHook].each { |provider| provider.list.find_all { |name| name.start_with?("#{@script_name}::") }.each { |name| provider.remove(name) }; }; end;

  def self.issue_command(command, start_pattern, end_pattern = /<prompt/, include_end = true, timeout = 5, silent = nil, usexml = true, quiet = true)
    result = []
    name = self.anon_hook(command.gsub(' ', '_'))
    filter = false

    save_script_silent = Script.current.silent
    save_want_downstream = Script.current.want_downstream
    save_want_downstream_xml = Script.current.want_downstream_xml

    Script.current.silent = silent if !silent.nil?
    Script.current.want_downstream = !usexml
    Script.current.want_downstream_xml = usexml

    begin
      Timeout::timeout(timeout, Interrupt) {
        DownstreamHook.add(name, proc { |line|
          if filter
            if line =~ end_pattern
              DownstreamHook.remove(name)
              filter = false
            else
              next(nil) if quiet
              line
            end
          elsif line =~ start_pattern
            filter = true
            next(nil) if quiet
            line
          else
            line
          end
        })
        fput command
        until (line = get) =~ start_pattern; end
        result << line.rstrip
        until (line = get) =~ end_pattern
          result << line.rstrip
        end
        if include_end
          result << line.rstrip
        end
      }
    rescue Interrupt
      DownstreamHook.remove(name);
      nil
    ensure
      DownstreamHook.remove(name)
      Script.current.silent = save_script_silent if !silent.nil?
      Script.current.want_downstream = save_want_downstream
      Script.current.want_downstream_xml = save_want_downstream_xml
    end
    return result
  end

  def self.client_command(command, start_pattern, end_pattern = /^(?:<pop(?:Bold|Stream)\/>)?<prompt/, quiet = @quiet, timeout = 5, include_end = true, silent = nil)
    return self.old_quiet_command(command, start_pattern, end_pattern, include_end, timeout) if @use_old_quiet_command == true;
    return self.issue_command(command, start_pattern, end_pattern, include_end, timeout, silent, true, quiet)
  end;

  #------------------------------------------------------------------------------#
  # quickdo -- with output
  #------------------------------------------------------------------------------#
  def self.quickdo(command_queue, success_pattern, speed = 3)
    return if command_queue.length < 1;
    queue    = command_queue;
    pattern  = success_pattern;
    flock    = speed;
    inflight = 0;
    output   = [];
    timeout  = queue.length * 2;
    begin;
      Timeout::timeout(timeout, Interrupt) {
        while queue.length > 0;
          put queue.pop;
          inflight += 1;
          while inflight > flock;
            nil until (m = pattern.match(get));
            output << m[0];
            inflight -= 1;
          end;
        end;
        inflight.times { nil until (m = pattern.match(get)); output << m[0] };
      }
    rescue Interrupt
      nil;
    end;
    return output;
  end;

  #------------------------------------------------------------------------------#
  # help & related
  #------------------------------------------------------------------------------#
  help_text = %{    ;inv help      > help text (this)       
    ;inv examples  > examples
    ;inv menu      > basic starter menu     
    ;inv changelog > changelog

    first parameter: action (default to refresh all if no parameters provided)
      options: refresh, query, sum (or total), export, reset, delete, remove, update
        refresh     load/update your database
        query       prints out results to your story window
        sum         less detail than query, aggregates by type and item
        count       shows totals by character and location
        export      export table or query to a file
        reset       clear everything and start over
        delete      delete stuff, can be complicated, more on this later
        remove      safer delete for rooms based on the current room
        update      used to update certain properties for some targets
                    room, room_object, item, item_detail

    second parameter: target (defaults to all or item)
      options: bank, bounty, char, item, inv, locker, lumnis, resource, tickets
               room/prop, rooms, room_objects,
        bank         bank account & silvers
        bounty       shows bounty info
        char         character info
        item         both inventory and lockers
        item_detail
        inv          inventory, but not lockers
        locker       locker(s), but not inventory
        lumnis       lumnis status
        resource     resource and suffusion status, and voln favor
        tickets      ticket balance information
        rooms        rooms for room inventory
        room_objects objects scanned for room inventory
        room/prop    room inventory

    optional parameters and filters:
      all queries sent have a game filter, defaulting to the current game
      char=name
      game=gsiv                      # defaults to the current game
      type=gem                       # based on your GameObj type data.
      category=Container             # based on simutronics category from sorted view
      amount(<|<=|=|>|>=)42          # amount greater than, equal to, etc a number
      qty(<|<=|=|>|>=)42             # qty greater than, equal to, etc a number
      noun=stone                     # filter by item noun
      path=backpack                  # all items that start in a backpack
      stack=(jar|bundle|stack|pack)  # only jars implemented so far
      epf=(empty|partial|full)       # to help find empty or full jars
      marked=Y                       # not recorded in standard lockers
      registered=Y                   # not recorded in standard lockers

      groupby=char                   # adds char column to sum/total queries
      orderby="path asc, qty desc"   # customize result order
      limit=5                        # limits number of rows output to 5
      delay=6                        # delay N seconds before doing stuff (e.g. autostart)

      these follow a format of `[parameter][operator][value]`
        e.g. char=Xanlin
      text values support =, !=, <>, and =/regex/ regular expressions
      numeric values support =, >=, <=, !=, <>

    All other input is used as a search string in the primary name in the target.
    If no parameters are provided, defaults to `refresh all`
    If no applicable action & target are specified, but has other input, defaults to searching items
    +---------------------------------------------------------------+
    exporting:
      ;inv export (char|item|inv|locker|bank|tickets|sbank|stickets) (optional parameters)
      - additional optional export parameters:
        format=(csv|txt|pipe)         default = csv
        dir="c:\\users\me\\desktop"   default = $lich_dir\\inv\\
        file="filename.ext"           default = target_(params)_timestamp.csv
    +---------------------------------------------------------------+
    most commands have abbreviations:
      q  = query      c = char        m = marked
      i  = item       g = game        r = registered
      in = inv        t = type        s = stack
      l  = locker     n = noun        epf = stack_status
      b  = bank       p = path
    +---------------------------------------------------------------+
    settings (on/off is converted into true/false)
      ;inv --settings lists your current settings
      ;inv --jar=on/off will turn on/off looking in jars
      ;inv --stack=on/off will turn on/off reading stacks of notes (light and deep notes)
    };
  help_examples = %{
    examples:
      ;inv                           # refresh all
      ;inv query item golden glim    # contains the phrase golden glim
      ;inv q i golden glim           # contains the phrase golden glim
      ;inv q i n glim                # contains the phrase n glim
      ;inv q i gold*glim             # * is a wildcard, contains gold and glim
      ;inv q i =golden wand          # = exact match (not just contains)
      ;inv gold*                    # = can be used with wildcards
      ;inv type=wand gold            # all wands with gold in the name
      ;inv gold type=wand            # all wands with gold in the name
      ;inv gold t=wand               # all wands with gold in the name
      ;inv sapphire char=xanlin      # all sapphires in Xanlin's inv & lockers
      ;inv path=backpack char=xanlin # all items in Xanlin's backpack
      ;inv path=*sack                # all items in any sack
      ;inv count locker char=xanlin  # show locker item count for each of Xanlin's lockers};
  help_menu = "
      #{Inv_db.format_monsterbold("Run #1 first if your database is empty:")}
       1: <d cmd=\"#{$clean_lich_char}eq Script.run('inv_db','refresh all');Script.start('inv_db','menu')\">#{$clean_lich_char}inv_db refresh all</d> to create/update the database

       other examples:
       2: character list       <d cmd=\"#{$clean_lich_char}eq Script.run('inv_db','q char');Script.start('inv_db','menu')\">#{$clean_lich_char}inv_db query char</d>
       3: bank accounts        <d cmd=\"#{$clean_lich_char}eq Script.run('inv_db','q bank');Script.start('inv_db','menu')\">#{$clean_lich_char}inv_db q bank</d>
       4: landing bank total   <d cmd=\"#{$clean_lich_char}eq Script.run('inv_db','sum bank amount&gt;100000 elan');Script.start('inv_db','menu')\">#{$clean_lich_char}inv_db sum bank amount&gt;100000 elan</d>
       5: all gems in inv(s)   <d cmd=\"#{$clean_lich_char}eq Script.run('inv_db','q inv type=gem');Script.start('inv_db','menu')\">#{$clean_lich_char}inv_db q inv type=gem</d>
       6: your stuff           <d cmd=\"#{$clean_lich_char}eq Script.run('inv_db','q item char=#{XMLData.name}');Script.start('inv_db','menu')\">#{$clean_lich_char}inv_db q item c=#{XMLData.name}</d>
       7: all locker stuff     <d cmd=\"#{$clean_lich_char}eq Script.run('inv_db','q locker');Script.start('inv_db','menu')\">#{$clean_lich_char}inv_db q locker</d>
       8: all empty jars       <d cmd=\"#{$clean_lich_char}eq Script.run('inv_db','type=jar epf=empty');Script.start('inv_db','menu')\">#{$clean_lich_char}inv_db type=jar epf=empty</d>
       9: total gems           <d cmd=\"#{$clean_lich_char}eq Script.run('inv_db','sum type=gem');Script.start('inv_db','menu')\">#{$clean_lich_char}inv_db sum type=gem</d>
      10: total uncut diamonds <d cmd=\"#{$clean_lich_char}eq Script.run('inv_db','sum type=gem =uncut dia*');Script.start('inv_db','menu')\">#{$clean_lich_char}inv_db sum type=gem =uncut dia*</d>
      11: locker counts        <d cmd=\"#{$clean_lich_char}eq Script.run('inv_db','count char=#{XMLData.name}');Script.start('inv_db','menu')\">#{$clean_lich_char}inv_db count char=#{XMLData.name}</d>

      Add an optional delay for autostart:
          <d cmd=\"#{$clean_lich_char}autostart add --global #{Script.current.name} delay=6 @no_squelch\r\">#{$clean_lich_char}autostart add --global #{Script.current.name} delay=6 @no_squelch</d>
      To set autostart #{$clean_lich_char}repository to download updates:
          <d cmd=\"#{$clean_lich_char}autostart add --global repository download-updates\r\">#{$clean_lich_char}autostart add --global repository download-updates</d>
      To set #{Script.current.name} to auto-update:
          <d cmd=\"#{$clean_lich_char}repository set-updatable #{Script.current.name}\r\">#{$clean_lich_char}repository set-updatable inv_db</d>
      To update just your character info on logout:
          <d cmd=\"#{$clean_lich_char}alias add --global quit=;eq Script.run('#{Script.current.name}','refresh char');fput 'quit';\r\">;alias add --global quit=#{$clean_lich_char}eq Script.run('#{Script.current.name}','refresh char');fput 'quit'</d>
  ";
  help_changelog = %{  changelog:
      #.#.#.# (2023-12) 
        - beta: added bounty
        - beta: more fixes for property/room inventory
        - beta: silver proc to methods refactor
      #.#.#.# (2023-04)
        - beta: large refactor and database update, introduces item notes and room/property inventory, item categories
      0.3.7.7 (2023-04-18)
        - encoding fixes
        - removed autofit option, all will autofit now
      0.3.7.6 (2023-04-15)
        - fix for unclosable statement sometimes
      0.3.7.5 (2023-04-15)
        - fix for location error
      0.3.7.4 (2023-04-11)
        - fix for sum bank, internals refactoring
      0.3.7.3 (2023-04-10)
        - fix for checking lumnis to reset resource weekly
      0.3.7.1 (2023-04-09)
        - skip updating resource for those with no profession resource or favor
      0.3.7.0 (2023-04-09)
        - added lumnis
        - added resource
        - added society and citizenship to character
        - all filters now support regex
        - switch from duskruin view account to account verb
        - significant refactor of parameter handling and query generation};
=begin
      0.3.6.7 (2023-03-31)
        - fix for reset
      0.3.6.6 (2023-03-31)
        - fix for schema update
      0.3.6.5 (2023-03-31)
        - fix family vault manifest inside locker on standard accounts
      0.3.6.4 (2023-03-27)
        - added astral vault, family vault
      0.3.6.3 (2023-03-14)
        - container open adjustment
      0.3.6.2 (2023-02-22)
        - settings_hash update
      0.3.6.1 (2023-02-22)
        - ruby 3.2 fix, File.exists? => File.exist?
      0.3.6 (2023-02-22)
        - refactoring code, ruby 3.2 fix
      0.3.5 (2023-01-23)
        - add version check before safe
      0.3.4 (2022-10-15)
        - fixed bug with bag of boldings skipping some lines
        - boh can now scan other types of bags of holding like vasculums, caboodles, tackle boxes
      0.3.3.06 (2022-07-26)
        - fixed f2p bank account bugs
      0.3.3.05 (2022-06-12)
        - inv_full pattern fix for mounts (monsterbold)
      0.3.3.04
        - added date format setting
        - fix for change to inventory container
      0.3.3.03 (2022-03-14)
        - fix for account type on f2ps being set to standard if they hadn't opened a bank account yet
      0.3.3.02 (2022-03-11)
        - fix for autostart sending an empty string in an array instead of an empty array
      0.3.3.01 (2022-03-03)
        - typo fix
      0.3.3.0 (2022-02-26)
        - updated ;invdb --settings
        - added handling for bags of holding -- Thanks Nisugi!
        - add custom bag of holdings names with ;invdb +boh Nisgui's special sack with things
        - remove custom bag of holdings names with ;invdb -boh Nisgui's special sack with things
        - tries to find nouns in locker items
      0.3.2.9 (2021-05-31)
        - added --use_old_quiet_command=true for strange issues that break current versions.
      0.3.2.8 (2021-05-25)
        - silence reading notes
      0.3.2.7 (2021-05-25)
        - set current area unknown if nil
        - remove bundle checking, since it breaks hiding and is noisy as fuck
      0.3.2.6 (2021-05-25)
        - only look for current area when refreshing character info, skip using location verb if room window is disabled or more than 2 people there
        - added bundles and stacks to stack types.  Only counts them when in inventory though.
        - removed locker refresh from default for f2ps
        - removed extra call to bank info on f2ps for character info
        - fixed nosquelch typo
      0.3.2.4 (2020-09-07)
      0.3.2.3 (2020-09-07)
        - fix for commas in bank account
      0.3.2.2 (2020-09-03)
        - oops, added Cysaegir to the lockers
      0.3.2.19 (2021-12-09)
        - jar pattern correction
      0.3.2.18 (2021-12-09)
        - because Naiken is rearranging things again...
      0.3.2.17 (2021-12-07)
        - added --silence_stack=off option to unsilence the results of peeking in jars/stacks
      0.3.2.16 (2021-12-07)
        - update to fix default settings
      0.3.2.15 (2021-12-05)
        - update for (Items: \d+) instead of displayed items
        - update for inventory full no longer saying 'wearing and carrying'
      0.3.2.14 (2021-12-01)
        - update for Naiken's new alongside inventory commands
        - added settings to turn on/off scanning stacks and jars
        - ;invdb --jar=on/off will turn on/off looking in jars
        - ;invdb --stack=on/off will turn on/off reading stacks of notes (light and deep notes)
        - ;invdb --autofit=on/off will turn on/off table columns adjusting to fit content (on) or being ragged (off)
      0.3.2.13 (2021-12-01)
        - updated to adjust for missing . in \(\d+ items displayed.\) for inventory full.
      0.3.2.12 (2021-11-14)
        - added export filename replacement keyword timestamp to be replaced with current timestamp
      0.3.2.11 (2021-11-13)
        - added export for sum bank, with target sbank,e.g. ;invdb export sbank
        - added export for sum tickets, with target stickets,e.g. ;invdb export stickets
        - switched peek_jar usage to peek_stack
      0.3.2.10 (2021-10-10)
        - disabling drop
        - added race and profession filter for querying characters
      0.3.2.1 (2020-09-03)
        - added Kraken's Fall bank
      0.3.2.0 (2020-09-03)
        - added Kraken's Fall locker
        - some merge logic updates
      0.3.1.9 (2020-06-15)
        - fix for locker info... again (?).
      0.3.1.8 (2020-05-23)
        - fix for user input confusion while getting inventory container
        - added hidden attribute for items (badges, soulstone, hairbeads, etc)
      0.3.1.7 (2020-04-21)
        - fix for feature concealing veils
      0.3.1.6 (2020-04-09)
        - fix for Vyrshkana's custom gameobj-data.xml file
      0.3.1.5 (2020-04-07)
        - added locker info fix for the warning when downgrading from premium to standard
        - added some basic callable methods for pass_thru and formatting output
      0.3.1.4 (2020-02-28)
        - added more logic to find area
        - fixed puts instead of gs_print
      0.3.1.2 (2019-12-01)
        - bugfix for miscounting items
      0.3.1.01 (2019-12-01)
        - messing with the exit conditions for dead LostRangers.
      0.3.1.0 (2019-11-21)
        - fix for missing lines in inventory full, credit to LostRanger: Script.current.downstream_buffer.instance_variable_set(:@max_size, 1000)
      0.3.0.9b (2019-11-16)
        - adjusted inv full regex
      0.3.0.9a (2019-11-16)
        - adjusted opening containers pattern for 'You pick at'
      0.3.0.8 (2019-11-16)
        - adjusted jarserve check to wait before opening containers
      0.3.0.7 (2019-11-13)
        - adjusted deplural for jar update
        - moved jarserve integration to only fire on inventory refresh instead of all the time
      0.3.0.6 (2019-11-13)
        - added jarserve2 wait and import
      0.3.0.5 (2019-11-11)
        - switch most of everything over to quiet_command to avoid squelching issues
        - add vacuum once every 12 hours (that's often, but it's quick -- and didn't help what I had hoped it would)
        - switched some variable (level,game) to XMLData instead of Char (infomon)
      0.3.0.4 (2019-09-24)
        - adjust already open pattern for 'doesn't seem to be any way...'
      0.3.0.3 (2019-09-21)
        - fixed count for f2p
      0.3.0.2
        - slowed down container actions on wizard
      0.3.0.1
        - added count action
      0.3.0.0
        - adjusted open/closing containers
      0.2.9.9 (2019-08-10)
        - query tickets (ticket_balance)
        - some stuff that isn't done yet
        - probably some other tweaks I forgot about
      0.2.9.8 (2019-06-27)
        - use inventory instead of inv to use commands in roundtime (per LostRanger tip)
      0.2.9.5 (2019-05-30)
        - container opening blacklist:
        - This is a global list, so you won't need to do the same containers on each character.
        - ;invdb --noopen <item name without long to add to noopen list>
        - ;invdb --open  <item name to remove from noopen list>
        - ;invdb --noopen
        - lists the containers on the noopen list
      0.2.9.4 (2019-05-26)
        - adjusted results highlight for regex searches
      0.2.9.3 (2019-05-26)
        - testing regex matching for items
        - multiple characters in search with pipe
      0.2.9 (2018-09-08)
        - open uncommon type for containers
        - stop opening my locket.
      0.2.8 (2018-08-31)
        - added inventory item counts to query character screen
        - changed character update to timestamp every update
      0.2.7 (2018-08-16)
        - just adding the fix for the change in collectibles
      0.2.6 (2018-08-08)
        - added more scripts for open/close checking
        - fixed untyped gems in jars with hyphens, untyped essences in jars
      0.2.5 (2018-08-05)
        - catch some additional open patterns
        - close containers before exit if failing to scrape
        - fix some options broken in prior update
      0.2.4 (2018-07-13)
        - removed other types from collectibles
        - wait until GameObjAdd etc is done
      0.2.3 (2018-07-08)
        - fix spacing issue with standard locker prename
        - made it easier to delete characters from the database
        - patched in collectible type
        - set type filter to have leading wildcard
      0.2.2 (2018-07-07):
        - fix rr / twilight locker inside the counter issue
      0.2.1 (2018-07-06):
        - fix safe puts for profanity
        - fix wizard fe output
        - break up help txt
      0.2.0 (2018-07-06):
        - added location filter, searches location name or abbr
        - game filter will now default to the current game (so gstest info doesn't get mixed in)
      0.1.9 (2018-07-05):
        - fixed stormfront inv window being empty after refresh
        - fixed jar issue on standard locker
        - fixed bank searching that I broke
        - improved profanity support (probably)
      0.1.8 (2018-07-01):
        - fixed not closing after opening secure gem pouches
        - started implementation of groupby
      0.1.7 (2018-06-29):
        - tweaked sql generation
        - added pivot columns for sum type=gem and reagent -- more for other stacks soon
        - started implementation of other stacks
        - started implementation of orderby
      0.1.6 (2018-06-29):
        - fix for startup abort to also accept delay parameter
        - cleanup some patterns, fixed locker bug?
        - fix premium 'you must visit your local locker' hanging
      0.1.5 (2018-06-28):
        - fix for peek_jar, now always includes a path
      0.1.4 (2018-06-28):
        - bugfix for :inv_full pattern
        - fix for export text/pipe
        - fix for only one bank account transfer stalling bank scrape
      0.1.3 (2018-06-27):
        - added option for sum|total. Like query, but aggregated
      0.1.2 (2018-06-26):
        - added abbreviation definitions before query output
        - made filters more flexible
      0.1.1 (2018-06-25):
        - Fixed some over squelching on premium accounts
        - Fixed profanity output
      0.1.0 (2018-06-22): Beta - first version on the repo
=end

  menu_width = 62 + (Script.current.name.length % 2 == 0 ? 0 : 1).to_i;
  help_hl = "  +#{"-" * menu_width}+";

  print_menu = proc {
    help_menu.gsub!('inv_db', Script.current.name);
    to_print = [];
    to_print << @mono_start;
    to_print << help_hl;
    center_spaces = " " * ((menu_width / 2) - (Script.current.name.length / 2)).to_i;
    to_print <<  "  |#{center_spaces}#{Script.current.name}#{center_spaces}|";
    to_print <<  help_hl;
    to_print <<  help_menu;
    to_print <<  help_hl;
    to_print <<  @mono_end;
    Inv_db.gs_print to_print.join("\n");
  }
  print_help = proc {
    help_text.gsub!(';inv', "#{$clean_lich_char}#{Script.current.name}");
    to_print = [];
    to_print << @mono_start;
    to_print << help_text;

    to_print << @mono_end;
    Inv_db.gs_print to_print.join("\n");
  };
  print_examples = proc {
    help_examples.gsub!(';inv', "#{$clean_lich_char}#{Script.current.name}");
    to_print = [];
    to_print << @mono_start;
    to_print << help_hl;
    to_print << help_examples;
    to_print << help_hl;
    to_print << @mono_end;
    Inv_db.gs_print to_print.join("\n");
  };
  print_changelog = proc {
    help_changelog.gsub!(';inv', "#{$clean_lich_char}#{Script.current.name}");
    to_print = [];
    to_print << @mono_start;
    to_print << help_hl;
    to_print << help_changelog;
    to_print << help_hl;
    to_print << @mono_end;
    Inv_db.gs_print to_print.join("\n");
  };
  (print_help.call; exit) if Script.current.vars[1] =~ /help|setup|\?/i;
  (print_menu.call; exit) if Script.current.vars[1] =~ /menu/i;
  (print_examples.call; exit) if Script.current.vars[1] =~ /examples/i;
  (print_changelog.call; exit) if Script.current.vars[1] =~ /changelog/i;
  #------------------------------------------------------------------------------#
  # startup delay for autostart
  # ;autostart add inv_db delay=6
  #------------------------------------------------------------------------------#
  startup_delay = ((Time.now - $login_time) < 12 ? 8 : 0);
  startup_delay = $2.to_i if Script.current.vars[0] =~ /\b(delay)=(\d+).*/i;
  _respond "invdb startup_delay = #{startup_delay}" if startup_delay > 0 && @debug;
  sleep startup_delay;

  if Script.current.vars[0] !~ /^[qcse]/ and Script.current.vars[0] !~ /\bchar\b/
    waiton_scripts = ["updater", "repository", "GameObjAdd", "GameObjAddMore", "xmlpatch", "box", "go2"]
    waiton_scripts.each { |s|
      if Script.running?(s)
        respond "Waiting for #{s} to finish"
        sleep 1 while Script.running?(s);
      end
    }
  end
  # sleep 1 while Script.running?("updater") || Script.running?("repository") || Script.running?("go2") || Script.running?("GameObjAdd") || Script.running?("GameObjAddMore") || Script.running?("xmlpatch") || Script.running?("box");
  #------------------------------------------------------------------------------#
  # start infomon if it's not running
  #------------------------------------------------------------------------------#
  Script.start('infomon') if !defined?(Infomon) && !running?('infomon');
  #------------------------------------------------------------------------------#
  # check conditions are conducive to running -- not dead/stunned/etc
  # for those who autostart
  #------------------------------------------------------------------------------#
  if XMLData.indicator["IconDEAD"] == "y" or dead? or stunned? or checkrt > 0;
    # should still be able to query and junk in roundtime or while dead
    if Script.current.vars[0] !~ /^[qcse]/ and Script.current.vars[0] !~ /\bchar\b/
      _respond "This seems like a bad time...";
      exit;
    end;
  end;
  #------------------------------------------------------------------------------#
  # for whatever reason, sometimes type_data is empty for some people
  #------------------------------------------------------------------------------#
  if GameObj.type_data.keys.length < 2 and File.exist?("#{$lich_dir}data/gameobj-data.xml");
    respond "Waiting for GameObj.type_data to finish loading."
    sleep 2
    if GameObj.type_data.keys.length < 2
      respond "Reloading GameObj.type_data."
      GameObj.load_data;
      sleep 1;
    end
  end;
  #------------------------------------------------------------------------------#
  # local variables
  #------------------------------------------------------------------------------#
  start_sorter = nil
  refresh_item = refresh_locker = refresh_inv = nil
  open_containers = close_containers = nil
  insert_temp_item_inv = insert_temp_item_locker = nil
  scan_parse_item_lines = nil
  locker = locker_info = locker_info_result = nil;
  @locker_info_run = false
  @locker_location = nil
  locker_item_capacity = locker_look_count = nil
  not_in_locker = true;
  locker_standard = locker_standard_debug = nil;
  locker_premium = nil
  locker_manifest_scrape = nil; parse_manifest = nil;
  scan_parse_item_lines = nil;
  table_format = table_hl = table_headers = nil
  action = target = nil
  input_params = character_filter = location_type_filter = nil
  style = nil
  item_path = nil
  match_fail_lines = []
  match_fail_count = 0
  db = nil
  #------------------------------------------------------------------------------#
  # variables
  #------------------------------------------------------------------------------#
  empty_string = String.new.encode('UTF-8')
  start_sorter = false
  sorter_handler = proc { (Script.kill("sorter"); wait_until { !running? "sorter" }; start_sorter = true;) if Script.running? "sorter" }
  sql = String.new.encode('UTF-8')
  
  @db_changes = Hash.new
  def self.db_changes;return @db_changes;end
  
  def self.db_changes_reset
    changes_template = { :inserted => 0, :updated => 0, :deleted => 0 }
    @db_changes = Hash.new
    @db_changes[:account]         = {}.merge(changes_template)
    @db_changes[:bank]            = {}.merge(changes_template)
    @db_changes[:bounty]          = {}.merge(changes_template)
    @db_changes[:tickets]         = {}.merge(changes_template)
    @db_changes[:char]            = {}.merge(changes_template)
    @db_changes[:item]            = {}.merge(changes_template)
    @db_changes[:item_categories] = {}.merge(changes_template)

    @db_changes[:resource]        = {}.merge(changes_template)
    @db_changes[:lumnis]          = {}.merge(changes_template)

    @db_changes[:room]            = {}.merge(changes_template)
    @db_changes[:room_object]     = {}.merge(changes_template)
    @db_changes[:room_inv]        = {}.merge(changes_template)
  end
  
  def self.db_changes_print();
    has_changes = 0
    @db_changes.each { |k, v|
      v.each { |_l, w|
        has_changes = w if w > has_changes
      } if k !~ /char/
    }
    Inv_db.gs_print "@action:#{@action.inspect} | has_changes:#{has_changes.inspect}" if @debug

    #if @action =~ /^(r|d|u|a|scan)/i && has_changes > 0
    if has_changes > 0
      rows = [["table", "inserted", "updated", "deleted"]]
      @db_changes.each { |k, v|
        rows << [k, v[:inserted], v[:updated], v[:deleted]] if v.values.max > 0
      }
      self.to_table(rows)
      self.db_changes_reset
    end
  end
  self.db_changes_reset

  #------------------------------------------------------------------------------#
  # Silencers/Squelchers
  #------------------------------------------------------------------------------#
  (@no_squelch = true;) if Script.current.vars[0] =~ /@no_?squelch/
  (@autofit = true;) if Script.current.vars[0] =~ /@autofit/
  @quiet = true; @quiet = false if @no_squelch;

  inv_open_close_squelch_pattern = /It appears to be locked|There doesn't seem to be any way to do that|^Try holding it first|You need to be holding|You are holding.*|You are wearing.*|You (open|close|push|pull|flip).*|^You absentmindedly fiddle with your|already open|open already|^You pick at the knot holding|^You tie your|^You carefully unwind|^You flip the cover|^Hooking a finger into|^Lightly brushing your fingers|^Brushing your fingers against|^Pinching the toggle|^As you reach for the flap|^You rub your hand across|^You focus for a moment/i

  squelch_remove = proc {
    respond "HookRemoved" if @debug_hook
    respond if @debug_hook
    DownstreamHook.remove('inv_db')
    sleep 0.05
  }

  squelch = proc { |squelch_pattern|
    respond "HookStart: #{squelch_pattern}" if @debug_hook
    respond if @debug_hook
    squelch_remove.call
    hook_action = proc { |server_string|
      next if server_string.strip.length == 0
      next if server_string =~ squelch_pattern
      server_string
    }
    DownstreamHook.add("inv_db", hook_action) if !@no_squelch
    sleep 0.05
    before_dying {
      squelch_remove.call
      start_script "sorter" if start_sorter
    }
  };

  # @patterns[:container_open] =
  @patterns = Hash.new
  @patterns[:bank]              = / *(?<bank>\w[^:]+): (?<amount>[,\d]+)/
  @patterns[:bank_single]       = /You currently have an account with the (?<bank>.*?) in the amount of (?<amount>[,\d]+) silver/i
  @patterns[:bank_transfers]    = /You currently have (?<transfers>[,\d]+) inter-town bank transfer options? available/i
  @patterns[:bank_break]        = /You currently have (?<transfers>[,\d]+) inter-town bank transfer options? available/i
  @patterns[:bank_f2p]          = /You can deposit up to a maximum of (?<max>[,\d]+)/i
  @patterns[:bank_none]         = /You haven't opened a bank account yet/
  @patterns[:debt]              = /In the back of your mind you remember you owe a debt of (?<debt>[,\d]+) silvers? in the town of (?<town>.*)\./

  @patterns[:inv_count]         = /\((?:Items: )?(?<count>\d+)(?: items? displayed.?)?\)|^You have nothing|^You are carrying nothing/
  @patterns[:inv_look]          = /(?:(?:Peering into|[IO]n) .* <a exist="(-?\d+)"[^>]*>([^<]*)<\/a>,? you see )|(?:[OI]n the <a exist="(-?\d+)"[^>]*>([^<]*)<\/a>:\s*$)|There is nothing [io]n there|That is closed.|I could not find what you were referring to\./
  @patterns[:inv_break]         = /\((?:Items: )?(?<count>\d+)(?: items? displayed.?)?\)|Obvious items?: *(?<count>\d+)|^Your locker is currently holding (?<count>\d+) items? out of a maximum of (?<locker_max>\d+)|^You have nothing|^You are carrying nothing/
  #@patterns[:inv_start]        = /You are (carrying|currently|holding|wearing|currently mounted)/
  @patterns[:inv_start]         = /^(?:<popBold\/>)?(?:You are currently (?:wearing and )?(?:carrying)?(?:(?!, which conceals).)+$|^(?:<popBold\/>)?You are carrying nothing at this time|^(?:<popBold\/>)?You are holding)|^You currently have placed alongside you|^You have nothing placed alongside you.|That's not a valid option|^You are currently mounted on/
  @patterns[:inv_full]          = /^(?<depth> +)(?:<pushBold\/>)?(?<pre>[^<]+)? ?<a exist="(?<exist>-?\d+)" noun="(?<noun>[^"]*?)">(?<name>[^<]*?)<\/a>(?:<popBold\/>)?(?<post>[^\(\r\n]*)?(?<attrs>\(.*)?/i
  @patterns[:inv_full_noxml]    = /^(?<depth> +)(?<name>[^\(]+?)(?<attrs>\(.*)?$/
  @patterns[:jar]               = /^Inside the (?<pre>.*?)<a exist="(?<exist>-?\d+)" noun="(?<noun>[^"]*)">[^<]*<\/a>.*? you see (?<count>\d+) portions? of (?<name>.*?)\. *It is (?<stack_status>.*?)\./i
  @patterns[:jar_simple]        = /^Inside the .*? you see (?<amount>\d+) portions? of .*?\. *It is (?<stack_status>.*?)\./

  @patterns[:locker_info]       = /You possess locker(?<multi>s)|Your locker(?<multi>s)? in .* are currently being swapped|Your locker is currently located in the town of (?<town>.*?)\.|Your locker(?<town> )/
  @patterns[:locker_open]       = /Your locker is currently holding (?<count>[,\d]+) items? out of a maximum of (?<max>[,\d]+)|That is already open/
  @patterns[:locker_count]      = /Your locker is currently holding (?<count>[,\d]+) items? out of a maximum of (?<locker_max>[,\d]+)/

  @patterns[:locker_container]  = /[IO]n a.*?(?:armor|weapon|clothing|deep|magical item) (?<noun>stand|rack|wardrobe|chest|bin)/i
  @patterns[:manifest_count]    = /Obvious items?: *(?<count>\d+)/
  @patterns[:manifest_break]    = /Obvious items?: *(?<count>\d+)|You must have a Premium subscription|There are no items in this locker|Your lockers in .*?are currently being swapped|You must first visit your local locker before using the LOCKER MANIFEST command in this town./
  @patterns[:manifest_start]    = /^Thinking back, you recall|^Looking in front of you, you see the contents of your locker/
  @patterns[:manifest_inside]   = /^(?:<popBold\/>)?(?<depth> +)(?<pre>[^<]+ ?)?<a exist="(?<exist>-?\d+)" noun="(?<noun>[^"]*)">(?<name>[^<]*)<\/a>(?<post>[^\(]*)?(?<attrs>\(.*)?/
  @patterns[:manifest_outside]  = /^(?:<popBold\/>)?(?<depth> <d.*?d> +|  +)(?<pre>an |a )?(?<name>[^\(]*?)(?:containing (?<post>[^\(]*?))?(?<attrs>\(.*)?$/
  @patterns[:manifest]          = Regexp.union(@patterns[:manifest_outside], @patterns[:manifest_inside])

  @patterns[:glance_right]      = /see (?:an? |some )?(?<before_name>.*?)?<a exist="(?<id>-?\d+)" noun="(?<noun>[^"]+)">(?<link_name>.*?)<\/a>(?<after_name>.*?)?(?: containing.*?)? in your right hand/
  
  @patterns[:container_list]    = /<a exist="(?<id>\d+)" noun="(?<noun>[^"]+)">(?<link_name>[^<]+)</;
  
  #------------------------------------------------------------------------------#
  # sqlite version check
  #------------------------------------------------------------------------------#
  # sqlite_version = Inv_db.sqlite_version
  # if Gem::Version.new(sqlite_version) < Gem::Version.new('3.8.3')
  #  Inv_db.gs_print "#{Script.current.name} requires sqlite_version: 3.8.3+ ... exiting"
  #  exit
  # end
  db = Inv_db.open();
  #------------------------------------------------------------------------------#
  # Reset / Drop tables
  #------------------------------------------------------------------------------#
  def self.drop_tables(target = nil)
    db = Inv_db.open();
    begin
      (db.execute("drop table if exists silver");) if target =~ /bank|all/
      (db.execute("drop table if exists bank");) if target =~ /bank|all/
      (db.execute("drop table if exists bounty");) if target =~ /bounty|all/
      (db.execute("drop table if exists tickets");) if target =~ /tickets|all/
      (db.execute("drop table if exists location");) if target =~ /all/i

      (db.execute("drop table if exists old_item");) if target =~ /all|items?/
      (db.execute("drop table if exists item_detail");) if target =~ /items?$|item_detail|all/
      (db.execute("drop table if exists char_inventory");) if target =~ /items?$|all/
      (db.execute("drop table if exists item");) if target =~ /items$|all/i

      (db.execute("drop table if exists room_inventory");) if target =~ /room_inventory|all/
      (db.execute("drop table if exists room_object");) if target =~ /room_object|all/
      (db.execute("drop table if exists room");) if target =~ /room$|all/

      # (db.execute("drop table if exists boost") ;) if target =~ /all|boost/
      # (db.execute("drop table if exists collectible") ;) if target =~ /all|collectible/
      # (db.execute("drop table if exists feature") ;) if target =~ /all|feature/
      # (db.execute("drop table if exists info") ;) if target =~ /all|info/
      # (db.execute("drop table if exists profile") ;) if target =~ /all|profile/
      # (db.execute("drop table if exists simucoin") ;) if target =~ /all|simucoin/
      # (db.execute("drop table if exists skill") ;) if target =~ /all|skill/

      (db.execute("drop table if exists resource");) if target =~ /all|resource/
      (db.execute("drop table if exists lumnis");) if target =~ /all|lumnis/
      (db.execute("drop table if exists character");) if target =~ /all/i
      (db.execute("drop table if exists account");) if target =~ /all|account/

      db.execute('pragma user_version=0')
      # clear values in instance variables
      Inv_db.instance_variables.each do |i|
        Inv_db.remove_instance_variable(i)
      end
    rescue SQLite3::BusyException
      sleep 0.1
      retry
    ensure
      db.close() if db;
    end
    Inv_db.gs_print Inv_db.format_monsterbold(target == "all" ? "#{@db_name} database reset." : "#{target} table(s) dropped")
    exit
  end;
  #------------------------------------------------------------------------------#
  # schema
  #   todo: db.execute_batch instead? => didn't work as expected
  #   todo: database and schema versioning => upgrade/alter handling
  #------------------------------------------------------------------------------#
  user_version = db.get_first_value('pragma user_version;')

  if user_version == 0
    begin
      sql = %{
      create table if not exists character (
          id            integer not null primary key autoincrement
        , name          text    not null            --# XMLData.name
        , game          text    not null default '' --# XMLData.game
        , account       text    not null default '' --#
        , prof          text    not null default '' --# Stats.prof
        , race          text    not null default '' --# Stats.race
        , level         integer not null default 0  --# XMLData.level.to_i
        , exp           integer not null default 0  --# Stats.exp
        , area          text    not null default '' --# Room.current.location
        , subscription  text    not null default '' --# from locker info
        , locker        text    not null default '' --# from locker info
        , citizenship   text    not null default '' --# Char.citizenship
        , society       text    not null default '' --# Society.status
        , society_rank  text    not null default '' --# Society.rank
        , timestamp     integer not null default 0
        , unique (name,game)
      );};
      db.execute(sql)

      sql = %{
      create table if not exists bank (
          id      integer not null primary key autoincrement
        , name    text    not null unique
        , abbr    text    not null unique
      );};
      db.execute(sql)

      sql = %{
        with defaults(id,name,abbr) as (values
           (1, 'First Elanith Secured Bank'   ,'wl')
          ,(2, 'Great Bank of Kharam-Dzu'     ,'teras')
          ,(3, 'Vornavis Bank of Solhaven'    ,'sol')
          ,(4, 'Bank of Torre County'         ,'rr')
          ,(5, 'Icemule Trace Bank'           ,'im')
          ,(6, 'Bank of Kharag ''doth Dzulthu','zul')
          ,(7, 'United City-States Bank'      ,'en')
          ,(8, 'Four Winds Bank'              ,'fwi')
          ,(9, 'Cysaegir Bank'                ,'cy')
          ,(11,'Kraken''s Fall Bank'          , 'kf')
          ,(99,'Total'                        ,'total')
        )
        insert into bank(id,name,abbr)
        select id,name,abbr
        from defaults d
        where not exists (
          select 1
          from bank b
          where b.name = d.name
        )
        order by id;
      };
      db.execute(sql)

      sql = %{
      create table if not exists silver (
          character_id integer not null references character(id)
        , bank_id      integer not null references bank(id)
        , amount       integer not null
        , timestamp    integer not null
        , unique (character_id, bank_id)
      );};
      db.execute(sql)

      sql = %{
      create table if not exists location (
          id      integer not null primary key
        , type    text    not null
        , name    text    not null unique
        , abbr    text    not null unique
      );};
      db.execute(sql)

      sql = %{
        with defaults(id,type,name,abbr) as (values
           (1 ,'inv'   ,'hands'              ,'hands')
          ,(2 ,'inv'   ,'inv'                ,'inv')
          ,(6 ,'inv'   ,'alongside'          ,'alongside')
          ,(10,'locker','locker'             ,'locker')
          ,(11,'locker','Wehnimer''s Landing','wl')
          ,(12,'locker','Teras Isle'         ,'teras')
          ,(13,'locker','Solhaven'           ,'sol')
          ,(14,'locker','River''s Rest'      ,'rr')
          ,(15,'locker','Icemule Trace'      ,'im')
          ,(16,'locker','Zul Logoth'         ,'zul')
          ,(17,'locker','Ta''Illistim'       ,'ti')
          ,(18,'locker','Ta''Vaalor'         ,'tv')
          ,(19,'locker','Mist Harbor'        ,'fwi')
          ,(20,'locker','Cysaegir'           ,'cy')
          ,(21,'locker','Kraken''s Fall'     ,'kf')
          ,(30,'locker','Astral Vault'       ,'av')
          ,(40,'locker','Family Vault'       ,'fam')
        )
        insert into location(id,type,name,abbr)
        select id,type,name,abbr
        from defaults d
        where not exists (
          select 1
          from location l
          where l.name = d.name
            or l.id = d.id
        )
        order by id
      };
      db.execute(sql)

      sql = %{
      create table if not exists item (
          character_id   integer not null references character(id)
        , location_id    integer not null references location(id)
        , level          integer not null default 0
        , path           text    not null default ''
        , type           text    not null default ''
        , name           text    not null
        , noun           text    not null default ''
        , amount         integer not null
        , stack          text    not null default ''
        , status         text    not null default ''
        , marked         text    not null default ''
        , registered     text    not null default ''
        , worn           text    not null default ''
        , hidden         text    not null default ''
        , timestamp      integer not null
        , unique(name, character_id, location_id, path, stack, status, marked, registered)
      );};
      self.execute(sql,)

      sql = "create index if not exists ix_item_name on item(name);";
      db.execute(sql)

      respond "initial schema confirmed" if @debug
    rescue SQLite3::BusyException
      sleep 0.1
      retry
    end
    db.execute('pragma user_version=1')
    user_version = db.get_first_value('pragma user_version;')
  end

  if user_version == 1
    db.execute('pragma user_version=2');
    user_version = db.get_first_value('pragma user_version;')
  end;

  if user_version == 2
    sql = %{
    create table if not exists tickets (
        character_id   integer not null
      , source         text    not null
      , amount         integer not null
      , currency       text    not null
      , timestamp      integer not null
      , unique(character_id, source)
    );};
    db.execute(sql)

    db.execute('pragma user_version=3')
    user_version = db.get_first_value('pragma user_version;')
  end

  if user_version == 3
    if !db.execute2("select * from item limit 0")[0].include?("hidden")
      sql = "alter table item add column hidden text default ''"
      db.execute(sql)
    end
    db.execute('pragma user_version=4')
    user_version = db.get_first_value('pragma user_version;')
  end

  if user_version == 4
    sql = %{
        with defaults(id,type,name,abbr) as (values
          (21,'locker','Kraken''s Fall'      ,'kf')
        )
        insert into location(id,type,name,abbr)
        select id,type,name,abbr
        from defaults d
        where not exists (
          select 1
          from location l
          where l.name = d.name or l.id = d.id
        )
        order by id
      };
    db.execute(sql)
    db.execute('pragma user_version=5')
    user_version = db.get_first_value('pragma user_version;')
  end

  if user_version == 5
    sql = %{
        with defaults(id,name,abbr) as (values
          (11,'Kraken''s Fall Bank', 'kf')
        )
        insert into bank(id,name,abbr)
        select id,name,abbr
        from defaults d
        where not exists (
          select 1
          from bank b
          where b.name = d.name or b.id = d.id
        )
        order by id;
      };
    db.execute(sql)
    sql = "update bank set id = 99 where name='Total'"
    db.execute(sql)
    db.execute('pragma user_version=6')
    user_version = db.get_first_value('pragma user_version;')
  end

  if user_version == 6
    sql = "delete from location where id >= 20"
    db.execute(sql)
    sql = %{
        with defaults(id,type,name,abbr) as (values
          (20,'locker','Cysaegir'      ,'cy'),
          (21,'locker','Kraken''s Fall'      ,'kf')
        )
        insert into location(id,type,name,abbr)
        select id,type,name,abbr
        from defaults d
        where not exists (
          select 1
          from location l
          where l.name = d.name or l.id = d.id
        )
        order by id
      };
    db.execute(sql)
    db.execute('pragma user_version=7')
    user_version = db.get_first_value('pragma user_version;')
  end

  if user_version == 7
    sql = %{
      with defaults(id,type,name,abbr) as (values (6 ,'inv' ,'alongside' ,'alongside'))
      insert into location(id,type,name,abbr)
      select id,type,name,abbr
      from defaults d
      where not exists (
        select 1
        from location l
        where l.name = d.name
      )
    };
    db.execute(sql)
    db.execute('pragma user_version=8')
    user_version = db.get_first_value('pragma user_version;')
  end

  if user_version == 8
    db.execute("delete from location where abbr in ('av','fam')")
    sql = %{
      with defaults(id,type,name,abbr) as (values
          (30,'locker' ,'Astral Vault' ,'av')
         ,(40,'locker' ,'Family Vault' ,'fam')
        )
      insert into location(id,type,name,abbr)
      select id,type,name,abbr
      from defaults d
      where not exists (
        select 1
        from location l
        where l.id = d.id
      )
    };
    db.execute(sql)

    if !db.execute2("select * from character limit 0")[0].include?("subscription")
      db.execute("alter table character rename to old_character_table")
      sql = %{
        create table if not exists character (
          id            integer not null primary key autoincrement
        , name          text    not null            --# XMLData.name
        , game          text    not null default '' --# XMLData.game
        , account       text    not null default '' --# Account.name or account_verb
        , prof          text    not null default '' --# Stats.prof
        , race          text    not null default '' --# Stats.race
        , level         integer not null default 0  --# XMLData.level.to_i
        , exp           integer not null default 0  --# Stats.exp
        , area          text    not null default '' --# Room.current.location
        , subscription  text    not null default '' --# Account.subscription or locker info
        , locker        text    not null default '' --# from locker info # for non premium
        , timestamp     integer not null default 0
        , unique (name,game)
      );};
      db.execute(sql)
      sql = %{
        insert into character(id, name, game, account, prof, race, level, exp, area, subscription, locker, timestamp)
        select id, name, game, '', prof, race, level, exp, area, account_type, locker, timestamp from old_character_table
      }
      db.execute(sql)
      db.execute("drop table old_character_table")
    end

    db.execute('pragma user_version=9')
    user_version = db.get_first_value('pragma user_version;')
  end

  if user_version == 9
    respond "Updating database schema"
    sql = %{
        create table if not exists lumnis (
          character_id integer  not null primary key references character(id)
        , status        text    not null default ''
        , triple        text    not null default 0
        , double        text    not null default 0
        , total         text    not null default 0
        , start_day     text    not null default ''
        , start_time    text    not null default ''
        , last_schedule text    not null default ''
        , timestamp     integer not null default 0
      );};
    db.execute(sql)

    sql = %{
        create table if not exists resource (
          character_id  integer not null primary key references character(id)
        , energy        text    not null default ''
        , weekly        integer not null default 0
        , total         integer not null default 0
        , suffused      integer not null default 0
        , favor         integer not null default 0
        , bonus         integer not null default 0
        , timestamp     integer not null default 0
      );};
    db.execute(sql)

    sql = %{
        create table if not exists account (
          account        text    not null primary key
        , premium_points integer not null default 0
        , simucoin       integer not null default 0
        , timestamp      integer not null default 0
      );};
    db.execute(sql)

    db.execute("alter table character add citizenship text not null default ''")  if !db.execute2("select * from character limit 0")[0].include?("citizenship")
    db.execute("alter table character add society text not null default ''")      if !db.execute2("select * from character limit 0")[0].include?("society")
    db.execute("alter table character add society_rank text not null default ''") if !db.execute2("select * from character limit 0")[0].include?("society_rank")

    db.execute('pragma user_version=10')
    user_version = db.get_first_value('pragma user_version;')
  end

  if user_version == 10
    if !db.execute2("select * from item limit 0")[0].include?("game")
      sql = "drop table if exists old_item"
      self.execute(sql, {}, db)
      sql = "alter table item rename to old_item"
      self.execute(sql, {}, db)
    end
    sql = %{
    create table if not exists item (
        id        integer not null primary key autoincrement
      , name      text not null
      , noun      text not null default ''
      , link_name text not null default ''
      , type      text not null default 'unknown'
      , category  text not null default ''
      , game      text not null default ''
      , unique(name, game)
    );};
    self.execute(sql, {}, db)

    sql = %{
    create table if not exists item_detail (
        item_id     integer not null primary key --autoincrement
      , note        text not null default ''
      , inspect     text not null default ''
      , analyze     text not null default ''
      , look        text not null default '' --# requires special handling because usually no links (some do like fusion)
      , label       text not null default ''
      , read        text not null default '' --# no scrolls
      , recall      text not null default '' -- anyone recall quick
      , loresong    text not null default ''
      , assess      text not null default '' -- warriors
      , elemental   text not null default '' --# 405
      , charge      text not null default '' --# inventory enhancive list?
      , script      text not null default ''
      , constraint fk_item_detail_item_id foreign key (item_id) references item(id) on delete cascade
    );};
    self.execute(sql, {}, db)

    sql = %{
    create table if not exists char_inventory (
        id             integer not null primary key autoincrement
      , character_id   integer not null
      , location_id    integer not null
      , item_id        integer not null
      , containing     text    not null default ''
      , path           text    not null default ''
      , level          integer not null default 0
      , amount         integer not null default 1
      , stack          text    not null default ''
      , stack_status   text    not null default '' --# stack_status
      , marked         text    not null default ''
      , registered     text    not null default ''
      , hidden         text    not null default ''
      , timestamp      integer not null
      , unique(character_id, location_id, item_id, containing, path, stack, stack_status, marked, registered, hidden)
      , constraint fk_inventory_character_id foreign key (character_id) references character(id) on delete cascade
      , constraint fk_inventory_location_id foreign key (location_id) references location(id) on delete cascade
      , constraint fk_inventory_item_id foreign key (item_id) references item(id) on delete cascade
    );};
    self.execute(sql, {}, db)

    sql = %{
    create table if not exists room (
        id          integer not null primary key autoincrement
      , uid         integer not null
      , lich_id     integer null
      , property    text not null default ''
      , nickname    text not null default ''
      , title       text not null default ''
      , game        text not null default ''
      , unique (uid, game)
    );};
    self.execute(sql, {}, db)

    sql = %{
    create table if not exists room_object(
        id           integer not null primary key autoincrement
      , room_id      integer not null
      , object       text not null
      , prepositions text not null default 'in,on,under,behind'
      , depth        integer not null default 2
      , special      text not null default '' --# moardrobe?
      , unique(room_id, object)
      , constraint fk_room_object_uid foreign key (room_id) references room(id) on delete cascade
    );};
    self.execute(sql, {}, db)

    sql = %{
    create table if not exists room_inventory(
        id                integer not null primary key autoincrement
      , room_object_id    integer not null
      , item_id           integer not null
      , containing        text    not null default ''
      , path              text    not null default ''
      , level             integer not null default 0
      , amount            integer not null default 1
      , stack             text    not null default ''
      , stack_status      text    not null default ''
      , timestamp         integer not null
      , unique(room_object_id, item_id, path, containing, stack, stack_status)
      , constraint fk_room_object_id foreign key (room_object_id) references room_object(id) on delete cascade
      , constraint fk_room_inventory_item_id foreign key (item_id) references item(id) on delete cascade
    );};
    self.execute(sql, {}, db)

    if db.get_first_value("select 1 from sqlite_master where tbl_name ='old_item'") == 1
      cte_sql = %{
      with cte as (
      select
        ltrim(rtrim(case
          when instr(o.name,'(') > 0 then ltrim(substr(o.name, 0, instr(o.name,'(')))
          when instr(o.name,'containing') > 0 then ltrim(substr(o.name, 0, instr(o.name,'(')))
          else o.name
        end)) as name
        , max(case when o.noun = 'lapis lazuli' then 'lapis' else o.noun end) as noun
        , max(o.type) as type
        , c.game
        , case when location_id < 11 then 1 else 0 end as update_noun
      from (
        select
            replace(replace(name,substr(name,instr(name,'<'),instr(name,'\">')+1),''),'</a>','') as name
           , noun
           , type
           , location_id
           , character_id
        from old_item
        ) o
        inner join character c on c.id = o.character_id
      group by
          ltrim(rtrim(case
            when instr(o.name,'(') > 0 then ltrim(substr(o.name, 0, instr(o.name,'(')))
            when instr(o.name,'containing') > 0 then ltrim(substr(o.name, 0, instr(o.name,'(')))
            else o.name
          end))
        , case when location_id < 11 then 1 else 0 end
        , c.game
      )}
      sql = %{
      insert into item(name, noun, type, game)
      select
        o.name, o.noun, o.type, o.game
      from cte o
      where o.update_noun = 1
        and not exists (select 1 from item i where i.name = o.name and i.game = o.game)
      order by o.game, o.name
      };
      self.execute(cte_sql + sql, {}, db)

      sql = %{
      insert into item(name, type, game)
      select
        o.name, o.type, o.game
      from cte o
      where o.update_noun = 0
        and not exists (select 1 from item i where i.name = o.name and i.game = o.game)
      order by o.game, o.name

      };
      self.execute(cte_sql + sql, {}, db)

      sql = %{
      with cte as (
      select
        o.character_id, o.location_id, o.level, o.path, o.amount, o.stack, o.status, o.marked, o.registered, o.hidden, o.timestamp
        , case
          when instr(o.name,'(') > 0 then ltrim(substr(o.name, 0, instr(o.name,'(') > 0))
          when instr(o.name,'containing') > 0 then ltrim(substr(o.name, 0, instr(o.name,'(') > 0))
          else o.name end as name
        , case
          when instr(o.name,'(') > 0 then ltrim(substr(o.name, instr(o.name,'(') > 0))
          when instr(o.name,'containing') > 0 then ltrim(substr(o.name, instr(o.name,'(') > 0))
          else '' end as containing
      from (
        select
            replace(replace(name,substr(name,instr(name,'<'),instr(name,'\">')+1),''),'</a>','') as new_name
           , oi.*
        from old_item oi
        ) o
      )
      insert into char_inventory(character_id, location_id, item_id, level, path, containing, amount, stack, stack_status, marked, registered, hidden, timestamp)
      select o.character_id, o.location_id, i.id, o.level, o.path, o.containing, sum(o.amount), o.stack, o.status, o.marked, o.registered, o.hidden, o.timestamp
      from cte o
        inner join character c on c.id = o.character_id
        inner join item i on i.game = c.game and i.name = o.name
      where not exists (select 1 from char_inventory v where v.character_id = o.character_id)
      group by o.character_id, o.location_id, i.id, o.level, o.path, o.containing, o.stack, o.status, o.marked, o.registered, o.hidden, o.timestamp
      order by c.id, o.location_id, o.path, i.id
      };
      self.execute(sql, {}, db)
      # db.execute("drop table old_item")
      db.execute("VACUUM")
      Settings["last_vacuum"] = Time.now;
      Settings.save;
    end
    db.execute('pragma user_version=11')
    user_version = db.get_first_value('pragma user_version;')
  end
  ####
  #
  #
  #
  ###
  if user_version == 11 
    
    sql = %{
    create table if not exists bounty (
        character_id   integer not null primary key
      , type           text    not null default '' -- # from Bounty module
      , area           text    not null default '' -- # :area or :town
      , requirements   text    not null default '' -- # summary from requirements 
      , task           text    not null default '' -- # XMLData.bounty_task
      , timestamp      integer not null default 0
      , unique(character_id)
      , constraint fk_bounty_character_id foreign key (character_id) references character(id) on delete cascade
    );};
    self.execute(sql, {}, db)
   
    db.execute('pragma user_version=12')
    user_version = db.get_first_value('pragma user_version;')
  end
  
 if 1 == 0 and user_version == 12
    
    sql = %{
      create table if not exists last_refresh (
          id             integer not null primary key autoincrement
        , character_id   integer not null
        , target         text    not null
        , unique(character_id, target)
        , constraint fk_last_refresh_character_id foreign key (character_id) references character(id) on delete cascade
      );};
      self.execute(sql, {}, db)
      

    # db.execute('pragma user_version=13')
    # user_version = db.get_first_value('pragma user_version;')
  end
  # if user_version == 13
    # db.execute('pragma user_version=14')
    # user_version = db.get_first_value('pragma user_version;')
  # end
  #------------------------------------------------------------------------------#
  # temp tables for refresh
  #------------------------------------------------------------------------------#
  if user_version
    sql = %{
    create temporary table if not exists temp_item (
        character_id   integer not null references character(id)
      , location_id    integer not null references location(id)
      , level          integer not null default 0
      , path           text    not null default ''
      , type           text    not null default ''
      , name           text    not null
      , link_name      text    not null default ''
      , containing     text    not null default ''
      , noun           text    not null default ''
      , amount         integer not null
      , stack          text    not null default ''
      , stack_status   text    not null default ''
      , marked         text    not null default ''
      , registered     text    not null default ''
      , hidden         text    not null default ''
      , update_noun    int     not null default 0
      , gs_id          int     null
      , timestamp      integer not null
      --, unique(name, character_id, location_id, path, marked, registered, hidden)
    );}
    db.execute(sql)

    sql = %{
    create temporary table if not exists temp_item_category (
        name     text not null primary key
      , category text not null
      , game     text not null
    );}
    db.execute(sql)

    sql = %{
    create temporary table if not exists temp_room_item (
        room_object_id   integer not null references room_object(id)
      , path             text    not null default ''
      , level            integer not null default 0
      , type             text    not null default ''
      , name             text    not null
      , link_name        text    not null default ''
      , containing       text    not null default ''
      , noun             text    not null default ''
      , amount           integer not null
      , stack            text    not null default ''
      , stack_status     text    not null default ''
      , update_noun      ineger  not null default 0
      , gs_id            int     null
      , timestamp        integer not null
      --, unique(room_object_id, path, type, name)
    );}
    db.execute(sql)
  end

  #------------------------------------------------------------------------------#
  # deletes
  #------------------------------------------------------------------------------#
  def self.bank_delete(db = nil, params = [])
    @calling_proc = @current_proc
    @current_proc = "delete_bank"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    _where, qargs, _extras = self.where_builder(params,'bank',false,'delete')
    sql = %{
      delete from silver
      where character_id = (
        select id
        from character
        where name like :character_filter
          and game like :game_filter
        )
    }
    _rows, changes = self.execute(sql, qargs, db)
    @db_changes[:bank][:deleted] += changes
  end

  def self.item_delete(db = nil, params = [])
    @calling_proc = @current_proc
    @current_proc = "delete_char_inventory"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    _where, qargs, _extras = self.where_builder(params,'char_inventory',false,'delete')
    sql = %{
    delete from char_inventory}
    if qargs
      sql += "\n    where 1=1"
      sql += "\n      and exists ( select 1 from character c where char_inventory.character_id = c.id " if qargs[:character_filter] || qargs[:game_filter]
      sql += "\n        and c.name like :character_filter" if qargs[:character_filter] && !qargs[:char_array]
      sql += "\n        and c.name in ('#{qargs[:char_array].join("','")}')" if qargs[:char_array]
      sql += "\n        and c.game like :game_filter " if qargs[:game_filter]
      sql += "\n      )"                              if qargs[:character_filter] || qargs[:game_filter]

      sql += "\n      and exists ( select 1 from location l where char_inventory.location_id = l.id " if qargs[:location_type_filter]
      sql += "\n        and l.type like :location_type_filter" if qargs[:location_type_filter]
      sql += "\n      )" if qargs[:location_type_filter]

      sql += "\n      and char_inventory.amount #{qargs[:amount_filter]}" if qargs[:amount_filter]
      sql += "\n      and char_inventory.path like :path_filter " if qargs[:path_filter]

      if !(qargs.keys & [:type_filter, :noun_filter, :search_filter]).empty?
        sql += "\n      and exists (select 1 from item i where i.id = char_inventory.item_id"
        sql += "\n        and char_inventory.type like :type_filter"   if qargs[:type_filter]
        sql += "\n        and char_inventory.noun like :noun_filter"   if qargs[:noun_filter]
        sql += "\n        and char_inventory.name like :search_filter" if qargs[:search_filter]
        sql += "\n     )"
      end
      sql += "\n      and char_inventory.stack like :stack_filter" if qargs[:stack_filter]
      sql += "\n      and char_inventory.stack_status like :stack_status_filter" if qargs[:stack_status_filter]
      sql += "\n      and char_inventory.marked like :marked_filter" if qargs[:marked_filter]
      sql += "\n      and char_inventory.registered like :registered_filter" if qargs[:registered_filter]
    end
    _rows, changes = self.execute(sql, qargs, db)
    @db_changes[:item][:deleted] += changes
  end

  def self.character_delete(db = nil, params = [])
    @calling_proc = @current_proc
    @current_proc = "character_delete"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    _where, qargs, _extras = self.where_builder(params,'character',false,'delete')
    sql = %{
    delete from character
    where name like :character_filter
      and game like :game_filter}
    _rows, changes = self.execute(sql, qargs, db)
    @db_changes[:char][:deleted] += changes
  end

  #------------------------------------------------------------------------------#
  # account
  #------------------------------------------------------------------------------#

  def self.account_get()
    if defined?(Account)
      @account_name = Account.name if Account.name.to_s.length > 2
      @subscription = Account.subscription.downcase
      @subscription = 'f2p' if @subscription =~ /^free/i
      @subscription = 'premium' if @subscription =~ /internal/i
      @locker_location = 'multi' if @subscription == 'premium'
    end
    if @account_name.nil? or @subscription.nil?
      @account_name, @subscription = self.account_verb
    end
    return @account_name.capitalize.encode('UTF-8'), @subscription.downcase.encode('UTF-8')
  end

  def self.account_lookup(db = nil, name = nil, game = nil)
    close_db = false
    (close_db = true; db = Inv_db.open) if db.nil?
    name = XMLData.name if name.nil?
    game = XMLData.game if game.nil?
    qargs = { :name => name.encode('UTF-8'), :game => game.encode('UTF-8') }
    sql = %{ select account, subscription from character where name = :name and game = :game limit 1 }
    account_name, subscription = self.execute2(sql, qargs, db)[1]
    db.close if close_db
    return account_name, subscription
  end

  def self.account_verb();
    command       = "account";
    start_pattern = /^<pushBold\/>(?:Game|^Account)/i
    data          = self.client_command(command, start_pattern);
    account_name, subscription, instance = nil
    data.each { |l|
      a = l.split(/<popBold\/> */)
      instance = a.last.downcase if a.first =~ /Game Instance/
      account_name = a.last if a.first =~ /Account Name/
      subscription = a.last if a.first =~ /Account Type|Subscription/
    }
    return account_name, subscription
  end;

  #------------------------------------------------------------------------------#
  # character
  #   todo: Soliere wants all the things (stats,skills,profile,society)
  #------------------------------------------------------------------------------#
  def self.current_area();
    current_area = nil
    if !Room.current.id.nil?;
      if !Room.current.location.nil?;
        current_area = Room.current.location.to_s;
      else; # room not tagged with location
        current_area = "#{Room[Room.current.find_nearest_by_tag("town")].location}";
      end;
    else; # unmapped room
      if XMLData.room_window_disabled == false and GameObj.pcs.size < 3
        location_result = dothistimeout 'location', 1, /^You carefully survey your surroundings and guess that your current location is (.*?) or somewhere close to it\.$|^You can't do that while submerged under water\.$|^You can't do that\.$|^It would be rude not to give your full attention to the performance\.$|^You can't do that while hanging around up here!$|^You are too distracted by the difficulty of staying alive in these treacherous waters to do that\.$|^You carefully survey your surroundings but are unable to guess your current location\.$|^Not in pitch darkness you don't\.$|^That is too difficult to consider here\.$/
        if location_result =~ /^You carefully survey your surroundings and guess that your current location is (.*?) or somewhere close to it\.$/
          current_area = $1
        end
      end
    end;
    current_area = current_area.gsub(/(the )?(town|hamlet|city|village|plains|free port|lowlands|tunnels and caverns|foothills|holdings|southern part|northern slopes|northern reaches|environs|somewhere)( o[fn] )?|,.*$|^the /i, "").encode('UTF-8')
    current_area = "unknown" if current_area.nil?
    return current_area;
  end
  
  def self.citizenship_info
    if defined?(Char.citizenship)
      (fput "citizen";sleep 1) if Char.citizenship.nil?
      citizenship = Char.citizenship
    else
      citizenship = "error"
    end
    return citizenship;
  end

  def self.society_info
    societies = {
      "Council of Light"     => "CoL",
      "Order of Voln"        => "Voln",
      "Guardians of Sunfist" => "GoS",
      "None"                 => "none"
    }
    society_status = (defined?(Society.status) ? Society.status : "")
    society = societies[society_status] if !Society.status.nil?
    society = society_status if society.nil?
    society_rank = (defined?(Society.rank) ? Society.rank : "")
    return society.encode('UTF-8'), society_rank.to_s.encode('UTF-8')
  end

  def self.character_insert(name = nil, game = nil, db = nil)
    Inv_db.gs_print("Inserting character #{name.inspect} for game #{game.inspect}.") if @debug
    close_db = false
    (close_db = true; db = Inv_db.open) if db.nil?
    name = name.nil? ? XMLData.name.encode('UTF-8') : name.encode('UTF-8')
    game = game.nil? ? XMLData.game.encode('UTF-8') : game.encode('UTF-8')
    current_area = self.current_area;
    @account_name, @subscription = self.account_get if @account_name.nil? or @subscription.nil?
    @locker_location = "" if @locker_location.nil?
    society, society_rank = self.society_info
    citizenship = self.citizenship_info
    cparams = {
      :name         => name,
      :game         => game.encode('UTF-8'),
      :account      => @account_name,
      :prof         => (defined?(Stats.prof) ? Stats.prof.encode('UTF-8') : ""),
      :race         => (defined?(Stats.race) ? Stats.race.encode('UTF-8') : ""),
      :level        => XMLData.level.to_i,
      :exp          => (defined?(Stats.exp) ? Stats.exp.to_i : ""),
      :area         => current_area.encode('UTF-8'),
      :subscription => @subscription,
      :locker       => @locker_location,
      :citizenship  => citizenship.encode('UTF-8'),
      :society      => society,
      :society_rank => society_rank,
      :timestamp    => self.db_timestamp_integer
    }

    sql = %{
      insert into character (name, game, account, prof, race, level, exp, area, subscription, locker, citizenship, society, society_rank, timestamp)
      select :name, :game, :account, :prof, :race, :level, :exp, :area, :subscription, :locker, :citizenship, :society, :society_rank, :timestamp
      where not exists (
        select 1
        from character
        where name = :name
          and game = :game
        );
    }
    # cparams = { :game => game, :name => name}
    # sql = "insert into character (name, game) select :name, :game where not exists (select 1 from character where name = :name and game = :game)"
    _rows, changes = self.execute(sql, cparams, db)
    @db_changes[:char][:inserted] += changes

    qargs = { :name => name, :game => game }
    sql = %{ select id from character where name = :name and game = :game }
    character_id = db.get_first_value(sql, qargs)
    db.close if close_db
    return character_id
  end

  def self.character_id_get(db = nil, name = nil, game = nil)
    close_db = false
    (close_db = true; db = Inv_db.open) if db.nil?
    name = name.nil? ? XMLData.name.encode('UTF-8') : name.encode('UTF-8')
    game = game.nil? ? XMLData.game.encode('UTF-8') : game.encode('UTF-8')
    qargs = { :name => name, :game => game }
    sql = %{ select id from character where name = :name and game = :game }
    character_id = db.get_first_value(sql, qargs)
    character_id = self.character_insert(name, game, db) if character_id.nil?
    db.close if close_db;
    return character_id
  end

  def self.insert_fake_character(db, account_name)
    name_spoof = "#{account_name}_"
    cparams = {
      :name         => name_spoof.encode('UTF-8'),
      :game         => XMLData.game.encode('UTF-8'),
      :account      => account_name.encode('UTF-8'),
      :prof         => "".encode('UTF-8'),
      :race         => "".encode('UTF-8'),
      :level        => 0,
      :exp          => 0,
      :area         => "".encode('UTF-8'),
      :subscription => @subscription.encode('UTF-8') || "".encode('UTF-8'),
      :locker       => "".encode('UTF-8'),
      :timestamp    => self.db_timestamp_integer
    }
    sql = %{
    insert into character (name, game, account, prof, race, level, exp, area, subscription, locker, timestamp)
      select :name, :game, :account, :prof, :race, :level, :exp, :area, :subscription, :locker, :timestamp
      where not exists (
        select 1
        from character
        where name = :name
          and game = :game
        );
    }
    _rows, changes = self.execute(sql, cparams, db)
    #@db_changes[:char][:updated] += changes
    qargs = { :name => name_spoof.encode('UTF-8'), :game => XMLData.game.encode('UTF-8') }
    sql = %{ select id from character where name = :name and game = :game }
    character_id = db.get_first_value(sql, qargs)
    return character_id
  end

  def self.character_refresh(db = nil, params = {})
    @calling_proc = @current_proc
    @current_proc = "character_refresh"
    respond "+---------------- proc_start: #{@current_proc}" if @debug

    society, society_rank = self.society_info
    citizenship  = self.citizenship_info
    current_area = self.current_area;
    
    qargs = {
      :name         => XMLData.name.encode('UTF-8'),
      :game         => XMLData.game.encode('UTF-8'),
      :account      => @account_name.encode('UTF-8'),
      :prof         => (defined?(Stats.prof) ? Stats.prof.encode('UTF-8') : ""),
      :race         => (defined?(Stats.race) ? Stats.race.encode('UTF-8') : ""),
      :level        => XMLData.level.to_i,
      :exp          => (defined?(Stats.exp) ? Stats.exp.to_i : ""),
      :area         => current_area.encode('UTF-8'),
      :subscription => @subscription.encode('UTF-8'),
      :locker       => @locker_location.encode('UTF-8'),
      :citizenship  => citizenship.encode('UTF-8'),
      :society      => society.encode('UTF-8'),
      :society_rank => society_rank,
      :timestamp    => self.db_timestamp_integer
    }
    sql = %{
      update character set
          account      = coalesce(:account, account)
        , prof         = :prof
        , race         = :race
        , level        = :level
        , exp          = :exp
        , area         = :area
        , subscription = coalesce(:subscription, subscription)
        , locker       = coalesce(:locker, locker)
        , citizenship  = :citizenship
        , society      = :society
        , society_rank = :society_rank
        , timestamp    = :timestamp
      where name = :name and game = :game
    }
    respond qargs.inspect if @debug_sql
    respond sql if @debug_sql
    _rows, changes = self.execute(sql, qargs, db)
    #@db_changes[:char][:updated] += changes
  end
  
  def self.character_query(db = nil, params = {})
    @calling_proc = @current_proc
    @current_proc = "character_query"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    respond "+----params:#{params.inspect}" if @debug
    begin
      sql, qargs = Inv_db.query_char_sql(params)
      rows = self.execute2(sql, qargs, db)
    rescue SQLite3::BusyException
      sleep 0.1
      retry
    end
    Inv_db.output_table(rows, "char", qargs, "name")
  end
  #------------------------------------------------------------------------------#
  # lumnis
  #------------------------------------------------------------------------------#
  def self.lumnis_status_lookup(db = nil, character_id = nil)
    close_db = false
    (close_db = true; db = Inv_db.open) if db.nil?
    character_id = @character_id if character_id.nil?
    character_id = self.character_id_get(db) if character_id.nil?
    qargs = { :character_id => character_id }
    sql = %{ select status, timestamp from lumnis where character_id = :character_id limit 1 }
    lumnis_status, updated = self.execute2(sql, qargs, db)[1]
    db.close if close_db
    return lumnis_status, updated
  end

  def self.lumnis_info()
    command       = "lumnis info";
    start_pattern = /^You have \d+|Your Gift of Lumnis|^Because your account is free/;
    data = self.client_command(command, start_pattern)
    (Inv_db.gs_print("error checking lumnis info"); return nil) if data.nil? or data.empty?

    exp_pattern           = /(?<value>\d[\d,]*) points of (?<key>triple|double)/
    status_pattern        = /Your Gift of Lumnis (?:has|will) (?<lumnis_status>expired|restart)/
    f2p_pattern           = /Because your account is free, you do not have access to the weekly Gift of Lumnis./
    scheduled_pattern     = /Your Gift of Lumnis is scheduled to start on (?<start_day>\w+)s at (?<start_time>\d\d:\d\d)/
    last_schedule_pattern = /You last used a Lumnis scheduling option on (?<last_schedule>[^\.]+)\./

    d = "".encode('UTF-8')
    lumnis_info = {
      :lumnis_status => d,
      :double        => 0,
      :triple        => 0,
      :total         => 0,
      :start_day     => d,
      :start_time    => d,
      :last_schedule => d,
    }

    data.each { |line|
      if line =~ f2p_pattern
        break
      elsif line =~ exp_pattern
        line.scan(exp_pattern).each { |value, key| lumnis_info[key.to_sym] = value.to_i }
        lumnis_info[:total] = (lumnis_info[:triple] * 2) + lumnis_info[:double]
      elsif (m = line.match(status_pattern))
        lumnis_info[:lumnis_status] = m[:lumnis_status].encode('UTF-8')
        if m[:lumnis_status] == 'restart'
          lumnis_info[:double] = 7300
          lumnis_info[:triple] = 7300
          lumnis_info[:total]  = 21900
        end
      elsif (m = line.match(scheduled_pattern))
        lumnis_info[:start_day]  = m[:start_day].encode('UTF-8')
        lumnis_info[:start_time] = m[:start_time].encode('UTF-8')
      elsif (m = line.match(last_schedule_pattern))
        lumnis_info[:last_schedule] = Time.parse(m[:last_schedule]).strftime("%Y-%m-%d %H:%M:%S").encode('UTF-8')
      end
    }
    return lumnis_info
  end

  def self.lumnis_update(db, qargs)
    iargs = { :character_id => qargs[:character_id] }
    if db.get_first_value("select character_id from lumnis where character_id = :character_id", iargs).nil?
      sql = "insert into lumnis (character_id) values (:character_id)"
      _rows, _changes = self.execute(sql, iargs, db)
      # @db_changes[:lumnis][:inserted] += changes
    end
    sql = %{
      update lumnis set
          status        = :lumnis_status
        , triple        = :triple
        , double        = :double
        , total         = :total
        , start_day     = :start_day
        , start_time    = :start_time
        , last_schedule = :last_schedule
        , timestamp     = :timestamp
      where character_id = :character_id
    }
    _rows, _changes = self.execute(sql, qargs, db)
    # @db_changes[:lumnis][:updated] += changes
  end

  def self.lumnis_refresh(db = nil, character_id = nil)
    close_db = false
    (close_db = true; db = Inv_db.open) if db.nil?
    qargs = self.lumnis_info
    character_id = @character_id if character_id.nil?
    character_id = self.character_id_get(db) if character_id.nil?
    qargs[:character_id] = character_id
    qargs[:timestamp] = self.db_timestamp_integer
    self.lumnis_update(db, qargs)
    db.close if close_db;
  end

  def self.lumnis_query(db = nil, params = {})
    groupby = having = limit = "";
    where, qargs, extras = self.where_builder(params, 'lumnis')
    select = %{
        select
            c.account
          , c.name
          , lower(c.game) as game
          , u.status
          , u.triple
          , u.double
          , u.total
          , u.start_day
          , u.start_time
          , u.last_schedule
          , u.timestamp as updated
      };
    from = %{
        from lumnis u
          inner join character c on u.character_id = c.id
      };
    orderby = "\n    order by c.account, c.name"
    orderby = "\n    order by #{extras[:orderby]}" if extras.key?(:orderby);
    limit   = "\n    limit #{extras[:limit]}" if extras.key?(:limit);
    sql = "#{select} #{from} #{where} #{groupby} #{having} #{orderby} #{limit}";
    _respond sql if @debug_sql;
    rows = self.execute2(sql, qargs, db)
    self.output_table(rows, 'lumnis', qargs)
  end

  #------------------------------------------------------------------------------#
  # resource
  #------------------------------------------------------------------------------#
  def self.resource()
    command       = "resource";
    start_pattern = /^<output class="mono/;
    data = self.client_command(command, start_pattern)
    (Inv_db.gs_print("error checking resource"); return nil) if data.nil? or data.empty?
    resource_pattern = /(?<key>[A-Z](?!old).*?:|\(Weekly\)) *(?<value>[^\(]*?)(?: +|$)/
    d = "".encode('UTF-8')
    resource = { :weekly => d, :total => d, :suffused => d, :energy => d, :favor => d }
    data.each { |line|
      line.scan(resource_pattern).each { |key, value|
        values    = value.gsub(/<(?:push|pop)Bold\/>/, '').split(/\/|\(/)
        value     = values[0]
        max_value = values[1]
        key       = key.sub(/(Suffused)(.*?)$/, '\1').sub(/^Voln /, '').delete(':').downcase
        if max_value == "50,000"
          resource[:energy] = key.downcase.encode('UTF-8')
          resource[:weekly] = value.delete(',').to_i
        elsif max_value == "200,000"
          resource[:total] = value.delete(',').to_i
        elsif ['favor', 'suffused'].include?(key)
          resource[key.to_sym] = value.delete(',').to_i
        else
          resource[key.to_sym] = value.delete(',').downcase.encode('UTF-8')
        end
      }
    }
    return resource
  end

  def self.resource_update(db, qargs)
    return nil if qargs[:energy] == '' and ['', 0].include?(qargs[:favor])
    iargs = { :character_id => qargs[:character_id] }
    if db.get_first_value("select character_id from resource where character_id = :character_id", iargs).nil?
      sql = "insert into resource (character_id) values (:character_id)"
      _rows, changes = self.execute(sql, iargs, db)
      @db_changes[:resource][:inserted] += changes
    end
    qargs[:timestamp] = self.db_timestamp_integer
    #qargs[:bonus] = Resource.load_bonuses["#{XMLData.game}:#{Char.name}"][:bonus] if defined?(Resource::load_bonuses)
    lumnis_status, updated = self.lumnis_status_lookup(db, qargs[:character_id])
    if qargs[:energy] != ''
      if !updated.nil? and Time.at(updated.to_i) + 60 > Time.now
        qargs[:weekly] = 0 if lumnis_status == 'restart'
      else
        self.lumnis_refresh(db, qargs[:character_id])
        lumnis_status, _updated = self.lumnis_status_lookup(db, qargs[:character_id])
        qargs[:weekly] = 0 if lumnis_status == 'restart'
      end
    end
    qargs[:bonus] = nil if !qargs.key?(:bonus)
    qargs[:favor] = 0 if !qargs.key?(:favor)
    qargs.delete_if { |key, _value| !key.to_s.match(/energy|weekly|total|suffused|bonus|favor|timestamp|character_id/) }
    sql = %{
      update resource set
          energy    = coalesce(:energy,'')
        , weekly    = :weekly
        , total     = :total
        , suffused  = :suffused
        , bonus     = coalesce(:bonus,bonus)
        , favor     = :favor
        , timestamp = :timestamp
      where character_id = :character_id
        and (weekly <> :weekly
          or total <> :total
          or bonus <> :bonus
          or favor <> :favor
        )
    }
    _rows, changes = self.execute(sql, qargs, db)
    @db_changes[:resource][:updated] += changes
  end

  def self.resource_refresh(db = nil, character_id = nil)
    close_db = false
    (close_db = true; db = Inv_db.open) if db.nil?
    qargs = self.resource
    character_id = @character_id if character_id.nil?
    character_id = self.character_id_get(db) if character_id.nil?
    qargs[:character_id] = character_id
    self.resource_update(db, qargs)
    db.close if close_db;
  end

  def self.resource_query(db = nil, params = {})
    groupby = having = limit = "";
    where, qargs, extras = self.where_builder(params, 'resource')
    select = %{
    select
        c.account
      , c.name
      , lower(c.game) as game
      , substr(c.prof,1,3) as pro
      , c.level as lvl
      , e.energy
      , e.weekly
      , e.total
      , e.suffused
      , e.bonus
      , e.favor
      , e.timestamp as updated};
    from = %{
    from resource e
      inner join character c on e.character_id = c.id};
    orderby = "\n    order by c.account, c.name"
    orderby = "\n    order by #{extras[:orderby]}" if extras.key?(:orderby);
    limit   = "\n    limit #{extras[:limit]}" if extras.key?(:limit);
    sql = "#{select} #{from} #{where} #{groupby} #{having} #{orderby} #{limit}";
    rows = self.execute2(sql, qargs, db)
    self.output_table(rows, 'resource', qargs)
  end
  
  #------------------------------------------------------------------------------#
  # bounty
  #------------------------------------------------------------------------------#
  def self.bounty_parse
    if defined?(Bounty)
      b = Bounty::Task.new(Bounty::Parser.new(XMLData.bounty_task).parse)
      r = b.requirements
      
      type = b.type.to_s
      area = (r[:area].nil? ? [r[:town],b.town].max : r[:area])
      area = "" if area.nil?
      req  = ""

      if r.key?(:assist) and r[:assist].length > 0  # cull /  bandit
        req = "assist %s %s %s" % [r[:assist], r[:number], r[:creature]]
      elsif r.key?(:herb) # herb
        req = "%s %s %s" % [r[:number], r[:herb], r[:area]]
      elsif r.key?(:gem) # gem
        req = "%s %s" % [r[:number], r[:gem]]
      elsif r.key?(:skin) # skin
        req = "%s %s %s" % [r[:number], r[:quality], r[:skin]]
      elsif r.key?(:item) # heirlooms
        req = "%s, %s, %s" % [r[:action], r[:item], r[:creature]]
      elsif r.key?(:destination) # escort
        req = "%s to %s" % [r[:start], r[:destination]]
      elsif r.key?(:creature) # cull / bandit / dangerous
        req = "%s %s" % [r[:number], r[:creature]]
      elsif XMLData.bounty_task =~ /succeeded/i
        req = "Succeeded"
      else
      end
      req = req.strip
    else
      type = "", area = "", req = ""
    end
    return {:type => type.to_s, :area => area, :requirements => req, :task => XMLData.bounty_task}
  end
  
  def self.bounty_update(db, qargs)
    iargs = { :character_id => qargs[:character_id] }
    if db.get_first_value("select character_id from bounty where character_id = :character_id", iargs).nil?
      sql = "insert into bounty (character_id) values (:character_id)"
      _rows, changes = self.execute(sql, iargs, db)
      @db_changes[:bounty][:inserted] += changes
    end
    qargs[:timestamp] = self.db_timestamp_integer
    sql = %{
      update bounty set
          type         = :type
        , area         = :area
        , requirements = :requirements
        , task         = :task
        , timestamp    = :timestamp
      where character_id = :character_id
        and (type       <> :type
        or area         <> :area
        or requirements <> :requirements
        or task         <> :task
        )
    }
    _rows, changes = self.execute(sql, qargs, db)
    @db_changes[:bounty][:updated] += changes
  end
  
  def self.bounty_refresh(db = nil, character_id = nil)
    close_db = false
    (close_db = true; db = Inv_db.open) if db.nil?
    qargs = self.bounty_parse
    respond "bounty_refresh:qargs:#{qargs.inspect}" if @debug
    character_id = @character_id if character_id.nil?
    character_id = self.character_id_get(db) if character_id.nil?
    qargs[:character_id] = character_id
    self.bounty_update(db, qargs)
    db.close if close_db;
  end
  
  def self.bounty_query(db = nil, params = {})
    groupby = having = limit = "";
    where, qargs, extras = self.where_builder(params, 'bounty')
    select = %{
        select
          -- c.account
            c.name
          -- , lower(c.game) as game
          , bo.type
          , bo.area
          , bo.requirements
          , bo.timestamp as updated
          , bo.task
      };
    from = %{
        from bounty bo
          inner join character c on bo.character_id = c.id
    };
    orderby = "\n    order by c.account, c.name"
    orderby = "\n    order by #{extras[:orderby]}" if extras.key?(:orderby);
    limit   = "\n    limit #{extras[:limit]}" if extras.key?(:limit);
    sql = "#{select} #{from} #{where} #{groupby} #{having} #{orderby} #{limit}";
    _respond sql if @debug_sql;
    rows = self.execute2(sql, qargs, db)
    self.output_table(rows, 'bounty', qargs)
  end
  #------------------------------------------------------------------------------#
  # collectibles
  #------------------------------------------------------------------------------#
  def self.collect_info()
    command       = "collect info";
    start_pattern = /^Your collection is as follows:/;
    data          = Inv_db.client_command(command, start_pattern)
    (Inv_db.gs_print("error checking collect info"); return nil) if data.nil? or data.empty?
    collectibles_pattern = /^\s*(?<ordinal>\d+).\s\((?:an? )?(?<name>.*?)\):\s+(?<amount>[\d,]+)/
    collectibles         = []
    data.each { |line|
      if m = collectibles_pattern.match(line)
        collectibles << {:ordinal => m[:ordinal].to_i, :name => m[:name], :amount => m[:amount].delete(',').to_i }
      end
    }
    return collectibles
  end
  
  #------------------------------------------------------------------------------#
  # banks
  #   todo: add silvers/notes
  # You have 2351 coins with you.
  # You are carrying City-States promissory notes valued at a total of 10216 silver.
  # You are carrying 12567 silver between notes and coins.
  # In the back of your mind you remember you owe a debt of 85 silvers in the town of Icemule Trace.
  #------------------------------------------------------------------------------#
  def self.bank_account()
    @calling_proc = @current_proc
    @current_proc = "scrape_bank"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    command         = "bank account";
    start_pattern   = /^You currently have the following amounts on deposit:|You currently have an account|You haven't opened a bank account yet/i;
    end_pattern     = /^(?:<popBold\/>)?<prompt/;
    bank_account_result = self.client_command(command, start_pattern, end_pattern)

    bank_accounts = Hash.new
    # bank_transfers = 0 # not tracked
    bank_account_result.each { |line|
      if m = @patterns[:bank].match(line)
        bank = m[:bank]
        amount = m[:amount].delete(',').to_i
        bank_accounts[bank] = amount
      elsif m = @patterns[:bank_single].match(line)
        bank   = m[:bank]
        amount = m[:amount].delete(',').to_i
        bank_accounts[bank] = amount
        bank_accounts["Total"] = amount
      elsif m = @patterns[:bank_transfers].match(line)
        # bank_transfers = m[:transfers] # not tracked
      elsif m = @patterns[:bank_f2p].match(line)
        # bank_max = m[:max]
        break
      elsif m = @patterns[:bank_none].match(line)
        break # has no banks
      end
    }
    return bank_accounts
  end
  
  def self.bank_temp(db)
    sql = %{
    create temporary table if not exists temp_silver (
         character_id   integer not null
       , bank           text    not null
       , amount         integer not null
       , timestamp      integer not null
       , unique(character_id, bank)
    );};
    db.execute(sql)
  end
  
  def self.bank_merge(db, qargs)
    @calling_proc = @current_proc
    @current_proc = "bank_merge"
    
    self.bank_temp(db)
    
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    timestamp = self.db_timestamp_integer
    bank_accounts = self.bank_account
    sql = "insert into temp_silver (character_id, bank, amount, timestamp) values(:character_id, :bank, :amount, #{timestamp})"
    bank_accounts.each { |k, v|
      self.execute(sql, { :character_id => qargs[:character_id], :bank => k.encode('UTF-8'), :amount => v,}, db)
    }
    #  ----delete
    sql = %{
    delete
    from silver
    where silver.character_id = :character_id
      and not exists (
        select 1
        from temp_silver t
          inner join bank b on t.bank = b.name
        where t.character_id = silver.character_id
          and b.id           = silver.bank_id
        )
    }
    _rows, changes = self.execute(sql, qargs, db)
    @db_changes[:bank][:deleted] += changes
    #  ----update: sqlites doesn't support joins in updates
    sql = %{
    with cte (character_id, bank_id, amount, timestamp) as (
      select t.character_id, b.id, t.amount, t.timestamp
      from temp_silver t
        inner join bank b on t.bank=b.name
    )
    update silver set
        amount    = (
          select amount
          from cte
          where silver.character_id = cte.character_id
            and silver.bank_id = cte.bank_id
            and silver.amount <> cte.amount
        )
      , timestamp = (
          select timestamp
          from cte
          where silver.character_id = cte.character_id
            and silver.bank_id = cte.bank_id
            and silver.amount <> cte.amount
        )
    where exists (
      select 1
      from cte
      where silver.character_id = cte.character_id
        and silver.bank_id = cte.bank_id
        and silver.amount <> cte.amount
      )
    }
    _rows, changes = self.execute(sql, {}, db)
    @db_changes[:bank][:updated] += changes
    sql = %{
    with cte (character_id, bank_id, amount, timestamp) as (
      select t.character_id, b.id, t.amount, t.timestamp
      from temp_silver t
        inner join bank b on t.bank=b.name
    )
    insert into silver (character_id, bank_id, amount, timestamp)
      select character_id, bank_id, amount, timestamp
      from cte
      where not exists (
        select 1
        from silver i
        where i.character_id = cte.character_id
          and i.bank_id      = cte.bank_id
        )
      order by character_id, bank_id
    }
    _rows, changes = self.execute(sql, {}, db)
    @db_changes[:bank][:inserted] += changes
  end

  def self.bank_refresh(db = nil, character_id = nil)
    @calling_proc = @current_proc
    @current_proc = "bank_refresh"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    close_db = false
    (close_db = true; db = Inv_db.open) if db.nil?
    character_id = @character_id if character_id.nil?
    character_id = self.character_id_get(db) if character_id.nil?
    qargs = Hash.new
    qargs[:character_id] = character_id
    self.bank_merge(db, qargs)
    db.close if close_db;
  end
  
  def self.bank_query(db = nil, params = {})
    @calling_proc = @current_proc
    @current_proc = "bank_query"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    respond "+----params:#{params.inspect}" if @debug
    begin
      sql, qargs = Inv_db.query_bank_sql(params)
      rows = self.execute2(sql, qargs, db)
    rescue SQLite3::BusyException
      sleep 0.1
      retry
    end
    Inv_db.output_table(rows, "bank", qargs, "name")
  end
  
  def self.bank_sum(db = nil, params = {})
    @calling_proc = @current_proc
    @current_proc = "bank_sum"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    respond "+----params:#{params.inspect}" if @debug
    begin
      sql, qargs = Inv_db.sum_bank_sql(params)
      rows = self.execute2(sql, qargs, db)
    rescue SQLite3::BusyException
      sleep 0.1
      retry
    end
    Inv_db.output_table(rows, "bank", qargs, "name")
  end
  #------------------------------------------------------------------------------#
  # ticket
  #------------------------------------------------------------------------------#
  def self.ticket_balance
    ticket_patterns = Hash.new
    ticket_patterns[:balance_start] = /You take a moment to recall the alternative/
    ticket_patterns[:balance_split] = /^ +(?<source>.*?) - (?<amount>[,\d]+) (?<currency>.*?)\./
    ticket_patterns[:balance_none] = /You haven't collected any alternative currencies./
    ticket_balance = []

    command        = "ticket balance"
    start_pattern  = ticket_patterns[:balance_start]
    ticket_data    = self.client_command(command, start_pattern)
    
    # because it goes mono before saying anything:
    puts "<output class=\"\"/>" if $frontend =~ /storm|wrayth/i
    if ticket_patterns[:balance_none].match(ticket_data.join("\n"))
      return ticket_balance
    else
      ticket_data.each { |l|
        m = ticket_patterns[:balance_split].match(l)
        if m
          ticket = {
            :source   => m[:source].encode('UTF-8'),
            :amount   => m[:amount].delete(',').to_i,
            :currency => m[:currency].encode('UTF-8')
          }
          ticket_balance.push(ticket)
        end
      }
      ticket_balance.each { |t| echo "#{t[:source]}, #{t[:amount]}, #{t[:currency]}" } if @debug
      
      return ticket_balance
    end
    
  end
  
  def self.ticket_temp(db)
      sql = %{
      create temporary table if not exists temp_tickets (
           character_id   integer not null
         , source         text    not null
         , amount         integer not null
         , currency       text    not null
         , timestamp      integer not null
         , unique(character_id, source)
    );};
    db.execute(sql)
  end
  
  def self.ticket_merge(db, qargs)
    @calling_proc = @current_proc
    @current_proc = "ticket_merge"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    ticket_balance = self.ticket_balance
    if ticket_balance.empty?
      return self.ticket_delete(db)
    end
    self.ticket_temp(db)
    timestamp = self.db_timestamp_integer
    sql = "
    insert into temp_tickets (character_id, source, amount, currency, timestamp)
    values(#{qargs[:character_id]}, :source, :amount, :currency, #{timestamp})"
    ticket_balance.each { |ticket| self.execute(sql, ticket, db) }

    # delete tickets
    sql = %{
    delete
    from tickets
    where tickets.character_id = :character_id
      and not exists (
        select 1
        from temp_tickets t
        where t.character_id = tickets.character_id
          and t.source = tickets.source
          and t.currency = tickets.currency
        )
    }
    _rows, changes = self.execute(sql, qargs, db)
    @db_changes[:tickets][:deleted] += changes

    # update tickets ----update: sqlites doesn't support joins in updates
    sql = %{
    with cte (character_id, source, amount, currency) as (
      select t.character_id, t.source, t.amount, t.currency
      from temp_tickets t
      where t.character_id = :character_id
    )
    update tickets set
        amount = (
          select amount
          from cte
          where tickets.character_id = cte.character_id
            and tickets.source = cte.source
            and tickets.amount <> cte.amount
            and tickets.currency = cte.currency
        )
      , timestamp = #{timestamp}
    where tickets.character_id = :character_id
      and exists (
      select 1
      from cte
      where tickets.character_id = cte.character_id
        and tickets.source = cte.source
        and tickets.amount <> cte.amount
        and tickets.currency = cte.currency
      )
    }
    _rows, changes = self.execute(sql, qargs, db)
    @db_changes[:tickets][:updated] += changes

    # insert tickets
    sql = %{
    with cte (character_id, source, amount, currency) as (
      select t.character_id, t.source, t.amount, t.currency
      from temp_tickets t
      where t.character_id = :character_id
    )
    insert into tickets (character_id, source, amount, currency, timestamp)
      select character_id, source, amount, currency, #{timestamp}
      from cte
      where not exists (
        select 1
        from tickets i
        where i.character_id = cte.character_id
          and i.source       = cte.source
          and i.currency     = cte.currency
        )
      order by character_id, source
    }
    _rows, changes = self.execute(sql, qargs, db)
    @db_changes[:tickets][:inserted] += changes
  end
  
  def self.ticket_refresh(db = nil, character_id = nil)
    @calling_proc = @current_proc
    @current_proc = "ticket_refresh"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    close_db = false
    (close_db = true; db = Inv_db.open) if db.nil?
    character_id = @character_id if character_id.nil?
    character_id = self.character_id_get(db) if character_id.nil?
    qargs = Hash.new
    qargs[:character_id] = character_id
    self.ticket_merge(db, qargs)
    db.close if close_db;
  end
  
  def self.ticket_query(db = nil, params = {})
    @calling_proc = @current_proc
    @current_proc = "ticket_query"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    respond "+----params:#{params.inspect}" if @debug
    begin
      sql, qargs = Inv_db.query_tickets_sql(params)
      rows = self.execute2(sql, qargs, db)
    rescue SQLite3::BusyException
      sleep 0.1
      retry
    end
    Inv_db.output_table(rows, 'tickets', qargs, "name")
  end
  
  def self.ticket_sum(db = nil, params = {})
    @calling_proc = @current_proc
    @current_proc = "ticket_sum"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    respond "+----params:#{params.inspect}" if @debug
    begin
      sql, qargs = Inv_db.sum_tickets_sql(params)
      rows = self.execute2(sql, qargs, db)
    rescue SQLite3::BusyException
      sleep 0.1
      retry
    end
    Inv_db.output_table(rows, 'tickets', qargs, "name")
  end
    
  def self.ticket_delete(db = nil, params = [])
    @calling_proc = @current_proc
    @current_proc = "delete_tickets"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    respond "+--------params: #{params.inspect}" if @debug
    params = [{:name=>"character", :operator=>"=", :value=>"#{XMLData.name.encode('UTF-8')}"}, {:name=>"game", :operator=>"=", :value=>"#{XMLData.game.encode('UTF-8')}"}] if params.empty?
    respond "+--------params: #{params.inspect}" if @debug
    _where, qargs, _extras = self.where_builder(params,'tickets',false,'delete')
    sql = %{
      delete from tickets
      where character_id = (
        select id
        from character
        where name like :character_filter
          and game like :game_filter
        )
    }
    _rows, changes = self.execute(sql, qargs, db)
    @db_changes[:tickets][:deleted] += changes
  end
  #------------------------------------------------------------------------------#
  # item
  #    todo: scrape & capture parent/path of nested items
  #    todo: locker manifest might not have all lockers (simucoin)
  #------------------------------------------------------------------------------#

  insert_temp_item_inv = proc { |location_id| # |location_id,contents|
    @calling_proc = @current_proc
    @current_proc = "insert_temp_item_inv.call(#{location_id})"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    respond "@inv_items.count: #{@inv_items.count}" if @debug
    timestamp = self.db_timestamp_integer
    sql = "insert into temp_item (
        character_id, location_id
      , level, path
      , name
      , type
      , link_name, containing
      , noun, amount
      , stack, stack_status
      , marked, registered, hidden
      , timestamp, update_noun, gs_id
      )
    values(#{@character_id}, :location_id
      , :level, :path
      , :name
      , :type
      , :link_name, :containing
      , :noun, :amount
      , :stack, :stack_status
      , :marked, :registered, :hidden
      , #{timestamp}, :update_noun, :id )"

    temp_item_time = Benchmark.realtime do;
      @inv_items.each { |item| 
        self.execute(sql, item, db)
      }
    end
    if @debug
      inserted = db.get_first_value("select count(*) from temp_item where location_id = #{location_id}")
      respond  "inserted: #{inserted.inspect}"
    end
    Inv_db.gs_print "+----insert_temp_item_inv time elapsed #{(temp_item_time * 1000).round(2)} milliseconds" if @benchmark;
  }

  insert_temp_item_locker = proc { |items|
    @calling_proc = @current_proc
    @current_proc = "insert_temp_item_locker"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    respond "locker_items.count: #{items.count}" if @debug
    timestamp = self.db_timestamp_integer
    sql = "insert into temp_item (
         character_id, location_id
       , level, path
       , name
       , type
       , link_name, containing
       , noun, amount
       , stack, stack_status
       , timestamp, update_noun, gs_id
       )
       -- insert_temp_item_locker
     values(#{@character_id}, :location_id
       , :level, :path
       , :name
       , :type
       , :link_name, :containing
       , :noun, :amount
       , :stack, :stack_status
       , #{timestamp}, :update_noun, :id )"
    insert_temp_item_locker_time = Benchmark.realtime do;
      items.each { |locker_item|
        locker_item.delete_if { |key, _value| !key.to_s.match(/^(?:location_id|level|path|type|name|link_name|containing|noun|amount|stack|status|update_noun)/) }
        self.execute(sql, locker_item, db)
      }
    end;
    Inv_db.gs_print "+----insert_temp_item_locker_time time elapsed #{(insert_temp_item_locker_time * 1000).round(2)} milliseconds" if @benchmark;
  }

  insert_temp_item_premium_locker = proc { |location_id|
    @calling_proc = @current_proc
    @current_proc = "insert_temp_item_premium_locker"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    timestamp = self.db_timestamp_integer
    if location_id.to_i == 40
      @account_name, @subscription = self.account_verb if @account_name.nil?
      character_id = self.insert_fake_character(db, @account_name)
    else
      character_id = @character_id
    end
    sql = "insert into temp_item (
          character_id, location_id
        , level, path
        , name
        , type
        , link_name, containing
        , noun, amount
        , stack, stack_status
        , marked, registered
        , timestamp, update_noun, gs_id
        )
      values(#{character_id}, :location_id
        , :level, :path
        , :name
        , :type
        , :link_name, :containing
        , :noun, :amount
        , :stack, :stack_status
        , :marked, :registered
        , #{timestamp}, :update_noun, :id )"
    insert_temp_item_premium_locker_time = Benchmark.realtime do;
      @locker_items.each { |locker_item|
        locker_item.delete_if { |key, _value| !key.to_s.match(/^(?:location_id|level|path|type|name|link_name|containing|noun|amount|stack|status|marked|registered|update_noun)/) }
        self.execute(sql, locker_item, db)
      }
    end;
    Inv_db.gs_print "+----insert_temp_item_premium_locker_time time elapsed #{(insert_temp_item_premium_locker_time * 1000).round(2)} milliseconds" if @benchmark;
  }

  merge_item_by_location = proc { |location_id|
    @calling_proc = @current_proc
    @current_proc = "merge_item_by_location.call(#{location_id})"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    character_id = @character_id
    character_id = self.insert_fake_character(db, @account_name) if location_id.to_i == 40
    merge_params = { :character_id => character_id, :location_id => location_id.to_i, :game => XMLData.game }
    respond "merge_params:#{merge_params.inspect}" if @debug
    
    
    # if @debug;
    #   location_item_count = db.execute2("select count(*) as item_count from temp_item where location_id = #{location_id}")[1]
    #   respond "location #{location_id} item_count: #{location_item_count.inspect}"
    #   rows = db.execute2("select * from temp_item where location_id = #{location_id} limit 10") #.each { |r| respond r.inspect }
    #   Inv_db.to_table(rows)
    # end
    changes = nil

    self.item_base_merge(db,'temp_item')
    
    temp_item_cte = %{
    with cte as (
      select
          character_id, location_id, i.id as item_id
        , level, path, containing
        , sum(amount) as amount
        , stack, stack_status
        , marked, registered, t.hidden
        --, timestamp
      from temp_item t
        inner join item i on i.name = t.name and i.game = :game
      where character_id = :character_id
        and location_id = :location_id
      group by
          character_id, location_id, i.id
        , level, path, containing
        , stack, stack_status
        , marked, registered, t.hidden
        --, timestamp
    )}

    # if @debug;
    #   respond db.execute2(temp_item_cte + "select count(*) as item_count from cte", merge_params)
    #   location_item_count = db.execute2(temp_item_cte + "select count(*) as item_count from cte", merge_params)
    #   respond "cte: location #{location_id} item_count: #{location_item_count.inspect}"
    # end
    # if @debug;
    #   location_item_count = db.execute2("select count(*) as item_count from temp_item where location_id = #{location_id}")[1]
    #   respond "location #{location_id} item_count: #{location_item_count.inspect}"
    #   rows = self.execute2(temp_item_cte +" select * from cte", merge_params, db) #.each { |r| respond r.inspect }
    #   Inv_db.to_table(rows)
    # end
    
    sql = %{
    select
      i.name, v.*
    from char_inventory v
      inner join item i on v.item_id = i.id and i.game = :game
    where v.character_id = :character_id
      and v.location_id = :location_id
      and not exists (
        select 1
        from temp_item t
          inner join item i on t.name = i.name and i.game = :game
        where t.character_id = :character_id
          and t.location_id  = :location_id
          and i.id           = v.item_id
          and t.containing   = v.containing
          and t.path         = v.path
          and t.stack        = v.stack
          and t.stack_status = v.stack_status
          and t.marked       = v.marked
          and t.registered   = v.registered
          and t.hidden       = v.hidden
    );}
    if @debug
    respond "+---- deleting these rows"
    rows = self.execute2(sql, merge_params, db)
    Inv_db.to_table(rows)
    respond "+--------------------------"
    end


    respond "+----#{@current_proc}: delete" if @debug
    sql = %{
    delete
    from char_inventory
    where char_inventory.character_id = :character_id
      and char_inventory.location_id = :location_id
      and not exists (
        select 1
        from temp_item t
          inner join item i on t.name = i.name and i.game = :game
        where t.character_id = :character_id
          and t.location_id  = :location_id
          and i.id           = char_inventory.item_id
          and t.containing   = char_inventory.containing
          and t.path         = char_inventory.path
          and t.stack        = char_inventory.stack
          and t.stack_status = char_inventory.stack_status
          and t.marked       = char_inventory.marked
          and t.registered   = char_inventory.registered
          and t.hidden       = char_inventory.hidden
        );}
    temp_time = Benchmark.realtime do;
      _rows, changes = self.execute(sql, merge_params, db)
      @db_changes[:item][:deleted] += changes
    end
    Inv_db.gs_print "+----merge-delete(#{location_id}) with #{changes.inspect} changes, time elapsed #{(temp_time * 1000).round(2)} milliseconds" if @benchmark;

    #  ----update: sqlite doesn't support joins in updates
    respond "+----#{@current_proc}: update" if @debug
    sql = %{
    update char_inventory set
        amount = (
          select amount
          from cte t
          where t.character_id = :character_id
            and t.location_id  = :location_id
            and t.item_id      = char_inventory.item_id
            and t.containing   = char_inventory.containing
            and t.path         = char_inventory.path
            and t.stack        = char_inventory.stack
            and t.stack_status = char_inventory.stack_status
            and t.marked       = char_inventory.marked
            and t.registered   = char_inventory.registered
            and t.hidden       = char_inventory.hidden
        )
      , timestamp = :timestamp
    where char_inventory.character_id = :character_id
      and char_inventory.location_id = :location_id
      and exists (
        select 1
        from cte t
        where t.character_id = :character_id
          and t.location_id  = :location_id
          and t.item_id      = char_inventory.item_id
          and t.containing   = char_inventory.containing
          and t.path         = char_inventory.path
          and t.amount       <> char_inventory.amount
          and t.stack        = char_inventory.stack
          and t.stack_status = char_inventory.stack_status
          and t.marked       = char_inventory.marked
          and t.registered   = char_inventory.registered
          and t.hidden       = char_inventory.hidden
        );
    }
    merge_params.merge!({ :timestamp => self.db_timestamp_integer })
    temp_time = Benchmark.realtime do;
      _rows, changes = self.execute(temp_item_cte + sql, merge_params, db)
      @db_changes[:item][:updated] += changes
    end
    Inv_db.gs_print "+----merge-update(#{location_id}) with #{changes.inspect} changes, time elapsed #{(temp_time * 1000).round(2)} milliseconds" if @benchmark;

    #  ----insert items
    respond "+----#{@current_proc}: insert" if @debug
    sql = %{
    insert into char_inventory (
        character_id, location_id, item_id
      , level, path
      , containing
      , amount
      , stack, stack_status
      , marked, registered, hidden
      , timestamp
    )
    select
        character_id, location_id, item_id
      , level, path
      , containing
      , amount
      , stack, stack_status
      , marked, registered, hidden
      , :timestamp
    from cte t
    where not exists (
      select 1
      from char_inventory i
      where i.character_id = :character_id
        and i.location_id  = :location_id
        and i.path         = t.path
        and i.containing   = t.containing
        and i.item_id      = t.item_id
        and i.stack        = t.stack
        and i.stack_status = t.stack_status
        and i.marked       = t.marked
        and i.registered   = t.registered
        and i.hidden       = t.hidden
        )
      order by character_id, location_id, path, item_id;}

    temp_time = Benchmark.realtime do;
      _rows, changes = self.execute(temp_item_cte + sql, merge_params, db)
      @db_changes[:item][:inserted] += changes
    end
    Inv_db.gs_print "+----merge-insert(#{location_id}) with #{changes.inspect} changes, time elapsed #{(temp_time * 1000).round(2)} milliseconds" if @benchmark;

    # todo:remove
    # testing performance impact of clearing temp table
    sql = %{
    delete from temp_item
    where character_id = :character_id
      and location_id = :location_id}
    temp_time = Benchmark.realtime do;
      _rows, changes = self.execute(sql, merge_params.delete_if { |k, _v| k.to_s =~ /game|timestamp/ }, db)
    end
    Inv_db.gs_print "+----merge-cleanup(#{location_id}) with #{changes.inspect} changes, time elapsed #{(temp_time * 1000).round(2)} milliseconds" if @benchmark;
  } # end merge

  refresh_item = proc { |params|
    @calling_proc = @current_proc;
    @current_proc = "refresh_item";
    respond "+---------------- proc_start: #{@current_proc}" if @debug;
    respond "+----params:#{params.inspect}" if @debug;
    location_type_filter = params.find { |h| h[:name] == "location_type" }[:value];
    location_type_filter = "all" if location_type_filter.nil?;
    if location_type_filter =~ /all|inv/;
      Inv_db.gs_print "updating inventory..." if !@benchmark;
      inv_time = Benchmark.realtime do;
        refresh_inv.call;
      end;
      Inv_db.gs_print "+--refresh_inv combined time elapsed #{(inv_time * 1000).round(2)} milliseconds" if @benchmark;
    end;
    if location_type_filter =~ /all|locker/ and not (location_type_filter =~ /all/ and @subscription == "f2p");
      Inv_db.gs_print "updating locker(s)..." if !@benchmark;
      locker_time = Benchmark.realtime do;
        refresh_locker.call;
      end;
      Inv_db.gs_print "+--refresh_locker time elapsed #{(locker_time * 1000).round(2)} milliseconds" if @benchmark;
    end;
  };

  #------------------------------------------------------------------------------#
  # waitfor jarserve2 if it's running
  #------------------------------------------------------------------------------#
  @js2 = Hash.new

  check_jarserve2 = proc {
    if Script.running?("jarserve2");
      respond "jarserve2 is running, waiting until ready:"
      $jarserve2.wait_until_ready
      $jarserve2.do_query().value[:jars].each do |gem, jars|
        jars.each do |jar|
          @js2[jar.id] = {
            :name         => jar.gem.to_s,
            :noun         => gem.noun_first =~ /^([^,]+),/ ? $1 : "?",
            :amount       => jar.count.to_i,
            :stack_status => (jar.status.to_s =~ /^(full|empty)/ ? $1 : "partial".encode('UTF-8'))
          }
        end
      end
    end
  }
  #------------------------------------------------------------------------------#
  # containers
  #------------------------------------------------------------------------------#
  @containers               = Hash.new;
  @containers_with_contents = Hash.new
  @worn_inventory           = Hash.new
  
  def self.inventory_container();
    command       = "inventory container";
    start_pattern = /^(?:<popBold\/>)?You are wearing (?:(?!, which conceals).)+$|^(?:<popBold\/>)?You are holding/;
    end_pattern   = /^(<popBold\/>)?<prompt/;
    data          = self.client_command(command, start_pattern, end_pattern)
    popbold       = (data[0] =~ /^<popBold\/>/ ? true : false;)
    _respond '<popBold/>' if popbold == true;
    respond "inventory container #{data}" if @debug;
    if data.size > 1 and data[1..-1].join('') =~ /Click <d cmd='invento help'>INVENTORY HELP<\/d> for more options./
      echo "caught bad inventory result:\n #{data.join("\n")}\n" if @debug;
      data = self.client_command(command, start_pattern, end_pattern);
    end;
    respond "inventory_container: data:#{data.inspect}" if @debug
    data.each { |d|
      d.scan(@patterns[:container_list]).each { |id, noun, name|
        @containers[id] = {:name => name, :noun => noun}
      };
    };
    return @containers;
  end;

  def self.containers_with_contents_get()
    respond "+---------------- containers_with_contents_find" if @debug
    lines         = self.client_command('inventory full',@patterns[:inv_start])
    lines         += self.client_command('inventory hands full',@patterns[:inv_start]) if !GameObj.right_hand.id.nil? or !GameObj.left_hand.id.nil?
    prev_id       = nil
    prev_level    = 0
    item_path_ids = []
    lines.each{ |line|
      if (m = @patterns[:inv_full].match(line))
        level = ((m[:depth].length.to_i - 2) / 4).to_i
        id    = m[:exist]
        name  = line.gsub(/^ *(?:an? |some )?| *containing.*$| *\(.*$|<a.*?\>/,'').strip
        if level == 0 and !@worn_inventory.key?(id)
          @worn_inventory[id] = {:name => name, :noun => m[:noun], :link_name => m[:name]}
        end
        if level > prev_level
          if !@containers_with_contents.key?(prev_id)
            @containers_with_contents[prev_id] = item_path_ids.size > 0 ? "in ##{item_path_ids.reverse.join(" in #")}" : ""
          end
          item_path_ids.push(prev_id)
        end
        if level < prev_level
          n_pop = prev_level - level;
          n_pop.times { item_path_ids.pop; }
        end
        prev_id       = id
        prev_level    = level.to_i
      end
    }
    return @containers_with_contents
  end
  
  close_containers = proc {
    @calling_proc = @current_proc
    @current_proc = "close_containers"
    respond "+---------------- proc_start: #{@current_proc}" if @debug

    command_queue = @containers_to_close.reverse.map { |c| "close ##{c}" }
    if !command_queue.empty?
      squelch.call(inv_open_close_squelch_pattern) if @quiet
      echo "command_queue:#{command_queue.inspect}" if @debug
      success_pattern = /You.*?(?:"#{@containers_to_close.join("|")}")/
      speed           = (@slower == true ? 1 : 2)
      quickdo(command_queue, success_pattern, speed)
      squelch_remove.call if @quiet
    end
  }
  
  open_containers = proc {
    @calling_proc = @current_proc
    @current_proc = "open_containers"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    
    self.containers_with_contents_get if @containers_with_contents.empty?
    self.inventory_container
    #respond "data:#{data.inspect}" if @debug
    respond "@containers_noopen_pattern:#{@containers_noopen_pattern.inspect}" if @debug
    @containers.each{ |k,v|
      @containers_to_open << k if !@containers_noopen_pattern.match(v[:name]) and !@containers_with_contents.key(k)
    }
    respond "@containers_to_open:#{@containers_to_open.inspect}" if @debug
    
    before_dying {close_containers.call}
    
    command_queue = @containers_to_open.map { |c| "open ##{c}" };
    if !command_queue.empty?
      respond "command_queue:#{command_queue.inspect}" if @debug
      squelch.call(inv_open_close_squelch_pattern);
      success_pattern = /^It appears to be locked.|^That is already open|^There doesn't seem to be any way to do that|(?<already_open>already open|open already|resists opening|absentmindedly fiddle with your)|(?<not_holding>Try holding it first|You need to be holding)|(?:You|Hooking|Lightly|Pinching|Sliding|With|focus) (?:flip|open|pull|push|throw|unwind|unfasten|unsnap|unhitch|unclasp|a finger|a flick|pick at|brushing|the toggle|the lever|rub|for).*?(?:<a exist="(?<id>#{@containers_to_open.join("|")})" noun="(?<noun>[^"]+)">(?<name>[^<]+)<.*?)|<exposeContainer|<container|^Try holding it first/
      speed           = (@slower == true ? 1 : 2)
      open_output = quickdo(command_queue, success_pattern, speed)
      respond "open_output:#{open_output.inspect}" if @debug
      container_id_pattern = /<a exist="(?<id>#{@containers_to_open.join("|")})" noun="(?<noun>[^"]+)">/
      open_output.each { |o|
        m = container_id_pattern.match(o)
        if m
          @containers_to_close.push(m[:id]) if m[:id]
        end
      }
      respond "@containers_to_close:#{@containers_to_close.inspect}" if @debug
      squelch_remove.call
    end
  }

  #------------------------------------------------------------------------------#
  #
  #------------------------------------------------------------------------------#
  refresh_inv = proc {
    @calling_proc = @current_proc
    @current_proc = "refresh_inv"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    location_type_filter = "all" if location_type_filter.nil?
    check_jarserve2.call
    if @settings_hash["open_containers"] == true
      open_time = Benchmark.realtime do
        open_containers.call
      end
      Inv_db.gs_print "+--open_containers time elapsed #{(open_time * 1000).round(2)} milliseconds" if @benchmark
    end
    if location_type_filter =~ /inv|item|all/i
      respond "+---------------- #{@current_proc}: scan inv" if @debug

      # Usage:
      # meh#     INVENTORY                         - Show the items you're currently wearing
      # meh#     INVENTORY HANDS                   - Show the items you're currently holding
      # meh#     INVENTORY {option}                - Show the items of a specific type that you're currently wearing
      # neat#     INVENTORY FULL [option]           - Show items in your inventory, including the contents of containers, optionally only showing those of a specific type
      # neat#     INVENTORY LOCATION                - Show items you are currently wearing and where they are located.  Also indicates whether the items are functional or not.
      # meh#     INVENTORY QUANTITY [option]       - Count items in your inventory, including the contents of containers, optionally only counting those of a specific type
      # neat#     INVENTORY HANDS FULL [option]     - Show items in your hands, including the contents of containers, optionally only showing those of a specific type
      # meh#     INVENTORY HANDS QUANTITY [option] - Count items in your hands, including the contents of containers, optionally only counting those of a specific type
      # hm#     INVENTORY ENHANCIVE [ON| OFF]     - Toggle whether your enhancive items provide their benefits (and thus expend charges) or not.
      #
      # Where {option} is one of the following:
      # hm#     ARMOR      - List armor
      # hm#     WEAPONS    - List weapons
      # hm#     COMBAT     - List weapons, armor, and unarmed combat equipment
      # neat#     CONTAINERS - List items that can hold other items
      # meh#     FLUFF      - List non-combat, non-container items
      # meh#     REGISTERED - List items that were most recently registered by you
      #------------------------------------------------------------------------------#
      @inv_scan = [
        { :command => 'inventory hands full', :id => 1, :squelch => nil, :path => "".encode('UTF-8'), :lines => [], :name => 'hands' }, # You are carrying
        { :command => 'inventory full alongside', :id => 6, :squelch => nil, :path => "".encode('UTF-8'), :lines => [], :name => 'alongside' }, # You are carrying
        { :command => 'inventory full', :id => 2, :squelch => nil, :path => '', :lines => [], :name => 'inven' } # , #You are currently wearing and carrying:
        # {:command => 'inventory location', :id => 3}, #You are currently wearing:
        # inv full con doesn't see containers in closed containers, just sayin'
        # inv full container may require multiple loops if containers aren't already open
        # alternately, open all containers before running the scan -- seems simpler
        # keep track of the opened containers and close them again in reverse order
        # {:command => 'inv full containers', :id => 0, :path => 'container', :contents => Hash.new(0), :squelch => inv_hands_squelch_pattern}, #You are carrying
        # {:command => 'inv full fluff', :id => 9, :path => 'container', :contents => Hash.new(0), :squelch => inv_hands_squelch_pattern}, #You are carrying
        # don't need registered
        # {:command => 'inv full registered', :id => , :path => 'container', :contents => Hash.new(0), :squelch => inv_hands_squelch_pattern}, #You are carrying
      ];
      @inv_scan.each { |scan|
        scan_time = Benchmark.realtime do;
          @inv_items = []
          scan_parse_item_lines.call(scan)
          insert_temp_item_inv.call(scan[:id])
          merge_item_by_location.call(scan[:id])
        end;
        Inv_db.gs_print "+----scan #{scan[:name]} time elapsed #{(scan_time * 1000).round(2)} milliseconds" if @benchmark;
      }
      close_time = Benchmark.realtime do
        if @settings_hash["open_containers"] == true
          close_containers.call
        end
      end
      Inv_db.gs_print "+----close_containers time elapsed #{(close_time * 1000).round(2)} milliseconds" if @benchmark
      # debug_parsed_items.call
    end
  };

  scan_parse_item_lines = proc { |scan|
    @calling_proc = @current_proc
    @current_proc = "scan_parse_item_lines"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    respond "+---------------- scan:#{scan.inspect}" if @debug
    temp_items       = []
    other_lines      = []
    location_id      = scan[:id]
    match_fail_lines = []
    match_fail_count = 0
    ############
    command         = scan[:command]
    start_pattern   = /^(?:<popBold\/>)?(?:You are currently (?:wearing and )?(?:carrying)?(?:(?!, which conceals).)+$|^(?:<popBold\/>)?You are carrying nothing at this time|^(?:<popBold\/>)?You are holding)|^You currently have placed alongside you|^You have nothing placed alongside you.|That's not a valid option|^You are currently mounted on/i;
    end_pattern     = /^(?:<popBold\/>)?<prompt/;
    sp_lines        = self.client_command(command, start_pattern, end_pattern)
    # resend captured popBold
    _respond '<popBold/>' if (sp_lines[0] =~ /^<popBold\/>/ ? true : false;)

    count_line      = sp_lines.find { |line| @patterns[:inv_count].match(line) }
    displayed_count = 0
    if count_line !~ /nothing/
      displayed_count = @patterns[:inv_count].match(count_line).captures[0].to_i
    end
    _respond "command: #{scan[:command]}, count_line: #{count_line.inspect}, displayed_count: #{displayed_count.inspect}" if @debug
    ############
    prev_id     = empty_string
    prev_noun   = empty_string
    prev_level  = 0
    item_path   = []
    item_path_ids = []
    matched_count = 0
    # matched_count = -1 if XMLData.name =~ /Xanlin/
    sp_lines.each { |line|
      m = @patterns[:inv_full].match(line)
      if m
        matched_count += 1
        leading_space = m[:depth]
        prename       = m[:pre]
        id            = m[:exist]
        noun          = m[:noun].split(' ').first
        name          = m[:name].strip
        link_name     = m[:name].strip
        postname      = m[:post].strip
        other         = m[:attrs]
        registered    = other =~ /registered/ ? "Y" : empty_string
        marked        = other =~ /marked/ ? "Y" : empty_string
        hidden        = other =~ /hidden/ ? "Y" : empty_string;
        amount        = 1
        type          = name == "some blue lapis lazuli" ? "gem" : Inv_db.get_item_type(name, noun) || "unknown";
        level         = ((leading_space.length.to_i - 2) / 4).to_i
        item_path.push(prev_noun) if level > prev_level
        item_path_ids.push("##{prev_id}") if level > prev_level 
        if level < prev_level
          n_pop = prev_level - level;
          n_pop.times { item_path.pop; item_path_ids.pop; }
        end
        path = "#{item_path.join(' > ')}" if !item_path.nil?

        stack           = empty_string
        stack_name      = empty_string
        stack_noun      = empty_string
        stack_type      = empty_string
        stack_amount    = 0
        stack_status    = empty_string
        # respond "------------------------------------notes" if line =~ /notes/
        # stk = /^(?<stack>stack) of .*? notes|^(?<stack>bundle) of .*(?!arrows|bolts)$/i.match(name);
        stk = /^(?<stack>stack) of .*? notes$/i.match(name);
        stk = /^(?<stack>jar)/i.match(type) if !stk;
        # stk = /^(?<stack>jar|beaker|bottle)$/i.match(type);
        # stk[:stack] = 'jar' if stk and stk[:stack] =~ /(?:jar|beaker|bottle)$/i;
        if stk
          if stk[:stack] =~ /jar/i and @js2 and @js2[id][:amount] > 0
            # jarserve2 removes parts of the name, so let's not use that version.
            stack_name      = Inv_db.deplural(m[:post]).strip
            stack_noun      = @js2[id][:noun] =~ /lazuli/ ? "lapis" : @js2[id][:noun]
            stack_type      = (Inv_db.get_item_type(stack_name, stack_noun) || empty_string) if !postname.nil?
            stack_status    = @js2[id][:stack_status].encode('UTF-8')
            stack_amount    = @js2[id][:amount]
            stack           = stk[:stack] if stack_amount > 0
            # stack           = 'jar' if stack =~ /(?:jar|beaker|bottle)$/i;
            respond "#{stack_name}|#{stack_noun}|#{stack_type}|#{stack_status}|#{stack_amount}" if @debug
          elsif stk[:stack] =~ /jar/i and @settings_hash[stk[:stack].downcase] == true
            # respond "@settings_hash['#{stk[:stack].downcase}']: #{@settings_hash[stk[:stack].downcase]}" if @debug
            # stack_name      = Inv_db.deplural($6).strip
            stack_name      = Inv_db.deplural(m[:post]).strip
            stack_noun      = stack_name =~ /(.*?) ([\w\-]+)$/ ? $2 : empty_string
            stack_noun      = stack_noun =~ /lazuli/ ? "lapis" : stack_noun
            stack_type      = (Inv_db.get_item_type(stack_name, stack_noun) || empty_string) if postname != ''
            stack_amount    = 0
            stack_status    = "empty".encode('UTF-8')
            stack_path      = (item_path.length > 0 ? "in #{item_path_ids.reverse.join(" in ")}" : "") if postname =~ /containing/ or stk[:stack] !~ /jar/i
            stack_amount, stack_status = Inv_db.peek_stack(id, stack_path, stk[:stack]) #if postname =~ /containing/
            stack_status    = stack_status =~ /^(full|empty)/ ? stack_status : "partial".encode('UTF-8')
            stack           = stk[:stack] if stack_amount > 0
          elsif @settings_hash[stk[:stack].downcase] == true
            # respond "@settings_hash['#{stk[:stack].downcase}']: #{@settings_hash[stk[:stack].downcase]}" if @debug
            stack_name      = Inv_db.deplural(name.gsub(/^(?:bundle|stack) of/, '')).strip
            stack_noun      = Inv_db.deplural(noun).strip
            stack_type      = (Inv_db.get_item_type(stack_name, stack_noun) || empty_string)
            stack_path      = (item_path.length > 0 ? "in #{item_path_ids.reverse.join(" in ")}" : "") if postname =~ /containing/ or stk[:stack] !~ /jar/i
            stack_amount, stack_status = Inv_db.peek_stack(id, stack_path, stk[:stack])
            respond "stack_amount, stack_status: #{stack_amount}, #{stack_status}" if @debug
            stack = stk[:stack] if stack_amount > 0
          end
        end
        prename = prename =~ /^(an |a |some )(.*)?/ ? $2 : prename

        containing = stack == empty_string ? empty_string : "(#{stack_name}) (#{stack_amount})"
        postname      = postname.gsub(/ *containing.*$/,'').encode('UTF-8')
        name          = "#{prename.strip} #{name =~ /^(some )?(.*)/ ? $2 : name}#{(' ' + "#{postname}").rstrip}".strip;
        # name          = "#{prename} #{name =~ /^(some )?(.*)/ ? $2 : name}".strip;
        # name          = "#{prename}#{name =~ /^(some )?(.*)/ ? $2 : name} #{stack == "" ? postname : (stack_name == "" ? "" : "(#{stack_name}) ") + "(#{stack_amount})"}".strip
        type          = 'boh' if @settings_hash['boh'].include?(name)
        prev_id       = id
        prev_level    = level.to_i
        prev_noun     = noun
        temp_items.push({
          # :rn           => rn,
          :id           => id,
          :location_id  => location_id.to_i,
          :level        => level.to_i,
          :path         => path.encode('UTF-8'),
          :type         => type.encode('UTF-8'),
          :name         => name.encode('UTF-8'),
          :link_name    => link_name.encode('UTF-8'),
          :containing   => containing.encode('UTF-8'),
          :noun         => noun.encode('UTF-8'),
          :amount       => amount.to_i,
          :stack        => empty_string,
          :stack_status => stack_status,
          :marked       => marked.encode('UTF-8'),
          :registered   => registered.encode('UTF-8'),
          :hidden       => hidden.encode('UTF-8'),
          :update_noun  => 1
        })

        temp_items.push({
          :id           => id,
          :location_id  => location_id.to_i,
          :level        => level + 1,
          :path         => item_path.length > 0 ? "#{path} > #{stack}".encode('UTF-8') : "#{stack}".encode('UTF-8'),
          :type         => stack_type.encode('UTF-8'),
          :name         => stack_name.encode('UTF-8'),
          :link_name    => empty_string,
          :containing   => empty_string,
          :noun         => stack_noun.encode('UTF-8'),
          :amount       => stack_amount.to_i,
          :stack        => stack.encode('UTF-8'),
          :stack_status => empty_string,
          :marked       => empty_string,
          :registered   => empty_string,
          :hidden       => empty_string,
          :update_noun  => 1
        }) if stack != "";

        if @settings_hash['boh'].include?(name)
          respond "#{name} is a boh" if @debug
          verb = 'look in'
          if name =~ /tackle/
            verb = 'gaze'
          end
          id_path = item_path_ids.join(" in ")
          respond "Inv_db.peek_boh(#{id.inspect},#{location_id.inspect},#{level.inspect},#{path.inspect},#{id_path.inspect},#{noun.inspect},#{verb.inspect})" if @debug
          boh_items = Inv_db.peek_boh(id, location_id, level, path, id_path, noun, verb)
          if boh_items.size > 1
            temp_items.concat(boh_items)
          end
        end
      else
        match_fail_lines << line
        match_fail_count += 1
      end
    }
    if matched_count == displayed_count
      @inv_items = @inv_items + temp_items
      @inventory_count += displayed_count if displayed_count > 0
    else
      _respond "total lines scanned: #{sp_lines.count}"
      _respond "parse count: #{matched_count} != displayed count: #{displayed_count}"
      _respond "failed on lines:\n\n#{match_fail_lines.join('\n')}\n\n"
      if @inv_retry < 4
        _respond "retrying after error in scan & parse: #{scan[:command]}"
        _respond "match_fail_count = #{match_fail_count}"
        _respond "match_fail_lines: #{match_fail_lines.join("\n")}"
        @inv_retry += 1
        _respond "starting attempt ##{@inv_retry}"
        scan_parse_item_lines.call(scan)
      else
        _respond "something is fucky, let's dump the lines:\n\n"
        sp_lines.each_with_index { |line, index|
          respond "#{index}:#{line}"
        }
        _respond "\n\n"
        _respond "giving up on inventory scan, exiting."
        _respond other_lines.join("\n")
        _respond "giving up on inventory scan, exiting."
        close_containers.call
        exit
      end
    end
  }

  # debug_parsed_items = proc {
  #   table_headers =  ["location_id", "level", "path", "type", "noun", "name", "amount", "stack", "stack_status"]
  #   table_format = "| % -12s | %-5s | %-20s | %-9s | %-8s | %-36s | %-8s | %-8s | %-8s |"
  #   respond table_format % table_headers
  #   @inv_items.each { |v|
  #     respond table_format % [v[:location_id], v[:level], v[:path], v[:type], v[:noun], v[:name], v[:amount], v[:stack], v[:stack_status]]
  #   }
  # }

  locker_info = proc {
    @calling_proc = @current_proc
    @current_proc = "locker_info"
    respond "+---------------- proc_start: #{@current_proc}" if @debug

    command         = "locker info"
    start_pattern   = /^#{XMLData.name}, your locker information is as follows:|(?:You possess locker(?<multi>s)|Your locker(?<multi>s)? in .* are currently being swapped|Your locker is currently located in the town of (?<town>.*?)\.|Your locker(?<town> )|(?<town>WARNING).*?: *You currently possess lockers in multiple towns.  However, you are no longer eligible for them.)/i;
    end_pattern     = /^(?:<popBold\/>)?<prompt/;
    locker_info_result = self.client_command(command, start_pattern, end_pattern).join("\n")

    m = @patterns[:locker_info].match(locker_info_result)
    if m[:multi] == "s"
      @locker_location = "multi"
      # @subscription   = "premium" if @subscription.nil?
    end
    if m[:town]
      @locker_location = m[:town] == "Kharag 'doth Dzulthu" ? "Zul Logoth" : m[:town]
      # @subscription   = "standard" if @subscription.nil?
    end
    @locker_location = @locker_location || "transit"
    # @subscription   =  "standard"  if @subscription.nil?
    # respond "locker_info: @subscription:#{@subscription.inspect}" if @debug

    @locker_info_run = true
  }

  refresh_locker = proc {
    @calling_proc = @current_proc
    @current_proc = "refresh_locker"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    locker_info.call if !@locker_info_run
    locker_premium.call  if @subscription == "premium"
    locker_standard.call if @subscription != "premium"
  }

  def self.object_find(string, _preposition = nil)
    obj = GameObj.room_desc.find { |i| i.name =~ /#{string.split(' ').join('.*?')}/ }
    obj = GameObj.loot.find { |i| i.name =~ /#{string.split(' ').join('.*?')}/ } if obj.nil?
    return obj
  end

  def self.object_close(o, path = nil)
    command       = "close #{o.class == String ? o : "##{o.id}"}#{path.nil? ? "" : " #{path}"}"
    start_pattern = /#{o.class == String ? "" : "#{o.id}|"}You close .*|That is already closed|What were you referring to|seem to be any way to do that|You tie/
    quiet         = @quiet;
    end_pattern   = /(<popBold\/>)?<prompt/;
    timeout       = 2
    return self.client_command(command, start_pattern, end_pattern, quiet, timeout)
  end

  def self.object_open(o, path = nil)
    return [] if o.class == GameObj and o.name =~ @containers_noopen_pattern;
    command       = "open #{o.class == String ? o : "##{o.id}"}#{path.nil? ? "" : " #{path}"}"
    start_pattern = /#{o.class == String ? "" : "#{o.id}|"}^<(?:container|clearContainer|exposeContainer)|That is already open|<container|There doesn't seem to be any way to do that.|You open|What were you referring to|Try holding it first/i
    quiet         = @quiet;
    end_pattern   = /(<popBold\/>)?<prompt/;
    timeout       = 2
    return self.client_command(command, start_pattern, end_pattern, quiet, timeout)
  end

  def self.object_look(o, preposition = 'in', path = nil)
    path          = 
    command       = "look #{preposition} #{o.class == String ? o : "##{o.id}"}#{path.nil? ? "" : " #{path}"}"
    start_pattern = /#{o.class == String ? "" : "#{o.id}|"}^<(?:container|clearContainer|exposeContainer)|That is closed|You see the shifting form|There is nothing|I could not find|You see nothing unusual|Try holding it first|Too many container windows already open.  Unable to open more./
    quiet         = @quiet;
    end_pattern   = /(<popBold\/>)?<prompt/;
    timeout       = 3
    respond "object_look: command: #{command.inspect}" if @debug
    return self.client_command(command, start_pattern, end_pattern, quiet, timeout, quiet)
  end

  locker_open = proc {
    @calling_proc = @current_proc
    @current_proc = "locker_open"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    # open_locker = dothistimeout "open ##{locker.id}", 3, @patterns[:locker_open] #/Your locker is currently holding (\d+) items? out of a maximum of (\d+)|That is already open/i
    open_locker = self.object_open(locker).join("/n")
    (self.object_close(locker); locker_open.call;) if open_locker =~ /That is already open/

    if open_locker =~ @patterns[:locker_open] # /Your locker is currently holding (\d+) items? out of a maximum of (\d+)/i
      locker_look_count    = $1
      locker_item_capacity = $2
    end
    self.object_look(locker, "in")
  }

  locker_standard = proc {
    @calling_proc = @current_proc
    @current_proc = "locker_standard"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    not_in_locker = true;
    respond "-----Looking for locker by name" if @debug
    locker = GameObj.loot.find { |i| locker = i if i.name =~ /your locker/i }
    if !locker
      respond "-----Looking for locker by noun" if @debug
      locker = GameObj.loot.find { |i| locker = i if i.noun =~ /locker/i }
    end
    if !locker
      respond "-----Looking for locker by interaction" if @debug
      close_result = self.object_close("locker").join("/n")
      if close_result !~ /What were you referring/
        open_result = self.object_open("locker")
        if m = /<a exist="(?<id>\-?\d+)" noun="(?<noun>locker)">(?<name>.*?)<\/a>/i.match(open_result.join("\n"))
          _respond "#{m[:id]} | #{m[:noun]} | #{m[:name]}" if @debug
          locker = GameObj.new(m[:id], m[:noun], m[:name])
        end
      end
    end
    if !locker
      not_in_locker = true;
      respond "Couldn't find your locker" if target == "locker"
    end
    if locker
      sorter_handler.call
      not_in_locker = false;
      locker_open.call
      respond "locker_look_count:#{locker_look_count.inspect}  |  locker_item_capacity:#{locker_item_capacity.inspect}" if @debug

      # locker_items = self.traverse_container(locker, "in", "", -1, @settings_hash['open_containers'], 9, false)
      locker_items, item_categories, _has_in, _has_on = self.traverse_container(locker, "in", "", "", -1, @settings_hash['open_containers'], 9, false)
      self.item_category_merge(db, item_categories)

      locker_items.each { |i| i[:location_id] = 10 }
      respond "locker_items.count: #{locker_items.count} " if @debug

      normalize_path = true
      prepositions = ['in', 'on', 'under', 'behind']

      if normalize_path
        locker_items.each { |h|
          path_segments = h[:path].scan(/(#{prepositions.join(' |')} )((?:(?!#{prepositions.join(' |')}).)*)/)
          h[:path] = path_segments.reverse.join().gsub(/(#{prepositions.join(' |')} )/, ' > ').gsub(/ +/, ' ').gsub(/^ *> */, '').strip
          # npath = h[:path].gsub(/^ ?in /, '')
          # npath = npath.split(' in ')
          # npath.each { |i| i.strip! }
          # npath = npath.reverse.join(' > ')
          # h[:path] = npath
        }
      end
      locker_standard_debug.call(locker_items) if @debug
      insert_temp_item_locker.call(locker_items) if locker_items.count > 0
      merge_item_by_location.call(10)
    end

    if @subscription != 'f2p'
      scan_time = Benchmark.realtime do;
        locker_manifest_scrape.call(40, 'family vault')
      end;
      Inv_db.gs_print "+----locker manifest Family Vault total time elapsed #{(scan_time * 1000).round(2)} milliseconds" if @benchmark;
      insert_temp_item_premium_locker.call(40)
      merge_item_by_location.call(40)
    end
  }

  locker_standard_debug = proc { |items|
    @calling_proc = @current_proc
    @current_proc = "locker_standard_debug"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    table_hl     = "+------------------------+-------+------------------------+-------------------+-------------------+"
    table_format = "| %-22s | %-3s | %-32s | %-22s| %-32s "
    table_headers = ["type", "lvl", "path", "noun", "name"]
    output = []
    rows = []
    rows << table_headers
    # output << table_hl
    # output << table_format % table_headers
    # output << table_hl
    items.each { |i|
      rows << [i[:type], i[:level], i[:path], i[:noun], i[:name]]
    }
    # output << table_hl
    self.to_table(rows)
    output << "+-------- Item count != listed item count." if locker_look_count.to_i != items.count.to_i
    output << "+-------- Item count == listed item count." if locker_look_count.to_i == items.count.to_i
    respond output
  }

  locker_premium = proc {
    @calling_proc = @current_proc
    @current_proc = "locker_premium"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    @locations.each { |k, v|
      if k.to_i > 10 and v[:type] == 'locker'
        @locker_items = []
        scan_time = Benchmark.realtime do;
          locker_manifest_scrape.call(k.to_i, v)
        end;
        insert_temp_item_premium_locker.call(k.to_i)
        merge_item_by_location.call(k.to_i)
        Inv_db.gs_print "+----locker manifest(#{k}) #{v[:name]} total time elapsed #{(scan_time * 1000).round(2)} milliseconds" if @benchmark;
      end
    }
  }

  locker_manifest_scrape = proc { |location_id|
    @calling_proc = @current_proc
    @current_proc = "locker_manifest_scrape"
    respond "+---------------- proc_start: #{@current_proc} #{location_id}" if @debug

    lm_lines        = []
    other_lines     = []
    location        = @locations[location_id.to_s][:name]
    displayed_count = 0

    command         = "locker manifest #{location}"
    start_pattern   = /^Thinking back, you recall|^Looking in front of you|^You must first visit your local locker before using the LOCKER MANIFEST command in this town.|^You must have a Premium|Unknown town specified|You do not currently have a.*? vault.|^Unknown town specified/
    end_pattern     = /^(?:<popBold\/>)?<prompt/;
    locker_manifest_command_time = Benchmark.realtime do;
      lm_lines = self.client_command(command, start_pattern, end_pattern)
      lm_lines = self.client_command(command, start_pattern, end_pattern) if lm_lines.nil?
    end;
    Inv_db.gs_print "+--------locker_manifest_command #{location_id} time elapsed #{(locker_manifest_command_time * 1000).round(2)} milliseconds" if @benchmark
    count_line      = lm_lines.find { |line| @patterns[:manifest_count].match(line) }
    displayed_count = 0
    if count_line !~ /nothing/
      displayed_count = @patterns[:manifest_count].match(count_line).captures[0].to_i
    end

    locker_manifest_parse_time = Benchmark.realtime do;
      if lm_lines.join("\n") !~ /You must have a Premium|You must first visit your local locker before using the LOCKER MANIFEST command in this town.|You do not currently have a.*? vault./
        parse_manifest.call(lm_lines, location_id, displayed_count, other_lines) if lm_lines.size > 0
      end
    end;
    Inv_db.gs_print "+--------locker_manifest_parse #{location_id} time elapsed #{(locker_manifest_parse_time * 1000).round(2)} milliseconds" if @benchmark
  }

  parse_manifest = proc { |pm_lines, location_id, displayed_count, other_lines|
    temp_items = []
    matched_count = 0
    match_fail_lines = []
    match_fail_count = 0
    if pm_lines.size > 0
      Inv_db.gs_print("+-------- #{pm_lines.size} pm_lines to parse") if @debug or @benchmark
    end

    prev_name   = ""
    prev_noun   = ""
    prev_level  = 0
    item_path   = []
    base_path   = nil

    pm_lines.each { |line|
      if (c = @patterns[:locker_container].match(line));
        base_path = c[:noun]
        item_path = [base_path.clone]
      #elsif (m = @patterns[:manifest].match(line));
      elsif (m = @patterns[:manifest_inside].match(line) or m = @patterns[:manifest].match(line));
        matched_count += 1
        leading_space = m[:depth] =~ /<d/ ? m[:depth].gsub!(/<[^>]+>/, "").gsub!(" ", "-") : m[:depth].gsub!(" ", "-")
        prename       = m[:pre] =~ /^(an |a |some )(.*)?/ ? $2.strip : m[:pre]
        id            = m[:exist]
        name          = m[:name].gsub(/<[^>]*>/, '').strip
        link_name     = !id.nil? ? m[:name].strip : empty_string
        # noun          = !m[:noun].nil? ? m[:noun] : name.strip.scan(/^(?:.*?) ([^\s]+)$|^([^ ]+)$/).flatten.join('')
        noun          = m[:noun] # Inv_db.noun_test(name)
        postname      = m[:post]
        attrs         = m[:attrs]
        registered    = attrs =~ /registered/ ? "Y" : empty_string
        marked        = attrs =~ /marked/     ? "Y" : empty_string
        hidden        = attrs =~ /hidden/     ? "Y" : empty_string
        amount        = 1
        # type          = name == "some blue lapis lazuli" ? "gem" : Inv_db.get_item_type(name,noun) || 'unknown' #empty_string
        type = Inv_db.get_item_type(name, noun) || 'unknown' # empty_string
        level = ((leading_space.length.to_i - 6) / 2).to_i

        item_path.push(prev_noun) if level > prev_level
        if level < prev_level
          n_pop = prev_level - level;
          n_pop.times { item_path.pop; }
          item_path = [base_path] if item_path.length == 0
        end

        path          = "#{item_path.join(' > ')}" if !item_path.nil?
        stack         = empty_string
        stack_name    = empty_string
        stack_noun    = empty_string
        stack_type    = empty_string
        stack_amount  = 0
        status        = empty_string
  
        if type =~ /\bjar\b/
          # if type =~ stack_pattern
          stack_name      = Inv_db.deplural(postname).strip
          stack_noun      = stack_name =~ /(.*?) ([^\s]+)$/ ? $2 : empty_string
          stack_noun      = empty_string # stack_noun =~ /lazuli/ ? "lapis" : stack_noun
          stack_type      = Inv_db.get_item_type(stack_name, nil) if !postname.nil?
          stack_amount    = attrs =~ /\((\d+)\/\d+\)/ ? $1 : nil
          status          = stack_amount.nil? ? "empty".encode('UTF-8') : attrs =~ /\((\d+)\/\1\)/ ? "full".encode('UTF-8') : "partial".encode('UTF-8')
          stack           = "jar" if stack_amount.to_i > 0
        end

        containing    = stack == empty_string ? empty_string : "(#{stack_name}) (#{stack_amount})"
        #containing    = /containing (.*?)(?:(?=\(\D|$))/.match(postname).captures.first.strip.encode('UTF-8') || empty_string
        #if m[:exist].nil?
        #  name          = "#{prename.strip} #{name =~ /^(some )?(.*)/ ? $2.strip : name.strip}".strip;
        #else
          name          = "#{prename.strip} #{name =~ /^(some )?(.*)/ ? $2.strip : name.strip} #{stack == "" ? postname.strip : ""}".strip;
        #end
        #name          = "#{prename}#{name =~ /^(some )?(.*)/ ? $2.strip : name.strip} #{stack == "" ? postname.strip : "(#{postname.strip}) #{stack_manifest.strip}"}".strip
        prev_level    = level.to_i
        prev_noun     = noun.nil? ? Inv_db.noun_test(name) : noun
        prev_name     = name

        temp_items.push({
          :id           => id,
          :location_id  => location_id.to_i,
          :level        => level + 1,
          :path         => path.encode('UTF-8'),
          :type         => type ? type : empty_string,
          :name         => name.encode('UTF-8'),
          :link_name    => link_name.encode('UTF-8'),
          :containing   => containing.encode('UTF-8'),
          :noun         => noun.nil? ? Inv_db.noun_test(name).encode('UTF-8') : noun.encode('UTF-8'),
          :amount       => amount.to_i,
          :stack        => empty_string,
          :stack_status => status.encode('UTF-8'),
          :marked       => marked.encode('UTF-8'),
          :registered   => registered.encode('UTF-8'),
          :hidden       => hidden.encode('UTF-8'),
          :update_noun  => id ? 1 : 0
        })

        temp_items.push({
          :id           => id,
          :location_id  => location_id.to_i,
          :level        => level + 1,
          :path         => "#{path} > #{stack}".to_s.encode('UTF-8'),
          :type         => stack_type ? stack_type : empty_string,
          :name         => stack_name.encode('UTF-8'),
          :link_name    => empty_string,
          :containing   => empty_string,
          :noun         => stack_noun.encode('UTF-8'),
          :amount       => stack_amount.to_i,
          :stack        => stack.encode('UTF-8'),
          :stack_status => empty_string,
          :marked       => empty_string,
          :registered   => empty_string,
          :hidden       => empty_string,
          :update_noun  => 0
        }) if stack != "";
      else # no match
        match_fail_lines << line
        match_fail_count += 1
      end
    }
    if matched_count == displayed_count
      @manifest_retry = 1;
      @manifest_count += displayed_count
      matched_count = 0;
      @locker_items = @locker_items + temp_items
    else
      _respond "parse count: #{matched_count} != displayed count: #{displayed_count}"
      if @manifest_retry < 4
        _respond "retrying after missing lines in manifest: #{location_id}"
        _respond "match_fail_count = #{match_fail_count}"
        _respond "match_fail_lines: #{match_fail_lines.join("\n")}"
        @manifest_retry += 1
        _respond "starting attempt ##{@manifest_retry}"
        locker_manifest_scrape.call(location_id)
      else
        _respond other_lines.join("\n")
        _respond "giving up on manifest scan, exiting."
        exit
      end
    end
  }

  query_item = proc { |params|
    @calling_proc = @current_proc
    @current_proc = "query_item"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    respond "+----params:#{params.inspect}" if @debug
    
    rows = []
    if !params.any?{|h| h[:name] =~ /^(?:room|prop|object)/ }
      sql, qargs = Inv_db.query_item_sql(params.clone, style)
      rows = self.execute2(sql, qargs, db)
    end
    room_rows = []
    if target =~ /item|all/ and !params.any?{|h| h[:name] =~ /^(?:char|location|account|hidden|registered|marked)/ }
      sql, qargs = self.room_inventory_query_sql(params)
      room_rows = self.execute2(sql, qargs, db)
    end
    regex_highlight = !params.find { |h| h[:name] == 'search_filter' and h[:operator] == 'REGEXP' }.nil?
    if (room_rows.size + rows.size) == 0
      Inv_db.format_whisper("no results found#{target.nil? ? '' : " in #{target}"}.");
    else
      self.check_output_size(rows.size + room_rows.size)
      Inv_db.output_table(rows, target, qargs, "item", regex_highlight) if rows.size > 0
      Inv_db.output_table(room_rows, 'room_inventory', qargs, "room_inventory", regex_highlight) if room_rows.size > 0
    end
  };

  #------------------------------------------------------------------------------#
  # sum / aggregate queries
  #------------------------------------------------------------------------------#
  sum_item = proc { |params|
    @calling_proc = @current_proc
    @current_proc = "sum_item"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    respond "+----params:#{params.inspect}" if @debug
    sql, qargs = Inv_db.sum_item_sql(params.clone, "")
    Inv_db.gs_print sql if @debug_sql
    begin
      rows = db.execute2(sql, qargs)
    rescue SQLite3::BusyException
      sleep 0.1
      retry
    end
    Inv_db.output_table(rows, target, qargs, "item")
  };
  count_item = proc { |params|
    @calling_proc = @current_proc
    @current_proc = "count_item"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    respond "+----params:#{params.inspect}" if @debug
    sql, qargs = Inv_db.count_item_sql(params.clone, "")
    Inv_db.gs_print sql if @debug_sql
    begin
      rows = db.execute2(sql, qargs)
    rescue SQLite3::BusyException
      sleep 0.1
      retry
      #    ensure
      #      #db.close if db
    end
    Inv_db.output_table(rows, target, qargs, "item")
  };

  def self.count_room_inventory(params, db)
    @calling_proc = @current_proc
    @current_proc = "count_room_inventory"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    respond "+----params:#{params.inspect}" if @debug
    sql, qargs = self.count_room_inventory_sql(params.clone, "")
    Inv_db.gs_print sql if @debug_sql
    rows = self.execute2(sql, qargs, db)
    # begin
      # Inv_db.gs_print sql if @debug_sql
      # rows = db.execute2(sql, qargs, db)
    # rescue SQLite3::BusyException
      # sleep 0.1
      # retry
      # #    ensure
      # #      #db.close if db
    # end
    Inv_db.output_table(rows, target='room_inventory', qargs, "item")
  end
  
  #------------------------------------------------------------------------------#
  # itemdb
  #------------------------------------------------------------------------------#

  def self.item_category_merge(db = nil, item_categories = {}, game = nil)
    respond "+----item_category_merge" if @debug
    return if item_categories.empty?
    close_db = false
    (close_db = true; db = Inv_db.open) if db.nil?
    game = game.nil? ? XMLData.game.encode('UTF-8') : game.encode('UTF-8')
    sql = "
    update item set
        category = :category
    where name = :name
      and game = :game
      and category = ''"
    db_changes = 0
    temp_item_time = Benchmark.realtime do;
      item_categories.each { |k, v|
        _rows, changes = self.execute(sql, { :category => v.encode('UTF-8'), :name => k.encode('UTF-8'), :game => game }, db)
        db_changes += changes
      }
      @db_changes[:item_categories][:updated] = db_changes
    end
    Inv_db.gs_print "+----item_category_merge time elapsed #{(temp_item_time * 1000).round(2)} milliseconds" if @benchmark;
    respond "item_category_merge: db_changes: #{db_changes}" if @debug
    db.close if close_db;
  end

  def self.item_base_merge(db, table)
    @current_proc = "item_base_merge";
    changes = 0
    new_item_args = { :game => XMLData.game.encode('UTF-8') }
    # update
    # Inv_db.to_table(db.execute2("select * from #{table} t")) if db.get_first_value("select location_id from #{table}").to_i == 19  ###REMOVEME
    update_item_sql = "
    update item set
        noun      = ( select noun      from #{table} t where t.update_noun = 1 and t.name = item.name limit 1) 
      , link_name = ( select link_name from #{table} t where t.update_noun = 1 and t.name = item.name limit 1) 
      , type      = ( select type      from #{table} t where t.update_noun = 1 and t.name = item.name limit 1) 
    where 1 = 1
      and item.game like :game
      and item.link_name = ''
      and exists (
        select 1
        from #{table} t
        where t.update_noun = 1 
          and t.name = item.name
        limit 1);"
    
    temp_time = Benchmark.realtime do;
      _rows, changes = self.execute(update_item_sql, new_item_args, db)
      Inv_db.gs_print "item_base_merge: update: #{changes} changes" if @debug
      @db_changes[:item_base][:updated] = changes
    end
    Inv_db.gs_print "+--------- item_base update with #{changes.inspect} changes, time elapsed #{(temp_time * 1000).round(2)} milliseconds" if @benchmark; 
    
    # insert 
    select_new_item_sql = %{
    select name, max(link_name) as link_name, max(noun) as noun, max(type) as type, :game as game
    from temp_room_item t
    where not exists (select 1 from item i where i.name = t.name and i.game = :game)
      and ltrim(rtrim(name)) <> ''
    group by name;}
    Inv_db.to_table(self.execute2(select_new_item_sql, new_item_args, db)) if @debug
    
    insert_item_sql = "
    insert into item(name, link_name, noun, type, game)
    select 
        name
      , max(link_name) as link_name
      , max(noun) as noun
      , case when ltrim(max(type)) == '' then 'unknown' else max(type) end as type
      , :game as game
    from #{table} t
    where not exists (select 1 from item i where i.name = t.name and i.game = :game)
      and ltrim(rtrim(name)) <> ''
    group by name;"

    temp_time = Benchmark.realtime do;
      _rows, changes = self.execute(insert_item_sql, new_item_args, db)
      Inv_db.gs_print "item_base_merge: insert: #{changes} changes" if @debug
      @db_changes[:item_base][:inserted] = changes
    end
    Inv_db.gs_print "+--------- item_base insert with #{changes.inspect} changes, time elapsed #{(temp_time * 1000).round(2)} milliseconds" if @benchmark; 
  end
    
  def self.sorted_view_scan_inventory(db = nil)
    # manage hook
    if @rehook_inventory_boxes_off == false and DownstreamHook.list.find{|h| h == 'inventory_boxes_off'}
      DownstreamHook.remove('inventory_boxes_off')
      @rehook_inventory_boxes_off = true
      before_dying { self.hook_inventory_boxes; }
    end
    # 
    sorted_view_scan_inventory_time = Benchmark.realtime do
      @containers_with_contents = self.containers_with_contents_get if @containers_with_contents.nil? or @containers_with_contents.empty?
      (respond "@containers_with_contents is empty";return) if @containers_with_contents.empty?
      preposition = 'in'
      merge_categories = Hash.new
      @containers_with_contents.each{|id, path|
        items, item_categories, _has_in, _has_on = self.traverse_container("##{id}", preposition, '', '', -1, @settings_hash["open_containers"])
        merge_categories.merge!(item_categories) if item_categories.class == Hash
      }
      self.item_category_merge(db, merge_categories)
    end
    Inv_db.gs_print "+--------- sorted_view_scan_inventory time elapsed #{(sorted_view_scan_inventory_time * 1000).round(2)} milliseconds" if @benchmark; 
  end
  
  def self.sorted_view_scan_premium_locker(db = nil)
    # manage hook
    if @rehook_inventory_boxes_off == false and DownstreamHook.list.find{|h| h == 'inventory_boxes_off'}
      DownstreamHook.remove('inventory_boxes_off')
      @rehook_inventory_boxes_off = true
      before_dying { self.hook_inventory_boxes; }
    end
    # 
    sorted_view_scan_premium_locker = Benchmark.realtime do
      h = {"weapon rack"=> "on","armor stand"=> "on","clothing wardrobe"=> "in","magical item bin"=> "in","deep chest" => "in", "dark stained antique oak trunk" => "in"}
      merge_categories = Hash.new
      h.each { |name,preposition|
        id = GameObj.loot.find{|o| o.name==name}.id
        #respond "id:#{id.inspect}"
        next if id.nil?
        items, item_categories, _has_in, _has_on = self.traverse_container("##{id}", preposition, '', '', 9, @settings_hash["open_containers"])
        merge_categories.merge!(item_categories) if item_categories.class == Hash
        #if name == "deep chest"
          # respond item_categories.inspect
        #end
      }
      self.item_category_merge(db, merge_categories)
    end
    Inv_db.gs_print "+--------- sorted_view_scan_premium_locker time elapsed #{(sorted_view_scan_premium_locker * 1000).round(2)} milliseconds" if @benchmark; 
  end

  #------------------------------------------------------------------------------#
  # itemdb - queries
  #------------------------------------------------------------------------------#
  def self.item_base_query(db, params)
    close_db = false
    (close_db = true; db = Inv_db.open) if db.nil?
    where, qargs, extras = self.where_builder(params, 'item_base')
    select  = "\n    select i.id, i.game, i.noun, i.category, i.type, i.name, i.link_name"
    from    = "\n    from item i"
    orderby = "\n    order by i.id desc"
    orderby = "\n    order by #{extras[:orderby]}" if extras.key?(:orderby);
    limit   = "\n    limit #{extras[:limit]}" if extras.key?(:limit);
    sql = "#{select}#{from}#{where}#{orderby}#{limit}";
    rows = self.execute2(sql, qargs, db)
    self.check_output_size(rows.size)
    Inv_db.output_table(rows, 'item_base', qargs, 'item_base')
    db.close if close_db;
  end
  
  def self.item_detail_query(db = nil, params = {})
    close_db = false
    (close_db = true; db = Inv_db.open) if db.nil?
    where, qargs, extras = self.where_builder(params, 'item_detail')
    select  = "\n    select i.name, id.*"
    from    = "\n    from item_detail id
      inner join item i on i.id = id.item_id"
    orderby = "\n    order by id.note desc"
    orderby = "\n    order by #{extras[:orderby]}" if extras.key?(:orderby);
    limit   = "\n    limit #{extras[:limit]}" if extras.key?(:limit);
    sql = "#{select}#{from}#{where}#{orderby}#{limit}";
    rows = self.execute2(sql, qargs, db)
    self.check_output_size(rows.size)
    Inv_db.output_table(rows, 'item_detail', qargs, 'item_detail')
    db.close if close_db;
  end
  
  def self.item_note_query(_db = nil, _params = {})
    close_db = false
    (close_db = true; db = Inv_db.open) if db.nil?
    where, qargs, extras = self.where_builder(params, 'item_detail')
    select  = "\n    select i.name, id.*"
    from    = "\n    from item_detail id
      inner join item i on i.id = id.item_d"
    orderby = "\n    order by id.note desc"
    orderby = "\n    order by #{extras[:orderby]}" if extras.key?(:orderby);
    limit   = "\n    limit #{extras[:limit]}" if extras.key?(:limit);
    sql = "#{select}#{from}#{where}#{orderby}#{limit}";
    rows = self.execute2(sql, qargs, db)
    self.check_output_size(rows.size)
    Inv_db.output_table(rows, 'item_detail', qargs, 'item_detail')
    db.close if close_db;
  end
  
  def self.right_hand_full_name()
    lines = self.client_command("glance",/You glance down/)
    right_hand_pattern = @patterns[:glance_right]
    link_name, name = nil;
    lines.each{|line|
      if (i = right_hand_pattern.match(line))
        link_name = i[:link_name].encode('UTF-8')
        name = "#{i[:before_name]}#{i[:link_name]}#{i[:after_name]}".encode('UTF-8')
      end
    }
    return link_name, name.encode('UTF-8')
  end
  
  def self.item_id_lookup(db = nil, name = nil, game = nil)
    return nil if GameObj.right_hand.id.nil? and name.nil?
    close_db = false
    (close_db = true; db = Inv_db.open) if db.nil?
    item_id = nil
    name = self.right_hand_full_name.last if name.nil?
    game = XMLData.game if game.nil?
    qargs = { :name => name.encode('UTF-8'), :game => game.encode('UTF-8') }
    sql = %{ select id from item where name = :name and game = :game limit 1 }
    item_id = self.execute2(sql, qargs, db)[1].first
    if item_id.nil?
      sql = %{ select id from item where link_name = :name and game = :game limit 1 }
      item_id = self.execute2(sql, qargs, db)[1].first
    end
    db.close if close_db;
    return item_id
  end
  
  def self.item_note_upsert(db = nil, params = {})
    close_db = false
    (close_db = true; db = Inv_db.open) if db.nil?
    _where, qargs, _extras = self.where_builder(params, 'room')
    args = {}
    qargs.each { |k, v| key = k.to_s.gsub('_filter', '').to_sym; args[key] = v.class == String ? v.encode('UTF-8') : v }
    # add timestamp to note ?
    # get item_id for item in right hand if item_id not in qargs
    
    hash_args.merge!(args)
    sql = "
      insert into item_detail(item_id, note)
      select :item_id, :note
      where not exists (select 1 from item_detail where item_id = :item_id and note = :note)"
    _rows, changes = self.execute(sql, hash_args, db)
    @db_changes[:item_detail][:inserted] += changes
    if changes == 0
      sql = "
        update item_detail set
          , note = :note
        where item_id = :item_id"
      _rows, changes = self.execute(sql, hash_args, db)
      @db_changes[:item_detail][:updated] += changes
    end
    db.close if close_db;
  end
  
  def self.item_note_edit_gui()
    respond "not implemented"
    
  end
  #------------------------------------------------------------------------------#
  # propdb
  #------------------------------------------------------------------------------#
  @rehook_inventory_boxes_off = false
  def self.hook_inventory_boxes()
    if @rehook_inventory_boxes_off == true
      inv_off_proc = proc { |server_string|
         if server_string =~ /^<(?:container|clearContainer|exposeContainer)/
            server_string.gsub!(/<(?:container|clearContainer|exposeContainer)[^>]*>|<inv.+\/inv>/, '')
            if server_string.empty?
               nil
            else
               server_string
            end
         elsif server_string =~ /^<flag id="Display Inventory Boxes" status='on' desc="Display all inventory and container windows."\/>/
            server_string.sub("status='on'", "status='off'")
         elsif server_string =~ /^\s*<d cmd="flag Inventory off">Inventory<\/d>\s+ON/
            server_string.sub("flag Inventory off", "flag Inventory on").sub('ON', 'OFF')
         else
            server_string
         end
      }
      DownstreamHook.add('inventory_boxes_off', inv_off_proc)
    end
  end

  def self.property_refresh(db, params = {}, property = nil)
    close_db = false
    (close_db = true; db = Inv_db.open) if db.nil?
    respond "property refresh" if @debug
    sql = "select property from room where uid = :uid and game = :game limit 1"
    qargs = { :uid => XMLData.room_id, :game => XMLData.game.encode('UTF-8') }
    property = self.execute(sql, qargs, db)[0][0][0] if property.nil?
    (Inv_db.gs_print("property not found for the current room"); return nil) if property.nil?
    sql = "select uid, lich_id from room where property like :property and game = :game"
    qargs = { :property => property.encode('UTF-8'), :game => XMLData.game.encode('UTF-8') }
    rooms_result = self.execute(sql, qargs, db)[0]
    (Inv_db.gs_print("Not currently in #{property}."); return nil) if rooms_result.find { |uid, _lich_id| uid == XMLData.room_id }.nil?
    start_room = Map.current.id
    rooms = Hash[rooms_result.map { |_uid, lich_id| lich_id }.zip(rooms_result.map { |uid, _lich_id| uid })]
    room_ids = rooms.keys
    until room_ids.empty?
      nearest = Map.current.find_nearest(room_ids)
      Script.run('go2', nearest.to_s) if Map.current.id != nearest
      sleep 0.2
      room_ids.delete(nearest)
      self.room_refresh(db, params, rooms[nearest]) if Map.current.id == nearest
    end
    Script.run('go2',"#{start_room}") if Map.current.id != start_room
    db.close if close_db;
  end

  def self.room_refresh(db, params, uid = nil)
    respond "+----- start:room_refresh" if @debug
    params.delete_if { |i| i[:name] == 'uid' }
    uid = XMLData.room_id if uid.nil?
    params << { :name => 'uid', :operator => '=', :value => uid }
    where, qargs, _extras = self.where_builder(params, 'room_object','refresh')
    close_db = false
    (close_db = true; db = Inv_db.open) if db.nil?
    sql = "select ro.id, object, prepositions, special, depth
      from room_object ro
        inner join room r on r.id = ro.room_id
      #{where}"
    room_objects = self.execute(sql, qargs, db)[0]
    room_objects.each { |room_object_id, name, prepositions, special, max_depth|
      Inv_db.gs_print("updating #{name}...")
      self.room_object_refresh(db, room_object_id, name, prepositions, special, max_depth)
      Inv_db.gs_print(self.format_preset("updated #{name}: ","speech"))
      self.db_changes_print() #if @debug
      _respond self.format_preset("@objects_looked:#{@objects_looked.inspect}","speech") if @debug
      if @objects_looked >= 50  and @settings_hash["move_rooms"] == true
        self.move_rooms
      end
    }
    @objects_looked = 0  # done with room, reset for next room
    #self.db_changes_print if !@debug
    db.close if close_db;
  end

  def self.room_object_refresh(db, room_object_id, name, prepositions, special = '', max_depth = 9)
    respond "name: #{name.inspect}, prepositions:#{prepositions.inspect}, special: #{special.inspect}" if @debug
    if @rehook_inventory_boxes_off == false and DownstreamHook.list.find{|h| h == 'inventory_boxes_off'}
      DownstreamHook.remove('inventory_boxes_off')
      @rehook_inventory_boxes_off = true
      before_dying { self.hook_inventory_boxes; }
    end
    merge_items = nil, merge_categories = {}
    if special == ''
      prepositions.split(/ *,/).each { |preposition|
        items, item_categories, _has_in, _has_on = self.traverse_container(name, preposition, '', '', -1, @settings_hash["open_containers"], max_depth, swclose=true)
        if @debug_traverse
          respond "preposition: #{preposition}"
          respond "\nitems:"
          respond items.inspect
          respond "\nitem_categories:"
          item_categories.each { |k, v| respond "#{k}: #{v}" }
        end
        if merge_items.nil?
          merge_items = items
        else
          merge_items += items if !items.empty? and items.first.class == Hash
        end
        merge_categories.merge!(item_categories) if item_categories.class == Hash
      }
      #respond "merge items:"
      #merge_items.each{|i| respond i.inspect }
      # $merge_items = merge_items
      #respond "merge_categories.inspect:1:#{merge_categories.inspect}"
      mcat = merge_categories.clone
      self.room_inventory_temp_items(db, room_object_id, merge_items);
      #respond "mcat.inspect:2:#{mcat.inspect}"
      self.room_inventory_merge(db, room_object_id);
      #respond "mcat.inspect:3:#{mcat.inspect}"
      respond "mcat:" if @debug
      respond mcat.inspect if @debug
      #respond "mcat.inspect:4:#{mcat.inspect}"
      self.item_category_merge(db, mcat)
    else
      respond "#{special.inspect} not implemented"
    end
  end

  def self.room_inventory_temp_items(db, room_object_id, items)
    timestamp = self.db_timestamp_integer
    sql = "  insert into temp_room_item (room_object_id, level, path, name, type, link_name, containing, noun, amount, stack, stack_status, timestamp, update_noun, gs_id)
    values(#{room_object_id}, :level, :path, :name, :type, :link_name, :containing, :noun, :amount, :stack, :stack_status, #{timestamp}, :update_noun, :id )"
    temp_changes = 0
    temp_time = Benchmark.realtime do;
      items.each { |room_item|
        room_item.delete_if { |key, _value| !key.to_s.match(/^(?:location_id|level|path|type|name|link_name|containing|noun|amount|stack|stack_status|update_noun)$/) }
        if !room_item.nil? and !room_item.empty?
          _rows, changes = self.execute(sql, room_item, db)
          temp_changes += changes
        end
      }
    end;
    Inv_db.gs_print "+----room_inventory_temp_items(#{room_object_id}) with #{temp_changes} changes time elapsed #{(temp_time * 1000).round(2)} milliseconds" if @benchmark;
  end

  def self.room_inventory_merge(db, room_object_id)
    @current_proc = "room_inventory_merge";
    changes = 0
    merge_params = { :room_object_id => room_object_id, :game => XMLData.game.encode('UTF-8') }

    self.item_base_merge(db, 'temp_room_item')
    
    temp_item_cte = %{
    with cte as (
      select
          room_object_id, i.id as item_id
        , level, path, containing
        , sum(amount) as amount
        , stack, stack_status
      from temp_room_item t
        inner join item i on t.name = i.name and i.game = :game
      where room_object_id = :room_object_id
      group by
          room_object_id, i.id
        , level, path, containing
        , stack, stack_status
    )}

    if @debug;
      respond db.execute2(temp_item_cte + "select count(*) as item_count from cte", merge_params)
      item_count = db.execute2(temp_item_cte + "select count(*) as item_count from cte", merge_params)
      respond "cte: room_object_id: #{room_object_id}, item_count: #{item_count.inspect}"
    end


    if @debug
      respond "current temp_room_item, limit 10"
      sql = "select * from temp_room_item limit 10"
      rows = self.execute2(sql, {}, db)
      Inv_db.to_table(rows)

      respond "deleting these rows"
      sql = %{
      select *
      from room_inventory
      where room_inventory.room_object_id = :room_object_id
        and not exists (
          select 1
          from temp_room_item t
            inner join item i on t.name = i.name and i.game = :game
          where t.room_object_id = :room_object_id
            and i.id           = room_inventory.item_id
            and t.containing   = room_inventory.containing
            and t.path         = room_inventory.path
            and t.stack        = room_inventory.stack
            and t.stack_status = room_inventory.stack_status
          );}
      rows = self.execute2(sql, merge_params, db)
      Inv_db.to_table(rows)
    end

    respond "+----#{@current_proc}: delete" if @debug
    sql = %{
    delete
    from room_inventory
    where room_inventory.room_object_id = :room_object_id
      and not exists (
        select 1
        from temp_room_item t
          inner join item i on t.name = i.name and i.game = :game
        where t.room_object_id = :room_object_id
          and i.id           = room_inventory.item_id
          and t.containing   = room_inventory.containing
          and t.path         = room_inventory.path
          and t.stack        = room_inventory.stack
          and t.stack_status = room_inventory.stack_status
        );}
    temp_time = Benchmark.realtime do;
      _rows, changes = self.execute(sql, merge_params, db)
      @db_changes[:room_inv][:deleted] += changes
    end
    Inv_db.gs_print "+----room_inventory_merge-delete(#{room_object_id}) with #{changes.inspect} changes, time elapsed #{(temp_time * 1000).round(2)} milliseconds" if @benchmark;

    #  ----update: sqlite doesn't support joins in updates
    respond "+----#{@current_proc}: update" if @debug
    sql = %{
    update room_inventory set
        amount = (
          select amount
          from cte t
          where t.room_object_id = :room_object_id
            and t.item_id      = room_inventory.item_id
            and t.containing   = room_inventory.containing
            and t.path         = room_inventory.path
            and t.stack        = room_inventory.stack
            and t.stack_status = room_inventory.stack_status
        )
      , timestamp = :timestamp
    where room_inventory.room_object_id = :room_object_id
      and exists (
        select 1
        from cte t
        where t.room_object_id = :room_object_id
          and t.item_id      = room_inventory.item_id
          and t.containing   = room_inventory.containing
          and t.path         = room_inventory.path
          and t.amount      <> room_inventory.amount
          and t.stack        = room_inventory.stack
          and t.stack_status = room_inventory.stack_status
        );
    }
    merge_params.merge!({ :timestamp => self.db_timestamp_integer })
    temp_time = Benchmark.realtime do;
      _rows, changes = self.execute(temp_item_cte + sql, merge_params, db)
      @db_changes[:room_inv][:updated] += changes
    end
    Inv_db.gs_print "+----room_inventory_merge-update(#{room_object_id}) with #{changes.inspect} changes, time elapsed #{(temp_time * 1000).round(2)} milliseconds" if @benchmark;

    #  ----insert items
    respond "+----#{@current_proc}: insert" if @debug
    sql = %{
    insert into room_inventory (
        room_object_id, item_id
      , level, path
      , containing
      , amount
      , stack, stack_status
      , timestamp
    )
    select
        room_object_id, item_id
      , level, path
      , containing
      , amount
      , stack, stack_status
      , :timestamp
    from cte t
    where not exists (
      select 1
      from room_inventory i
      where i.room_object_id = :room_object_id
        and i.path         = t.path
        and i.containing   = t.containing
        and i.item_id      = t.item_id
        and i.stack        = t.stack
        and i.stack_status = t.stack_status
        )
      order by room_object_id, path, item_id;}

    temp_time = Benchmark.realtime do;
      _rows, changes = self.execute(temp_item_cte + sql, merge_params, db)
      @db_changes[:room_inv][:inserted] += changes
    end
    Inv_db.gs_print "+----room_inventory_merge-insert(#{room_object_id}) with #{changes.inspect} changes, time elapsed #{(temp_time * 1000).round(2)} milliseconds" if @benchmark;

    # todo:remove
    # testing performance impact of clearing temp table
    sql = %{
    delete from temp_room_item
    where room_object_id = :room_object_id}
    temp_time = Benchmark.realtime do;
      _rows, changes = self.execute(sql, merge_params.delete_if { |k, _v| k.to_s =~ /game|timestamp/ }, db)
    end
    Inv_db.gs_print "+----room_inventory_merge-cleanup(#{room_object_id}) with #{changes.inspect} changes, time elapsed #{(temp_time * 1000).round(2)} milliseconds" if @benchmark;
  end # end merge

  def self.room_upsert(db, params)
    close_db = false
    (close_db = true; db = Inv_db.open) if db.nil?
    _where, qargs, _extras = self.where_builder(params, 'room', false, 'upsert')
    args = {}
    qargs.each { |k, v| key = k.to_s.gsub('_filter', '').to_sym; args[key] = v.class == String ? v.encode('UTF-8') : v }
    hash_args = {
      :uid      => XMLData.room_id,
      :lich_id  => Map.uids[XMLData.room_id].first,
      :title    => XMLData.room_title.encode('UTF-8'),
      :property => ''.encode('UTF-8'),
      :nickname => XMLData.room_title.split(',').last.gsub(/\]|\[/,'').strip.encode('UTF-8'),
      :game     => XMLData.game.encode('UTF-8'),
    }
    hash_args.merge!(args)
    sql = "
      insert into room(uid, lich_id, title, nickname, property, game)
      select :uid, :lich_id, :title, coalesce(:nickname,''), :property, :game
      where not exists (select 1 from room where uid = :uid and game = :game)"
    _rows, changes = self.execute(sql, hash_args, db)
    @db_changes[:room][:inserted] += changes
    if changes == 0
      sql = "
        update room set
            uid = :uid
          , lich_id = :lich_id
          , title = :title
          , nickname  = coalesce(:nickname, nickname, '')
          , property = :property
        where uid = :uid
          and game = :game"
      _rows, changes = self.execute(sql, hash_args, db)
      @db_changes[:room][:updated] += changes
    end
    db.close if close_db;
  end

  def self.room_object_upsert(db, params)
    close_db = false
    (close_db = true; db = Inv_db.open) if db.nil?
    _where, qargs, _extras = self.where_builder(params, 'room_object', false, 'upsert')
    args = {}
    qargs.each { |k, v| key = k.to_s.gsub('_filter', '').to_sym; args[key] = v.class == String ? v.encode('UTF-8') : v }
    hash_args = {
      :room_id      => nil,
      :depth        => 9,
      :prepositions => 'in',
      :special      => ''.encode('UTF-8'),
    }
    hash_args.merge!(args)
    if hash_args[:room_id].nil?
      hash_args[:room_id] = db.get_first_value("select id from room where uid = :uid and game = :game", { :uid => XMLData.room_id, :game => XMLData.game.encode('UTF-8') })
    end
    if hash_args[:room_id].nil?
      respond "unable to identify this room"
    else
      hash_args.delete(:game)
      sql = "
        insert into room_object(room_id, object, prepositions, depth, special)
        select :room_id, :object, :prepositions, :depth, :special
        where not exists (select 1 from room_object where room_id = :room_id and object = :object)"
      _rows, changes = self.execute(sql, hash_args, db)
      @db_changes[:room_object][:inserted] += changes
      if changes == 0
        sql = "
          update room_object set
              prepositions = :prepositions
            , depth = :depth
            , special = :special
          where room_id = :room_id
            and object = :object"
        _rows, changes = self.execute(sql, hash_args, db)
        @db_changes[:room_object][:updated] += changes
      end
      db.close if close_db;
    end
  end

  def self.room_delete(db, params)
    close_db = false
    (close_db = true; db = Inv_db.open) if db.nil?
    where, qargs, _extras = self.where_builder(params, 'room', false, 'delete')
    if qargs.keys.size == 1
      qargs[:uid_filter] = XMLData.room_id
      sql = "delete from room where game = :game_filter and uid = :uid_filter"
    else
      sql = "delete from room #{where.gsub(/\w+\./, '')}"
    end
    _rows, changes = self.execute(sql, qargs, db)
    @db_changes[:room][:deleted] += changes
    db.close if close_db;
  end

  def self.room_object_delete(db, params)
    close_db = false
    (close_db = true; db = Inv_db.open) if db.nil?
    where, qargs, _extras = self.where_builder(params, 'room_object', false, 'delete')
    subquery = "
    select ro.id
    from room_object ro
      inner join room r on ro.room_id = r.id#{where}"
    sql = "delete from room_object where id in (#{subquery})"
    _rows, changes = self.execute(sql, qargs, db)
    @db_changes[:room][:deleted] += changes
    db.close if close_db;
  end

  def self.room_query(db, params)
    close_db = false
    (close_db = true; db = Inv_db.open) if db.nil?
    where, qargs, extras = self.where_builder(params, 'room_object')
    select  = "\n    select *"
    from    = "\n    from room r"
    orderby = "\n    order by r.uid"
    orderby = "\n    order by #{extras[:orderby]}" if extras.key?(:orderby);
    limit   = "\n    limit #{extras[:limit]}" if extras.key?(:limit);
    sql = "#{select}#{from}#{where}#{orderby}#{limit}";
    rows = self.execute2(sql, qargs, db)
    Inv_db.output_table(rows, 'room', qargs, "rooms")
    db.close if close_db;
  end

  def self.room_object_query(db, params)
    close_db = false
    (close_db = true; db = Inv_db.open) if db.nil?
    respond "room_object_query" if @debug
    where, qargs, extras = self.where_builder(params, 'room_object')
    select  = "\n    select *"
    from    = "\n    from room_object ro
      inner join room r on r.id = ro.room_id"
    orderby = "\n    order by r.uid, ro.object"
    orderby = "\n    order by #{extras[:orderby]}" if extras.key?(:orderby);
    limit   = "\n    limit #{extras[:limit]}" if extras.key?(:limit);
    sql = "#{select}#{from}#{where}#{orderby}#{limit}";
    rows = self.execute2(sql, qargs, db)
    Inv_db.output_table(rows, 'room_object', qargs, "room_object")
    db.close if close_db;
  end

  def self.room_inventory_query(db, params)
    close_db = false
    (close_db = true; db = Inv_db.open) if db.nil?
    sql, qargs = self.room_inventory_query_sql(params)
    rows = self.execute2(sql, qargs, db)
    regex_highlight = !params.find { |h| h[:name] == 'search_filter' and h[:operator] == 'REGEXP' }.nil?
    self.check_output_size(rows.size)
    Inv_db.output_table(rows, 'room_inventory', qargs, "room_inventory", regex_highlight)
    db.close if close_db;
  end

  def self.room_inventory_query_sql(params, style = "");
    respond "+---------------- proc_start: #{@current_proc}" if @debug_sql
    respond "+----params:#{params.inspect}" if @debug_sql;
    respond "+----style:#{style.inspect}" if @debug_sql;
    groupby = having = limit = "";
    where, qargs, extras = self.where_builder(params, 'room_inventory')

    select = "\n    select
        r.property
      , case when r.nickname = '' then r.title else r.nickname end as room
      , ro.object
      , ri.level as lvl
      , ri.path
      , ri.amount as qty
      , i.type
      , i.category
      , substr(ri.stack,1,3) as stk
      , ' ' || substr(ri.stack_status,1,1) as epf";
    select += "\n      , i.noun" if qargs.any? { |_k, v| v =~ /i\.noun/ };
    select += "\n      , (i.name || rtrim(' ' || ri.containing)) as item";

    export_select = "\n    select r.*, rc.*, ri.*, i.*, d.*"
    select = export_select if style == 'export'
    from = %{
    from room_inventory ri
      inner join room_object ro on ro.id = ri.room_object_id
      inner join room r on r.id = ro.room_id
      inner join item i on i.id = ri.item_id
      left join item_detail d on d.item_id = ri.item_id};

    orderby = "\n    order by r.property, r.nickname, r.title, ro.object, ri.path, i.noun, i.name"
    orderby = "\n    order by #{extras[:orderby]}" if extras.key?(:orderby);
    limit   = "\n    limit #{extras[:limit]}" if extras.key?(:limit);
    sql = "#{select}#{from}#{where}#{groupby}#{having}#{orderby}#{limit}";
    _respond sql if @debug_sql;
    return sql.encode('UTF-8'), qargs;
  end;

  #------------------------------------------------------------------------------#
  # export helpers
  #------------------------------------------------------------------------------#
  export_formats = Hash.new
  export_formats["csv"]  = { :type => 'csv', :delimiter => ',',   :extension => 'csv' }
  export_formats["txt"]  = { :type => 'txt', :delimiter => 9.chr, :extension => 'txt' }
  export_formats["text"] = { :type => 'txt', :delimiter => 9.chr, :extension => 'txt' }
  export_formats["pipe"] = { :type => 'txt', :delimiter => '|',   :extension => 'txt' }
  #------------------------------------------------------------------------------#
  # Export
  #------------------------------------------------------------------------------#
  export = proc { |_target, qparams, xparams|
    # where, qargs, extra = self.where_builder(params, '')

    export_format = xparams[:format].nil? ? export_formats["csv"] : export_formats[xparams[:format]]

    dir_delim = $lich_dir =~ /(\\|\/)/ ? $1 : "/"
    export_dir = xparams[:dir] || "#{$lich_dir}inv"
    export_dir = export_dir.gsub(/\$lich_dir/i, $lich_dir)

    respond "export_dir:#{export_dir.inspect}" if @debug
    Dir.mkdir(export_dir) unless File.exist?(export_dir)
    export_dir = "#{export_dir}#{dir_delim}" if export_dir.slice(-1) !~ /\/\\$/

    datetimestamp = "#{Time.now.strftime("%Y-%m-%d_%H-%M-%S")}"

    respond "qparams:#{qparams.inspect}" if @debug

    params_for_export = []
    qparams.each { |h|
      if @filters.include?(h[:name]) and h[:operator] !~ /REGEX/
        params_for_export << "#{h[:operator][0] == '!' ? "not_" : ""}#{h[:value].downcase}"
      end
    }
    query_params = (params_for_export.empty? ? "" : (params_for_export.join('_'))).gsub(' ', '_')
    respond "query_params:#{query_params.inspect}" if @debug

    export_filename = xparams[:file] || "#{target}_#{query_params}_#{datetimestamp}.#{export_format[:extension]}"
    export_filename = export_filename.sub('timestamp', datetimestamp)
    export_file = "#{export_dir}#{export_filename}"

    style = xparams[:style] || "export"

    sql, qargs = Inv_db.query_bank_sql(qparams, style) if target == "bank"
    sql, qargs = Inv_db.sum_bank_sql(qparams, style)   if target == "sbank"
    sql, qargs = Inv_db.query_tickets_sql(qparams, style) if target == "tickets"
    sql, qargs = Inv_db.sum_tickets_sql(qparams, style) if target == "stickets"

    sql, qargs = Inv_db.query_char_sql(qparams, style) if target == "character"
    sql, qargs = Inv_db.query_item_sql(qparams, style) if target =~ /item|inv|loc/
    rows = db.execute2(sql, qargs)

    if rows.length > 1
      if export_format[:type] !~ /csv/
        begin
          file = File.open(export_file, "w+")
          rows.each { |row|
            file.puts row.join(export_format[:delimiter])
          }
        ensure
          file.close
        end
      end
      if export_format[:type] =~ /csv/
        begin
          require 'csv'
          csv = CSV.open(export_file, "w+")
          rows.each { |row|
            csv << row
          }
        ensure
          csv.close
        end
      end
      export_file = export_file.gsub("/", "\\") if export_file =~ /^\w:/i
      Inv_db.gs_print Inv_db.format_whisper("exported #{rows.length - 1} row#{rows.length > 2 ? "s" : ""} from #{target} to #{export_file}.")
    else
      Inv_db.gs_print Inv_db.format_whisper("no rows to export for #{target}")
    end
  }

  #------------------------------------------------------------------------------#
  # dynamic where sql
  #------------------------------------------------------------------------------#
  def self.extras_processor(h, _query_type)
    e = {}
    key = h[:name].to_sym
    if h[:name] == 'orderby'
      h[:value] = h[:value].to_s.gsub(/['"\]\[]/, "").gsub(/[,]+/, ", ").gsub("-", " desc ").gsub("+", " asc ")
    end
    e[key] = h[:value]
    return e
  end

  def self.where_expression(h, action = nil)
    return nil if !h.key?(:value)
    expression = nil
    if h[:operator] == "REGEXP"
      operator = "REGEXP"
      expression = "#{operator} :#{h[:name]}_filter"
    elsif h[:value].class == String
      operator = "like"
      operator = "not like" if h[:operator] =~ /^(?:!=|<>)$/
      expression = "#{operator} :#{h[:name]}_filter"
      h[:value] = "#{h[:value]}%" if h[:operator] == "=" and action.inspect.to_s =~ /nil|query/  # 2023-10-30  restore wildcard ending if not == and not regex
    elsif h[:value].class.to_s =~ /Fixnum|Integer/
      operator = h[:operator]
      expression = "#{operator} :#{h[:name]}_filter"
    elsif h[:value].class == Array
      operator = "in"
      operator = "not in" if h[:operator] =~ /^(?:!=|<>)$/
      expression = "#{operator} ( '#{h[:value].map { |s| s.gsub("'", "''") }.join("','")}' )"
    end
    #respond "  where_expression:expression:#{expression.inspect}" if @debug_sql
    return expression
  end

  @filter_operator_pattern = /^(?:\!=|<=?|>=?|<>|==?|!?REGEXP)$/

  @query_types = {
    "account" => "a", "bank" => "b", "bounty" => "bo", "character" => "c", "char_inventory" => "v", "detail" => "d", "item" => "i", "lumnis" => "u", "resource" => "e", "tickets" => "t", 
    "item_base" => "i", "item_detail" => "id",
    "note" => "n",
    "property" => "p", "room" => "r", "room_object" => "ro", "room_inventory" => "ri", 
  }
  @filter_map = {
    # char
    "account" => "c", "area" => "c", "char" => "c", "citizenship" => "c", "game" => "c",
    "level" => "c", "race" => "c", "rank" => "c", "society" => "c", "subscription" => "c",
    "prof" => "c", "inv" => "i",
    # item
    "name" =>"i", "noun" => "i", "type" => "i", "link_name" => "i", "category" => "i",
    # item_detail
    "note" => "id", "inspect" => "id", "analyze" => "id", "look" => "id", "label" => "id", 
    "read" => "id", "recall" => "id", "loresong" => "id", "assess" => "id", "elemental" => "id",
    "charge" => "id", "script" => "id", 

    # char_inventory
    "hidden" => "v", "marked" => "v", "path" => "v", "amount" => "v", "registered" => "v", "stack" => "v", "stack_status" => "v",
    # location
    "location" => "l",
    # lumnis
    "double" => "u", "triple" => "u", "start_day" => "u", "start_time" => "u", "last_schedule" => "u",
    # resource
    "energy" => "e", "weekly" => "e", "suffused" => "e", "bonus" => "e", "favor" => "e",
    # room
    "title" => "r", "nickname" => "r", "property" => "r",  "room" => "r", "lich_id" => "r", "uid" => "r",
    # room_object
    "room_id" => "ro", "object" => "ro", "prepositions" => "ro", "depth" => "ro", "special" => "ro",
    # room_inventory
    "room" => "r", "room_object_id" => "ri"
  }
  @special_filters = { 
    "account" => nil, "amount" => nil, "character" => nil,
    "location" => nil, "level" => nil, "type" => nil,
    "search" => nil, "location_type" => nil, "total" => nil, "status" => nil,
    "game" => nil, "prepositions" => nil, "favor" => nil, #"object" => nil,
    "room" => nil,
    }

  @amount_map = { "bank" => "s", "char_inventory" => "v", "tickets" => "t", "room_inventory" => "ri" }
  @search_map = { "account" => "account", "bank" => "name", "tickets" => "source", "item" => "name",
    "room_inventory" => nil, "bounty" => "task" }
  @dealias = { "rank" => "society_rank" }
  @where_prefix = "\n      and "

  def self.where_expression_special(h, query_type, _aggregate, action = nil)
    where = ""
    qargs = {}
    (respond "---#{Script.current.name}: error: unknown operator #{h[:operator].inspect}"; exit) if !@filter_operator_pattern.match(h[:operator]);
    h[:value] = h[:value].gsub('*', '%') if h[:value].class == String
    if h[:name] == 'location'
      where += "#{@where_prefix}(l.name #{self.where_expression(h,action)} or l.abbr #{self.where_expression(h,action)})"
      qargs[:location_filter] = h[:value] if h[:value].class != Array
    elsif h[:name] == 'location_type'
      where += "#{@where_prefix}(l.type #{self.where_expression(h,action)} )" if h[:value].to_s.downcase != 'all'
      qargs[:location_type_filter] = h[:value] if h[:value].class != Array
    elsif h[:name] == 'search'
      if query_type == 'tickets'
        where += "#{@where_prefix}(t.source #{self.where_expression(h,action)} or t.currency #{self.where_expression(h,action)})"
      elsif query_type =~ /^item/
        where += "#{@where_prefix}i.name #{self.where_expression(h,action)}"
      elsif query_type == 'char_inventory'
        where += "#{@where_prefix}(i.name || rtrim(' ' || v.containing)) #{self.where_expression(h,action)}"
      elsif query_type == 'room_inventory'
        where += "#{@where_prefix}(i.name || rtrim(' ' || ri.containing)) #{self.where_expression(h,action)}"
      else
        where += "#{@where_prefix}#{@query_types[query_type]}.#{@search_map[query_type]} #{self.where_expression(h,action)}"
      end
      qargs[:search_filter] = h[:value].gsub(/^=/, '')
      qargs[:search_filter] = "%#{h[:value]}%" if h[:operator] == "=" and h[:value] !~ /^=/
      respond "qargs[:search_filter]:#{qargs[:search_filter].inspect}" if @debug_sql
    elsif h[:name] == 'type'  
      where += "#{@where_prefix}i.type #{self.where_expression(h,action)}"
      qargs[:type_filter] = h[:value].gsub(/^=/, '')
      qargs[:type_filter] = "%#{h[:value]}%" if h[:operator] == "=" and h[:value] !~ /^=/
    elsif h[:name] == 'character'
      where += "#{@where_prefix}c.name #{self.where_expression(h,action)}"
      qargs[:character_filter] = h[:value] if h[:value].class != Array
    elsif h[:name] == 'level' and query_type == 'room_inventory'
      where += "#{@where_prefix}ri.level #{self.where_expression(h,action)}"
      qargs[:level_filter] = h[:value] 
    elsif h[:name] == 'level' and query_type == 'item'
      where += "#{@where_prefix}v.level #{self.where_expression(h,action)}"
      qargs[:level_filter] = h[:value] 
    elsif h[:name] == 'level' and query_type == 'item'
      where += "#{@where_prefix}c.level #{self.where_expression(h,action)}"
      qargs[:level_filter] = h[:value] 
    elsif h[:name] == 'account'
      where += "#{@where_prefix}#{query_type == 'account' ? 'a' : 'c'}.account #{self.where_expression(h,action)}"
      qargs[:account_filter] = h[:value].encode('UTF-8')
    elsif h[:name] == 'amount'
      where += "#{@where_prefix}#{@amount_map[query_type]}.amount #{self.where_expression(h,action)}"
      qargs[:amount_filter] = h[:value]
    elsif h[:name] == 'favor'
      where += "#{@where_prefix}cast(e.favor as int) #{self.where_expression(h,action)}"
      qargs[:favor_filter] = h[:value]
    elsif h[:name] == 'total' # changes table
      where += "#{@where_prefix}#{@query_types[query_type]}.total #{self.where_expression(h,action)}"
      qargs[:total_filter] = h[:value]
    elsif h[:name] == 'stack_status' # add wildcard
      where += "#{@where_prefix}#{@query_types[query_type]}.stack_status #{self.where_expression(h,action)}"
      qargs[:stack_status_filter] = "#{h[:value]}%"
    elsif h[:name] == 'game'
      if query_type =~ /room/
        where += "#{@where_prefix}r.game = :game_filter"
      elsif query_type =~ /item/
        where += "#{@where_prefix}i.game = :game_filter"
      else
        where += "#{@where_prefix}c.game = :game_filter"
      end
      qargs[:game_filter] = h[:value].encode('UTF-8')
    elsif h[:name] == 'prepositions'
      where += "#{@where_prefix}#{@query_types[query_type]}.prepositions = :prepositions_filter"
      qargs[:prepositions_filter] = h[:value].class == Array ? h[:value].join(',') : h[:value]
    # elsif h[:name] == 'object'
      # where += "#{@where_prefix}#{@query_types[query_type]}.object = :object_filter"
      # qargs[:object_filter] = "#{h[:value]}"
    elsif h[:name] == 'room'
      where += "#{@where_prefix} (case when r.nickname = '' then r.title else r.nickname end ) like :room_filter"
      qargs[:room_filter] = h[:value].class == Array ? h[:value].join(',') : h[:value]
    end
    #respond "  where_expression_special:#{{:where => where, :qargs => qargs}.inspect}" if @debug_sql
    return where, qargs
  end

  def self.where_builder(filter_array = [], query_type = 'item', aggregate = false, action = nil)
    (respond "---#{Script.current.name}: error: unknown query_type #{query_type.inspect}"; exit) if !@query_types.key?(query_type)
    where = "";
    qargs = {};
    extras = {};
    filter_array.each { |h|
      #respond "where_builder:#{h.inspect}" if @debug_sql
      next if @export_options.include?(h[:name])
      if @extras.include?(h[:name])
        extra = self.extras_processor(h, query_type)
        extras.merge!(extra)
        #respond "  where_builder:@extras:#{extras.inspect}" if @debug_sql
        next
      end
      (respond "---#{Script.current.name}: error: unknown operator #{h[:operator].inspect}"; exit) if !@filter_operator_pattern.match(h[:operator]);
      if @special_filters.key?(h[:name])
        w, qarg = self.where_expression_special(h, query_type, aggregate, action)
        where += w
        qargs.merge!(qarg)
        #respond "  where_builder:@special_filters:#{{:where => where, :qargs => qargs}.inspect}" if @debug_sql
        next
      end
      if !@filter_map.key?(h[:name])
        respond "--- #{Script.current.name}: error: unknown filter #{h[:name].inspect}"
      else
        h[:value] = h[:value].gsub('*', '%') if h[:value].class == String
        table_alias = @filter_map[h[:name]] if @filter_map.key?(h[:name])
        h[:name] = @dealias[h[:name]] if @dealias.key?(h[:name])
        table_alias = @filter_map[h[:name]] if @filter_map.key?(h[:name])
        
        base_where ="#{@where_prefix}#{table_alias}.#{h[:name]} #{self.where_expression(h, action)}"
        base_where = base_where.gsub('v.', 'ri.') if query_type == 'room_inventory'
        where += base_where
        key = "#{h[:name]}_filter".to_sym
        qargs[key] = h[:value] if h[:value].class != Array
      end
    }
    where = "\n    where #{where[11..-1]}" if where[0..10] == "#{@where_prefix}"
    #respond "where:#{where.inspect}\nqargs:#{qargs.inspect}\nextras:#{extras.inspect}" if @debug_sql
    return where, qargs, extras
  end

  #------------------------------------------------------------------------------#
  # messy user input helper
  #------------------------------------------------------------------------------#
  def self.generate_partials(arr, min_length = 1, concat = "");
    h = Hash.new;
    arr.each { |a|
      temp_str = a.clone;
      matchto_str = a == "inventory" ? "inv" : a;
      iter = (temp_str.length - min_length);
      h["#{temp_str}#{concat}"] = matchto_str;
      iter.times {
        temp_str.slice!(-1);
        h["#{temp_str}#{concat}"] = matchto_str if !h.key?("#{temp_str}#{concat}");
      };
    };
    return h;
  end;
  #------------------------------------------------------------------------------#
  # Parse user input
  #------------------------------------------------------------------------------#
  # exit if api load
  exit if Script.current.vars[0] =~ /^(?:@|\-+)api/;

  (@benchmark      = true;) if Script.current.vars[0] =~ /@ben/
  (@debug          = true;) if Script.current.vars[0] =~ /@debug/
  (@debug_sql      = true;) if Script.current.vars[0] =~ /@sql|@debug_sql/
  (@debug_hook     = true;) if Script.current.vars[0] =~ /@hook/
  (@debug_input    = true;) if Script.current.vars[0] =~ /@input|@debug_input/
  (@debug_print    = true;) if Script.current.vars[0] =~ /@print|@debug_print/
  (@debug_traverse = true;) if Script.current.vars[0] =~ /@debug_traverse/
  (@no_squelch     = true;) if Script.current.vars[0] =~ /@no_?squelch/
  (@show_commands  = true;) if Script.current.vars[0] =~ /@show_?commands/
  (@autofit        = true;) if Script.current.vars[0] =~ /@autofit/
  (@slower         = true;) if Script.current.vars[0] =~ /@slower/

  silence_me if !@debug && !@no_squelch && !@show_commands

  actions = ["query", "refresh", "count"]
  targets = ["all", "account", "bank", "bounty", "character", "inventory", "item", "locker", "lumnis", "resource", "sbank", "silver", "stickets", "tickets",
             "room_inventory", "room_objects", "rooms", "property",
             "item_base", "item_detail", "item_note" ]
             
  @filters = ["account", "amount", "area", "character", "game", "hidden",
              "location", "marked", "noun", "name", "path", "race",
              "registered", "society", "stack", "stack_status", "subscription", "type", "category", "item_id",
              "society", "citizenship", "rank", "suffused", "weekly", "total", "favor", "energy",
              "title", "nickname", "property", "uid", "lich_id", "title",
              "room_id", "item_id", "object", "nickname", "prepositions", "depth", "special"]
  @filter_map.keys.each{|k| @filters << k.to_s if !@filters.include?(k.to_s)}
  @extras = ["select", "include", "groupby", "orderby", "limit"]

  @export_options = ["format", "style", "dir", "file"]
  # todo: abbreviations for columns in additional groupby
  # groupbys = ["character", "name", "noun", "amount", "qty", "type", "stack", "stack_status", "location", "path", "marked", "registered"]

  partials = Hash.new
  partials[:actions] = self.generate_partials(actions, 1)
  partials[:actions]["export"] = "export"
  partials[:actions]["reset"]  = "reset"
  partials[:actions]["delete"] = "delete"
  partials[:actions]["sum"]    = "sum"
  partials[:actions]["count"]  = "count"
  partials[:actions]["total"]  = "sum"
  partials[:actions]["add"]    = "upsert"
  partials[:actions]["update"] = "upsert"
  partials[:actions]["remove"] = "remove"
  partials[:actions]["scan"]   = "scan"

  partials[:targets] = self.generate_partials(targets, 1)
  partials[:targets]["scrip"] = "tickets"
  partials[:targets]["rooms"] = "rooms"
  partials[:targets]["prop"]  = "room"
  partials[:targets]["item_base"]   = "item_base"
  partials[:targets]["item_detail"] = "item_detail"
  partials[:targets]["notes"]       = "item_note"
  partials[:targets]["note"]        = "item_note"
  # partials[:targets]["boosts"] = "boost"
  # partials[:targets]["collectibles"] = "collectible"
  # partials[:targets]["profiles"] = "profile"
  # partials[:targets]["features"] = "feature"
  # partials[:targets]["info"] = "info"
  # partials[:targets]["skills"] = "skill"


  partials[:filters] = self.generate_partials(@filters, 1)
  partials[:filters]["epf"]  = "stack_status"
  partials[:filters]["qty"]  = "amount"
  partials[:filters]["stk"]  = "stack"
  partials[:filters]["act"]  = "account"
  partials[:filters]["lvl"]  = "level"
  partials[:filters]["char"] = "character"
  partials[:filters]["pro"]  = "prof"

  partials[:extras] = self.generate_partials(@extras, 5)

  partials[:export]

  # print_partials = proc {
  #   table_headers = ["partial", "target"]
  #   table_format = "| %-22s | %-22s"
  #   respond table_format % table_headers
  #   partials.each { |type, h|
  #     respond "-----#{type}"
  #     h.each { |k, v|
  #       respond table_format % [k, v]
  #     }
  #   }
  # }
  # print_partials.call
  vars = Script.current.vars
  vars.delete_if { |i| i =~ /^(@|delay=)/ }
  _respond "#{Script.current.name} vars:#{vars.inspect}" if @debug_input

  if @debug_input
    if vars.empty?
      respond "no input"
    else
      i = 0
      vars.each {
        respond "#{i}: #{Script.current.vars[i]}"
        i += 1
      }
    end
  end
  if vars.select { |v| v =~ /^[^@]/ }.compact.empty?
    action = "refresh"
    target = "all"
  else
    reparse_vars = []
    regex_join = []
    regex_index_start = nil

    action = partials[:actions][vars[1]]
    vars.slice!(1) if action
    target = partials[:targets][vars[1].to_s] if action
    item_filter = target if target =~ /^(inv|locker|item|all)/i
    vars.slice!(1) if action && target

    action = action.nil? ? "query" : action
    @action = action
    target = target.nil? ? (action =~ /query|sum|count/ ? "item" : "all") : target
    @target = target

    ## reparse vars
    vars.each_with_index { |v, x|
      next if x == 0
      if !regex_index_start.nil?
        regex_join << v.encode('UTF-8')
        if v =~ /[^\\]\/$/
          reparse_vars << regex_join.join(' ')
          regex_index_start = nil
        end
      elsif v =~ /=\/[^\/]+$/
        regex_join = []
        regex_join << v.encode('UTF-8')
        regex_index_start = x
      else
        reparse_vars << v.encode('UTF-8')
      end
    }

    respond "--- #{Script.current.name}: error: unclosed regex expression" if !regex_index_start.nil?

    filter_pattern = /(?<filter_key>..*?)(?<operator>[!<>=]+)(?<filter_value>..*)$/
    search_expression = []
    filters = []

    reparse_vars.each_with_index { |v, _x|
      captures = v.match(filter_pattern).captures
      if captures[2][0] == '/' and captures[2][-1] == '/'
        captures[1] = (captures[1] =~ /!=|<>/ ? '!REGEXP' : 'REGEXP')
        captures[2] = "#{captures[2][1..-2]}"
      elsif captures[2] =~ /^[\d,]+$/
        captures[2] = captures[2].delete(',').to_i
      elsif captures[2] =~ /\|/
        captures[2] = captures[2].split(/\| */)
      elsif captures[2] =~ /,/
        captures[2] = captures[2].split(/, */)
      elsif captures[2] == "''"
        captures[2] = ""
      elsif v !~ filter_pattern
        search_expression << v
      end
      if !captures.nil?
        name = captures[0]
        name = partials[:filters][captures[0].downcase] if partials[:filters].key?(captures[0].downcase)
        name = partials[:extras][captures[0].downcase] if partials[:extras].key?(captures[0].downcase)
        captures[0] = name
        h = Hash[[:name, :operator, :value].zip(captures)]
        respond h.inspect if @debug_input
        filters << h
      end
    }

    if search_expression.size > 0
      search_value = search_expression.join(' ')
      operator = "="
      if search_value[0] == '/' and search_value[-1] == '/'
        operator = "REGEXP"
        search_value = "#{search_value[1..-2]}"
      end
      search_hash = Hash[[:name, :operator, :value].zip(['search', operator, search_value])]
      respond "search_hash:#{search_hash.inspect}" if @debug
      filters << search_hash
    end
    if !filters.find { |h| h[:name] == 'game' }
      filters << Hash[[:name, :operator, :value].zip(['game', '=', XMLData.game.encode('UTF-8')])]
    end
    filters << Hash[[:name, :operator, :value].zip(['location_type', '=', item_filter])] if item_filter.to_s =~ /^(?:inv|locker)/
    input_params = filters
  end
  #------------------------------------------------------------------------------#
  # do stuff
  #------------------------------------------------------------------------------#
  if action == "refresh"
    require "benchmark"

    @character_id = self.character_id_get(db) if target !~ /^room/

    # need account for character, family vault
    if target =~ /^(?:cha|item|locker|all)/ || target.nil?

      if @account_name.nil? or @subscription.nil? or @locker_location.nil?
        Inv_db.gs_print "fetching account info" if @debug
        account_time = Benchmark.realtime do
          @account_name, @subscription = self.account_get
        end
        Inv_db.gs_print "account time elapsed #{(account_time * 1000).round(2)} milliseconds" if @benchmark
        locker_info_time = Benchmark.realtime do
          locker_info.call if @locker_location.nil?
        end
        Inv_db.gs_print "locker info time elapsed #{(locker_info_time * 1000).round(2)} milliseconds" if @benchmark
      end
    end

    if target =~ /^(?:cha|all)/i || target.nil?
      Inv_db.gs_print "updating character..." if !@benchmark
      char_time = Benchmark.realtime do
        self.character_refresh()
      end
      Inv_db.gs_print "character_refresh time elapsed #{(char_time * 1000).round(2)} milliseconds" if @benchmark
    end

    if (target == 'bounty' or target == 'all')
      if @subscription.nil?
        @account_name, @subscription = self.account_lookup(db)
      end
      if @subscription == 'f2p' or XMLData.level < 10
        # Inv_db.gs_print "skipping bounty on f2p..."
      else
        Inv_db.gs_print "updating bounty..." if !@benchmark
        bounty_time = Benchmark.realtime do
          self.bounty_refresh(db)
        end
        Inv_db.gs_print "bounty_refresh time elapsed #{(bounty_time * 1000).round(2)} milliseconds" if @benchmark
      end
    end
    
    if (target == 'lumnis' or (target == 'all' and @settings_hash['lumnis'] == true))
      if @subscription.nil?
        @account_name, @subscription = self.account_lookup(db)
      end
      if @subscription == 'f2p'
        # Inv_db.gs_print "skipping lumnis on f2p..."
      else
        Inv_db.gs_print "updating lumnis..." if !@benchmark
        lumnis_time = Benchmark.realtime do
          self.lumnis_refresh(db)
        end
        Inv_db.gs_print "lumnis_refresh time elapsed #{(lumnis_time * 1000).round(2)} milliseconds" if @benchmark
      end
    end

    if (target == 'resource' or (target == 'all' and @settings_hash['lumnis'] == true))
      if @subscription.nil?
        @account_name, @subscription = self.account_lookup(db)
      end
      if @subscription == 'f2p'
        # Inv_db.gs_print "skipping resource on f2p..."
      else
        Inv_db.gs_print "updating resource..." if !@benchmark
        resource_time = Benchmark.realtime do
          self.resource_refresh(db)
        end
        Inv_db.gs_print "resource_refresh time elapsed #{(resource_time * 1000).round(2)} milliseconds" if @benchmark
      end
    end

    # if target == 'account' or (target == 'all' and @settings_hash['resource'] == true)
    #
    # end

    if target =~ /^(?:bank|all)/i || target.nil?
      Inv_db.gs_print "updating bank account..." if !@benchmark
      bank_time = Benchmark.realtime do
        #refresh_bank.call()
        self.bank_refresh(db)
      end
      Inv_db.gs_print "refresh_bank time elapsed #{(bank_time * 1000).round(2)} milliseconds" if @benchmark
    end

    if target =~ /^(?:tickets|all)/i || target.nil?
      Inv_db.gs_print "updating ticket balance..." if !@benchmark
      ticket_time = Benchmark.realtime do
        #refresh_tickets.call()
        self.ticket_refresh(db)
      end
      Inv_db.gs_print "refresh_tickets time elapsed #{(ticket_time * 1000).round(2)} milliseconds" if @benchmark
    end

    if target =~ /^(?:inv|locker|item|all)/i || target.nil?
      item_time = Benchmark.realtime do
        refresh_item.call(input_params)
      end
      Inv_db.gs_print "+refresh_item time elapsed #{(item_time * 1000).round(2)} milliseconds" if @benchmark
    end

    #####

    if target =~ /^(?:room)/
      sorter_handler.call
      room_time = Benchmark.realtime do
        self.room_refresh(db, input_params)
      end
      Inv_db.gs_print "+refresh_room time elapsed #{(room_time * 1000).round(2)} milliseconds" if @benchmark
    end

    if target == 'property'
      sorter_handler.call
      property_time = Benchmark.realtime do
        self.property_refresh(db, input_params)
      end
      Inv_db.gs_print "+refresh_item time elapsed #{(property * 1000).round(2)} milliseconds" if @benchmark
    end
  end # end refresh

  if action == "scan"
    self.sorted_view_scan_inventory if target =~ /inv/
    self.sorted_view_scan_premium_locker if target =~ /locker/
  end
  
  if action == "upsert"
    self.room_upsert(db, input_params) if target =~ /rooms|room_inventory/  # wrong target but simpler syntax for users
    self.room_object_upsert(db, input_params) if target =~ /room_objects?/
    self.item_note_upsert(db, input_params) if target =~ /note/
  end

  if action =~ /remove|delete/
    self.room_delete(db, input_params) if target =~ /rooms|room_inventory/  # wrong target but simpler syntax for users, room_inventory will use delete action
    self.room_object_delete(db, input_params) if target =~ /room_objects?/
  end

  if action == "query"
    target = target.nil? ? "item" : target
    self.character_query(db, input_params)          if target =~ /char/i
    self.bank_query(db, input_params)           if target =~ /wealth|bank|silver/i
    self.ticket_query(db, input_params)         if target =~ /tickets/i
    #query_tickets.call(input_params)            if target =~ /tickets/i
    query_item.call(input_params)               if target =~ /^(?:inv|lockers?|items?)$/i
    self.bounty_query(db, input_params)         if target == 'bounty'
    self.lumnis_query(db, input_params)         if target == 'lumnis'
    self.resource_query(db, input_params)       if target == 'resource'

    # echo "target:#{target}"
    self.room_query(db, input_params)           if target =~ /rooms$|property/
    self.room_object_query(db, input_params)    if target =~ /room_objects?/
    self.room_inventory_query(db, input_params) if target == 'room_inventory'

    self.item_base_query(db, input_params)      if target == 'item_base'
    self.item_detail_query(db, input_params)    if target == 'item_detail'
    self.item_note_query(db, input_params)      if target == 'notes'
  end

  if action == "sum"
    target = target.nil? ? "item" : target
    self.bank_sum(db, input_params)             if target =~ /wealth|bank|silver/i
    self.ticket_sum(db, input_params)           if target =~ /tickets?/i
    sum_item.call(input_params)                 if target =~ /inv|locker|item/i
  end

  if action == "count"
    target = target.nil? ? "item" : target
    count_item.call(input_params)               if target =~ /inv|locker|item/i
    self.count_room_inventory(input_params, db) if target =~ /^rooms?$/
  end

  if action == "export"
    xparams = {}
    xparams[:style]  = "export"
    xparams[:format] = input_params.find { |h| h[:name] = "format" }[:value] if input_params.find { |h| h[:name] == "format" }
    xparams[:dir]    = input_params.find { |h| h[:name] = "dir" }[:value]    if input_params.find { |h| h[:name] == "dir" }
    xparams[:file]   = input_params.find { |h| h[:name] = "file" }[:value]   if input_params.find { |h| h[:name] == "file" }
    export.call(target, input_params, xparams)
  end

  if action == "delete"
    character_filter = input_params.find { |h| h[:name] == "character" }[:value];
    _respond "character_filter = #{character_filter}" if @debug
    _respond "target = #{target}" if @debug
    self.bank_delete(db,input_params)    if target =~ /all|char|bank|silver|wealth/i && character_filter
    self.ticket_delete(db,input_params) if target =~ /all|tickets/i && character_filter
    self.item_delete(db,input_params)    if target =~ /all|char|inv|item|locker/i && character_filter
    self.char_delete(db,input_params)    if target =~ /all|char/i && character_filter
  end

  if action == "reset"
    target = target.nil? ? "all" : target
    if Script.current.vars[0] =~ /confirm$/i
      Inv_db.drop_tables(target)
    else
      echo "Warning:  This will drop all the tables related to '#{target}' in the inv.db3 database.  If you wish to continue, enter the command with CONFIRM at the end."
    end
  end

  #------------------------------------------------------------------------------#
  # sum up, if did stuff
  #------------------------------------------------------------------------------#
  self.db_changes_print()
  final_output = []
  final_output << "Total inventory items: #{@inventory_count}" if @inventory_count > 0
  final_output << "Total manifest items: #{@manifest_count}" if @manifest_count > 0
  Inv_db.gs_print Inv_db.format_whisper(final_output.join("\n")) if final_output.length > 0
  #------------------------------------------------------------------------------#
  # close db
  # added sqlite VACUUM every 12 hours.  That's often, but it's fast.
  #------------------------------------------------------------------------------#

  begin
    retries ||= 0
    last_vacuum = @settings_hash["last_vacuum"]
    respond "last_vacuum:#{last_vacuum.inspect}" if @debug
    if (last_vacuum + 36000) < Time.now # vacuum once every ten hours
      db.execute('VACUUM')
      Settings["last_vacuum"] = Time.now;
      Settings.save;
    end
    db.close if db
    _respond "#{Script.current.name}: db closed" if @debug
  rescue SQLite3::BusyException
    sleep 0.4
    retry if (retries += 1) < 3
  end

  if XMLData.name == 'Xanlin' or @benchmark
    end_time = Time.now;
    total_run_time = (end_time.to_r - start_time.to_r).to_f
    respond "total run time: #{sprintf("%d:%02d:%06.3f", (total_run_time / 3600), (total_run_time / 60) % 60, total_run_time % 60)}"
  end;
end; # end module Inv_db
