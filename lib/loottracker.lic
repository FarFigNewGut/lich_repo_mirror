# frozen_string_literal: true

=begin
  This script is in beta. Putting it up for testing/development.

  LootTracker - Self-parsing loot tracking system

        author: Nisugi
          game: Gemstone
          tags: loot, tracking, hunting
       version: 0.2.0
      required: Lich >= 5.12.0

  Automatically tracks searches, skins, boxes, sales, appraisals, bounties,
  and bank transactions. Run in background while hunting.

  Usage:
    ;loottracker              Start tracking (run in background)
    ;loottracker help         Show all commands

  Reports:
    ;loottracker cap          Monthly loot cap report (estimated vs realized)
    ;loottracker cap last     Previous month's loot cap
    ;loottracker recent       Recent items (filterable by type)
    ;loottracker boxes        Recent boxes with contents
    ;loottracker creatures    Top creatures by loot value
    ;loottracker wands        Wand duplication stats

  Debug:
    ;loottracker debug        Toggle debug output

=end
no_kill_all
hide_me

require 'sequel'

module LootTracker
  # ===== Constants =====
  # Guard against redefinition warnings when script is reloaded
  VERSION = '0.2.0' unless defined?(VERSION)
  MAX_BUFFER_SIZE = 100 unless defined?(MAX_BUFFER_SIZE)
  SCRIPT_NAME = Script.current.name unless defined?(SCRIPT_NAME)
  DB_FILE = "#{DATA_DIR}/loottracker.db3" unless defined?(DB_FILE)
  PAWN_CAP_VALUE = 25_000 unless defined?(PAWN_CAP_VALUE)

  # Town-based racial bonus lookup (5% bonus for selling in favorable towns)
  # Source: https://gswiki.play.net/Trading
  unless defined?(TOWN_RACIAL_BONUS)
    TOWN_RACIAL_BONUS = {
      "Wehnimer's Landing" => { 'Giantman' => 5, 'Halfling' => 5, 'Half-Elf' => 5, 'Dark Elf' => 5, 'Forest Gnome' => 5 },
      'Icemule Trace'      => { 'Halfling' => 5, 'Sylvankind' => 5, 'Half-Krolvin' => 5 },
      'Solhaven'           => { 'Human' => 5, 'Half-Elf' => 5 },
      "River's Rest"       => { 'Human' => 5, 'Half-Krolvin' => 5 },
      "Ta'Vaalor"          => { 'Elf' => 5 },
      "Ta'Illistim"        => { 'Elf' => 5, 'Sylvankind' => 5, 'Burghal Gnome' => 5, 'Erithian' => 5, 'Aelotoi' => 5 },
      'Cysaegir'           => { 'Dark Elf' => 5, 'Forest Gnome' => 5, 'Erithian' => 5, 'Aelotoi' => 5 },
      'Kharam Dzu'         => { 'Halfling' => 5 },
      'Zul Logoth'         => { 'Halfling' => 5 },
    }.freeze
  end

  # Box nouns (containers from creatures that can be opened/picked)
  # Does NOT include: satchel, backpack, shroud, bandolier, cloak, pouch, sack, etc.
  BOX_NOUNS = %w[box trunk coffer chest strongbox casket lockbox crate case reliquary].freeze unless defined?(BOX_NOUNS)

  # ===== Module State =====
  @buffer = []
  @queue = Queue.new
  @command_queue = Queue.new
  @mutex = Mutex.new
  @hook_id = nil
  @upstream_hook_id = nil
  @enabled = false
  @debug = false
  @db = nil
  @_setup_done = false
  @pending_pool_drop = nil  # { box_id:, box_noun:, box_name:, tip:, fee: }
  @pending_pool_returns = {}  # new_box_id => loot_item.id (for linking returned pool boxes)

  # Cross-character proxy settings (for loresinging/appraising items on behalf of another character)
  # When set, name-based fallback matching will restrict to items from the proxy character
  @loresong_proxy = nil   # Restrict loresong fallback to this character's items
  @appraise_proxy = nil   # Restrict appraise/shop appraisal/sale fallback to this character's items
  @dupe_proxy = nil       # Restrict wand dupe fallback to this character's items

  class << self
    attr_reader :enabled, :debug, :db
    attr_accessor :buffer, :queue, :command_queue, :pending_pool_drop, :pending_pool_returns
    attr_accessor :loresong_proxy, :appraise_proxy, :dupe_proxy

    def mutex
      @mutex
    end

    def debug?
      @debug
    end

    def enabled?
      @enabled
    end

    def log(msg)
      timestamp = Time.now.strftime('%H:%M:%S')
      respond "[LootTracker #{timestamp}] #{msg}"
    end

    def current_character
      Char.name rescue 'Unknown'
    end

    def current_game
      XMLData.game rescue 'GSIV'
    end

    def current_room_id
      Room.current.id rescue nil
    end

    def current_room_uid
      Room.current.uid rescue nil
    end

    def current_location
      raw_location = Room.current.location rescue nil
      return nil unless raw_location

      # Normalize to town name (e.g., "the free port of Solhaven" -> "Solhaven")
      town = TOWN_RACIAL_BONUS.keys.find { |t| raw_location.include?(t) }
      town || raw_location
    end

    # Calculate current trading skill boost percentage
    # Formula: TRUNC((INF_BONUS + TRADING_SKILL_BONUS) / 12)
    # Max: 28%
    # Cached for 5 minutes since stats/skills don't change during a sell session
    TRADING_BONUS_CACHE_TTL = 300 unless defined?(TRADING_BONUS_CACHE_TTL) # 5 minutes

    def calculate_trading_bonus
      return 0 unless defined?(Skills) && defined?(Stats)

      # Check cache
      cached = LootTracker.instance_variable_get(:@_trading_bonus_cache)
      if cached && (Time.now - cached[:time]) < TRADING_BONUS_CACHE_TTL
        return cached[:value]
      end

      # Calculate fresh value
      inf_bonus = Stats.influence.enhanced.bonus.to_i rescue 0
      trading_skill_bonus = Skills.to_bonus(Skills.trading).to_i rescue 0
      value = ((inf_bonus + trading_skill_bonus) / 12).truncate

      # Cache it
      LootTracker.instance_variable_set(:@_trading_bonus_cache, { value: value, time: Time.now })
      value
    end

    # Get racial bonus for current location (5% if favorable, 0% otherwise)
    def calculate_racial_bonus
      location = current_location
      return 0 unless location

      race = Stats.race rescue nil
      return 0 unless race

      # Find matching town (location may be "the free port of Solhaven" but key is "Solhaven")
      town_data = TOWN_RACIAL_BONUS.find { |town, _| location.include?(town) }
      return 0 unless town_data

      town_data[1][race] || 0
    end
  end

  # ===== Database Module =====
  module Database
    class << self
      def setup!
        return if LootTracker.instance_variable_get(:@_setup_done)

        LootTracker.instance_variable_set(:@db, Sequel.sqlite(DB_FILE))
        db = LootTracker.db

        setup_loot_events_table(db)
        setup_skin_events_table(db)
        setup_bundle_events_table(db)
        setup_loot_items_table(db)
        setup_bounty_rewards_table(db)
        setup_transactions_table(db)

        # Mark setup complete AFTER all migrations succeed
        LootTracker.instance_variable_set(:@_setup_done, true)
        LootTracker.log("Database initialized: #{DB_FILE}")
      end

      def setup_loot_events_table(db)
        db.create_table?(:loot_events) do
          primary_key :id
          String :event_type, null: false      # 'search' or 'box_open'
          String :source_id                    # Creature/box GameObj id
          String :source_name                  # Creature/box name
          Integer :silvers_found, default: 0   # Silvers found
          String :character, null: false
          String :game, null: false
          Integer :room_id
          String :room_uid                     # Room UID from <nav rm='X'/> - stable across sessions
          DateTime :created_at, null: false

          index [:character, :game, :created_at]
          index [:source_id]
          index [:event_type]
          index [:room_uid]
        end

        # Migration: add room_uid if missing
        columns = db[:loot_events].columns
        unless columns.include?(:room_uid)
          db.alter_table(:loot_events) { add_column :room_uid, String }
          db.alter_table(:loot_events) { add_index :room_uid, if_not_exists: true }
        end
      end

      def setup_skin_events_table(db)
        db.create_table?(:skin_events) do
          primary_key :id
          String :creature_id                  # Creature GameObj id
          String :creature_name                # Creature name
          String :character, null: false
          String :game, null: false
          DateTime :created_at, null: false

          index [:character, :game, :created_at]
          index [:creature_id]
        end
      end


      def setup_bundle_events_table(db)
        db.create_table?(:bundle_events) do
          primary_key :id
          String :event_type, null: false      # 'bundle_create' or 'bundle_add'
          String :skin_id                      # Skin being added/merged
          String :skin_name                    # Skin name
          String :bundle_id                    # Bundle receiving the skin
          String :bundle_name                  # Bundle name
          String :container_id                 # Container holding the bundle
          String :container_name               # Container name
          String :character, null: false
          String :game, null: false
          DateTime :created_at, null: false

          index [:character, :game, :created_at]
          index [:skin_id]
          index [:bundle_id]
          index [:container_id]
        end
      end

      def setup_loot_items_table(db)
        db.create_table?(:loot_items) do
          primary_key :id
          String :item_id                      # GameObj id
          String :item_name, null: false
          String :item_noun
          String :item_type                    # 'gem', 'skin', 'box', etc.
          String :item_source                  # 'search', 'box', 'skin'
          Integer :event_id                    # FK to loot_events.id
          Integer :skin_event_id               # FK to skin_events.id
          Integer :opened_event_id             # FK to loot_events.id for box_open (boxes only)
          DateTime :opened_at                  # When box was opened (NULL = not yet opened)
          DateTime :pool_dropped_at            # When box was dropped at pool (NULL = not dropped)
          String :pool_room_uid                # Room UID where box was dropped at pool - for reconciliation
          String :pool_dropped_by              # Who dropped the box at pool (may differ from searcher)
          Integer :pool_fee                    # Fee paid to pool (boxes only)
          Integer :pool_tip                    # Tip given to pool (boxes only)
          String :searcher                     # Who found the item
          String :game, null: false
          DateTime :created_at, null: false

          index [:searcher, :game, :created_at]
          index [:item_id, :item_noun], unique: true
          index [:event_id]
          index [:skin_event_id]
          index [:opened_event_id]
          index [:item_type]
        end

        # Migration: add new columns if missing
        migrate_loot_items_for_box_tracking(db)
      end

      def migrate_loot_items_for_box_tracking(db)
        columns = db[:loot_items].columns
        unless columns.include?(:opened_at)
          db.alter_table(:loot_items) { add_column :opened_at, DateTime }
        end
        unless columns.include?(:opened_event_id)
          db.alter_table(:loot_items) { add_column :opened_event_id, Integer }
          db.alter_table(:loot_items) { add_index :opened_event_id, if_not_exists: true }
        end
        unless columns.include?(:pool_dropped_at)
          db.alter_table(:loot_items) { add_column :pool_dropped_at, DateTime }
        end
        unless columns.include?(:pool_fee)
          db.alter_table(:loot_items) { add_column :pool_fee, Integer }
        end
        unless columns.include?(:pool_tip)
          db.alter_table(:loot_items) { add_column :pool_tip, Integer }
        end
        unless columns.include?(:pool_room_uid)
          db.alter_table(:loot_items) { add_column :pool_room_uid, String }
          db.alter_table(:loot_items) { add_index :pool_room_uid, if_not_exists: true }
        end
        unless columns.include?(:pool_dropped_by)
          db.alter_table(:loot_items) { add_column :pool_dropped_by, String }
        end

        # Search-to-sell tracking columns
        migrate_loot_items_for_sale_tracking(db)
      end

      def migrate_loot_items_for_sale_tracking(db)
        columns = db[:loot_items].columns
        unless columns.include?(:appraised_value)
          db.alter_table(:loot_items) { add_column :appraised_value, Integer }
        end
        unless columns.include?(:appraised_at)
          db.alter_table(:loot_items) { add_column :appraised_at, DateTime }
        end
        unless columns.include?(:loresong_value)
          db.alter_table(:loot_items) { add_column :loresong_value, Integer }
        end
        unless columns.include?(:loresong_at)
          db.alter_table(:loot_items) { add_column :loresong_at, DateTime }
        end
        unless columns.include?(:loresong_value_2)
          db.alter_table(:loot_items) { add_column :loresong_value_2, Integer }
        end
        unless columns.include?(:loresong_at_2)
          db.alter_table(:loot_items) { add_column :loresong_at_2, DateTime }
        end
        unless columns.include?(:sold_value)
          db.alter_table(:loot_items) { add_column :sold_value, Integer }
        end
        unless columns.include?(:sold_at)
          db.alter_table(:loot_items) { add_column :sold_at, DateTime }
        end
        unless columns.include?(:sold_category)
          db.alter_table(:loot_items) { add_column :sold_category, String }
        end
        unless columns.include?(:shop_appraisal)
          db.alter_table(:loot_items) { add_column :shop_appraisal, Integer }
        end
        unless columns.include?(:shop_appraised_at)
          db.alter_table(:loot_items) { add_column :shop_appraised_at, DateTime }
        end

        # Sale bonus tracking columns (for reverse-calculating estimated values)
        migrate_loot_items_for_sale_bonus_tracking(db)

        # Wand duplication tracking columns
        migrate_loot_items_for_wand_tracking(db)

        # Gem shatter tracking column
        migrate_loot_items_for_shatter_tracking(db)
      end

      def migrate_loot_items_for_sale_bonus_tracking(db)
        columns = db[:loot_items].columns
        unless columns.include?(:sold_location)
          db.alter_table(:loot_items) { add_column :sold_location, String }
        end
        unless columns.include?(:sold_room_uid)
          db.alter_table(:loot_items) { add_column :sold_room_uid, String }
        end
        unless columns.include?(:sold_trading_bonus)
          db.alter_table(:loot_items) { add_column :sold_trading_bonus, Integer }
        end
        unless columns.include?(:sold_racial_bonus)
          db.alter_table(:loot_items) { add_column :sold_racial_bonus, Integer }
        end
        unless columns.include?(:sold_to)
          db.alter_table(:loot_items) { add_column :sold_to, String }
        end
      end

      def migrate_loot_items_for_wand_tracking(db)
        columns = db[:loot_items].columns
        unless columns.include?(:dupe_source_id)
          db.alter_table(:loot_items) { add_column :dupe_source_id, Integer }
          db.alter_table(:loot_items) { add_index :dupe_source_id, if_not_exists: true }
        end
        unless columns.include?(:duplicated_at)
          db.alter_table(:loot_items) { add_column :duplicated_at, DateTime }
        end

        # Unique index migration (item_id alone -> item_id + item_noun)
        migrate_loot_items_unique_index(db)
      end

      # Migration: change unique index from item_id to (item_id, item_noun)
      # This prevents ID reuse collisions while still blocking true duplicates
      def migrate_loot_items_unique_index(db)
        indexes = db.indexes(:loot_items)
        # Only migrate if old single-column unique index exists
        if indexes[:loot_items_item_id_index]
          db.alter_table(:loot_items) do
            drop_index :item_id, name: :loot_items_item_id_index
            add_index [:item_id, :item_noun], unique: true, if_not_exists: true
          end
        end
      end

      def migrate_loot_items_for_shatter_tracking(db)
        columns = db[:loot_items].columns
        unless columns.include?(:shattered_at)
          db.alter_table(:loot_items) { add_column :shattered_at, DateTime }
        end

        # Gem shop rejection tracking (too valuable items - 25k pawn cap)
        migrate_loot_items_for_gemshop_rejection(db)
      end

      def migrate_loot_items_for_gemshop_rejection(db)
        columns = db[:loot_items].columns
        unless columns.include?(:gemshop_rejected_at)
          db.alter_table(:loot_items) { add_column :gemshop_rejected_at, DateTime }
        end
        unless columns.include?(:pawn_cap_value)
          db.alter_table(:loot_items) { add_column :pawn_cap_value, Integer }
        end
        unless columns.include?(:lost_at)
          db.alter_table(:loot_items) { add_column :lost_at, DateTime }
        end
      end

      def setup_bounty_rewards_table(db)
        db.create_table?(:bounty_rewards) do
          primary_key :id
          Integer :bounty_points
          Integer :experience
          Integer :silver
          String :character, null: false
          String :game, null: false
          DateTime :created_at, null: false

          index [:character, :game, :created_at]
        end
      end

      def setup_transactions_table(db)
        db.create_table?(:transactions) do
          primary_key :id
          String :character, null: false
          String :game, null: false
          Integer :amount, null: false
          String :category, null: false
          String :subcategory
          String :metadata
          DateTime :created_at, null: false
          Integer :year, null: false
          Integer :month, null: false
          Integer :day, null: false
          Integer :hour, null: false

          index [:character, :game, :year, :month, :day]
          index [:category, :character, :game]
          index [:created_at]
        end

        # Add item linking column
        migrate_transactions_for_item_linking(db)
      end

      def migrate_transactions_for_item_linking(db)
        columns = db[:transactions].columns
        unless columns.include?(:loot_item_id)
          db.alter_table(:transactions) { add_column :loot_item_id, Integer }
          db.alter_table(:transactions) { add_index :loot_item_id, if_not_exists: true }
        end
      end
    end
  end

  # ===== Table Accessors =====
  class << self
    def events_table
      @_events_table ||= begin
        Database.setup!
        @db[:loot_events]
      end
    end

    def skin_events_table
      @_skin_events_table ||= begin
        Database.setup!
        @db[:skin_events]
      end
    end

    def bundle_events_table
      @_bundle_events_table ||= begin
        Database.setup!
        @db[:bundle_events]
      end
    end

    def items_table
      @_items_table ||= begin
        Database.setup!
        @db[:loot_items]
      end
    end

    def bounties_table
      @_bounties_table ||= begin
        Database.setup!
        @db[:bounty_rewards]
      end
    end

    def transactions_table
      @_transactions_table ||= begin
        Database.setup!
        @db[:transactions]
      end
    end
  end

  # ===== Patterns Module =====
  # Full-match trigger patterns for the hook (prevents false positives)
  # These match complete XML structure, not partial substrings
  # NOTE: noun can contain hyphens (e.g., "shield-maiden"), so use [^"]+ instead of \w+
  module Patterns
    # ===== SEARCH =====
    # Trigger: "You search the <creature>"
    # Note: No ^ anchor because line can have <dialogData> prefix from UI
    SEARCH_TRIGGER = %r{You search the <pushBold/><a exist="(\d+)" noun="([^"]+)">([^<]+)</a><popBold/>\.}

    # Within-search extraction patterns (not triggers)
    # Real: <pushBold/><a exist="393774588" noun="berserker">He</a><popBold/> had 344 silvers on <pushBold/><a exist="393774588" noun="berserker">him</a><popBold/>.
    SEARCH_SILVER = %r{<pushBold/><a exist="\d+" noun="[^"]+">[^<]+</a><popBold/> had (\d[\d,]*) silvers on}

    # Real: <pushBold/><a exist="393750260" noun="berserker">He</a><popBold/> had a <a exist="393771201" noun="deathstone">misty grey deathstone</a> on...
    # Note: Some items lack a/an article
    SEARCH_ITEM_HAD = %r{<pushBold/><a exist="\d+" noun="[^"]+">[^<]+</a><popBold/> had (?:an? )?<a exist="(\d+)" noun="([^"]+)">([^<]+)</a> on}

    # Real: <pushBold/><a exist="474795230" noun="berserker">She</a><popBold/> had a <a exist="474796069" noun="sword">bone-pommeled rolaren short sword</a>.
    # Weapons/equipment ending with period (no "on him/her"). Note: Some items lack a/an article.
    SEARCH_ITEM_HAD_SIMPLE = %r{<pushBold/><a exist="\d+" noun="[^"]+">[^<]+</a><popBold/> had (?:an? )?<a exist="(\d+)" noun="([^"]+)">([^<]+)</a>\.}

    # Real: <pushBold/><a exist="393770644" noun="berserker">She</a><popBold/> carried an <a exist="393771197" noun="strongbox">enruned silver strongbox</a> on...
    # Note: Some items lack a/an article
    SEARCH_ITEM_CARRIED = %r{<pushBold/><a exist="\d+" noun="[^"]+">[^<]+</a><popBold/> carried (?:an? )?<a exist="(\d+)" noun="([^"]+)">([^<]+)</a> on}

    # Real: Interesting, <pushBold/><a exist="393774588" noun="berserker">he</a><popBold/> carried <a exist="393795395" noun="leaf">some acantha leaf</a> on...
    # Note: No "a/an" before item - can be "some" or nothing
    SEARCH_INTERESTING = %r{Interesting, <pushBold/><a exist="\d+" noun="[^"]+">[^<]+</a><popBold/> carried (?:an? |some )?<a exist="(\d+)" noun="([^"]+)">([^<]+)</a> on}

    # Real: <pushBold/><a exist="13734312" noun="berserker">He</a><popBold/> left a <a exist="13734557" noun="crystal">n'ayanad crystal</a> behind.
    # Note: Uses creature pronoun format. Can have "some" instead of a/an for plurals.
    SEARCH_ITEM_LEFT = %r{<pushBold/><a exist="\d+" noun="[^"]+">[^<]+</a><popBold/> left (?:an? |some )?<a exist="(\d+)" noun="([^"]+)">([^<]+)</a> behind\.}

    # Real: A <a exist="308801244" noun="key">vibrant royal blue key</a> appears on the ground!
    SEARCH_KEY = %r{A <a exist="(\d+)" noun="key">((?:radiant|vibrant) (?:blood red|forest green|frosty white|royal blue|rainbow-hued) key)</a> appears on the ground!}
    SEARCH_LOCK = %r{A <a exist="(\d+)" noun="lock">((?:radiant|vibrant) (?:blood red|forest green|frosty white|royal blue|rainbow-hued) lock)</a> appears on the ground!}

    # Real: <pushBold/>You notice a scintillating mote of gemstone dust on the ground and gather it quickly.
    SEARCH_GEMSTONE_DUST = %r{<pushBold/>You notice a scintillating mote of gemstone dust on the ground and gather it quickly\.}

    # Real: <pushBold/> ** A glint of light catches your eye, and you notice an <a exist="309578537" noun="jewel">unfinished pyrite jewel aswirl with dark opacity</a> at your feet! **
    SEARCH_GEMSTONE_JEWEL = %r{<pushBold/> \*\* A glint of light catches your eye, and you notice an? <a exist="(\d+)" noun="([^"]+)">([^<]+)</a> at your feet! \*\*}

    # Real: <pushBold/>You have been awarded 1 Long-Term Experience Boost!  You may use the <d>BOOST</d> command to access this reward!
    SEARCH_BOOST = %r{<pushBold/>You have been awarded (\d+) Long-Term Experience Boost!}

    # ===== SKINNING =====
    # Real: You skinned the <pushBold/><a exist="...">triton brawler</a><popBold/>, yielding a <a exist="...">darkened triton hide</a>.
    # Note: No ^ anchor because line can have <dialogData> prefix from UI
    SKIN_TRIGGER = %r{You skinned the <pushBold/><a exist="(\d+)" noun="([^"]+)">([^<]+)</a><popBold/>, yielding an? <a exist="(\d+)" noun="([^"]+)">([^<]+)</a>\.}

    # ===== APPRAISAL =====
    # Gem appraise: "You peer intently at the <gem>... worth approximately X silvers"
    # Real: You peer intently at the <a exist="321408923" noun="diamond">uncut diamond</a> as you turn it in your fingers, meticulously inspecting for flaws.  You estimate that the <a exist="321408923" noun="diamond">uncut diamond</a> is a rare gemstone of above average quality and worth approximately 4,000 silvers.
    # Rarity can be multiple words: "rare", "very rare", "extremely common", etc.
    # Quality can be multi-word: "above average", "very cheap", etc.
    # Captures: 1=item_id, 2=noun, 3=name, 4=rarity, 5=quality, 6=value
    # NOTE: Most gems say "gemstone" but rare items like fossilized eggs say "piece of treasure"
    GEM_APPRAISE = %r{You peer intently at the <a exist="(\d+)" noun="([^"]+)">([^<]+)</a> as you turn it in your fingers, meticulously inspecting for flaws\.\s+You estimate that the <a exist="\d+" noun="[^"]+">[^<]+</a> is an? (.+?) (?:gemstone|piece of treasure) of (.+?) quality and worth approximately ([\d,]+) silvers[.!]}

    # Skin appraise: "You turn the <hide> over... worth approximately X silvers"
    # Real: You turn the <a exist="691558" noun="hide">darkened triton hide</a> over in your hands, meticulously inspecting for flaws.  You estimate that the <a exist="691558" noun="hide">darkened triton hide</a> is of magnificent quality and worth approximately 25 silvers!
    # Captures: 1=item_id, 2=noun, 3=name, 4=quality, 5=value
    SKIN_APPRAISE = %r{You turn the <a exist="(\d+)" noun="([^"]+)">([^<]+)</a> over in your hands, meticulously inspecting for flaws\.\s+You estimate that the <a exist="\d+" noun="[^"]+">[^<]+</a> is of (\w+) quality and worth approximately ([\d,]+) silvers[.!]}

    # Real: You turn the <hides> over...  You estimate that of the 8 <hides> in your bundle, 3 are fine quality and 5 are magnificent quality.
    SKIN_APPRAISE_BUNDLE_QUALITY = %r{You turn the <a exist="\d+" noun="[^"]+">[^<]+</a> over in your hands, meticulously inspecting for flaws\.\s+You estimate that of the (\d+) <a exist="\d+" noun="[^"]+">[^<]+</a> in your bundle}

    # Real: You estimate that the total value of your <hides> is approximately 75 silvers.
    SKIN_APPRAISE_BUNDLE_VALUE = %r{You estimate that the total value of your <a exist="\d+" noun="[^"]+">[^<]+</a> is approximately ([\d,]+) silvers\.}

    # ===== LORESONG (BARD) =====
    # Bard loresong value appraisal - comes in two separate lines/chunks
    # Line 1: As you sing, you feel a faint resonating vibration from the <a exist="554177549" noun="ivory">age-darkened ivory</a> in your hand, and you learn something about it...
    # Line 2: This is a small item, under a pound.  In your best estimation, it's worth about 1,400 silvers, and is of outstanding quality.
    LORESONG_START = %r{As you sing, you feel a faint resonating vibration from the <a exist="(\d+)" noun="([^"]+)">([^<]+)</a> in your hand}
    LORESONG_VALUE_LINE = %r{it's worth about ([\d,]+) silvers}

    # ===== GEM SHATTER (failed purification) =====
    # Your focused voice causes the <a exist="143218758" noun="diamond">uncut diamond</a> to shatter into thousands of fragments!
    GEM_SHATTER = %r{Your focused voice causes the <a exist="(\d+)" noun="([^"]+)">([^<]+)</a> to shatter}

    # ===== BUNDLING =====
    # Real: As you place your <hide> inside your <shroud>, you notice another <hide> inside the <shroud> and carefully arrange the two <hides> into a neat bundle.
    BUNDLE_CREATE = %r{As you place your <a exist="(\d+)" noun="([^"]+)">([^<]+)</a> inside your <a exist="(\d+)" noun="([^"]+)">([^<]+)</a>, you notice another.+?the two <a exist="(\d+)" noun="([^"]+)">([^<]+)</a> into a neat bundle\.}

    # Real: You carefully add your <hide> to your bundle of <hides> inside your <shroud>.
    BUNDLE_ADD = %r{You carefully add your <a exist="(\d+)" noun="([^"]+)">([^<]+)</a> to your bundle of <a exist="(\d+)" noun="([^"]+)">([^<]+)</a> inside your <a exist="(\d+)" noun="([^"]+)">([^<]+)</a>\.}

    # Real: You carefully arrange your two <hides> into a neat bundle.
    BUNDLE_MANUAL = %r{You carefully arrange your two <a exist="(\d+)" noun="([^"]+)">([^<]+)</a> into a neat bundle\.}

    # ===== BOX OPENING =====
    # Real format (all on one line):
    # <container id='394764379' title='Chest'...><clearContainer id="394764379"/>
    # Real: <pushBold/>The <locksmith><popBold/> says, "Alright, here's your <box> back."
    BOX_RETURN_TRIGGER = %r{<pushBold/>The <a exist="\d+" noun="[^"]+">[^<]+</a><popBold/> says, "Alright, here's your <a exist="(\d+)" noun="([^"]+)">([^<]+)</a> back\."}

    # Pool quote - first message with box details
    # Real: You want a locksmith to open a <a exist="12345" noun="strongbox">simple haon strongbox</a> for a tip of 219 silvers, or 3 percent of the box value.  There is also a fee of 2,716 silvers due up front
    # Captures: 1=box_id, 2=box_noun, 3=box_name, 4=tip, 5=fee
    BOX_POOL_QUOTE = %r{You want a locksmith to open (?:a |an )?<a exist="(\d+)" noun="([^"]+)">([^<]+)</a> for a tip of ([\d,]+) silvers?.+?fee of ([\d,]+) silvers? due up front}

    # Pool confirmation - second message after dropping box
    # Real: <pushBold/>The <locksmith><popBold/> takes your chest and says, "Your tip of 169 silvers has been recorded, and the 2001 silver fee has been collected.  We'll get someone on that right away."
    # Note: "The" may be omitted in some contexts
    # Captures: 1=box_noun, 2=tip, 3=fee
    BOX_POOL_DROP_CONFIRM = %r{<pushBold/>(?:The )?<a exist="\d+" noun="[^"]+">[^<]+</a><popBold/> takes your (\w+) and says, "Your tip of ([\d,]+) silvers? has been recorded, and the ([\d,]+) silvers? fee has been collected\.}

    # Real: You gather the remaining 1,576 <a exist="517651953" noun="coins">coins</a> from inside your <a exist="517651949" noun="strongbox">maoral strongbox</a>.
    # Real: You gather the remaining 2,410 <a exist="23611759" noun="coins">coins</a> from inside a <a exist="23611757" noun="trunk">painted mahogany trunk</a>.
    # Captures: 1=silvers, 2=box_id, 3=box_noun, 4=box_name
    BOX_SILVER = %r{You gather the remaining ([\d,]+) <a exist="\d+" noun="coins">coins</a> from inside (?:your|an?) <a exist="(\d+)" noun="([^"]+)">([^<]+)</a>\.}

    # Real: You summon a swarm of corpse flies from your <charm>...inside an <coffer>...locate a pile of 2,090 <coins>, reclaiming them...
    # Also: You summon a swarm of crystal-shelled snails from your <charm>...inside a <chest>...They locate a pile of 4,305 <coins>, reclaiming them...
    # Captures: 1=box_id, 2=box_noun, 3=box_name, 4=silvers
    BOX_SILVER_CHARM = %r{You summon a swarm of [^<]+from your.+?inside an? <a exist="(\d+)" noun="([^"]+)">([^<]+)</a>.+?locate a pile of ([\d,]+) <a exist="\d+" noun="coins">coins</a>, reclaiming them}

    # Extract items from <inv> tags
    # Real: <inv id='394764379'> a <a exist="394764382" noun="scroll">shimmering scroll</a></inv>
    BOX_INV_ITEM = %r{<inv id='(\d+)'>\s*(?:a |an |some )?<a exist="(\d+)" noun="([^"]+)">([^<]+)</a></inv>}

    # LOOK IN wedged/stuck-open box - captures container header from LOOK IN command
    # Real: <container id='555359993' title='Chest'...><clearContainer id="555359993"/>
    #       <inv id='555359993'>In the <a exist="555359993" noun="chest">chest</a>:</inv>
    #       <inv id='555359993'> a <a exist="555686108" noun="spring">steel spring</a></inv>...
    #       In the <a exist="555359993" noun="chest">maoral chest</a>:  <-- FULL NAME here
    # Note: First <inv> header has short name, full name comes after </inv> tags
    BOX_LOOK_IN = %r{<container id='(?<box_id>\d+)'[^>]*/>.*In the <a exist="\d+" noun="(?<box_noun>[^"]+)">(?<box_name>[^<]+)</a>:}

    # ===== SELLING (Pawnbroker) =====
    # Trigger: You offer to sell your <item> to Bushybrow.
    SELL_ITEM_TRIGGER = %r{You offer to sell your <a exist="(\d+)" noun="([^"]+)">([^<]+)</a> to}

    # Real: Bushybrow takes your <a exist="339188773" noun="wand">bloodwood wand</a>, glances at it briefly, then hands you 582 silver coins.
    SELL_RECEIVED_SILVER = %r{takes your <a exist="(\d+)" noun="([^"]+)">([^<]+)</a>, glances at it briefly, then hands you ([\d,]+) silver coins\.}

    # Real: He scribbles out a <a exist="339455621" noun="chit">salt-stained kraken chit</a> for 25,000 silvers and hands it to you.
    SELL_RECEIVED_NOTE = %r{scribbles out a <a exist="(\d+)" noun="([^"]+)">([^<]+)</a> for ([\d,]+) silvers? and hands it to you\.}

    # Real: Bushybrow says, "That's basically worthless here, Dicate.  Maybe you can find a buyer somewhere in town, but I doubt it."
    SELL_WORTHLESS = %r{says, "That's basically worthless here,}

    # Real: Sniffberry examines your pouch carefully and exclaims, "Goodness, gracious me!  Where do you find this junk?
    # Captures: 1=item_id, 2=noun, 3=name
    SELL_JUNK = %r{Where do you find this junk\?.*?your <a exist="(\d+)" noun="([^"]+)">([^<]+)</a>}

    # ===== SHOP APPRAISAL (value check without selling) =====
    # Pawn shop multi-line: Line 1 has item, Line 2 has value
    # Real: <Walsor Gryhm> turns the <a exist="568226735" noun="aventail">aventail</a> over in his hands a few times.
    # Real: <Walsor Gryhm> says, "Hmm, a most impressive bit of protection of note.  I'll give you 9,472 silver coins for it."
    SHOP_APPRAISE_START = %r{turns the <a exist="(\d+)" noun="([^"]+)">([^<]+)</a> over in (?:his|her) hands}
    # Multiple formats for value line (all capture the actual offer, which counts for lootcap):
    # Normal: "I'll give you 9,472 silver coins for it."
    # High value: "I'll offer you 25,000 silver and no more!"
    # Alternate: "I will offer you 25,000 silvers for it."
    SHOP_APPRAISE_VALUE = %r{I(?:'ll| will) (?:give|offer) you ([\d,]+) silver}

    # Jeweler single-line appraisal (ingots, etc.)
    # Real: The <jeweler> takes the <a exist="568262930" noun="ingot">gold ingot</a> and inspects it carefully before saying, "I'll give you 7,825 silvers for it..."
    SHOP_APPRAISE_JEWELER = %r{takes the <a exist="(\d+)" noun="([^"]+)">([^<]+)</a> and inspects it carefully before saying, "I'll give you ([\d,]+) silvers? for it}

    # Pawn "probably worth about" format (item + value on same line after appraisal)
    # Real: Sniffberry shrugs before saying, "That <item> looks decent, probably worth about 83,058 silvers.
    SHOP_APPRAISE_WORTH = %r{That <a exist="(\d+)" noun="([^"]+)">([^<]+)</a> looks decent, probably worth about ([\d,]+) silvers}

    # ===== GEM SHOP =====
    # Format 1 (named NPC): The <pushBold/><a exist="-480255" noun="Krosane">jeweler Krosane</a><popBold/> takes the <star sapphire>...
    # Format 2 (generic NPC): The gemcutter takes the <platinum nugget>...
    # Format 3 (multi-word NPC): The dwarven clerk takes the <green starstone>...
    GEMSHOP_SELL = %r{[Tt]he (?:<pushBold/><a exist="[^"]+" noun="[^"]+">[^<]+</a><popBold/>|[\w\s]+?) takes the <a exist="(\d+)" noun="([^"]+)">([^<]+)</a>, gives it a careful examination and hands you ([\d,]+) silver for it\.}

    # Real: The <jeweler><popBold/> takes the <shroud>, inspects the contents carefully, and removes the gems he is interested in.  He hands it back to you, along with 8,383 silver.
    GEMSHOP_BULK_SELL = %r{[Tt]he (?:<pushBold/><a exist="[^"]+" noun="[^"]+">[^<]+</a><popBold/>|[\w\s]+?) takes the <a exist="\d+" noun="[^"]+">[^<]+</a>, inspects the contents carefully, and removes the gems.+?hands it back to you, along with ([\d,]+) silver\.}

    # Real: The <pushBold/><jeweler Krosane><popBold/> removes the gems and hands you a <chit> for 533,549 silvers.
    GEMSHOP_BULK_SELL_CHIT = %r{[Tt]he (?:<pushBold/><a exist="[^"]+" noun="[^"]+">[^<]+</a><popBold/>|[\w\s]+?) removes the gems and hands you a <a exist="\d+" noun="[^"]+">[^<]+</a> for ([\d,]+) silvers?\.}

    # Real (XML): ...hands you a <a exist="25965764" noun="note">Vornavis promissory note</a> for 33,250 silvers.
    # Real (stripped): ...hands you a Northwatch bond note for 21,030 silvers.
    GEMSHOP_SELL_NOTE = %r{[Tt]he (?:<pushBold/><a exist="[^"]+" noun="[^"]+">[^<]+</a><popBold/>|[\w\s]+?) takes the <a exist="(\d+)" noun="([^"]+)">([^<]+)</a>, gives it a careful examination and.+?hands you a.+?note(?:<\/a>)? for ([\d,]+) silvers?\.}

    # ===== GEM SHOP REJECTION (too valuable) =====
    # Two-step: ASK caches item, REJECT marks it as too valuable for gem shop (25k pawn cap)
    # Real: You ask Kahlyr if she would like to buy an <a exist="20230323" noun="stickpin">enruned gold stickpin</a>.
    # Real: You ask Zirconia to appraise an <a exist="20230323" noun="stickpin">enruned gold stickpin</a>.
    GEMSHOP_ASK = %r{You ask \S+ (?:if \S+ would like to buy|to appraise) an? <a exist="(\d+)" noun="([^"]+)">([^<]+)</a>}

    # Real: The <pushBold/><a exist="92482" noun="Kahlyr">jeweler Kahlyr</a><popBold/> says, "Sorry, <player>, I'm not buying anything this valuable today.  Maybe tomorrow."
    GEMSHOP_REJECT = %r{says, "Sorry,.+?I'm not buying anything this valuable today}

    # ===== CHRONOMAGE =====
    # Real: <pushBold/>A <a exist="522933755" noun="halfling">finely-dressed halfling</a><popBold/> gleefully snatches
    #       a <a exist="522418497" noun="ring">braided gold ring</a> from your outreached hand and exclaims,
    #       "...In return I'll charge you 5,000 silvers less for your next travel ticket..."
    # Captures: 1=item_id, 2=noun, 3=name, 4=credit_value
    CHRONOMAGE_RING = %r{gleefully snatches a <a exist="(\d+)" noun="([^"]+)">([^<]+)</a> from your outreached hand.+?I'll charge you ([\d,]+) silvers less}

    # ===== FURRIER =====
    # Real: Delosa takes the <a exist="339211582" noun="hide">hide</a>, scrutinizes it carefully, then hands you 12 silvers.
    # Zul Logoth: Bulthark takes the <a exist="...">hide</a>, appraises it minutely, then pays you 12 silvers.
    SKIN_SELL = %r{(\w+) takes the <a exist="(\d+)" noun="([^"]+)">([^<]+)</a>, (?:scrutinizes it carefully|appraises it minutely), then (?:hands|pays) you ([\d,]+) silvers?\.}

    # Real: Delosa takes the <shroud>, inspects the contents carefully and removes the item he is interested in.  Delosa hands it back to you, along with 127 silver.
    SKIN_SELL_BULK = %r{(\w+) takes the <a exist="\d+" noun="[^"]+">[^<]+</a>, inspects the contents carefully and removes the items?.+?hands it back to you, along with ([\d,]+) silver\.}

    # ===== BANKING =====
    # Real: You deposit 9,250 silvers into your account.  The teller carefully records...
    SILVER_DEPOSIT = %r{You deposit ([\d,]+) silvers? into your account\.}

    # Real: The teller carefully records the transaction, hands you 8,000 silvers, and says, "This brings your total to 455,394 silvers."
    SILVER_WITHDRAW = %r{teller carefully records the transaction,? (?:and )?hands you ([\d,]+) silvers?}

    # Real: She says, "That's a total of 50,683 silvers, bringing your balance to 234,039 silvers."
    NOTE_DEPOSIT = %r{That's a total of ([\d,]+) silvers, bringing your balance to}

    # ===== BOUNTY =====
    # Real: [You have earned 925 bounty points, 800 experience points, and 9250 silver.]
    BOUNTY_REWARD = %r{\[You have earned ([\d,]+) bounty points?, ([\d,]+) experience points?, and ([\d,]+) silver\.\]}

    # ===== WAND DUPLICATION (918 spell) =====
    # Success message - unique identifier for successful dupe
    WAND_DUPE_TRIGGER = /The glow fades from both objects and they solidify, looking almost identical to the original, and feeling a little lighter\./

    # Extract donor wand from gesture line: "You gesture at a <wand>."
    WAND_DUPE_GESTURE = %r{You gesture at an? <a exist="(\d+)" noun="([^"]+)">([^<]+)</a>}

    # New wand appearing in either hand
    WAND_IN_HAND = %r{<(?:left|right) exist="(\d+)" noun="([^"]+)">([^<]+)</(?:left|right)>}

    # Combined trigger for hook filter
    # Only actual event triggers - extraction patterns are used within processors
    TRIGGER_REGEX = Regexp.union(
      SEARCH_TRIGGER,
      SKIN_TRIGGER,
      GEM_APPRAISE,
      SKIN_APPRAISE,
      SKIN_APPRAISE_BUNDLE_QUALITY,
      BUNDLE_CREATE,
      BUNDLE_ADD,
      BUNDLE_MANUAL,
      BOX_RETURN_TRIGGER,
      BOX_POOL_QUOTE,
      BOX_POOL_DROP_CONFIRM,
      BOX_SILVER,
      BOX_SILVER_CHARM,
      BOX_LOOK_IN,
      SELL_ITEM_TRIGGER,
      SELL_WORTHLESS,
      SHOP_APPRAISE_START,
      SHOP_APPRAISE_VALUE,
      SHOP_APPRAISE_JEWELER,
      SHOP_APPRAISE_WORTH,
      GEMSHOP_SELL,
      GEMSHOP_SELL_NOTE,
      GEMSHOP_BULK_SELL,
      GEMSHOP_BULK_SELL_CHIT,
      GEMSHOP_ASK,
      GEMSHOP_REJECT,
      CHRONOMAGE_RING,
      SKIN_SELL,
      SKIN_SELL_BULK,
      SILVER_DEPOSIT,
      SILVER_WITHDRAW,
      NOTE_DEPOSIT,
      BOUNTY_REWARD,
      WAND_DUPE_TRIGGER,
      LORESONG_START,
      LORESONG_VALUE_LINE,
      GEM_SHATTER
    ).freeze

    class << self
      def trigger_match?(line)
        line.match?(TRIGGER_REGEX)
      end
    end
  end

  # ===== Parser Module =====
  # Dispatches chunks to appropriate processors based on trigger patterns
  module Parser
    class << self
      def process(chunk)
        joined = chunk.join("\n")

        # Dispatch based on content - order matters (most specific first)
        # Search events (includes klock/special find detection)
        if joined.match?(Patterns::SEARCH_TRIGGER)
          Processors::SearchProcessor.process(chunk)

        # Skinning events
        elsif joined.match?(Patterns::SKIN_TRIGGER)
          Processors::SkinProcessor.process(chunk)

        # Appraisal events (gems and skins)
        elsif joined.match?(Patterns::GEM_APPRAISE) || joined.match?(Patterns::SKIN_APPRAISE) || joined.match?(Patterns::SKIN_APPRAISE_BUNDLE_QUALITY)
          Processors::AppraisalProcessor.process(chunk)

        # Loresong value (bard) - two-step: start caches item, value line applies it
        # Also handles gem shatter (failed purification)
        elsif joined.match?(Patterns::LORESONG_START) || joined.match?(Patterns::LORESONG_VALUE_LINE) ||
              joined.match?(Patterns::GEM_SHATTER)
          Processors::LoresongProcessor.process(chunk)

        # Bundle events
        elsif joined.match?(Patterns::BUNDLE_CREATE) || joined.match?(Patterns::BUNDLE_ADD) || joined.match?(Patterns::BUNDLE_MANUAL)
          Processors::BundleProcessor.process(chunk)

        # Box events (return, silver gather, look in wedged)
        elsif joined.match?(Patterns::BOX_RETURN_TRIGGER) ||
              joined.match?(Patterns::BOX_SILVER) || joined.match?(Patterns::BOX_SILVER_CHARM) ||
              joined.match?(Patterns::BOX_LOOK_IN)
          Processors::BoxProcessor.process(chunk)

        # Box pool quote (save pending) and confirm (record fee/tip)
        elsif joined.match?(Patterns::BOX_POOL_QUOTE) || joined.match?(Patterns::BOX_POOL_DROP_CONFIRM)
          Processors::LocksmithProcessor.process(chunk)

        # Pawn/item sell events
        elsif joined.match?(Patterns::SELL_ITEM_TRIGGER) || joined.match?(Patterns::SELL_RECEIVED_SILVER) ||
              joined.match?(Patterns::SELL_WORTHLESS)
          Processors::SellProcessor.process(chunk)

        # Shop appraisal (value check without selling)
        elsif joined.match?(Patterns::SHOP_APPRAISE_START) || joined.match?(Patterns::SHOP_APPRAISE_VALUE) ||
              joined.match?(Patterns::SHOP_APPRAISE_JEWELER) || joined.match?(Patterns::SHOP_APPRAISE_WORTH)
          Processors::ShopAppraisalProcessor.process(chunk)

        # Gem shop events (including rejection for too-valuable items)
        elsif joined.match?(Patterns::GEMSHOP_SELL) || joined.match?(Patterns::GEMSHOP_SELL_NOTE) ||
              joined.match?(Patterns::GEMSHOP_BULK_SELL) || joined.match?(Patterns::GEMSHOP_BULK_SELL_CHIT) ||
              joined.match?(Patterns::GEMSHOP_ASK) || joined.match?(Patterns::GEMSHOP_REJECT)
          Processors::GemshopProcessor.process(chunk)

        # Furrier events
        elsif joined.match?(Patterns::SKIN_SELL) || joined.match?(Patterns::SKIN_SELL_BULK)
          Processors::FurrierProcessor.process(chunk)

        # Banking events
        elsif joined.match?(Patterns::SILVER_DEPOSIT) || joined.match?(Patterns::SILVER_WITHDRAW) ||
              joined.match?(Patterns::NOTE_DEPOSIT)
          Processors::BankProcessor.process(chunk)

        # Bounty reward
        elsif joined.match?(Patterns::BOUNTY_REWARD)
          Processors::BountyProcessor.process(chunk)

        # Chronomage ring turn-in
        elsif joined.match?(Patterns::CHRONOMAGE_RING)
          Processors::ChronomageProcessor.process(chunk)

        # Wand duplication (918 spell)
        elsif joined.match?(Patterns::WAND_DUPE_TRIGGER)
          Processors::WandDupeProcessor.process(chunk)
        end
      end
    end
  end

  # ===== XML Helpers =====
  module XMLHelpers
    # Extract GameObj-style data from XML link
    # Input: <a exist="123456" noun="gem">blue sapphire</a>
    # Output: { id: "123456", noun: "gem", name: "blue sapphire" }
    def self.extract_gameobj(xml_line)
      match = xml_line.match(/<a exist="(\d+)" noun="([^"]+)">([^<]+)<\/a>/)
      return nil unless match

      {
        id: match[1],
        noun: match[2],
        name: match[3]
      }
    end

    # Extract all GameObj links from a line
    def self.extract_all_gameobjs(xml_line)
      xml_line.scan(/<a exist="(\d+)" noun="([^"]+)">([^<]+)<\/a>/).map do |match|
        { id: match[0], noun: match[1], name: match[2] }
      end
    end

    # Strip XML tags from line
    def self.strip_xml(line)
      line.gsub(/<[^>]+>/, '').strip
    end

    # Extract silver amount from text like "You find 847 coins!"
    def self.extract_silvers(line)
      match = line.match(/(\d[\d,]*)\s*(?:coins?|silvers?)/)
      return nil unless match

      match[1].delete(',').to_i
    end
  end

  # ===== Processors Module =====
  module Processors
    # Base processor with common functionality
    class BaseProcessor
      def self.log(msg)
        LootTracker.log("[#{name.split('::').last}] #{msg}") if LootTracker.debug?
      end
    end

    # Processes creature search results
    # Uses patterns from Patterns module for extraction
    class SearchProcessor < BaseProcessor
      def self.process(chunk)
        creature = nil
        silvers = nil
        items = []
        klocks = []
        special_finds = []

        chunk.each do |line|
          # Extract creature from search line - SEARCH_TRIGGER now has captures: id, noun, name
          if (match = line.match(Patterns::SEARCH_TRIGGER))
            creature = { id: match[1], noun: match[2], name: match[3] }
          end

          # Extract silver coins
          if (match = line.match(Patterns::SEARCH_SILVER))
            silvers = match[1].delete(',').to_i
          end

          # Extract items - use elsif chain because "Interesting" lines also match CARRIED pattern
          # Check INTERESTING first since it's more specific
          if (match = line.match(Patterns::SEARCH_INTERESTING))
            items << { id: match[1], noun: match[2], name: match[3] }
          elsif (match = line.match(Patterns::SEARCH_ITEM_HAD))
            items << { id: match[1], noun: match[2], name: match[3] }
          elsif (match = line.match(Patterns::SEARCH_ITEM_CARRIED))
            items << { id: match[1], noun: match[2], name: match[3] }
          elsif (match = line.match(Patterns::SEARCH_ITEM_HAD_SIMPLE))
            items << { id: match[1], noun: match[2], name: match[3] }
          elsif (match = line.match(Patterns::SEARCH_ITEM_LEFT))
            items << { id: match[1], noun: match[2], name: match[3] }
          end

          # Detect klock keys appearing on ground
          if (match = line.match(Patterns::SEARCH_KEY))
            klocks << { id: match[1], name: match[2], type: 'key' }
          end

          # Detect klock locks appearing on ground
          if (match = line.match(Patterns::SEARCH_LOCK))
            klocks << { id: match[1], name: match[2], type: 'lock' }
          end

          # Detect gemstone dust
          if line.match?(Patterns::SEARCH_GEMSTONE_DUST)
            special_finds << { type: 'gemstone_dust', name: 'gemstone dust' }
          end

          # Detect gemstone jewel at feet
          if (match = line.match(Patterns::SEARCH_GEMSTONE_JEWEL))
            special_finds << { type: 'gemstone_jewel', id: match[1], noun: match[2], name: match[3] }
          end

          # Detect LTE boost
          if line.match?(Patterns::SEARCH_BOOST)
            special_finds << { type: 'lte_boost', name: 'Long-Term Experience Boost' }
          end
        end

        return unless creature

        log("Search: #{creature[:name]} -> #{silvers || 0} silvers, #{items.size} items, #{klocks.size} klocks, #{special_finds.size} special")

        LootTracker.record_search(
          creature_id: creature[:id],
          creature_name: creature[:name],
          silvers: silvers,
          items: items
        )

        # Record klocks found during search
        klocks.each do |klock|
          log("Klock found: #{klock[:name]}")
          LootTracker.record_klock(item_id: klock[:id], item_name: klock[:name])
        end

        # Record special finds
        special_finds.each do |find|
          log("Special find: #{find[:type]} - #{find[:name]}")
          LootTracker.record_special_find(
            item_name: find[:name],
            find_type: find[:type],
            item_id: find[:id],
            item_noun: find[:noun]
          )
        end
      end
    end

    # Processes skinning results
    class SkinProcessor < BaseProcessor
      # Real format: "You skinned the <creature>, yielding a <skin>."
      # Note: Creature has pushBold/popBold tags, skin doesn't
      SKIN_LINE = /You skinned the (?:<[^>]+>)*<a exist="(\d+)" noun="([^"]+)">([^<]+)<\/a>(?:<[^>]+>)*, yielding an? <a exist="(\d+)" noun="([^"]+)">([^<]+)<\/a>/

      def self.process(chunk)
        chunk.each do |line|
          next unless (match = line.match(SKIN_LINE))

          # Creature is groups 1-3, skin is groups 4-6
          creature = { id: match[1], noun: match[2], name: match[3] }
          skin = { id: match[4], noun: match[5], name: match[6] }

          log("Skin: #{skin[:name]} from #{creature[:name]}")

          LootTracker.record_skin(
            creature_id: creature[:id],
            creature_name: creature[:name],
            item_id: skin[:id],
            item_name: skin[:name],
            item_noun: skin[:noun]
          )
        end
      end
    end

    # Processes box opening results
    # Real format: <container...><inv...>items</inv>You open a <box>.
    class BoxProcessor < BaseProcessor

      def self.process(chunk)
        log("[BoxProcessor] Called with #{chunk.size} lines") if LootTracker.debug?
        chunk.each do |line|
          # Debug: Check if BOX_LOOK_IN pattern could match this line
          if LootTracker.debug? && line.include?('<container')
            log("[BoxProcessor] Line has <container>, testing BOX_LOOK_IN...")
            log("[BoxProcessor] Match result: #{!!line.match(Patterns::BOX_LOOK_IN)}")
          end

          # 1. BOX_RETURN_TRIGGER - check FIRST, return early if matched
          # This prevents processing worn item lines for inv/silver patterns
          if (match = line.match(Patterns::BOX_RETURN_TRIGGER))
            returned_box_id = match[1]
            returned_box_name = match[3]
            log("Box returned from pool: #{returned_box_name} (#{returned_box_id})") if LootTracker.debug?
            LootTracker.link_returned_pool_box(new_box_id: returned_box_id, box_name: returned_box_name)
            return # Exit - don't process for open/inv/silver
          end

          # 2. BOX_LOOK_IN - handle wedged/stuck-open boxes via LOOK IN
          # Uses duplicate checking to avoid recording same items twice
          if (match = line.match(Patterns::BOX_LOOK_IN))
            box_id = match[:box_id]
            box_noun = match[:box_noun]
            box_name = match[:box_name]

            # Skip non-box containers (satchels, disks, herb kits, etc.)
            unless BOX_NOUNS.include?(box_noun)
              log("[BoxProcessor] Skipping non-box container: #{box_noun}") if LootTracker.debug?
              next
            end

            # Get full name from trailing "In the <a>name</a>:" (BOX_LOOK_IN captures short name from container tag)
            if (trailing_match = line.match(/In the <a exist="\d+" noun="[^"]+">([^<]+)<\/a>:\s*$/))
              box_name = trailing_match[1]
            end

            log("[BoxProcessor] LOOK IN: #{box_name} (#{box_id})") if LootTracker.debug?

            # Extract items FIRST (needed for duplicate check)
            items = []
            line.scan(Patterns::BOX_INV_ITEM).each do |inv_match|
              next if inv_match[2] == 'coins'
              items << { id: inv_match[1], noun: inv_match[2], name: inv_match[3] }
              log("[BoxProcessor] Found item: #{inv_match[3]}") if LootTracker.debug?
            end

            # Find box with duplicate check against opened boxes (last 7 days)
            result = LootTracker.find_box_with_duplicate_check(box_id, box_name, items)

            if result[:duplicate]
              log("[BoxProcessor] LOOK IN: Skipping - items already recorded in opened box") if LootTracker.debug?
              next
            end

            if result[:already_opened]
              opened = result[:already_opened]
              log("[BoxProcessor] LOOK IN: Box already opened - '#{opened[:item_name]}' (##{opened[:id]}, searcher: #{opened[:searcher]})") if LootTracker.debug?
              next
            end

            box_item = result[:box]
            unless box_item
              log("[BoxProcessor] LOOK IN: No unopened box found for '#{box_name}' - skipping")
              next
            end

            # Reconcile stale ID if needed
            if box_item[:item_id] != box_id.to_s
              old_id = box_item[:item_id]
              LootTracker.items_table.where(id: box_item[:id]).update(item_id: box_id.to_s)
              log("[BoxProcessor] Reconciled box ID: #{old_id} -> #{box_id}") if LootTracker.debug?
            end

            log("Box (LOOK IN): #{box_name} (#{box_id}) -> #{items.size} items")
            LootTracker.record_box_open(
              box_id: box_id,
              box_name: box_name,
              silvers: nil,
              items: items,
              loot_item_id: box_item[:id]
            )

            return # Done with LOOK IN
          end

          # 3. BOX_SILVER / BOX_SILVER_CHARM - update box with silver amount
          # This comes in a separate chunk after the box is opened

          # Manual gather: "You gather the remaining X coins from inside your <box>."
          if (match = line.match(Patterns::BOX_SILVER))
            silvers = match[1].delete(',').to_i
            box_id = match[2]
            box_name = match[4]

            log("Silver gather (manual): #{silvers} from #{box_name} (#{box_id})")
            update_box_or_record_transaction(box_id, silvers)
            return
          end

          # Charm gather: "You summon a swarm of corpse flies...inside <box>...locate X coins..."
          if (match = line.match(Patterns::BOX_SILVER_CHARM))
            box_id = match[1]
            box_name = match[3]
            silvers = match[4].delete(',').to_i

            log("Silver gather (charm): #{silvers} from #{box_name} (#{box_id})")
            update_box_or_record_transaction(box_id, silvers)
            return
          end
        end
      end

      def self.update_box_or_record_transaction(box_id, silvers)
        updated = LootTracker.update_box_silvers(box_id: box_id, silvers: silvers)

        if updated
          log("Updated box #{box_id} with #{silvers} silvers")
        else
          # No matching box event found - record as standalone transaction
          log("No box event found for #{box_id}, recording as transaction")
          LootTracker.record_transaction(amount: silvers, category: 'box_silver')
        end
      end
    end

    # Processes transaction events (sales, bank, bounty, locksmith)
    class TransactionProcessor < BaseProcessor
      # Transaction pattern definitions - ported from loot_tracker.lic
      PATTERNS = {
        # Gem sales
        gem_sale_individual: {
          regex: /takes the .+?, gives it a careful examination and hands you ([\d,]+) silver for it/,
          category: 'gem_sale',
          sign: :positive
        },
        gem_sale_individual_chit: {
          regex: /takes the .+?, gives it a careful examination.*?hands (?:you|[A-Z][a-z]+) (?:a |an )?.*?(?:chit|note|scrip) for ([\d,]+) silvers/,
          category: 'gem_sale',
          sign: :positive
        },
        gem_sale_bulk: {
          regex: /removes the gems and hands you (?:a |an )?.*? for ([\d,]+) silvers/,
          category: 'gem_sale',
          sign: :positive
        },
        gem_sale_bulk_cash: {
          regex: /removes the gems (?:he|she) is interested in.*?hands it back to you, along with ([\d,]+) silver/,
          category: 'gem_sale',
          sign: :positive
        },

        # Pawn sales
        pawn_sale: {
          regex: /takes your .+?, glances at it briefly, then hands you ([\d,]+) silver coins/,
          category: 'pawn_sale',
          sign: :positive
        },
        pawn_sale_chit: {
          regex: /(?:He|She) scribbles out a .+? chit for ([\d,]+) silvers? and hands it to you/,
          category: 'pawn_sale',
          sign: :positive
        },

        # Furrier sales
        furrier_sale_individual: {
          regex: /takes the .+?, examines it carefully, then hands you ([\d,]+) silvers?/,
          category: 'furrier_sale',
          sign: :positive
        },
        furrier_sale_bulk: {
          regex: /removes the items and hands you (?:a |an )?.*? for ([\d,]+) silvers/,
          category: 'furrier_sale',
          sign: :positive
        },
        furrier_sale_cash: {
          regex: /removes the items (?:he|she) is interested in.*?hands it back to you, along with ([\d,]+) silver/,
          category: 'furrier_sale',
          sign: :positive
        },

        # Bounty rewards
        bounty_silver: {
          regex: /\[You have earned ([\d,]+) bounty points?, ([\d,]+) experience points?, and ([\d,]+) silver\.\]/,
          category: 'bounty_silver',
          sign: :positive,
          capture_index: 3,
          bounty: true
        },

        # Bank transactions
        bank_deposit: {
          regex: /You deposit ([\d,]+) silvers? into your account/,
          category: 'bank_deposit',
          sign: :positive
        },
        bank_deposit_note: {
          regex: /You deposit your notes? worth ([\d,]+) into your account/,
          category: 'note_deposit',
          sign: :positive
        },
        bank_deposit_bulk_notes: {
          regex: /They add up to ([\d,]+) silvers?/,
          category: 'note_deposit',
          sign: :positive
        },
        bank_deposit_bulk_notes_total: {
          regex: /That's a total of ([\d,]+) silvers/,
          category: 'note_deposit',
          sign: :positive
        },
        bank_withdrawal_1: {
          regex: /Very well, a withdrawal of ([\d,]+) silvers?/,
          category: 'bank_withdrawal',
          sign: :negative
        },
        bank_withdrawal_2: {
          regex: /teller scribbles the transaction into a book and hands you ([\d,]+) silvers?/,
          category: 'bank_withdrawal',
          sign: :negative
        },
        bank_withdrawal_3: {
          regex: /teller carefully records the transaction,? (?:and )?hands you ([\d,]+) silvers?/,
          category: 'bank_withdrawal',
          sign: :negative
        },
        note_withdrawal_terras: {
          regex: /scrip for ([\d,]+) silvers?, with a ([\d,]+) silvers? fee/,
          category: 'note_withdrawal',
          sign: :negative
        },

        # Player transactions
        player_give: {
          regex: /^You give .+ ([\d,]+) coins\.$/,
          category: 'player_give',
          sign: :negative
        },

        # Locksmith pool
        locksmith_pool_submit: {
          regex: /Your tip of ([\d,]+) silvers? has been recorded, and the ([\d,]+) silvers? fee has been collected/,
          category: 'locksmith_fee',
          sign: :negative,
          capture_index: 2,
          extra_capture: { index: 1, category: 'locksmith_tip_given', sign: :negative }
        },

        # Debt payment
        debt_payment: {
          regex: /I have a bill of ([\d,]+) silvers? (?:presented by your creditors|that I suggest you pay immediately)/,
          category: 'debt_payment',
          sign: :negative
        }
      }.freeze

      def self.process(chunk)
        chunk.each do |line|
          stripped = XMLHelpers.strip_xml(line)
          next if stripped.empty?

          PATTERNS.each do |name, pattern|
            next unless (match = stripped.match(pattern[:regex]))

            # Get the capture index (default to 1 for first capture group)
            capture_idx = pattern[:capture_index] || 1
            amount_str = match[capture_idx]
            next unless amount_str

            amount = amount_str.delete(',').to_i
            amount = -amount if pattern[:sign] == :negative

            log("#{name}: #{pattern[:category]} #{amount > 0 ? '+' : ''}#{amount}")

            # Handle bounty rewards specially
            if pattern[:bounty]
              bp = match[1].delete(',').to_i
              xp = match[2].delete(',').to_i
              silver = match[3].delete(',').to_i
              LootTracker.record_bounty(bounty_points: bp, experience: xp, silver: silver)
            else
              LootTracker.record_transaction(amount: amount, category: pattern[:category])

              # Handle extra capture (e.g., locksmith tip + fee)
              if pattern[:extra_capture]
                extra = pattern[:extra_capture]
                extra_amount = match[extra[:index]].delete(',').to_i
                extra_amount = -extra_amount if extra[:sign] == :negative
                LootTracker.record_transaction(amount: extra_amount, category: extra[:category])
                log("#{name}: #{extra[:category]} #{extra_amount > 0 ? '+' : ''}#{extra_amount}")
              end
            end

            break  # Only match one pattern per line
          end
        end
      end
    end

    # Processes klock (special key/lock) events
    class KlockProcessor < BaseProcessor
      KLOCK_PATTERN = /<a exist="(\d+)" noun="(key|lock)">(?:radiant|vibrant) (?:blood red|forest green|frosty white|royal blue|rainbow-hued) (key|lock)<\/a>/

      def self.process(chunk)
        chunk.each do |line|
          next unless (match = line.match(KLOCK_PATTERN))

          klock = { id: match[1], noun: match[2], name: match[0].match(/>([^<]+)</)[1] }

          log("Klock: #{klock[:name]}")

          LootTracker.record_klock(
            item_id: klock[:id],
            item_name: klock[:name]
          )
        end
      end
    end

    # Processes special find events (gemstone dust, feeder items, etc.)
    class SpecialFindProcessor < BaseProcessor
      # Gemstone dust (Duskruin, etc.)
      GEMSTONE_DUST = /You notice a scintillating mote of gemstone dust on the ground/

      # Feeder item notification (no item ID, just notification)
      FEEDER_ITEM = /\*\*\* A glint of light draws your attention to your latest find! \*\*\*/

      # Legendary item notification
      LEGENDARY_ITEM = /A prismatic display of color tints the air around you and arcs away, heralding your discovery of a legendary treasure!/

      # Gemstone jewel find (has item ID)
      GEMSTONE_JEWEL = /\*\* A glint of light catches your eye, and you notice an? <a exist="(\d+)" noun="(\w+)">([^<]+)<\/a> at your feet! \*\*/

      # Draconic idol find - captures creature_id (1) and item details (2,3,4)
      # Real: While rifling through <pushBold/>the <a exist="420754492" noun="mutant">mutant's</a><popBold/> belongings, you find a <a exist="420755239" noun="idol">silver-veined black draconic idol</a>...
      DRACONIC_IDOL = /rifling through.*<a exist="(\d+)" noun="[^"]+">[^<]+<\/a>.*belongings.*find a <a exist="(\d+)" noun="(\w+)">([^<]+)<\/a>/

      def self.process(chunk)
        chunk.each do |line|
          # Gemstone dust - no item ID, just count
          if line.match?(GEMSTONE_DUST)
            log("Special find: gemstone dust")
            LootTracker.record_special_find(item_name: 'gemstone dust', find_type: 'gemstone_dust')
            next
          end

          # Feeder item notification
          if line.match?(FEEDER_ITEM)
            log("Special find: feeder item notification")
            LootTracker.record_special_find(item_name: 'feeder item', find_type: 'feeder_item')
            next
          end

          # Legendary item notification
          if line.match?(LEGENDARY_ITEM)
            log("Special find: legendary item notification")
            LootTracker.record_special_find(item_name: 'legendary item', find_type: 'legendary_item')
            next
          end

          # Gemstone jewel with item details
          if (match = line.match(GEMSTONE_JEWEL))
            item = { id: match[1], noun: match[2], name: match[3] }
            log("Special find: gemstone jewel - #{item[:name]}")
            LootTracker.record_special_find(
              item_id: item[:id],
              item_name: item[:name],
              item_noun: item[:noun],
              find_type: 'gemstone_jewel'
            )
            next
          end

          # Draconic idol - captures creature_id and item details
          if (match = line.match(DRACONIC_IDOL))
            creature_id = match[1]
            item = { id: match[2], noun: match[3], name: match[4] }
            log("Special find: draconic idol - #{item[:name]} from creature #{creature_id}")
            LootTracker.record_special_find(
              item_id: item[:id],
              item_name: item[:name],
              item_noun: item[:noun],
              find_type: 'draconic_idol',
              source_id: creature_id
            )
            next
          end
        end
      end
    end

    # Processes bundle create and add events
    class BundleProcessor < BaseProcessor
      # First-person bundle create: "As you place your <skin> inside your <container>, you notice...
      # ...and carefully arrange the two <bundle> into a neat bundle."
      BUNDLE_CREATE = /As you place your <a exist="(\d+)" noun="([^"]+)">([^<]+)<\/a> inside your <a exist="(\d+)" noun="([^"]+)">([^<]+)<\/a>, you notice another.*?the two <a exist="(\d+)" noun="([^"]+)">([^<]+)<\/a> into a neat bundle/

      # First-person bundle add: "You carefully add your <skin> to your bundle of <bundle> inside your <container>."
      BUNDLE_ADD_SELF = /You carefully add your <a exist="(\d+)" noun="([^"]+)">([^<]+)<\/a> to your bundle of <a exist="(\d+)" noun="([^"]+)">([^<]+)<\/a> inside your <a exist="(\d+)" noun="([^"]+)">([^<]+)<\/a>/

      # Third-person bundle add (group members): "<player> carefully adds <pronoun> <skin> to <pronoun> bundle of <bundle>..."
      BUNDLE_ADD_OTHER = /<a exist="[^"]+" noun="[^"]+">[^<]+<\/a> carefully adds (?:<a exist="[^"]+" noun="[^"]+">[^<]+<\/a>|[a-z]+) <a exist="(\d+)" noun="([^"]+)">([^<]+)<\/a> to (?:<a exist="[^"]+" noun="[^"]+">[^<]+<\/a>|[a-z]+) bundle of <a exist="(\d+)" noun="([^"]+)">([^<]+)<\/a> inside (?:<a exist="[^"]+" noun="[^"]+">[^<]+<\/a>|[a-z]+) <a exist="(\d+)" noun="([^"]+)">([^<]+)<\/a>/

      def self.process(chunk)
        chunk.each do |line|
          # Bundle creation (first bundle from two skins)
          if (match = line.match(BUNDLE_CREATE))
            skin = { id: match[1], noun: match[2], name: match[3] }
            container = { id: match[4], noun: match[5], name: match[6] }
            bundle = { id: match[7], noun: match[8], name: match[9] }

            log("Bundle create: #{skin[:name]} -> bundle #{bundle[:name]} in #{container[:name]}")

            LootTracker.record_bundle_create(
              skin_id: skin[:id],
              skin_name: skin[:name],
              bundle_id: bundle[:id],
              bundle_name: bundle[:name],
              container_id: container[:id],
              container_name: container[:name]
            )
            next
          end

          # Self bundle add
          if (match = line.match(BUNDLE_ADD_SELF))
            skin = { id: match[1], noun: match[2], name: match[3] }
            bundle = { id: match[4], noun: match[5], name: match[6] }
            container = { id: match[7], noun: match[8], name: match[9] }

            log("Bundle add: #{skin[:name]} -> bundle #{bundle[:name]} in #{container[:name]}")

            LootTracker.record_bundle_add(
              skin_id: skin[:id],
              skin_name: skin[:name],
              bundle_id: bundle[:id],
              bundle_name: bundle[:name],
              container_id: container[:id],
              container_name: container[:name]
            )
            next
          end

          # Note: Third-person bundle adds (BUNDLE_ADD_OTHER) are intentionally not tracked
          # to avoid confusion from watching other players bundle their skins.
          # The pattern is kept for reference/future use if needed.
        end
      end
    end

    # Processes skin appraisal events (informational only)
    class AppraisalProcessor < BaseProcessor
      def self.process(chunk)
        joined = chunk.join("\n")

        # Gem appraisal - captures: item_id, noun, name, rarity, quality, value
        if (match = joined.match(Patterns::GEM_APPRAISE))
          item_id = match[1]
          item_noun = match[2]
          item_name = match[3]
          value = match[6].delete(',').to_i
          log("Gem appraisal: #{item_name} (#{item_id}) -> #{value} silvers")
          LootTracker.update_item_appraisal(item_id: item_id, value: value, item_name: item_name, item_noun: item_noun)
          return
        end

        # Single skin appraisal - captures: item_id, noun, name, quality, value
        if (match = joined.match(Patterns::SKIN_APPRAISE))
          item_id = match[1]
          item_noun = match[2]
          item_name = match[3]
          value = match[5].delete(',').to_i
          log("Skin appraisal: #{item_name} (#{item_id}) -> #{value} silvers")
          LootTracker.update_item_appraisal(item_id: item_id, value: value, item_name: item_name, item_noun: item_noun)
          return
        end

        # Bundle appraisal (quality breakdown + total value) - no individual item tracking
        if joined.match?(Patterns::SKIN_APPRAISE_BUNDLE_QUALITY)
          if (match = joined.match(Patterns::SKIN_APPRAISE_BUNDLE_VALUE))
            value = match[1].delete(',').to_i
            log("Bundle appraisal: ~#{value} silvers (not linked to individual items)")
          end
        end
      end
    end

    # Processes bard loresong value events (two-step: start caches item, value line applies it)
    class LoresongProcessor < BaseProcessor
      @pending_item = nil

      class << self
        attr_accessor :pending_item
      end

      def self.process(chunk)
        joined = chunk.join("\n")

        # Step 1: Cache item info from the "As you sing..." line
        if (match = joined.match(Patterns::LORESONG_START))
          @pending_item = {
            id: match[1],
            noun: match[2],
            name: match[3]
          }
          log("[LoresongProcessor] Cached: #{@pending_item[:name]} (#{@pending_item[:id]})") if LootTracker.debug?
        end

        # Step 2: Check for shatter BEFORE checking for value
        # Shatter happens during purification attempt - gem is destroyed
        if (match = joined.match(Patterns::GEM_SHATTER))
          shattered_item = {
            id: match[1],
            noun: match[2],
            name: match[3]
          }
          log("Shatter: #{shattered_item[:name]} (#{shattered_item[:id]}) shattered during purification!")
          LootTracker.record_gem_shatter(
            item_id: shattered_item[:id],
            item_name: shattered_item[:name],
            item_noun: shattered_item[:noun]
          )
          @pending_item = nil
          return
        end

        # Step 3: Apply value from the "it's worth about..." line
        if (match = joined.match(Patterns::LORESONG_VALUE_LINE)) && @pending_item
          value = match[1].delete(',').to_i
          log("Loresong: #{@pending_item[:name]} (#{@pending_item[:id]}) -> #{value} silvers")
          LootTracker.update_item_loresong(
            item_id: @pending_item[:id],
            value: value,
            item_name: @pending_item[:name],
            item_noun: @pending_item[:noun]
          )
          @pending_item = nil
        end
      end
    end

    # Processes shop appraisal events (value check without selling)
    # Two-step for pawn (multi-line), single-step for jeweler
    class ShopAppraisalProcessor < BaseProcessor
      @pending_item = nil

      class << self
        attr_accessor :pending_item
      end

      def self.process(chunk)
        joined = chunk.join("\n")

        # Jeweler single-line appraisal (ingots, etc.)
        if (match = joined.match(Patterns::SHOP_APPRAISE_JEWELER))
          item_id = match[1]
          item_noun = match[2]
          item_name = match[3]
          value = match[4].delete(',').to_i
          log("Shop appraisal: #{item_name} (#{item_id}) -> #{value} silvers")
          LootTracker.update_item_shop_appraisal(item_id: item_id, value: value, item_name: item_name, item_noun: item_noun)
          return
        end

        # Pawn "probably worth about" single-line format
        if (match = joined.match(Patterns::SHOP_APPRAISE_WORTH))
          item_id = match[1]
          item_noun = match[2]
          item_name = match[3]
          value = match[4].delete(',').to_i
          log("Shop appraisal: #{item_name} (#{item_id}) -> #{value} silvers")
          LootTracker.update_item_shop_appraisal(item_id: item_id, value: value, item_name: item_name, item_noun: item_noun)
          return
        end

        # Pawn multi-line: Step 1 - cache item from "turns the <item> over"
        if (match = joined.match(Patterns::SHOP_APPRAISE_START))
          @pending_item = {
            id: match[1],
            noun: match[2],
            name: match[3]
          }
          log("[ShopAppraisalProcessor] Cached: #{@pending_item[:name]} (#{@pending_item[:id]})") if LootTracker.debug?
        end

        # Pawn multi-line: Step 2 - apply value from "I'll give you X silver coins"
        if (match = joined.match(Patterns::SHOP_APPRAISE_VALUE)) && @pending_item
          value = match[1].delete(',').to_i
          log("Shop appraisal: #{@pending_item[:name]} (#{@pending_item[:id]}) -> #{value} silvers")
          LootTracker.update_item_shop_appraisal(
            item_id: @pending_item[:id],
            value: value,
            item_name: @pending_item[:name],
            item_noun: @pending_item[:noun]
          )
          @pending_item = nil
        end
      end
    end

    # Processes locksmith pool quote and confirmation events
    # Quote saves pending state, confirmation matches and records with box linkage
    class LocksmithProcessor < BaseProcessor
      def self.process(chunk)
        chunk.each do |line|
          # Phase 1: Pool quote - save pending drop info
          if (match = line.match(Patterns::BOX_POOL_QUOTE))
            box_id = match[1]
            box_noun = match[2]
            box_name = match[3]
            tip = match[4].delete(',').to_i
            fee = match[5].delete(',').to_i

            LootTracker.pending_pool_drop = {
              box_id: box_id,
              box_noun: box_noun,
              box_name: box_name,
              tip: tip,
              fee: fee,
              quoted_at: Time.now
            }
            log("Pool quote: #{box_name} (#{box_id}) tip=#{tip}, fee=#{fee}")
            next
          end

          # Phase 2: Pool confirmation - match pending and record
          if (match = line.match(Patterns::BOX_POOL_DROP_CONFIRM))
            box_noun = match[1]
            tip = match[2].delete(',').to_i
            fee = match[3].delete(',').to_i

            pending = LootTracker.pending_pool_drop
            if pending && pending[:box_noun] == box_noun && pending[:tip] == tip && pending[:fee] == fee
              # Match found - record with box linkage
              log("Pool confirm: #{pending[:box_name]} (#{pending[:box_id]}) tip=#{tip}, fee=#{fee}")
              LootTracker.record_pool_drop(
                box_id: pending[:box_id],
                box_name: pending[:box_name],
                tip: tip,
                fee: fee
              )
              LootTracker.pending_pool_drop = nil
            else
              # No match - record as unlinked transactions (fallback)
              log("Pool confirm (no match): tip=#{tip}, fee=#{fee}")
              LootTracker.record_transaction(amount: -fee, category: 'locksmith_fee')
              LootTracker.record_transaction(amount: -tip, category: 'locksmith_tip') if tip > 0
            end
          end
        end
      end
    end

    # Processes pawn/general item sell events
    # Real format: "Cendadric takes your <item>, glances at it briefly, then hands you X silver coins."
    class SellProcessor < BaseProcessor
      def self.process(chunk)
        pending_item = nil
        is_worthless = false

        chunk.each do |line|
          # Track item being offered - SELL_ITEM_TRIGGER captures: item_id, noun, name
          if (match = line.match(Patterns::SELL_ITEM_TRIGGER))
            pending_item = { id: match[1], noun: match[2], name: match[3] }
          end

          # Check for worthless/junk response
          if line.match?(Patterns::SELL_WORTHLESS) || line.match?(Patterns::SELL_JUNK)
            is_worthless = true
          end

          # Direct silver payment - SELL_RECEIVED_SILVER captures: item_id, noun, name, amount
          if (match = line.match(Patterns::SELL_RECEIVED_SILVER))
            item_id = match[1]
            item_noun = match[2]
            item_name = match[3]
            amount = match[4].delete(',').to_i

            # Update item as sold and get loot_items.id for linking
            loot_item_id = LootTracker.update_item_sold(
              item_id: item_id, value: amount, category: 'pawn_sale',
              item_name: item_name, item_noun: item_noun
            )

            log("Pawn sale: #{item_name} (#{item_id}) -> +#{amount} silvers")
            LootTracker.record_transaction(amount: amount, category: 'pawn_sale', metadata: item_name, loot_item_id: loot_item_id)
            pending_item = nil  # Clear pending since we got a result
          end

          # Note/chit payment - use pending_item's id for linking if available
          # SELL_RECEIVED_NOTE captures: note_id, note_noun, note_name, amount (these are the NOTE, not the sold item)
          if (match = line.match(Patterns::SELL_RECEIVED_NOTE))
            amount = match[4].delete(',').to_i
            loot_item_id = nil

            # If we have a pending item from the offer, use that for linking
            if pending_item
              loot_item_id = LootTracker.update_item_sold(
                item_id: pending_item[:id], value: amount, category: 'pawn_sale',
                item_name: pending_item[:name], item_noun: pending_item[:noun]
              )
              log("Pawn sale (note): #{pending_item[:name]} (#{pending_item[:id]}) -> +#{amount} silvers")
            else
              log("Pawn sale (note): +#{amount} silvers (no item to link)")
            end

            LootTracker.record_transaction(amount: amount, category: 'pawn_sale', metadata: pending_item&.[](:name), loot_item_id: loot_item_id)
            pending_item = nil  # Clear pending since we got a result
          end
        end

        # Handle worthless item (0 value sale)
        if is_worthless && pending_item
          # Update item as sold with 0 value
          loot_item_id = LootTracker.update_item_sold(
            item_id: pending_item[:id], value: 0, category: 'pawn_sale',
            item_name: pending_item[:name], item_noun: pending_item[:noun]
          )

          log("Pawn sale (worthless): #{pending_item[:name]} (#{pending_item[:id]}) -> 0 silvers")
          LootTracker.record_transaction(amount: 0, category: 'pawn_sale', metadata: pending_item[:name], loot_item_id: loot_item_id)
        end
      end
    end

    # Processes gem shop sale events
    class GemshopProcessor < BaseProcessor
      @pending_ask = nil

      class << self
        attr_accessor :pending_ask
      end

      def self.process(chunk)
        chunk.each do |line|
          # Step 1: Cache item from "You ask X to buy/appraise" line
          if (match = line.match(Patterns::GEMSHOP_ASK))
            @pending_ask = {
              id: match[1],
              noun: match[2],
              name: match[3]
            }
            log("[GemshopProcessor] Cached ask: #{@pending_ask[:name]} (#{@pending_ask[:id]})") if LootTracker.debug?
          end

          # Step 2: Detect rejection - "not buying anything this valuable"
          # Marks item with 25k pawn cap value for loot cap estimation
          if line.match?(Patterns::GEMSHOP_REJECT) && @pending_ask
            log("Gem shop rejection: #{@pending_ask[:name]} (#{@pending_ask[:id]}) - too valuable (25k pawn cap)")
            LootTracker.record_gemshop_rejection(
              item_id: @pending_ask[:id],
              item_name: @pending_ask[:name],
              item_noun: @pending_ask[:noun]
            )
            @pending_ask = nil
            next
          end

          # Individual gem sale - GEMSHOP_SELL captures: item_id, noun, name, amount
          # Clear pending_ask on successful sale (same item or different)
          if (match = line.match(Patterns::GEMSHOP_SELL))
            @pending_ask = nil
            item_id = match[1]
            item_noun = match[2]
            item_name = match[3]
            amount = match[4].delete(',').to_i

            # Update item as sold and get loot_items.id for linking (with name fallback for ID mismatches)
            loot_item_id = LootTracker.update_item_sold(
              item_id: item_id, value: amount, category: 'gem_sale',
              item_name: item_name, item_noun: item_noun
            )

            log("Gem sale: #{item_name} (#{item_id}) -> +#{amount} silvers")
            LootTracker.record_transaction(amount: amount, category: 'gem_sale', metadata: item_name, loot_item_id: loot_item_id)
          end

          # Individual gem sale paid via bank note (when gemcutter doesn't have enough silver)
          # GEMSHOP_SELL_NOTE captures: item_id, noun, name, amount
          if (match = line.match(Patterns::GEMSHOP_SELL_NOTE))
            item_id = match[1]
            item_noun = match[2]
            item_name = match[3]
            amount = match[4].delete(',').to_i

            loot_item_id = LootTracker.update_item_sold(
              item_id: item_id, value: amount, category: 'gem_sale',
              item_name: item_name, item_noun: item_noun
            )

            log("Gem sale (note): #{item_name} (#{item_id}) -> +#{amount} silvers")
            LootTracker.record_transaction(amount: amount, category: 'gem_sale', metadata: item_name, loot_item_id: loot_item_id)
          end

          # Bulk gem sale - no individual item tracking
          if (match = line.match(Patterns::GEMSHOP_BULK_SELL))
            amount = match[1].delete(',').to_i
            log("Bulk gem sale: +#{amount} silvers (not linked to items)")
            LootTracker.record_transaction(amount: amount, category: 'gem_sale', subcategory: 'bulk')
          end

          # Bulk gem sale with chit (for large amounts) - no individual item tracking
          if (match = line.match(Patterns::GEMSHOP_BULK_SELL_CHIT))
            amount = match[1].delete(',').to_i
            log("Bulk gem sale (chit): +#{amount} silvers (not linked to items)")
            LootTracker.record_transaction(amount: amount, category: 'gem_sale', subcategory: 'bulk_chit')
          end
        end
      end
    end

    # Processes furrier sale events
    class FurrierProcessor < BaseProcessor
      def self.process(chunk)
        chunk.each do |line|
          # Individual skin sale - SKIN_SELL captures: npc_name, item_id, noun, name, amount
          if (match = line.match(Patterns::SKIN_SELL))
            item_id = match[2]
            item_name = match[4]
            amount = match[5].delete(',').to_i

            # Update item as sold and get loot_items.id for linking
            loot_item_id = LootTracker.update_item_sold(item_id: item_id, value: amount, category: 'furrier_sale')

            log("Furrier sale: #{item_name} (#{item_id}) -> +#{amount} silvers")
            LootTracker.record_transaction(amount: amount, category: 'furrier_sale', metadata: item_name, loot_item_id: loot_item_id)
          end

          # Bulk skin sale - no individual item tracking
          if (match = line.match(Patterns::SKIN_SELL_BULK))
            amount = match[2].delete(',').to_i
            log("Bulk furrier sale: +#{amount} silvers (not linked to items)")
            LootTracker.record_transaction(amount: amount, category: 'furrier_sale', subcategory: 'bulk')
          end
        end
      end
    end

    # Processes bank deposit/withdrawal events
    class BankProcessor < BaseProcessor
      def self.process(chunk)
        chunk.each do |line|
          # Silver deposit
          if (match = line.match(Patterns::SILVER_DEPOSIT))
            amount = match[1].delete(',').to_i
            log("Bank deposit: +#{amount} silvers")
            LootTracker.record_transaction(amount: amount, category: 'bank_deposit')
          end

          # Silver withdrawal
          if (match = line.match(Patterns::SILVER_WITHDRAW))
            amount = match[1].delete(',').to_i
            log("Bank withdrawal: -#{amount} silvers")
            LootTracker.record_transaction(amount: -amount, category: 'bank_withdrawal')
          end

          # Note deposit
          if (match = line.match(Patterns::NOTE_DEPOSIT))
            amount = match[1].delete(',').to_i
            log("Note deposit: +#{amount} silvers")
            LootTracker.record_transaction(amount: amount, category: 'note_deposit')
          end
        end
      end
    end

    # Processes bounty reward events
    class BountyProcessor < BaseProcessor
      def self.process(chunk)
        chunk.each do |line|
          next unless (match = line.match(Patterns::BOUNTY_REWARD))

          bp = match[1].delete(',').to_i
          xp = match[2].delete(',').to_i
          silver = match[3].delete(',').to_i

          log("Bounty reward: #{bp} BP, #{xp} XP, #{silver} silvers")

          LootTracker.record_bounty(
            bounty_points: bp,
            experience: xp,
            silver: silver
          )
        end
      end
    end

    # Processes chronomage ring turn-in events (gold rings for travel credit)
    class ChronomageProcessor < BaseProcessor
      # Each gold ring is worth 5,000 silvers credit
      RING_VALUE = 5_000

      def self.process(chunk)
        chunk.each do |line|
          next unless (match = line.match(Patterns::CHRONOMAGE_RING))

          item_id = match[1]
          noun = match[2]
          name = match[3]
          credit = match[4].delete(',').to_i

          log("Chronomage ring: #{name} (#{item_id}) -> #{credit} credit")

          LootTracker.record_chronomage_ring(
            item_id: item_id,
            noun: noun,
            name: name,
            credit_value: credit
          )
        end
      end
    end

    # Processes wand duplication (918 spell) events
    class WandDupeProcessor < BaseProcessor
      def self.process(chunk)
        joined = chunk.join("\n")

        # Must have success trigger
        return unless joined.match?(Patterns::WAND_DUPE_TRIGGER)

        # Extract donor wand from gesture line
        donor_match = joined.match(Patterns::WAND_DUPE_GESTURE)
        return unless donor_match

        donor = {
          id: donor_match[1],
          noun: donor_match[2],
          name: donor_match[3]
        }

        # Extract new wand from first line (either hand)
        new_wand = nil
        chunk.each do |line|
          if (hand_match = line.match(Patterns::WAND_IN_HAND))
            new_wand = {
              id: hand_match[1],
              noun: hand_match[2],
              name: hand_match[3]
            }
            break
          end
        end
        return unless new_wand

        log("Wand dupe: #{donor[:name]} (#{donor[:id]}) -> #{new_wand[:name]} (#{new_wand[:id]})")
        LootTracker.record_wand_dupe(donor: donor, copy: new_wand)
      end
    end
  end

  # ===== Hook Management =====
  class << self
    def add_downstream_hook
      @hook_id = 'LootTracker::downstream'

      hook_proc = proc do |server_string|
        @buffer << server_string

        # Slice on prompt (natural game action boundary)
        if server_string.include?('<prompt time=')
          chunk = @buffer.slice!(0, @buffer.size)

          # Quick filter - only queue if contains trigger pattern
          if chunk.any? { |line| Patterns.trigger_match?(line) }
            @queue.push(chunk)
            log("[Hook] Queued chunk (#{chunk.size} lines)") if debug?
          end
        end

        # Overflow protection
        if @buffer.size > MAX_BUFFER_SIZE
          @buffer.shift(@buffer.size - MAX_BUFFER_SIZE)
        end

        server_string  # Pass through unchanged
      end

      DownstreamHook.add(@hook_id, hook_proc)
      log("Downstream hook installed")
    end

    def remove_downstream_hook
      return unless @hook_id

      DownstreamHook.remove(@hook_id)
      @hook_id = nil
      log("Downstream hook removed")
    end

    def add_upstream_hook
      @upstream_hook_id = 'LootTracker::upstream'

      hook_proc = proc do |client_string|
        if client_string =~ /^(?:<c>)?;(?:loottracker|lt)\s*(.*)/i
          cmd = $1.strip
          @command_queue.push(cmd)
          nil  # Consume the command
        else
          client_string  # Pass through
        end
      end

      UpstreamHook.add(@upstream_hook_id, hook_proc)
      log("Upstream hook installed")
    end

    def remove_upstream_hook
      return unless @upstream_hook_id

      UpstreamHook.remove(@upstream_hook_id)
      @upstream_hook_id = nil
      log("Upstream hook removed")
    end

    def remove_hooks
      remove_downstream_hook
      remove_upstream_hook
    end
  end

  # ===== API Methods =====
  class << self
    # Create a loot event (search or box_open)
    def create_event(event_type:, source_id:, source_name:, silvers: 0)
      now = Time.now
      events_table.insert(
        event_type: event_type,
        source_id: source_id,
        source_name: source_name,
        silvers_found: silvers || 0,
        character: current_character,
        game: current_game,
        room_id: current_room_id,
        room_uid: current_room_uid,
        created_at: now
      )
    end

    # Create a skin event
    def create_skin_event(creature_id:, creature_name:)
      now = Time.now
      skin_events_table.insert(
        creature_id: creature_id,
        creature_name: creature_name,
        character: current_character,
        game: current_game,
        created_at: now
      )
    end

    # Create a loot item record
    # searcher: optional override for item attribution (default: current_character)
    def create_item(item_id:, item_name:, item_noun: nil, item_type: nil, item_source:, event_id: nil, skin_event_id: nil, searcher: nil)
      now = Time.now
      begin
        items_table.insert(
          item_id: item_id,
          item_name: item_name,
          item_noun: item_noun,
          item_type: item_type,
          item_source: item_source,
          event_id: event_id,
          skin_event_id: skin_event_id,
          searcher: searcher || current_character,
          game: current_game,
          created_at: now
        )
      rescue Sequel::UniqueConstraintViolation
        log("Item already exists: #{item_id}/#{item_noun}") if debug?
      end
    end

    # Record a creature search event
    def record_search(creature_id:, creature_name:, silvers:, items:)
      return unless @enabled

      event_id = create_event(
        event_type: "search",
        source_id: creature_id.to_s,
        source_name: creature_name,
        silvers: silvers
      )

      items.each do |item|
        create_item(
          item_id: item[:id],
          item_name: item[:name],
          item_noun: item[:noun],
          item_type: classify_item(item[:id]),
          item_source: "search",
          event_id: event_id
        )
      end

      log("Recorded search: #{creature_name} -> #{silvers || 0} silvers, #{items.size} items") if debug?
      event_id
    end

    # Record a skinning event
    def record_skin(creature_id:, creature_name:, item_id:, item_name:, item_noun: nil)
      return unless @enabled

      skin_event_id = create_skin_event(
        creature_id: creature_id.to_s,
        creature_name: creature_name
      )

      create_item(
        item_id: item_id,
        item_name: item_name,
        item_noun: item_noun,
        item_type: "skin",
        item_source: "skin",
        skin_event_id: skin_event_id
      )

      log("Recorded skin: #{item_name} from #{creature_name}") if debug?
      skin_event_id
    end

    # Record a box opening event
    # loot_item_id: optional - if provided, directly links to that loot_item record (avoids re-search)
    def record_box_open(box_id:, box_name:, silvers:, items:, loot_item_id: nil)
      return unless @enabled

      # CRITICAL: Never record an empty box - boxes from creatures always have contents
      # If we see an empty box (no items AND no silver), it was already opened/emptied
      if items.empty? && silvers.to_i.zero?
        log("Box OPEN: Skipping empty box #{box_id} - already opened/emptied") if debug?
        return
      end

      game = current_game

      # CRITICAL: Find the original box record FIRST to get the original searcher
      # Box contents should be attributed to whoever FOUND the box, not who opened it
      box_item = nil
      original_searcher = nil

      if loot_item_id
        # Direct lookup if ID provided (from LOOK IN)
        box_item = items_table.where(id: loot_item_id).first
      elsif (linked_item_id = (@pending_pool_returns ||= {})[box_id])
        # Check pending pool returns (don't delete yet - we'll do that after linking)
        box_item = items_table.where(id: linked_item_id).first
      else
        # Fall back to name-based search (FIFO) - same logic as link_box_to_open_event
        box_item = items_table
          .where(item_type: 'box', game: game)
          .where(opened_at: nil)
          .where(Sequel.ilike(:item_name, "%#{box_name}%"))
          .order(Sequel.asc(:created_at))
          .first
      end

      # Get original searcher from box record, fall back to current character
      original_searcher = box_item&.[](:searcher) || current_character

      event_id = create_event(
        event_type: "box_open",
        source_id: box_id.to_s,
        source_name: box_name,
        silvers: silvers
      )

      # Create items with original searcher attribution (not the opener)
      items.each do |item|
        create_item(
          item_id: item[:id],
          item_name: item[:name],
          item_noun: item[:noun],
          item_type: classify_item(item[:id]),
          item_source: "box",
          event_id: event_id,
          searcher: original_searcher
        )
      end

      # Link the box record to this open event
      if box_item
        items_table.where(id: box_item[:id]).update(
          opened_at: Time.now,
          opened_event_id: event_id,
          item_id: box_id.to_s
        )
        # Clean up pending pool return if that's how we found it
        (@pending_pool_returns ||= {}).delete(box_id)
        log("Linked box '#{box_name}' (item ##{box_item[:id]}) to open event ##{event_id}, searcher: #{original_searcher}") if debug?
      else
        log("No box record found for '#{box_name}' - items attributed to opener: #{original_searcher}") if debug?
      end

      log("Recorded box: #{box_name} -> #{silvers || 0} silvers, #{items.size} items") if debug?
      event_id
    end

    # Find an unopened box loot_item by name (FIFO) and link it to the box_open event.
    # This handles the locksmith pool case where the box ID changes.
    # Cross-character: any character can open a box found by another - links back to original searcher
    def link_box_to_open_event(box_name:, box_id:, opened_event_id:)
      game = current_game

      # Find the oldest unopened box with matching name (any searcher)
      # Uses partial match because LOOK IN shows shortened name (e.g., "maoral chest")
      # but database has full name (e.g., "copper-edged maoral chest")
      box_item = items_table
        .where(item_type: 'box', game: game)
        .where(opened_at: nil)
        .where(Sequel.ilike(:item_name, "%#{box_name}%"))
        .order(Sequel.asc(:created_at))
        .first

      if box_item
        items_table.where(id: box_item[:id]).update(
          opened_at: Time.now,
          opened_event_id: opened_event_id,
          item_id: box_id.to_s
        )
        log("Linked box '#{box_name}' (item ##{box_item[:id]}) to open event ##{opened_event_id}") if debug?
        true
      else
        log("No unopened box found matching '#{box_name}'") if debug?
        false
      end
    end

    # Mark a box as lost (died, decayed, etc.)
    # Accepts a DB record ID or item name (partial match)
    # Returns the item record if found and marked, nil otherwise
    def mark_box_lost(identifier)
      return nil unless @enabled

      game = current_game

      # Try numeric ID first (DB record ID)
      if identifier.to_s =~ /^\d+$/
        item = items_table.where(id: identifier.to_i, item_type: 'box', game: game).first
      end

      # Fall back to name match (most recent unopened box)
      unless item
        item = items_table
          .where(item_type: 'box', game: game, opened_at: nil, lost_at: nil)
          .where(Sequel.ilike(:item_name, "%#{identifier}%"))
          .order(Sequel.desc(:created_at))
          .first
      end

      return nil unless item

      items_table.where(id: item[:id]).update(lost_at: Time.now)
      log("Marked box as lost: #{item[:item_name]} (##{item[:id]})")
      item
    end

    # Find an unopened box by name (for LOOK IN on wedged boxes)
    # Returns the box record if found, nil otherwise
    # Cross-character: matches any character's boxes in the same game
    # Uses partial match because LOOK IN shows shortened name (e.g., "maoral chest")
    # but database has full name (e.g., "copper-edged maoral chest")
    def find_unopened_box_by_name(box_name)
      items_table
        .where(item_type: 'box', game: current_game)
        .where(opened_at: nil, lost_at: nil)
        .where(Sequel.ilike(:item_name, "%#{box_name}%"))
        .order(Sequel.asc(:created_at))
        .first
    end

    # Find box with duplicate check for LOOK IN operations
    # Returns { box: box_record, duplicate: true/false }
    # - If exact ID match (unopened) found, returns that box
    # - Checks opened boxes (last 7 days) with matching name for exact item duplicates
    # - If duplicate found, returns { box: nil, duplicate: true }
    # - Otherwise returns first unopened name-matched box
    def find_box_with_duplicate_check(box_id, box_name, items)
      game = current_game

      # 1. Try exact ID match first (unopened, not lost)
      box = items_table
        .where(item_type: 'box', game: game, opened_at: nil, lost_at: nil, item_id: box_id.to_s)
        .first
      if box
        log("Box match: exact ID #{box_id} -> #{box[:item_name]} (##{box[:id]})") if debug?
        return { box: box, duplicate: false }
      end

      # 2. Check if exact ID + name exists but is already opened (avoid name fallback collision)
      opened_by_id = items_table
        .where(item_type: 'box', game: game, item_id: box_id.to_s)
        .where(Sequel.ilike(:item_name, "%#{box_name}%"))
        .exclude(opened_at: nil)
        .first
      if opened_by_id
        log("Box already opened: ID #{box_id} '#{opened_by_id[:item_name]}' (##{opened_by_id[:id]})") if debug?
        return { box: nil, duplicate: false, already_opened: opened_by_id }
      end

      # 3. Name search - get ALL matching boxes (opened and unopened)
      # Only fall back to name matching if ID lookup found nothing
      all_matches = items_table
        .where(item_type: 'box', game: game)
        .where(Sequel.ilike(:item_name, "%#{box_name}%"))
        .all

      # 4. Check opened boxes from last 7 days for exact duplicate (by contents)
      seven_days_ago = Time.now - (7 * 24 * 60 * 60)
      opened_matches = all_matches.select { |b| b[:opened_at] && b[:opened_at] > seven_days_ago }

      # Build signature from new items (name|noun sorted)
      new_sig = items.map { |i| "#{i[:name]}|#{i[:noun]}" }.sort

      opened_matches.each do |opened_box|
        next unless opened_box[:opened_event_id]

        box_items = items_table
          .where(event_id: opened_box[:opened_event_id], item_source: 'box')
          .all
        existing_sig = box_items.map { |i| "#{i[:item_name]}|#{i[:item_noun]}" }.sort

        if existing_sig == new_sig
          log("Duplicate detected: items match opened box ##{opened_box[:id]}") if debug?
          return { box: nil, duplicate: true }
        end
      end

      # 5. No duplicate - find first unopened match by name
      # Prefer same-character match first, then fall back to global FIFO
      character = current_character
      unopened = all_matches.select { |b| b[:opened_at].nil? && b[:lost_at].nil? }

      # 5a. Try same-character match first (FIFO within that character)
      same_char = unopened
        .select { |b| b[:searcher] == character }
        .sort_by { |b| b[:created_at] }
        .first

      if same_char
        log("Box match: same character '#{character}' -> #{same_char[:item_name]} (##{same_char[:id]})") if debug?
        return { box: same_char, duplicate: false }
      end

      # 5b. Fall back to global FIFO across all characters
      global = unopened
        .sort_by { |b| b[:created_at] }
        .first

      if global && debug?
        log("Box match: cross-character fallback '#{global[:searcher]}' -> #{global[:item_name]} (##{global[:id]})")
      end

      { box: global, duplicate: false }
    end

    # Record a box being dropped at the locksmith pool with fee/tip
    # Links to original loot_item by name (FIFO) and records transactions
    # Cross-character: any character can drop a box found by another - links back to original searcher
    def record_pool_drop(box_id:, box_name:, tip:, fee:)
      return unless @enabled

      game = current_game

      # 1. Try exact ID match first (most reliable)
      box_item = items_table
        .where(item_type: 'box', game: game)
        .where(pool_dropped_at: nil)
        .where(item_id: box_id.to_s)
        .first

      # 2. Fall back to name-based FIFO matching (for ID changes after locker storage)
      unless box_item
        box_item = items_table
          .where(item_type: 'box', game: game)
          .where(pool_dropped_at: nil)
          .where(Sequel.ilike(:item_name, box_name))
          .order(Sequel.asc(:created_at))
          .first
      end

      if box_item
        items_table.where(id: box_item[:id]).update(
          pool_dropped_at: Time.now,
          pool_room_uid: current_room_uid,
          pool_dropped_by: current_character,
          pool_fee: fee,
          pool_tip: tip
        )
        log("Pool drop: '#{box_name}' (item ##{box_item[:id]}) by=#{current_character} room=#{current_room_uid} fee=#{fee}, tip=#{tip}") if debug?
      else
        log("No box found matching '#{box_name}' for pool drop") if debug?
      end

      # Record transactions (linked or not, we still paid)
      record_transaction(amount: -fee, category: 'locksmith_fee')
      record_transaction(amount: -tip, category: 'locksmith_tip') if tip > 0
    end

    # Link a returned pool box (new ID) to the original loot_item record
    # Stores mapping so when the box is opened, we can link the event to the item
    def link_returned_pool_box(new_box_id:, box_name:)
      return unless @enabled

      game = current_game
      room = current_room_uid
      char = current_character

      # 1. Try to match by name + same room + same dropper (strongest match)
      box_item = nil
      if room
        box_item = items_table
          .where(item_type: 'box', game: game)
          .exclude(pool_dropped_at: nil)  # Was dropped at pool
          .where(opened_at: nil)           # Not yet opened
          .where(pool_room_uid: room)      # Same room as current
          .where(pool_dropped_by: char)    # Same character dropped it
          .where(Sequel.ilike(:item_name, "%#{box_name}%"))
          .order(Sequel.asc(:pool_dropped_at))
          .first
      end

      # 2. Try same room only (any dropper)
      if box_item.nil? && room
        box_item = items_table
          .where(item_type: 'box', game: game)
          .exclude(pool_dropped_at: nil)  # Was dropped at pool
          .where(opened_at: nil)           # Not yet opened
          .where(pool_room_uid: room)      # Same room as current
          .where(Sequel.ilike(:item_name, "%#{box_name}%"))
          .order(Sequel.asc(:pool_dropped_at))
          .first
      end

      # 3. Fall back to name-only match (any room, any dropper)
      # NOTE: Cross-character matching - any character can pick up a box that was searched by another
      # Items will count for whoever originally searched the creature
      box_item ||= items_table
        .where(item_type: 'box', game: game)
        .exclude(pool_dropped_at: nil)  # Was dropped at pool
        .where(opened_at: nil)           # Not yet opened
        .where(Sequel.ilike(:item_name, "%#{box_name}%"))
        .order(Sequel.asc(:pool_dropped_at))
        .first

      if box_item
        # Store mapping: when this new_box_id is opened, link to this loot_item
        @pending_pool_returns ||= {}
        @pending_pool_returns[new_box_id] = box_item[:id]
        log("Linked pool return: #{box_name} (new_id=#{new_box_id} -> item ##{box_item[:id]}, dropped_by=#{box_item[:pool_dropped_by]}, room=#{box_item[:pool_room_uid]})") if debug?
      else
        log("Pool return: No matching unretrieved box found for '#{box_name}'") if debug?
      end
    end

    # Update an existing box event with silver amount (from gather or charm)
    # Returns true if a matching box event was found and updated, false otherwise
    def update_box_silvers(box_id:, silvers:)
      return false unless @enabled

      # Find the most recent box_open event for this box_id
      box_event = events_table
        .where(source_id: box_id.to_s, event_type: 'box_open')
        .order(Sequel.desc(:created_at))
        .first

      if box_event
        events_table.where(id: box_event[:id]).update(silvers_found: silvers)
        log("Updated box #{box_id} silvers: #{silvers}") if debug?
        true
      else
        log("No box event found for #{box_id}") if debug?
        false
      end
    end

    # Record a klock (special key/lock) item
    def record_klock(item_id:, item_name:)
      return unless @enabled

      create_item(
        item_id: item_id,
        item_name: item_name,
        item_type: "klock",
        item_source: "search"
      )

      log("Recorded klock: #{item_name}") if debug?
    end

    # Record a special find (gemstone dust, feeder item, legendary, draconic idol, etc.)
    # source_id: optional creature GameObj ID to link item to search event
    def record_special_find(item_name:, find_type:, item_id: nil, item_noun: nil, source_id: nil)
      return unless @enabled

      # If source_id provided, find the search event for this creature to link the item
      event_id = nil
      if source_id
        search_event = events_table
          .where(source_id: source_id.to_s, event_type: 'search')
          .order(Sequel.desc(:created_at))
          .first
        event_id = search_event[:id] if search_event
      end

      if item_id
        create_item(
          item_id: item_id,
          item_name: item_name,
          item_noun: item_noun,
          item_type: find_type,
          item_source: "special_find",
          event_id: event_id
        )
      else
        # For items without ID (dust, notifications), just log to loot_items with a generated ID
        now = Time.now
        items_table.insert(
          item_id: "special_#{now.to_i}_#{rand(1000)}",
          item_name: item_name,
          item_type: find_type,
          item_source: "special_find",
          event_id: event_id,
          searcher: current_character,
          game: current_game,
          created_at: now
        )
      end

      log("Recorded special find: #{find_type} - #{item_name}#{source_id ? " (linked to creature #{source_id})" : ''}") if debug?
    end

    # Record a transaction (sale, bank, bounty, etc.)
    def record_transaction(amount:, category:, subcategory: nil, metadata: nil, loot_item_id: nil)
      return unless @enabled

      now = Time.now
      local = Time.now  # Keep local time for day/hour grouping
      transactions_table.insert(
        character: current_character,
        game: current_game,
        amount: amount,
        category: category,
        subcategory: subcategory,
        metadata: metadata,
        loot_item_id: loot_item_id,
        created_at: now,
        year: local.year,
        month: local.month,
        day: local.day,
        hour: local.hour
      )

      log("Recorded transaction: #{category} #{amount > 0 ? "+" : ""}#{amount}#{loot_item_id ? " (item ##{loot_item_id})" : ""}") if debug?
    end

    # Update an item's appraised value
    # Returns true if item was found and updated, false otherwise
    # Falls back to name-based FIFO matching if ID lookup fails (handles ID changes)
    def update_item_appraisal(item_id:, value:, item_name: nil, item_noun: nil)
      return false unless @enabled

      item = items_table.where(item_id: item_id.to_s, appraised_value: nil).first

      # Fallback: if ID not found and we have a name, try name-based FIFO matching
      if item.nil? && item_name
        game = current_game
        proxy = LootTracker.appraise_proxy

        if proxy
          # Proxy mode: MUST match proxy searcher's items
          item = items_table
            .where(game: game, searcher: proxy, appraised_value: nil)
            .where(Sequel.ilike(:item_name, "%#{item_name}%"))
            .order(Sequel.asc(:created_at))
            .first

          unless item
            log("ERROR: Appraise proxy '#{proxy}' - no item '#{item_name}' found for that searcher")
            return false
          end
        else
          # Normal mode: global FIFO
          item = items_table
            .where(game: game, appraised_value: nil)
            .where(Sequel.ilike(:item_name, "%#{item_name}%"))
            .order(Sequel.asc(:created_at))
            .first
        end

        if item
          # Update the item_id to the new ID so future lookups work
          old_id = item[:item_id]
          items_table.where(id: item[:id]).update(item_id: item_id.to_s)
          log("Appraisal fallback: '#{item_name}' matched item ##{item[:id]} (ID #{old_id} -> #{item_id})#{proxy ? " [proxy: #{proxy}]" : ''}") if debug?
        end
      end

      unless item
        # Check if item exists but is already appraised
        existing = items_table.where(item_id: item_id.to_s).first
        if existing && existing[:appraised_value]
          log("Appraisal: item #{item_id} '#{item_name}' already appraised (#{existing[:appraised_value]} silvers)") if debug?
        else
          log("Appraisal: item #{item_id} '#{item_name}' not found in loot_items") if debug?
        end
        return false
      end

      items_table.where(id: item[:id]).update(
        appraised_value: value,
        appraised_at: Time.now
      )

      log("Updated appraisal: item #{item_id} -> #{value} silvers") if debug?
      true
    end

    # Update an item's loresong value (bard appraisal)
    # Returns true if item was found and updated, false otherwise
    # Tracks pre-purify (loresong_value) and post-purify (loresong_value_2) values
    # - First loresong goes to loresong_value
    # - Second loresong goes to loresong_value_2 if it's higher (post-purify)
    def update_item_loresong(item_id:, value:, item_name: nil, item_noun: nil)
      return false unless @enabled

      item = items_table.where(item_id: item_id.to_s).first

      # Fallback: if ID not found and we have a name, try name-based FIFO matching
      if item.nil? && item_name
        game = current_game
        proxy = LootTracker.loresong_proxy

        if proxy
          # Proxy mode: MUST match proxy searcher's items
          item = items_table
            .where(game: game, searcher: proxy)
            .where(Sequel.ilike(:item_name, "%#{item_name}%"))
            .order(Sequel.asc(:created_at))
            .first

          unless item
            log("ERROR: Loresong proxy '#{proxy}' - no item '#{item_name}' found for that searcher")
            return false
          end
        else
          # Normal mode: global FIFO
          item = items_table
            .where(game: game)
            .where(Sequel.ilike(:item_name, "%#{item_name}%"))
            .order(Sequel.asc(:created_at))
            .first
        end

        if item
          # Update the item_id to the new ID so future lookups work
          old_id = item[:item_id]
          items_table.where(id: item[:id]).update(item_id: item_id.to_s)
          log("Loresong fallback: '#{item_name}' matched item ##{item[:id]} (ID #{old_id} -> #{item_id})#{proxy ? " [proxy: #{proxy}]" : ''}") if debug?
        end
      end

      unless item
        log("Loresong: item #{item_id} '#{item_name}' not found in loot_items") if debug?
        return false
      end

      existing_value = item[:loresong_value]

      if existing_value.nil?
        # First loresong - store in primary field
        items_table.where(id: item[:id]).update(
          loresong_value: value,
          loresong_at: Time.now
        )
        log("Updated loresong: item #{item_id} -> #{value} silvers (pre-purify)") if debug?
      elsif value > existing_value
        # Second loresong with higher value (post-purify) - store in secondary field
        items_table.where(id: item[:id]).update(
          loresong_value_2: value,
          loresong_at_2: Time.now
        )
        log("Updated loresong: item #{item_id} -> #{value} silvers (post-purify, was #{existing_value})") if debug?
      else
        log("Loresong: item #{item_id} value #{value} not higher than existing #{existing_value}, skipping") if debug?
      end

      true
    end

    # Update an item's shop appraisal value (pawn/jeweler appraisal without selling)
    # Used to track potential lootcap impact for items not sold
    def update_item_shop_appraisal(item_id:, value:, item_name: nil, item_noun: nil)
      return false unless @enabled

      item = items_table.where(item_id: item_id.to_s).first

      # Fallback: if ID not found and we have a name, try name-based FIFO matching
      if item.nil? && item_name
        game = current_game
        proxy = LootTracker.appraise_proxy

        if proxy
          # Proxy mode: MUST match proxy searcher's items
          item = items_table
            .where(game: game, searcher: proxy)
            .where(Sequel.ilike(:item_name, "%#{item_name}%"))
            .order(Sequel.asc(:created_at))
            .first

          unless item
            log("ERROR: Appraise proxy '#{proxy}' - no item '#{item_name}' found for that searcher")
            return false
          end
        else
          # Normal mode: global FIFO
          item = items_table
            .where(game: game)
            .where(Sequel.ilike(:item_name, "%#{item_name}%"))
            .order(Sequel.asc(:created_at))
            .first
        end

        if item
          # Update the item_id to the new ID so future lookups work
          old_id = item[:item_id]
          items_table.where(id: item[:id]).update(item_id: item_id.to_s)
          log("Shop appraisal fallback: '#{item_name}' matched item ##{item[:id]} (ID #{old_id} -> #{item_id})#{proxy ? " [proxy: #{proxy}]" : ''}") if debug?
        end
      end

      unless item
        log("Shop appraisal: item #{item_id} '#{item_name}' not found in loot_items") if debug?
        return false
      end

      # Only update if no existing shop appraisal (first appraisal wins)
      if item[:shop_appraisal].nil?
        # Capture bonuses at appraisal time for reverse-calculating loot cap value
        trading_bonus = LootTracker.calculate_trading_bonus
        racial_bonus = LootTracker.calculate_racial_bonus

        items_table.where(id: item[:id]).update(
          shop_appraisal: value,
          shop_appraised_at: Time.now,
          sold_trading_bonus: trading_bonus,
          sold_racial_bonus: racial_bonus
        )
        log("Updated shop appraisal: item #{item_id} -> #{value} silvers [trading=#{trading_bonus}%, racial=#{racial_bonus}%]") if debug?
      else
        log("Shop appraisal: item #{item_id} already has value #{item[:shop_appraisal]}, skipping") if debug?
      end

      true
    end

    # Update an item as sold and return its loot_items.id for transaction linking
    # Returns the loot_items.id if found and updated, nil otherwise
    # Falls back to name-based FIFO matching if ID lookup fails (handles ID changes)
    def update_item_sold(item_id:, value:, category:, item_name: nil, item_noun: nil)
      return nil unless @enabled

      item = items_table.where(item_id: item_id.to_s).first

      # Fallback: if ID not found and we have a name, try name-based FIFO matching
      if item.nil? && item_name
        game = current_game
        proxy = LootTracker.appraise_proxy
        item_type = category == 'gem_sale' ? 'gem' : nil

        query = items_table
          .where(game: game, sold_value: nil)
          .where(Sequel.ilike(:item_name, "%#{item_name}%"))
          .order(Sequel.asc(:created_at))

        # Proxy mode: restrict to proxy searcher's items
        query = query.where(searcher: proxy) if proxy

        query = query.where(item_type: item_type) if item_type

        # For gems: only match if appraise_value <= sell price (handles purified gems)
        if category == 'gem_sale'
          query = query.where(Sequel.lit('appraised_value IS NULL OR appraised_value <= ?', value))
        end

        item = query.first

        if proxy && item.nil?
          log("ERROR: Appraise proxy '#{proxy}' - no item '#{item_name}' found for that searcher")
          return nil
        end

        if item
          # Update the item_id to the new ID so future lookups work
          old_id = item[:item_id]
          items_table.where(id: item[:id]).update(item_id: item_id.to_s)
          log("Sale fallback: '#{item_name}' matched item ##{item[:id]} (ID #{old_id} -> #{item_id})#{proxy ? " [proxy: #{proxy}]" : ''}") if debug?
        end
      end

      # 3. No match - create orphan_sale item (unknown origin)
      unless item
        # Try GameObj first (uses gameobj-data.xml), fall back to noun/name classification
        item_type = classify_item(item_id)
        if item_type == 'other' && item_noun && item_name
          item_type = classify_by_noun_and_name(item_noun, item_name)
        end

        begin
          new_id = items_table.insert(
            item_id: item_id.to_s,
            item_name: item_name,
            item_noun: item_noun,
            item_type: item_type,
            item_source: 'orphan_sale',
            searcher: nil,  # Unknown origin - no loot cap estimate credit
            game: current_game,
            created_at: Time.now
          )
          item = items_table.where(id: new_id).first
          log("Orphan sale created: #{item_name} (#{item_type})") if debug?
        rescue Sequel::UniqueConstraintViolation
          # Item already exists with this ID - find it
          item = items_table.where(item_id: item_id.to_s, game: current_game).first
        end
      end

      return nil unless item

      # Capture sale location and bonuses for reverse-calculating estimated values
      location = LootTracker.current_location
      room = LootTracker.current_room_uid
      trading_bonus = LootTracker.calculate_trading_bonus
      racial_bonus = LootTracker.calculate_racial_bonus

      items_table.where(id: item[:id]).update(
        sold_value: value,
        sold_at: Time.now,
        sold_category: category,
        sold_location: location,
        sold_room_uid: room,
        sold_trading_bonus: trading_bonus,
        sold_racial_bonus: racial_bonus
      )

      log("Updated sale: item #{item_id} -> #{value} silvers (#{category}) [location=#{location}, room=#{room}, trading=#{trading_bonus}%, racial=#{racial_bonus}%]") if debug?
      item[:id]  # Return the loot_items.id for transaction linking
    end

    # Record a bounty reward
    def record_bounty(bounty_points: nil, experience: nil, silver: nil)
      return unless @enabled

      now = Time.now
      bounties_table.insert(
        bounty_points: bounty_points,
        experience: experience,
        silver: silver,
        character: current_character,
        game: current_game,
        created_at: now
      )

      if silver && silver > 0
        record_transaction(amount: silver, category: "bounty_silver")
      end

      log("Recorded bounty: #{bounty_points} BP, #{experience} XP, #{silver} silver") if debug?
    end

    # Record a gem shatter (failed purification)
    # Marks gem as shattered - counts toward loot cap estimate but realized value is 0
    def record_gem_shatter(item_id:, item_name:, item_noun:)
      return unless @enabled

      item = items_table.where(item_id: item_id.to_s, game: current_game).first

      # Fallback: name-based FIFO matching for items with stale IDs
      if item.nil? && item_name
        item = items_table
          .where(game: current_game, item_type: 'gem')
          .where(Sequel.ilike(:item_name, "%#{item_name}%"))
          .where(sold_value: nil, shattered_at: nil)
          .order(Sequel.asc(:created_at))
          .first

        if item
          old_id = item[:item_id]
          items_table.where(id: item[:id]).update(item_id: item_id.to_s)
          log("Shatter reconciled by name: #{item_name} (#{old_id} -> #{item_id})") if debug?
        end
      end

      if item
        items_table.where(id: item[:id]).update(
          sold_value: 0,
          sold_at: Time.now,
          sold_category: 'shattered',
          shattered_at: Time.now
        )
        log("Shatter: #{item_name} (#{item_id}) marked as shattered")
      else
        log("Shatter: #{item_name} (#{item_id}) NOT FOUND in database - may be untracked gem")
      end
    end

    # Record a gem shop rejection (item too valuable for gem shop)
    # Marks item with 25k pawn cap for loot cap estimation
    def record_gemshop_rejection(item_id:, item_name:, item_noun:)
      return unless @enabled

      item = items_table.where(item_id: item_id.to_s, game: current_game).first

      # Fallback: name-based FIFO matching for items with stale IDs
      if item.nil? && item_name
        item = items_table
          .where(game: current_game)
          .where(Sequel.ilike(:item_name, "%#{item_name}%"))
          .where(sold_value: nil, gemshop_rejected_at: nil)
          .order(Sequel.asc(:created_at))
          .first

        if item
          old_id = item[:item_id]
          items_table.where(id: item[:id]).update(item_id: item_id.to_s)
          log("Gemshop rejection reconciled by name: #{item_name} (#{old_id} -> #{item_id})") if debug?
        end
      end

      if item
        items_table.where(id: item[:id]).update(
          gemshop_rejected_at: Time.now,
          pawn_cap_value: PAWN_CAP_VALUE
        )
        log("Gemshop rejection: #{item_name} (#{item_id}) marked as too valuable (25k pawn cap)")
      else
        log("Gemshop rejection: #{item_name} (#{item_id}) NOT FOUND in database - may be untracked item")
      end
    end

    # Record a chronomage ring turn-in (gold rings for travel credit)
    # Each ring is worth 5,000 silvers credit, which counts toward loot cap
    CHRONOMAGE_RING_VALUE = 5_000

    def record_chronomage_ring(item_id:, noun:, name:, credit_value:)
      return unless @enabled

      now = Time.now
      character = current_character
      game = current_game

      # Try to find existing ring record (unlikely to be tracked, but check anyway)
      item = items_table.where(item_id: item_id.to_s, game: game).first

      if item
        # Ring was tracked - update with sold info
        items_table.where(id: item[:id]).update(
          sold_at: now,
          sold_to: 'chronomage',
          sold_value: credit_value
        )
        log("Chronomage ring: #{name} (#{item_id}) -> #{credit_value} credit (updated existing)")
      else
        # Ring not tracked - create record for loot cap tracking
        items_table.insert(
          item_id: item_id.to_s,
          item_name: name,
          item_noun: noun,
          item_type: 'ring',
          character: character,
          game: game,
          source_type: 'unknown',
          created_at: now,
          sold_at: now,
          sold_to: 'chronomage',
          sold_value: credit_value
        )
        log("Chronomage ring: #{name} (#{item_id}) -> #{credit_value} credit (new record)")
      end
    end

    # Record a wand duplication (918 spell) event
    def record_wand_dupe(donor:, copy:)
      return unless @enabled

      now = Time.now
      character = current_character
      game = current_game

      # Find or create donor wand record
      donor_item = items_table.where(item_id: donor[:id].to_s, game: game).first

      unless donor_item
        # Donor not previously tracked - create minimal record
        donor_item_id = items_table.insert(
          item_id: donor[:id].to_s,
          item_name: donor[:name],
          item_noun: donor[:noun],
          item_type: 'wand',
          item_source: 'wand_source',
          searcher: character,
          game: game,
          created_at: now
        )
        donor_item = items_table.where(id: donor_item_id).first
      end

      # Mark donor as duplicated
      items_table.where(id: donor_item[:id]).update(duplicated_at: now)

      # Create copy wand record
      begin
        items_table.insert(
          item_id: copy[:id].to_s,
          item_name: copy[:name],
          item_noun: copy[:noun],
          item_type: 'wand',
          item_source: 'wand_dupe',
          dupe_source_id: donor_item[:id],
          duplicated_at: now,
          searcher: donor_item[:searcher] || character,
          game: game,
          created_at: now
        )
        log("Recorded wand dupe: #{copy[:name]} from #{donor[:name]}") if debug?
      rescue Sequel::UniqueConstraintViolation
        log("Wand already exists: #{copy[:id]}") if debug?
      end
    end

    # Record a bundle creation event
    def record_bundle_create(skin_id:, skin_name:, bundle_id:, bundle_name:, container_id:, container_name:)
      return unless @enabled

      now = Time.now
      bundle_events_table.insert(
        event_type: 'bundle_create',
        skin_id: skin_id,
        skin_name: skin_name,
        bundle_id: bundle_id,
        bundle_name: bundle_name,
        container_id: container_id,
        container_name: container_name,
        character: current_character,
        game: current_game,
        created_at: now
      )

      log("Recorded bundle create: #{skin_name} -> #{bundle_name}") if debug?
    end

    # Record a bundle add event
    def record_bundle_add(skin_id:, skin_name:, bundle_id:, bundle_name:, container_id:, container_name:)
      return unless @enabled

      now = Time.now
      bundle_events_table.insert(
        event_type: 'bundle_add',
        skin_id: skin_id,
        skin_name: skin_name,
        bundle_id: bundle_id,
        bundle_name: bundle_name,
        container_id: container_id,
        container_name: container_name,
        character: current_character,
        game: current_game,
        created_at: now
      )

      log("Recorded bundle add: #{skin_name} -> #{bundle_name}") if debug?
    end

    # ===== Eastern Timezone Helpers =====
    # Loot cap resets on 1st of each month at midnight Eastern time

    # Returns the current Eastern timezone offset as a string.
    # Handles EST (-05:00) vs EDT (-04:00) based on US DST rules.
    #
    # @return [String] timezone offset like '-05:00' or '-04:00'
    def eastern_offset
      require 'tzinfo'
      tz = TZInfo::Timezone.get('America/New_York')
      offset_seconds = tz.current_period.offset.utc_total_offset
      hours, remainder = offset_seconds.abs.divmod(3600)
      minutes = remainder / 60
      sign = offset_seconds >= 0 ? '+' : '-'
      format('%s%02d:%02d', sign, hours, minutes)
    end

    # Returns the start of a calendar month in Eastern time, converted to local time.
    # Used for loot cap period boundaries.
    #
    # @param year [Integer, nil] year (defaults to current year in Eastern time)
    # @param month [Integer, nil] month 1-12 (defaults to current month in Eastern time)
    # @return [Time] midnight on 1st of month in Eastern time, as local time
    def month_start_eastern(year = nil, month = nil)
      offset = eastern_offset
      now_eastern = Time.now.getlocal(offset)
      year ||= now_eastern.year
      month ||= now_eastern.month

      Time.new(year, month, 1, 0, 0, 0, offset).getlocal
    end

    # Returns the start of the next month in Eastern time (exclusive end boundary).
    # Used with month_start_eastern for range queries: start <= x < end
    #
    # @param year [Integer] year
    # @param month [Integer] month 1-12
    # @return [Time] midnight on 1st of next month in Eastern time, as local time
    def month_end_eastern(year, month)
      offset = eastern_offset
      if month == 12
        Time.new(year + 1, 1, 1, 0, 0, 0, offset).getlocal
      else
        Time.new(year, month + 1, 1, 0, 0, 0, offset).getlocal
      end
    end

    # Returns the year and month for the previous calendar month.
    # Handles year rollover (January  December of previous year).
    #
    # @param year [Integer, nil] year (defaults to current year in Eastern time)
    # @param month [Integer, nil] month 1-12 (defaults to current month in Eastern time)
    # @return [Array<Integer, Integer>] [year, month] tuple
    def previous_month(year = nil, month = nil)
      offset = eastern_offset
      now_eastern = Time.now.getlocal(offset)
      year ||= now_eastern.year
      month ||= now_eastern.month

      if month == 1
        [year - 1, 12]
      else
        [year, month - 1]
      end
    end

    # Pattern to identify ingots by item name (currently only "gold ingot" exists)
    INGOT_PATTERN = /\b\w+\s+ingot\b/i

    # Classifies an item by its GameObj type, with special handling for ingots.
    # Ingots are classified separately from gems because they represent "delayed silver"
    # (found on corpses but sold for their silver value at gemshops).
    #
    # @param item_id [String, Integer] GameObj exist ID
    # @return [String] one of: 'gem', 'valuable', 'ingot', 'box', 'skin', 'wand', 'magic',
    #   'scroll', 'weapon', 'armor', 'jewelry', 'clothing', 'collectible', 'lockpick',

    #   'scarab', 'reagent', 'food', 'jar', 'boon', or 'junk'
    def classify_item(item_id)
      return "other" unless item_id && defined?(GameObj) && (obj = GameObj[item_id])

      # Check for ingot by name first (before gem classification)
      return "ingot" if obj.name&.match?(INGOT_PATTERN)

      case obj.type.to_s.downcase
      when "gem"
        "gem"
      when "valuable"
        "valuable"
      when "box"
        "box"
      when "skin"
        "skin"
      when "wand"
        "wand"
      when "magic"
        "magic"
      when "scroll"
        "scroll"
      when "weapon"
        "weapon"
      when "armor", "shield"
        "armor"
      when "jewelry"
        "jewelry"
      when "clothing"
        "clothing"
      when "collectible"
        "collectible"
      when "lockpick"
        "lockpick"
      when "scarab"
        "scarab"
      when "herb", "reagent"
        "reagent"
      when "food"
        "food"
      when "jar"
        "jar"
      when "boon"
        "boon"
      else
        # Fallback: classify by noun when GameObj.type isn't set (common for box contents)
        classify_by_noun(obj.noun)
      end
    end

    # Noun-based fallback classification for items where GameObj.type is nil/empty
    # This catches weapons/armor inside boxes where type info isn't populated
    WEAPON_NOUNS = %w[
      adze axe backsword bardiche bludgeon broadsword cestus claidhmore club crossbow
      cudgel dagger dart estoc falchion flail flamberge glaive greataxe greatsword
      halberd hammer handaxe harpoon hatchet javelin katana katar knife lance longsword
      mace maul mattock naginata pike quarterstaff rapier runestaff sabre scimitar
      spear staff sword trident voulge waraxe warblade whip yierka-spur yumi bow
    ].freeze

    ARMOR_NOUNS = %w[
      helm helmet greaves hauberk breastplate aventail armor leather leathers
      cuirass vambraces gauntlets pauldrons aegis shield buckler greatshield
    ].freeze

    # Wand nouns for explicit wand classification
    WAND_NOUNS = %w[wand rod baton].freeze

    # Valuable nouns - items that sell at gem shop but can't be purified
    VALUABLE_NOUNS = %w[nugget tusk].freeze

    # Lockpick nouns
    LOCKPICK_NOUNS = %w[lockpick].freeze

    # Gem nouns missing from gameobj-data.xml noun patterns
    # NOTE: shard, core, crystal are AMBIGUOUS - handled via partial name matching
    GEM_NOUNS = %w[duskjewel snowstone nightstone hoarstone kornerupine
                   glacialite titanite labradorite carnelian galena lichstone
                   snowdrop seaglass zoisite teardrop oligoclase citrine
                   spectrolite chrysoberyl bauxite mournstone firedrop
                   spruce chunk fang].freeze

    # Ambiguous nouns shared between gems and non-gems
    AMBIGUOUS_GEM_NOUNS = %w[shard core crystal].freeze

    # Gem-specific phrases for partial name matching (used with ambiguous nouns)
    GEM_PHRASES = [
      'glacial core',
      'ammolite shard',
      'cinnabar shard',
      'nephrite shard',
      'alexandrite shard',
      'shimmertine shard',
      'everfrost shard',
      'tigerfang crystal',
      'dragonmist crystal',
      'azurite crystal',
      'wulfenite crystal',
      'salt crystal',
      'sky blue crystal'
    ].freeze

    # Junk nouns (box components)
    JUNK_NOUNS = %w[spring].freeze

    # Classify by noun and name (for orphan sales where GameObj isn't available)
    def classify_by_noun_and_name(noun, name)
      return 'other' unless noun

      noun_lower = noun.to_s.downcase
      name_lower = name.to_s.downcase

      # Priority checks
      return 'wand' if WAND_NOUNS.include?(noun_lower)
      return 'valuable' if VALUABLE_NOUNS.include?(noun_lower)
      return 'lockpick' if LOCKPICK_NOUNS.include?(noun_lower)
      return 'box' if BOX_NOUNS.include?(noun_lower)
      return 'gem' if GEM_NOUNS.include?(noun_lower)
      return 'junk' if JUNK_NOUNS.include?(noun_lower)
      return 'ingot' if name_lower.match?(INGOT_PATTERN)

      # Partial name matching for ambiguous nouns
      if AMBIGUOUS_GEM_NOUNS.include?(noun_lower)
        return 'gem' if GEM_PHRASES.any? { |phrase| name_lower.include?(phrase) }
      end

      # Fallback to existing noun-based classification
      return 'weapon' if WEAPON_NOUNS.include?(noun_lower)
      return 'armor' if ARMOR_NOUNS.include?(noun_lower)

      'other'
    end

    def classify_by_noun(noun)
      return "junk" unless noun

      noun_lower = noun.to_s.downcase
      return "box" if BOX_NOUNS.include?(noun_lower)
      return "weapon" if WEAPON_NOUNS.include?(noun_lower)
      return "armor" if ARMOR_NOUNS.include?(noun_lower)
      return "wand" if WAND_NOUNS.include?(noun_lower)
      return "lockpick" if LOCKPICK_NOUNS.include?(noun_lower)

      "junk"
    end
  end

  # ===== Reports Module =====
  # Query methods returning raw data (hashes/arrays). No display logic.
  module Reports
    class << self
      # Core summary - returns hash of statistics for a time range
      def summary_for_range(start_time:, end_time: Time.now)
        character = LootTracker.current_character
        game = LootTracker.current_game

        # Base queries with time range
        events_base = LootTracker.events_table
                                 .where(character: character, game: game)
                                 .where { created_at >= start_time }
                                 .where { created_at < end_time }

        skin_events_base = LootTracker.skin_events_table
                                      .where(character: character, game: game)
                                      .where { created_at >= start_time }
                                      .where { created_at < end_time }

        items_base = LootTracker.items_table
                                .where(searcher: character, game: game)
                                .where { created_at >= start_time }
                                .where { created_at < end_time }

        transactions_base = LootTracker.transactions_table
                                       .where(character: character, game: game)
                                       .where { created_at >= start_time }
                                       .where { created_at < end_time }

        bounties_base = LootTracker.bounties_table
                                   .where(character: character, game: game)
                                   .where { created_at >= start_time }
                                   .where { created_at < end_time }

        {
          start_time: start_time,
          end_time: end_time,

          # Event counts
          search_count: events_base.where(event_type: 'search').count,
          box_count: events_base.where(event_type: 'box_open').count,
          skin_count: skin_events_base.count,

          # Silver totals from events
          silvers_search: events_base.where(event_type: 'search').sum(:silvers_found) || 0,
          silvers_boxes: events_base.where(event_type: 'box_open').sum(:silvers_found) || 0,

          # Item counts by type
          items_found: items_base.count,
          gems_found: items_base.where(item_type: 'gem').count,
          boxes_found: items_base.where(item_type: 'box').count,
          skins_found: items_base.where(item_type: 'skin').count,
          klocks_found: items_base.where(item_type: 'klock').count,
          magic_found: items_base.where(item_type: 'magic').count,
          other_found: items_base.where(item_type: 'other').count,

          # Transaction totals by category
          gem_sales: transactions_base.where(category: 'gem_sale').sum(:amount) || 0,
          pawn_sales: transactions_base.where(category: 'pawn_sale').sum(:amount) || 0,
          furrier_sales: transactions_base.where(category: 'furrier_sale').sum(:amount) || 0,
          locksmith_fees: transactions_base.where(category: 'locksmith_fee').sum(:amount) || 0,
          locksmith_tips: transactions_base.where(category: 'locksmith_tip').sum(:amount) || 0,
          bank_deposits: transactions_base.where(category: 'bank_deposit').sum(:amount) || 0,
          bank_withdrawals: transactions_base.where(category: 'bank_withdrawal').sum(:amount) || 0,
          bounty_silver: transactions_base.where(category: 'bounty_silver').sum(:amount) || 0,

          # Bounty totals
          bounty_points: bounties_base.sum(:bounty_points) || 0,
          bounty_experience: bounties_base.sum(:experience) || 0
        }
      end

      # Convenience: summary since midnight today
      def summary_today
        today = Date.today
        start_time = Time.new(today.year, today.month, today.day, 0, 0, 0)
        summary_for_range(start_time: start_time)
      end

      # Convenience: summary for last N hours
      def summary_last_hours(hours)
        start_time = Time.now - (hours * 3600)
        summary_for_range(start_time: start_time)
      end

      # Convenience: summary for current calendar month
      def summary_month
        today = Date.today
        start_time = Time.new(today.year, today.month, 1, 0, 0, 0)
        summary_for_range(start_time: start_time)
      end

      # ===== Loot Cap Report =====

      # Returns a loot cap summary for a calendar month.
      #
      # Loot cap tracks items entering the game (searches, skins, box contents, bounties)
      # rather than net income. The cap resets on the 1st of each month at midnight Eastern.
      #
      # @param year [Integer, nil] year (defaults to current year in Eastern time)
      # @param month [Integer, nil] month 1-12 (defaults to current month in Eastern time)
      # @return [Hash] summary with keys:
      #   - :year, :month, :start_time, :end_time - period info
      #   - :search_count, :boxes_found, :skin_count - event counts
      #   - :silvers_loose, :silvers_boxes, :bounty_silver - raw silver amounts
      #   - :items - Hash of item_type => { count:, estimated:, realized: }
      #   - :special_finds - count of special finds (dust, jewels, etc.)
      def loot_cap_summary(year: nil, month: nil)
        character = LootTracker.current_character
        game = LootTracker.current_game

        # Get Eastern time boundaries
        start_time = LootTracker.month_start_eastern(year, month)
        end_time = LootTracker.month_end_eastern(
          year || Time.now.getlocal(LootTracker.eastern_offset).year,
          month || Time.now.getlocal(LootTracker.eastern_offset).month
        )

        # Determine the actual year/month being queried
        offset = LootTracker.eastern_offset
        query_time = year && month ? Time.new(year, month, 15, 12, 0, 0, offset) : Time.now.getlocal(offset)
        query_year = query_time.year
        query_month = query_time.month

        # Base queries with time range
        events_base = LootTracker.events_table
                                 .where(character: character, game: game)
                                 .where { created_at >= start_time }
                                 .where { created_at < end_time }

        skin_events_base = LootTracker.skin_events_table
                                      .where(character: character, game: game)
                                      .where { created_at >= start_time }
                                      .where { created_at < end_time }

        items_base = LootTracker.items_table
                                .where(searcher: character, game: game)
                                .where { created_at >= start_time }
                                .where { created_at < end_time }

        bounties_base = LootTracker.bounties_table
                                   .where(character: character, game: game)
                                   .where { created_at >= start_time }
                                   .where { created_at < end_time }

        # Event counts
        search_count = events_base.where(event_type: 'search').count
        boxes_found = items_base.where(item_type: 'box').count
        boxes_lost = items_base.where(item_type: 'box').exclude(lost_at: nil).count
        skin_count = skin_events_base.count

        # Silver values (loose from searches, from boxes)
        silvers_loose = events_base.where(event_type: 'search').sum(:silvers_found) || 0
        silvers_boxes = events_base.where(event_type: 'box_open').sum(:silvers_found) || 0

        # Bounty silver
        bounty_silver = bounties_base.sum(:silver) || 0

        # Item values by type (excluding boxes themselves - they're containers, not loot value)
        # For loot cap: we want items from search, box, skin, special_find sources
        loot_items = items_base.where(item_source: %w[search box skin special_find])
                               .exclude(item_type: 'box')

        # Build item breakdown by type
        item_types = {}
        %w[gem valuable jewelry magic weapon armor skin clothing scroll collectible lockpick scarab reagent food jar boon klock junk].each do |type|
          type_items = loot_items.where(item_type: type)
          count = type_items.count
          next if count.zero?

          # Fetch items for estimated calculation (uses reverse bonus calc when no appraisal)
          items_arr = type_items.all
          estimated = CLI.sum_estimated_values(items_arr)
          realized = type_items.sum(:sold_value) || 0

          item_types[type] = {
            count: count,
            estimated: estimated,
            realized: realized
          }
        end

        # Wands need special handling:
        # - Estimated = sold value of searched wands only (no appraisal for wands)
        # - Realized = sold value of ALL wands (searched + duped)
        searched_wands = items_base.where(item_type: 'wand', item_source: 'search')
        all_wands = items_base.where(item_type: 'wand')
        searched_count = searched_wands.count
        duped_count = items_base.where(item_type: 'wand', item_source: 'wand_dupe').count
        total_wand_count = all_wands.count

        if total_wand_count > 0
          # Estimated = searched wands sold value minus trading/racial bonuses
          wand_estimated = CLI.sum_estimated_values(searched_wands.all)
          # Realized = all wands sold value (includes dupes)
          wand_realized = all_wands.sum(:sold_value) || 0

          item_types['wand'] = {
            count: total_wand_count,
            searched: searched_count,
            duped: duped_count,
            estimated: wand_estimated,
            realized: wand_realized
          }
        end

        # Special finds (gemstone_dust, etc.) - they're counted but have no sell value
        special_types = %w[gemstone_dust gemstone_jewel lte_boost feeder_item legendary_item draconic_idol]
        special_finds = items_base.where(item_type: special_types).count

        # Unsold items at pawn cap (too valuable to sell at shop)
        pawn_cap = LootTracker::PAWN_CAP_VALUE
        unsold_at_cap = loot_items
                          .where(sold_value: nil)
                          .where(
                            Sequel.|({ pawn_cap_value: pawn_cap }, Sequel.lit('shop_appraisal >= ?', pawn_cap))
                          )
                          .count

        {
          year: query_year,
          month: query_month,
          start_time: start_time,
          end_time: end_time,

          # Event counts
          search_count: search_count,
          boxes_found: boxes_found,
          boxes_lost: boxes_lost,
          skin_count: skin_count,

          # Raw silver (counts toward cap directly)
          silvers_loose: silvers_loose,
          silvers_boxes: silvers_boxes,
          bounty_silver: bounty_silver,

          # Item values by type
          items: item_types,
          special_finds: special_finds,
          unsold_at_cap: unsold_at_cap
        }
      end

      # Recent items query
      def recent_items(limit: 20, type: nil)
        character = LootTracker.current_character
        game = LootTracker.current_game

        query = LootTracker.items_table
                           .where(searcher: character, game: game)
                           .order(Sequel.desc(:created_at))
                           .limit(limit)

        query = query.where(item_type: type) if type
        query.all
      end

      # Recent boxes with silvers
      def recent_boxes(limit: 20)
        character = LootTracker.current_character
        game = LootTracker.current_game

        LootTracker.events_table
                   .where(event_type: 'box_open', character: character, game: game)
                   .order(Sequel.desc(:created_at))
                   .limit(limit)
                   .all
      end

      # Transaction breakdown by category
      def transactions_by_category(start_time: nil, end_time: nil)
        character = LootTracker.current_character
        game = LootTracker.current_game

        start_time ||= Time.now - 86400  # Default last 24h
        end_time ||= Time.now

        LootTracker.transactions_table
                   .where(character: character, game: game)
                   .where { created_at >= start_time }
                   .where { created_at < end_time }
                   .group(:category)
                   .select { [category, sum(amount).as(total), count.function.*.as(count)] }
                   .order(Sequel.desc(:total))
                   .all
      end

      # Creature profitability stats
      def creature_stats(limit: 10)
        character = LootTracker.current_character
        game = LootTracker.current_game

        # Last 24 hours by default
        start_time = Time.now - 86400

        LootTracker.events_table
                   .where(event_type: 'search', character: character, game: game)
                   .where { created_at >= start_time }
                   .group(:source_name)
                   .select { [source_name, count.function.*.as(kills), sum(silvers_found).as(silvers)] }
                   .order(Sequel.desc(:silvers))
                   .limit(limit)
                   .all
      end

      # Individual creature lookup by GameObj source_id
      def creature_lookup(source_id)
        character = LootTracker.current_character
        game = LootTracker.current_game

        # Find search event for this creature
        search_event = LootTracker.events_table
                                  .where(source_id: source_id, event_type: 'search', character: character, game: game)
                                  .first

        # Find skin event for this creature
        skin_event = LootTracker.skin_events_table
                                .where(creature_id: source_id, character: character, game: game)
                                .first

        # Get items from search
        search_items = search_event ? LootTracker.items_table.where(event_id: search_event[:id]).all : []

        # Get skin item if skinned
        skin_item = skin_event ? LootTracker.items_table.where(skin_event_id: skin_event[:id]).first : nil

        # For each box found, get its contents and fee info
        boxes_with_contents = search_items.select { |i| i[:item_type] == 'box' }.map do |box|
          box_contents = if box[:opened_event_id]
                           LootTracker.items_table
                                      .where(event_id: box[:opened_event_id])
                                      .all
                         else
                           []
                         end

          box_silvers = if box[:opened_event_id]
                          LootTracker.events_table
                                     .where(id: box[:opened_event_id])
                                     .get(:silvers_found) || 0
                        else
                          0
                        end

          {
            box: box,
            contents: box_contents,
            silvers: box_silvers
          }
        end

        {
          source_id: source_id,
          search_event: search_event,
          skin_event: skin_event,
          search_items: search_items.reject { |i| i[:item_type] == 'box' },
          skin_item: skin_item,
          boxes: boxes_with_contents
        }
      end

      # Individual box lookup by item_id or loot_items.id
      def box_lookup(box_identifier)
        character = LootTracker.current_character
        game = LootTracker.current_game

        # Try to find by item_id first (GameObj ID), then by record id
        box = LootTracker.items_table
                         .where(item_id: box_identifier, item_type: 'box', searcher: character, game: game)
                         .first

        box ||= LootTracker.items_table
                           .where(id: box_identifier.to_i, item_type: 'box', searcher: character, game: game)
                           .first

        return nil unless box

        # Get contents if opened
        contents = if box[:opened_event_id]
                     LootTracker.items_table
                                .where(event_id: box[:opened_event_id])
                                .all
                   else
                     []
                   end

        # Get silvers from box
        box_silvers = if box[:opened_event_id]
                        LootTracker.events_table
                                   .where(id: box[:opened_event_id])
                                   .get(:silvers_found) || 0
                      else
                        0
                      end

        # Get the search event that found this box
        search_event = box[:event_id] ? LootTracker.events_table.where(id: box[:event_id]).first : nil

        {
          box: box,
          contents: contents,
          silvers: box_silvers,
          search_event: search_event
        }
      end

      # Recent boxes with details for listing (includes IDs for drill-down)
      def recent_boxes_with_details(limit: 10)
        character = LootTracker.current_character
        game = LootTracker.current_game

        # Get recent boxes (opened or not) ordered by most recent first
        boxes = LootTracker.items_table
                           .where(item_type: 'box', searcher: character, game: game)
                           .order(Sequel.desc(:created_at))
                           .limit(limit)
                           .all

        boxes.map do |box|
          # Get silvers if opened
          box_silvers = if box[:opened_event_id]
                          LootTracker.events_table
                                     .where(id: box[:opened_event_id])
                                     .get(:silvers_found) || 0
                        else
                          0
                        end

          # Get source creature name
          source_name = if box[:event_id]
                          LootTracker.events_table
                                     .where(id: box[:event_id])
                                     .get(:source_name)
                        end

          # Count contents if opened
          contents_count = if box[:opened_event_id]
                             LootTracker.items_table
                                        .where(event_id: box[:opened_event_id])
                                        .count
                           else
                             0
                           end

          {
            box: box,
            silvers: box_silvers,
            source_name: source_name,
            contents_count: contents_count
          }
        end
      end
    end
  end

  # ===== CLI Module =====
  # Command parsing and formatted display
  module CLI
    class << self
      # Format silver amount with commas
      def format_silver(amount)
        amount.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse
      end

      # Calculate estimated value for an item (for lootcap purposes)
      # For gems: loresong (pre-purify) > appraised (gem estimate)
      # For non-gems: reverse-calc from sold value (remove trading/racial bonuses)
      #   BUT cap at PAWN_CAP_VALUE (25k) for items that are "too valuable"
      # @param item [Hash] item record with :item_type, :loresong_value, :appraised_value, :sold_value, etc.
      # @return [Integer, nil] estimated value or nil if no data available
      # Types where sold_value == estimated value (trading bonuses don't apply)
      NO_BONUS_TYPES = %w[ingot].freeze

      def calculate_estimated_value(item)
        pawn_cap = LootTracker::PAWN_CAP_VALUE

        # Ingots: trading bonuses don't affect sale price, so sold_value == estimated
        if NO_BONUS_TYPES.include?(item[:item_type])
          return item[:sold_value] || item[:shop_appraisal]
        elsif item[:item_type] == 'gem'
          # Gems: use loresong (pre-purify) or gem shop appraisal
          return item[:loresong_value] if item[:loresong_value]
          return item[:appraised_value] if item[:appraised_value]
        elsif item[:pawn_cap_value]
          # Gemshop rejected - use pawn cap value directly (no trading bonus applies)
          return item[:pawn_cap_value]
        elsif item[:shop_appraisal] && item[:sold_value].nil?
          # Non-gems with shop appraisal but not sold
          # If appraisal >= pawn cap, item is "too valuable" - cap at pawn cap
          return pawn_cap if item[:shop_appraisal] >= pawn_cap

          # Otherwise reverse-calc to remove trading/racial bonuses
          total_bonus = (item[:sold_trading_bonus] || 0) + (item[:sold_racial_bonus] || 0)
          return item[:shop_appraisal] if total_bonus.zero?

          return (item[:shop_appraisal] / (1 + total_bonus / 100.0)).round
        end

        # Fallback: reverse-calc from sold value (gems without loresong/appraisal, or sold non-gems)
        return nil unless item[:sold_value]

        # If sold at exactly pawn cap, item was "too valuable" for pawnshop - use cap as estimate
        # If sold ABOVE pawn cap, it was a gemshop sale - reverse-calc normally
        return pawn_cap if item[:sold_value] == pawn_cap

        # Otherwise reverse-calc to remove trading/racial bonuses
        total_bonus = (item[:sold_trading_bonus] || 0) + (item[:sold_racial_bonus] || 0)
        return item[:sold_value] if total_bonus.zero?

        (item[:sold_value] / (1 + total_bonus / 100.0)).round
      end

      # Sum estimated values for a collection of items
      # @param items [Array<Hash>] items to sum
      # @return [Integer] total estimated value
      def sum_estimated_values(items)
        items.sum { |item| calculate_estimated_value(item) || 0 }
      end

      # Format time for display
      def format_time(time)
        time.strftime("%m/%d %H:%M")
      end

      # Format item appraised/sold values for display
      # Returns a string like "Loresong: 800/1200  Appraised: 800  Sold: 1200 (gem_sale)" or empty if no values
      def format_item_values(item)
        parts = []

        if item[:loresong_value]
          lore_str = "Loresong: #{format_silver(item[:loresong_value])}"
          lore_str += "/#{format_silver(item[:loresong_value_2])}" if item[:loresong_value_2]
          parts << lore_str
        end

        if item[:appraised_value]
          parts << "Appraised: #{format_silver(item[:appraised_value])}"
        end

        if item[:sold_value]
          sold_str = "Sold: #{format_silver(item[:sold_value])}"
          sold_str += " (#{item[:sold_category]})" if item[:sold_category]
          parts << sold_str
        end

        parts.join("  ")
      end

      # Format single value for compact display (sold > loresong_2 > loresong > appraised)
      # @param item [Hash] item with value fields
      # @return [String] value string or empty if no values (S=sold, L2=loresong post-purify, L=loresong, A=appraised)
      def format_item_value_compact(item)
        if item[:sold_value]
          "#{format_silver(item[:sold_value]).rjust(6)} S"
        elsif item[:loresong_value_2]
          "#{format_silver(item[:loresong_value_2]).rjust(6)} L2"
        elsif item[:loresong_value]
          "#{format_silver(item[:loresong_value]).rjust(6)} L"
        elsif item[:appraised_value]
          "#{format_silver(item[:appraised_value]).rjust(6)} A"
        else
          ""
        end
      end

      # Format item row with aligned columns: name (type) [ID: xxx]
      # prefix: leading whitespace/bullet (e.g., "    - " or "  - ")
      def format_item_row(item, prefix)
        name = item[:item_name].to_s.ljust(38)
        type = "(#{item[:item_type]})".ljust(12)
        "#{prefix}#{name} #{type} [ID: #{item[:item_id]}]"
      end

      # Format box item on single line: [id]  name  (type)  value
      # @param item [Hash] item with :item_id, :item_name, :item_type, and value fields
      # @return [String] formatted line
      def format_box_item(item)
        id_str = "[#{item[:item_id]}]".ljust(14)
        name = item[:item_name].to_s.ljust(32)
        type = "(#{item[:item_type]})".ljust(10)
        value = format_item_value_compact(item)
        "  #{id_str} #{name} #{type} #{value}".rstrip
      end

      # Main command dispatcher
      def process(args)
        args = args.to_s.strip
        parts = args.split(/\s+/)
        command = parts.first&.downcase || ''
        rest = parts[1..-1] || []

        case command
        when '', 'summary'
          summary_command(rest)
        when 'cap', 'lootcap'
          cap_command(rest)
        when 'recent'
          recent_command(rest)
        when 'boxes'
          boxes_command(rest)
        when 'box'
          box_command(rest)
        when 'transactions', 'tx'
          transactions_command(rest)
        when 'creatures'
          creatures_command(rest)
        when 'creature'
          creature_command(rest)
        when 'status'
          show_status
        when 'wands'
          wands_command(rest)
        when 'proxy'
          proxy_command(rest)
        when 'lost'
          lost_command(rest)
        when 'debug'
          toggle_debug
        when 'help', '?'
          show_help
        else
          respond "Unknown command: #{command}. Type ';loottracker help' for usage."
        end
      end

      # Summary command handler
      def summary_command(args)
        period = args.first&.downcase

        summary, label = case period
                         when 'today', 'midnight'
                           [Reports.summary_today, 'Since Midnight']
                         when 'month', 'monthly'
                           [Reports.summary_month, 'Current Month']
                         when /^\d+$/
                           hours = period.to_i
                           [Reports.summary_last_hours(hours), "Last #{hours} Hours"]
                         else
                           [Reports.summary_last_hours(24), 'Last 24 Hours']
                         end

        show_summary(summary, label)
      end

      # Handles the ;lt cap command for loot cap reporting.
      #
      # @param args [Array<String>] command arguments:
      #   - empty or nil: current month
      #   - ['last'] or ['previous']: previous month
      #   - ['2025-12']: specific month in YYYY-MM format
      def cap_command(args)
        period = args.first&.downcase

        year = nil
        month = nil

        case period
        when 'last', 'previous', 'prev'
          year, month = LootTracker.previous_month
        when /^(\d{4})-(\d{1,2})$/
          # Specific month: 2025-12
          year = ::Regexp.last_match(1).to_i
          month = ::Regexp.last_match(2).to_i
        end

        data = Reports.loot_cap_summary(year: year, month: month)
        show_loot_cap(data)
      end

      # Recent items command handler
      # Type aliases for recent command
      unless defined?(RECENT_TYPE_ALIASES)
        RECENT_TYPE_ALIASES = {
          # Gems
          '--gems' => 'gem', '-g' => 'gem', 'gems' => 'gem', 'gem' => 'gem',
          # Boxes
          '--boxes' => 'box', '-b' => 'box', 'boxes' => 'box', 'box' => 'box',
          # Skins
          '--skins' => 'skin', '-s' => 'skin', 'skins' => 'skin', 'skin' => 'skin',
          # Klocks
          '--klocks' => 'klock', '-k' => 'klock', 'klocks' => 'klock', 'klock' => 'klock',
          # Magic items
          '--magic' => 'magic', '-m' => 'magic', 'magic' => 'magic',
          # Wands
          '--wands' => 'wand', '-w' => 'wand', 'wands' => 'wand', 'wand' => 'wand',
          # Weapons
          '--weapons' => 'weapon', 'weapons' => 'weapon', 'weapon' => 'weapon',
          # Armor
          '--armor' => 'armor', '-a' => 'armor', 'armor' => 'armor',
          # Jewelry
          '--jewelry' => 'jewelry', '-j' => 'jewelry', 'jewelry' => 'jewelry',
          # Clothing
          '--clothing' => 'clothing', 'clothing' => 'clothing',
          # Scrolls
          '--scrolls' => 'scroll', 'scrolls' => 'scroll', 'scroll' => 'scroll',
          # Valuables
          '--valuables' => 'valuable', '-v' => 'valuable', 'valuables' => 'valuable', 'valuable' => 'valuable',
          # Collectibles
          '--collectibles' => 'collectible', 'collectibles' => 'collectible', 'collectible' => 'collectible',
          # Lockpicks
          '--lockpicks' => 'lockpick', 'lockpicks' => 'lockpick', 'lockpick' => 'lockpick',
          # Scarabs
          '--scarabs' => 'scarab', 'scarabs' => 'scarab', 'scarab' => 'scarab',
          # Reagents
          '--reagents' => 'reagent', '-r' => 'reagent', 'reagents' => 'reagent', 'reagent' => 'reagent',
          # Food
          '--food' => 'food', 'food' => 'food',
          # Jars
          '--jars' => 'jar', 'jars' => 'jar', 'jar' => 'jar',
          # Boons
          '--boons' => 'boon', 'boons' => 'boon', 'boon' => 'boon',
          # Ingots
          '--ingots' => 'ingot', 'ingots' => 'ingot', 'ingot' => 'ingot',
          # Junk
          '--junk' => 'junk', 'junk' => 'junk',
          # Other (catch-all)
          '--other' => 'other', '-o' => 'other', 'other' => 'other'
        }.freeze
      end

      def recent_command(args)
        limit = 20
        type = nil

        args.each do |arg|
          case arg.downcase
          when /^\d+$/
            limit = arg.to_i
          else
            type = RECENT_TYPE_ALIASES[arg.downcase] if RECENT_TYPE_ALIASES.key?(arg.downcase)
          end
        end

        items = Reports.recent_items(limit: limit, type: type)
        show_recent_items(items, type)
      end

      # Boxes command handler
      def boxes_command(args)
        limit = args.first&.to_i || 20
        boxes = Reports.recent_boxes(limit: limit)
        show_recent_boxes(boxes)
      end

      # Transactions command handler
      def transactions_command(args)
        data = Reports.transactions_by_category
        show_transactions(data)
      end

      # Creatures command handler
      def creatures_command(args)
        limit = args.first&.to_i || 10
        stats = Reports.creature_stats(limit: limit)
        show_creatures(stats)
      end

      # Individual creature lookup command handler
      def creature_command(args)
        source_id = args.first
        unless source_id
          respond "Usage: ;loottracker creature <id>"
          respond "  Shows all loot from a specific creature by its GameObj ID."
          return
        end

        data = Reports.creature_lookup(source_id)
        show_creature_lookup(data)
      end

      # Box command handler - lists recent boxes OR shows individual box details
      def box_command(args)
        limit = 10
        box_id = nil

        args.each do |arg|
          case arg
          when /^--n=(\d+)$/
            limit = ::Regexp.last_match(1).to_i
          when /^-n$/
            # Next arg will be the number, handled by position
            next
          when /^\d+$/
            # Could be limit after -n, or a box ID
            # If previous arg was -n, treat as limit
            prev_idx = args.index(arg) - 1
            if prev_idx >= 0 && args[prev_idx] == '-n'
              limit = arg.to_i
            else
              box_id = arg
            end
          else
            # Non-numeric arg that's not an option - treat as box ID
            box_id = arg unless arg.start_with?('-')
          end
        end

        if box_id
          # Individual box lookup
          data = Reports.box_lookup(box_id)
          if data
            show_box_lookup(data)
          else
            respond "No box found with ID: #{box_id}"
          end
        else
          # List recent boxes with IDs for drilling down
          boxes = Reports.recent_boxes_with_details(limit: limit)
          show_box_list(boxes)
        end
      end

      # Display summary report
      def show_summary(summary, period_label)
        char = LootTracker.current_character
        game = LootTracker.current_game
        time_range = "#{format_time(summary[:start_time])} - #{format_time(summary[:end_time])}"

        silvers_looted = summary[:silvers_search] + summary[:silvers_boxes]
        sales_income = summary[:gem_sales] + summary[:pawn_sales] + summary[:furrier_sales]
        expenses = summary[:locksmith_fees] + summary[:locksmith_tips]
        net_income = silvers_looted + sales_income + summary[:bounty_silver] + expenses

        respond ""
        respond "LootTracker Summary for #{char} (#{game})"
        respond "Period: #{period_label} (#{time_range})"
        respond "-" * 55
        respond "  Searches:           #{summary[:search_count]}"
        respond "  Boxes Opened:       #{summary[:box_count]}"
        respond "  Skins:              #{summary[:skin_count]}"
        respond ""
        respond "  Silvers (Search):   #{format_silver(summary[:silvers_search])}"
        respond "  Silvers (Boxes):    #{format_silver(summary[:silvers_boxes])}"
        respond "  Silvers (Bounty):   #{format_silver(summary[:bounty_silver])}"
        respond "                      " + "-" * 12
        respond "  Total Silvers:      #{format_silver(silvers_looted + summary[:bounty_silver])}"
        respond ""
        respond "  Items Found:        #{summary[:items_found]}"
        respond "    Gems:             #{summary[:gems_found]}"
        respond "    Boxes:            #{summary[:boxes_found]}"
        respond "    Skins:            #{summary[:skins_found]}"
        respond "    Klocks:           #{summary[:klocks_found]}" if summary[:klocks_found] > 0
        respond "    Magic:            #{summary[:magic_found]}" if summary[:magic_found] > 0
        respond "    Other:            #{summary[:other_found]}" if summary[:other_found] > 0
        respond ""
        respond "  Sales Income:"
        respond "    Gem Sales:        #{format_silver(summary[:gem_sales])}"
        respond "    Pawn Sales:       #{format_silver(summary[:pawn_sales])}"
        respond "    Furrier Sales:    #{format_silver(summary[:furrier_sales])}"
        respond ""
        respond "  Expenses:"
        respond "    Locksmith Fees:   #{format_silver(summary[:locksmith_fees])}"
        respond "    Locksmith Tips:   #{format_silver(summary[:locksmith_tips])}"
        respond ""
        respond "  Bounty Rewards:"
        respond "    Points:           #{format_silver(summary[:bounty_points])}"
        respond "    Experience:       #{format_silver(summary[:bounty_experience])}"
        respond "-" * 55
        respond "  Net Income:         #{format_silver(net_income)}"
        respond ""
      end

      # Displays the loot cap report to the user.
      #
      # Shows event counts, silver totals, and item values with both
      # Estimated (appraised) and Realized (sold) columns. Includes
      # time until next cap reset for current month.
      #
      # @param data [Hash] loot cap summary from Reports.loot_cap_summary
      def show_loot_cap(data)
        char = LootTracker.current_character
        game = LootTracker.current_game

        # Format month name
        month_name = Date::MONTHNAMES[data[:month]]
        period_label = "#{month_name} #{data[:year]}"

        # Calculate reset time
        reset_time = data[:end_time].getlocal(LootTracker.eastern_offset)
        now_eastern = Time.now.getlocal(LootTracker.eastern_offset)

        # Check if this is current month or a past month
        is_current_month = (data[:year] == now_eastern.year && data[:month] == now_eastern.month)

        respond ""
        respond "LootTracker - Loot Cap Report for #{char} (#{game})"
        respond "Period: #{period_label} (Month-to-Date)" if is_current_month
        respond "Period: #{period_label}" unless is_current_month
        if is_current_month
          # Calculate time until reset
          seconds_until = (data[:end_time] - Time.now).to_i
          if seconds_until > 0
            days = seconds_until / 86400
            hours = (seconds_until % 86400) / 3600
            if days > 0
              respond "Reset: #{reset_time.strftime('%b %d, %Y %H:%M')} ET (in #{days}d #{hours}h)"
            else
              respond "Reset: #{reset_time.strftime('%b %d, %Y %H:%M')} ET (in #{hours}h)"
            end
          end
        end
        respond "=" * 65
        respond ""

        # Event counts
        respond "  EVENTS"
        respond "  " + "-" * 35
        respond "  Searches:             #{data[:search_count]}"
        respond "  Boxes Found:          #{data[:boxes_found]}"
        respond "  Boxes Lost:           #{data[:boxes_lost]}" if data[:boxes_lost] > 0
        respond "  Creatures Skinned:    #{data[:skin_count]}"
        respond ""

        # Loot cap values
        respond "  LOOT CAP VALUE                     Estimated    Realized"
        respond "  " + "-" * 60

        # Raw silvers (always same for estimated/realized)
        respond "  Silvers (loose):         #{format_silver(data[:silvers_loose]).rjust(12)}  #{format_silver(data[:silvers_loose]).rjust(11)}"
        respond "  Silvers (boxes):         #{format_silver(data[:silvers_boxes]).rjust(12)}  #{format_silver(data[:silvers_boxes]).rjust(11)}"

        # Ingots (no estimated, only realized)
        if data[:items][:ingot]
          ingot = data[:items][:ingot]
          respond "  Silvers (ingots):      #{'--'.rjust(12)}  #{format_silver(ingot[:realized]).rjust(11)}"
        end

        respond ""

        # Item types with estimated/realized values
        item_order = %w[gem valuable wand jewelry magic weapon armor skin clothing scroll collectible lockpick scarab reagent food jar boon klock ingot junk]
        item_labels = {
          'gem'         => 'Gems',
          'valuable'    => 'Valuables',
          'wand'        => 'Wands',
          'jewelry'     => 'Jewelry',
          'magic'       => 'Magic Items',
          'weapon'      => 'Weapons',
          'armor'       => 'Armor',
          'skin'        => 'Skins',
          'clothing'    => 'Clothing',
          'scroll'      => 'Scrolls',
          'collectible' => 'Collectibles',
          'lockpick'    => 'Lockpicks',
          'scarab'      => 'Scarabs',
          'reagent'     => 'Reagents',
          'food'        => 'Food',
          'jar'         => 'Jars',
          'boon'        => 'Boons',
          'klock'       => 'Klocks',
          'ingot'       => 'Ingots',
          'junk'        => 'Junk'
        }

        total_estimated = data[:silvers_loose] + data[:silvers_boxes] + data[:bounty_silver]
        total_realized = data[:silvers_loose] + data[:silvers_boxes] + data[:bounty_silver]

        item_order.each do |type|
          next unless data[:items][type]

          item = data[:items][type]
          label = "#{item_labels[type]} (#{item[:count]}):".ljust(24)

          est_str = item[:estimated] > 0 ? format_silver(item[:estimated]).rjust(12) : '--'.rjust(12)
          real_str = item[:realized] > 0 ? format_silver(item[:realized]).rjust(11) : '--'.rjust(11)

          respond "  #{label} #{est_str}  #{real_str}"

          total_estimated += item[:estimated]
          total_realized += item[:realized]
        end

        respond ""

        # Bounty silver
        respond "  Bounty Silver:           #{format_silver(data[:bounty_silver]).rjust(12)}  #{format_silver(data[:bounty_silver]).rjust(11)}"

        respond "  " + "-" * 60
        respond "  TOTAL LOOT CAP:          #{format_silver(total_estimated).rjust(12)}  #{format_silver(total_realized).rjust(11)}"
        respond "                           #{'(estimated)'.rjust(12)}  #{'(realized)'.rjust(11)}"

        if data[:unsold_at_cap] > 0
          pawn_cap = LootTracker::PAWN_CAP_VALUE
          cap_est = data[:unsold_at_cap] * pawn_cap
          label = "Unsold @ 25k (#{data[:unsold_at_cap]}):"
          respond ""
          respond "  #{label.ljust(24)} #{'0'.rjust(12)}  #{format_silver(cap_est).rjust(11)}"
        end

        respond ""
      end

      # Display recent items
      def show_recent_items(items, type_filter)
        type_label = type_filter ? type_filter.capitalize + "s" : "Items"
        respond ""
        respond "Recent #{items.size} #{type_label}:"
        respond "-" * 70

        items.each do |item|
          time_str = item[:created_at].strftime("%m/%d %H:%M")
          # Clean up type display for readability
          item_type = case item[:item_type]
                      when 'gemstone_dust' then 'dust'
                      when 'gemstone_jewel' then 'jewel'
                      when 'lte_boost' then 'boost'
                      when 'feeder_item' then 'feeder'
                      when 'legendary_item' then 'legend'
                      when 'draconic_idol' then 'idol'
                      else item[:item_type] || 'other'
                      end
          type_str = item_type.ljust(11)
          # Clean up source display
          item_source = (item[:item_source] || '')
                        .sub('_find', '')
                        .sub('wand_dupe', 'dupe')
                        .sub('wand_source', 'source')
          source_str = item_source.ljust(7)
          respond "  #{item[:item_name].ljust(40)} #{type_str} #{source_str} #{time_str}"
        end

        respond ""
      end

      # Display recent boxes
      def show_recent_boxes(boxes)
        respond ""
        respond "Recent Boxes:"
        respond "-" * 70

        total_silvers = 0
        boxes.each do |box|
          time_str = box[:created_at].strftime("%m/%d %H:%M")
          silvers = box[:silvers_found] || 0
          total_silvers += silvers
          respond "  #{box[:source_name].ljust(30)} #{format_silver(silvers).rjust(10)} silvers   #{time_str}"
        end

        respond "-" * 70
        respond "  Total: #{boxes.size} boxes".ljust(30) + " #{format_silver(total_silvers).rjust(10)} silvers"
        respond ""
      end

      # Display transaction breakdown
      def show_transactions(data)
        respond ""
        respond "Transaction Breakdown (Last 24 Hours):"
        respond "-" * 55

        net = 0
        data.each do |row|
          category = row[:category].ljust(20)
          total = row[:total] || 0
          count = row[:count] || 0
          net += total
          sign = total >= 0 ? '+' : ''
          respond "  #{category} #{sign}#{format_silver(total).rjust(12)}   (#{count} transactions)"
        end

        respond "-" * 55
        sign = net >= 0 ? '+' : ''
        respond "  Net:".ljust(20) + " #{sign}#{format_silver(net).rjust(12)}"
        respond ""
      end

      # Display creature stats
      def show_creatures(stats)
        respond ""
        respond "Top Creatures (Last 24 Hours):"
        respond "-" * 60

        stats.each do |row|
          name = (row[:source_name] || 'unknown').ljust(25)
          kills = row[:kills] || 0
          silvers = row[:silvers] || 0
          respond "  #{name} #{kills.to_s.rjust(4)} kills   #{format_silver(silvers).rjust(10)} silvers"
        end

        respond ""
      end

      # Display individual creature lookup
      def show_creature_lookup(data)
        respond ""

        search_event = data[:search_event]
        skin_event = data[:skin_event]

        if !search_event && !skin_event
          respond "No records found for creature ID: #{data[:source_id]}"
          return
        end

        creature_name = search_event&.[](:source_name) || skin_event&.[](:creature_name) || 'Unknown'
        respond "Creature Lookup: #{creature_name}"
        respond "GameObj ID: #{data[:source_id]}"
        respond "-" * 70

        # Search event info
        if search_event
          respond ""
          respond "SEARCH EVENT (ID: #{search_event[:id]})"
          respond "  Time:     #{format_time(search_event[:created_at])}"
          respond "  Room:     #{search_event[:room_id] || 'N/A'}"
          respond "  Silvers:  #{format_silver(search_event[:silvers_found])}"

          # Non-box items from search
          search_items = data[:search_items]
          if search_items.any?
            respond ""
            respond "  Items Found:"
            search_items.each do |item|
              respond "  #{format_box_item(item)}"
            end
          end
        end

        # Skin event info
        if skin_event
          respond ""
          respond "SKIN EVENT (ID: #{skin_event[:id]})"
          respond "  Time:     #{format_time(skin_event[:created_at])}"

          if data[:skin_item]
            respond "  #{format_box_item(data[:skin_item])}"
          end
        end

        # Boxes from this creature
        if data[:boxes].any?
          respond ""
          respond "BOXES (#{data[:boxes].size}):"

          data[:boxes].each_with_index do |box_data, idx|
            box = box_data[:box]
            box_id_link = Lich::Messaging.make_cmd_link(box[:item_id].to_s, ";lt box #{box[:id]}")
            respond ""
            _respond "  Box #{idx + 1}: #{box[:item_name]} [#{box_id_link}]"
            respond "    Pool Fee:    #{box[:pool_fee] ? format_silver(box[:pool_fee]) : 'N/A'}"
            respond "    Pool Tip:    #{box[:pool_tip] ? format_silver(box[:pool_tip]) : 'N/A'}"
            status = if box[:lost_at]
                       'Lost'
                     elsif box[:opened_at]
                       'Opened'
                     else
                       'Unopened'
                     end
            respond "    Status:      #{status}"

            if box[:opened_at]
              respond "    Opened At:   #{format_time(box[:opened_at])}"
              respond "    Box Silvers: #{format_silver(box_data[:silvers])}"

              if box_data[:contents].any?
                respond "    Contents:"
                box_data[:contents].each do |item|
                  respond "    #{format_box_item(item)}"
                end
              else
                respond "    Contents:    (none recorded)"
              end
            end
          end
        end

        # Calculate totals including sold values
        total_silvers = (search_event&.[](:silvers_found) || 0)
        data[:boxes].each { |b| total_silvers += b[:silvers] }
        total_fees = data[:boxes].sum { |b| b[:box][:pool_fee] || 0 }
        total_tips = data[:boxes].sum { |b| b[:box][:pool_tip] || 0 }

        # Calculate total from items (use sold_value if available, otherwise appraised_value)
        total_items = 0
        total_items += data[:search_items].sum { |i| i[:sold_value] || i[:appraised_value] || 0 }
        total_items += (data[:skin_item][:sold_value] || data[:skin_item][:appraised_value] || 0) if data[:skin_item]
        data[:boxes].each do |b|
          total_items += b[:contents].sum { |i| i[:sold_value] || i[:appraised_value] || 0 }
        end

        respond ""
        respond "-" * 70
        respond "TOTALS:"
        respond "  Silvers (search + boxes): #{format_silver(total_silvers)}"
        respond "  Items Value:              #{format_silver(total_items)}"
        respond "  Pool Fees:                -#{format_silver(total_fees)}"
        respond "  Pool Tips:                -#{format_silver(total_tips)}"
        respond "  Net:                      #{format_silver(total_silvers + total_items - total_fees - total_tips)}"
        respond ""
      end

      # Display individual box lookup
      def show_box_lookup(data)
        box = data[:box]
        respond ""
        respond "Box Lookup: #{box[:item_name]}"
        respond "-" * 70

        respond ""
        respond "BOX INFO:"
        respond "  Item ID:       #{box[:item_id]}"
        respond "  Record ID:     #{box[:id]}"
        respond "  Found:         #{format_time(box[:created_at])}"

        if data[:search_event]
          creature_id = data[:search_event][:source_id]
          id_link = Lich::Messaging.make_cmd_link(creature_id.to_s, ";lt creature #{creature_id}")
          _respond "  Source:        #{data[:search_event][:source_name]} [#{id_link}]"
        end

        respond ""
        respond "POOL INFO:"
        respond "  Dropped At:    #{box[:pool_dropped_at] ? format_time(box[:pool_dropped_at]) : 'N/A'}"
        respond "  Fee:           #{box[:pool_fee] ? format_silver(box[:pool_fee]) : 'N/A'}"
        respond "  Tip:           #{box[:pool_tip] ? format_silver(box[:pool_tip]) : 'N/A'}"

        respond ""
        respond "STATUS:"
        if box[:opened_at]
          respond "  Opened:        Yes"
          respond "  Opened At:     #{format_time(box[:opened_at])}"
          respond "  Box Silvers:   #{format_silver(data[:silvers])}"

          respond ""
          respond "CONTENTS:"
          if data[:contents].any?
            data[:contents].each do |item|
              respond format_box_item(item)
            end
          else
            respond "  (none recorded)"
          end

          # Net value including sold items (use sold_value if available, otherwise appraised_value)
          total_silvers = data[:silvers]
          total_items = data[:contents].sum { |i| i[:sold_value] || i[:appraised_value] || 0 }
          total_cost = (box[:pool_fee] || 0) + (box[:pool_tip] || 0)
          respond ""
          respond "-" * 70
          respond "NET VALUE:"
          respond "  Silvers from box:  #{format_silver(total_silvers)}"
          respond "  Items Value:       #{format_silver(total_items)}"
          respond "  Pool costs:        -#{format_silver(total_cost)}"
          respond "  Net:               #{format_silver(total_silvers + total_items - total_cost)}"
        elsif box[:lost_at]
          respond "  Lost:          Yes"
          respond "  Lost At:       #{format_time(box[:lost_at])}"
        else
          respond "  Opened:        No"
        end

        respond ""
      end

      # Display list of recent boxes with IDs for drill-down
      def show_box_list(boxes)
        respond ""
        respond "Recent Boxes (use ';lt box <id>' for details):"
        respond "-" * 85
        respond "  #{'ID'.ljust(8)} #{'Box Name'.ljust(28)} #{'Source'.ljust(18)} #{'Status'.ljust(10)} #{'Silvers'.rjust(10)}"
        respond "-" * 85

        boxes.each do |data|
          box = data[:box]
          id_link = Lich::Messaging.make_cmd_link(box[:id].to_s.ljust(8), ";lt box #{box[:id]}")
          name_str = (box[:item_name] || 'unknown')[0, 28].ljust(28)
          source_str = (data[:source_name] || 'unknown')[0, 18].ljust(18)
          status = if box[:lost_at]
                     'Lost'
                   elsif box[:opened_at]
                     'Opened'
                   else
                     'Unopened'
                   end
          status_str = status.ljust(10)
          silvers_str = box[:opened_at] ? format_silver(data[:silvers]).rjust(10) : '-'.rjust(10)

          _respond "  #{id_link} #{name_str} #{source_str} #{status_str} #{silvers_str}"
        end

        respond ""
        respond "Tip: Use ';lt box <id>' to see full details including contents and fees"
        respond ""
      end

      # Wands command handler - show wand duplication stats
      def wands_command(_args)
        character = LootTracker.current_character
        game = LootTracker.current_game

        respond ""
        respond "Wand Duplications"
        respond "-" * 70

        # Source wands that have been duplicated
        sources = LootTracker.items_table
                             .where(searcher: character, game: game)
                             .exclude(duplicated_at: nil)
                             .where(Sequel.lit("item_source = 'wand_source' OR dupe_source_id IS NULL"))
                             .where(item_type: 'wand')
                             .order(Sequel.desc(:duplicated_at))
                             .limit(20)
                             .all

        respond ""
        respond "Source Wands (duplicated):"
        if sources.empty?
          respond "  No wand duplications recorded."
        else
          sources.each do |wand|
            time_str = wand[:duplicated_at]&.strftime('%m/%d %H:%M') || 'N/A'
            respond "  #{wand[:item_name].to_s.ljust(40)} #{time_str}"
          end
        end

        # Copy wands created via dupe
        respond ""
        respond "Copy Wands (created via 918):"
        respond "-" * 70

        dupes = LootTracker.items_table
                           .where(searcher: character, game: game, item_source: 'wand_dupe')
                           .order(Sequel.desc(:duplicated_at))
                           .limit(20)
                           .all

        if dupes.empty?
          respond "  No copy wands recorded."
        else
          dupes.each do |wand|
            time_str = wand[:duplicated_at]&.strftime('%m/%d %H:%M') || 'N/A'
            # Try to find the source wand name
            source_name = if wand[:dupe_source_id]
                            source = LootTracker.items_table.where(id: wand[:dupe_source_id]).first
                            source ? " (from #{source[:item_name]})" : ''
                          else
                            ''
                          end
            respond "  #{wand[:item_name].to_s.ljust(35)} #{time_str}#{source_name}"
          end
        end

        respond ""
      end

      # Proxy command handler
      # Usage: proxy [loresong|appraise|dupe] <name>
      #        proxy <name>      - Set all proxies
      #        proxy clear       - Clear all proxies
      #        proxy             - Show current settings
      def lost_command(args)
        if args.empty?
          respond ""
          respond "Mark a box as lost (died, decayed, etc.)"
          respond "Usage:"
          respond "  ;lt lost <name>    - Mark most recent unopened box matching name"
          respond "  ;lt lost #<id>     - Mark box by DB record ID"
          respond ""
          respond "Example: ;lt lost haon strongbox"
          return
        end

        identifier = args.join(' ')
        # Strip leading # for DB ID lookups
        identifier = identifier.sub(/^#/, '') if identifier =~ /^#\d+$/

        item = LootTracker.mark_box_lost(identifier)
        if item
          respond ""
          respond "Marked as lost: #{item[:item_name]} (##{item[:id]}, searcher: #{item[:searcher]})"
        else
          respond ""
          respond "No matching unopened box found for '#{identifier}'"
        end
      end

      def proxy_command(args)
        respond ""
        respond "Cross-Character Proxy Settings"
        respond "-" * 40

        if args.empty?
          # Show current proxy settings
          loresong = LootTracker.loresong_proxy || '(none)'
          appraise = LootTracker.appraise_proxy || '(none)'
          dupe = LootTracker.dupe_proxy || '(none)'

          respond "  Loresong proxy:   #{loresong}"
          respond "  Appraise proxy:   #{appraise}"
          respond "  Dupe proxy:       #{dupe}"
          respond ""
          respond "Usage:"
          respond "  ;lt proxy <name>           - Set all proxies to <name>"
          respond "  ;lt proxy loresong <name>  - Set loresong proxy only"
          respond "  ;lt proxy appraise <name>  - Set appraise proxy only"
          respond "  ;lt proxy dupe <name>      - Set dupe proxy only"
          respond "  ;lt proxy clear            - Clear all proxies"
          respond ""
          return
        end

        command = args.first&.downcase
        name = args[1]

        case command
        when 'clear'
          LootTracker.loresong_proxy = nil
          LootTracker.appraise_proxy = nil
          LootTracker.dupe_proxy = nil
          respond "  All proxies cleared."
        when 'loresong'
          if name
            LootTracker.loresong_proxy = name
            respond "  Loresong proxy set to: #{name}"
          else
            respond "  ERROR: Name required. Usage: ;lt proxy loresong <name>"
          end
        when 'appraise'
          if name
            LootTracker.appraise_proxy = name
            respond "  Appraise proxy set to: #{name}"
          else
            respond "  ERROR: Name required. Usage: ;lt proxy appraise <name>"
          end
        when 'dupe'
          if name
            LootTracker.dupe_proxy = name
            respond "  Dupe proxy set to: #{name}"
          else
            respond "  ERROR: Name required. Usage: ;lt proxy dupe <name>"
          end
        else
          # Shorthand: ;lt proxy Nisugi - sets all proxies
          LootTracker.loresong_proxy = command
          LootTracker.appraise_proxy = command
          LootTracker.dupe_proxy = command
          respond "  All proxies set to: #{command}"
        end

        respond ""
      end

      # Display status
      def show_status
        respond ""
        respond "LootTracker Status"
        respond "-" * 40
        respond "  Version:          #{LootTracker::VERSION}"
        respond "  Tracking:         #{LootTracker.enabled ? 'Active' : 'Inactive'}"
        respond "  Debug:            #{LootTracker.debug? ? 'ON' : 'OFF'}"
        respond "  Database:         #{LootTracker::DB_FILE}"
        respond "  Character:        #{LootTracker.current_character}"
        respond "  Game:             #{LootTracker.current_game}"
        respond ""
      end

      # Toggle debug mode
      def toggle_debug
        LootTracker.instance_variable_set(:@debug, !LootTracker.debug?)
        respond "LootTracker debug: #{LootTracker.debug? ? 'ON' : 'OFF'}"
      end

      # Display help
      def show_help
        respond ""
        respond "LootTracker v#{LootTracker::VERSION} - Self-parsing loot tracker"
        respond "-" * 60
        respond "Usage:"
        respond "  ;loottracker                    Start tracking (or show summary if running)"
        respond "  ;lt                             Alias for ;loottracker"
        respond ""
        respond "  ;loottracker summary            Last 24 hours (default)"
        respond "  ;loottracker summary today      Since midnight"
        respond "  ;loottracker summary month      Current month"
        respond "  ;loottracker summary <hours>    Last N hours"
        respond ""
        respond "Loot Cap Report (resets 1st of month, midnight ET):"
        respond "  ;loottracker cap                Current month loot cap"
        respond "  ;loottracker cap last           Previous month"
        respond "  ;loottracker cap 2025-12        Specific month"
        respond ""
        respond "  ;loottracker recent [n]         Recent items (default 20)"
        respond "  ;loottracker recent [n] <type>  Filter by type"
        respond "    Types: gems, boxes, skins, klocks, magic, wands, weapons, armor,"
        respond "           jewelry, clothing, scrolls, valuables, collectibles,"
        respond "           lockpicks, scarabs, reagents, food, jars, boons, ingots, junk, other"
        respond ""
        respond "  ;loottracker boxes [n]          Recent boxes with silvers"
        respond "  ;loottracker transactions       Transaction breakdown"
        respond "  ;loottracker creatures [n]      Top creatures by value"
        respond "  ;loottracker wands              Wand duplication stats (918 spell)"
        respond ""
        respond "Individual Lookups:"
        respond "  ;loottracker creature <id>      Lookup creature by GameObj ID"
        respond "                                  Shows: search loot, skin, boxes + contents"
        respond ""
        respond "  ;loottracker box                List recent 10 boxes with IDs"
        respond "  ;loottracker box -n 20          List recent 20 boxes"
        respond "  ;loottracker box <id>           Lookup box by record ID"
        respond "                                  Shows: fee, tip, contents, net value"
        respond ""
        respond "Cross-Character Proxy (for loresinging/appraising on behalf of others):"
        respond "  ;loottracker proxy              Show current proxy settings"
        respond "  ;loottracker proxy <name>       Set all proxies to <name>"
        respond "  ;loottracker proxy loresong <n> Set loresong proxy only"
        respond "  ;loottracker proxy appraise <n> Set appraise proxy only"
        respond "  ;loottracker proxy dupe <n>     Set dupe proxy only"
        respond "  ;loottracker proxy clear        Clear all proxies"
        respond ""
        respond "  ;loottracker status             Show tracker status"
        respond "  ;loottracker debug              Toggle debug mode"
        respond "  ;loottracker help               Show this help"
        respond ""
      end
    end
  end

  # ===== Main Run Loop =====
  class << self
    def run
      @enabled = true
      @debug = Script.current.vars[1] == 'debug'

      add_downstream_hook
      add_upstream_hook
      log("Started (debug=#{@debug})")

      # Non-blocking main loop
      loop do
        # Process commands first (responsive to user input)
        until @command_queue.empty?
          cmd = @command_queue.pop(true) rescue nil
          CLI.process(cmd) if cmd
        end

        # Process loot chunks (non-blocking)
        begin
          chunk = @queue.pop(true)  # Non-blocking pop
          Parser.process(chunk) if chunk
        rescue ThreadError
          # Queue empty, this is expected
        rescue StandardError => e
          log("Parser error: #{e.message}")
          log(e.backtrace.first(3).join("\n")) if debug?
        end

        sleep(0.05)  # Yield CPU, stay responsive
      end
    rescue StandardError => e
      log("Fatal error: #{e.message}")
      log(e.backtrace.first(5).join("\n"))
    ensure
      remove_hooks
      @enabled = false
      log("Stopped")
    end

    def stop
      @enabled = false
    end
  end
end

# ===== Script Entry Point =====
before_dying { LootTracker.stop }

# Initialize database for all modes (needed for reports)
LootTracker::Database.setup!

# Handle command-line arguments
args = script.vars[1..-1]&.join(' ') || ''
first_arg = script.vars[1]&.downcase

case first_arg
when 'help', '-h', '--help'
  # One-shot help
  LootTracker::CLI.show_help
when 'summary', 'cap', 'lootcap', 'recent', 'boxes', 'transactions', 'tx', 'creatures', 'status', 'lost'
  # One-shot report commands (don't start tracking)
  LootTracker::CLI.process(args)
when 'debug'
  # Start tracking with debug mode
  LootTracker.run
when nil, ''
  # Default: start tracking
  LootTracker.run
else
  # Unknown command - show help
  respond "Unknown command: #{first_arg}"
  LootTracker::CLI.show_help
end
