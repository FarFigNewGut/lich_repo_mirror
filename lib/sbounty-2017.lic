##quiet
## vim: set ft=ruby:
=begin
    ----------------
    SBounty-2017 fork by Daedeus
    NEW FEATURE:
      ;sbounty load
         - will load the hunter (like bigshot) with parameters
           for current bounty.  Useful if you want to MA bigshot
           with data stored in sbounty
      ;sbounty load "monster name"
         - will load the hunter (like bigshot) with parameters
           for the specified monster name 
    
    FIXES:
      fix: line 625: skipping grizzled enemies due to extra space
      darkelf: will route to Tanzania and Gaedrein in Illistim even if rest_room is in Cysaegir
      fix: sometimes fail to stow herb while foraging
      fix: rare bug where stopping a hunt will leave go2 running
      fix: sbounty will run rest scripts in table lobby if rest_enter/rest_exit is "go table"/"out"
           - will now call rest_enter right after rest_goto
      fix: will run from harmless npcs while foraging/searching
           - now check npc for "aggressive" type
      fix: fail to load ancient/grizzled targetting if attack routine has parenthesis
           - now perform a "clean" before loading
      fix: game now shows heirloom name in bounty description
           - sbounty now reads that name
      fix: now detect tasks for being added to another player's bounty
    -------------------
    SBounty by SpiffyJr (spiffyjr@gmail.com)

    Does all bounties except gem, escorts, and bandits. Gems should
    be handled via your loot with stockpiling.

    Feel free to send donations or Gift's of Adventure.

     author: spiffyjr
      email: theman@spiffyjr.me
       name: SpiffyBounty
       tags: bounty
    version: 1.0

=end

CharSettings[:hunter] ||= 'sbounty-bigshot'

CharSettings[:enable_cull]      = CharSettings[:enable_cull].nil? ? true : CharSettings[:enable_cull]
CharSettings[:enable_dangerous] = CharSettings[:enable_dangerous].nil? ? true : CharSettings[:enable_dangerous]
CharSettings[:enable_forage]    = CharSettings[:enable_forage].nil? ? true : CharSettings[:enable_forage]
CharSettings[:enable_loot]      = CharSettings[:enable_loot].nil? ? true : CharSettings[:enable_loot]
CharSettings[:enable_rescue]    = CharSettings[:enable_rescue].nil? ? true : CharSettings[:enable_rescue]
CharSettings[:enable_search]    = CharSettings[:enable_search].nil? ? true : CharSettings[:enable_search]
CharSettings[:enable_bandit]    = CharSettings[:enable_bandit].nil? ? false : CharSettings[:enable_bandit]
CharSettings[:enable_skin]      = CharSettings[:enable_skin].nil? ? true : CharSettings[:enable_skin]
CharSettings[:enable_expedite]  = CharSettings[:enable_expedite].nil? ? true : CharSettings[:enable_expedite]

CharSettings[:enable_hunt_complete] = CharSettings[:enable_hunt_complete].nil? ? true : CharSettings[:enable_hunt_complete]

CharSettings[:hunting_scripts]       ||= ['spellactive']
CharSettings[:enable_bandit_script]  ||= false
CharSettings[:bandit_script]         ||= 'sbounty-bandit-example'
CharSettings[:pre_search_commands]   ||= ['store all']
CharSettings[:post_search_commands]  ||= ['gird']
CharSettings[:forage_retry_delay]    ||= 300
CharSettings[:loot_script]           ||= 'sloot'
CharSettings[:turn_in_percent]       ||= 95
CharSettings[:enable_turn_in_bounty] ||= CharSettings[:enable_turn_in_bounty].nil? ? true : CharSettings[:enable_turn_in_bounty]

CharSettings[:should_hunt_mind]    ||= 75
CharSettings[:should_hunt_mana]    ||= 0
CharSettings[:should_hunt_spirit]  ||= 7
CharSettings[:hunt_pre_commands]   ||= ['gird']
CharSettings[:should_rest_mind]    ||= 100
CharSettings[:should_rest_mana]    ||= 0
CharSettings[:should_rest_encum]   ||= 20
CharSettings[:should_rest_wounded] ||= StringProc.new('bleeding? || percenthealth <= 75 || [Wounds.nsys, Wounds.limbs, Wounds.neck, Wounds.head, Wounds.leftEye, Wounds.rightEye].max > 1')

CharSettings[:rest_in_commands]    ||= ['go table, sit']
CharSettings[:rest_out_commands]   ||= ['stand', 'out']
CharSettings[:rest_pre_commands]   ||= ['store all']
CharSettings[:rest_scripts]        ||= ['useherbs --buy-missing=on', 'sloot sell', 'waggle']
CharSettings[:rest_sleep_interval] ||= 30

CharSettings[:locations] ||= {}

$sbounty_rest        = false
$sbounty_rest_reason = nil
in_rest_area         = false
rest_reason          = nil
hunt_reason          = nil
can_do_bounty_cache  = nil
expedite_left        = true
last_forage_attempt  = 0
last_forage_delay    = 300
first_run            = true

if UserVars.lootsack.nil? or UserVars.lootsack.empty?
    echo '** lootsack has not been set, set it with ;set change lootsack [container]'
    exit
end

if CharSettings[:enable_skin] and (UserVars.skinsack.nil? or UserVars.skinsack.empty?)
    echo '** skinsack has not been set, set it with ;set change skinsack [container]'
    exit
end

lootsack = GameObj.inv.find { |i| i.noun =~ /#{UserVars.lootsack}/ } or GameObj.inv.find { |i| i.name =~ /#{UserVars.lootsack}/ }
skinsack = GameObj.inv.find { |i| i.noun =~ /#{UserVars.skinsack}/ } or GameObj.inv.find { |i| i.name =~ /#{UserVars.lootsack}/ }

if lootsack.nil?
    echo '** failed to find your lootsack, set it with ;set change lootsack [container]'
    exit
end

if CharSettings[:enable_skin] and skinsack.nil?
    echo '** failed to find your skinsack, set it with ;set change skinsack [container]'
    exit
end

# You have been tasked to recover a peridot-inset pewter ring that an unfortunate citizen lost after being attacked by a storm giant in the Upper Trollfang near Wehnimer's Landing.  The heirloom can be identified by the initials MG engraved upon it.  Hunt down the creature and LOOT the item from its corpse.

bounty_patterns = {
    'none' => '^You are not currently assigned a task\.',

    # help
    'help_bandit'    => 'It appears they have a bandit problem',
    'help_creature'  => 'It appears they have a creature problem they\'d like you to solve\.',
    'help_resident'  => 'It appears that a local resident urgently needs our help in some matter\.',
    'help_heirloom'  => 'It appears they need your help in tracking down some kind of lost heirloom\.',
    'help_gemdealer' => 'The local gem dealer, .*, has an order to fill and wants our help\.',
    'help_herbalist' => 'local herbalist|local healer|local alchemist',
    'help_furrier'   => 'The local furrier',

    # in progress
    'task_bandit'    => '^You have been tasked to suppress bandit activity (?:in|on|near) (?:the )?(.*)\s(?:near|between|under|\.)',
    'task_escort'    => '^You have made contact with the child',
    'task_dangerous' => 'You have been tasked to hunt down and kill a particularly dangerous (.*) that has established a territory (?:in|on|near) (?:the )?(.*)(?:\s(?:near|between|under)|\.)\s+You can',
    'task_provoked'  => 'You have been tasked to hunt down and kill a particularly dangerous (.*) that has established a territory (?:in|on|near) (?:the )?(.*)(?:\s(?:near|between|under)|\.)\s+You have provoked',
    'task_dealer'    => '^The(?: local)? gem dealer',
    'task_forage'    => 'concoction that requires (?:a|an|some) (.*) found (?:in|on|near) (?:the )?(.*?)(?: near| between| under|\.).*These samples must be in pristine condition\.\s+You have been tasked to retrieve (\d+) (?:more )?samples?\.',
    'task_cull'      => 'You have been tasked to(?: help \w*)?(?: (?:retrieve an heirloom|kill a dangerous creature|rescue a missing child) by)? suppress(?:ing)? (.*) activity (?:in|on) (?:the )?(.*)(?:\s(?:near|between|under)|\.)',
#    'task_search'    => 'unfortunate citizen lost after being attacked by (?:a|an) (.*) (?:in|on|near) (?:the )?(.*)(?:near|between|under|\.).*SEARCH',
    'task_search'    => 'unfortunate citizen lost after being attacked by (?:a|an) (.*) (?:in|on|near)(?: the)? (.*) (?:(?:near) (.*))?\.  The heirloom.*SEARCH',
    'task_heirloom'  => 'unfortunate citizen lost after being attacked by (?:a|an) (.*) (?:in|on|near)(?: the)? (.*) (?:(?:near) (.*))?\.  The heirloom.*LOOT',
 #   'task_heirloom'  => 'unfortunate citizen lost after being attacked by (?:a|an) (.*) (?:in|on|near) (?:the )?(.*)(?:near|between|under|\.).*LOOT',
    'task_found'     => 'You have located .* and should bring it back',
    'task_skin'      => '^You have been tasked to retrieve (\d+|\w+)s? (.*) of at least .*\.  You can SKIN them off the corpse of (?:a|an) (.*) or ',
    'task_rescue'    => 'A local divinist has had visions of the child fleeing from (?:a|an) (.*) (?:in|on) (?:the )?(.*) (?:near|between|under)',

    # fail
    'fail_child' => 'The child you were tasked to rescue is gone and your task is failed\.',

    # success
    'success'          => '^You have succeeded in your task and can return',
    'success_guard'    => '^You succeeded in your task and should report back to',
    'success_heirloom' => '^You have located an? (.*) and should bring it back .*\.$',
}

setup = proc {
    script_name = script.name

    action   = nil
    window   = nil
    notebook = nil

    locations = CharSettings[:locations].dup
    location  = nil

    error = proc { |msg|
        dlg = Gtk::Dialog.new(
            'Error!',
            window,
            Gtk::Dialog::DESTROY_WITH_PARENT,
            [ Gtk::Stock::OK, Gtk::Dialog::RESPONSE_NONE ]
        )
        dlg.resize 200,100
        dlg.signal_connect 'response' do dlg.destroy end
        dlg.vbox.add(Gtk::Label.new(msg))
        dlg.show_all
    }

    widgets = {
        :gui_widgets => {
            # buttons
            :close  => Gtk::Button.new('Close'),
            :create => Gtk::Button.new('Create'),
            :delete => Gtk::Button.new('Delete'),
            :save   => Gtk::Button.new('Save & Close'),

            # combos
            :locations => Gtk::ComboBox.new,

            # entries
            :new_name => Gtk::Entry.new,
        },

        :location_widgets => {
            # check buttons
            :enable_bounty_only      => Gtk::CheckButton.new('Only attack bouny critters'),
            :enable_hunting_rotation => Gtk::CheckButton.new('In hunting rotation'),
            :enable_search_only      => Gtk::CheckButton.new('Only search here (no hunting)'),

            #entries
            :location   => Gtk::Entry.new,
            :skins      => Gtk::Entry.new,
            :targets    => Gtk::Entry.new,
            :room       => Gtk::Entry.new,
            :boundaries => Gtk::Entry.new,
        },

        # check buttons
        :enable_cull          => Gtk::CheckButton.new('Cull critters').set_active(CharSettings[:enable_cull]),
        :enable_dangerous     => Gtk::CheckButton.new('Dangerous critter').set_active(CharSettings[:enable_dangerous]),
        :enable_forage        => Gtk::CheckButton.new('Forage herbs').set_active(CharSettings[:enable_forage]),
        :enable_loot          => Gtk::CheckButton.new('Loot heirloom').set_active(CharSettings[:enable_loot]),
        :enable_rescue        => Gtk::CheckButton.new('Rescue child').set_active(CharSettings[:enable_rescue]),
        :enable_search        => Gtk::CheckButton.new('Search heirloom').set_active(CharSettings[:enable_search]),
        :enable_bandit        => Gtk::CheckButton.new('Bandits').set_active(CharSettings[:enable_bandit]),
        :enable_skin          => Gtk::CheckButton.new('Skin critters').set_active(CharSettings[:enable_skin]),
        :enable_expedite      => Gtk::CheckButton.new('Expedite bounties').set_active(CharSettings[:enable_expedite]),
        :enable_bandit_script => Gtk::CheckButton.new('Use bandit script').set_active(CharSettings[:enable_bandit_script]),
        :enable_hunt_complete => Gtk::CheckButton.new('Hunt until complete?').set_active(CharSettings[:enable_hunt_complete]),
        :enable_turn_in_bounty => Gtk::CheckButton.new('Force turn in if new bounty').set_active(CharSettings[:enable_turn_in_bounty]),

        # entries
        :hunting_scripts      => Gtk::Entry.new.set_text(CharSettings[:hunting_scripts].collect { |a| a.strip }.join(',')),
        :bandit_script        => Gtk::Entry.new.set_text(CharSettings[:bandit_script]),
        :pre_search_commands  => Gtk::Entry.new.set_text(CharSettings[:pre_search_commands].collect { |a| a.strip }.join(',')),
        :post_search_commands => Gtk::Entry.new.set_text(CharSettings[:post_search_commands].collect { |a| a.strip }.join(',')),
        :forage_retry_delay   => Gtk::Entry.new.set_text(CharSettings[:forage_retry_delay].to_s),
        :loot_script          => Gtk::Entry.new.set_text(CharSettings[:loot_script].to_s),
        :turn_in_percent      => Gtk::Entry.new.set_text(CharSettings[:turn_in_percent].to_s),

        :should_hunt_mind   => Gtk::Entry.new.set_text(CharSettings[:should_hunt_mind].to_s),
        :should_hunt_mana   => Gtk::Entry.new.set_text(CharSettings[:should_hunt_mana].to_s),
        :should_hunt_spirit => Gtk::Entry.new.set_text(CharSettings[:should_hunt_spirit].to_s),

        :hunt_pre_commands => Gtk::Entry.new.set_text(CharSettings[:hunt_pre_commands].collect { |a| a.strip }.join(',')),
        :hunt_commands_a   => Gtk::Entry.new.set_text(CharSettings[:hunt_commands_a].collect { |a| a.strip }.join(',')),
        :hunt_commands_b   => Gtk::Entry.new.set_text(CharSettings[:hunt_commands_b].collect { |a| a.strip }.join(',')),
        :hunt_commands_c   => Gtk::Entry.new.set_text(CharSettings[:hunt_commands_c].collect { |a| a.strip }.join(',')),

        :should_rest_mana    => Gtk::Entry.new.set_text(CharSettings[:should_rest_mana].to_s),
        :should_rest_mind    => Gtk::Entry.new.set_text(CharSettings[:should_rest_mind].to_s),
        :should_rest_encum   => Gtk::Entry.new.set_text(CharSettings[:should_rest_encum].to_s),
        :should_rest_wounded => Gtk::Entry.new.set_text(CharSettings[:should_rest_wounded]._dump),

        :rest_in_commands  => Gtk::Entry.new.set_text(CharSettings[:rest_in_commands].collect { |a| a.strip }.join(',')),
        :rest_out_commands => Gtk::Entry.new.set_text(CharSettings[:rest_out_commands].collect { |a| a.strip }.join(',')),
        :rest_pre_commands => Gtk::Entry.new.set_text(CharSettings[:rest_pre_commands].collect { |a| a.strip }.join(',')),
        :rest_room         => Gtk::Entry.new.set_text(CharSettings[:rest_room]),
        :rest_scripts      => Gtk::Entry.new.set_text(CharSettings[:rest_scripts].collect { |a| a.strip }.join(','))
    }

    Gtk.queue {
        update_disabled = proc {
            widgets[:location_widgets].each { |key, widget|
                if location.nil?
                    widget.set_sensitive(false)
                else
                    widget.set_sensitive(true)
                end
            }
        }

        populate_locations = proc {
            loop {
                break if not widgets[:gui_widgets][:locations].model.iter_first
                widgets[:gui_widgets][:locations].remove_text(0)
            }

            locations.keys.sort.each { |text|
                widgets[:gui_widgets][:locations].append_text(text)
            }
        }

        save_location = proc {
            widgets[:location_widgets].each { |key, widget|
                if widget.class == Gtk::CheckButton
                    value = widget.active?
                elsif [:skins, :targets, :boundaries].include?(key)
                    value = widget.text.strip.split(',').collect { |item| item.strip }
                else
                    value = widget.text.strip
                end

                locations[location][key] = value
            }
        }

        attach_signals = proc {
            widgets[:gui_widgets][:close].signal_connect 'clicked' do action = :close end
            widgets[:gui_widgets][:save].signal_connect 'clicked' do action = :save; save_location.call end

            widgets[:gui_widgets][:create].signal_connect 'clicked' do
                name = widgets[:gui_widgets][:new_name].text.strip

                if name.nil? or name.empty? or name.length < 3
                    error.call 'You need to enter a name!'
                elsif locations.keys.find { |n| n.downcase.strip == name.downcase.strip }
                    error.call 'A location with that name already exists!'
                else
                    locations[name] = {}

                    widgets[:gui_widgets][:new_name].set_text ""

                    populate_locations.call
                    update_disabled.call
                end
            end

            widgets[:gui_widgets][:delete].signal_connect 'clicked' do
                Gtk.queue {
                    if widgets[:gui_widgets][:locations].active == -1
                        error.call 'You do not have a location selected!'
                    else
                        locations.delete(widgets[:gui_widgets][:locations].active_text)
                        widgets[:gui_widgets][:locations].remove_text(widgets[:gui_widgets][:locations].active)

                        widgets[:location_widgets].each { |key, widget|
                            if widget.class == Gtk::CheckButton
                                widget.set_active(false)
                            else
                                widget.set_text("")
                            end
                        }
                    end
                }
            end

            widgets[:gui_widgets][:locations].signal_connect 'changed' do
                Gtk.queue {
                    save_location.call

                    location = widgets[:gui_widgets][:locations].active_text

                    if locations[location]
                        widgets[:location_widgets].each { |key, widget|
                            if widget.class == Gtk::CheckButton
                                widget.set_active(!!locations[location][key])
                            elsif [:skins, :targets, :boundaries].include?(key)
                                widget.set_text(locations[location][key].join(','))
                            else
                                widget.set_text(locations[location][key].strip)
                            end
                        }
                    end

                    update_disabled.call
                }
            end
        }

        # main window
        window = Gtk::Window.new
        window.border_width = 5
        window.keep_above = true
        window.resizable = true
        window.resize 500, 300
        window.set_window_position Gtk::Window::POS_CENTER

        # main notebook (tabs)
        notebook = Gtk::Notebook.new
        notebook.show_border = true

        vbox_main = Gtk::VBox.new
        vbox_main.pack_start notebook

        # sbounty options
        vbox = Gtk::VBox.new

        frm = Gtk::Frame.new('Locations').set_border_width(3)
        tbl = Gtk::Table.new(7, 4, true).set_border_width(3)

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('New name: ')), 0, 1, 0, 1
        tbl.attach widgets[:gui_widgets][:new_name], 1, 3, 0, 1
        tbl.attach widgets[:gui_widgets][:create], 3, 4, 0, 1

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Locations: ')), 0, 1, 1, 2
        tbl.attach widgets[:gui_widgets][:locations], 1, 3, 1, 2
        tbl.attach widgets[:gui_widgets][:delete], 3, 4, 1, 2

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Location: ')), 0, 1, 3, 4
        tbl.attach widgets[:location_widgets][:location], 1, 2, 3, 4
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Skins: ')), 2, 3, 3, 4
        tbl.attach widgets[:location_widgets][:skins], 3, 4, 3, 4

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Targets: ')), 0, 1, 4, 5
        tbl.attach widgets[:location_widgets][:targets], 1, 2, 4, 5

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Room #: ')), 0, 1, 5, 6
        tbl.attach widgets[:location_widgets][:room], 1, 2, 5, 6
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Boundaries: ')), 2, 3, 5, 6
        tbl.attach widgets[:location_widgets][:boundaries], 3, 4, 5, 6

        tbl.attach widgets[:location_widgets][:enable_hunting_rotation], 0, 1, 6, 7
        tbl.attach widgets[:location_widgets][:enable_bounty_only], 1, 2, 6, 7
        tbl.attach widgets[:location_widgets][:enable_search_only], 2, 3, 6, 7

        frm.add(tbl)
        vbox.pack_start(frm)

        frm = Gtk::Frame.new('Bounties').set_border_width(3)
        tbl = Gtk::Table.new(5, 4, true).set_border_width(3)

        tbl.attach widgets[:enable_cull], 0, 1, 0, 1
        tbl.attach widgets[:enable_dangerous], 1, 2, 0, 1
        tbl.attach widgets[:enable_rescue], 2, 3, 0, 1
        tbl.attach widgets[:enable_skin], 3, 4, 0, 1

        tbl.attach widgets[:enable_loot], 0, 1, 1, 2
        tbl.attach widgets[:enable_search], 1, 2, 1, 2
        tbl.attach widgets[:enable_forage], 2, 3, 1, 2
        tbl.attach widgets[:enable_bandit], 3, 4, 1, 2

        tbl.attach widgets[:enable_bandit_script], 1, 2, 2, 3
        tbl.attach widgets[:enable_expedite], 2, 3, 2, 3
        tbl.attach widgets[:enable_hunt_complete], 3, 4, 2, 3

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('turn in when mind >= ')), 0, 1, 3, 4
        tbl.attach widgets[:turn_in_percent], 1, 2, 3, 4
        tbl.attach widgets[:enable_turn_in_bounty], 3, 4, 3, 4

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('hunting scripts:')), 2, 3, 4, 5
        tbl.attach widgets[:hunting_scripts], 3, 4, 4, 5
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('bandit script:')), 0, 1, 4, 5
        tbl.attach widgets[:bandit_script], 1, 2, 4, 5

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('pre-search commands: ')), 0, 1, 5, 6
        tbl.attach widgets[:pre_search_commands], 1, 2, 5, 6
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('post-search commands: ')), 2, 3, 5, 6
        tbl.attach widgets[:post_search_commands], 3, 4, 5, 6

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('forage retry delay: ')), 0, 1, 6, 7
        tbl.attach widgets[:forage_retry_delay], 1, 2, 6, 7
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('loot script: ')), 2, 3, 6, 7
        tbl.attach widgets[:loot_script], 3, 4, 6, 7

        frm.add(tbl)
        vbox.pack_start(frm)

        notebook.append_page vbox, Gtk::Label.new('Locations / Options')

        # default options
        vbox = Gtk::VBox.new

        frm = Gtk::Frame.new('Should Rest').set_border_width(3)
        tbl = Gtk::Table.new(3, 4, true).set_border_width(3)

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('when mind % >= ')), 0, 1, 0, 1
        tbl.attach widgets[:should_rest_mind], 1, 2, 0, 1
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('or mana <= ')), 2, 3, 0, 1
        tbl.attach widgets[:should_rest_mana], 3, 4, 0, 1

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('or encumbrance % >= ')), 0, 1, 1, 2
        tbl.attach widgets[:should_rest_encum], 1, 2, 1, 2

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('or wounded eval: ')), 0, 1, 2, 3
        tbl.attach widgets[:should_rest_wounded], 1, 4, 2, 3

        frm.add(tbl)
        vbox.pack_start(frm)

        frm = Gtk::Frame.new('Resting').set_border_width(3)
        tbl = Gtk::Table.new(2, 4, true).set_border_width(3)

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('room #: ')), 0, 1, 0, 1
        tbl.attach widgets[:rest_room], 1, 2, 0, 1
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('pre-rest commands: ')), 2, 3, 0, 1
        tbl.attach widgets[:rest_pre_commands], 3, 4, 0, 1

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('enter commands: ')), 0, 1, 1, 2
        tbl.attach widgets[:rest_in_commands], 1, 2, 1, 2
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('exit commands: ')), 2, 3, 1, 2
        tbl.attach widgets[:rest_out_commands], 3, 4, 1, 2

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('scripts: ')), 0, 1, 2, 3
        tbl.attach widgets[:rest_scripts], 1, 4, 2, 3

        frm.add(tbl)
        vbox.pack_start(frm)

        frm = Gtk::Frame.new('Should Hunt').set_border_width(3)
        tbl = Gtk::Table.new(2, 4, true).set_border_width(3)

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('when mind % <= ')), 0, 1, 0, 1
        tbl.attach widgets[:should_hunt_mind], 1, 2, 0, 1
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('and mana >= ')), 2, 3, 0, 1
        tbl.attach widgets[:should_hunt_mana], 3, 4, 0, 1

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('and spirit >= ')), 0, 1, 1, 2
        tbl.attach widgets[:should_hunt_spirit], 1, 2, 1, 2

        frm.add(tbl)
        vbox.pack_start(frm)

        frm = Gtk::Frame.new('Hunting').set_border_width(3)
        tbl = Gtk::Table.new(2, 4, true).set_border_width(3)

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Pre-hunt commands: ')), 0, 1, 0, 1
        tbl.attach widgets[:hunt_pre_commands], 1, 2, 0, 1
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Commands (a): ')), 2, 3, 0, 1
        tbl.attach widgets[:hunt_commands_a], 3, 4, 0, 1

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Commands (b): ')), 0, 1, 1, 2
        tbl.attach widgets[:hunt_commands_b], 1, 2, 1, 2
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Commands (c): ')), 2, 3, 1, 2
        tbl.attach widgets[:hunt_commands_c], 3, 4, 1, 2

        frm.add(tbl)
        vbox.pack_start(frm)

        notebook.append_page vbox, Gtk::Label.new('Resting / Hunting')

        # main window widgets
        vbox = Gtk::VBox.new
        vbox.pack_start Gtk::Alignment.new(0, 1, 0, 0), false

        hbox = Gtk::HBox.new
        hbox.add widgets[:gui_widgets][:save]
        hbox.add widgets[:gui_widgets][:close]

        halign = Gtk::Alignment.new 1, 0, 0, 0
        halign.add hbox

        vbox.pack_start halign
        vbox_main.pack_start vbox

        # create the window
        attach_signals.call
        update_disabled.call
        populate_locations.call

        window.add vbox_main
        window.show_all
    }

    before_dying { Gtk.queue { window.destroy unless window.nil? } }

    sleep 0.10 while action.nil?

    case action
        when :save
            CharSettings[:locations] = locations

            widgets.each { |key, widget|
                next if [:location_widgets, :gui_widgets].include?(key)

                if widget.class == Gtk::CheckButton
                    value = widget.active?
                elsif [:hunting_scripts, :pre_search_commands, :post_search_commands, :hunt_pre_commands, :hunt_commands_a, :hunt_commands_b, :hunt_commands_c, :rest_in_commands, :rest_out_commands, :rest_pre_commands, :rest_scripts].include?(key)
                    value = widget.text.strip.split(',').collect { |item| item.strip }
                elsif key == :should_rest_wounded
                    value = StringProc.new widget.text.strip
                else
                    value = widget.text.strip
                end

                CharSettings[key] = value
            }
    end
}

error = proc { |msg|
    echo "** #{msg}"
    exit
}

print = proc { |msg|
    echo "-- #{msg}"
}

clean_skin = proc { |name|
    name.strip.downcase.gsub(/s$/, '').gsub(/teeth/, 'tooth').gsub(/hooves?/, 'hoof')
}

has_skins = proc {
    if bounty? =~ /#{bounty_patterns['task_skin']}/
        count = $1.to_i
        skin  = $2.downcase

        skinsack.contents.find_all { |item| item.name =~ /#{clean_skin.call(skin)}/i }.size >= (count + 3)
    else
        false
    end
}

is_bounty = proc { |types|
    result = []
	if types.class != Array
		types = [types]
	end
    types.each { |type| result.push(bounty_patterns[type]) if not bounty_patterns[type].nil? }

    !(bounty? =~ /#{result.join('|')}/).nil?
}

get_bounty_location = proc { |location,target|
    if location.nil?
        location = target = nil

        # remove search only locations for hunting areas
        locations = CharSettings[:locations].dup
        if is_bounty.call ['task_skin', 'task_heirloom', 'task_dangerous', 'task_cull', 'task_rescue']
            locations.delete_if { |name, data| data[:enable_search_only] }
        end

        if bounty? =~ /#{bounty_patterns['task_skin']}/
            # remember: don't swap the order or the global $ vars are lost!
            target   = $3.strip.downcase
            skin     = clean_skin.call($2)
            location = locations.find { |name, data| $SBOUNTY_CLEAN_TARGETS.call(data[:targets]).find { |t| target =~ /#{t}/i } and data[:skins].find { |s| skin =~ /#{s.strip.downcase}/i }}
        else
            bounty_patterns.each { |key,value|
                if bounty? =~ /#{value}/i
                    target   = $1
                    location = $2
                    #echo "#{$1} - #{$2}" #if key == "task_provoked"
                    break
                end
            }

            location = location.downcase.strip
            location = locations.find { |name, data|
                cleaned = $SBOUNTY_CLEAN_TARGETS.call(data[:targets])
                location =~ /#{data[:location].strip}/i and cleaned.find {
                    |t| target =~ /#{t}/i
                }
            }
        end
    end

    if location
        name = location[0].dup
        data = location[1].to_hash.dup

        if target
            targets = data[:targets].dup
            cleaned = $SBOUNTY_CLEAN_TARGETS.call(data[:targets])
            target_key = nil

            # see if they have a provoked ancient/grizzled line
            if is_bounty.call 'task_provoked'
                target_key = cleaned.find { |t|
                    t =~ /ancient|grizzled/ and (
                        "ancient #{target}" =~ /#{t}/i or
                        "grizzled #{target}" =~ /#{t}/i
                    )
                }
            end

            # regular bounties
            if target_key.nil?
                target_key = cleaned.find { |t| target =~ /#{t}/i }
            end

            index = cleaned.index(target_key)
            target = targets[index]

            if is_bounty.call 'task_provoked'
                # add the ancient|grizzled for them
                if target !~ /ancient|grizzled/i
                    new_target = target.gsub(cleaned[index], "(?:ancient|grizzled).*#{cleaned[index]}")
                    targets[target.index(target)] = new_target
                    target = new_target
                end
            end
        end

        if data[:enable_bounty_only]
            targets = [ target ]
        end

        data[:targets] = targets

        [name, data]
    else
        print.call 'could not find bounty location'
        nil
    end
}

get_herb_rooms = proc { |location, herb|
    target_list = Array.new
    names = [herb]

    if herb == 'ayana leaf'
        names = [herb, 'ayana leaf', 'ayana lichen', 'ayana weed', 'ayana berry', 'ayana root']
    elsif herb == "ayana'al leaf"
        names = [herb, 'ayana\'al leaf', 'ayana\'al lichen', 'ayana\'al weed', 'ayana\'al berry', 'ayana\'al root']
    end

    Room.list.each { |room|
        if room.tags.find { |tag| names.find { |name| name =~ /#{tag}/i } }
            target_list.push(room.id)
        end
    }
    previous, shortest_distances = Map.dijkstra(Room.current.id)

    if location
        # delete the room if it's not the correct location
        target_list.delete_if { |room_num|
            if Room[room_num].location.nil?
                Room[room_num].title[0] !~ /#{location}/i
            elsif not Room[room_num].location.nil?
                Room[room_num].location !~ /#{location}/i
            else
                false
            end
        }
    end

    if target_list.length == 0
        similar = Room.tags.find_all { |tag| tag =~ /#{herb}/i }

        if not similar.empty?
            herb = similar.join(', ')
            Room.list.each { |room| target_list.push(room.id) if room.tags.include?(herb) }

            previous, shortest_distances = Map.dijkstra(Room.current.id)

            if location
                target_list.delete_if { |room_num| (Room[room_num].location == nil && Room[room_num].title[0] !~ /#{location}/i) }
                target_list.delete_if { |room_num| (Room[room_num].location != nil && Room[room_num].location !~ /#{location}/i) }
            end
        end
    end

    previous, shortest_distances = Map.dijkstra(CharSettings[:rest_room])
    target_list.delete_if { |room| shortest_distances[room].nil? or shortest_distances[room] > 600 }
}

can_turn_in = proc {
    is_bounty.call ['success', 'success_guard', 'success_heirloom'] and (
        CharSettings[:turn_in_percent].nil? or
        CharSettings[:enable_turn_in_bounty] and not Spell['Next Bounty'].active? or
        percentmind >= CharSettings[:turn_in_percent].to_i and checkmind !~ /saturated/
    )
}

can_do_bounty = proc {
    if not can_do_bounty_cache.nil?
        ; # intentionally left blank
    elsif is_bounty.call ['success', 'success_heirloom', 'success_guard']
        can_do_bounty_cache = true
    elsif is_bounty.call ['task_bandit'] and CharSettings[:enable_bandit]
        can_do_bounty_cache = true
    elsif ((is_bounty.call 'task_search' and CharSettings[:enable_search] and get_bounty_location.call) or (is_bounty.call 'task_heirloom' and CharSettings[:enable_loot] and get_bounty_location.call))
        can_do_bounty_cache = true
    elsif bounty? =~ /#{bounty_patterns['task_forage']}/ and CharSettings[:enable_forage] and not get_herb_rooms.call($2, $1).empty?
        can_do_bounty_cache = true
        # and bounty? !~ /exceptional|outstanding|superb|magnificent/
    elsif is_bounty.call 'task_skin' and CharSettings[:enable_skin] and get_bounty_location.call
        can_do_bounty_cache = true
    elsif is_bounty.call ['task_provoked', 'task_dangerous'] and CharSettings[:enable_dangerous] and get_bounty_location.call
        can_do_bounty_cache = true
    elsif is_bounty.call 'task_cull' and CharSettings[:enable_cull] and get_bounty_location.call
        can_do_bounty_cache = true
    elsif (is_bounty.call 'task_escort' and CharSettings[:enable_rescue]) or (is_bounty.call 'task_rescue' and CharSettings[:enable_rescue] and get_bounty_location.call)
        can_do_bounty_cache = true
    else
        can_do_bounty_cache = false
    end

    $sbounty_can_do_bounty = can_do_bounty_cache

    can_do_bounty_cache
}

should_hunt = proc {
	res = false

	if is_bounty.call ['success', 'success_heirloom', 'success_guard'] and not can_turn_in.call
		res = true
    # on start if less than numb then always try to do bounty
    elsif (can_do_bounty.call and not fried? and not saturated? and first_run)
        res = true
    elsif (not can_do_bounty.call or is_bounty.call ['success', 'success_heirloom', 'success_guard'] or not CharSettings[:enable_hunt_complete]) and percentmind > CharSettings[:should_hunt_mind].to_i
        hunt_reason = 'mind not clear enough'
        ;
    elsif not checkmana(CharSettings[:should_hunt_mana].to_i)
        hunt_reason = 'out of mana'
        ;
    elsif not checkspirit(CharSettings[:should_hunt_spirit].to_i)
        hunt_reason = 'low spirit'
        ;
    else
        res = true
    end

	res
}

should_rest = proc {
    if CharSettings[:should_rest_wounded].call
        rest_reason = 'wounded'
        true
    elsif $sbounty_rest
        if $sbounty_rest_reason
            rest_reason = $sbounty_rest_reason
        else
            rest_reason = '$sbounty_rest was set'
        end

        if $sbounty_rest_until and Time.now.to_i > $sbounty_rest_until
            $sbounty_rest        = false
            $sbounty_rest_reason = nil
            $sbounty_rest_until  = nil
        end

        true
    elsif not checkmana(CharSettings[:should_rest_mana].to_i)
        rest_reason = 'out of mana'
        true
    elsif checkencumbrance(CharSettings[:should_rest_encum].to_i)
        rest_reason = 'encumbered'
        true
    elsif is_bounty.call 'task_provoked'
        false
    elsif is_bounty.call 'task_forage' and can_do_bounty.call and Time.now.to_i < last_forage_attempt + last_forage_delay and percentmind >= CharSettings[:should_rest_mind].to_i
        rest_reason = 'mind is full (waiting on foraging cooldown)'
        true
    elsif ((not can_turn_in.call and is_bounty.call ['success', 'success_guard', 'success_heirloom']) or not can_do_bounty.call or not CharSettings[:enable_hunt_complete]) and percentmind >= CharSettings[:should_rest_mind].to_i
        rest_reason = 'mind is full'
        true
    else
        rest_reason = nil
        false
    end
}

wander = proc { |boundaries|
	room = Room.current
	next_room_options = room.wayto.keys - boundaries
	next_room_options.delete_if { |room_id| (room.timeto[room_id].class == Proc) and room.timeto[room_id].call.nil? }
	next_room = next_room_options.find_all { |r| not $sbounty_wander_rooms.include?(r) }
	if next_room.empty?
		next_room = $sbounty_wander_rooms.find { |r| next_room_options.include?(r) }
	else
		next_room = next_room[rand(next_room.length)]
	end
	$sbounty_wander_rooms.delete(next_room)
	$sbounty_wander_rooms.push(next_room)
	way = room.wayto[next_room]
	if way.class == String
		move(way)
	else
		way.call
	end
}

go2 = proc { |room|
    next if Room.current.id.to_s == room.to_s

    if checkarea =~ /Table/
		if room.to_s == CharSettings[:rest_room].to_s
			next
		end

        fput 'stand' until standing?
        move 'out'
    end

    wait_while { running? 'go2' }
    start_script('go2', [ room.to_s, '_disable_confirm_', '--typeahead=3' ], h={:quiet=>true});
    wait_while { running? 'go2' }
}

go2_nearest = proc { |list|
    room = Room[CharSettings[:rest_room]].find_nearest(list)
    if room.nil?
        error.call "failed to find nearest room"
    end

    go2.call(room)
}

go2_nearest_tag = proc { |tag|
    if checkarea =~ /Table/i
        fput 'stand' until standing?
        fput 'out'
    end

    town = Room[CharSettings[:rest_room]].find_nearest_by_tag('town')
    room = Room[town].find_nearest_by_tag(tag)
    if room.nil?
        error.call "failed to find room by tag: #{tag}"
    end

    go2.call(room)
}

run_commands = proc { |commands|
    next if commands.empty?

    if commands.class != Array
        error.call "run_commands expects an input Array"
    end

    commands.each { |command|
        if command =~ /;/
            scriptname = command.sub(/;/,'')
            start_script scriptname
            wait_while { running? scriptname }
        else
            fput command
        end
    }
}

run_scripts = proc { |scripts|
    scripts.each { |script|
        args   = script.split(' ')
        script = args.shift

        start_script(script, args, true)
        wait_while { running? script }
    }
}

run_loot_script = proc {
    wait_while { running? CharSettings[:loot_script] }
    start_script(CharSettings[:loot_script], [], true)
    wait_while { running? CharSettings[:loot_script] }
}

hunt_prepare = proc {
    run_commands.call(CharSettings[:hunt_pre_commands])
}

start_hunting_scripts = proc {
    CharSettings[:hunting_scripts].each { |script|
        start_script(script, [], h={:quiet=>true}) if not running?(script)
    }
}

kill_hunting_scripts = proc {
    CharSettings[:hunting_scripts].each { |script|
        stop_script(script) if running?(script)
    }
}

rest_goto = proc {
    next if in_rest_area
    go2.call(CharSettings[:rest_room])
}

rest_exit = proc {
    next unless in_rest_area
    if Room.current.id != CharSettings[:rest_room] and Room.current.path_to(CharSettings[:rest_room]).nil?
		run_commands.call(CharSettings[:rest_out_commands])
    end
    in_rest_area = false
}

rest_enter = proc {
    next if in_rest_area
    if Room.current.id != CharSettings[:rest_room] and Room.current.path_to(CharSettings[:rest_room]).nil?
        run_commands.call(CharSettings[:rest_in_commands])
    end
    in_rest_area = true
}

rest_run_scripts = proc {
    rest_exit.call
    run_scripts.call(CharSettings[:rest_scripts])
}

reload_hunter = proc {
    $SBOUNTY_HUNTER_SETUP.call(CharSettings.to_hash.dup, get_bounty_location.call)
    $SBOUNTY_HUNTER_RELOAD.call
}

start_hunter = proc { |location|
    $SBOUNTY_HUNTER_SETUP.call(CharSettings.to_hash.dup, location)
    start_script($SBOUNTY_HUNTER_NAME, [], false)
}

finish_hunt = proc {
    if running? $SBOUNTY_HUNTER_NAME
        stop_script($SBOUNTY_HUNTER_NAME)
        wait_while { running? $SBOUNTY_HUNTER_NAME }
    end
 
    stop_script 'go2' if running? 'go2'
    fput 'stance defensive' until checkstance('defensive') or checkstance('guarded')

    # pause to make sure looter isn't running
    wait_while { running? CharSettings[:loot_script] }

    # run loot script in case the hunter wasn't able to clean up
    if GameObj.npcs.find { |npc| npc.status =~ /dead/ } or is_bounty.call 'success_heirloom'
        run_loot_script.call
    end
}

remove_bounty = proc {
    next if (not CharSettings[:enable_expedite] and Spell['Next Bounty'].active?) or is_bounty.call 'none'

    rest_exit.call

    kill_script 'go2' if running? 'go2'

    go2_nearest_tag.call('advguild')

    print.call 'removing bounty, you have five seconds to kill me'
    sleep 5.00

    npc = GameObj.npcs.find { |t| t.name =~ /taskmaster/i }
    if npc.nil?
        error.call 'failed to find taskmaster'
    end

    res = dothistimeout "ask #{npc} about remove", 5, /^#{npc}.*?want to be removed|Trying to sneak/
    if res =~ /Trying to sneak/
        fput "ask #{npc} about bounty"
    else
        dothistimeout "ask #{npc} about remove", 5, /^#{npc}.*?have removed you/
    end

    can_do_bounty_cache = nil
}

expedite_bounty = proc {
    print.call 'expediting bounty, you have five seconds to kill me'
    sleep 5.00

    remove_bounty.call

    rest_exit.call
    go2_nearest_tag.call('advguild')

    npc = GameObj.npcs.find { |t| t.name =~ /taskmaster/i }
    if npc.nil?
        error.call 'failed to find taskmaster'
    end

    res = dothistimeout "ask #{npc} about expedite", 5, /I'll expedite|You don't seem to have any expedited task reassignment|I still need to complete/
    if res =~ /expedited/
        expedite_left = false
    end

    can_do_bounty_cache = nil
}

get_bounty = proc {
    rest_exit.call

    go2_nearest_tag.call('advguild')

    npc = GameObj.npcs.find { |t| t.name =~ /taskmaster/i }
    res = dothistimeout "ask ##{npc.id} for bounty", 2, /(?:protective escort|creature problem|local gem dealer|local furrier|lost heirloom|local healer|local herbalist|local alchemist|local resident|bandit problem|I'm kind of busy right now)/

    if res.nil?
        error.call 'invalid response from taskmaster'
    elsif res =~ /in about (\d+) minutes|in about a minute/
        time = $1.nil? ? 1 : $1.to_i

        Spell['Next Bounty'].putup
        Spell['Next Bounty'].timeleft = time
    elsif res =~ /bandit/
        remove_bounty.call
    end

    can_do_bounty_cache = nil
}

talk_to_herbalist = proc {
    go2_nearest.call([ 3824, 1851, 10396, 640, 5722, 2406, 11002, 9505 ])

    if Room.current.id == 10396
        npc = 'maraene'
    else
        npc = GameObj.npcs.find { |t| t.name =~ /brother Barnstel|scarred Agarnil kris|healer|herbalist|merchant Kelph|famed baker Leaftoe|Akrash|old Mistress Lomara/i }
    end

    if is_bounty.call 'help_herbalist'
        res = dothistimeout "ask #{npc} about bounty", 5, /Yes, I do have a task for you/
        if res =~ /I've recently received an order for ([0-9]+) (.*?)\./
            print.call "received bounty from herbalist [#{$1} #{$2}]"
        end
    elsif bounty? =~ /#{bounty_patterns['task_forage']}/
        herb_name = $1.gsub(/s?$/,'')
        herbs     = lootsack.contents.find_all { |item| item.name =~ /#{herb_name}/ }

        if herbs.empty?
            error.call 'no herbs to turn in, why are you here?'
        end

        prev_item = nil
        if GameObj.right_hand
            prev_item = GameObj.right_hand

            fput 'store right' if checkright
            fput 'stow right' if checkright
        end

        herbs.each { |herb|
            fput "get ##{herb.id} from ##{lootsack.id}"
            result = dothistimeout "give ##{herb.id} to #{npc}", 3, /This looks perfect|That looks like it has been partially used up/

            if result !~ /perfect/
                fput "drop ##{herb.id}"
            end
        }

        if prev_item
            fput "get ##{prev_item.id}"
        end
    else
        error.call 'why are you at the herbalist?'
    end
}

talk_to_gemdealer = proc {
    if bounty? =~ /Tanzania/
        go2.call(1439) #this fixes gem bounties in Illistim when your rest room is set in Cysaegir
    else    
        go2_nearest_tag.call('gemshop')
    end

    if Room.current.id == 10327
        npc = 'areacne'
    else
        npc = GameObj.npcs.find { |t| t.name =~ /dwarven clerk|gem dealer|jeweler|Zirconia/i }
    end

    res = dothistimeout "ask #{npc} about bounty", 5, /Yes, I do have a task for you/
    if res =~ /interested in purchasing an? (.*?)\. .* go round up ([0-9]+) of them/
        name  = $1
        count = $2.to_i

        print.call "-- received bounty from gem dealer [#{count} #{name}]"
    end
}

talk_to_furrier = proc {
    if bounty? =~ /Gaedrein/
        go2.call(4019) #this fixes skin bounties in Illistim when your rest room is set in Cysaegir
    else    
        go2_nearest_tag.call('furrier')
    end

    if Room.current.id == 10327
        npc 'areacne'
    else
        npc = GameObj.npcs.find { |t| t.name =~ /dwarven clerk|furrier/i }
    end

    res = dothistimeout "ask #{npc} about bounty", 5, /Yes, I do have a task for you/
    if res =~ /I've recently received an order for ([0-9]+) (.*?)\./
        print.call "received bounty from furrier [#{$1} #{$2}]"
    end
}

get_guard_npc = proc {
    if Room.current.id == 10915
        'purser'
    else
        GameObj.npcs.find { |npc| npc.name =~ /guard|sergeant|guardsman|purser|Belle/i }
    end
}

find_guard = proc {
    go2_nearest_tag.call('advguard')
    npc = get_guard_npc.call

    if npc.nil?
        go2_nearest_tag.call('advguard2')
        npc = get_guard_npc.call
    end

    if npc.nil?
        error.call "failed to locate guard"
    end

    npc
}

talk_to_guard = proc {
    npc = find_guard.call

    res = dothistimeout "ask #{npc} about bounty", 5, /Yes, we do have a task for you|Ah, so you have returned/
    if res.nil?
        print.call "unknown response from guard: #{res}"
    end
}

get_random_location = proc {
    keys = []
    CharSettings[:locations].each { |key, data|
        if data[:enable_hunting_rotation]
            keys.push(key)
        end
    }
    name = keys[rand(keys.size)]

    if name.nil?
        error.call 'failed to find a hunting area'
    end

    [ name, CharSettings[:locations][name] ]
}

task_escort = proc { |target|

    print.call "escorting child to nearest dropoff"
    dropoff_points = Room.current.find_all_nearest_by_tag("advguard") + Room.current.find_all_nearest_by_tag("advguard2") + [2777, 2778, 2782, 2779, 2780, 2781, 2783, 2784, 2785, 2786, 2787]

    1.times {
        path  = []
        step2 = proc { |destination_room|
            unless path and (s = path.index(Room.current.id)) and (d = path.index(destination_room)) and (s < d)
                previous, shortest_distances = Map.dijkstra(Room.current.id, destination_room)
                unless previous[destination_room]
                    echo "error: failed to find a path between your current room (#{Room.current.id}) and destination room (#{destination_room})"
                    exit
                end
                path = [ destination_room ]
                path.push(previous[path[-1]]) until previous[path[-1]].nil?
                path.reverse!
                previous = shortest_distances = nil
            end

            nextroom = path[path.index(Room.current.id)+1].to_s
            if nextroom =~ /9734/
                #we are trying to get out of Maaghara's Tower and need special script
            end

            way = Room.current.wayto[nextroom]

            if way.class == String
                move way
            elsif way.class == Proc
                way.call
            end
        }

        waitrt?
        fput 'stance defensive' unless checkstance('guarded')

        #destination = Room[CharSettings[:rest_room]].find_nearest_by_tag(target)
        place = Room.current.find_nearest(dropoff_points)
        destination = place
        while Room.current.id != destination and is_bounty.call 'task_escort'
            if GameObj.npcs.find { |n| n.name =~ /child/i }
                step2.call(destination)
            end
            sleep 0.25
        end
        if is_bounty.call 'fail_child'
            print.call 'failed to escort child or child was killed'
        elsif npc = get_guard_npc.call
            print.call 'waiting for child to arrive'
            wait_until { GameObj.npcs.find { |n| n.name =~ /child/ } }

            if npc.class == String
                fput "ask #{npc} for bounty"
            else
                fput "ask ##{npc.id} for bounty"
            end
        else
            #no guard is here
            dropoff_points.delete(place)
            redo
        end
    }
}

task_search = proc {
    if bounty? !~ /#{bounty_patterns['task_search']}/
        error.call 'you are not on a search bounty'
    end

    print.call 'searching for heirloom'

    name, location = get_bounty_location.call
    song_of_peace  = false
    invalid_rooms  = []
    last_room      = nil

    hunt_prepare.call
    rest_exit.call

    go2.call location[:room]

    start_hunting_scripts.call

    while is_bounty.call 'task_search' and not CharSettings[:should_rest_wounded].call
        if Spell[1011].known? and Spell[1011].affordable? and not song_of_peace
            Spell[1011].cast
            song_of_peace = true
		elsif Spell[506].known? and Spell[506].affordable? and not Spell[506].active?
			Spell[506].cast
        end

        wander.call location[:boundaries]

        fput 'stand' until standing?
        fput 'stance defensive' until checkstance 'defensive' or checkstance 'guarded'

        if (GameObj.npcs.empty? or GameObj.npcs.nil?) and Room.current.location =~ /#{location[:location].downcase.strip}/i and not invalid_rooms.include?(Room.current.id) and Room.current.id != last_room
            run_commands.call(CharSettings[:pre_search_commands])

            fput 'kneel' until kneeling?

            res = dothistimeout 'search', 1, /You intently search the area|You put your head to the/
            if res =~ /You intently search the area|You put your head to the/
                last_room = Room.current.id
            else
                print.call 'invalid room, skipping in the future'
                invalid_rooms.push Room.current.id
            end

            waitrt?

            run_commands.call CharSettings[:post_search_commands]

            while not checkstance 'offensive' and (song_of_peace or GameObj.npcs.find_all { |npc| npc.status !~ /dead/ }.nil?)
                fput 'stance offensive'
				sleep 0.10
            end

            fput 'stand' until standing?

            fput 'stance defensive' until checkstance 'defensive' or checkstance 'guarded'

            if is_bounty.call 'task_found'
                run_loot_script.call
                break
            end
        end
    end

    waitrt?

    if song_of_peace
        fput "stop 1011"
    end

    kill_hunting_scripts.call
}

task_bandit = proc {
    if bounty? !~ /#{bounty_patterns['task_bandit']}/
        error.call('you are not on a bandits bounty')
    end

    print.call('culling bandits')

    my_ambush = false
    ambush_room_count = XMLData.room_count

    location = $1.strip.downcase
    rooms = Room.list.find_all { |r| r.location =~ /#{location}/i }.collect { |r| r.id }

    if CharSettings[:enable_bandit_script] and not Script.exists?(CharSettings[:bandit_script])
        error.call('bandit script is enabled could not be found')
    end

    start_hunting_scripts.call

    while not CharSettings[:should_rest_wounded].call and is_bounty.call('task_bandit')
        rooms.each { |room|
            waitrt?
            waitcastrt?

            print.call 'moving to room ' + room.to_s

            fput 'stance defensive' unless checkstance == 'defensive'

            go2.call(room)

            print.call('waiting for attack')

            start = Time.now.to_i
            while true
                if Time.now.to_i - start > 1
                    break
                end

                if GameObj.npcs.find { |npc| npc.type =~ /bandit/ }
                    break
                end

                sleep 0.25
            end

            while not CharSettings[:should_rest_wounded].call()
                npcs = GameObj.npcs.to_a.find_all { |npc| npc.type =~ /bandit/ and npc.status !~ /dead/ }
                dead = GameObj.npcs.to_a.find_all { |npc| npc.type =~ /bandit/ and npc.status =~ /dead/ }

                if npcs.empty?
                    break
                elsif CharSettings[:enable_bandit_script]
                    waitrt?
                    waitcastrt?

                    if not dead.empty?
                        run_loot_script.call()
                    else
                        start_script(CharSettings[:bandit_script], npcs.collect { |n| n.id }, h={:quiet=>true})
                        wait_while { running?(CharSettings[:bandit_script]) }
                    end
                else
                    print.call('kill them all then unpause me!')
                    script.pause
                end

                sleep 0.25
            end

            break if CharSettings[:should_rest_wounded].call or not is_bounty.call('task_bandit')
        }

        rooms.reverse!

        sleep 0.1
    end

    kill_hunting_scripts.call
}

task_forage = proc {
    if bounty? !~ /#{bounty_patterns['task_forage']}/
        error.call 'you are not on a forage bounty'
    end

    herb     = $1
    location = $2
    count    = $3.to_i

    print.call("foraging for #{count} #{herb} at #{location}")

    herb = herb.downcase

    refresh_spells = proc {
        [506, 603, 9704].each { |spell|
            if Spell[spell].known? and not Spell[spell].active? and Spell[spell].affordable?
                waitrt?
                waitcastrt?

                Spell[spell].cast
            end
        }

        yierka          = Spell['AA: Yierka']
        yierka_cooldown = Spell['AA: Yierka Cooldown']

        if yierka.known? and yierka.affordable? and not yierka_cooldown.active?
            yierka.cast
        end
    }

    get_herb_count = proc {
        lootsack.contents.find_all { |item| item.name =~ /#{herb.gsub(/s?$/,'')}/i }.size
    }

    last_forage_attempt = Time.now.to_i

    if get_herb_count.call < count
        hunt_prepare.call
        rest_exit.call

        rooms = get_herb_rooms.call(location, herb)
        bright_rooms = []

        cur_room  = 0
        num_tries = 0

        song_of_peace = false

        start_hunting_scripts.call

        while get_herb_count.call < count and not CharSettings[:should_rest_wounded].call and num_tries < 3
            sanct_cast = false
            light_cast = false

            go2.call(rooms[cur_room])
            cur_room = cur_room + 1

            if cur_room >= rooms.length
                cur_room  = 0
                num_tries = num_tries + 1
            end

            while get_herb_count.call < count and rooms.length > 0 and not CharSettings[:should_rest_wounded].call
                if Spell[1011].known? and Spell[1011].affordable? and not song_of_peace
                    Spell[1011].cast
                    song_of_peace = true
                end

                waitrt?
                fput 'stance defensive' until ['defensive', 'guarded'].include?(checkstance)

                refresh_spells.call

                if not song_of_peace and not GameObj.npcs.find_all { |npc| npc.type =~ /aggressive/ && npc.status !~ /dead|gone/ }.nil?
                    break
                end

                if not kneeling?
                    run_commands.call(CharSettings[:pre_search_commands])
                    fput "kneel" until kneeling?
                end

                if Spell[213].known? and Spell[213].affordable? and not sanct_cast
                    sanct_cast = true
                    fput "incant 213"
                    waitcastrt?
                end

                if Spell[205].known? and Spell[205].affordable? and not bright_rooms.include?(cur_room) and not light_cast
                    light_cast = true
                    fput "incant 205"
                    bright_rooms.push(cur_room)
                    waitcastrt?
                end

                res = dothistimeout "forage #{herb.gsub(/(?:(?:handful|bunch|sprig) of|fragrant|fetid)\s+/, '') }", 1, /not even positive|it could be|it could even be found|and manage to find|Roundtime|In order to forage|foraging here recently/

			    if res =~ /it could be|it could even be found|not even positive/
                    rooms.delete_at(cur_room)
				    break
			    elsif res =~ /and manage to find/
                    fput "put #{checkleft} in ##{lootsack.id}" while checkleft =~ /#{herb}/ || (!checkleft.nil? && herb =~ /#{checkleft}/)
                    fput "put #{checkright} in ##{lootsack.id}" while checkright =~ /#{herb}/ || (!checkright.nil? && herb =~ /#{checkright}/)

				    print.call "-- success, found #{get_herb_count.call} of #{count} #{herb}"
			    elsif res =~ /In order to forage/
				    fput "stow all"
			    elsif res =~ /foraging here recently/
                    print.call 'herb can not be found here, skipping room...'
                    rooms.delete_at(cur_room)
				    break
			    else
			        print.call "failure, found #{get_herb_count.call} of #{count} #{herb}"
			    end
            end

            # Sanity check, cleanup any remaining herbs
            fput "put #{checkleft} in ##{lootsack.id}" while checkleft =~ /#{herb}/ || (!checkleft.nil? && herb =~ /#{checkleft}/)
            fput "put #{checkright} in ##{lootsack.id}" while checkright =~ /#{herb}/ || (!checkright.nil? && herb =~ /#{checkright}/)

            if not standing?
                run_commands.call(CharSettings[:post_search_commands])

                while not checkstance 'offensive' and (song_of_peace or GameObj.npcs.find_all { |npc| npc.type =~ /aggressive/ && npc.status !~ /dead/ }.nil?)
                    fput 'stance offensive'
					sleep 0.10
                end

                fput "stand" until standing?
                fput 'stance defensive' until checkstance 'defensive' or checkstance 'guarded'
            end
        end
    end

    if song_of_peace
        fput "stop 1011"
    end

    if get_herb_count.call >= count
        talk_to_herbalist.call
        last_forage_attempt = 0
    end

    kill_hunting_scripts.call
}

success_heirloom = proc {
    print.call 'turning in heirloom'

    npc = find_guard.call

    empty_hands

    close = false
    if lootsack.contents.nil?
        open_result = dothistimeout "open ##{lootsack.id}", 5, /^You open|^That is already open\.$/
        if open_result =~ /^You open/
            close = true
        else
            dothistimeout "look in ##{lootsack.id}", 5, /In .*? you see/
        end
    end

    found = false
    bounty? =~ /#{bounty_patterns['success_heirloom']}/
    heirloom_name = $1
    echo "Looking for #{heirloom_name}"
    lootsack.contents.each { |item|
        if item.name =~ /#{heirloom_name}/
            res = dothistimeout "look ##{item.id}", 2, /^Engraved .* initials|^You see nothing unusual\.$|^The ring appears|^It takes you a moment|^It is difficult to see/
            if res =~ /^Engraved .* initials/
                fput "get ##{item.id}"
                fput "give ##{item.id} to #{npc}"
                found = true

                break
            end
        end
    }

    fput "close ##{lootsack.id}" if close

    if not found
        error.call 'failed to find heirloom for guard'
    end

    fill_hands
}

turn_in = proc {
    rest_exit.call

    if is_bounty.call 'success_guard'
        talk_to_guard.call
    elsif is_bounty.call 'success_heirloom'
        success_heirloom.call
    end

    go2_nearest_tag.call('advguild')

    npc = GameObj.npcs.find { |t| t.name =~ /taskmaster/i }
    res = dothistimeout "ask #{npc} about bounty", 5, /^#{npc}.*?done with that assignment/
    10.times {
        if line = get? and line =~ /You have earned ([0-9]+) bounty points?, ([0-9]+) experience points, and ([0-9]+) silver\./
            print.call "finished task (#{$1} points, #{$2} exp, #{$3} silver)"
            break
        end

        sleep 0.1
    }

    run_loot_script.call
    can_do_bounty_cache = nil
    $sbounty_can_do_bounty = nil
}

talk_to_npc = proc {
    if is_bounty.call ['help_creature', 'help_resident', 'help_heirloom', 'success_guard']
        talk_to_guard.call
    # separate bandits so we don't trigger them on accident while walking
    elsif is_bounty.call ['help_bandit'] and CharSettings[:enable_bandit]
        talk_to_guard.call
    elsif is_bounty.call 'help_furrier'
        talk_to_furrier.call
    elsif is_bounty.call 'help_herbalist'
        talk_to_herbalist.call
    elsif is_bounty.call 'help_gemdealer'
        talk_to_gemdealer.call
    end
}

help = proc {
    respond
    respond 'SpiffyBounty by SpiffyJr (theman@spiffyjr.me)'
    respond 'usage: ;sbounty [hunter=bigshot]'
    respond
}

hunter        = CharSettings[:hunter]
task_accepted = false
resting       = false

start_script(hunter, nil, true)
wait_while { running? hunter }

if script.vars[1] =~ /^setup$/i
    setup.call
    exit
elsif script.vars[1] =~ /^help$/i
    help.call
    exit
elsif script.vars[1] =~ /^forage$/i
    task_forage.call
    exit
elsif script.vars[1] =~ /^bandits?$/i
    task_bandit.call
    exit
elsif script.vars[1] =~ /^npc$/i
    talk_to_npc.call
    exit
elsif script.vars[1] =~ /^load$/i
    location = nil
    if script.vars[2]
        target = script.vars[2]
        locations = CharSettings[:locations].dup
        location = locations.find { |name, data| $SBOUNTY_CLEAN_TARGETS.call(data[:targets]).find { |t| target =~ /#{t}/i } }
    end
    $SBOUNTY_HUNTER_SETUP.call(CharSettings.to_hash.dup, get_bounty_location.call(location,target))
    exit
elsif script.vars[1] =~ /^check$/i
    can_do_bounty.call
    exit
elsif script.vars[1]
    CharSettings[:hunter] = "sbounty-#{script.vars[1]}"
end


if not defined? $SBOUNTY_HUNTER_SETUP
    error.call 'hunter setup was not defined'
elsif not defined? $SBOUNTY_HUNTER_NAME
    error.call 'hunter name was not defined'
elsif not defined? $SBOUNTY_HUNTER_RELOAD
    error.call 'hunter reload was not defined'
end

before_dying {
    kill_script($SBOUNTY_HUNTER_NAME) if running?($SBOUNTY_HUNTER_NAME)
    kill_hunting_scripts.call
}

Thread.new {
    wait_until { dead? }
    exit
}

while true
    talk_to_npc.call

    if can_do_bounty.call and not CharSettings[:should_rest_wounded].call
        if is_bounty.call 'task_search'
            task_search.call
        elsif is_bounty.call 'task_forage' and Time.now.to_i >= last_forage_attempt + last_forage_delay
            task_forage.call
        end
    elsif Spell['Next Bounty'].active? and (expedite_left and not is_bounty.call 'none' and not can_do_bounty.call and CharSettings[:enable_expedite])
        expedite_bounty.call
        next
    end

    if is_bounty.call 'task_escort' and GameObj.npcs.find { |npc| npc.name =~ /child/ }
        task_escort.call 'advguard'
    elsif is_bounty.call 'task_fail'
        can_do_bounty_cache = nil
    elsif is_bounty.call 'success_heirloom'
        success_heirloom.call
    end

    exit if dead?

    if can_turn_in.call
        turn_in.call
        resting = false
    else
        if not can_do_bounty.call and not Spell['Next Bounty'].active?
            remove_bounty.call
            get_bounty.call
        elsif should_hunt.call and not should_rest.call and not has_skins.call
            resting   = false
            provoked  = false
            success   = false
            first_run = false
            bounty    = bounty?

            rest_exit.call
            hunt_prepare.call

            # default hunter location
            if can_do_bounty.call
                # order is important here - bandits and regular culling look similar
                if is_bounty.call ['task_bandit']
                    task_bandit.call
                elsif is_bounty.call ['task_cull', 'task_dangerous', 'task_heirloom', 'task_rescue', 'task_skin']
                    start_hunter.call(get_bounty_location.call)
                else
                    start_hunter.call(get_random_location.call)
                end
            else
                start_hunter.call(get_random_location.call)
            end

            while not should_rest.call and running? $SBOUNTY_HUNTER_NAME
                if bounty? =~ /#{bounty_patterns['task_provoked']}/ and not provoked
                    reload_hunter.call
                    provoked = true
                elsif is_bounty.call 'task_escort'
                    break
                elsif has_skins.call
                    break
                elsif not success and (bounty? != bounty and (is_bounty.call [ 'success', 'success_heirloom' ] or (provoked and is_bounty.call 'success_guard')))
                    finish_hunt.call
                    start_hunter.call(get_random_location.call)

                    success = true
                elsif can_turn_in.call
                    break
                #elsif not can_do_bounty.call and not Spell['Next Bounty'].active?
                #    break
                end

                sleep 0.10
            end

            finish_hunt.call
        elsif not can_turn_in.call
            rest_goto.call
            rest_enter.call

            if not resting or CharSettings[:should_rest_wounded].call
                rest_run_scripts.call
                rest_goto.call
                rest_enter.call

                sleep 1
            end

            while should_rest.call or not should_hunt.call
                if can_turn_in.call
                    break
                elsif CharSettings[:should_rest_wounded].call
                    break
                elsif not can_do_bounty.call and not Spell['Next Bounty'].active?
                    break
                end

                fput 'exp'

                if rest_reason.nil?
                    rest_reason = hunt_reason
                end
                print.call "still resting because: #{rest_reason}"

                sleep CharSettings[:rest_sleep_interval]
            end

            resting = true
            rest_exit.call
        end
    end

    sleep 0.10
end
