=begin
 
     help:                    ;forge-perfects ? 
     current Settings:        ;forge-perfects display
     gui:                     ;forge-perfects setup

    ;forge-perfects will start it if you have it set up right (also ;forge- or ;forge, etc will work if you're lazy)

  IMPORTANT (READ THIS DAMNIT):
     ~Oil type (if needed) will auto-determined. 
     ~Leaving the Average and Scrap settings BLANK will cause those pieces to be discarded.
     ~Block, Slab, Keeper, and Scrap containers MUST be different, although the last one is optional.
     ~'Average' & 'Keeper' containers should be different as finished pieces are identical-looking.
     ~To make HANDLES, set handle order # for glyph, and wood OR metal for material.
     ~This script DOES NOT COMBINE/VISE the pieces for you...thats the fun part!!

 Authors: Moredin (forging stuff) & Tillek (GUI, squelching, iron-making.)
 Problems or suggestions: contact Moredin who is maintaining the script.
 Moredin:  Moredin7@gmail.com
 Category: Artisan
 Tags: forging, forge, craft, artisan, perfect
 
 UPDATES:
 Early 2011 -> heavily modified Dalem's dforge script.
 Sept 2011 	-> fixed measuring the stand-alone hammerhead glyph for forging hammer heads.
 Jan 2012 	-> fixed citizenship buying bug
 Mar 2012 	-> fixed forging-hammer hang bugs.  thanks to Kuirit
			-> broke buying for non-citizens by accident when i fixed it for citizens.  error gone now and should work fine.  my bad!
			-> fixed a problem with the oil section of the script, and cleaned it up a little bit.  also added the oil type for rare metal slabs...props to Gizmo!
			-> fixed more bugs.  thanks to Gizmo for pointin em out.
 03/29/12	-> fixed and reworked the scrap-selling part which I dont think many people actually used because it only activates if the scrap_container fills up.
 
 LET ME KNOW IF SOMETHING DOESN'T WORK.

=end
#Notes to self:
#
#GSIV:Kuirit: "No, it like hangs up, like a moment ago with blocks...it went to turn the grinder but wouldn't budge since time ran out, 
#after it did that it inputted "put block in""
#GSIV:Kuirit: "Also hangs up sometimes when I have a leftover block, it won't trash it when polishing my best piece"
#
#


Oil_trough = {
	"water" => "some water",
	"tempering oil" => "some oil",
	"enchanted oil" => "some iridescent oil",
	"twice-enchanted oil" => "some opalescent oil",
	"ensorcelled oil" => "some dimly glowing oil"
}

Material_oil = {
	"bronze" => "water",
	"iron" => "water",
	"steel" => "tempering oil",
	"invar" => "tempering oil",
	"faenor" => "enchanted oil",
	"mithril" =>  "enchanted oil",
	"ora" => "enchanted oil",
	"drakar" => "enchanted oil",
	"gornar" => "enchanted oil",
	"rhimar" => "enchanted oil",
	"zorchar" => "enchanted oil",
	"kelyn" => "enchanted oil",
	"imflass" => "twice-enchanted oil",
	"razern" => "twice-enchanted oil",
	"eahnor" => "ensorcelled oil",
	"mithglin" => "ensorcelled oil",
	"vaalorn" => "ensorcelled oil",
	"vultite" => "ensorcelled oil",
	"rolaren" => "ensorcelled oil",
	"veil iron" => "ensorcelled oil",
	"eonake" => "ensorcelled oil",
	"golvern" => "ensorcelled oil"
}

Oil_order = {
	"tempering oil" => 5,
	"enchanted oil" => 6,
	"twice-enchanted oil" => 7,
	"ensorcelled oil" => 8
}

Settings.load
before_dying { Settings.save }

forger = Object.new 
settings 					= Settings.to_hash

setup = proc {
	gtk_globals = Hash.new
	gtk_locals = Hash.new

	window = window_action = nil
	Gtk.queue {
	ttips = Gtk::Tooltips.new.enable
		ttips_text = { 
			'average_container' => "Container that will contain all your completed pieces that are not perfect\nIf left blank, average pieces will be trashed instead\n\nAverage and Keeper containers must be different!",
			'keeper_container' 	=> "Container that will contain all your perfect pieces\n\nAverage and Keeper containers must be different!",	
			'oil_container' 	=> "Container that will contain your oil\n\nCan be left blank if you are using bronze or iron for your forging material",
			'block_container'	=> "Container that will contain your cut slab pieces\n\nMust be different than Fresh and Leftover containers",
			'slab_container'	=> "Container that will contain your fresh slabs\n\nMust be different than Cut and Leftover containers",
			'scrap_container'	=> "Container that will contain your leftover cut pieces\nIf left blank, leftover cut pieces will be trashed instead\n\nMust be different than Fresh and Cut containers",
			'glyph_container'	=> "Container that will contain your forging glyph",
			'material_noun'		=> "Noun of your forging material\nExample: bar",
			'material_name'		=> "Name of your forging material\nExample: bronze",
			'material_no'		=> "Order number of your forging material\nExample: 2",
			'glyph_name'		=> "Name of your forging glyph\nExample: blade-glyph\n\nWhen making forging hammers, use head-glyph, etc.",
			'glyph_no'			=> "The order number for the forging glyph\nExample: 44\n\nIf using the forging-hammer glyphs, leave BLANK\nOtherwise: Put 99 here.",
			'glyph_material'	=> "Custom Material of your forging glyph\nExample: wax\n\nNot applicable to forging-hammer glyphs",
			'make_hammers'		=> "Will make hammer-heads and hammer-handles from the workshop glyphs.\nSpecify handle-glyph or head-glyph above!\n\nOther glyph fields are ignored.",
			'surge'				=> "Will perform the Combat Manuever \"Surge of Strength\" at the appropriate places while forging",
			'squelch'			=> "Will remove the annoying screen scroll that happens when you perform forging actions\n\nCourtesy of Gibreficul\nTHANKS GIB!",
			'make_iron'			=> "Makes iron in kobold mines rather than buying it\nREQUIRES Iron.lic script",
		}
	
		gtk_locals['average_container'] 	= Gtk::Entry.new.set_text(settings['average_container'])
		gtk_locals['keeper_container'] 		= Gtk::Entry.new.set_text(settings['keeper_container'])
		gtk_locals['oil_container'] 		= Gtk::Entry.new.set_text(settings['oil_container'])
		gtk_locals['block_container'] 		= Gtk::Entry.new.set_text(settings['block_container'])
		gtk_locals['slab_container'] 		= Gtk::Entry.new.set_text(settings['slab_container'])
		gtk_locals['scrap_container'] 		= Gtk::Entry.new.set_text(settings['scrap_container'])
		gtk_locals['glyph_container'] 		= Gtk::Entry.new.set_text(settings['glyph_container'])
		gtk_locals['material_noun'] 		= Gtk::Entry.new.set_text(settings['material_noun'])
		gtk_locals['material_name'] 		= Gtk::Entry.new.set_text(settings['material_name'])
		gtk_locals['material_no'] 			= Gtk::Entry.new.set_text(settings['material_no'])
		gtk_locals['glyph_name'] 			= Gtk::Entry.new.set_text(settings['glyph_name'])
		gtk_locals['glyph_no'] 				= Gtk::Entry.new.set_text(settings['glyph_no'])
		gtk_locals['glyph_material'] 		= Gtk::Entry.new.set_text(settings['glyph_material'])
		gtk_locals['make_hammers'] 			= Gtk::CheckButton.new('Make FORGING-HAMMER pieces with the free glyph').set_active(settings['make_hammers'])
		gtk_locals['surge'] 				= Gtk::CheckButton.new('Use CMan Surge of Strength').set_active(settings['surge'])
		gtk_locals['squelch'] 				= Gtk::CheckButton.new('Squelch Forging Screen Scroll').set_active(settings['squelch'])
		gtk_locals['make_iron'] 			= Gtk::CheckButton.new('Make Iron in Kobold Mines').set_active(settings['make_iron'])
		
		# Add tooltips
		ttips_text.each_pair { |widget,tip|
			if widget = gtk_globals[widget] || gtk_locals[widget]
				ttips.set_tip(widget,tip,'')
			end
		}
		
		# Primary Window
			window = Gtk::Window.new
			window.title = "Forge Perfects"
			window.border_width = 3
			window.resizable = false
			window.resize(450, 300)
					
			# Notebooks for tabs at the top
			nb = Gtk::Notebook.new.set_show_border(true).set_tab_border(3)
			
			#
			# Notebook Page 1 - Sacks
			#
			vb_pg1 = Gtk::VBox.new(false,1).set_border_width(3)
			
			#
			# Page 1, Frame 1 - Sacks
			#
			vb_pg1_1 = Gtk::VBox.new(false,1).set_border_width(3)
			fr_pg1_1 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('Container Options'))
			fr_pg1_1.add(vb_pg1_1)
			vb_pg1.pack_start(fr_pg1_1,false)

			lbl = Gtk::Label.new.set_markup("<b>*MOUSE OVER FIELDS FOR IMPORTANT INFO*</b>")
			lbl.set_wrap(true).set_width_request(250).set_padding(0,0)
			vb_pg1_1.pack_start(lbl,false)
			
			hb = Gtk::HBox.new(false,1)
			hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Average Container:')),true)
			hb.pack_start(gtk_locals['average_container'],false)
			vb_pg1_1.pack_start(hb,false)
			
			hb = Gtk::HBox.new(false,1)
			hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Keeper Container:')),true)
			hb.pack_start(gtk_locals['keeper_container'],false)
			vb_pg1_1.pack_start(hb,false)
			
			hb = Gtk::HBox.new(false,1)
			hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Oil Container:')),true)
			hb.pack_start(gtk_locals['oil_container'],false)
			vb_pg1_1.pack_start(hb,false)
			
			hb = Gtk::HBox.new(false,1)
			hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Cut Slab Container:')),true)
			hb.pack_start(gtk_locals['block_container'],false)
			vb_pg1_1.pack_start(hb,false)

			hb = Gtk::HBox.new(false,1)
			hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Fresh Slab Container:')),true)
			hb.pack_start(gtk_locals['slab_container'],false)
			vb_pg1_1.pack_start(hb,false)
			
			hb = Gtk::HBox.new(false,1)
			hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Leftover Cut Slabs Container:')),true)
			hb.pack_start(gtk_locals['scrap_container'],false)
			vb_pg1_1.pack_start(hb,false)
			
			hb = Gtk::HBox.new(false,1)
			hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Glyph Container:')),true)
			hb.pack_start(gtk_locals['glyph_container'],false)
			vb_pg1_1.pack_start(hb,false)
			
			vb_pg1_2 = Gtk::VBox.new(false,1).set_border_width(3)
			fr_pg1_2 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('Material Order Options'))
			fr_pg1_2.add(vb_pg1_2)
			vb_pg1.pack_start(fr_pg1_2,false)
			
			hb = Gtk::HBox.new(false,1)
			hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Name:')),true)
			hb.pack_start(gtk_locals['material_name'],false)
			vb_pg1_2.pack_start(hb,false)
			
			hb = Gtk::HBox.new(false,1)
			hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Noun:')),true)
			hb.pack_start(gtk_locals['material_noun'],false)
			vb_pg1_2.pack_start(hb,false)
			
			hb = Gtk::HBox.new(false,1)
			hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Order #:')),true)
			hb.pack_start(gtk_locals['material_no'],false)
			vb_pg1_2.pack_start(hb,false)
			
			vb_pg1_3 = Gtk::VBox.new(false,1).set_border_width(3)
			fr_pg1_3 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('Glyph Order Options'))
			fr_pg1_3.add(vb_pg1_3)
			vb_pg1.pack_start(fr_pg1_3,false)
			
			hb = Gtk::HBox.new(false,1)
			hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Name:')),true)
			hb.pack_start(gtk_locals['glyph_name'],false)
			vb_pg1_3.pack_start(hb,false)
			
			hb = Gtk::HBox.new(false,1)
			hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Order Material:')),true)
			hb.pack_start(gtk_locals['glyph_material'],false)
			vb_pg1_3.pack_start(hb,false)
			
			hb = Gtk::HBox.new(false,1)
			hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Order #:')),true)
			hb.pack_start(gtk_locals['glyph_no'],false)
			vb_pg1_3.pack_start(hb,false)
			
			hb = Gtk::HBox.new(false,1)
			hb.pack_start(gtk_locals['make_hammers'].set_width_request(300),false)
			vb_pg1_3.pack_start(hb,false)
			
			vb_pg1_4 = Gtk::VBox.new(false,1).set_border_width(3)
			fr_pg1_4 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('Miscellaneous Options'))
			fr_pg1_4.add(vb_pg1_4)
			vb_pg1.pack_start(fr_pg1_4,false)
			
			hb = Gtk::HBox.new(false,1)
			hb.pack_start(gtk_locals['surge'].set_width_request(300),false)
			vb_pg1_4.pack_start(hb,false)
			
			hb = Gtk::HBox.new(false,1)
			hb.pack_start(gtk_locals['squelch'].set_width_request(300),false)
			vb_pg1_4.pack_start(hb,false)
			
			hb = Gtk::HBox.new(false,1)
			hb.pack_start(gtk_locals['make_iron'].set_width_request(300),false)
			vb_pg1_4.pack_start(hb,false)
			
			nb.append_page(vb_pg1,Gtk::Label.new('Setup'))
		
		
		# Save/Close buttons
		hb_saveclose = Gtk::HBox.new
		save = Gtk::Button.new('_Save & Close')
		close = Gtk::Button.new('E_xit')
		
		save.signal_connect('clicked') { window_action = :save }
		close.signal_connect('clicked') { window_action = :done }
		
		hb_saveclose.pack_start(save,false)
		hb_saveclose.pack_start(close,false)
		
		# Primary VerticalBox to split up Notebook and Save/Close buttons
		vb_main = Gtk::VBox.new(false,5)
		vb_main.border_width = 3
		
		vb_main.pack_start(nb,false)
		vb_main.pack_start(Gtk::Alignment.new(1,0,0,0).add(hb_saveclose),false)
		
		window.signal_connect('delete_event') { respond window.allocation.width; window_action = :exit }
		
		window.add(vb_main)	
		window.show_all
		window.keep_above = true # On windows keep_above is required AFTER show_all
	}
	
	before_dying { Gtk.queue { window.destroy } }
	wait_while { window_action.nil? }
	undo_before_dying # Don't ask me what this does - I stripped it from Tillmen's code
	Gtk.queue { window.destroy }
	
	clean_entry = proc { |entry|
		entry.text = entry.text.strip
		if entry.text.empty?
			entry.text = nil
		end
		
		entry.text
	}
		
	if window_action == :save	
		gtk_locals.each_pair { |option,widget|
			if widget.class == Gtk::CheckButton
				Settings[option] = widget.active?
			elsif widget.class == Gtk::Entry
				Settings[option] = clean_entry.call(widget)
			else
				echo "error: unknown local widget #{option} [#{widget.class}]"
			end
		}
		
		echo 'Settings saved'
	else
		echo 'Closed without saving'
	end
	exit
}

class << forger
	attr_accessor :keeper_container, :oil_container, 
	:wastebin, :block_container, :material_no,
	:material_name, :slab_container, :glyph_no, :glyph_name,
	:glyph_material, :scrap_container, :size, :keepers, :average_container,
	:DEBUG
	
	Rent = 300
	
	Targets = {
		"Ta'Illistim" => {
			'town'		=>   188,
			'wastebin'	=> 'bin'
		},
		"Wehnimer's Landing" => { 
			'town'		=>   228,
			'wastebin'	=> 'bin'
		},
		'Solhaven' => { 
			'town'		=>  1438,
			'wastebin'	=> 'bin'
		},
		'Icemule Trace' => { 
			'town'		=>  2300,
			'wastebin'	=> 'bin'
		},
		'Teras Isle' => {
			'town'		=>  1932,
			'wastebin'	=> 'barrel'
		},
		"River's Rest" => { 
			'town'		=> 10861,
			'wastebin'	=> 'bin'
		},
		'Zul Logoth' => {
			'town'		=>  1005,
			'wastebin'	=> 'barrel'
		},
		"Ta'Vaalor" => {
			'town'		=>  3519,
			'wastebin'	=> 'bin'
		}
	}

	def find_wastebin
		target_list = Array.new
		Targets.each_value { |town| target_list += [ town['town'] ] }

		previous, shortest_distances = Map.dijkstra(Room.current, target_list)
		@wastebin = least_time = nil
		for town in Targets.values
			next unless shortest_distances[ town['town'] ]
			est_time = shortest_distances[ town['town'] ]
			if !est_time.nil? and (least_time.nil? or least_time > est_time)
				@wastebin = town['wastebin']
				least_time = est_time
			end
		end
	end

	def squelch
		forgeaction  = proc { |server_string|
			if server_string.strip.length == 0
				nil
				next
			end
			case server_string
			when /begin pumping to set the wheel spinning|you press it against the spinning stone|dust rises from the spinning wheel as you grind|internal strength fully recovers|begin to lose touch with your internal sources|You swap|you feel pleased with yourself at having cleaned|may order a .*? of this item|for your patronage|ask about the price|silvers you offer in payment|Sold for \d+ silvers|sparks leap from the spinning wheel|around you see a grinder that may suit your|focus deep within yourself, searching for untapped sources|feel a great deal stronger|feel fully energetic|you still have some time remaining, the clerk directs you|press it against the spinning wheel|hum of the spinning wheel and the scent|reducing areas of roughness to a polished|pause to press a tube of diamond dust paste|straighten up from working at the polishing wheel|#{Char.name} is using the polisher right|pause to examine both pieces closely|pick up a file and file|eternity you realize that the scribed pattern has been chewed|decide the safest thing to do now is to|you get to your feet|cost you \d+ silvers|you set to work assembling your|dip some rendered rolton fat from a small|upon fitting the two pieces together/
				nil
			when /around you see a trough and a pair of tongs|need it in order to set the temper in the weapon when you're done|pull the drain plug from the tempering trough|the tempering trough is empty nothing happens|lift the bucket from its hook and dip a bucket|take the mithril tongs from their place on the anvil|dull orange glow filling the gaps between the coals pulses|darkens with perspiration as the newly awakened heat floods|takes on the glow from the surrounding|you begin to shape it with your forging|reddish sparks fly in all directions as you hammer away|hammer until the glow has faded|waiting for.*?to heat up again|from the forge and resume your work|fall about the base of the anvil|toward its final form as beads of perspiration form|you realize that the scribed pattern is gone|wipe sweat from your forehead with the back of your hand|waiting for.*?coloring of workable|sparks fly in all directions as you hammer|dozens of the blue sparks strike the chain webbing overhead\.  As each spark touches a mithril link it winks out of existence, but in its place a blue nimbus forms around the link|spinning wheel as you grind away/
				nil
			when /(<roundTime value=\'.*\'\/>)(?:You carefully trace|You begin to trace)/
				$1
			else
				server_string
			end
		}
		DownstreamHook.remove('forgesquelch')
		DownstreamHook.add('forgesquelch', forgeaction)
	end

	def location
		fput "citizenship"
		location_check = dothistimeout "location", 7, /You carefully survey your surroundings/
		if location_check =~ /your current location is (.*) or somewhere close to it/
			forge_location = $1.to_s
			if forge_location =~ /Kharam Dzu/
				$forge_town = "Teras Isle"
			else 
				$forge_town = forge_location
			end
		else
			echo "Error: did not recognize location response"
		end
	end

	def setup
		if Settings["average_container"] == ""
			Settings["average_container"] = nil
		end
		if Settings["keeper_container"] == ""
			Settings["keeper_container"] = nil
		end
		if Settings["oil_container"] == ""
			Settings["oil_container"] = nil
		end
		if Settings["block_container"] == ""
			Settings["block_container"] = nil
		end
		if Settings["slab_container"] == ""
			Settings["slab_container"] = nil
		end
		if Settings["scrap_container"] == ""
			Settings["scrap_container"] = nil
		end
		if Settings["glyph_container"] == ""
			Settings["glyph_container"] = nil
		end
		if Settings["material_noun"] == ""
			Settings["material_noun"] = nil
		end
		if Settings["material_name"] == ""
			Settings["material_name"] = nil
		end
		if Settings["material_no"] == ""
			Settings["material_no"] = nil
		end
		if Settings["glyph_name"] == ""
			Settings["glyph_name"] = nil
		end
		if Settings["glyph_no"] == ""
			Settings["glyph_no"] = nil
		end
		if Settings["glyph_material"] == ""
			Settings["glyph_material"] = nil
		end
		@average_container	= Settings["average_container"]
		@keeper_container 	= Settings["keeper_container"]
		@oil_container 		= Settings["oil_container"]
		@block_container	= Settings["block_container"]
		@slab_container		= Settings["slab_container"]
		@scrap_container	= Settings["scrap_container"]
		@glyph_container	= Settings["glyph_container"]
		@material_noun		= Settings["material_noun"]
		@material_name		= Settings["material_name"]
		@material_no		= Settings["material_no"].to_i
		@glyph_name			= Settings["glyph_name"]
		@glyph_no			= Settings["glyph_no"].to_i
		@glyph_material		= Settings["glyph_material"]
		@make_hammers		= Settings["make_hammers"]
		@keepers 			= 0
		@surge				= Settings["surge"]
		@squelch			= Settings["squelch"]
		@make_iron			= Settings["make_iron"]
		
		if @squelch
			squelch
			echo "Squelch Successful"
			before_dying {DownstreamHook.remove('forgesquelch')}
		end
		find_wastebin
		wear_apron
		empty_hands
		rent
	end

	def withdraw(x)
		multifput ("deposit all", "withdraw #{x} silver")
		exit if (waitfor "makes a few marks", "carefully records the transaction", "you don't seem to have that much in the account.\"") =~ /sorry/
	end
	
	def bank(amt)
		waitrt?
		start_script "go2", [ "bank"]
		wait_while {running?('go2')}
		withdraw(amt)
		start_script "go2", [ "forge"]
		wait_while {running?('go2')}
	end

	def use_surge
		if Spell[9606].active?
			fput "cman surge" unless checkstamina < 61
		else
			fput "cman surge" unless checkstamina < 31
		end
	end

	def get_glyph
		if @glyph_container && @glyph_no && @glyph_name && @glyph_material
			move "out"
			buy(@glyph_no, @glyph_material)
			you_put(@glyph_name, @glyph_container)
			rent
		elsif @glyph_container && @glyph_name
			rent
		end
		if @size == nil
			measure		##measures the glyph size and saves for later...IMPORTANT
		end
	end

	def buy(item, material=nil)
		line = ""
		until line =~ /hands you/
			if $forge_town == nil
				location
			end
			if material
				if Char.citizenship == $forge_town
					cost = dothis "order #{item} material #{material}", /a citizen of this town, I\'ll drop the price to (\d+)\./
				else
					cost = dothis "order #{item} material #{material}", /(\d+) silvers/
				end
				cost = cost.slice(/[0-9]+/).to_i
			else
				if Char.citizenship == $forge_town
					cost = dothis "order #{item}", /a citizen of this town, I\'ll drop the price to (\d+)\./
				else
					cost = dothis "order #{item}", /(\d+) silvers/
				end
				cost = cost.slice(/[0-9]+/).to_i
			end
			fput "buy"
			line = waitfor "buckle under", "hands you", "do not have"
			exit if line =~ /buckle under/
			if line =~ /do not have/
				bank(cost+Rent)
			end
		end
	end
	
	def hammer_time
		waitrt?
		fput "swap" if checkleft =~ /forging-hammer/
		until checkright =~ /forging-hammer/
			command = "get my forging" if GameObj.inv.find {|i| i.contents == "forging-hammer"}
			command = "remove forging" if GameObj.inv.find {|i| i.noun == "forging-hammer"}
			fput "stow right" if checkright
			fput command unless checkright =~ /forging-hammer/
		end
	end

	def rent
		if checkroom !~ /Workshop\]/
			fput "go workshop"
			if (waitfor "rentals", "remaining", "collects") =~ /You don\'t have enough silver, rentals are 300 silver\./ ## what's the message when you are too poor?
				bank(Rent)
				move "go workshop"
			end
		end
	end

	def tongs
		waitrt?
		move "go door"
		oil
		done = false
		line = ""
		until done
			if Spell[9605].timeleft < 1 and @surge == "on"
				use_surge
			end
			hammer_time
			fput "get tongs"
			line = waitfor "tempering trough is empty", "will be ruined if you try to set the temper with", "tongs on the anvil", "tongs to the anvil", "need to be holding", "material you want to work", "expired", "has not been scribed", "hanging crystal and spreads", "into the tempering trough", "anvil as you shake your head and ", "hammer in your right","this would be a real waste", "grinding wheel chews"
			waitrt?
			## more return handlers
			done = true if line =~ /shake your head and /
			exit if line =~ /need to be holding|material you want to work|has not been scribed/
			if line =~ /this would be a real waste|will be ruined if you try to set the temper with|trough is empty/
				oil
			elsif line =~ /hammer in your right/
				hammer_time
			elsif line =~/tongs to the anvil/
				done = true
				move "go door"
				fput "wear my forging"
				glyph
			elsif line =~ /expired/
				multimove "go door", "out"
				rent
				move "go door"
			elsif line =~ /best work/
				done = true
				fput "wear my forging"
				move "go door"
				keeper
			elsif line =~ /into the tempering trough/
				done = true
				fput "wear my forging"
				move "go door"
				if @average_container
					you_put("left", @average_container)
				else
					trash(checkleft)
				end
			elsif line =~ /hanging crystal and spreads|grinding wheel chews/
				fput "wear my forging"
				move "go door"
				trash(checkleft)
				done = true
			end
		end
		
		if line !~ /hanging crystal and spreads across|into the tempering trough|grinding wheel chews into|best work|tongs to the anvil/
			fput "wear forging"
			move "go door"
		end
	end

	def buy_oil
		waitrt?
		fput "wear forging" if checkright =~ /forging-hammer/ && !(checkleft and checkright).nil?
		multimove "go door", "out"
		buy(Oil_order[Material_oil[@material_name]])
		you_put("oil", @oil_container)
		rent
		move "go door"
	end

	def oil
		waitrt?
		fput "wear forging" if checkright =~ /forging-hammer/ && !(checkleft and checkright).nil?
		oil = Material_oil[@material_name]
		res = dothistimeout "look in trough", 10, /In the trough/
		unless res =~ /#{Oil_trough[oil]}/		#ie.. unless you already have the oil you need in the trough
			if res =~ /oil|water/
				fput "pull plug"
				you_put("oil", @oil_container) if (checkright =~ /oil/ or checkleft =~ /oil/)   
			end
			if oil != "water" 
				if you_get(oil, @oil_container)	
					fput "pour oil in trough" until !(checkright =~ /oil/ or checkleft =~ /oil/)
				else
					buy_oil
				end
			else
				fput "get bucket"	
			end
		end
	end

	def prepare			##sees if you have/gets a cut slab...(if not, then an uncut slab), then sees if you have/gets/measures the glyph to make a note of how big your cut slabs (bars) need to be, then puts the raw slab back in the slab container
		unless you_get(@material_noun, @block_container)
			if @slab_container
				get_slab
				measure		##measures the glyph size and saves for later...IMPORTANT
				you_put(@material_noun, @slab_container)
			end
		end
	end

	def get_slab		##gets a raw slab from container (or merchant) and puts it in your left hand
		echo "getting slab" if @DEBUG
		unless you_get(@material_noun, @slab_container)
			if @material_name == "iron" && @make_iron
				you_get("iron", @slab_container)
			end
			if checkright != "iron"
				echo "buying slab" if @DEBUG
				move "out"
				if @material_name == "iron" && @make_iron
					start_script('iron');
					wait_while{ running?('iron') }
					rent
					4.times{multifput "get my iron", "swap", "stare head-glyph"
							waitfor "Roundtime"
							pause "1s"
							waitrt?
							pause "1s"
							fput "stow my slab"}
					fput "get my slab"
				else
					buy(@material_no)
					rent
				end
			end
		end
		fput "swap"
		waitfor "You swap"
	end

	def you_get(item, container)
		echo "getting" if @DEBUG
		if container
			echo "container exists" if @DEBUG
			closed = false
			line = nil
			until line && !(line =~ /It's closed/)
				fput "get #{item} from #{container}"
				line = waitfor "You remove", "It's closed", "Get what"
				closed = closed || line =~ /It's closed./
			end
			fput "close #{container}" if closed
		else
			echo "container doesn't exist" if @DEBUG
			fput "get my #{item}"
			line = waitfor "You remove", "It's closed", "Get what"
		end
		return line =~ /You remove/
	end

	def measure
		if @make_hammers
			res = dothistimeout "measure #{glyph_name}", 5, /you determine it|What were|You can\'t seem/
		else
			res = dothistimeout "measure my #{glyph_name}", 5, /you determine it|What were|You can\'t seem/
		end
			if res =~ /necessary to have (\d+) pounds of/
				@size = $1.to_i
				echo ""
				echo "Your glyph requires #{@size} pound blocks.  saving info..."
				echo ""
			elsif res =~ /You can't seem to get a good measurement without holding the metal you intend to use in your left hand/
				get_bar
				measure
			else
				get_glyph
		end
	end

	def you_put(item, container)
		closed = false
		line = nil
		until line =~ /You put/
			fput "put #{item} in #{container}"
			line = waitfor "You put", "It's closed.", "won't fit"
			exit if line =~ /won't fit/
			closed = closed || line =~ /It's closed./
		end
		fput "close #{container}" if closed
	end

	def forge
		get_bar
		glyph
	end

	def get_bar			##sees if you have correct sized BLOCKs (cut slabs in your @block_container) and puts in your left hand  
						##if NOT, it gets a raw slab from slab container, CUTs it to needed size, and puts it in your left hand
		unless checkleft(@material_noun) or checkright(@material_noun)
			unless you_get(@material_noun, @block_container)
				exit unless @slab_container
				get_slab		##gets a raw slab from container (or merchant) and puts it in your left hand, returns to workshop if you had to buy it
				if @size == nil
					measure		##measures the glyph size and saves for later...IMPORTANT
				end
				cut(@size)		##goes to workshop if you're not already, cuts slab into right sized blocks
				exit unless you_get(@material_noun, @block_container)
			end
		end
		until checkleft =~/#{@material_noun}/
			fput "swap"
		end
	end

	def cut(y, x=nil)			##y is @size variable saved from earlier when measuring glyph
		rent unless checkroom =~ /Workshop/
		left = right = 0
		if x					##ONLY true when using the manual ;Forge- cut <#> 
			x.times { left, right = cut_once(y, left, right) }
		else
			until checkleft.nil?	##when forging automatically with ;forge-
				if @material_noun =~ /block/
					left = 10
				elsif @material_noun =~ /bar/
					left = 15
				elsif @material_noun =~ /slab/
					left = 25
				end
				left, right = cut_once(y, left, right)
			end
		end
		scrap("left") if checkleft
	end

	def cut_once(y, left, right)
		if left == y || (left/2) < y  			##no need to cut if you can't get at least 2 pieces out of it (e.g. greatsword blade =13 lbs)
			you_put("left", @block_container) 
		else
			fput "poke slab-"					##checks the starting position "proposed" cut sizes 
			line = waitfor("You've just set", "You slide your", "You've just reset", "You really can't accomplish much", "too small to cut in two!") 
			if line =~ /reset/
				right = left = left/2
			elsif line =~ /into a (\d+)lb. piece and a (\d+)lb. piece/
				left, right = $1.to_i, $2.to_i
				echo "#{left} #{right} #{$1} #{$2}" if @DEBUG
			elsif line =~ /too small to cut in two/
				left = 1
				right = 0
			else
				get_slab unless checkleft
				redo
			end
			if left + right == y					##if the 'proposed' cut sizes exactly add up to the desired size, then left IS ALREADY the desired size
				you_put("left", @block_container)
			elsif left + right < y && left + right > 0		##if proposed cut sizes added together are less than the desired size, it's useless.
				scrap("left")
			else
				until left == y || right == y		##until EITHER proposed size is a correct match, push cutter into other measurements
					fput "push slab-cutter"
					(waitfor "You slide") =~ /cut it into a (\d+)lb. piece and a (\d+)lb. piece/
					if ($1.to_i + $2.to_i) == (y*2)
						fput "poke slab-"
						left, right = y, y
					else
						left, right = $1.to_i, $2.to_i
					end
				end
				fput "pull slab-cutter"				##when proposed cut size is correctly reached by the "until" condition above
				if left == y && right == y
					you_put("right", @block_container)
					you_put("left", @block_container)
					left = right = nil
				elsif right == y
					you_put("right", @block_container)
					if left < y
						scrap("left")
						left = right = nil
					end
				elsif left == y
					you_put("left", @block_container)
					if right < y
						scrap("right")
					else
						fput "swap"
						left = right
						right = nil
					end
				end
			end
		end
	pause "0.5s"
	return left, right									##does right need to be nil now?
	end

	def glyph
		waitrt?
		if @make_hammers
			fput "stare #{@glyph_name}"
		else
			fput "stare my #{@glyph_name}"
		end
		line = matchwait /Your left hand is empty|grinder that may suit|door to the forging chamber|need to shape it somehow|realize it is too small|What were you referring to/
		waitrt?
	###  What the fuck is this for?  I dont remember adding this....
	#	if line !~ /Your left hand is empty|realize it is too small|What were you referring to/
	#		line2 = matchwait /Your left hand is empty|grinder that may suit|door to the forging chamber|need to shape it somehow|realize it is too small|What were you referring to|Roundtime:/
	#	end
		if line =~ /Your left hand is empty/
			fput "swap"
			get_bar if (waitfor "swap" =~ /have anything to swap/)
		elsif line =~ /grinder that may suit/ #|| line2 =~ /grinder that may suit/
			grind
		elsif line =~ /door to the forging chamber/ #|| line2 =~ /door to the forging chamber/
			tongs
		elsif line =~ /need to shape it somehow/
			if checkleft =~ /slab|bar/ and @glyph_name =~ /haft|handle|head|hilt|shaft/
				grind
			elsif checkleft == "block"
				grind
			elsif checkleft =~ /slab|bar/
				tongs
			end
		elsif line =~ /realize it is too small/
			trash(checkleft)
		elsif line =~ /What were you referring to/
			you_put(@material_noun, @block_container)
			get_glyph
		end
	end

	def polish
		container = nil
		unfinished = nil
		GameObj.inv.each { |container| container.noun =~ /#{@average_container}|#{@keeper_container}/ 
			break if unfinished = container.contents.find { |obj| obj.name =~ /rough|polished/ && obj.noun !~ /wand|shell|coral|ring|anklet|bracelet/ } 
		}
		if unfinished != nil
			echo ""
			echo "Have a #{unfinished.noun} that needs polishing."
			echo ""
			unless checkroom =~ /Workshop/
				move "go door"
			end
			fput "get ##{unfinished.id} from ##{container.id}"
			fput "swap"
			fput "lean polisher"
			line = waitfor "rent on this workshop has expired", "You give the polishing wheel a shove"
			waitrt?
			if line =~ /rent on this workshop has expired/
				move "out"
				rent
				fput "lean polisher"
			elsif line =~ /You give the polishing wheel a shove/
				waitfor "You straighten up from working at the polishing wheel"
				waitrt?
			end
			fput "put ##{unfinished.id} in ##{container.id}"
		else
			sleep 1
		end
	end

	def wear_apron
		if !GameObj.inv.find {|i| i.noun == "apron"}
			get_apron unless GameObj.inv.find {|i| i.contents == ("apron")}
			multifput("get apron", "wear my apron")
		end
	end

	def get_apron
		fput "stow all"
		bank(1000)
		buy(1)
	end
	
	def grind
		fput "wear forging" if checkright =~ /forging-hammer/
		if Spell[9605].timeleft < 1 and @surge == "on"
			use_surge
		end
		waitrt?
		fput "turn grinder"
		line = waitfor "doesn't budge!", "Resignedly", "you need to hold it in your", "satisfied with the piece", "vindictive", "very best"
		waitrt?
		if line =~ /doesn't budge!/
			you_put(@material_noun, @block_container)
			move "out"
			rent
		elsif line =~ /Resignedly, you get/
			glyph
		elsif line =~ /you need to hold it in your/
			fput "swap"
		elsif line =~ /very best/
			keeper 
			if checkright(@material_noun)
				scrap("right")
			end
		elsif line =~ /satisfied with the piece/
			if @average_container
				you_put("left", @average_container)
			else
				trash(checkleft)
			end
			if checkright(@material_noun)
				scrap("right")
			end
		elsif line =~ /vindictive/
			trash(checkleft)
			if checkright(@material_noun)
				scrap("right")
			end
		end
	end
	
	def keeper
		if @keeper_container
			you_put(checkleft, @keeper_container)
			@keepers += 1
		else
			echo "No keeper container set!  Aborting..."
			exit
		end
	end

	def trash(item)
		if checkname =~ /Forge/
			move "go door"
			fput "put #{item} in #{@wastebin}"
			move "go door"
		else
			fput "put #{item} in #{@wastebin}"
		end
	end
	
	def scrap(item)
		if @scrap_container
			closed = false
			donescrapping = false
			until donescrapping == true	
				line = nil
				fput "put #{item} in #{@scrap_container}"
				line = waitfor "You put", "It's closed", "won't fit"
				if line =~ /fit/
					fput "look in my #{@scrap_container}"
					unless checkroom =~ /Workshop/
						move "go door"
					end
					move "out"
					start_script "go2", [ "pawnshop"]; wait_while {running?('go2')}
					fput "sell #{item}"
					line = waitfor "then hands you", "basically worthless here", "hands it back to you"
					if line =~ /then hands you/
						GameObj.inv.find { |container| container.noun =~ /#{@scrap_container}/
							if container.contents.to_a.find_all { |obj| obj.name =~ /#{@material_name} slab/ }.each { |obj| multifput "get ##{obj.id}", "sell ##{obj.id}" }
							end 
						}
						donescrapping = true
						start_script "go2", [ "forge"]; wait_while {running?('go2')}
						rent
					elsif line =~ /worthless|hands it back to you/
						fput "drop #{item}"
						echo ""
						echo "Don't save worthless scraps!"
						echo ""
						exit
					end
				elsif line =~ /closed/
					closed = true
					fput "open my #{@scrap_container}"
				elsif line =~ /You put/
					donescrapping = true
				end
			end
			fput "close #{container}" if closed
		else
			trash(item)
		end
	end

	def usage
		respond "",
		"Forge-Perfects SETUP:                                                                                ",
		"  ;Forge- set average <container>   <= container for average pieces  (will TRASH them if left blank) ",
		"  ;Forge- set oil <container>       <= container for tempering oil                                   ",
		"  ;Forge- set keepers <container>   <= container for keepers (perfect pieces)                        ",
		"  ;Forge- set slabs <container>     <= container for raw slabs                             (REQUIRED)",
		"  ;Forge- set blocks <container>    <= container for the measured and cut slab blocks      (REQUIRED)", 
		"  ;Forge- set scraps <container>    <= container for material scraps  (will TRASH them if left blank)",
		"  ;Forge- set glyph <name> <container> <#> <material> <=e.g.[blade-glyph backpack 14 wax] (SEE NOTE*)",
		"  ;Forge- set material <material> <noun> <order #>    <=e.g.[steel slab 4][maoral block 3] (REQUIRED)",
		"  ;Forge- set make_hammers <true/false>  <= make forging hammer-heads/handles with workshop glyphs   ",
		"  ;Forge- set surge <on/off>        <= toggles use of Cman Surge of Strength for relevant steps      ",
		"  ;Forge- set squelch <true/false>  <= squelches screen scroll for forging actions                   ",
		"  ;Forge- set make_iron <true/false><= makes iron in kobold mines (Requires iron.lic!)               ",
		"  ;Forge- set <name>                <= will clear that setting                                       ",
		"  ;Forge- display                   <= display the current Settings                                  ",
		"                                                                                                     ",
		"IMPORTANT NOTES ABOUT SETUP:                                                                         ",
		"  Block, Slab, Scrap, Keeper containers MUST be different.                                           ",
		"  If keeping 'Average' pieces, container should be different from 'Keeper' container.                ",
		"  Do NOT use commas in when entering Settings for glyph and material                                 ",
		"  *To use your own glyphs (eg Maul/Lance), do NOT set order # or material. e.g.[blade-glyph backpack]",
		"                                                                                                     ",
		"Forge-Perfects USAGE:                                                                                ",
		"  ;Forge- setup            <= Will open a graphic gui to setup your options                          ",
		"  ;Forge- cut <size> <#>   <= cuts as many of # size as it can from one slab                         ",
		"  ;Forge- keepers <#>      <= stop when # of keepers have been forged                                ",
		"  ;Forge- forge <#>        <= does the forge routine # times                                         ",
		"  ;Forge- polish           <= polishes rough hilt/blade pieces found in your containers              ",
		"  ;Forge-                  <= Begin perfect forging! (if you did the setup right)                    ",
		"                                                                                                     "
	end
end

case script.vars[1]
when nil
	waitrt?
	start_script "go2", [ "forge"]
	wait_while {running?('go2')}
	forger.setup
	forger.prepare
	fput "look in my #{@average_container}" if @average_container
	fput "look in my #{@keeper_container}" if @keeper_container
	fput "inventory"
	loop {
		forger.forge
		forger.polish
	}
when "forge"
	waitrt?
	start_script "go2", [ "forge"]
	wait_while {running?('go2')}
	forger.setup
	forger.prepare
	fput "look in my #{@average_container}" if @average_container
	fput "look in my #{@keeper_container}" if @keeper_container
	fput "inventory"
	script.vars[2].to_i.times {
		forger.forge
	}
when "polish"
	waitrt?
	start_script "go2", [ "forge"]
	wait_while {running?('go2')}
	forger.setup
	fput "look in my #{@average_container}" if @average_container
	fput "look in my #{@keeper_container}" if @keeper_container
	fput "inventory"
	rent
	forger.polish
when "cut"
	waitrt?
	start_script "go2", [ "forge"]
	wait_while {running?('go2')}
	forger.setup
	fput "inventory"
	forger.cut(script.vars[2].to_i, script.vars[3].to_i)
when "keepers"
	unless Settings["keeper_container"]
		respond "You must first set a keeper container."
		exit
	end
	fput "look in my #{@average_container}" if @average_container
	fput "look in my #{@keeper_container}" if @keeper_container
	fput "inventory"
	waitrt?
	start_script "go2", [ "forge"]
	wait_while {running?('go2')}
	forger.setup
	forger.prepare
	while forger.keepers < script.vars[2].to_i
		forger.forge
		forger.polish
	end
when "display"
	respond  "Current Forger Settings:",
	"average             =>  #{Settings["average_container"]}   ",
	"oil                 =>  #{Settings["oil_container"]}       ",
	"keepers             =>  #{Settings["keeper_container"]}    ",
	"slabs               =>  #{Settings["slab_container"]}      ",
	"blocks  (slab cuts) =>  #{Settings["block_container"]}     ",
	"scraps              =>  #{Settings["scrap_container"]}     ",
	"glyph (name, container, order #, order material)  =>  #{Settings["glyph_name"]} #{Settings["glyph_container"]} #{Settings["glyph_no"]} #{Settings["glyph_material"]}  ",
	"material  (material type, material noun, order #) =>  #{Settings["material_name"]} #{Settings["material_noun"]} #{Settings["material_no"]}  ",
	"make_hammers        =>  #{Settings["make_hammers"]}        ",
	"surge               =>  #{Settings["surge"]}               ",
	"squelch             =>  #{Settings["squelch"]}             ",
	"make_iron           =>  #{Settings["make_iron"]}           ",
	"                                                           ",
	"IMPORTANT:",
	"   ;Forge- set <setting> <whatever>    for details type  ;Forge- help",
	"   Keepers, slabs, blocks, and scraps container must be different, but only the first 3 are required.",
	"   Leaving the average and scrap Settings blank will cause those things to be thrown away!   ",
	""
when "set"
	case script.vars[2]
	when "average"
		Settings["average_container"] = script.vars[3]
		echo "Settings saved!"
	when "keepers"
		Settings["keeper_container"] = script.vars[3]
		echo "Settings saved!"
	when "blocks"
		Settings["block_container"] = script.vars[3]
		echo "Settings saved!"
	when "oil"
		Settings["oil_container"] = script.vars[3]
		echo "Settings saved!"
	when "slabs"
		Settings["slab_container"] = script.vars[3]
		echo "Settings saved!"
	when "material"
		Settings["material_name"] = script.vars[3]
		Settings["material_noun"] = script.vars[4]
		Settings["material_no"] = script.vars[5]
		echo "Settings saved!"
	when "glyph"
		Settings["glyph_name"] = script.vars[3]
		Settings["glyph_container"] = script.vars[4]
		Settings["glyph_no"] = script.vars[5]
		Settings["glyph_material"] = script.vars[6]
		echo "Settings saved!"
	when "make_hammers"
		Settings["make_hammers"] = script.vars[3]
		echo "Settings saved!"
	when "scraps"
		Settings["scrap_container"] = script.vars[3]
		echo "Settings saved!"
	when "surge"
		Settings["surge"] = script.vars[3]
		echo "Settings saved!"
	when "squelch"
		Settings["squelch"] = script.vars[3]
		echo "Settings saved!"
	when "make_iron"
		Settings["make_iron"] = script.vars[3]
		echo "Settings saved!"
	else
		forger.usage
	end
when "setup"
	setup.call
when "settings"
	setup.call
else
	forger.usage
end
