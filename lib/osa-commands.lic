=begin
  Reduces OSA tedium by adding a helpers for multistep actions.

  ;osa-commands

  author: Jymamon (gs4-jymamon@hotmail.com)
    game: Gemstone
    tags: osa
 version: 2023.08.13.01

  While running, adds the following commands:
    ;anchor    - Raises the sails and drops the anchor.
    ;engage    - Wait for enemy ships that meet certain criteria to engage. Flee from any other ships.
    ;fire      - Fires one cannon, loading it if necessary.
    ;flag      - Change the flag raised.
    ;launch    - Lowers the sails, raises the anchor, and pulls in the gang plank. If docked, will depart the dock.
    ;load      - Loads all the cannons.
    ;patch     - Repairs the room you are currently in.
    ;repair    - Repairs the entire ship.
    ;sail      - Sets course in a direction, towards a target, to a room, to a sea, or to a town's port room. Not AFK friendly.
    ;volley    - Fires all the cannons.
    ;osa help  - Displays short help text.
    ;osa help! - Displays long help text with more information about the commands.
=end
=begin
  history:
    2023.08.13.01 - Board as part of engaging. Add all rooms for repair to ships > sloop.
    2023.07.07.01 - Various minor fixes.
    2023.07.02.01 - Cleanup sailing course correction.
    2023.06.10.01 - Minor fix in UpstreamHook regex for Lich 5. (Thanks for the report, Loraek!)
    2022.12.22.01 - Better evasion with ;engage
    2022.12.17.01 - Fix ;anchor messaging
    2022.12.16.01 - Allow '|' in ;engage
    2022.12.12.01 - ;engage to engage ships that meet some criteria and flee from the rest
    2022.12.06.01 - Add ;flag because I'm clearly lazy.
                  - Change ";sail port" to not just turn the wheel to the port - instead, if
                    there isn't a port in the room, find the nearest port and sail to it
                    because ";sail port of" to do the same thing was weird.
                  - Change a bunch of waitrt's to pause + waitrt? to address more hangs
                    when waitrt doesn't execute until the rt is completed.
    2022.12.03.02 - Fix hang manipulating sails where waitrt was triggering after the RT
                    already finished for some reason.
    2022.12.03.01 - Try suppporting ships other than a sloop.
    2022.12.02.01 - Better handling when sailing destination is same as current room.
    2022.11.30.03 - Fix response to anchor being dropped by a storm.
                  - Fix sailing to handle player initiated RT between commands.
    2022.11.30.02 - Better handling for a storm causing the anchor to drop or wheel to turn
                    to an invalid direction/nowhere.
                  - Support ships with more than one room with cannons.
                  - Update support for roles than can see damage in all room's.
    2022.11.30.01 - More automatic course correct - but you better be a veteran or better
                  - Navigator for storms.
    2022.11.27.03 - Respond to various game lines while sailing to fix ship state. (Expiramental)
    2022.11.27.02 - Add ;stopsailing to stop a long sailing trip without having to
                    kill the script.
    2022.11.27.01 - Just a fun update for the crew announcements.
    2022.11.24.01 - Update ;sail for room ids, tags, locations. Not afk friendly, but
                    will get you there most of the time.
    2022.11.21.01 - Better ;repair when able to assess all rooms.
    2022.11.20.01 - New command: ;anchor - raises the sails and drops the anchor
    2022.11.16.02 - New command: ;patch - repairs just the current room
    2022.11.16.01 - New command: ;fire - fires a single cannon, loading it if needed
    2022.11.15.02 - New command: ;volley - fires all the loaded cannons
    2022.11.15.01 - Initial version. New commands: ;launch, ;load, ;repair, ;sail
=end

silence_me unless $osadebug
toggle_upstream
$osa_cmd_queue = Queue.new
commands = []

# ------------------------------------------------------------------------------------------------------------
# General routines
# ------------------------------------------------------------------------------------------------------------

# Adds an downstream hook and ensures it is removed when the script exits
#   parameters:
#   - the string to register as the hook
#   - the action to call when the string is entered
add_down_hook = lambda { |hookname, hookproc|
  before_dying {
    DownstreamHook.remove(hookname)
  }

  DownstreamHook.add(hookname, hookproc)
}

# Adds an upstream hook and ensures it is removed when the script exits
#   parameters:
#   - the string to register as the hook
#   - the action to call when the string is entered
add_up_hook = lambda { |hookname, hookproc|
  before_dying {
    UpstreamHook.remove(hookname)
  }

  UpstreamHook.add(hookname, hookproc)
}

# Registers a new command for use while OSA is running.
#   parameters:
#   - the string to register as the command
#   - the action to call when the string is entered
#   Note: If the action is a lambda, it must take a single parameter
#         which is everything from the command line after the initial
#         command word.
add_command = lambda { |command, command_proc, help_text|
  hookname = "#{script.name}_#{command}_cmd"
  respond "Adding command #{$clean_lich_char}#{command}"

  hook_proc = proc { |client_string|
    if client_string =~ /^(?:<c>)?#{$clean_lich_char}(?:#{command})\s*(.*)/i
      params = $1.to_s
      $osa_cmd_queue << [command, command_proc, params]
      nil
    else
      client_string
    end
  }

  add_up_hook.call(hookname, hook_proc)

  commands << [command, help_text]
}

# Gets information for the current ship or nil if not on a ship.
#   parameters:
#   - none
get_ship = lambda {
  # Ship room data built from:
  # ships = Hash.new
  # ['Sloop', 'Brigantine', 'Carrack', 'Galleon', 'Frigate', 'Man O\' War'].each{|ship_type|
  #    if !ship_type.nil? && ship_type != ""
  #        ship = Hash.new
  #        ship[:type] = ship_type.downcase
  #        ship[:capstan] = Map.list.find{|room| room.title[0] =~ /^\[#{ship_type}, Helm\]$/}.id
  #        ship[:cannons] = Map.list.find_all{|room| room.title[0] =~ /^\[#{ship_type}, (?:Main|Forward) Deck\]$/}.map{|room| room.id}
  #        ship[:crowsnest] = Map.list.find{|room| room.title[0] =~ /^\[#{ship_type}, Crow's Nest\]$/}.id
  #        ship[:gangplank] = Map.list.find{|room| room.title[0] =~ /^\[#{ship_type}, Main Deck\]$/}.id
  #        ship[:map] = Map.list.find{|room| room.title[0] =~ /^\[#{ship_type}, Captain's Quarters\]$/}.id
  #        ship[:node] = Map.list.find{|room| room.title[0] =~ /^\[#{ship_type}, Captain's Quarters\]$/}.id
  #        ship[:sails] = Map.list.find_all{|room| room.title[0] =~ /^\[#{ship_type}, (?:Main|Forward) Deck\]$/}.map{|room| room.id}
  #        ship[:supplies] = Map.list.find{|room| room.title[0] =~ /^\[#{ship_type}, Cargo Hold\]$/}.id
  #        ship[:wheel] =  Map.list.find{|room| room.title[0] =~ /^\[#{ship_type}, Helm\]$/}.id
  #        ship[:rooms] = ship.select{|k, v| k!=:type}.values.flatten.uniq
  #
  #        ships[ship_type] = ship
  #    else
  #        nil
  #    end
  # }
  #
  # ships.keys.each{|ship_type|
  #    puts "\"#{ship_type}\" => {\n"
  #    ships[ship_type].keys.each{|symbol|
  #        if symbol==:type
  #            puts "    :#{symbol} => \"#{ships[ship_type][symbol]}\",\n"
  #        else
  #            puts "    :#{symbol} => #{ships[ship_type][symbol]},\n"
  #        end
  #    }
  #    puts "},\n"
  # }
  # which is painfully too slow to run at startup of this script. Instead of optimizing, just use
  # the results since they're unlikely to change much. (Famous last words?)
  #
  # So far, I only have a sloop to mess with, so other ship types haven't been tested.

  ships = {
    'Sloop' => {
      :type => 'sloop',
      :capstan => 29041,
      :cannons => [29038],
      :crowsnest => 29040,
      :gangplank => 29038,
      :map => 29042,
      :node => 29042,
      :sails => [29038],
      :supplies => 29039,
      :wheel => 29041,
      :rooms => [29041, 29038, 29040, 29042, 29039],
    },
    'Brigantine' => {
      :type => 'brigantine',
      :capstan => 30141,
      :cannons => [30142, 30144],
      :crowsnest => 30143,
      :gangplank => 30142,
      :map => 30140,
      :node => 30140,
      :sails => [30142, 30144],
      :supplies => 30145,
      :wheel => 30141,
      :rooms => [30140, 30141, 30142, 30143, 30144, 30145, 30146, 30147],
    },
    'Carrack' => {
      :type => 'carrack',
      :capstan => 30120,
      :cannons => [30119, 30121],
      :crowsnest => 30123,
      :gangplank => 30119,
      :map => 30124,
      :node => 30124,
      :sails => [30119, 30121],
      :supplies => 30125,
      :wheel => 30120,
      :rooms => [30119, 30120, 30121, 30122, 30123, 30124, 30125, 30126, 30126],
    },
    'Galleon' => {
      :type => 'galleon',
      :capstan => 30179,
      :cannons => [30176, 30177],
      :crowsnest => 30181,
      :gangplank => 30176,
      :map => 30180,
      :node => 30180,
      :sails => [30176, 30177],
      :supplies => 30182,
      :wheel => 30179,
      :rooms => [30176, 30177, 30178, 30179, 30180, 30181, 30182, 30183, 30184, 30185],
    },
    'Frigate' => {
      :type => 'frigate',
      :capstan => 30174,
      :cannons => [30166, 30171],
      :crowsnest => 30173,
      :gangplank => 30166,
      :map => 30175,
      :node => 30175,
      :sails => [30166, 30171],
      :supplies => 30167,
      :wheel => 30174,
      :rooms => [30166, 30167, 30168, 30169, 30170, 30171, 30172, 30173, 30174, 30175],
    },
    "Man O' War" => {
      :type => "man o' war",
      :capstan => 30128,
      :cannons => [30130, 30132],
      :crowsnest => 30134,
      :gangplank => 30130,
      :map => 30129,
      :node => 30129,
      :sails => [30130, 30132],
      :supplies => 30136,
      :wheel => 30128,
      :rooms => [30128, 30129, 30130, 30131, 30132, 30133, 30134, 30135, 30136, 30137, 30138, 30139],
    }
  }

  if Room.current.title[0] =~ /^\[(#{ships.keys.join('|')}),/
    ship_type = $1
    ships[ship_type] if !ship_type.nil? && ship_type != '' && ships.key?(ship_type)
  end
}

# Runs ;go2 to move to a specified room
#   parameters:
#   - the room to move to
#   - any additional parameters to pass to ;go2
go = lambda { |room, parameters = nil|
  script_parameters = ['_disable_confirm_']

  unless parameters.nil?
    if parameters.instance_of?(String)
      script_parameters.push(parameters)
    elsif parameters.instance_of?(Array)
      script_parameters.concat(parameters)
    else
      Message.bold "Ignoring parameters I don't know how to handle: #{parameters}!"
    end
  end

  if Room.current.id != room
    script_parameters.push(room)
    start_script 'go2', script_parameters
    wait_while { running? 'go2' }
  end
}

# Runs ;go2 to move to a specified room, performs an action,
# then returns to the initial room.
#   parameters:
#   - the room to move to
#   - the action to perform there
go_do_this = proc { |room, action, parameters|
  returnto = Room.current.id
  go.call(room)
  action.call(parameters)
  go.call(returnto)
}

# Displays a message to the client. The message will be in bold if the client
# supports that.
#   parameters:
#   - The message to display
message_bold = lambda { |text|
  stringArray  = []
  stringArray  = text.gsub(/\n+/, '<<CLRF>>').split(/<<CLRF>>/)
  begin_text   = "<pushBold\/>"
  end_text     = "<popBold\/>"

  if $fake_stormfront
    begin_text = "\034GSL\r\n "
    end_text   = "\034GSM\r\n "
  end

  stringArray.each { |line|
    puts "#{begin_text}#{line.gsub('\n', '')}#{end_text}"
  }
}

# Force a message to be monospaced in Stormfront. Just outputs the message
# in Wizard since that's a monospaced interface already. Also stolen from
# a script by Casis.
#   parameters:
#   - The message to display
#   - A bool to indicate if the text should also be bold
message_mono = lambda { |text, bold = false|
  stringArray  = []
  stringArray  = text.gsub(/\n+/, 'cr#lf').split(/cr#lf/)
  begin_text   = "<output class=\"mono\"\/>"
  end_text     = "<output class=\"\"\/>"

  if $fake_stormfront
    begin_text = ''
    end_text   = ''
  end

  if bold
    begin_text = "#{begin_text}<pushBold\/>"
    end_text = "<popBold\/>#{end_text}"
  end

  text = "#{begin_text}"
  stringArray.each { |line|
    text += "#{line}\n"
  }
  text += "#{end_text}"

  puts "#{text}"
}

# Orders a list of target rooms by nearest to furthest
#   parameters:
#   - The rooms to be ordered
order_by_nearest = lambda { |targets|
  start_room = Room.current
  previous, shortest_distances = Map.dijkstra(Room.current.id.to_i)
  return targets.reject { |t|
    shortest_distances[t].nil?
  }.sort { |a, b|
    shortest_distances[a] <=> shortest_distances[b]
  }
}

# ------------------------------------------------------------------------------------------------------------
# Common, ship related, actions
# ------------------------------------------------------------------------------------------------------------

# Tries to give message_bold some personality.
#   parameters:
#   - The message to display
crew_message = lambda { |text|
  punctuation = '!'

  if text =~ /([!.?])$/
    punctuation = $1
    text.chop!
  end

  # If they were in the same room, we'd see who. These should be valid on all ships. I hope?
  # Crew isn't in the Captain's Quarters!
  fromthe = ['Main Deck', 'Helm', 'Cargo Hold', "Crow's Nest"]
            .find_all { |title| Room.current.title[0] !~ /#{title}/i }
            .sample(1)
            .first

  who = ['someone', 'a crewman', 'a crewwoman', 'a crewmember', 'a voice', 'a deckhand', 'the first mate']
        .sample(1)
        .first

  verb = {
    '?' => ['ask', 'wonder', 'query'].sample(1).first,
    '.' => ['state', 'announce', 'say'].sample(1).first,
    '!' => ['shout', 'call out', 'yell'].sample(1).first
  }

  text = "From the #{fromthe} you hear #{who} #{verb[punctuation]}, \"#{text}, Cap'n#{punctuation}\""
  message_bold.call(text)
}

# Raises or lowers the anchor
#   parameters:
#   - ship - the current ship
#   - true/false - raising (true) or lowering (false) the anchor
anchor = lambda { |ship, raise|
  returnto = Room.current.id
  go.call(ship[:capstan])

  if raise
    loop {
      result = dothistimeout 'push capstan', 5, /You manage to push|You can now DEPART|you shove|The anchor is already up!/
      pause 0.1
      waitrt?

      if result =~ /DEPART/
        fput 'depart'
        fput 'depart'
      end

      break if result =~ /DEPART|already up/
    }

    crew_message.call("We're afloat!")

  else
    fput 'kick capstan'
    pause 0.1
    waitrt?
    crew_message.call("Stayin' put")
  end

  go.call(returnto)
}

# Gets the current wheel direction
#   parameters:
#   - ship - the current ship
current_direction = lambda { |ship|
  returnto = Room.current.id
  go.call(ship[:wheel])

  direction = nil

  result = dothistimeout 'look wheel', 2, /The wooden wheel is currently turned (.*)$/

  if result =~ /to the (.*)\.$/
    direction = $1
  elsif result =~ /nowhere in particular/
    direction = 'nowhere'
  elsif result =~ /toward a (.*)\.$/
    direction = $1
  end

  go.call(returnto)

  message_bold.call("The wheel is turned #{direction}") if $osadebug

  return direction
}

# Applies planks to a room until it is fixed.
#   parameters:
#   - ship - the current ship
fix_room = lambda { |ship|
  loop {
    result = dothistimeout 'get plank', 2, /Get what\?|plank|You already have that/

    if result =~ /Get what\?/
      count = ship[:supplies] == Room.current.id ? 0 : 3
      go_do_this.call(
        ship[:supplies],
        lambda { |params|
          1.upto(count) {
            fput 'get wood'
            pause 0.1
            waitrt?
            fput 'stow plank'
          }

          fput 'get wood'
          pause 0.1
          waitrt?
        },
        nil
      )
    end

    result = dothistimeout 'fix', 2, /repair some|repair all/
    pause 0.1
    waitrt?

    break if result =~ /repair all/
  }
}

# Given a string of words, makes a regex to match ships of that types
# as best possible.
#   parameters:
#   - ship_string - the string of words to match
make_ship_expression = lambda { |ship_string|
  allowed_criteria = [
    # Crew types
    'dark',
    'ethereal',
    'krolvin',
    'pirate',
    'undead',
    # Ship types
    'battle-marred',
    'merchant',
    'treasure',
    # Ship sizes
    'boat',
    'sloop',
    'brigantine',
    'carrack',
    'galleon',
    'frigate',
    'man o\' war',
    'ship',
  ]

  ship_string = "any|" if ship_string.nil?

  criteria = []

  ship_string.split(/\s*\|\s*/).each { |block|
    criteria << { :crew => [], :cargo => [], :class => [], }

    block.split(/\s+/).each { |qualifier|
      match_found = allowed_criteria.find { |word| word =~ /^#{qualifier}/ }

      if match_found.nil?
        message_bold.call("Got no idea what '#{qualifier}' means.")
      elsif match_found =~ /dark|krolvin|ethereal|pirate|undead/i
        criteria[-1][:crew] << match_found.downcase
          .sub('pirate', 'dark')
          .sub('undead', 'ethereal')
      elsif match_found =~ /battle-marred|treasure|merchant/i
        criteria[-1][:cargo] << match_found.downcase
      elsif match_found =~ /sloop|brigantine|carrack|galleon|frigate|man o' war/i
        criteria[-1][:class] << match_found.downcase
      end
    }
  }

  # Handle no criteria
  criteria << { :crew => [], :cargo => [], :class => [], } unless criteria.any?

  expression = criteria.map { |crit|
    expression = "(?:"
    expression += crit[:crew].any? ? "(?:#{crit[:crew].uniq.join('|')}) " : '(?:[^\s]+) '
    expression += crit[:cargo].any? ? "(?:#{crit[:cargo].uniq.join('|')}) " : '(?:[^\s]+) '
    expression += crit[:class].any? ? "(?:#{crit[:class].uniq.join('|')})" : '(?:[^\s]+)'
    expression += ")"
  }.join('|')

  return Regexp.new("(#{expression})", true)
}

# Raises or lowers the sails and optionall tries to fill them with magical wind
#   parameters:
#   - ship - the current ship
#   - true/false - raising (true) or lowering (false) the sails
#   - true/false - true if 612/912 should be cast at the sails (if known)
sails = lambda { |ship, raise, wind, force_wind|
  returnto = Room.current.id
  ship[:sails].each { |sail_room|
    go.call(sail_room)

    result = dothistimeout 'look sail', 1, /currently raised|half mast|fully lowered/

    if raise
      if result =~ /fully lowered/
        fput 'raise sail'
        pause 0.2
        waitrt?
        fput 'raise sail'
        pause 0.2
        waitrt?
      elsif result =~ /half mast/
        fput 'raise sail'
        pause 0.2
        waitrt?
      end
    else
      if result =~ /currently raised/
        fput 'lower sail'
        pause 0.2
        waitrt?
        fput 'lower sail'
        pause 0.2
        waitrt?
      elsif result =~ /half mast/
        fput 'lower sail'
        pause 0.2
        waitrt?
      end

      if wind || force_wind
        if Spell[912].known? && (force_wind || result !~ /filled with magical wind/)
          Spell[912].cast('sail')
          waitcastrt
        elsif Spell[612].known? && (force_wind || result !~ /filled with magical wind/)
          Spell[612].cast('sail')
          waitcastrt
        end
      end
    end
  }

  go.call(returnto)
}

# Returns extra planks to the supply room.
#   parameters:
#   - ship - the current ship
#   - true/false - true if we should return to our starting room
return_planks = lambda { |ship, goback|
  returnto = Room.current.id
  go.call(ship[:supplies])

  loop {
    result = dothistimeout 'get plank', 2, /Get what\?|plank|You already have that/
    break unless result !~ /Get what\?/
    fput 'put plank in wood'
  }

  go.call(returnto) if goback
}

# Turns the ship's wheel
#   parameters:
#   - ship - the current ship
#   - direction - the direction to turn the wheel
wheel = lambda { |ship, direction|
  go.call(ship[:wheel])

  waitrt?
  result = dothistimeout "turn wheel #{direction}", 2, /do your best to steer|you'd have better luck|already turned/

  if result =~ /better luck|already turned/
    crew_message.call("You been nippin' da rum too much") unless direction = ''
    return
  end

  pause 0.1
  waitrt?
}

# Navigates the ship to a destination
#   parameters:
#   - ship - the current ship
#   - destination - the destination to navigate to
sail2 = lambda { |ship, destination|
  returnto = Map.current.id

  if OsaMap.current.id == 0
    go.call(returnto)
    crew_message.call('We are nae at sea')
    return
  elsif !OsaMap.current.is_mapped?
    go.call(returnto)
    crew_message.call("But we're lost!")
    return
  end

  if destination =~ /^\d+$/
    navigate = Ocean.current.path_to(destination.to_i)
  else
    # Maybe move this to OsaMap.path_to instead?
    targets = OsaMap.list.find_all { |possible_room|
      possible_room.tags.any? { |tag|
        tag =~ /#{destination}/i
      } || possible_room.location =~ /#{destination}/i
    }.map { |target| target.id }

    if targets.length == 0
      go.call(returnto)
      crew_message.call("No knowin' where #{destination} is")
      return
    end

    navigate = Ocean.current.path_to(targets)
  end

  if navigate.nil?
    crew_message.call("Ya sure #{destination} is a place?")
    return
  elsif navigate.length == 0
    destination_room = OsaMap.current.id
  else
    destination_room = navigate[-1]
  end

  if destination_room != OsaMap.current.id
    crew_message.call("Headin' to #{destination_room} in #{OsaMap[destination_room].location}")

    go.call(ship[:wheel])

    sails.call(ship, false, true, true)
    last_sail_check = Time.now
    sailing = current_direction.call(ship)
    last_ocean = OsaMap.current.location

    # Allow ;stopsailing to stop the process
    crew_message.call("Jus' tell us ta ;stopsailing if ya want the helm back.")
    $osa_stop_action = false
    add_up_hook.call(
      'osa_stop_action',
      proc { |client_string|
        if client_string =~ /^(?:<c>)?#{$clean_lich_char}stopsailing/i
          $osa_stop_action = true
          nil
        else
          client_string
        end
      }
    )

    # Do we really need a queue here? Anchor, sails, wheel are all we deal with. Using
    # a queue means we could raise, lower, turn more than once per iteration which is
    # redundant.  Just make a set of flags for things to check?
    $sailing_cmd_queue = []

    add_down_hook.call(
      'fix_ship_conditions',
       proc { |game_line|
        if game_line =~ /sound of ropes coming free of the rigging/
          $sailing_cmd_queue.push('sail')
        elsif game_line =~ /The sound of the anchor can be heard rattling down the side|strains against the deployed anchor/
          $sailing_cmd_queue.push('anchor')
        elsif game_line =~ /wooden wheel slowly turns off course|the wooden wheel spins out of control|rocks idly in the ocean waters/
          # Looking at the map isn't really what is fixing anything. Rather, interrupting the loop and making
          # it recalculate is.
          $sailing_cmd_queue.push('map')
        end

        game_line
      }
    )

    go.call(returnto) # Return now or first iteration keeps us at the wheel.
    while (nextroom = navigate.shift)
      break if $osa_stop_action

      # Handle player moving around while ;sail is running. Maybe we should just set returnto
      # to this room instead?
      returnto = Room.current.id
      sailing_from = OsaMap.current.id
      turn = Ocean.current.wayto.invert[nextroom]

      message_bold.call("Heading from #{sailing_from} to #{nextroom} to the #{turn}") if $osadebug

      if turn != sailing
        wheel.call(ship, turn)
        sailing = turn
      end

      if (Spell[612].known? || Spell[912].known?) && ((Time.now - last_sail_check) > 80)
        last_sail_check = Time.now
        sails.call(ship, false, true, true)
      end

      go.call(returnto)

      # Instead of waiting on it being a specific room, wait on it having
      # changed at all.  If it changed and isn't what was expected, repopulate
      # navigate[] based on the current room.
      # Consider also having a timeout. We shouldn't be in the same room very
      # long. Maybe 15 seconds or so.
      wait_while { Ocean.current.id == sailing_from && !$osa_stop_action && $sailing_cmd_queue.empty? }

      if $sailing_cmd_queue.any?
        while (action = $sailing_cmd_queue.shift)
          crew_message.call("Lookin' after dat #{action} problem.")

          if action.to_s == 'sail'
            sails.call(ship, false, true, false) unless $osa_stop_action
          elsif action.to_s == 'anchor'
            anchor.call(ship, true) unless $osa_stop_action
          elsif action.to_s == 'map'
            here = Room.current.id
            go.call(ship[:map])
            fput 'look map'
            go.call(here)
          elsif action.class.is_a?(Proc)
            action.call(ship) unless $osa_stop_action
          else
            crew_message.call("There's sumtin' weird goin' on!")
          end
        end
      end

      # Just useful for check pointing long journey's in case we find a room
      # that doesn't match the map.
      if Ocean.current.location != last_ocean
        crew_message.call("We've entered #{Ocean.current.location}!")
        last_ocean = Ocean.current.location
      end

      next unless Ocean.current.id != nextroom && !$osa_stop_action

      unless Ocean.current.is_mapped?
        go.call(ship[:map])
        fput 'look map'
        go.call(ship[:wheel])
        sailing = current_direction.call(ship)
      end

      crew_message.call("Adjustin' course!")
      navigate = Ocean.current.path_to(destination_room)
    end

    UpstreamHook.remove('osa_stop_action')
    DownstreamHook.remove('fix_ship_conditions')
  end

  if $osa_stop_action
    crew_message.call("The helm's yers!")
  else
    if Ocean.current.tags.any? { |tag| tag =~ /port/i }
      crew_message.call("Figurin' ya wan' 'er at da docks")
      wheel.call(ship, 'port')
      waitfor('designated pier')
    else
      # Turns the wheel to point 'nowhere in particular' so we quit sailing
      wheel.call(ship, '')
    end

    go.call(returnto)

    if OsaMap.current.id == destination_room
      crew_message.call("We've arrived!")
    else
      crew_message.call('Youse better take over!')
      message_bold.call("Sailing to #{OsaMap.current.id} but ended up in #{destination_room}") if $osadebug
    end
  end
}

# ------------------------------------------------------------------------------------------------------------
# Command implementations
# ------------------------------------------------------------------------------------------------------------

# Anchors the boat.
#   parameters:
#   - ignored
anchor_cmd = lambda { |params|
  returnto = Room.current.id
  ship = get_ship.call

  anchor.call(ship, false)
  sails.call(ship, true, false, false)

  go.call(returnto)
  crew_message.call("We ain't going nowhere now!")
}

# Watches the seas looking for a enemy ship to engage and avoids
# ships taht aren't desirable to be engaged.
#   parameters:
#   - the type of ship to look for
engage_cmd = lambda { |ship_type|
  returnto = Room.current.id
  match_expression = make_ship_expression.call(ship_type.downcase)
  ship = get_ship.call
  crew_message.call("Searching for #{match_expression}.") if $osadebug

  intial = {
    :north => :south,
    :northeast => :southwest,
    :east => :west,
    :southeast => :northwest,
  }

  reverse = {}
  intial.each{|k, v| reverse[k] = v; reverse[v] = k; }

  # Allow ;stopsearching to stop the process
  crew_message.call("Jus' tell us ta ;stopsearching if ya want the helm back.")
  $osa_stop_action = false
  add_up_hook.call(
    'osa_stop_action',
    proc { |client_string|
      if client_string =~ /^(?:<c>)?#{$clean_lich_char}stopsearching/i
        $osa_stop_action = true
        nil
      elsif client_string =~ /^(?:<c>)?#{$clean_lich_char}stopsailing/i
        $osa_stop_action = true
        nil
      else
        client_string
      end
    }
  )

  while !$osa_stop_action
    wait_while { $pursuit_ship.nil? && !$osa_stop_action }

    crew_message.call("Got a #{$pursuit_ship} out there.") unless $pursuit_ship.nil?

    if match_expression.match($pursuit_ship)
      sails.call(ship, false, true, true)
      crew_message.call("Pursuin' her!")

      go.call(ship[:wheel])

      result = ''

      unless $osa_stop_action
        loop {
          result = dothistimeout 'turn wheel ship', 5, /do your best|better luck|already turned|expertly navigate|without much success/
          pause 0.1
          waitrt?
          break if $pursuit_ship.nil? || result !~ /best|expertly/
          break if $osa_stop_action
          matchtimeout(10, /cuts through the ocean toward the enemy/)
        }

        if !$osa_stop_action
            go.call(ship[:gangplank])
            fput "push gangplank"
            fput "go gang"
        end
      end

      crew_message.call('Yer in control') if $osa_stop_action
      break

    elsif !$osa_stop_action
      crew_message.call("Evadin' her!")

      anchor.call(ship, true)
      sails.call(ship, false, true, true)
      last_turn = nil

      # Evading has an issue when The wooden wheel slowly turns off course. and
      # the ship becomes lost. This is related to the osa-map-plugin change to
      # not treat that same message as being 'lost'.
      while !$pursuit_ship.nil? && !$osa_stop_action
        unless OsaMap.current.wayto.keys.include?(last_turn)
          possible_directions = OsaMap.current.wayto.keys

          if possible_directions.count > 1
            possible_directions.delete(reverse[last_turn]) unless last_turn.nil?
          end

          last_turn = possible_directions.sample(1).first
          wheel.call(ship, last_turn)
        end

        ship_was_in = OsaMap.current.id
        wait_while { OsaMap.current.id == ship_was_in && !$osa_stop_action && !$pursuit_ship.nil? }
      end

      if $osa_stop_action
        crew_message.call('Yer in control')
      else
        crew_message.call('Got away!')
        wheel.call(ship, "")
        go.call(returnto)
      end
    end
  end

  UpstreamHook.remove('osa_stop_action')

  crew_message.call("You got da helm!")

  return
}

# Fires a single cannon, loading it if necessary.
#   parameters:
#   - ignored
fire_cmd = lambda { |params|
  returnto = Room.current.id
  ship = get_ship.call

  go.call(ship[:cannons][0])

  result = dothistimeout 'look cannon', 1, /Loaded/

  if result !~ /Loaded/
    go.call(ship[:supplies])
    fput 'get ball'
    pause 0.1
    waitrt?
    go.call(ship[:cannons][0])
    fput 'load cannon'
    pause 0.1
    waitrt?
  end

  fput 'fire cannon'
  pause 0.1
  waitrt?

  go.call(returnto)

  crew_message.call("Light 'em up!")
}

# Fires a single cannon, loading it if necessary.
#   parameters:
#   - ignored
flag_cmd = lambda { |params|
  returnto = Room.current.id
  ship = get_ship.call

  go.call(ship[:crowsnest])

  result = dothistimeout "ship flag #{params}", 2, /already flying|currently flying a|Time until flag can be changed|just (?:lowered|raised)/
  pause 0.1
  waitrt?

  if result =~ /Time until flag can be changed: (.*)/
    message = "Gotta wait anutter #{$1}."
  elsif result =~ /(?:currently|already) flying a (.* flag?)/
    message = "Flyin' da #{$1}."
  elsif result =~ /just raised a (.* flag) atop/
    message = "Raised da #{$1}."
  elsif result =~ /lowered the (.* flag) from atop/
    message = "Hidin' da #{$1}."
  end

  go.call(returnto)

  crew_message.call(message)
}

# Launches the ship from the port
#   parameters:
#   - ignored
launch_cmd = lambda { |params|
  if (ship = get_ship.call) != nil
    go.call(ship[:gangplank])
  else
    message_bold.call('You need to be on your ship to launch it.')
    return
  end

  go.call(ship[:gangplank])
  fput 'pull gang'

  anchor.call(ship, true)
  sails.call(ship, false, false, false)

  go.call(ship[:map])

  if defined?(OsaMap)
    fput 'look map'
    pause 1 # Vanity to keep the output cleaner
  end
}

# Loads all the unloaded cannons on the ship.
#   parameters:
#   - ignored
load_cmd = lambda { |params|
  returnto = Room.current.id
  ship = get_ship.call

  ship[:cannons].each { |cannon_room|
    go.call(cannon_room)

    loop do
      result = dothistimeout 'look cannon', 1, /Unloaded/
      break if result !~ /Unloaded/

      go.call(ship[:supplies])
      fput 'get ball'
      pause 0.1
      waitrt?
      go.call(cannon_room)
      fput 'load cannon'
      pause 0.1
      waitrt?
    end
  }

  go.call(returnto)

  crew_message.call('Cannons ready!')
}

# Repairs just the current room
#   parameters:
#   - ignored
patch_cmd = lambda { |params|
  ship = get_ship.call
  result = ''

  unless ship.nil?
    result = dothistimeout 'assess', 2, /^[^:]*It appears to be .* damaged|\d+/
    pause 0.1
    waitrt?

    if result =~ /It appears to be/
      fix_room.call(ship)
    else
      crew_message.call("Lookin' fine 'ere")
      return
    end

    return_planks.call(ship, true)
  end

  crew_message.call("That should hold 'er")
}

# Checks each room on the ship for damage and repairs it. If run during
# a boarding action, it doesn't go back and check for new damage after
# completing a room.
#   parameters:
#   - ignored
repair_cmd = lambda { |params|
  returnto = Room.current.id

  ship = get_ship.call
  result = ''

  if !ship.nil?
    ship_rooms = order_by_nearest.call(ship[:rooms])

    ship_rooms.each { |room|
      loop {
        go.call(room)

        result = dothistimeout 'assess', 2, /It appears to be .* damaged|\d+/
        pause 0.1
        waitrt?

        break unless result =~ /It appears to be/

        if result =~ /^[^:]*It appears to be .* damaged/
          fix_room.call(ship)
        elsif result =~ /^\s*([^:]*):\s*It appears to be .* damaged/
          damaged = $1
          crew_message.call("That #{damaged} needs attention!")
          room_to_fix = Map.list.find { |room| room.title[0] =~ /\[#{ship[:type]}, #{damaged}/i }

          if !room_to_fix.nil?
            go.call(room_to_fix.id)
          else
            crew_message.call("Where is da #{damaged}?")
            break
          end

          fix_room.call(ship)
        else
          crew_message.call("I don' know wha' I'm doin'")
          break
        end
      }

      # 100% health, no need to continue to other rooms
      break if result =~ /(\d{3,})\/\1/
    }

    return_planks.call(ship, false)

    go.call(returnto)

    crew_message.call('All fixed up!')
  else
    crew_message.call('What kinda ship is dis?')
  end
}

# String to determine if a given 'sail' command should just turn the wheel or
# search the map for matching rooms.
wheel_directions_builtin = ['north', 'northeast', 'east', 'southeast', 'south', 'southwest', 'west', 'northwest', 'left', 'right', 'island', 'ship', 'ne', 'se', 'sw', 'nw']
wheel_directions_port = ['port']

# Sails the ship in the direction or towards a target
#   parameters:
#   - the direction or target to sail towards
sail_cmd = lambda { |direction|
  returnto = Room.current.id
  ship = get_ship.call

  if wheel_directions_builtin.find { |builtin| builtin =~ /^#{direction}/i } ||
     (OsaMap.current.tags.find { |tag| tag =~ /port/i } && wheel_directions_port.find { |builtin| builtin =~ /^#{direction}/i })

    launch_cmd.call(nil)
    wheel.call(ship, direction)

    sails.call(ship, false, direction != 'ship', false) if direction != 'port'

    go.call(returnto)

    if direction == 'ship'
      crew_message.call("Pursuin' 'em!")
    elsif direction == 'port'
      crew_message.call('Docking her')
    else
      crew_message.call('Under way')
    end

  elsif Object.const_defined?(:OsaMap)
    launch_cmd.call(nil)
    sail2.call(ship, direction)

  else
    go.call(returnto)
    crew_message.call('Got no idea where ya wanna go')
  end
}

# Fires all the loaded cannons
#   parameters:
#   - ignored
volley_cmd = lambda { |params|
  returnto = Room.current.id
  ship = get_ship.call
  fired_one = false

  ship[:cannons].each { |cannon_room|
    go.call(cannon_room)
    loop do
      result = dothistimeout 'fire cannon', 2, /You fire|You'll need to load|You cannot fire/

      break if result !~ /You fire/

      fired_one = true

      pause 0.1
      waitrt?
    end
  }

  go.call(returnto)

  if fired_one
    crew_message.call("That'll send a message!")
  else
    crew_message.call("They don't load themselves")
  end
}

# ------------------------------------------------------------------------------------------------------------
# Register the commmands.
# ------------------------------------------------------------------------------------------------------------
# TODO: Now that this is close to done, refactor the commands all into a single downstream hook instead
#       of creating one per command.
add_command.call('anchor', anchor_cmd, 'Raises the sails and drops the anchor.')
add_command.call('engage', engage_cmd, 'Wait for enemy ships that meet certain criteria to engage. Flee from any other ships.')
add_command.call('fire', fire_cmd, 'Fires one cannon, loading it if necessary.')
add_command.call('flag', flag_cmd, 'Change the flag raised.')
add_command.call('launch', launch_cmd, 'Lowers the sails, raises the anchor, and pulls in the gang plank. If docked, will depart the dock.')
add_command.call('load', load_cmd, 'Loads all the cannons.')
add_command.call('patch', patch_cmd, 'Repairs the room you are currently in.')
add_command.call('repair', repair_cmd, 'Repairs the entire ship.')
add_command.call('sail', sail_cmd, 'Sets course in a direction, towards a target, to a room, to a sea, or to a town\'s port room. Not AFK friendly.')
add_command.call('volley', volley_cmd, 'Fires all the cannons.')

# Add help - this overrides lich's default ;help for better or worse.
help_cmd = proc { |_client_string|
  text = ''
  commands.each { |command|
    next if command[0] == 'osa help'

    command_link = "<d cmd='#{$clean_lich_char}#{'%-20s' % command[0]}'>#{$clean_lich_char}#{command[0]}</d>"
    command_help = "- #{command[1]}"
    text += "#{'%-45s' % command_link} #{'%-20s' % command_help}\n"
  }

  message_mono.call(text, true)
}

more_help_proc = proc { |client_string|
  help_text = <<-LONGHELP.chomp
  Provides the following commands while running:
    ;anchor - Raises the sails and drops the anchor.
    ;engage [ship-string] - Engage or evade enemy ships.
        - ship-string is a list of words for the types of ships to engage. Words can include:
           - ship :type => sloop, brigantine, etc
           - crew :type => krolvin, pirate, undead
           - cargo :type => battle-scarred, merchant, treasure
          If more than one word of the same type is given, it matches any of them.
          '|' can be used to create multiple expressions
          For example:
            ;engage pirate krolvin --> engage any dark or krolvin ship
            ;engage merchant --> engage any merchant ship
            ;engage undead carrack --> engage any type of ethereal carrack
            ;engage p m s --> only engage a dark merchant sloop
            ;engage p | t m --> engage any pirate ship OR any treasure or merchant ship
            ;engage --> engage any ship

         If you are in a veteran or better navigator role, will continue to navigate towards the
         enemy ship to reduce time to board.

         DOES NOT push the gangplank, board the enemy, fight mobs, or raze
         the enemy ship.
    ;fire - Fires one cannon, loading it if necessary.
    ;flag [black|white|neutral] - Change the flag raised.
    ;launch - Lowers the sails, raises the anchor, and pulls in the gang plank. If docked, will depart the dock.
    ;load - Loads all the cannons.
    ;patch - Repairs the room you are currently in. Grabs planks if needed and returns any extras back to the pile.
    ;repair - Attempts to repair the whole ship.
        - If you are in a veteran (or master) boatswain or master captain role, the command will continue until
          the entire ship is repaired. (Ideal if you are currently under cannon fire and taking new damage.)
        - Otherwise, it will run ;patch to completely repair each room once. (Fine except when under fire.)
    ;sail [direction|target] - Turns the wheel in a direction or attempts to navigate you to a destination.
        - Can be any of the wheel directions to just run to the wheel, turn it, and return.
          - In this case, the command just runs and control returns for the next command.
          - If ;osa-map-plugin is running, you can sail to
            - any OsaMap room id.
            - any sea or town (except the flotilla) by name
            - the nearest port (again, except the flotilla)
          For these options, the command continues to run (i.e. you can't issue any other of the script's
          commands) until you reach the destination room.
            - A ;stopsailing command is provided to stop script from continuing to control the ship

          It can correct for many problems but maybe not everything.  Veteran or better navigators will see best
          results since they can see the map in a storm and are less likely to get stuck or lost.

          If you know Breeze or Call Wind, will refill the sails every 80 or so seconds.

          If the destination is a port room, will automatically dock your ship.

          DOES NOT handle if you happen to be boarded while sailing.

          DOES NOT handle any damage taken while outrunning ships attempting to engage your.

          For example:
            ;sail port --> sail to the nearest port
            ;sail kraken --> sail to the Kraken's Fall port
            ;sail kra --> sail to the Kraken's Fall port
            ;sail haven --> sail to Solhaven
            ;sail mists --> sail to the nearest room in the Sea of Mists
            ;sail mirkewater --> sail to the nearest room in the Sea of Mists
            ;sail 700 --> sail to the River's Rest port by id
    ;volley - Fires all the cannons.
    ;osa help - Display a more abbreviated help message.
    ;osa help! - Displays this long help.
LONGHELP

  message_mono.call(help_text, true)
}

add_command.call('osa help!', more_help_proc, 'Displays long help text.')
add_command.call('osa help', help_cmd, 'Displays this help text.')

# Only needed for ;engage, but fun messaging to see while doing
# long distance sailing, too.
# TODO: Now that this is close to done, refactor this into the consolidated
#       hook for commands.
add_down_hook.call(
  'osa-enemy-watcher',
  proc { |game_line|
    if game_line =~ /((?:dark|ethereal|krolvin) (?:battle-marred|merchant|treasure) (?:[^<>]+)).*(?:materializes next to your ship|(?:ripping|carves) through the ocean toward your)/
      $pursuit_ship = $1
      crew_message.call("Enemy #{$pursuit_ship} spotted")
    elsif game_line =~ /changes course away from your/
      crew_message.call("We lost 'er!")
      $pursuit_ship = nil
    elsif game_line =~ /Several ropes with claw-shaped hooks on the end find purchase into the railing|You grab a nearby torch/
      # We should never get to the second message but it is a safety net.
      case $pursuit_ship
        when /dark/
          crew_message.call("Give 'em to Koar")
        when /ethereal/
          crew_message.call("Send da cursed devils ta da bottom of tha #{OsaMap.current.location}!")
        when /krolvin/
          crew_message.call("Show da scurvy dogs that #{OsaMap.current.location} is no place for dem")
      end
      $pursuit_ship = nil
    elsif game_line =~ /designated pier/
      crew_message.call("She won't follow us 'ere") unless $pursuit_ship.nil?
      $pursuit_ship = nil
    end

    game_line
  }
)

unless Script.running?('osa-map-plugin')
  if !Script.start('osa-map-plugin')
    error_message = "osa-map-plugin must be trusted and running for advanced sailing features.\n"
    error_message += ";repos download osa-map-plugin\n"
  elsif Script.running?('osa-map-plugin')
    pause 0.5
    error_message = "osa-map-plugin must be trusted and running for advanced sailing features.\n"
    error_message += ";repos download osa-map-plugin\n"
  end
end

unless defined?(OsaMap)
  error_message += ";trust osa-map-plugin\n"
  error_message += ";osa-map-plugin\n"
  error_message += "Then restart ;osa-commands again to enable them.\n"
  message_bold.call(error_message)

  Script.kill('osa-map-plugin') if Script.running?('osa-map-plugin')
end

# ------------------------------------------------------------------------------------------------------------
# Process commands so long as we're running.
# ------------------------------------------------------------------------------------------------------------
loop {
  (command, action, parameters) = $osa_cmd_queue.pop
  break if action.nil? # /Should/ never happen.

  if  command == 'osa help!' || command == 'osa help' || Room.current.title[0] !~ /Enemy Ship/
    action.call(parameters)
  else
    message_bold.call("Ignoring command #{command} because you've boarded an enemy ship.")
  end
}
