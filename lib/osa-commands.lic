=begin
    Reduces OSA tedium by adding a helpers for multistep actions.

    ;osa-commands

    author: Jymamon (gs4-jymamon@hotmail.com)
       game: Gemstone
       tags: osa
    version: 2022.12.03.02

    history:
        2022.12.03.02 - Fix hang manipulating sails where waitrt was triggering after the RT
                        already finished for some reason.
        2022.12.03.01 - Try suppporting ships other than a sloop.
        2022.12.02.01 - Better handling when sailing destination is same as current room.
        2022.11.30.03 - Fix response to anchor being dropped by a storm.
                        Fix sailing to handle player initiated RT between commands.
=end
=begin
        2022.11.30.02 - Better handling for a storm causing the anchor to drop or wheel to turn
                        to an invalid direction/nowhere.
                      - Support ships with more than one room with cannons.
                      - Update support for roles than can see damage in all room's.
        2022.11.30.01 - More automatic course correct - but you better be a veteran or better
                        Navigator for storms.
        2022.11.27.03 - Respond to various game lines while sailing to fix ship state. (Expiramental)
        2022.11.27.02 - Add ;stopsailing to stop a long sailing trip without having to
                        kill the script.
        2022.11.27.01 - Just a fun update for the crew announcements.
        2022.11.24.01 - Update ;sail for room ids, tags, locations. Not afk friendly, but
                        will get you there most of the time.
        2022.11.21.01 - Better ;repair when able to assess all rooms.
        2022.11.20.01 - New command: ;anchor - raises the sails and drops the anchor
        2022.11.16.02 - New command: ;patch - repairs just the current room
        2022.11.16.01 - New command: ;fire - fires a single cannon, loading it if needed
        2022.11.15.02 - New command: ;volley - fires all the loaded cannons
        2022.11.15.01 - Initial version. New commands: ;launch, ;load, ;repair, ;sail
=end

silence_me unless $osadebug
toggle_upstream
$osa_cmd_queue = Queue.new
commands = Array.new

# ------------------------------------------------------------------------------------------------------------
# General routines
# ------------------------------------------------------------------------------------------------------------

# Adds an downstream hook and ensures it is removed when the script exits
#   parameters:
#   - the string to register as the hook
#   - the action to call when the string is entered
add_down_hook = lambda { |hookname, hookproc|
  before_dying {
    DownstreamHook.remove(hookname)
  }

  DownstreamHook.add(hookname, hookproc)
}

# Adds an upstream hook and ensures it is removed when the script exits
#   parameters:
#   - the string to register as the hook
#   - the action to call when the string is entered
add_up_hook = lambda { |hookname, hookproc|
  before_dying {
    UpstreamHook.remove(hookname)
  }

  UpstreamHook.add(hookname, hookproc)
}

# Registers a new command for use while OSA is running.
#   parameters:
#   - the string to register as the command
#   - the action to call when the string is entered
#   Note: If the action is a lambda, it must take a single parameter
#         which is everything from the command line after the initial
#         command word.
add_command = lambda { |command, command_proc, help_text|
  hookname = "#{script.name}_#{command}_cmd"
  respond "Adding command #{$clean_lich_char}#{command}"

  hook_proc = proc { |client_string|
    if client_string =~ /^(?:<c>)?#{$clean_lich_char}(?:#{command})\s+(.*)/i
      params = $1.to_s
      $osa_cmd_queue << [command, command_proc, params]
      nil
    else
      client_string
    end
  }

  add_up_hook.call(hookname, hook_proc)

  commands << [command, help_text]
}

# Gets information for the current ship or nil if not on a ship.
#   parameters:
#   - none
get_ship = lambda {
  # Ship room data built from:
  # ships = Hash.new
  # ['Sloop', 'Brigantine', 'Carrack', 'Galleon', 'Frigate', 'Man O\' War'].each{|ship_type|
  #    if !ship_type.nil? && ship_type != ""
  #        ship = Hash.new
  #        ship[:type] = ship_type.downcase
  #        ship[:capstan] = Map.list.find{|room| room.title[0] =~ /^\[#{ship_type}, Helm\]$/}.id
  #        ship[:cannons] = Map.list.find_all{|room| room.title[0] =~ /^\[#{ship_type}, (?:Main|Forward) Deck\]$/}.map{|room| room.id}
  #        ship[:crowsnest] = Map.list.find{|room| room.title[0] =~ /^\[#{ship_type}, Crow's Nest\]$/}.id
  #        ship[:gangplank] = Map.list.find{|room| room.title[0] =~ /^\[#{ship_type}, Main Deck\]$/}.id
  #        ship[:map] = Map.list.find{|room| room.title[0] =~ /^\[#{ship_type}, Captain's Quarters\]$/}.id
  #        ship[:node] = Map.list.find{|room| room.title[0] =~ /^\[#{ship_type}, Captain's Quarters\]$/}.id
  #        ship[:sails] = Map.list.find_all{|room| room.title[0] =~ /^\[#{ship_type}, (?:Main|Forward) Deck\]$/}.map{|room| room.id}
  #        ship[:supplies] = Map.list.find{|room| room.title[0] =~ /^\[#{ship_type}, Cargo Hold\]$/}.id
  #        ship[:wheel] =  Map.list.find{|room| room.title[0] =~ /^\[#{ship_type}, Helm\]$/}.id
  #        ship[:rooms] = ship.select{|k, v| k!=:type}.values.flatten.uniq
  #
  #        ships[ship_type] = ship
  #    else
  #        nil
  #    end
  # }
  #
  # ships.keys.each{|ship_type|
  #    puts "\"#{ship_type}\" => {\n"
  #    ships[ship_type].keys.each{|symbol|
  #        if symbol==:type
  #            puts "    :#{symbol} => \"#{ships[ship_type][symbol]}\",\n"
  #        else
  #            puts "    :#{symbol} => #{ships[ship_type][symbol]},\n"
  #        end
  #    }
  #    puts "},\n"
  # }
  # which is painfully too slow to run at startup of this script. Instead of optimizing, just use
  # the results since they're unlikely to change much. (Famous last words?)
  #
  # So far, I only have a sloop to mess with, so other ship types haven't been tested.

  ships = {
    "Sloop" => {
      :type => "sloop",
      :capstan => 29041,
      :cannons => [29038],
      :crowsnest => 29040,
      :gangplank => 29038,
      :map => 29042,
      :node => 29042,
      :sails => [29038],
      :supplies => 29039,
      :wheel => 29041,
      :rooms => [29041, 29038, 29040, 29042, 29039],
    },
    "Brigantine" => {
      :type => "brigantine",
      :capstan => 30141,
      :cannons => [30142, 30144],
      :crowsnest => 30143,
      :gangplank => 30142,
      :map => 30140,
      :node => 30140,
      :sails => [30142, 30144],
      :supplies => 30145,
      :wheel => 30141,
      :rooms => [30141, 30142, 30144, 30143, 30140, 30145],
    },
    "Carrack" => {
      :type => "carrack",
      :capstan => 30120,
      :cannons => [30119, 30121],
      :crowsnest => 30123,
      :gangplank => 30119,
      :map => 30124,
      :node => 30124,
      :sails => [30119, 30121],
      :supplies => 30125,
      :wheel => 30120,
      :rooms => [30120, 30119, 30121, 30123, 30124, 30125],
    },
    "Galleon" => {
      :type => "galleon",
      :capstan => 30179,
      :cannons => [30176, 30177],
      :crowsnest => 30181,
      :gangplank => 30176,
      :map => 30180,
      :node => 30180,
      :sails => [30176, 30177],
      :supplies => 30182,
      :wheel => 30179,
      :rooms => [30179, 30176, 30177, 30181, 30180, 30182],
    },
    "Frigate" => {
      :type => "frigate",
      :capstan => 30174,
      :cannons => [30166, 30171],
      :crowsnest => 30173,
      :gangplank => 30166,
      :map => 30175,
      :node => 30175,
      :sails => [30166, 30171],
      :supplies => 30167,
      :wheel => 30174,
      :rooms => [30174, 30166, 30171, 30173, 30175, 30167],
    },
    "Man O' War" => {
      :type => "man o' war",
      :capstan => 30128,
      :cannons => [30130, 30132],
      :crowsnest => 30134,
      :gangplank => 30130,
      :map => 30129,
      :node => 30129,
      :sails => [30130, 30132],
      :supplies => 30136,
      :wheel => 30128,
      :rooms => [30128, 30130, 30132, 30134, 30129, 30136],
    },
  }

  if Room.current.title[0] =~ /^\[(#{ships.keys.join('|')}),/
    ship_type = $1

    if !ship_type.nil? && ship_type != "" && ships.key?(ship_type)
      ships[ship_type]
    else
      nil
    end
  else
    nil
  end
}

# Runs ;go2 to move to a specified room
#   parameters:
#   - the room to move to
#   - any additional parameters to pass to ;go2
go = lambda { |room, parameters = nil|
  script_parameters = ["_disable_confirm_"]

  if (!parameters.nil?)
    if parameters.class == String
      script_parameters.push(parameters)
    elsif parameters.class == Array
      script_parameters.concat(parameters)
    else
      Message.bold "Ignoring parameters I don't know how to handle: #{parameters}!"
    end
  end

  if (Room.current.id != room)
    script_parameters.push(room)
    start_script "go2", script_parameters
    wait_while { running? "go2" }
  end
}

# Runs ;go2 to move to a specified room, performs an action,
# then returns to the initial room.
#   parameters:
#   - the room to move to
#   - the action to perform there
go_do_this = Proc.new { |room, action, parameters|
  returnto = Room.current.id
  go.call(room);
  action.call(parameters);
  go.call(returnto);
}

# Displays a message to the client. The message will be in bold if the client
# supports that.
#   parameters:
#   - The message to display
message_bold = lambda { |text|
  stringArray  = Array.new
  stringArray  = (text.gsub(/[\n]+/, "o=\_=zz")).split(/o=\_=zz/)
  begin_text   = "<pushBold\/>"
  end_text     = "<popBold\/>"

  if $fake_stormfront
    begin_text = "\034GSL\r\n "
    end_text   = "\034GSM\r\n "
  end

  stringArray.each { |line|
    puts "#{begin_text}#{line.gsub('\n', '')}#{end_text}"
  }
}

# Force a message to be monospaced in Stormfront. Just outputs the message
# in Wizard since that's a monospaced interface already. Also stolen from
# a script by Casis.
message_mono = lambda { |text, bold = false|
  stringArray  = Array.new
  stringArray  = (text.gsub(/[\n]+/, "cr#lf")).split(/cr#lf/)
  begin_text   = "<output class=\"mono\"\/>"
  end_text     = "<output class=\"\"\/>"

  if $fake_stormfront
    begin_text = ""
    end_text   = ""
  end

  if bold
    begin_text = "#{begin_text}<pushBold\/>"
    end_text = "<popBold\/>#{end_text}"
  end

  text = "#{begin_text}"
  stringArray.each { |line|
    text += "#{line}\n"
  }
  text += "#{end_text}"

  puts "#{text}"
}

# Orders a list of target rooms by nearest to furthest
#   parameters:
#   - The rooms to be ordered
order_by_nearest = lambda { |targets|
  start_room = Room.current
  previous, shortest_distances = Map.dijkstra(Room.current.id.to_i)
  return targets.reject { |t|
           shortest_distances[t].nil?
         }.sort { |a, b| shortest_distances[a] <=> shortest_distances[b] };
}

# ------------------------------------------------------------------------------------------------------------
# Common, ship related, actions
# ------------------------------------------------------------------------------------------------------------

# Tries to give message_bold some personality.
#   parameters:
#   - The message to display
crew_message = lambda { |text|
  punctuation = "!"

  if (text =~ /([!\.\?])$/)
    punctuation = $1
    text.chop!
  end

  # If they were in the same room, we'd see who ;) These should be valid on all ships. I hope?
  # Crew isn't in the Captain's Quarters!
  fromthe = ["Main Deck", "Helm", "Cargo Hold", "Crow's Nest"]
            .find_all { |title| Room.current.title[0] !~ /#{title}/i }
            .sample(1)
            .first

  who = ["someone", "a crewman", "a crewwoman", "a crewmember", "a voice", "a deckhand", "the first mate"]
        .sample(1)
        .first

  verb = {
    "?" => ["ask", "wonder", "query"].sample(1).first(),
    "." => ["state", "announce", "say"].sample(1).first(),
    "!" => ["shout", "call out", "yell"].sample(1).first()
  }

  text = "From the #{fromthe} you hear #{who} #{verb[punctuation]}, \"#{text}, Cap'n#{punctuation}\""
  message_bold.call(text)
}

# Raises or lowers the anchor
#   parameters:
#   - ship - the current ship
#   - true/false - raising (true) or lowering (false) the anchor
anchor = lambda { |ship, raise|
  returnto = Room.current.id
  go.call(ship[:capstan])

  if raise
    loop do
      result = dothistimeout "push capstan", 5,
                             /You manage to push|You can now DEPART|you shove|The anchor is already up!/
      pause 0.1
      waitrt?

      if result =~ /DEPART/
        fput "depart"
        fput "depart"
      end

      break if result =~ /DEPART|already up/
    end
  else
    fput "kick capstan"
    pause 0.1
    waitrt?
  end

  go.call(returnto)
}

# Gets the current wheel direction
#   parameters:
#   - none
current_direction = lambda { |ship|
  returnto = Room.current.id
  go.call(ship[:wheel])

  direction = nil

  result = dothistimeout "look wheel", 2, /The wooden wheel is currently turned (.*)$/

  if (result =~ /to the (.*)\.$/)
    direction = $1
  elsif (result =~ /nowhere in particular/)
    direction = "nowhere"
  elsif (result =~ /toward a (.*)\.$/)
    direction = $1
  end

  go.call(returnto)

  message_bold.call("The wheel is turned #{direction}") if $osadebug

  return direction
}

# Applies planks to a room until it is fixed.
#   parameters:
#   - none
fix_room = lambda { |ship|
  loop do
    result = dothistimeout "get plank", 2, /Get what\?|plank|You already have that/

    if (result =~ /Get what\?/)
      count = ship[:supplies] == Room.current.id ? 0 : 3
      go_do_this.call(
        ship[:supplies],
        lambda { |params|
          1.upto(count) {
            fput "get wood"
            waitrt
            fput "stow plank"
          }

          fput "get wood";
          waitrt;
        },
        nil
      )
    end

    result = dothistimeout "fix", 2, /repair some|repair all/
    waitrt

    break if result =~ /repair all/
  end
}

# Raises or lowers the sails and optionall tries to fill them with magical wind
#   parameters:
#   - ship - the current ship
#   - true/false - raising (true) or lowering (false) the sails
#   - true/false - true if 612/912 should be cast at the sails (if known)
sails = lambda { |ship, raise, wind|
  returnto = Room.current.id
  ship[:sails].each { |sail_room|
    go.call(sail_room)

    result = dothistimeout "look sail", 1, /currently raised|half mast|fully lowered/

    if raise
      if (result =~ /fully lowered/)
        fput "raise sail"
        pause 0.2 && waitrt?
        fput "raise sail"
        pause 0.2 && waitrt?
      elsif (result =~ /half mast/)
        fput "raise sail"
        pause 0.2 && waitrt?
      end
    else
      if (result =~ /currently raised/)
        fput "lower sail"
        pause 0.2 && waitrt?
        fput "lower sail"
        pause 0.2 && waitrt?
      elsif (result =~ /half mast/)
        fput "lower sail"
        pause 0.2 && waitrt?
      end

      if wind
        if Spell[912].known? && result !~ /filled with magical wind/
          Spell[912].cast("sail")
          waitcastrt
        elsif Spell[612].known? && result !~ /filled with magical wind/
          Spell[612].cast("sail")
          waitcastrt
        end
      end
    end
  }

  go.call(returnto)
}

# Returns extra planks to the supply room.
#   parameters:
#   - none
return_planks = lambda { |ship, goback|
  returnto = Room.current.id
  go.call(ship[:supplies])

  loop do
    result = dothistimeout "get plank", 2, /Get what\?|plank|You already have that/

    if (result !~ /Get what\?/)
      fput "put plank in wood"
    else
      break
    end
  end

  go.call(returnto) if goback
}

wheel = lambda { |ship, direction|
  go.call(ship[:wheel])

  waitrt?
  result = dothistimeout "turn wheel #{direction}", 2, /do your best to steer|you'd have better luck|already turned/

  if result =~ /better luck|already turned/
    crew_message.call("You been nippin' da rum too much") unless direction = ""
    return
  end

  waitrt
}

# ------------------------------------------------------------------------------------------------------------
# Command implementations
# ------------------------------------------------------------------------------------------------------------

# Anchoers the boat.
#   parameters:
#   - ignored
anchor_cmd = lambda { |params|
  returnto = Room.current.id
  ship = get_ship.call()

  anchor.call(ship, false)
  sails.call(ship, true, false)

  go.call(returnto)
  crew_message.call("We ain't going nowhere now!")
}

# Fires a single cannon, loading it if necessary.
#   parameters:
#   - ignored
fire_cmd = lambda { |params|
  returnto = Room.current.id
  ship = get_ship.call()

  go.call(ship[:cannons][0])

  result = dothistimeout "look cannon", 1, /Loaded/

  if result !~ /Loaded/
    go.call(ship[:supplies])
    fput "get ball"
    waitrt
    go.call(ship[:cannons][0])
    fput "load cannon"
    waitrt
  end

  fput "fire cannon"
  pause 0.1
  waitrt?

  go.call(returnto)

  crew_message.call("Light 'em up!")
}

# Launches the ship from the port
#   parameters:
#   - ignored
launch_cmd = lambda { |params|
  if (ship = get_ship.call) != nil
    case ship[:type]
    when 'sloop'
      go.call(ship[:gangplank])
    else
      crew_message.call("I have no idea what kind of ship this is")
      return
    end
  elsif  GameObj.loot.any? { |c| c.noun == "gangplank" }
    fput "go gangplank"
    ship = get_ship.call
  elsif  GameObj.loot.any? { |c| c.noun == "sloop" } # Not so bright... what if it is someone elses's sloop?
    fput "go sloop"
    ship = get_ship.call
  else
    message_bold.call("You need to be on or in front of your ship to launch it.")
    return
  end

  go.call(ship[:gangplank])
  fput "pull gang"

  anchor.call(ship, true)
  sails.call(ship, false, false)

  go.call(ship[:map])

  if (defined?(OsaMap))
    fput "look map"
  end

  crew_message.call("We're afloat!")
}

# Loads all the unloaded cannons on the ship.
#   parameters:
#   - ignored
load_cmd = lambda { |params|
  returnto = Room.current.id
  ship = get_ship.call()

  ship[:cannons].each { |cannon_room|
    go.call(cannon_room)

    loop do
      result = dothistimeout "look cannon", 1, /Unloaded/
      break if result !~ /Unloaded/

      go.call(ship[:supplies])
      fput "get ball"
      waitrt
      go.call(cannon_room)
      fput "load cannon"
      waitrt
    end
  }

  go.call(returnto)

  crew_message.call("Cannons ready!")
}

# Repairs just the current room
#   parameters:
#   - ignored
patch_cmd = lambda { |params|
  ship = get_ship.call()
  result = ""

  if !ship.nil?
    result = dothistimeout "assess", 2, /^[^:]*It appears to be .* damaged|\/\d+/
    waitrt

    if (result =~ /It appears to be/)
      fix_room.call(ship)
    else
      crew_message.call("Lookin' fine 'ere")
      return
    end

    return_planks.call(ship, true)
  end

  crew_message.call("That should hold 'er")
}

# Checks each room on the ship for damage and repairs it. If run during
# a boarding action, it doesn't go back and check for new damage after
# completing a room.
#   parameters:
#   - ignored
repair_cmd = lambda { |params|
  returnto = Room.current.id

  ship = get_ship.call()
  result = ""

  if !ship.nil?
    ship_rooms = order_by_nearest.call(ship[:rooms])

    ship_rooms.each { |room|
      loop do
        go.call(room)

        result = dothistimeout "assess", 2, /It appears to be .* damaged|\/\d+/
        waitrt

        if (result =~ /It appears to be/)

          if (result =~ /^[^:]*It appears to be .* damaged/)
            fix_room.call(ship)
          elsif (result =~ /^\s*([^:]*):\s*It appears to be .* damaged/)
            damaged = $1
            crew_message.call("That #{damaged} needs attention!")
            room_to_fix = Map.list.find { |room| room.title[0] =~ /\[#{ship[:type]}, #{damaged}/i }

            if !room_to_fix.nil?
              go.call(room_to_fix.id)
            else
              crew_message.call("Where is da #{damaged}?")
              break
            end

            fix_room.call(ship)
          else
            crew_message.call("I don' know wha' I'm doin'")
            break
          end
        else
          break
        end
      end

      # 100% health, no need to continue to other rooms
      break if result =~ /(\d{3,})\/\1/
    }

    return_planks.call(ship, false)

    go.call(returnto)

    crew_message.call("All fixed up!")
  else
    crew_message.call("What kinda ship is dis?")
  end
}

# String to determine if a given 'sail' command should just turn the wheel or
# search the map for matching rooms.
wheel_directions_builtin = ["north", "northeast", "east", "southeast", "south", "southwest", "west", "northwest",
                            "left", "right", "port", "island", "ship", "ne", "se", "sw", "nw"]

# Sails the ship in the direction or towards a target
#   parameters:
#   - the direction or target to sail towards
sail_cmd = lambda { |direction|
  returnto = Room.current.id
  ship = get_ship.call()

  if wheel_directions_builtin.find { |builtin| builtin =~ /^#{direction}/i }
    wheel.call(ship, direction)

    if (direction != "port")
      sails.call(ship, false, direction != "ship")
    end

    go.call(returnto)

    if direction == "ship"
      crew_message.call("Pursuin' 'em!")
    elsif direction == "port"
      crew_message.call("Docking her")
    else
      crew_message.call("Under way")
    end

  elsif (Object.const_defined?(:OsaMap))
    navigate = nil
    # V1 - assume the ship is launched but otherwise unmoving. Otherwise, a move while
    # we're setting up can much with things. Really, we probably want to get the route
    # list more frequently
    if (!OsaMap.current.is_mapped?)
      go.call(ship[:map])
      fput "look map"
      # It takes a moment for the map data to update
      pause 0.2
    end

    if OsaMap.current.id == 0
      go.call(returnto)
      crew_message.call("We are nae at sea")
      return
    elsif !OsaMap.current.is_mapped?
      go.call(returnto)
      crew_message.call("But we're lost!")
      return
    end

    if (direction =~ /^\d+$/)
      navigate = Ocean.current.path_to(direction.to_i)
    else
      # Maybe move this to OsaMap.path_to instead?
      targets = OsaMap.list.find_all { |destination|
        destination.tags.any? { |tag|
          tag =~ /#{direction}/i
        } || destination.location =~ /#{direction}/i
      }.map { |target| target.id }

      if targets.length == 0
        go.call(returnto)
        crew_message.call("No knowin' where #{direction} is")
        return
      end

      navigate = Ocean.current.path_to(targets)
    end

    # TODO: Handle finding path failed.
    if navigate.length == 0
      destination_room = OsaMap.current.id
    else
      destination_room = navigate[-1]
    end

    if destination_room != OsaMap.current.id
      crew_message.call("Headin' to #{destination_room} in the #{OsaMap[destination_room].location}")

      go.call(ship[:wheel])

      sails.call(ship, false, true)
      last_sail_check = Time.now
      sailing = current_direction.call(ship)
      last_ocean = OsaMap.current.location

      # Allow ;stopsailing to stop the process
      crew_message.call("Jus' tell us ta ;stopsailing if ya want the helm back.")
      $stop_sailing = false
      add_up_hook.call(
        "stop_sailing",
        proc { |client_string|
          if client_string =~ /^(?:<c>)?#{$clean_lich_char}stopsailing/i
            params = $1.to_s
            $stop_sailing = true
            nil
          elsif client_string =~ /^(?:<c>)?#{$clean_lich_char}checkanchor/i
            $sailing_cmd_queue.push(lambda { |ship| anchor.call(ship, true) })
            nil
          elsif client_string =~ /^(?:<c>)?#{$clean_lich_char}checkmap/i
            $sailing_cmd_queue.push(lambda { |ship|
                                      go.call(ship[:map]); fput "look map"; go.call(ship[:wheel])
                                    })
            nil
          elsif client_string =~ /^(?:<c>)?#{$clean_lich_char}checksails/i
            $sailing_cmd_queue.push(lambda { |ship| sails.call(ship, false, true) })
            nil
          else
            client_string
          end
        }
      )

      # Do we really need a queue here? Anchor, sails, wheel are all we deal with. Using
      # a queue means we could raise, lower, turn more than once per iteration which is
      # redundant.  Just make a set of flags for things to check?
      $sailing_cmd_queue = Array.new
      turn = nil
      add_down_hook.call(
        "fix_ship_conditions",
        proc { |game_line|
          if game_line =~ /sound of ropes coming free of the rigging/
            $sailing_cmd_queue.push(lambda { |ship| sails.call(ship, false, true) })          
          elsif game_line =~ /The sound of the anchor can be heard rattling down the side/
            $sailing_cmd_queue.push(lambda { |ship| anchor.call(ship, true) })
          elsif game_line =~ /strains against the deployed anchor/
            $sailing_cmd_queue.push(lambda { |ship| anchor.call(ship, true) })
          elsif game_line =~ /wooden wheel slowly turns off course/
            # Looking at the map isn't really what is fixing anything. Rather, interrupting the loop and making
            # it recalculate is.
            $sailing_cmd_queue.push(lambda { |ship| go.call(ship[:map]); fput "look map"; go.call(ship[:wheel]) })
          elsif game_line =~ /the wooden wheel spins out of control/
            # Looking at the map isn't really what is fixing anything. Rather, interrupting the loop and making
            # it recalculate is.
            $sailing_cmd_queue.push(lambda { |ship| go.call(ship[:map]); fput "look map"; go.call(ship[:wheel]) })
          elsif game_line =~ /rocks idly in the ocean waters/
            # Looking at the map isn't really what is fixing anything. Rather, interrupting the loop and making
            # it recalculate is.
            $sailing_cmd_queue.push(lambda { |ship| go.call(ship[:map]); fput "look map"; go.call(ship[:wheel]) })
          #These lines confirm this works, but I never see the above happen?            
          #elsif game_line =~ /do your best to steer the ship/
          #  $sailing_cmd_queue.push(lambda { |ship| go.call(ship[:map]); fput "look map"; go.call(ship[:wheel]) })
          end

          game_line
        }
      )

      go.call(returnto) # Return now or first iteration keeps us at the wheel.
      while (nextroom = navigate.shift)
        break if $stop_sailing

        # Handle player moving around while ;sail is running. Maybe we should just set returnto
        # to this room instead?
        returnto = Room.current.id
        sailing_from = OsaMap.current.id
        turn = Ocean.current.wayto.invert[nextroom]

        message_bold.call("Heading from #{sailing_from} to #{nextroom} to the #{turn}") if $osadebug

        if (turn != sailing)
          wheel.call(ship, turn)
          sailing = turn
        end

        if (Spell[612].known? || Spell[912].known?) && ((Time.now - last_sail_check) > 45)
          last_sail_check = Time.now
          sails.call(ship, false, true)
        end

        go.call(returnto)

        # Instead of waiting on it being a specific room, wait in it having
        # changed at all.  If it changed and isn't what was expected, repopulate
        # navigate[] based on the current room.
        wait_while { Ocean.current.id == sailing_from && !$stop_sailing && $sailing_cmd_queue.empty? }

        if $sailing_cmd_queue.any?
          while (action = $sailing_cmd_queue.shift)
            crew_message.call("Lookin' after dat problem.")
            action.call(ship) unless $stop_sailing
          end
        end

        if (Ocean.current.location != last_ocean)
          crew_message.call("We've entered #{Ocean.current.location} (#{Ocean.current.id})!")
          last_ocean = Ocean.current.location
        end

        if (Ocean.current.id != nextroom && !$stop_sailing)
          crew_message.call("Adjustin' course!")

          if !Ocean.current.is_mapped?
            go.call(ship[:map])
            fput "look map"
            go.call(ship[:wheel])
            sailing = current_direction.call(ship)
          end

          navigate = Ocean.current.path_to(destination_room)
        end
      end

      UpstreamHook.remove("stop_sailing")
      DownstreamHook.remove("fix_ship_conditions")
    end

    if $stop_sailing
      crew_message.call("The helm's yers!")
    else
      if Ocean.current.tags.any? { |tag| tag =~ /port/i }
        crew_message.call("Figurin' ya wan' 'er at da docks")
        wheel.call(ship, "port")
        waitfor("designated pier")
      else
        # Turns the wheel to point 'nowhere in particular' so we quit sailing
        wheel.call(ship, "")
      end

      go.call(returnto)

      if (OsaMap.current.id == destination_room)
        crew_message.call("We've arrived!")
      else
        crew_message.call("Youse better take over!")
        message_bold.call("Sailing to #{OsaMap.current.id} but ended up in #{destination_room}") if $osadebug
      end
    end

  else
    go.call(returnto)
    crew_message.call("Got no idea where ya wanna go")
  end
}

# Fires all the loaded cannons
#   parameters:
#   - ignored
volley_cmd = lambda { |params|
  returnto = Room.current.id
  ship = get_ship.call()
  fired_one = false

  ship[:cannons].each { |cannon_room|
    go.call(cannon_room)
    loop do
      result = dothistimeout "fire cannon", 2, /You fire|You'll need to load|You cannot fire/

      if result !~ /You fire/
        break
      else
        fired_one = true
      end

      waitrt?
    end
  }

  go.call(returnto)

  if fired_one
    crew_message.call("That'll send a message!")
  else
    crew_message.call("They don't load themselves")
  end
}

# ------------------------------------------------------------------------------------------------------------
# Register the commmands.
# ------------------------------------------------------------------------------------------------------------
add_command.call("anchor", anchor_cmd, "Raises the sails and drops the anchor.")
add_command.call("fire", fire_cmd, "Fires one cannon, loading it if necessary.")
add_command.call("launch", launch_cmd,
                 "Lowers the sails, raises the anchor, and pulls in the gang plank. If docked, will depart the dock.")
add_command.call("load", load_cmd, "Loads all the cannons.")
add_command.call("patch", patch_cmd, "Repairs the room you are currently in.")
add_command.call("repair", repair_cmd, "Repairs the entire ship.")
add_command.call("sail", sail_cmd,
                 "Sets course in a direction, towards a target, to a room, to a sea, or to a town's port room. Not AFK friendly.")
add_command.call("volley", volley_cmd, "Fires all the cannons.")

# Add help - this overrides lich's default ;help for better or worse.
help_cmd = proc { |client_string|
  text = ""
  commands.each { |command|
    next if command[0] == "osa help"

    command_link = "<d cmd='#{$clean_lich_char}#{'%-20s' % command[0]}'>#{$clean_lich_char}#{command[0]}</d>"
    command_help = "- #{command[1]}"
    text += "#{'%-45s' % command_link} #{'%-20s' % command_help}\n"
  }

  message_mono.call(text, true)
}

add_command.call("osa help", help_cmd, "Displays this help text.")

if !Script.running?("osa-map-plugin") || !defined?(OsaMap)
  error_message = "osa-map-plugin must be trusted and running for advanced sailing features.\n"

  if !Script.running?("osa-map-plugin")
    if !Script.start("osa-map-plugin")
      error_message = "osa-map-plugin must be trusted and running for advanced sailing features.\n"
      error_message += ";repos download osa-map-plugin\n"
    elsif Script.running?("osa-map-plugin")
      pause 0.5
      error_message = "osa-map-plugin must be trusted and running for advanced sailing features.\n"
      error_message += ";repos download osa-map-plugin\n"
    end
  end

  if !defined?(OsaMap)
    error_message += ";trust osa-map-plugin\n"
    error_message += ";osa-map-plugin\n"
    error_message += "Then restart ;osa-commands again to enable them.\n";
    message_bold.call(error_message);

    Script.kill("osa-map-plugin") if Script.running?("osa-map-plugin")
  end
end

# ------------------------------------------------------------------------------------------------------------
# Process commands so long as we're running.
# ------------------------------------------------------------------------------------------------------------
loop do
  (command, action, parameters) = $osa_cmd_queue.pop
  break if action.nil? # /Should/ never happen.

  if (command == "osa help" || Room.current.title[0] !~ /Enemy Ship/)
    action.call(parameters)
  else
    message_bold.call("Ignoring command #{command} because you've boarded an enemy ship.");
  end
end
