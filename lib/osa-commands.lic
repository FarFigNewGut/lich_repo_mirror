=begin
    Reduces OSA tedium by adding a helpers for multistep actions.

    ;osa-commands

    author: Jymamon (gs4-jymamon@hotmail.com)
       game: Gemstone
       tags: osa
    version: 2022.12.02.01

    history:
        2022.12.02.01 - Better handling when sailing destination is same as current room.
        2022.11.30.03 - Fix response to anchor being dropped by a storm.
                        Fix sailing to handle player initiated RT between commands.
        2022.11.30.02 - Better handling for a storm causing the anchor to drop or wheel to turn
                        to an invalid direction/nowhere.
                      - Support ships with more than one room with cannons.
                      - Update support for roles than can see damage in all room's.
        2022.11.30.01 - More automatic course correct - but you better be a veteran or better
                        Navigator for storms.
        2022.11.27.03 - Respond to various game lines while sailing to fix ship state. (Expiramental)
        2022.11.27.02 - Add ;stopsailing to stop a long sailing trip without having to
                        kill the script.
=end
=begin
        2022.11.27.01 - Just a fun update for the crew announcements.
        2022.11.24.01 - Update ;sail for room ids, tags, locations. Not afk friendly, but
                        will get you there most of the time.
        2022.11.21.01 - Better ;repair when able to assess all rooms.
        2022.11.20.01 - New command: ;anchor - raises the sails and drops the anchor
        2022.11.16.02 - New command: ;patch - repairs just the current room
        2022.11.16.01 - New command: ;fire - fires a single cannon, loading it if needed
        2022.11.15.02 - New command: ;volley - fires all the loaded cannons
        2022.11.15.01 - Initial version. New commands: ;launch, ;load, ;repair, ;sail
=end

silence_me unless $osadebug
toggle_upstream
$osa_cmd_queue = Queue.new
commands = Array.new

# ------------------------------------------------------------------------------------------------------------
# General routines
# ------------------------------------------------------------------------------------------------------------

# Adds an downstream hook and ensures it is removed when the script exits
#   parameters:
#   - the string to register as the hook
#   - the action to call when the string is entered
add_down_hook = lambda {|hookname, hookproc|
    before_dying {
        DownstreamHook.remove(hookname)
    }

    DownstreamHook.add(hookname, hookproc)
}

# Adds an upstream hook and ensures it is removed when the script exits
#   parameters:
#   - the string to register as the hook
#   - the action to call when the string is entered
add_up_hook = lambda {|hookname, hookproc|
    before_dying {
        UpstreamHook.remove(hookname)
    }

    UpstreamHook.add(hookname, hookproc)
}

# Registers a new command for use while OSA is running.
#   parameters:
#   - the string to register as the command
#   - the action to call when the string is entered
#   Note: If the action is a lambda, it must take a single parameter
#         which is everything from the command line after the initial
#         command word.
add_command = lambda {|command, command_proc, help_text|
    hookname = "#{script.name}_#{command}_cmd"
    respond "Adding command #{$clean_lich_char}#{command}"

    hook_proc = proc {|client_string|
        if client_string =~ /^(?:<c>)?#{$clean_lich_char}(?:#{command})\s+(.*)/i
            params = $1.to_s
            $osa_cmd_queue << [command, command_proc, params]
            nil
        else
            client_string
        end
    }

    add_up_hook.call(hookname, hook_proc)

    commands << [command, help_text]
}

# Gets information for the current ship or nil if not on a ship.
#   parameters:
#   - none
get_ship = lambda {
    # So far, I only have a sloop to mess with, so I'm guessing the correct
    # rooms on the others. Some are obvious, others seem right based on
    # the narost maps but the actual descriptions leave me wondering.
    ship = {
        'Sloop' => {
            :type => 'sloop',
            :cannons => [29038],
            :capstan => 29041,
            :crowsnest => 29040,
            :gangplank => 29038,
            :map => 29042,
            :node => 29042,
            :sails => [29038],
            :supplies => 29039,
            :wheel => 29041,
            # Named rooms for Captain's and Boatswains who
            # can see damage for the whole ship.
            "Crow's Nest" => 29040,
            "Captain's Quarters" => 29042,
            "Cargo Hold" => 29039,
            "Helm" => 29041,
            "Main Deck" => 29038,
        },
    }
    ships_needed = {
        'Brigantine' => {
            :type => 'brigantine',
            :cannons => [30144],
            :capstan => 30141,
            :crowsnest => 30143,
            :gangplank => 30142,
            :map => 30140,
            :node => 30140,
            :sails => [30142],
            :supplies => 30145,
            :wheel => 30141
        },
        'Carrack' => {
            :type => 'carrack',
            :cannons => [30144],
            :capstan => 30141,
            :crowsnest => 30143,
            :gangplank => 30142,
            :map => 30140,
            :node => 30140,
            :sails => [30142],
            :supplies => 30145,
            :wheel => 30141
        },
        'Galleon' => {
            :type => 'galleon',
            :cannons => [30144],
            :capstan => 30141,
            :crowsnest => 30143,
            :gangplank => 30142,
            :map => 30140,
            :node => 30140,
            :sails => [30142],
            :supplies => 30145,
            :wheel => 30141
        },
        'Frigate' => {
            :type => 'frigate',
            :cannons => [30144],
            :capstan => 30141,
            :crowsnest => 30143,
            :gangplank => 30142,
            :map => 30140,
            :node => 30140,
            :sails => [30142],
            :supplies => 30145,
            :wheel => 30141
        }
    }

    ship.keys.each{|type|
        ship[type][:rooms] = ship[type]
            .select{|k, v| k!=:type}
            .values
            .flatten
            .uniq
    }

    Room.current.title[0] =~ /^\[(#{ship.keys.join('|')}),/

    if $1 != "" && !$1.nil?
        ship[$1]
    else
        nil
    end
}

# Runs ;go2 to move to a specified room
#   parameters:
#   - the room to move to
#   - any additional parameters to pass to ;go2
go = lambda {|room, parameters=nil|
    script_parameters = ["_disable_confirm_"]

    if (!parameters.nil?)
        if parameters.class==String
            script_parameters.push(parameters)
        elsif parameters.class==Array
            script_parameters.concat(parameters)
        else
            Message.bold "Ignoring parameters I don't know how to handle: #{parameters}!"
        end
    end

    if ( Room.current.id != room )
        script_parameters.push(room)
        start_script "go2", script_parameters
        wait_while{running? "go2"}
    end
}

# Runs ;go2 to move to a specified room, performs an action,
# then returns to the initial room.
#   parameters:
#   - the room to move to
#   - the action to perform there
go_do_this = Proc.new {|room, action, parameters|
    returnto = Room.current.id
    go.call(room);
    action.call(parameters);
    go.call(returnto);
}

# Displays a message to the client. The message will be in bold if the client
# supports that.
#   parameters:
#   - The message to display
message_bold = lambda{|text|
    stringArray  = Array.new
    stringArray  = (text.gsub(/[\n]+/, "o=\_=zz")).split(/o=\_=zz/)
    begin_text   = "<pushBold\/>"
    end_text     = "<popBold\/>"

    if $fake_stormfront
        begin_text = "\034GSL\r\n "
        end_text   = "\034GSM\r\n "
    end

    stringArray.each { |line|
        puts "#{begin_text}#{line.gsub('\n','')}#{end_text}"
    }
}

# Force a message to be monospaced in Stormfront. Just outputs the message
# in Wizard since that's a monospaced interface already. Also stolen from
# a script by Casis.
message_mono = lambda{|text, bold=false|
    stringArray  = Array.new
    stringArray  = (text.gsub(/[\n]+/, "cr#lf")).split(/cr#lf/)
    begin_text   = "<output class=\"mono\"\/>"
    end_text     = "<output class=\"\"\/>"

    if $fake_stormfront
        begin_text = ""
        end_text   = ""
    end

    if bold
        begin_text = "#{begin_text}<pushBold\/>"
        end_text = "<popBold\/>#{end_text}"
    end

    text = "#{begin_text}"
    stringArray.each { |line|
        text += "#{line}\n"
    }
    text += "#{end_text}"

    puts "#{text}"
}

# Orders a list of target rooms by nearest to furthest
#   parameters:
#   - The rooms to be ordered
order_by_nearest = lambda{|targets|
    start_room   = Room.current
    previous, shortest_distances = Map.dijkstra(Room.current.id.to_i)
    return targets.reject{|t| shortest_distances[t].nil?}.sort{|a,b| shortest_distances[a]<=>shortest_distances[b]};
}

# ------------------------------------------------------------------------------------------------------------
# Common, ship related, actions
# ------------------------------------------------------------------------------------------------------------

# Tries to give message_bold some personality.
#   parameters:
#   - The message to display
crew_message = lambda{|text|
    punctuation = "!"

    if ( text =~ /([!\.\?])$/ )
        punctuation = $1
        text.chop!
    end

    # If they were in the same room, we'd see who ;) These should be valid on all ships. I hope?
    # Crew isn't in the Captain's Quarters!
    fromthe = ["Main Deck", "Helm", "Cargo Hold", "Crow's Nest"]
        .find_all{|title| Room.current.title[0] !~ /#{title}/i }
        .sample(1)
        .first

    who = ["someone", "a crewman", "a crewwoman", "a crewmember", "a voice", "a deckhand", "the first mate"]
        .sample(1)
        .first

    verb = {
        "?" => ["ask", "wonder", "query"].sample(1).first(),
        "." => ["state", "announce", "say"].sample(1).first(),
        "!" => ["shout", "call out", "yell"].sample(1).first()
    }

    text = "From the #{fromthe} you hear #{who} #{verb[punctuation]}, \"#{text}, Cap'n#{punctuation}\""
    message_bold.call(text)
}

# Raises or lowers the anchor
#   parameters:
#   - ship - the current ship
#   - true/false - raising (true) or lowering (false) the anchor
anchor = lambda { |ship, raise|
    returnto = Room.current.id
    go.call(ship[:capstan])

    if raise
        loop do
            result = dothistimeout "push capstan", 5, /You manage to push|You can now DEPART|you shove|The anchor is already up!/
            pause 0.1
            waitrt?

            if result =~ /DEPART/
                fput "depart"
                fput "depart"
            end

            break if result =~ /DEPART|already up/
        end
    else
        fput "kick capstan"
        pause 0.1
        waitrt?
    end

    go.call(returnto)
}

# Gets the current wheel direction
#   parameters:
#   - none
current_direction = lambda {|ship|
    returnto = Room.current.id
    go.call(ship[:wheel])

    direction = nil

    result = dothistimeout "look wheel", 2, /The wooden wheel is currently turned (.*)$/

    if ( result =~ /to the (.*)\.$/ )
        direction = $1
    elsif ( result =~ /nowhere in particular/ )
        direction = "nowhere"
    elsif ( result =~ /toward a (.*)\.$/ )
        direction = $1
    end

    go.call(returnto)

    message_bold.call("The wheel is turned #{direction}") if $osadebug

    return direction
}

# Applies planks to a room until it is fixed.
#   parameters:
#   - none
fix_room = lambda {|ship|
    loop do
        result = dothistimeout "get plank", 2, /Get what\?|plank|You already have that/

        if ( result =~ /Get what\?/ )
            count = ship[:supplies] == Room.current.id ? 0 : 3
            go_do_this.call(
                ship[:supplies],
                lambda { |params|
                    1.upto(count) {
                        fput "get wood";
                        waitrt;
                        fput "stow plank"
                    }

                    fput "get wood";
                    waitrt;
                },
                nil)
        end

        result = dothistimeout "fix", 2, /repair some|repair all/
        waitrt

        break if result =~ /repair all/
    end
}

# Raises or lowers the sails and optionall tries to fill them with magical wind
#   parameters:
#   - ship - the current ship
#   - true/false - raising (true) or lowering (false) the sails
#   - true/false - true if 612/912 should be cast at the sails (if known)
sails = lambda { |ship, raise, wind|
    returnto = Room.current.id
    ship[:sails].each {|sail_room|
        go.call(sail_room)

        result = dothistimeout "look sail", 1, /currently raised|half mast|fully lowered/

        if raise
            if (result =~ /fully lowered/)
                fput "raise sail"
                waitrt
                fput "raise sail"
                waitrt
            elsif (result =~ /half mast/)
                fput "raise sail"
                waitrt
            end
        else
            if (result =~ /currently raised/)
                fput "lower sail"
                waitrt
                fput "lower sail"
                waitrt
            elsif (result =~ /half mast/)
                fput "lower sail"
                waitrt
            end

            if wind
                if Spell[912].known? && result !~ /filled with magical wind/
                    Spell[912].cast("sail")
                    waitcastrt
                elsif Spell[612].known? && result !~ /filled with magical wind/
                    Spell[612].cast("sail")
                    waitcastrt
                end
            end
        end
    }

    go.call(returnto)
}

# Returns extra planks to the supply room.
#   parameters:
#   - none
return_planks = lambda {|ship, goback|
    returnto = Room.current.id
    go.call(ship[:supplies])

    loop do
        result = dothistimeout "get plank", 2, /Get what\?|plank|You already have that/

        if ( result !~ /Get what\?/ )
            fput "put plank in wood"
        else
            break
        end
    end

    go.call(returnto) if goback
}

wheel = lambda {|ship, direction|
    go.call(ship[:wheel])

    waitrt?
    result = dothistimeout "turn wheel #{direction}", 2, /do your best to steer|you'd have better luck|already turned/

    if result =~ /better luck|already turned/
        crew_message.call("You been nippin' da rum too much") unless direction = ""
        return
    end

    waitrt
}

# ------------------------------------------------------------------------------------------------------------
# Command implementations
# ------------------------------------------------------------------------------------------------------------

# Anchoers the boat.
#   parameters:
#   - ignored
anchor_cmd = lambda {|params|
    returnto = Room.current.id
    ship = get_ship.call()

    anchor.call(ship, false)
    sails.call(ship, true, false)

    go.call(returnto)
    crew_message.call("We ain't going nowhere now!")
}

# Fires a single cannon, loading it if necessary.
#   parameters:
#   - ignored
fire_cmd = lambda {|params|
    returnto = Room.current.id
    ship = get_ship.call()

    go.call(ship[:cannons][0])

    result = dothistimeout "look cannon", 1, /Loaded/

    if result !~ /Loaded/
        go.call(ship[:supplies])
        fput "get ball"
        waitrt
        go.call(ship[:cannons][0])
        fput "load cannon"
        waitrt
    end

    fput "fire cannon"
    pause 0.1
    waitrt?

    go.call(returnto)

    crew_message.call("Light 'em up!")
}

# Launches the ship from the port
#   parameters:
#   - ignored
launch_cmd = lambda {|params|
    if (ship = get_ship.call) != nil
        case ship[:type]
        when 'sloop'
            go.call(ship[:gangplank])
        else
            crew_message.call("I have no idea what kind of ship this is")
            return
        end
    elsif  GameObj.loot.any?{|c| c.noun=="gangplank"}
        fput "go gangplank"
        ship = get_ship.call
    elsif  GameObj.loot.any?{|c| c.noun=="sloop"}
        fput "go sloop"
        ship = get_ship.call
    else
        crew_message.call("I don't know where you are")
        return
    end

    go.call(ship[:gangplank])
    fput "pull gang"

    anchor.call(ship, true)

    go.call(ship[:map])

    if (defined?(OsaMap))
        fput "look map"
    end

    crew_message.call("We're afloat!")
}

# Loads all the unloaded cannons on the ship.
#   parameters:
#   - ignored
load_cmd = lambda {|params|
    returnto = Room.current.id
    ship = get_ship.call()

    ship[:cannons].each{|cannon_room|
        go.call(cannon_room)

        loop do
            result = dothistimeout "look cannon", 1, /Unloaded/
            break if result !~ /Unloaded/
            go.call(ship[:supplies])
            fput "get ball"
            waitrt
            go.call(cannon_room)
            fput "load cannon"
            waitrt
        end
    }

    go.call(returnto)

    crew_message.call("Cannons ready!")
}

# Repairs just the current room
#   parameters:
#   - ignored
patch_cmd = lambda {|params|
    ship = get_ship.call()
    result = ""

    if !ship.nil?
        result = dothistimeout "assess", 2, /^[^:]*It appears to be .* damaged|\/\d+/
        waitrt

        if (result =~ /It appears to be/)
            fix_room.call(ship)
        else
            crew_message.call("Lookin' fine 'ere")
            return
        end

        return_planks.call(ship, true)
    end

    crew_message.call("That should hold 'er")
}

# Checks each room on the ship for damage and repairs it. If run during
# a boarding action, it doesn't go back and check for new damage after
# completing a room.
#   parameters:
#   - ignored
repair_cmd = lambda {|params|
    returnto = Room.current.id

    ship = get_ship.call()
    result = ""

    if !ship.nil?
        ship_rooms = order_by_nearest.call(ship[:rooms])

        ship_rooms.each{|room|
            loop do
                go.call(room)

                result = dothistimeout "assess", 2, /It appears to be .* damaged|\/\d+/
                waitrt

                if (result =~ /It appears to be/)

                    if (result =~ /^[^:]*It appears to be .* damaged/)
                        fix_room.call(ship)
                    elsif (result =~ /^\s*([^:]*):\s*It appears to be .* damaged/)
                        damaged = $1

                        crew_message.call("That #{damaged} needs attention!")

                        if ship.key?(damaged)
                            go.call(ship[damaged])
                        else
                            crew_message.call("Where is da #{damaged}?")
                            break
                        end

                        fix_room.call(ship)
                    else
                        crew_message.call("I don' know wha' I'm doin'")
                        break
                    end
                else
                    break
                end
            end

            # 100% health, no need to continue to other rooms
            break if result =~ /(\d{3,})\/\1/
        }

        return_planks.call(ship, false)

        go.call(returnto)

        crew_message.call("All fixed up!")
    else
        crew_message.call("What kinda ship is dis?")
    end
}

# String to determine if a given 'sail' command should just turn the wheel or
# search the map for matching rooms.
wheel_directions_builtin = ["north", "northeast", "east", "southeast", "south", "southwest", "west", "northwest", "left", "right", "port", "island", "ship", "ne", "se", "sw", "nw"]

# Sails the ship in the direction or towards a target
#   parameters:
#   - the direction or target to sail towards
sail_cmd = lambda {|direction|
    returnto = Room.current.id
    ship = get_ship.call()

    if wheel_directions_builtin.find{|builtin| builtin =~ /^#{direction}/i}
        wheel.call(ship, direction)

        if ( direction != "port" )
            sails.call(ship, false, direction != "ship")
        end

        go.call(returnto)

        if direction == "ship"
            crew_message.call("Pursuin' 'em!")
        elsif direction == "port"
            crew_message.call("Docking her")
        else
            crew_message.call("Under way")
        end

    elsif (Object.const_defined?(:OsaMap))
        navigate = nil
        # V1 - assume the ship is launched but otherwise unmoving. Otherwise, a move while
        # we're setting up can much with things. Really, we probably want to get the route
        # list more frequently
        if ( !OsaMap.current.is_mapped? )
            go.call(ship[:map])
            fput "look map"
            # It takes a moment for the map data to update
            pause 0.2
        end

        if OsaMap.current.id == 0
            go.call(returnto)
            crew_message.call("We are nae a sea")
            return
        elsif !OsaMap.current.is_mapped?
            go.call(returnto)
            crew_message.call("But we're lost!")
            return
        end

        if (direction =~ /^\d+$/)
            navigate = Ocean.current.path_to(direction.to_i)
        else
            # Maybe move this to OsaMap.path_to instead?
            targets = OsaMap.list.find_all { |destination|
                destination.tags.any? {|tag|
                    tag =~ /#{direction}/i
                } || destination.location =~ /#{direction}/i
            }.map{|target| target.id}

            if targets.length == 0
                go.call(returnto)
                crew_message.call("No knowin' where #{direction} is")
                return
            end

            navigate = Ocean.current.path_to(targets)
        end

        # TODO: Handle finding path failed.
        # TODO: Handle already in the right room better.
        if navigate.length == 0
            destination_room = OsaMap.current.id
        else
            destination_room = navigate[-1]
        end
        
        if destination_room != OsaMap.current.id
            crew_message.call("Headin' to #{destination_room} in the #{OsaMap[destination_room].location}")

            go.call(ship[:wheel])

            sails.call(ship, false, true)
            last_sail_check = Time.now
            sailing = current_direction.call(ship)
            last_ocean = OsaMap.current.location

            # Allow ;stopsailing to stop the process
            crew_message.call("Jus' tell us ta ;stopsailing if ya want the helm back.")
            $stop_sailing = false
            add_up_hook.call(
                "stop_sailing",
                proc {|client_string|
                    if client_string =~ /^(?:<c>)?#{$clean_lich_char}stopsailing/i
                        params = $1.to_s
                        $stop_sailing = true
                        nil
                    elsif client_string =~ /^(?:<c>)?#{$clean_lich_char}checkanchor/i
                        $sailing_cmd_queue.push(lambda { |ship| anchor.call(ship, true) })
                        nil
                    elsif client_string =~ /^(?:<c>)?#{$clean_lich_char}checkmap/i
                        $sailing_cmd_queue.push(lambda { |ship| go.call(ship[:map]); fput "look map"; go.call(ship[:wheel])})
                        nil
                    elsif client_string =~ /^(?:<c>)?#{$clean_lich_char}checksails/i
                        $sailing_cmd_queue.push(lambda { |ship| sails.call(ship, false, true)})
                        nil
                    else
                        client_string
                    end
                })

            # Storms can drop the anchor, raise the sails, maybe more. Try to handle when those
            # happen so we can keep sailing.
            # Do we really need a queue here? Anchor, sails, wheel are all we deal with. Using
            # a queue means we could raise, lower, turn more than once per iteration which is
            # redundant.  Just make a set of flags for things to check? (Re-routing logic in the
            # main loop addresses looking at the map.)
            $sailing_cmd_queue = Array.new
            turn = nil
            add_down_hook.call(
                "fix_ship_conditions",
                proc {|game_line|
                    if game_line =~ /^The sound of ropes coming free of the rigging prelude the whipping of a rectangular sail!/
                        $sailing_cmd_queue.push(lambda { |ship| anchor.call(ship, true) })
                    elsif game_line =~ /^A large swell crashes into the side of the .*!  The sound of the anchor can be heard rattling down the side of the .*\./
                        $sailing_cmd_queue.push(lambda { |ship| anchor.call(ship, true) })
                    elsif game_line =~ /^The .* lurches forward as it strains against the deployed anchor\./
                        $sailing_cmd_queue.push(lambda { |ship| sails.call(ship, false, true)})
                    elsif game_line =~ /^The wooden wheel slowly turns off course./
                        $sailing_cmd_queue.push(lambda { |ship| go.call(ship[:map]); fput "look map"; go.call(ship[:wheel])})
                    elsif game_line =~ /as the wooden wheel spins out of control!/
                        $sailing_cmd_queue.push(lambda { |ship| go.call(ship[:map]); fput "look map"; go.call(ship[:wheel])})
                    elsif game_line =~ /^Aimless, the .* rocks idly in the ocean waters./
                        # This won't fix anything but detects the player did /something/ that messed up nav. This was
                        # probably something that caused RT and prevents us from turning the wheel.
                        $sailing_cmd_queue.push(lambda { |ship| go.call(ship[:map]); fput "look map"; go.call(ship[:wheel])})
                    end

                    game_line
                })

            go.call(returnto) # Return now or first iteration keeps us at the wheel.
            while (nextroom = navigate.shift)
                break if $stop_sailing

                # Handle player moving around while ;sail is running. Maybe we should just set returnto
                # to this room instead?
                returnto = Room.current.id
                sailing_from = OsaMap.current.id
                turn = Ocean.current.wayto.invert[nextroom]

                message_bold.call("Heading from #{sailing_from} to #{nextroom} to the #{turn}") if $osadebug

                if ( turn != sailing )
                    wheel.call(ship, turn)
                    sailing = turn
                end

                if (Spell[612].known? || Spell[912].known?) && ((Time.now - last_sail_check) > 45)
                    last_sail_check = Time.now
                    sails.call(ship, false, true)
                end

                go.call(returnto)

                # Instead of waiting on it being a specific room, wait in it having
                # changed at all.  If it changed and isn't what was expected, repopulate
                # navigate[] based on the current room.
                wait_while { Ocean.current.id == sailing_from && !$stop_sailing && $sailing_cmd_queue.empty?}

                if $sailing_cmd_queue.any?
                    while (action = $sailing_cmd_queue.shift)
                        message_bold.call("Doin' somethin' for a moment.")
                        action.call(ship) unless $stop_sailing
                    end
                end

                if ( Ocean.current.location != last_ocean )
                    crew_message.call("We've entered #{Ocean.current.location}!")
                    last_ocean = Ocean.current.location
                end

                if ( Ocean.current.id != nextroom && !$stop_sailing )
                    crew_message.call("Adjustin' course!")

                    if !Ocean.current.is_mapped?
                        go.call(ship[:map])
                        fput "look map"
                        go.call(ship[:wheel])
                        sailing = current_direction.call(ship)
                    end

                    navigate = Ocean.current.path_to(destination_room)
                end
            end

            UpstreamHook.remove("stop_sailing")
            DownstreamHook.remove("fix_ship_conditions")
        end

        if $stop_sailing
            crew_message.call("The helm's yers!")
        else
            if Ocean.current.tags.any?{|tag| tag =~ /port/i}
                crew_message.call("Figurin' ya wan' 'er at da docks")
                wheel.call(ship, "port")
                waitfor("designated pier")
            else
                # Turns the wheel to point 'nowhere in particular' so we quit sailing
                wheel.call(ship, "")
            end

            go.call(returnto)

            if ( OsaMap.current.id == destination_room )
                crew_message.call("We've arrived!")
            else
                crew_message.call("You better take over!")
                message_bold.call("Sailing to #{OsaMap.current.id} but ended up in #{destination_room}") if $osadebug
            end
        end

    else
        go.call(returnto)
        crew_message.call("Got no idea where ya wanna go")
    end
}

# Fires all the loaded cannons
#   parameters:
#   - ignored
volley_cmd = lambda {|params|
    returnto = Room.current.id
    ship = get_ship.call()
    fired_one = false

    ship[:cannons].each{|cannon_room|
        go.call(cannon_room)
        loop do
            result = dothistimeout "fire cannon", 2, /You fire|You'll need to load|You cannot fire/

            if result !~ /You fire/
                break
            else
                fired_one = true
            end

            waitrt?
        end
    }

    go.call(returnto)

    if fired_one
        crew_message.call("That'll send a message!")
    else
        crew_message.call("They don't load themselves")
    end
}

# ------------------------------------------------------------------------------------------------------------
# Register the commmands.
# ------------------------------------------------------------------------------------------------------------
add_command.call("anchor", anchor_cmd, "Raises the sails and drops the anchor.")
add_command.call("fire", fire_cmd, "Fires one cannon, loading it if necessary.")
add_command.call("launch", launch_cmd, "Lowers the sails, raises the anchor, and pulls in the gang plank. If docked, will depart the dock.")
add_command.call("load", load_cmd, "Loads all the cannons.")
add_command.call("patch", patch_cmd, "Repairs the room you are currently in.")
add_command.call("repair", repair_cmd, "Repairs the entire ship.")
add_command.call("sail", sail_cmd, "Sets course in a direction, towards a target, to a room, to a sea, or to a town's port room. Not AFK friendly.")
add_command.call("volley", volley_cmd, "Fires all the cannons.")

# Add help - this overrides lich's default ;help for better or worse.
help_cmd = proc {|client_string|
    text = ""
    commands.each{|command|
        next if command[0] == "osa help"
        command_link = "<d cmd='#{$clean_lich_char}#{'%-20s' % command[0]}'>#{$clean_lich_char}#{command[0]}</d>"
        command_help = "- #{command[1]}"
        text += "#{'%-45s' % command_link} #{'%-20s' % command_help}\n"
    }

    message_mono.call(text, true)
}

add_command.call("osa help", help_cmd, "Displays this help text.")

if !Script.running?("osa-map-plugin") || !defined?(OsaMap)
    error_message = "osa-map-plugin must be trusted and running for advanced sailing features.\n"

    if !Script.running?("osa-map-plugin")
        if !Script.start("osa-map-plugin")
            error_message = "osa-map-plugin must be trusted and running for advanced sailing features.\n"
            error_message += ";repos download osa-map-plugin\n"
        elsif Script.running?("osa-map-plugin")
            pause 0.5
            error_message = "osa-map-plugin must be trusted and running for advanced sailing features.\n"
            error_message += ";repos download osa-map-plugin\n"
        end
    end

    if !defined?(OsaMap)
        error_message += ";trust osa-map-plugin\n"
        error_message += ";osa-map-plugin\n"
        error_message += "Then restart ;osa-commands again to enable them.\n";
        message_bold.call(error_message);

        Script.kill("osa-map-plugin") if Script.running?("osa-map-plugin")
    end
end

# ------------------------------------------------------------------------------------------------------------
# Process commands so long as we're running.
# ------------------------------------------------------------------------------------------------------------
loop do
    (command, action, parameters) = $osa_cmd_queue.pop
    break if action.nil? # /Should/ never happen.

    if ( command == "osa help" || Room.current.title[0] !~ /Enemy Ship/ )
        action.call(parameters)
    else
        message_bold.call("Ignoring command #{command} because you've boarded an enemy ship.");
    end
end
