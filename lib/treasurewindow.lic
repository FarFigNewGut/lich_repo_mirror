=begin
  Original Wrayth FE Window
    https://discordapp.com/channels/226045346399256576/1339018254517145681

    New GTK Window for Avalon and Wizard FEs
    https://discordapp.com/channels/226045346399256576/1386507836191670342

  This script creates a dedicated window to display treasure objects in real time.

  Features:
  - Continuously updates with treasures found in the room.
  - Automatically removes treasures that disappear.
  - Clickable links to interact with treasure objects.
  - Incorporates killtracker output if killtracker is running.  Killtracker is courtesy of Alastir and Nisugi.
  - Adds click commands to facilitate looting the entire room or executing the eloot lich script.

  Commands:
       *click - Enable or disable LOOT ROOM and ELOOT clickable links in window.
           *twcol - Swap between single and double column layouts.
           *twgtk - Enable GTK window.

  Changelog:
     1.4.0 (2025-06-23)
           Added Wizard and Avalon FE compatability via implementation of a GTK window.
     1.3.1 (2025-06-07)
           Column button removed.  Command is *twcol to swap between single and double column layouts.
        Dead creatures output removed.
        Layout button added to toggle between a one or two column format.
        Will save state between sessions for all commands.
   1.2.2.(2025-05-6)
        Fix for Moonsedge bounties.
    1.2.1 (2025-05-2)
        Added an upstream hook to allow users to turn the clickable LOOT ROOM and ELOOT commands on or off.  They are off by default now.
    1.2.0 (2025-04-30)
        Added LOOT ROOM command.  Will empty and fill right hand automatically to loot room.
        Added eloot command.
        Dead Creature output added. Can click on dead creature to loot creature.
   1.1.0 (2025-04-26)
       Killtracker output removed from creaturewindow and moved to treasurewindow.
   1.0.0 (2025-02-11)
        Initial release.

author: Phocosoen, ChatGPT
tags: wrayth, frontend, mod, window, treasures, gems, coins, artifacts, loot, looting, avalon, wizard
version: 1.4.0

=end

no_kill_all

require 'yaml'
require 'gtk3'

class TreasureWindowGtk
  @window       = nil
  @css_provider = nil
  @font_size    = nil

  # Regenerates & reapplies our CSS (called after font‐size, mode, etc. change)
  def self.reload_css
    css = <<~CSS
						/* tighten up header-bar buttons */
						window#treasurewindow headerbar .header-toggle {
								margin: 0 2px;    /* horiz space between buttons */
								padding: 2px 4px; /* shrink the click target */
						}

						/* give the whole window a 2px solid grey border */
						window#treasurewindow {
								border: 2px solid #888888;
								border-radius: 4px;
						}

      /* Base label font size */
      window#treasurewindow label {
        font-size: #{@font_size}px;
      }

      /* Light-mode background */
      window#treasurewindow:not(.dark),
      window#treasurewindow:not(.dark), headerbar,
      window#treasurewindow:not(.dark), GtkScrolledWindow,
      window#treasurewindow:not(.dark), GtkFlowBox {
        background-color: #C0C0C0;
      }

      /* Light mode text */
      window#treasurewindow:not(.dark) label {
        color: #000000;
      }

      /* Dark-mode background */
      window#treasurewindow.dark,
      window#treasurewindow.dark headerbar,
      window#treasurewindow.dark GtkScrolledWindow,
      window#treasurewindow.dark GtkFlowBox {
        background-color: #000000;
      }

      /* Dark-mode text */
      window#treasurewindow.dark label {
        color: #FFFFFF;
      }

      /* HeaderBar toggles/buttons in dark mode */
      window#treasurewindow.dark headerbar .header-toggle {
        background-image: none;
        background-color: transparent;
        color:            #FFFFFF;
        border:           none;
        box-shadow:       none;
      }

      /* Highlight “on” state */
      window#treasurewindow.dark headerbar .header-toggle:checked {
        background-color: #444444;
      }

    CSS

    @css_provider.load(data: css)
  end

  def self.create_main_window
    return if @window

    # ——— load persisted settings ———
    settings = load_window_settings
    tw = settings["treasurewindow"] ||= {}

    dark_mode = tw["dark_mode"] || false
    @font_size = tw["font_size"] || 14

    # ——— build top‐level window & HeaderBar ———
    @window = Gtk::Window.new(:toplevel)
    @window.set_name("treasurewindow")
    @window.set_border_width(10)
    @window.set_type_hint(Gdk::WindowTypeHint::UTILITY)
    @window.set_keep_above(true)

    header = Gtk::HeaderBar.new
    header.show_close_button = true
    header.title = "TW"

    # — Font size buttons —
    dec_btn = Gtk::Button.new(label: "A−")
    inc_btn = Gtk::Button.new(label: "A+")
    [dec_btn, inc_btn].each { |b| b.style_context.add_class("header-toggle"); header.pack_start(b) }
    dec_btn.signal_connect("clicked") do
      @font_size = [@font_size - 1, 8].max
      tw["font_size"] = @font_size; save_window_settings(settings)
      reload_css
    end
    inc_btn.signal_connect("clicked") do
      @font_size = [@font_size + 1, 30].min
      tw["font_size"] = @font_size; save_window_settings(settings)
      reload_css
    end

    # — Dark/Light switch —
    theme_switch = Gtk::Switch.new
    theme_switch.active = dark_mode
    @window.style_context.add_class("dark") if dark_mode
    theme_switch.signal_connect("notify::active") do |sw, _|
      if sw.active?
        @window.style_context.add_class("dark")
      else
        @window.style_context.remove_class("dark")
      end
      tw["dark_mode"] = sw.active?; save_window_settings(settings)
      reload_css
    end
    header.pack_end(theme_switch)

    @window.set_titlebar(header)

    # — CSS provider & initial styling —
    @css_provider = Gtk::CssProvider.new
    reload_css
    screen = Gdk::Screen.default
    Gtk::StyleContext.add_provider_for_screen(
      screen,
      @css_provider,
      Gtk::StyleProvider::PRIORITY_APPLICATION
    )

    # — Restore geometry —
    @window.resize(tw["width"], tw["height"]) if tw["width"] && tw["height"]
    @window.move(tw["x"], tw["y"]) if tw["x"] && tw["y"]

    @scroll = Gtk::ScrolledWindow.new
    @scroll.set_policy(Gtk::PolicyType::AUTOMATIC, Gtk::PolicyType::AUTOMATIC)
    @scroll.set_hexpand(false)
    @scroll.set_vexpand(true)

    @flow = Gtk::FlowBox.new
    @flow.selection_mode        = :none
    @flow.max_children_per_line = 2
    @flow.column_spacing        = 0
    @flow.row_spacing           = 0
    @flow.set_hexpand(false)
    @flow.set_vexpand(true)
    @flow.valign                = Gtk::Align::START
    @flow.homogeneous           = false
    @scroll.add(@flow)

    @window.add(@scroll)

    # — save geometry on move/resize —
    @ignore_next_configure = true
    @window.signal_connect("configure_event") do |_w, _ev|
      if @ignore_next_configure
        @ignore_next_configure = false
      else
        x, y = @window.position
        w, h = @window.size
        s = load_window_settings
        s["treasurewindow"] ||= {}
        s["treasurewindow"].merge!("x" => x, "y" => y, "width" => w, "height" => h)
        save_window_settings(s)
      end
      false
    end

    @window.signal_connect("destroy") do
      @window = nil
      Gtk.main_quit
    end
    @window.show_all
  end # ← end create_main_window

  # -----------------------------------------------------------------------
  # now the updater lives _outside_ of create_main_window
  def self.add_full_row(left_text = "", right_text = "")
    # left label
    lbl_left = Gtk::Label.new(left_text)
    lbl_left.set_xalign(0)
    @flow.add(lbl_left)

    # right label
    lbl_right = Gtk::Label.new(right_text)
    lbl_right.set_xalign(0)
    @flow.add(lbl_right)
  end

def self.killtracker_two_columns
  lines = killtracker_summary_lines
  # For the "all gems found" case, "All Gems Found for Month!" will be at lines[2]
  if lines[2] =~ /All Gems Found for Month!/
    left = [lines[2], lines[7], lines[4], lines[5]]
    right = ["", "", "", ""]
    # Remove trailing empty rows
    left.pop while left.last == "" && left.size > 0
    right.pop while right.last == "" && right.size > 0
    [left, right]
  else
    # Regular two-column output for <3 gems found
    lines = (lines + Array.new(12, "")).first(12)
    left  = lines[2..5]  # Weekly column (skip the summary and divider)
    right = lines[7..10] # Monthly column (skipping the extra dividers)
    # Remove trailing empty rows
    left.pop while left.last == "" && left.size > 0
    right.pop while right.last == "" && right.size > 0
    [left, right]
  end
end

  # inside class TreasureWindowGtk, after add_full_row…
  def self.update_treasures(treasures, _summary_lines)
    return unless @window
    Gtk.queue do
      @flow.children.each { |c| @flow.remove(c) }

      # -- Always format killtracker summary in two columns --
      if Script.running?("killtracker") && defined?($killtracker) && $killtracker.is_a?(Hash)
        left, right = killtracker_two_columns
        max = [left.size, right.size].max
        (0...max).each do |i|
          add_full_row(left[i] || "", right[i] || "")
        end
        add_full_row("", "") # Spacer row if desired

      end

      # -- Treasures: single column --
      add_full_row("Treasures: #{treasures.size}", "")
      treasures.each do |t|
        lbl = Gtk::Label.new("#{t.name}")
        lbl.set_xalign(0)
        @flow.add(lbl)
      end

      @flow.show_all
    end
  end
end

# where to store our window settings
LICH5_PATHS = [
  "C:\\Lich5\\scripts",
  File.expand_path("~/Desktop/Lich5/scripts")
]

WINDOW_SETTINGS_PATH = nil

LICH5_PATHS.each do |path|
  next unless path && Dir.exist?(path)
  WINDOW_SETTINGS_PATH = File.join(path, "lichwraythwindows.yaml")
  break
end

# Fallback if nothing matched
WINDOW_SETTINGS_PATH ||= File.join(Dir.ewd, "lichwraythwindows.yaml")

def load_window_settings
  return {} unless File.exist?(WINDOW_SETTINGS_PATH)
  YAML.load_file(WINDOW_SETTINGS_PATH) || {}
end

def save_window_settings(settings)
  File.write(WINDOW_SETTINGS_PATH, settings.to_yaml)
rescue => e
  echo "creaturewindow: failed to save window settings: #{e.message}"
end

$treasure_settings       = load_window_settings
$treasure_window         = $treasure_settings["treasurewindow"] ||= {}
$use_gtk_window = $treasure_window["use_gtk_window"] || false

# if they’ve explicitly enabled GTK, always launch it
if $use_gtk_window
  respond ""
  respond " Initiating GTK window."
  respond ""
  respond " GTK Treasurewindow is active."
  respond ""
  Gtk.queue do
    TreasureWindowGtk.create_main_window
    Gtk.main
  end

# otherwise fall back to “if non-Stormfront” auto-GTK
elsif $frontend != "stormfront"
  respond ""
  respond " Using a frontend other than Wrayth."
  respond ""
  respond " Initiating GTK window."
  respond ""
  Gtk.queue do
    TreasureWindowGtk.create_main_window
    Gtk.main
  end
end

if $frontend == "stormfront"
  puts("<closeDialog id='TreasureWindow'/><openDialog type='dynamic' id='TreasureWindow' title='Treasure' target='TreasureWindow' scroll='manual' location='main' justify='3' height='100' resident='true'><dialogData id='TreasureWindow'></dialogData></openDialog>")
end

@last_treasures = []

def format_reset_time(seconds_left)
  return "Reset soon!" if seconds_left <= 0
  days = seconds_left / 86400
  hours = (seconds_left % 86400) / 3600
  minutes = (seconds_left % 3600) / 60
  if days > 0
    "Reset: #{days}d #{hours}h #{minutes}m"
  else
    "Reset: #{hours}h #{minutes}m"
  end
end

def killtracker_summary_lines
  return [] unless Script.running?("killtracker") && defined?($killtracker) && $killtracker.is_a?(Hash)

  $killtracker[:jewel_found].size
  $killtracker[:dust_found].size
  weekly_searches = $killtracker[:weekly_ascension_searches] || 0
  gems_this_week = $killtracker[:weekly_gemstone] || 0
  $killtracker[:weekly_dust] || 0
  gems_this_month = $killtracker[:monthly_gemstones] || 0

  # Calculate reset timers here, locally
  weekly_reset_in = ($killtracker[:cached_reset_time] - Time.now.to_i)
  weekly_reset_text = weekly_reset_in > 0 ? format_reset_time(weekly_reset_in) : "Reset soon!"

  now = Time.now
  if now.month == 12
    next_month_time = Time.new(now.year + 1, 1, 1)
  else
    next_month_time = Time.new(now.year, now.month + 1, 1)
  end
  monthly_reset_in = (next_month_time.to_i - now.to_i)
  monthly_reset_text = monthly_reset_in > 0 ? format_reset_time(monthly_reset_in) : "Reset soon!"

  summary_lines = []
  summary_lines << "Killtracker Summary"
  summary_lines << "--------------------------------------"
  if gems_this_month < 3
    summary_lines << "Weekly Gem"
    summary_lines << "Found: #{gems_this_week}"
    summary_lines << "Searches: #{weekly_searches.with_commas}"
    summary_lines << weekly_reset_text
  else
    summary_lines << "All Gems Found for Month!"
  end
  summary_lines << "--------------------------------------"
  summary_lines << "Monthly Gems"
  summary_lines << "Found: #{gems_this_month}"
  summary_lines << "Remaining: #{[0, 3 - gems_this_month].max}"
  summary_lines << monthly_reset_text
  summary_lines << "---------------------------------------"
  summary_lines
end

def push_treasures_to_window(treasures)
  output = "<dialogData id='TreasureWindow' clear='t'>"
  current_top = 0

  # Column layout toggle
  #  column_value = @twsingle_column ? 'Layout: Single Column' : 'Layout: Two Columns'
  #  column_cmd = "*twcolumns"
  #  output += "<link id='column_toggle' value='#{column_value}' cmd='#{column_cmd}' echo='Toggling Column Layout...' justify='bottom' left='0' top='#{current_top}' />"
  # current_top += 20
  # Two-column Killtracker layout
  if @twsingle_column
    killtracker_summary_lines.each do |line|
      output += "<label id='kt_line_#{current_top}' value='#{line}' justify='left' left='0' top='#{current_top}' />"
      current_top += 20
    end
  else
    if Script.running?("killtracker") && defined?($killtracker) && $killtracker.is_a?(Hash)
      #    output += "<label id='kt_title' value='Killtracker Summary' justify='left' left='0' top='#{current_top}' />"

      left_lines = [
        "Weekly Gem",
        "Found: #{$killtracker[:weekly_gemstone] || 0}",
        "Searches: #{($killtracker[:weekly_ascension_searches] || 0).with_commas}",
        format_reset_time($killtracker[:cached_reset_time] - Time.now.to_i)
      ]
      right_lines = [
        "Monthly Gems",
        "Found: #{$killtracker[:monthly_gemstones] || 0}",
        "Remaining: #{[0, 3 - ($killtracker[:monthly_gemstones] || 0)].max}",
        format_reset_time((Time.new(*((Time.now.month == 12 ? [Time.now.year + 1, 1] : [Time.now.year, Time.now.month + 1])) + [1]).to_i - Time.now.to_i))
      ]

      row_height = 20
      col_left = 0
      col_right = 180

      max_rows = [left_lines.size, right_lines.size].max
      max_rows.times do |i|
        output += "<label id='kt_left_#{i}' value='#{left_lines[i] || ''}' justify='left' left='#{col_left}' top='#{current_top}' />"
        output += "<label id='kt_right_#{i}' value='#{right_lines[i] || ''}' justify='left' left='#{col_right}' top='#{current_top}' />"
        current_top += row_height
      end

    end
  end

  if ARGV.first == "lootroom"
    empty_hand
    fput "loot room"
    fill_hand
    exit
  elsif ARGV.first == "eloot"
    start_script("eloot") unless Script.running?("eloot")
    exit
  end

  # Click to Loot Room
  if @show_click_links
    output += "<link id='lootroom' value='Click to LOOT ROOM.' cmd=';e empty_hand(); fput(\"loot room\"); fill_hand()' echo='Looting room...' fontSize='32' left='0' top='#{current_top}' />"
    current_top += 20
    output += "<link id='eloot' value='Click to run ELOOT.' cmd=';e start_script(\"eloot\") unless Script.running?(\"eloot\")' echo='Running eloot...' fontSize='32' left='0' top='#{current_top}' />"
    current_top += 20
    output += "<label id='div1' value='--------------------------------------' justify='left' left='0' top='#{current_top}' />"
    current_top += 20
  end

  # Treasure count
  output += "<label id='treasuretotal' value='Treasures: #{treasures.size}' left='0' top='#{current_top}' />"
  current_top += 20

  row_height = 20
  col_left = 0
  col_right = 180

  if @twsingle_column
    treasures.each_with_index do |treasure, index|
      stripped_name = treasure.name.sub(/^(an?|some|the)\s+/i, '')
      treasure_name = stripped_name

      output += "<link id='treasure_#{index}' value='#{treasure_name}' cmd='get ##{treasure.id}' echo='get ##{treasure.id}' justify='bottom' left='0' top='#{current_top}' />"
      current_top += row_height
    end
  else
    treasures.each_slice(2).with_index do |pair, row|
      pair.each_with_index do |treasure, col|
        stripped_name = treasure.name.sub(/^(an?|some|the)\s+/i, '')
        treasure_name = stripped_name

        left = col == 0 ? col_left : col_right
        top = current_top + row * row_height

        output += "<link id='treasure_#{row}_#{col}' value='#{treasure_name}' cmd='get ##{treasure.id}' echo='get ##{treasure.id}' justify='bottom' left='#{left}' top='#{top}' />"
      end
    end
    current_top += ((treasures.size + 1) / 2) * row_height
  end

  output += "</dialogData>"
  puts(output)
end

UPSTREAM_HOOK_ID = "#{Script.current.name}_upstream".freeze
UpstreamHook.remove(UPSTREAM_HOOK_ID) rescue nil

UpstreamHook.add(UPSTREAM_HOOK_ID, proc do |command|
  case command.strip.downcase
  when /\*click/i
    @show_click_links = !@show_click_links
    respond "Click-to-loot links are now #{@show_click_links ? 'ENABLED' : 'DISABLED'}."
    nil
  when /\*twcol/i
    @twsingle_column = !@twsingle_column
    window_settings["treasurewindow"]["single_column"] = @twsingle_column
    save_window_settings(window_settings)
    current_treasures = GameObj.loot.select do |obj|
      obj.type =~ /ammo|armor|box|clothing|collectible|cursed|gem|herb|jewelry|junk|magic|reagent|scarab|scroll|skin|uncommon|valuable|wand|weapon/i
    end
    push_treasures_to_window(current_treasures)
    respond "Column Layout: #{@twsingle_column ? 'Single' : 'Double'}"
    nil
  when /\*twgtk/i
    # toggle GTK window on/off
    settings = load_window_settings
    settings["treasurewindow"] ||= {}
    settings["treasurewindow"]["use_gtk_window"] = @use_gtk_window
    save_window_settings(settings)

    if @use_gtk_window
      respond "GTK window: ON"
      Gtk.queue { TreasureWindowGtk.create_main_window }
    else
      respond "GTK window: OFF"
      if defined?(TreasureWindowGtk) && TreasureWindowGtk.instance_variable_get(:@window)
        Gtk.queue { TreasureWindowGtk.instance_variable_get(:@window).close }
      end
    end
    nil
  else
    command
  end
end)

before_dying do
  UpstreamHook.remove("#{Script.current.name}_upstream")

  if defined?(TreasureWindowGtk) && TreasureWindowGtk.instance_variable_get(:@window)
    Gtk.queue { TreasureWindowGtk.instance_variable_get(:@window).close }
  end
end

last_push_time = Time.now

echo "Treasurewindow is active." if $frontend == "stormfront"

loop do
  current_treasures = GameObj.loot.select do |obj|
    obj.name !~ /message board|cart|disk|door|patchworked saiful sphere|stairs|shop|swirled steel bowl full of sticks|wastebin|wide-mouthed wicker basket|rubbish bin|portal|barrel|arch|establishment|hut|gate|locksmith|firefly|cask|table|cafe|bench|shanty|plant|twisted pile of metal|puppy|flying .*? tome/i &&
      (
        #     obj.type.nil? ||
        obj.type =~ /ammo|armor|box|clothing|collectible|cursed|gem|herb|jewelry|junk|magic|reagent|scarab|scroll|skin|uncommon|valuable|wand|weapon/i
      )
  end

  now = Time.now
  if current_treasures != @last_treasures || (now - last_push_time) >= 2
    @last_treasures = current_treasures

    # update the Wrayth window
    push_treasures_to_window(current_treasures) if $frontend == "stormfront"

    # *and* update the GTK window
    if defined?(TreasureWindowGtk) && TreasureWindowGtk.instance_variable_get(:@window)
      # grab the same summary lines you used in push_treasures_to_window
      summary = killtracker_summary_lines
      TreasureWindowGtk.update_treasures(current_treasures, summary)
    end

    last_push_time = now
  end


  sleep 0.025
end
