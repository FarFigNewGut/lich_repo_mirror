=begin

	Tries to parse the "creatures by level page" on the wiki to mimic the old
	behavior from ;bestiary

	requires nokogiri gem if not already installed. (gem install nokogiri)

	for usage info:
		;wikibeast help

	support = none, just go to the page yourself. Or don't, i'm not your dad. You do you.


		author: someone?
		contributers: someone else?
		game: Gemstone
		tags: info, play.net, news, wiki, bestiary, monsters, critters, help
		version: 2.0

	changelog:
		2.0 - changed to a proper class and added type / name filter
		1.1 - tries to infer creature type from name using gameobj data
		1.0 - initial release
=end
require "net/https"
require "terminal-table"
require "uri"

begin
  require "nokogiri"
rescue LoadError 
  _respond "#{monsterbold_start}You must install the nokogiri gem to use this script#{monsterbold_end}"
  exit
end

class WikiBeast
	def initialize(args, charsettings)
		@base_url = "https://gswiki.play.net/List_of_creatures_by_level"
		@disarm_url = "https://gswiki.play.net/List_of_creatures_that_can_cause_item_loss"
		@MOB_BY_LEVEL = {}
		@args = args
		@charsettings = charsettings
		@output = Terminal::Table.new :headings => ["Level", "Creature", "Types", "Wiki Link"]
		parse_args()
	end

	def get_page(url)
		uri = URI.parse(url)
		http = Net::HTTP.new(uri.host, uri.port)
		http.use_ssl = true

		req = Net::HTTP::Get.new(uri.request_uri)
		begin
			resp = http.request(req)
			http_code = "HTTP: #{resp.code}"
		rescue
			http_code = 'DNS or connection error'
		end
		if not resp.kind_of? Net::HTTPSuccess
			echo "Error retrieving #{uri} (#{http_code})"
		end
		return http_code, resp.body
	end

	def get_level_from_main(tab, level)
		url_root = "https://gswiki.play.net"
		lvl_list = tab.xpath('//td/b/a[@title="Category:Level ' + level.to_s + ' Creatures"]').first.parent.parent.xpath(".//li/a")
		@MOB_BY_LEVEL[level] = []
		lvl_list.each { |m|
			@MOB_BY_LEVEL[level].push({"name": m.text.capitalize, "link": "#{url_root}#{m['href']}"})
		}
	end

	def pretty_print_level(lvl, type_filter = nil)
		#_respond "#{monsterbold_start}Level #{lvl}:#{monsterbold_end}"
		@MOB_BY_LEVEL[lvl].each { |mob|
			fake_mobj = fake_obj(mob[:name])
			types = get_types(fake_mobj)
			if (type_filter == "" or types =~ /#{type_filter}/ or types == "UNKNOWN" or mob[:name] =~ /#{type_filter}/i)
				#typestring = "#{types}".ljust(40)
				#_respond "      #{lvl}:    #{mob[:name].ljust(40)}#{typestring}#{mob[:link]}"
				@output.add_row [lvl, mob[:name], types, mob[:link]]
			end
		}
	end

	# makes a fake creature game obj to check type
	def fake_obj(creature)
		fakeobj = GameObj.new(666999, creature.split(" ").last, creature.downcase)
		if fakeobj.type.nil?
			fakeobj = GameObj.new(666999, creature.split(" ").last, creature)
		end
		return fakeobj
	end

	def get_types(fakeobj)
		types = fakeobj.type
		if types.nil? or types.empty?
			types = "UNKNOWN"
		end
		types = types.split(",")
		types.reject! { |t| t == "aggressive npc" }
		return types.join(",")
	end

	def search_mobs
		levels = @args[0].scan(/(\d+)/)
		type_filter = @args[0].scan(/([a-z-']+)/i).join("|")
		if (!levels.nil? and !levels.empty?)
			if levels.length > 2
				echo "Too many things that look like levels in your arguments"
				exit
			elsif levels.length == 2
				lvl_range = [levels[0][0].to_i, levels[1][0].to_i].sort
				lvl_range = (lvl_range[0]..lvl_range[1])
			else
				lvl_range = [levels[0][0].to_i]
			end
		elsif levels.nil? or levels.empty?
			lvl_range = ((Char.level.to_i - 5)..(Char.level.to_i + 5)).to_a
		end

		last_lvl = nil
		lvl_range.each { |lvl|
			if lvl.nil?
				echo "Error parsing given level range"
				exit
			end
			next if lvl < 1
			if !last_lvl.nil? && lvl != last_lvl
				@output.add_separator
			end
			last_lvl = lvl
			get_level_from_main(@creature_table, lvl)	
			pretty_print_level(lvl, type_filter)
		}
		_respond @output
	end

	def parse_args
		if @args.include? "help"
			_respond "usage:"
			_respond "    ;wikibeast refresh                              - refresh local cache of the 'creatures by level' page"
			_respond "                                                      this happens automatically if you have not run this script previously"
			 respond "    ;wikibeast <start level> <end level (optional)> - show creatures between start and end level"
			_respond "                                                      if end level is omitted, only shows creatures of <start level>"
			_respond "    ;wikibeast                                      - show creatures that are +/-5 from your current level"
			_respond ""
			_respond " any other non-numeric argument will filter results that have that as a name or creature type"
			_respond " i.e. ;wikibeast 20 undead             - show level 20 undead"
			_respond "      ;wikibeast 5 10 orc              - show orcs between levels 5 and 10"
			_respond "      note: any mob with an UNKNOWN type will always be displayed"
			exit
		elsif @args[1] =~ /refresh|reload/ or not @charsettings['page_cache']
			_respond "Updating local cache of creature list from wiki..."
			http_code, resp = get_page(@base_url)
			@charsettings['page_cache'] = resp
			@charsettings['updated_at'] = Time.now
			exit
		else
			_respond "Loading local cache of creature list from wiki (last updated: #{CharSettings['updated_at']})"
			resp = @charsettings['page_cache']
		end
		@page = Nokogiri::HTML(resp)
		@creature_table = @page.xpath("//table").first
	end
end

wb = WikiBeast.new(script.vars, CharSettings.to_hash)
wb.search_mobs()
