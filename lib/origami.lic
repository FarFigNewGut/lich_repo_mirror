# origamitest_optimized.lic
# Optimized origami looper with improved performance and error handling
# Examples:
#   ;origamitest_optimized 20 palace
#   ;origamitest_optimized palace 20
#   ;origamitest_optimized                 # run until out of paper

begin
  # -------- Configuration --------
  DEFAULT_DESIGN = 'palace'
  MAX_FOLDS_PER_SHEET = 5
  BASE_WAIT_TIME = 0.5  # Longer base pause for game processing
  MAX_GET_ATTEMPTS = 15  # More attempts for slower responses
  
  # -------- CLI args parsing (optimized) --------
  tokens = (Script.current.vars || []).map(&:to_s).reject(&:empty?)
  
  # Help display
  if tokens.include?('help') || tokens.include?('-h') || tokens.include?('--help')
    echo ""
    echo "=== ORIGAMI LOOPER SCRIPT HELP ==="
    echo ""
    echo "USAGE:"
    echo "  ;origami [cycles] [design]"
    echo "  ;origami [design] [cycles]"
    echo "  ;origami                    (run until out of paper)"
    echo ""
    echo "EXAMPLES:"
    echo "  ;origami 20 palace         (20 cycles of palace design)"
    echo "  ;origami crane 50          (50 cycles of crane design)"
    echo "  ;origami palace            (unlimited palace cycles)"
    echo "  ;origami 100               (100 cycles of default palace)"
    echo ""
    echo "FEATURES:"
    echo "  - Automatically gets paper from Vars.lootsack (or knapsack)"
    echo "  - 5 folds per sheet maximum, then tosses and gets new paper"
    echo "  - Returns unused paper to container when finished"
    echo "  - Shows progress with time estimates"
    echo "  - Stops if hands too injured for origami work"
    echo "  - Stops if invalid design name entered"
    echo ""
    echo "COMMON DESIGNS: palace, crane, flower, box, star, swan"
    echo ""
    exit
  end
  
  max_cycles = nil
  design = DEFAULT_DESIGN
  
  tokens.each do |token|
    if token.match?(/^\d+$/)
      max_cycles = token.to_i
    else
      design = token.strip
    end
  end

  # -------- Container setup --------
  sack = (Vars.lootsack rescue nil).to_s.strip
  sack = "knapsack" if sack.empty?

  # -------- Optimized utility methods --------
  def log(msg)
    echo "[origami] #{msg}"
  end

  def wait_ready
    pause BASE_WAIT_TIME
    waitrt?
    waitcastrt?
  end

  def send_command(cmd)
    wait_ready
    fput cmd
    # Only fold commands have roundtime, unfold and other commands don't
    if cmd.include?("origami fold")
      pause 2.0  # 2 second pause for origami fold commands
      waitrt?    # Catch any remaining RT
    else
      pause 0.3  # Short pause for unfold and regular commands
      waitrt?
    end
  end

  def has_paper?
    [GameObj.right_hand, GameObj.left_hand].any? { |hand| hand&.name&.match?(/paper/i) }
  end

  def get_paper(container)
    return true if has_paper?
    
    log "Getting paper from #{container}..."
    send_command "get paper from my #{container}"
    pause 0.2  # Allow time for inventory update
    has_paper?
  end

  def perform_fold(design_name)
    log "Folding #{design_name}..."
    send_command "origami fold #{design_name}"
    send_command "origami fold #{design_name}"
    
    # Check for hand injury messages, invalid design, and creativity overload after folding
    3.times do
      line = get?
      break unless line
      if line =~ /hands are far too sore for such delicate work/i || 
         line =~ /tips of your fingers are too sore from previous paper cuts/i
        log "HANDS TOO INJURED FOR ORIGAMI WORK!"
        log "Please heal your hands before continuing."
        log "Script stopping for safety."
        exit
      elsif line =~ /does not appear to be a valid mnemonic for an origami pattern/i
        log "INVALID ORIGAMI DESIGN: '#{design_name}'"
        log "Please check your design name and try again."
        log "Script stopping due to invalid design."
        exit
      elsif line =~ /mind feels overloaded with creativity.*unable to think clearly.*rest until a new day/i
        log "CREATIVITY OVERLOADED!"
        log "Your mind is too overwhelmed to remember origami patterns."
        log "Please rest until a new day before continuing."
        log "Script stopping - daily limit reached."
        exit
      end
    end
  end

  # Simple unfold with straightforward timing
  def perform_unfold
    log "Unfolding..."
    send_command "origami unfold"
    send_command "origami unfold"
    
    result = :unknown
    MAX_GET_ATTEMPTS.times do
      pause 0.2
      line = get?
      break unless line
      
      case line
      when /You gently unfold the origami/i
        return :success
      when /not an origami creation/i
        result = :flat if result == :unknown
      when /pain of your injuries/i, /concentration.*falters/i
        log "Injury distraction - pausing for recovery"
        pause 2.0
        waitrt?
      when /hands are far too sore for such delicate work/i,
           /tips of your fingers are too sore from previous paper cuts/i
        log "HANDS TOO INJURED FOR ORIGAMI WORK!"
        log "Please heal your hands before continuing."
        log "Script stopping for safety."
        exit
      end
    end
    
    result
  end

  def discard_paper
    return unless has_paper?
    log "Discarding used paper..."
    send_command "toss my paper"
    pause 0.2
    send_command "toss my paper"  # Second toss to ensure it's gone
    pause 0.1  # Allow inventory to update
  end

  # -------- Main execution --------
  cycles_label = max_cycles ? max_cycles.to_s : "unlimited"
  log "Starting: #{cycles_label} cycles | design: #{design} | container: #{sack}"
  
  # Time estimation for finite cycles
  if max_cycles
    # Estimate: ~8-10 seconds per cycle (fold+unfold+processing time)
    estimated_seconds = max_cycles * 9  # Average 9 seconds per cycle
    estimated_minutes = estimated_seconds / 60.0
    if estimated_minutes < 1
      log "Estimated time: #{estimated_seconds} seconds"
    elsif estimated_minutes < 60
      log "Estimated time: #{estimated_minutes.round(1)} minutes"
    else
      hours = estimated_minutes / 60.0
      log "Estimated time: #{hours.round(1)} hours"
    end
  end

  total_completed = 0
  current_sheet_folds = 0
  start_time = Time.now

  # Initial paper check
  unless get_paper(sack)
    log "ERROR: No paper available in #{sack}. Exiting."
    exit
  end

  # Main processing loop
  loop do
    # Check cycle limit before processing
    break if max_cycles && total_completed >= max_cycles

    # Perform fold/unfold cycle
    perform_fold(design)
    unfold_result = perform_unfold

    case unfold_result
    when :success
      current_sheet_folds += 1
      total_completed += 1
      
      # Progress and time tracking
      elapsed_time = Time.now - start_time
      if max_cycles && total_completed > 0
        avg_time_per_cycle = elapsed_time / total_completed
        remaining_cycles = max_cycles - total_completed
        estimated_remaining = remaining_cycles * avg_time_per_cycle
        
        if estimated_remaining < 60
          time_left = "#{estimated_remaining.round}s"
        elsif estimated_remaining < 3600
          time_left = "#{(estimated_remaining / 60).round(1)}m"
        else
          time_left = "#{(estimated_remaining / 3600).round(1)}h"
        end
        
        log "Cycle #{total_completed}/#{max_cycles} (#{current_sheet_folds}/#{MAX_FOLDS_PER_SHEET} on sheet) - ETA: #{time_left}"
      else
        log "Cycle #{total_completed} (#{current_sheet_folds}/#{MAX_FOLDS_PER_SHEET} on current sheet)"
      end

      # Handle sheet completion
      if current_sheet_folds >= MAX_FOLDS_PER_SHEET
        discard_paper
        current_sheet_folds = 0
        
        # Check if we've reached our target
        break if max_cycles && total_completed >= max_cycles
        
        # Get new paper
        unless get_paper(sack)
          log "No more paper available in #{sack}. Session complete."
          break
        end
      end

    when :flat
      log "Sheet unusable (flat paper). Discarding and getting new sheet."
      discard_paper
      current_sheet_folds = 0
      
      unless get_paper(sack)
        log "No more paper available in #{sack}. Session complete."
        break
      end

    else
      log "WARNING: Unclear unfold result. Continuing..."
      # Don't increment counters or discard paper
    end
  end

  # Final cleanup
  if max_cycles && total_completed >= max_cycles && current_sheet_folds == MAX_FOLDS_PER_SHEET
    discard_paper
  end

  # Put any remaining paper back in the sack
  if has_paper?
    log "Returning unused paper to #{sack}"
    send_command "put my paper in my #{sack}"
  end

  # Final completion summary
  elapsed_time = Time.now - start_time
  if elapsed_time < 60
    time_summary = "#{elapsed_time.round}s"
  elsif elapsed_time < 3600
    time_summary = "#{(elapsed_time / 60).round(1)}m"
  else
    time_summary = "#{(elapsed_time / 3600).round(1)}h"
  end
  
  log "Session complete! Total cycles: #{total_completed} in #{time_summary}"

rescue StandardError => e
  log "FATAL ERROR: #{e.class}: #{e.message}"
  e.backtrace.first(3).each { |line| log "  #{line}" }
  
  # Emergency cleanup - return paper to sack if possible
  if has_paper?
    log "Emergency cleanup: returning paper to #{sack}"
    begin
      send_command "put my paper in my #{sack}"
    rescue
      log "Could not return paper to sack, discarding instead"
      discard_paper
    end
  end
end