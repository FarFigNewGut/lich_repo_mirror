#Safety.lic
=begin

Author: Alastir
Date: 11/23/25
Purpose: Help disable creatures based upon Profession and chances of success.

=end

module Safety

  #Determine how dangerous the room creature setup is.
  def self.unsafe?
    count = GameObj.targets.count
    danger = 0

    if GameObj.targets.count <= 2
      danger = 0
      danger = [danger, 0].max
    elsif GameObj.targets.count >= 3
      danger = GameObj.targets.count
    end

    if danger > 0
      Lich::Messaging.stream_window("Room: #{Room.current.id} -- Creatures: #{count} -- Danger!", "speech")
      return true
    else
      Lich::Messaging.stream_window("Room: #{Room.current.id} -- Creatures: #{count} -- Threat level acceptable.", "speech")
      return false
    end
  end #end of self.unsafe?

#~~~~~~~~~~~~~~~~~~~~~~~~~#
#     Support Routines    #
#~~~~~~~~~~~~~~~~~~~~~~~~~#

  def self.stance_offensive
    while not checkstance 'offensive'
      waitrt?
      fput 'stance offensive'
      sleep 0.3
    end
  end

#~~~~~~~~~~~~~~~~~~~~~~~~~#  
# Bard Spellsong Routines #
#~~~~~~~~~~~~~~~~~~~~~~~~~#  
  
  def self.depress
    #Song of Depression
    #Open Cast Warding Spell
    #Reduces TD by 20
    #Increases action RT
    if $disabled_rooms.include?(Room.current.id)
      nil
    else
      $disabled_rooms = []
      waitrt?
      waitcastrt?
      result = dothistimeout 'renew 1015', 3, /Renewing "Song of Depression" for 6 mana.|But you are not singing that spellsong./
      if result =~ /Renewing "Song of Depression" for 6 mana./
        $disabled_rooms.push(Room.current.id)
        nil
      elsif result =~ /But you are not singing that spellsong./
        Spell[1015].force_incant if Spell[1015].affordable?
        $disabled_rooms.push(Room.current.id)
      end
      waitrt?
      waitcastrt?
    end
  end

  def self.disruption
    waitrt?
    waitcastrt?
    if Spell[1030].affordable?
      result = dothistimeout 'incant 1030 open', 3, /reels under the force of the sonic vibrations!|The evanescent shield shrouding a pale scaled shaper flares to life and absorbs the essence of the spell, dissipating it harmlessly.  Before fading, it flickers with a pale incandescence.|The evanescent shield shrouding a pale scaled shaper flares to life and absorbs the essence of the spell, dissipating it harmlessly.|Your armor prevents the song from working correctly.|Your magic fails to find a target./
      if result =~ /reels under the force of the sonic vibrations!/
      elsif result =~ /The evanescent shield shrouding a pale scaled shaper flares to life and absorbs the essence of the spell, dissipating it harmlessly.  Before fading, it flickers with a pale incandescence.|The evanescent shield shrouding a pale scaled shaper flares to life and absorbs the essence of the spell, dissipating it harmlessly./
        Safety::disruption
      elsif result =~ /Your armor prevents the song from working correctly./
        Safety::disruption
      elsif result =~ /Your magic fails to find a target./
      end
    else
      Script.kill('safety')
    end
  end

  def self.hold
    #Song of Holding
    #Open Cast Warding Spell
    #Reduces DS by 10%
    waitrt?
    waitcastrt?
    Spell[1001].force_incant if Spell[1001].affordable?
    fput 'stop 1001'
  end

  def self.rage
    #Song of Rage
    #Single Target Warding Spell
    #Forces Offensive Stance
    #High Endrolls can prone
    waitrt?
    waitcastrt?
    Spell[1016].force_incant if Spell[1016].affordable?
    waitcastrt?
    fput 'stop 1016'
  end

  def self.unravel(current_creature, cmd)
    #Song of Unraveling
    #Single target targeted dispel
    #Mana drain up to 50 mana
    cast_results = Regexp.union(
      /You are already singing that spellsong\./,
      /The evanescent shield shrouding .* flares to life and absorbs the essence of the spell, dissipating it harmlessly\./,
      /You feel your song resonate around the .*, pulling at the threads of mana within\./,
      /The silvery tendril continues to wend its way away from the /,
      /You gain \d+ mana!/,
      /You feel your song echo around the .* as if it had entered a vast empty chamber\./,
      /The serpentine thread stretching between you and the (.*) fades, then disappears\./,
      /Your concentration on unravelling the threads of mana is broken\./,
      /A little bit late for that don't you think\?/,
      /What were you referring to\?/,
    )
    
    target = GameObj.npcs.find { |npc| npc.name =~ /#{current_creature}/}
    waitrt?
    waitcastrt?
    result = Spell[1013].force_cast("##{target.id}", "#{cmd || ''}", cast_results)
    case result
    when /You are already singing that spellsong\./
      fput('stop 1013')
    when /You feel your song resonate around the .*, pulling at the threads of mana within\.|You gain \d+ mana!/
      waitrt?
      waitcastrt?
      fput('stop 1013')
    when /The silvery tendril continues to wend its way away from the .*\./
      fput('stop 1013')
    when /Your concentration on unravelling the threads of mana is broken\.|You feel your song echo around the .* as if it had entered a vast empty chamber\./
      fput('stop 1013')
    when /What were you referring to\?|A little bit late for that don't you think\?/
      fput 'release'
      nil
    end
  end

#~~~~~~~~~~~~~~~~~~~~~~~~~#
#    Sorcerer Routines    #
#~~~~~~~~~~~~~~~~~~~~~~~~~#

  def self.grasp
    if $disabled_rooms.include?(Room.current.id)
      nil
    else
      $disabled_rooms = []

      grasp_success = Regexp.union(
      /Numerous grotesque limbs in varying states of decay suddenly burst out of the (.*)!  With startling speed and ferocity, the arms grab at whatever they can!/,
      )

      grasp_failure = Regexp.union(
      /The evanescent shield shrouding (.*) flares to life and thickens to create a substantial buffer around (?:him|her|it)\./,
      /\.\.\.wait (\d) seconds\./,
      )

      grasp_regex = Regexp.union(grasp_success, grasp_failure)

      waitrt?
      waitcastrt?
      result = dothistimeout 'incant 709', 3, grasp_regex
      if result =~ /The evanescent shield shrouding (.*) flares to life and thickens to create a substantial buffer around (?:him|her|it)\.|\.\.\.wait (\d) seconds\./
        $disabled_rooms.push(Room.current.id)
      elsif result =~ /Numerous grotesque limbs in varying states of decay suddenly burst out of the (.*)!  With startling speed and ferocity, the arms grab at whatever they can!/
        $disabled_rooms.push(Room.current.id)
      end
    end
  end

#~~~~~~~~~~~~~~~~~~~~~~~~~#
#     Warrior Routines    #
#~~~~~~~~~~~~~~~~~~~~~~~~~#
  
  def self.warcry(target)
    if !Effects::Spells.active?("Griffin's Voice") and checkstamina(30)
      fput 'cman griffin'
    end

    waitrt?
    waitcastrt?
    if GameObj.targets.count > 2
      sleep 0.5
      fput 'warcry cry all' if checkstamina(30)

    elsif GameObj.targets.count == 1
      return unless target

      # Run warcry and capture "SSR result: <number>"
      result = dothistimeout("warcry cry #{target}", 3, /SSR result: (\d+)|is unaffected!/)
      if result =~ /SSR result: (\d+)/
        total = $1.to_i
        Safety::warcry(target) if total < 100
      elsif result =~ /is unaffected!/
        Safety::warcry(target)
      end
    end
  end

#~~~~~~~~~~~~~~~~~~~~~~~~~#
#     Wizard Routines     #
#~~~~~~~~~~~~~~~~~~~~~~~~~#

  def self.multi_stomp
    waitrt?
    waitcastrt?
    if Spell[909].active?
      result = dothistimeout 'stomp', 2, /The evanescent shield shrouding a pale scaled shaper flares to life and thickens to create a substantial buffer around her.|The evanescent shield shrouding a pale scaled shaper flares to life and thickens to create a substantial buffer around him.|loses (?:his|her|its) balance and falls over.|Your magic fails to find a target./
      if result =~ /The evanescent shield shrouding a pale scaled shaper flares to life and thickens to create a substantial buffer around her.|The evanescent shield shrouding a pale scaled shaper flares to life and thickens to create a substantial buffer around him./
        self.stomp
      elsif result =~ /loses (?:his|her|its) balance and falls over.|Your magic fails to find a target./
        nil
      end
    else
      Spell[909].force_incant if Spell[909].affordable?
      self.stomp
    end
  end
  
  def self.stomp
    if $disabled_rooms.include?(Room.current.id)
      nil
    else
      $disabled_rooms = []
        
      waitrt?
      waitcastrt?
      if Spell[909].active?
        result = dothistimeout 'stomp', 2, /The evanescent shield shrouding a pale scaled shaper flares to life and thickens to create a substantial buffer around her.|The evanescent shield shrouding a pale scaled shaper flares to life and thickens to create a substantial buffer around him.|loses (?:his|her|its) balance and falls over.|Your magic fails to find a target./
        if result =~ /The evanescent shield shrouding a pale scaled shaper flares to life and thickens to create a substantial buffer around her.|The evanescent shield shrouding a pale scaled shaper flares to life and thickens to create a substantial buffer around him./
          self.stomp
        elsif result =~ /loses (?:his|her|its) balance and falls over.|Your magic fails to find a target./
          $disabled_rooms.push(Room.current.id)
        end
      else
        Spell[909].force_incant if Spell[909].affordable?
        self.stomp
      end
    end
  end

end  #End of module

Safety::unsafe?

=begin

The main loop starts below here.  

=end

if Char.prof == 'Bard' and Group.leader?
  #Define the list of priority targets, listing the most difficult/dangerous first.
  priority_targets = ["disciple", "disir", "draugr", "valravn", "angargeist", "mutant", "warg", "skald", "shield-maiden", "golem"]
  
  #Go through each of the priority target names.
  priority_targets.each do |possible_thing|
    #Find ALL targets matching this type
    matching_targets = GameObj.targets.select { |npc| npc.name =~ /#{possible_thing}/ && npc.status !~ /dead|gone/ }
    
    matching_targets.each do |found_target|
      Lich::Messaging.stream_window("Room:#{Room.current.id} - (#{found_target}) - (#{found_target.id})", "speech")
      fput("target ##{found_target.id}")
      Lich::Messaging.stream_window("Room:#{Room.current.id} - Disabling: (#{found_target}) - (#{found_target.id}).", "speech")
      
      if found_target.name =~ /disciple/ and found_target.status !~ /dead|gone|prone|lying down/
        #Hamstring
        waitrt?
        waitcastrt?
        Safety::stance_offensive
        CMan.use('hamstring', found_target) if found_target.status !~ /dead|gone|prone|lying down|sleeping/
      elsif found_target.name =~ /disir|draugr/
        #Hamstring
        waitrt?
        waitcastrt?
        Safety::stance_offensive
        CMan.use('hamstring', found_target) if found_target.status !~ /dead|gone|prone|lying down|sleeping/
      elsif found_target.name =~ /valravn/        
        #Song of Rage
        waitrt?
        waitcastrt?
        Safety::stance_offensive
        CMan.use('feint',found_target) if found_target.status !~ /dead|gone/
      elsif found_target.name =~ /mutant/     
        #Unravel Brace
        waitrt?
        waitcastrt?
        Safety::unravel(found_target, '1214') if found_target.status !~ /dead|gone/
      elsif found_target.name =~ /golem|shield-maiden|skald|warg/ and found_target.status !~ /dead|gone|prone|lying down|sleeping/
        #Hamstring
        waitrt?
        waitcastrt?
        Safety::stance_offensive
        CMan.use('hamstring', found_target) if found_target.status !~ /dead|gone|prone|lying down|sleeping/
      end
    end
  end
end

if Char.prof == 'Cleric'
  #Define the list of priority targets, listing the most difficult/dangerous first.
  priority_targets = ["disciple", "disir", "draugr", "valravn", "angargeist", "mutant", "warg", "skald", "shield-maiden", "golem", "shaper", "lurk", "sentinel", "fanatic"]
  
  #Go through each of the priority target names.
  priority_targets.each do |possible_thing|
    #Find ALL targets matching this type
    matching_targets = GameObj.targets.select { |npc| npc.name =~ /#{possible_thing}/ && npc.status !~ /dead|gone/ }
    
    matching_targets.each do |found_target|
      Lich::Messaging.stream_window("Room:#{Room.current.id} - (#{found_target}) - (#{found_target.id})", "speech")
      fput("target ##{found_target.id}")
      Lich::Messaging.stream_window("Room:#{Room.current.id} - Disabling: (#{found_target}) - (#{found_target.id}).", "speech")
      
      waitrt?
      waitcastrt?
      if found_target.name =~ /disciple/ and found_target.status !~ /dead|gone/
        Spell[240].force_incant if !Spell[240].active? and Spell[240].affordable?
        Spell[217].force_incant if Spell[217].affordable?
        waitcastrt?
        Spell[317].force_incant if Spell[317].affordable?
        waitcastrt?
      elsif found_target.name =~ /disir|draugr/ and found_target.status !~ /dead|gone|stunned/
        Spell[316].force_incant if Spell[316].affordable?
      elsif found_target.name =~ /angargeist|valravn/ and found_target.status !~ /dead|gone/
        Spell[118].force_incant if Spell[118].affordable?
      elsif found_target.name =~ /mutant/ and found_target.status !~ /dead|gone/
        Spell[119].force_incant if Spell[119].affordable?
      elsif found_target.name =~ /golem|shield-maiden|skald|warg/ and found_target.status !~ /dead|gone|stunned/
        Spell[316].force_incant if Spell[316].affordable?
      elsif found_target.name =~ /shaper/ and found_target.status !~ /dead|gone/
        Spell[210].force_incant if Spell[210].affordable?
        waitcastrt?
      end
    end
  end
end

if Char.prof == 'Sorcerer'
  #Define the list of priority targets, listing the most difficult/dangerous first.
  priority_targets = ["disciple", "disir", "draugr", "valravn", "angargeist", "mutant", "warg", "skald", "shield-maiden", "golem", "shaper", "lurk", "sentinel", "fanatic"]
  
  #Go through each of the priority target names.
  priority_targets.each do |possible_thing|
    #Find ALL targets matching this type
    matching_targets = GameObj.targets.select { |npc| npc.name =~ /#{possible_thing}/ && npc.status !~ /dead|gone/ }
    
    matching_targets.each do |found_target|
      Lich::Messaging.stream_window("Room:#{Room.current.id} - (#{found_target}) - (#{found_target.id})", "speech")
      fput("target ##{found_target.id}")
      Lich::Messaging.stream_window("Room:#{Room.current.id} - Disabling: (#{found_target}) - (#{found_target.id}).", "speech")
      
      waitrt?
      waitcastrt?
      if found_target.name =~ /disciple/ and found_target.status !~ /dead|gone/
        Spell[119].force_incant if Spell[119].affordable?
        waitcastrt?
        Spell[703].force_incant if Spell[703].affordable?
      elsif found_target.name =~ /disir|draugr/ and found_target.status !~ /dead|gone|lying down|prone|stunned/
        Safety::grasp if Spell[709].affordable?
      elsif found_target.name =~ /valravn/ and found_target.status !~ /dead|gone/
        Spell[118].force_incant if Spell[118].affordable?
      elsif found_target.name =~ /angargeist/ and found_target.status !~ /dead|gone/        
        Spell[704].force_cast("##{target.id}") if Spell[704].affordable?
      elsif found_target.name =~ /mutant/ and found_target.status !~ /dead|gone/
        Spell[119].force_incant if Spell[119].affordable?
      elsif found_target.name =~ /golem|shield-maiden|skald|warg/ and found_target.status !~ /dead|gone|stunned/
#        Spell[316].force_incant if Spell[316].affordable?
      elsif found_target.name =~ /berserker|golem|hinterboar|shield-maiden|skald|warg|wendigo/ and found_target.status !~ /dead|gone/
#        Spell[316].force_incant if Spell[316].affordable?
      elsif found_target.name =~ /shaper/ and found_target.status !~ /dead|gone/
        Spell[703].force_incant if Spell[703].affordable?
      end
    end
  end
end

if Char.prof == 'Warrior'
  #Define the list of priority targets, listing the most difficult/dangerous first.
  priority_targets = ["disciple", "disir", "draugr", "valravn", "angargeist", "mutant", "warg", "skald", "shield-maiden", "golem", "shaper", "lurk", "sentinel", "fanatic"]
  
  #Go through each of the priority target names.
  priority_targets.each do |possible_thing|
    #Find ALL targets matching this type
    matching_targets = GameObj.targets.select { |npc| npc.name =~ /#{possible_thing}/ && npc.status !~ /dead|gone/ }
    
    matching_targets.each do |found_target|
      Lich::Messaging.stream_window("Room:#{Room.current.id} - (#{found_target}) - (#{found_target.id})", "speech")
      fput("target ##{found_target.id}")
      Lich::Messaging.stream_window("Room:#{Room.current.id} - Disabling: (#{found_target}) - (#{found_target.id}).", "speech")
      
      if found_target.name =~ /disciple|disir|draugr|mutant|shaper|sentinel|lurk/ and found_target.status !~ /dead|gone|prone|lying down/
        #Warcry, Hamstring - must be proned or it falls
        waitrt?
        waitcastrt?
        Safety::warcry(found_target)
        waitrt?
        Safety::stance_offensive
        CMan.use('hamstring', found_target) if found_target.status !~ /dead|gone|prone|lying down|sleeping/
      elsif found_target.name =~ /valravn/        
        #Song of Rage
        waitrt?
        waitcastrt?
        Safety::warcry(found_target)
        waitrt?
        Safety::stance_offensive
        CMan.use('feint',found_target)
      elsif found_target.name =~ /fanatic|golem|shield-maiden|skald|warg/ and found_target.status !~ /dead|gone|prone|lying down/
        #Hamstring
        waitrt?
        waitcastrt?
        Safety::stance_offensive
        CMan.use('hamstring', found_target) if found_target.status !~ /dead|gone|prone|lying down|sleeping/
      end
    end
  end
end

if Char.prof == 'Wizard'
  #Define the list of priority targets, listing the most difficult/dangerous first.
  priority_targets = ["disciple", "disir", "draugr", "valravn", "angargeist", "mutant", "berserker", "cannibal", "hinterboar", "shield-maiden", "skald", "warg", "wendigo", "shaper", "lurk", "sentinel", "fanatic" ]
  
  #Go through each of the priority target names.
  priority_targets.each do |possible_thing|
    #Find ALL targets matching this type
    matching_targets = GameObj.targets.select { |npc| npc.name =~ /#{possible_thing}/ && npc.status !~ /dead|gone/ }
    
    matching_targets.each do |found_target|
      Lich::Messaging.stream_window("Room:#{Room.current.id} - (#{found_target}) - (#{found_target.id})", "speech")
      fput("target ##{found_target.id}")
      Lich::Messaging.stream_window("Room:#{Room.current.id} - Disabling: (#{found_target}) - (#{found_target.id}).", "speech")
      
      if found_target.name =~ /disciple|mutant/ and found_target.status !~ /dead|gone/
        #Dispel the Arcane Barrier (1720)
        Spell[417].force_incant if Spell[417].affordable?
      elsif found_target.name =~ /disir|draugr|valravn|angargeist/ and found_target.status !~ /dead|gone|prone|lying down|stunned|webbed/
        #Call Wind
        Spell[912].force_incant if Spell[912].affordable?
      elsif found_target.name =~ /berserker|cannibal|golem|hinterboar|shield-maiden|skald|warg|wendigo/ and found_target.status !~ /dead|gone|prone|lying down|stunned|webbed/
        Safety::multi_stomp
      elsif found_target.name =~ /shaper|sentinel|lurk|fanatic/ and found_target.status !~ /dead|gone|prone|lying down|stunned|webbed/
        if Group.leader?
          Spell[912].force_incant if Spell[912].affordable?
        else
          Safety::stomp
        end
      end
    end
  end
end