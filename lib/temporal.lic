# frozen_string_literal: true
require 'yaml'
require 'socket'

# Returns [offset_seconds, rtt_seconds] or nil on failure
def sntp_sample(host: 'pool.ntp.org', port: 123, timeout: 1.5)
  s = UDPSocket.new
  s.connect(host, port)

  # NTP packet: 48 bytes. First byte = LI(0) VN(4) Mode(3) => 0x23
  pkt = "\x23" + ("\x00" * 47)

  t0 = Time.now.to_f
  s.send(pkt, 0)

  r = IO.select([s], nil, nil, timeout)
  return nil unless r

  data = s.recv(48)
  t3 = Time.now.to_f
  return nil unless data && data.bytesize >= 48

  # Transmit Timestamp (server time) starts at byte 40: 64-bit (seconds, fraction)
  sec, frac = data[40, 8].unpack("N2")
  ntp_time = (sec - 2_208_988_800) + (frac / 2.0**32) # convert NTP epoch->Unix epoch

  # Simple SNTP offset estimate using midpoint:
  # offset = ((t1 - t0) + (t2 - t3)) / 2 ; but we only have server transmit ~t2.
  # Approximate server time at midpoint of our request/response:
  local_mid = (t0 + t3) / 2.0
  offset = local_mid - ntp_time     # + = local clock ahead, - = behind
  rtt = t3 - t0

  [offset, rtt]
ensure
  s.close rescue nil
end

def clock_drift_tenths(samples: 3)
  offsets = []

  samples.times do
    res = sntp_sample
    next unless res
    offset, rtt = res
    # toss garbage / high-latency samples
    next if rtt > 1.0
    offsets << offset
  end

  raise "No successful samples" if offsets.empty?

  offsets.sort!
  drift = offsets[offsets.length / 2]      # median is stable under jitter
  (drift * 10).round / 10.0
end

#DRIFT_SECONDS = clock_drift_tenths(samples: 9)
#echo "Clock drift: #{DRIFT_SECONDS}s"

def auto_detect_offset!(samples: 3, host: 'pool.ntp.org')
  drift = clock_drift_tenths(samples: samples) # drift = local - server (seconds, tenths)

  # temporal wants offset_sec such that: server = local + offset_sec
  offset_sec = -drift

  if offset_sec >= 0
    seconds = offset_sec.abs
    dir = "behind"
  else
    seconds = offset_sec.abs
    dir = "ahead"
  end

  [seconds, dir, offset_sec, drift]
end


module ConfigManager
  def self.load_config(config_name, defaults = {})
    data_dir = "#{$data_dir}#{XMLData.game}/#{Char.name}/"
    config_file_path = "#{data_dir}#{config_name}.yaml"

    config_data = if File.exist?(config_file_path)
                    YAML.load_file(config_file_path) || {}
                  elsif UserVars.respond_to?(config_name)
                    UserVars.send(config_name) || {}
                  else
                    {}
                  end

    defaults.merge(config_data)
  end

  def self.save_config(config_name, data)
    data_dir = "#{$data_dir}#{XMLData.game}/#{Char.name}/"
    config_file_path = "#{data_dir}#{config_name}.yaml"
    Dir.mkdir(data_dir) unless Dir.exist?(data_dir)

    begin
      File.open(config_file_path, "w") { |file| file.write(data.to_yaml) }
      #echo("Preferences successfully saved to #{config_file_path}.")
    rescue StandardError => e
      echo("Failed to save preferences: #{e.message}")
    end
  end
end

require 'yaml'
require 'gtk3'

module ConfigGUI
  def self.run(config_name, defaults = {}, display_params = {})
    config = ConfigManager.load_config(config_name, defaults)
    window = nil
    window_closed = false

    begin
      Gtk.queue {
        window = Gtk::Window.new("Configure #{config_name}")
        window.set_default_size(600, 600)

        notebook = Gtk::Notebook.new
        entries = {}

        grouped_settings = config.keys.group_by { |key| display_params.dig(key, :display_tab) || "General Settings" }

        grouped_settings.each do |tab_name, keys|
          scrolled_window = Gtk::ScrolledWindow.new
          scrolled_window.set_policy(:automatic, :automatic)

          grid = Gtk::Grid.new
          grid.column_spacing = 10
          grid.row_spacing = 10
          scrolled_window.add_with_viewport(grid)

          keys.each_with_index do |key, index|
            label = Gtk::Label.new(format_key(key.to_s))
            datatype = display_params.dig(key, :datatype) || :text
            tooltip = display_params.dig(key, :tooltip) || ""

            widget = case datatype
                     when :boolean
                       checkbox = Gtk::CheckButton.new
                       checkbox.active = config[key] == true || config[key].to_s.downcase == 'true'
                       checkbox
                     when :dropdown
                       Gtk::ComboBoxText.new.tap do |combo|
                         (display_params.dig(key, :options) || []).each { |opt| combo.append_text(opt) }
                         combo.active = (display_params.dig(key, :options) || []).index(config[key]) || 0
                       end
                     else
                       entry = Gtk::Entry.new
                       entry.text = config[key].to_s
                       entry
                     end

            widget.tooltip_text = tooltip if tooltip
            entries[key] = widget

            grid.attach(label, index % 2 * 2, index / 2, 1, 1)
            grid.attach(widget, index % 2 * 2 + 1, index / 2, 1, 1)
          end

          notebook.append_page(scrolled_window, Gtk::Label.new(tab_name))
        end

        save_button = Gtk::Button.new(label: "Save")
        save_button.signal_connect("clicked") do
          entries.each do |key, widget|
            value = case widget
                    when Gtk::CheckButton
                      widget.active?
                    when Gtk::ComboBoxText
                      widget.active_text
                    else
                      parse_entry_value(widget.text)
                    end
            config[key] = value
          end
          ConfigManager.save_config(config_name, config)
          window.destroy
          window_closed = true
        end

        window.signal_connect("destroy") do
          window_closed = true
        end

        main_box = Gtk::Box.new(:vertical, 10)
        main_box.pack_start(notebook, expand: true, fill: true, padding: 10)
        main_box.pack_start(save_button, expand: false, fill: false, padding: 10)

        window.add(main_box)
        window.show_all
      }

      wait_while { !window_closed }
    rescue StandardError => e
      echo("An error occurred: #{e.message}")
      puts e.backtrace
      exit(1)
    end
  end

  def self.format_key(key)
    key.split('_').map(&:capitalize).join(' ')
  end

  def self.parse_entry_value(value)
    if value =~ /^\d+$/
      value.to_i
    elsif value =~ /^\.?\d+$/ || value =~ /^\d+\.\d+$/
      value.start_with?('.') ? "0#{value}".to_f : value.to_f
    elsif value =~ /^true$/i || value =~ /^false$/i
      value.downcase == 'true'
    else
      value
    end
  end
end

AUTHOR  = "Nick S"
VERSION = "0.4.0"

USAGE_TEXT = <<~TXT
  # temporal.lic (v#{VERSION}) — #{AUTHOR}
  #
  # Setup (auto-populates offset):
  #   ;temporal setup
  #     - Attempts to auto-detect your time offset (SNTP) and pre-fills the Timing fields
  #     - Configure flare/enchant/action/hand and Save
  #     - Flare Type supports "Next" (computed at runtime)
  #
  # Run with saved config:
  #   ;temporal
  #
  # Auto-detect offset and run with saved config:
  #   ;temporal auto
  #
  # Auto-detect offset and run with CLI overrides:
  #   ;temporal auto <flare> <enchant> [clench|break] [right|left]
  #     - Example: ;temporal auto fire 67 clench
  #     - Valid regular flare types are:
  #         "fire"
  #         "ice" 
  #         "lightning"      
  #         "earth"          
  #         "acid"           
  #         "void"           
  #         "disruption"     
  #         "plasma"         
  #         "steam"          
  #         "disintegration" 
  #
  # Auto-detect offset and set Death flares:
  #   ;temporal auto 66death
  #   ;temporal auto 100death
  #
  # Next flare type (requires enchant):
  #   ;temporal next <enchant> [clench|break] [right|left]
  #   ;temporal auto next <enchant> [clench|break] [right|left]
  #     - Sets Flare Type = "Next" (based on the hundreds digit of server Unix time)
  #     - Prints what the next flare will be + ETA until it becomes active
  #
  # Manual offset override (time.is style):
  #   ;temporal <seconds> <behind|ahead>
  #     - Saves the offset, then runs using saved flare/enchant/action/hand
  #
  # Full manual mode (explicit tail):
  #   ;temporal <seconds> <behind|ahead> <tail> [clench|break] [right|left]
  #
  # Notes:
  #   - behind X => server = local + X
  #   - ahead  X => server = local - X
  #   - If Flare Type is saved as "Next", it is re-computed on EVERY run of ;temporal
  #
  # Help:
  #   ;temporal help
TXT

MAX_DIGITS  = 6
CONFIG_NAME = "temporal"

# Temporal flare digit mapping (3rd-to-last digit for normal flares; "666" prefix for Death special)
FLARE_DIGIT = {
  "Fire"           => "1",
  "Ice"            => "2",
  "Lightning"      => "3",
  "Earth"          => "4",
  "Acid"           => "5",
  "Void"           => "6",
  "Disruption"     => "7",
  "Plasma"         => "8",
  "Steam"          => "9",
  "Disintegration" => "0",
  "+66 Death"      => "666",
  "+100 Death"     => "666100"
}.freeze

# Inverse map for NORMAL flares only (0-9), used for "Next"
DIGIT_TO_FLARE = FLARE_DIGIT
  .select { |_k, v| v =~ /\A\d\z/ }
  .invert
  .freeze

DEFAULTS = {
  flare_type:       "Earth",
  enchant:          100,
  action:           "clench",
  hand:             "right",
  offset_seconds:   0.0,
  offset_direction: "behind",
  offset_source:    "",
  offset_note:      ""
}.freeze

DISPLAY_PARAMS = {
  flare_type: {
    display_name: "Flare type",
    display_tab:  "Temporal",
    datatype:     :dropdown,
    options:      (FLARE_DIGIT.keys + ["Next"]),
    tooltip:      "Select the flare appearance/type for the daily set. 'Next' is computed at runtime from server time."
  },
  enchant: {
    display_name: "Enchant",
    display_tab:  "Temporal",
    tooltip:      "Enter desired enchant (0–100). For normal flares: 100 => last two digits 00."
  },
  action: {
    display_name: "Action",
    display_tab:  "Temporal",
    datatype:     :dropdown,
    options:      %w[clench break],
    tooltip:      "Verb to perform on your held item."
  },
  hand: {
    display_name: "Hand",
    display_tab:  "Temporal",
    datatype:     :dropdown,
    options:      %w[right left],
    tooltip:      "Which hand item to use."
  },
  offset_seconds: {
    display_name: "Time offset seconds",
    display_tab:  "Timing",
    tooltip:      "Value from time.is: how far you are ahead/behind (seconds)."
  },
  offset_direction: {
    display_name: "Offset direction",
    display_tab:  "Timing",
    datatype:     :dropdown,
    options:      %w[behind ahead],
    tooltip:      "behind: your clock is behind server; ahead: your clock is ahead."
  },
  offset_note: {
    display_name: "Offset note",
    display_tab:  "Timing",
    tooltip:      "Status from auto-detection / failures."
  }
}.freeze

def usage
  echo USAGE_TEXT
end

def normalize_hand(raw)
  h = (raw || "right").to_s.downcase.strip
  return "left"  if h.start_with?("l")
  return "right" if h.start_with?("r")
  "right"
end

def hand_obj(hand)
  hand == "left" ? GameObj.left_hand : GameObj.right_hand
end

def perform_action(action, hand)
  obj = hand_obj(hand)
  noun = obj&.noun

  unless noun && !noun.to_s.strip.empty?
    echo "temporal: nothing detected in your #{hand} hand."
    return
  end

  fput "#{action} my #{noun}"
end

def parse_flare_token(token)
  t = token.to_s.strip
  return nil if t.empty?

  down = t.downcase

  return "+66 Death"  if down == "66death"
  return "+100 Death" if down == "100death"

  FLARE_DIGIT.keys.each do |k|
    return k if k.downcase == down
  end

  nil
end

def build_tail(flare_type, enchant)
  flare = flare_type.to_s
  digit = FLARE_DIGIT.fetch(flare)

  ench = enchant.to_i
  ench = 0 if ench < 0
  ench = 100 if ench > 100

  return "666100" if flare == "+100 Death"
  return "666"    if flare == "+66 Death"

  ench2 = format("%02d", ench % 100) # 100 => "00"
  "#{digit}#{ench2}"
end

def offset_from(seconds, dir)
  sec = seconds.to_f.abs
  case dir.to_s.downcase.strip
  when "behind" then sec
  when "ahead"  then -sec
  else
    raise ArgumentError, "direction must be 'behind' or 'ahead'"
  end
end

def next_flare_info(offset_sec)
  server_sec = (Time.now.to_f + offset_sec).to_i

  current_digit = (server_sec / 100) % 10
  next_digit    = ((server_sec / 100) + 1) % 10

  next_boundary = ((server_sec / 100) + 1) * 100
  eta = next_boundary - server_sec

  current_flare = DIGIT_TO_FLARE[current_digit.to_s]
  next_flare    = DIGIT_TO_FLARE[next_digit.to_s]

  [current_flare, current_digit, next_flare, next_digit, eta]
end

def resolve_flare_type(flare_type, offset_sec)
  return [flare_type, nil] unless flare_type.to_s.downcase == "next"

  current_flare, current_digit, next_flare, next_digit, eta = next_flare_info(offset_sec)
  note = "[temporal] Next flare computed from server time: now=#{current_flare}(#{current_digit}), next=#{next_flare}(#{next_digit}) in ~#{eta}s"
  [next_flare, note]
end

def wait_for_server_tail(tail, offset_sec:, fire_at: 0.5)
  tail_s = tail.to_s.strip
  unless tail_s =~ /\A\d+\z/ && (1..MAX_DIGITS).include?(tail_s.length)
    raise ArgumentError, "tail must be 1..#{MAX_DIGITS} digits"
  end

  mod    = 10 ** tail_s.length
  tail_i = tail_s.to_i

  # --- ETA (best-effort, printed once) ---
  server_now = Time.now.to_f + offset_sec
  sec  = server_now.to_i
  frac = server_now - sec

  rem = (tail_i - (sec % mod)) % mod

  eta =
    if rem == 0
      # we're in the target second already; wait until fire_at within it
      [fire_at - frac, 0.0].max
    else
      # wait rem seconds to reach target second, then wait to fire_at
      (rem - frac) + fire_at
    end

  if eta <= 0.5
    echo "[temporal] Trigger imminent..."
  else
    echo "[temporal] Estimated time until fire: ~#{eta.round(2)}s"
  end
  # --- end ETA ---

  # Poll until:
  #   1) server seconds match tail
  #   2) we're at/after fire_at inside that second
  #
  # This avoids the bug where we enter the right second AFTER fire_at and return immediately (late).
  poll_sleep = 0.01

  loop do
    server_now = Time.now.to_f + offset_sec
    sec  = server_now.to_i
    frac = server_now - sec

    if (sec % mod) == tail_i
      return if frac >= fire_at

      # We're in the correct second but before fire_at; sleep just enough to land near fire_at.
      sleep_time = fire_at - frac
      sleep(sleep_time) if sleep_time > 0
      return
    end

    sleep(poll_sleep)
  end
end

def load_cfg
  ConfigManager.load_config(CONFIG_NAME, DEFAULTS)
end

def save_cfg(cfg)
  ConfigManager.save_config(CONFIG_NAME, cfg)
end

def run_setup_gui
  cfg = load_cfg
  begin
    seconds, dir, offset_sec, drift = auto_detect_offset!
    cfg[:offset_seconds]   = seconds
    cfg[:offset_direction] = dir
    cfg[:offset_source]    = 'auto'
    cfg[:offset_note]      = "Auto-detected during setup via SNTP: drift=#{drift}s => offset=#{offset_sec}s"
    puts "*** temporal setup auto-detected offset: #{seconds} #{dir} (offset=#{offset_sec})"
  rescue => e
    cfg[:offset_note] = "Auto-detect during setup failed: #{e.class}: #{e.message}"
    echo "temporal: #{cfg[:offset_note]}"
  end
  save_cfg(cfg)

  ConfigGUI.run(CONFIG_NAME, DEFAULTS, DISPLAY_PARAMS)
end

def run_from_config(cfg, offset_override: nil)
  action = (cfg[:action] || "clench").to_s.downcase.strip
  hand   = normalize_hand(cfg[:hand])

  offset_sec =
    if offset_override
      offset_override
    else
      offset_from(cfg[:offset_seconds], cfg[:offset_direction])
    end

  flare  = cfg[:flare_type]
  ench   = cfg[:enchant]

  resolved_flare, next_note = resolve_flare_type(flare, offset_sec)
  echo next_note if next_note

  tail = build_tail(resolved_flare, ench)

  if offset_override.nil?
    puts "************************************************************"
    puts "*** temporal using SAVED offset: #{cfg[:offset_seconds]} #{cfg[:offset_direction]} (offset=#{offset_sec})"
    puts "*** target tail=#{tail} (flare=#{resolved_flare}, enchant=#{ench}), action=#{action}, hand=#{hand}"
    puts "************************************************************"
  end

  wait_for_server_tail(tail, offset_sec: offset_sec, fire_at: 0.5)
  perform_action(action, hand)
end

# ----------------------------
# Entry (Lich variable[] args)
# ----------------------------
args = []
i = 1
while (v = variable[i])
  s = v.to_s.strip
  args << s unless s.empty?
  i += 1
end

if args.empty?
  begin
    cfg = load_cfg
    run_from_config(cfg)
  rescue => e
    echo "temporal: ERROR: #{e.class}: #{e.message}"
    echo "temporal: run ';temporal setup' first."
  end
  exit
end

auto_mode = false
if args.first.downcase == "auto"
  auto_mode = true
  args.shift
end

cmd = (args.first || "").downcase

if cmd == "help"
  usage
  exit
end

if cmd == "setup"
  begin
    run_setup_gui
  rescue => e
    echo "temporal: ERROR launching setup GUI: #{e.class}: #{e.message}"
  end
  exit
end

cfg = load_cfg

auto_offset_sec = nil
if auto_mode
  begin
    seconds, dir, offset_sec, drift = auto_detect_offset!
    cfg[:offset_seconds]   = seconds
    cfg[:offset_direction] = dir
    cfg[:offset_source]    = 'auto'
    cfg[:offset_note]      = "Auto-detected via SNTP: drift=#{drift}s => offset=#{offset_sec}s"
    save_cfg(cfg)
    auto_offset_sec = offset_sec
    puts "*** temporal auto-detected offset: #{seconds} #{dir} (offset=#{offset_sec})"
  rescue => e
    cfg[:offset_note] = "Auto-detect failed: #{e.class}: #{e.message}"
    save_cfg(cfg)
    echo "temporal: #{cfg[:offset_note]}"
  end
end

# ';temporal auto' (with no further args)
if auto_mode && args.empty?
  begin
    if auto_offset_sec
      run_from_config(cfg, offset_override: auto_offset_sec)
    else
      run_from_config(cfg)
    end
  rescue => e
    echo "temporal: ERROR: #{e.class}: #{e.message}"
    echo "temporal: run ';temporal setup' first."
  end
  exit
end

# consume command token
args.shift

# Next flare type (requires enchant): ;temporal [auto] next <enchant> [clench|break] [right|left]
if cmd == "next"
  ench_arg = (args[0] || "").to_s.strip
  unless ench_arg =~ /\A\d+\z/
    echo "temporal: 'next' requires an enchant integer (0-100)."
    usage
    exit
  end

  action = (args[1] || cfg[:action] || "clench").to_s.downcase.strip
  hand   = normalize_hand(args[2] || cfg[:hand])

  begin
    cfg[:flare_type] = "Next"
    cfg[:enchant]    = ench_arg.to_i
    cfg[:action]     = action
    cfg[:hand]       = hand
    save_cfg(cfg)

    if auto_offset_sec
      run_from_config(cfg, offset_override: auto_offset_sec)
    else
      run_from_config(cfg)
    end
  rescue => e
    echo "temporal: ERROR: #{e.class}: #{e.message}"
    echo "temporal: run ';temporal setup' first."
  end

  exit
end

flare_token = parse_flare_token(cmd)

if flare_token
  begin
    cfg[:flare_type] = flare_token

    if flare_token == "+66 Death" || flare_token == "+100 Death"
      action = (args[0] || cfg[:action] || "clench").to_s.downcase.strip
      hand   = normalize_hand(args[1] || cfg[:hand])
      cfg[:action] = action
      cfg[:hand]   = hand
      save_cfg(cfg)

      if auto_offset_sec
        run_from_config(cfg, offset_override: auto_offset_sec)
      else
        run_from_config(cfg)
      end
      exit
    end

    ench_arg = (args[0] || "").to_s.strip
    unless ench_arg =~ /\A\d+\z/
      echo "temporal: expected enchant after flare (example: ;temporal#{auto_mode ? ' auto' : ''} fire 67 clench)."
      usage
      exit
    end

    action = (args[1] || cfg[:action] || "clench").to_s.downcase.strip
    hand   = normalize_hand(args[2] || cfg[:hand])

    cfg[:enchant] = ench_arg.to_i
    cfg[:action]  = action
    cfg[:hand]    = hand
    save_cfg(cfg)

    if auto_offset_sec
      run_from_config(cfg, offset_override: auto_offset_sec)
    else
      run_from_config(cfg)
    end
  rescue => e
    echo "temporal: ERROR: #{e.class}: #{e.message}"
  end
  exit
end

# Manual offset modes:
seconds_str = cmd
dir         = (args[0] || "").to_s.downcase.strip
tail_arg    = (args[1] || "").to_s.strip

unless seconds_str =~ /\A-?\d+(\.\d+)?\z/ && %w[behind ahead].include?(dir)
  usage
  exit
end

seconds = seconds_str.to_f.abs
offset_sec = offset_from(seconds, dir)

if tail_arg.empty?
  begin
    cfg[:offset_seconds]   = seconds
    cfg[:offset_direction] = dir
    cfg[:offset_source]    = 'manual'
    cfg[:offset_note]      = "Manual override provided on CLI."
    save_cfg(cfg)

    puts "*** temporal using PROVIDED offset (saved): #{seconds} #{dir} (offset=#{offset_sec})"
    run_from_config(cfg, offset_override: offset_sec)
  rescue => e
    echo "temporal: ERROR: #{e.class}: #{e.message}"
    echo "temporal: run ';temporal setup' first."
  end
  exit
end

action = (args[2] || "clench").to_s.downcase.strip
hand   = normalize_hand(args[3])

begin
  echo "temporal: offset=#{offset_sec} (server = local + offset)"
  echo "temporal: waiting for server tail #{tail_arg} @ ~.5s, action=#{action}, hand=#{hand}..."
  wait_for_server_tail(tail_arg, offset_sec: offset_sec, fire_at: 0.5)
  perform_action(action, hand)
rescue => e
  echo "temporal: ERROR: #{e.class}: #{e.message}"
end
