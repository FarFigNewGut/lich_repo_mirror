# frozen_string_literal: true
require 'yaml'

module ConfigManager
  def self.load_config(config_name, defaults = {})
    data_dir = "#{$data_dir}#{XMLData.game}/#{Char.name}/"
    config_file_path = "#{data_dir}#{config_name}.yaml"

    config_data = if File.exist?(config_file_path)
                    YAML.load_file(config_file_path) || {}
                  elsif UserVars.respond_to?(config_name)
                    UserVars.send(config_name) || {}
                  else
                    {}
                  end

    config_data = defaults.merge(config_data)
    config_data
  end

  def self.save_config(config_name, data)
    data_dir = "#{$data_dir}#{XMLData.game}/#{Char.name}/"
    config_file_path = "#{data_dir}#{config_name}.yaml"
    Dir.mkdir(data_dir) unless Dir.exist?(data_dir)

    begin
      File.open(config_file_path, "w") { |file| file.write(data.to_yaml) }
      echo("Preferences successfully saved to #{config_file_path}.")
    rescue StandardError => e
      echo("Failed to save preferences: #{e.message}")
    end
  end
end

require 'yaml'
require 'gtk3'

module ConfigGUI
  def self.run(config_name, defaults = {}, display_params = {})
    config = ConfigManager.load_config(config_name, defaults)
    window = nil
    window_closed = false

    begin
      Gtk.queue {
        # Create a window
        window = Gtk::Window.new("Configure #{config_name}")
        window.set_default_size(600, 600)

        # Create a notebook to organize tabs
        notebook = Gtk::Notebook.new

        # Create a hash to store the entries
        entries = {}

        # Group settings by display_tab
        grouped_settings = config.keys.group_by { |key| display_params.dig(key, :display_tab) || "General Settings" }

        # Create tabs for each group
        grouped_settings.each do |tab_name, keys|
          scrolled_window = Gtk::ScrolledWindow.new
          scrolled_window.set_policy(:automatic, :automatic)

          # Create a grid to organize the widgets in two columns
          grid = Gtk::Grid.new
          grid.column_spacing = 10
          grid.row_spacing = 10
          scrolled_window.add_with_viewport(grid)

          keys.each_with_index do |key, index|
            label = Gtk::Label.new(format_key(key.to_s))
            datatype = display_params.dig(key, :datatype) || :text
            tooltip = display_params.dig(key, :tooltip) || ""

            widget = case datatype
                     when :boolean
                       checkbox = Gtk::CheckButton.new
                       checkbox.active = config[key] == true || config[key].to_s.downcase == 'true'
                       checkbox
                     when :dropdown
                       Gtk::ComboBoxText.new.tap do |combo|
                         (display_params.dig(key, :options) || []).each { |opt| combo.append_text(opt) }
                         combo.active = (display_params.dig(key, :options) || []).index(config[key]) || 0
                       end
                     else
                       entry = Gtk::Entry.new
                       entry.text = config[key].to_s
                       entry
                     end

            widget.tooltip_text = tooltip if tooltip
            entries[key] = widget

            grid.attach(label, index % 2 * 2, index / 2, 1, 1)
            grid.attach(widget, index % 2 * 2 + 1, index / 2, 1, 1)
          end

          # Add the grid to the notebook tab
          notebook.append_page(scrolled_window, Gtk::Label.new(tab_name))
        end

        # Add a save button
        save_button = Gtk::Button.new(label: "Save")
        save_button.signal_connect("clicked") do
          # Save the changes back to config
          entries.each do |key, widget|
            value = case widget
                    when Gtk::CheckButton
                      widget.active?
                    when Gtk::ComboBoxText
                      widget.active_text
                    else
                      parse_entry_value(widget.text)
                    end
            config[key] = value
          end
          ConfigManager.save_config(config_name, config)
          window.destroy
          window_closed = true
        end

        # Add a close event that does NOT save
        window.signal_connect("destroy") do
          window_closed = true
        end

        # Add the notebook and save button to the layout
        main_box = Gtk::Box.new(:vertical, 10)
        main_box.pack_start(notebook, expand: true, fill: true, padding: 10)
        main_box.pack_start(save_button, expand: false, fill: false, padding: 10)

        # Add main box to window
        window.add(main_box)

        # Show the window
        window.show_all
      }

      # Wait until the window is closed
      wait_while { !window_closed }
    rescue StandardError => e
      echo("An error occurred: #{e.message}")
      puts e.backtrace # Optional: Print the stack trace for debugging
      exit(1)
    end
  end

  # Format key to Title Case for display
  def self.format_key(key)
    key.split('_').map(&:capitalize).join(' ')
  end

  # Parse entry value to appropriate type
  def self.parse_entry_value(value)
    if value =~ /^\d+$/
      value.to_i
    elsif value =~ /^\.?\d+$/ || value =~ /^\d+\.\d+$/
      value.start_with?('.') ? "0#{value}".to_f : value.to_f
    elsif value =~ /^true$/i || value =~ /^false$/i
      value.downcase == 'true'
    else
      value
    end
  end
end

AUTHOR  = "Nick S"
VERSION = "0.3.0"

USAGE_TEXT = <<~TXT
  # temporal.lic (v#{VERSION}) — #{AUTHOR}
  #
  # Quick start (GUI):
  #   ;temporal setup
  #     - Choose flare type + enchant (and optional action/hand)
  #     - Save your time.is offset (seconds + behind/ahead)
  #
  # Run using saved config (one-liner):
  #   ;temporal
  #     - Uses saved flare/enchant/action/hand + saved time offset
  #
  # Override ONLY the time offset (still uses GUI target):
  #   ;temporal <seconds> <behind|ahead>
  #     - Example: ;temporal 3.2 behind
  #     - Overwrites & saves offset_seconds/offset_direction
  #     - Uses saved flare/enchant/action/hand to compute the tail
  #
  # Full CLI mode (explicit tail):
  #   ;temporal <seconds> <behind|ahead> <tail> [action=clench] [hand=right|left]
  #     - Example: ;temporal 3.2 behind 400 break
  #     - Tail may be 1..6 digits (e.g. 6, 100, 400, 41234, 666100)
  #
  # Notes:
  #   - time.is tells you if you are AHEAD or BEHIND (in seconds).
  #   - behind X => server = local + X
  #   - ahead  X => server = local - X
  #
  # Help:
  #   ;temporal help
TXT


MAX_DIGITS  = 6
CONFIG_NAME = "temporal"

# Temporal flare digit mapping (3rd-to-last digit for normal flares; "666" prefix for Death special)
FLARE_DIGIT = {
  "Fire"           => "1",
  "Ice"            => "2",
  "Lightning"      => "3",
  "Earth"          => "4",
  "Acid"           => "5",
  "Void"           => "6",
  "Disruption"     => "7",
  "Plasma"         => "8",
  "Steam"          => "9",
  "Disintegration" => "0",
  "+66 Death"      => "666",
  "+100 Death"     => "666100"
}.freeze

DEFAULTS = {
  flare_type:       "Earth",
  enchant:          100,
  action:           "clench",
  hand:             "right",
  offset_seconds:   0.0,
  offset_direction: "behind"
}.freeze

DISPLAY_PARAMS = {
  flare_type: {
    display_name: "Flare type",
    display_tab:  "Temporal",
    datatype:     :dropdown,
    options:      FLARE_DIGIT.keys,
    tooltip:      "Select the flare appearance/type for the daily set."
  },
  enchant: {
    display_name: "Enchant",
    display_tab:  "Temporal",
    tooltip:      "Enter desired enchant (0–100). For normal flares: 100 => last two digits 00."
  },
  action: {
    display_name: "Action",
    display_tab:  "Temporal",
    datatype:     :dropdown,
    options:      %w[clench break],
    tooltip:      "Verb to perform on your held item."
  },
  hand: {
    display_name: "Hand",
    display_tab:  "Temporal",
    datatype:     :dropdown,
    options:      %w[right left],
    tooltip:      "Which hand item to use."
  },
  offset_seconds: {
    display_name: "Time offset seconds",
    display_tab:  "Timing",
    tooltip:      "Value from time.is: how far you are ahead/behind (seconds)."
  },
  offset_direction: {
    display_name: "Offset direction",
    display_tab:  "Timing",
    datatype:     :dropdown,
    options:      %w[behind ahead],
    tooltip:      "behind: your clock is behind server; ahead: your clock is ahead."
  }
}.freeze


def usage
  echo USAGE_TEXT
end

def normalize_hand(raw)
  h = (raw || "right").to_s.downcase.strip
  return "left"  if h.start_with?("l")
  return "right" if h.start_with?("r")
  "right"
end

def hand_obj(hand)
  hand == "left" ? GameObj.left_hand : GameObj.right_hand
end

def perform_action(action, hand)
  obj = hand_obj(hand)
  noun = obj&.noun

  unless noun && !noun.to_s.strip.empty?
    echo "temporal: nothing detected in your #{hand} hand."
    return
  end

  fput "#{action} my #{noun}"
end

def build_tail(flare_type, enchant)
  flare = flare_type.to_s
  digit = FLARE_DIGIT.fetch(flare)

  ench = enchant.to_i
  ench = 0 if ench < 0
  ench = 100 if ench > 100

  if flare == "+100 Death"
    return "666100"
  end

  if flare == "+66 Death"
    return "666"
  end

  # Normal flares: one-digit flare + last-two digits of enchant (00 => +100)
  ench2 = format("%02d", ench % 100) # 100 => "00"
  "#{digit}#{ench2}"
end

def offset_from(seconds, dir)
  sec = seconds.to_f.abs
  case dir.to_s.downcase.strip
  when "behind" then sec
  when "ahead"  then -sec
  else
    raise ArgumentError, "direction must be 'behind' or 'ahead'"
  end
end

def wait_for_server_tail(tail, offset_sec:, fire_at: 0.5)
  tail_s = tail.to_s.strip
  unless tail_s =~ /\A\d+\z/ && (1..MAX_DIGITS).include?(tail_s.length)
    raise ArgumentError, "tail must be 1..#{MAX_DIGITS} digits"
  end

  mod    = 10 ** tail_s.length
  tail_i = tail_s.to_i

  loop do
    server_now = Time.now.to_f + offset_sec
    sec  = server_now.to_i
    frac = server_now - sec

    if (sec % mod) == tail_i
      sleep_time = fire_at - frac
      sleep(sleep_time) if sleep_time > 0
      return
    end

    remaining = (tail_i - (sec % mod)) % mod

    sleep_time =
      if remaining <= 2
        0.05
      else
        [1.0 - frac, 0.5].min
      end

    sleep(sleep_time) if sleep_time > 0
  end
end

def load_cfg
  ConfigManager.load_config(CONFIG_NAME, DEFAULTS)
end

def save_cfg(cfg)
  ConfigManager.save_config(CONFIG_NAME, cfg)
end

def run_setup_gui
  ConfigGUI.run(CONFIG_NAME, DEFAULTS, DISPLAY_PARAMS)
end

def run_from_config(cfg, offset_override: nil)
  flare  = cfg[:flare_type]
  ench   = cfg[:enchant]
  action = (cfg[:action] || "clench").to_s.downcase.strip
  hand   = normalize_hand(cfg[:hand])

  tail = build_tail(flare, ench)

  offset_sec =
    if offset_override
      offset_override
    else
      offset_from(cfg[:offset_seconds], cfg[:offset_direction])
    end

  # Loud notice when using saved timing (requested)
  if offset_override.nil?
    puts "************************************************************"
    puts "*** temporal using SAVED offset: #{cfg[:offset_seconds]} #{cfg[:offset_direction]} (offset=#{offset_sec})"
    puts "*** target tail=#{tail} (flare=#{flare}, enchant=#{ench}), action=#{action}, hand=#{hand}"
    puts "************************************************************"
  end

  wait_for_server_tail(tail, offset_sec: offset_sec, fire_at: 0.5)
  perform_action(action, hand)
end

# ----------------------------
# Entry (Lich variable[] args)
# ----------------------------
echo "DEBUG: FILE=#{__FILE__}"

cmd1 = (variable[1] || "").to_s.strip

if cmd1.empty?
  # ;temporal  => run using saved config
  begin
    cfg = load_cfg
    run_from_config(cfg)
  rescue => e
    echo "temporal: ERROR: #{e.class}: #{e.message}"
    echo "temporal: run ';temporal setup' first."
  end
  exit
end

if cmd1.downcase == "help"
  usage
  exit
end

if cmd1.downcase == "setup"
  begin
    run_setup_gui
  rescue => e
    echo "temporal: ERROR launching setup GUI: #{e.class}: #{e.message}"
  end
  exit
end

# If params and not setup/help:
# - If ONLY "<seconds> <behind|ahead>" are provided: run using config-derived tail/action/hand, and overwrite saved offset.
# - Otherwise: command line behavior: "<seconds> <behind|ahead> <tail> [action] [hand]"

seconds_str = cmd1
dir         = (variable[2] || "").to_s.downcase.strip
tail_arg    = (variable[3] || "").to_s.strip

unless seconds_str =~ /\A-?\d+(\.\d+)?\z/ && %w[behind ahead].include?(dir)
  usage
  exit
end

seconds = seconds_str.to_f.abs
offset_sec = offset_from(seconds, dir)

if tail_arg.empty?
  # ;temporal 3.2 behind  => use GUI-configured target, but overwrite saved offset
  begin
    cfg = load_cfg
    cfg[:offset_seconds] = seconds
    cfg[:offset_direction] = dir
    save_cfg(cfg)

    puts "************************************************************"
    puts "*** temporal using PROVIDED offset (saved): #{seconds} #{dir} (offset=#{offset_sec})"
    puts "************************************************************"

    run_from_config(cfg, offset_override: offset_sec)
  rescue => e
    echo "temporal: ERROR: #{e.class}: #{e.message}"
    echo "temporal: run ';temporal setup' first."
  end
  exit
end

# CLI mode (explicit tail/action/hand)
action = (variable[4] || "clench").to_s.downcase.strip
hand   = normalize_hand(variable[5])

begin
  echo "temporal: offset=#{offset_sec} (server = local + offset)"
  echo "temporal: waiting for server tail #{tail_arg} @ ~.5s, action=#{action}, hand=#{hand}..."
  wait_for_server_tail(tail_arg, offset_sec: offset_sec, fire_at: 0.5)
  perform_action(action, hand)
rescue => e
  echo "temporal: ERROR: #{e.class}: #{e.message}"
end
