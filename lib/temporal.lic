AUTHOR  = "Lucullan"
VERSION = "0.2.0"

USAGE_TEXT = <<~TXT
	# temporal.lic — Timed verb execution by server timestamp
	#
	# Uses a manual time offset (from time.is) to execute an action during a
	# specific server-time second, matching trailing digits of the Unix timestamp.
	#
	# Usage:
	#   ;temporal <seconds> <behind|ahead> <tail> [action=clench] [hand=right|left]
	#
	# Examples:
	#   ;temporal 3.2 behind 400
	#     → CLENCH right-hand item when server time ends in 400
	#
	#   ;temporal 3.2 behind 400 break
	#     → BREAK right-hand item when server time ends in 400
	#
	#   ;temporal 1.1 ahead 666100 clench left
	#     → CLENCH left-hand item when server time ends in 666100
	#
	# Notes:
	#   - Check time.is to determine how many seconds you are ahead or behind.
	#   - "behind X" means your local clock is X seconds behind the server.
	#   - "ahead X"  means your local clock is X seconds ahead of the server.
	#   - Tail can be any number of digits (e.g. 6, 100, 400, 41234, 666100).
	#   - Defaults: action=clench, hand=right.
	#
	#   Use ;temporal help to display this message.

TXT

MAX_DIGITS = 6

def usage
  echo USAGE_TEXT
end

def normalize_hand(raw)
  h = (raw || "right").to_s.downcase.strip
  return "left"  if h.start_with?("l")
  return "right" if h.start_with?("r")
  "right"
end

def hand_obj(hand)
  hand == "left" ? GameObj.left_hand : GameObj.right_hand
end

def perform_action(action, hand)
  obj = hand_obj(hand)
  noun = obj&.noun

  unless noun && !noun.to_s.strip.empty?
    echo "temporal: nothing detected in your #{hand} hand."
    return
  end

  fput "#{action} my #{noun}"
end

def wait_for_server_tail(tail, offset_sec:, fire_at: 0.5)
  tail_s = tail.to_s.strip
  unless tail_s =~ /\A\d+\z/ && (1..MAX_DIGITS).include?(tail_s.length)
    raise ArgumentError, "tail must be 1..#{MAX_DIGITS} digits"
  end

  mod    = 10 ** tail_s.length
  tail_i = tail_s.to_i

  loop do
	  server_now = Time.now.to_f + offset_sec
	  sec  = server_now.to_i
	  frac = server_now - sec

	  if (sec % mod) == tail_i
		sleep_time = fire_at - frac
		sleep(sleep_time) if sleep_time > 0
		return
	  end

	  remaining = (tail_i - (sec % mod)) % mod

	  sleep_time =
		if remaining <= 2
		  0.05
		else
		  [1.0 - frac, 0.5].min
		end

	  sleep(sleep_time) if sleep_time > 0
  end

end

# ----------------------------
# Entry (Lich variable[] args)
# ----------------------------
seconds_str = (variable[1] || "").to_s.strip
if seconds_str.downcase == "help"
  usage
  exit
end

dir         = (variable[2] || "").to_s.downcase.strip
tail        = (variable[3] || "").to_s
action      = (variable[4] || "clench").to_s.downcase.strip
hand        = normalize_hand(variable[5])

echo "DEBUG: args seconds=#{seconds_str.inspect} dir=#{dir.inspect} tail=#{tail.inspect} action=#{action.inspect} hand=#{hand.inspect}"

if seconds_str.empty? || dir.empty? || tail.empty?
  usage
  exit
end

unless seconds_str =~ /\A-?\d+(\.\d+)?\z/
  echo "temporal: seconds must be a number (e.g., 3.2)"
  usage
  exit
end

seconds = seconds_str.to_f.abs

offset_sec =
  case dir
  when "behind" then seconds
  when "ahead"  then -seconds
  else
    echo "temporal: second arg must be 'behind' or 'ahead'"
    usage
    exit
  end

begin
  echo "temporal: offset=#{offset_sec} (server = local + offset)"
  echo "temporal: waiting for server tail #{tail} @ ~.5s, action=#{action}, hand=#{hand}..."
  wait_for_server_tail(tail, offset_sec: offset_sec, fire_at: 0.5)
  perform_action(action, hand)
rescue => e
  echo "temporal: ERROR: #{e.class}: #{e.message}"
end
