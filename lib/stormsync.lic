=begin
  StormSync allows you to manage and organize StormFront highlights, including syncing them between multiple characters.

  *-*-*-*  EXPERIMENTAL PREVIEW!  EXPERIMENTAL PREVIEW!  EXPERIMENTAL PREVIEW! *-*-*-*
  WARNING: This version of StormSync contains actual dragons.  Usage of this script is not for the faint of heart.
  While there is a backup mechanism, loss of StormFront settings MAY occur.
  Also, GUI crashes tend to take out the entire Ruby instance, so you may get disconnected without warning.

  READ ALL THE REPO INFO.  IT IS IMPORTANT.
  A VERSION OF LICH WITH GTK3 IS (PRACTICALLY) REQUIRED.

  STORING YOUR SETTINGS ON THE SERVER IS NOT SUPPORTED WITH STORMSYNC.
  *-*-*-*  EXPERIMENTAL PREVIEW!  EXPERIMENTAL PREVIEW!  EXPERIMENTAL PREVIEW! *-*-*-*

  Backup and restore of StormFront settings can be managed through the ;stormsync backup commands.
  Backup and restore of the StormSync database is currently not functional, but can be done by copying ssy.db3 to a
  safe location.

  Before using StormSync, it is important to understand how it works and its philosophy for managing highlights:

  There are three "layers" of organization to StormSync highlights:

   - "Scopes", like "GSIV" or "GSIV-Lostranger" which are used to allow a mix character-specific and shared highlights.
   - "Groups", which exist inside a scope and define common settings for a group of highlights.  For instance, you might
        highlight clerics in blue.
   - "Strings", which are the actual individual highlights you have.

  Groups define common default colors and other settings (like Highlight Entire Line) for strings that belong to the
  group.  Strings can override these settings on an individual basis, though.  Changing settings for the group changes
  it for all strings in the group that don't specify an override.

  Each of your characters has a list of scopes it participates in and an order they are applied.  By default, a freshly
  imported GSIV character will be associated with the "GS-Global", "GSIV", and "GSIV-Charactername" scopes.  The logic
  here is:
    - Highlights that are useful in all game instances go in the GS-Global scope -- things like spell effect messaging,
        for instance.
    - Highlights that are intended for all characters in a specific instance go in the GSIV (or GSF or GSX) scope.
        Highlighting all the clerics and empaths you know?  You probably want them here.
    - Highlights for the specific character go in the scope named for that character.  Maybe you actually want to keep
        track of who you've formally introduced yourself to in an RP setting, or maybe you don't want to instantly know
        who clerics are unless that character has personally witnessed them raise someone.

  Of course, you can completely customize the list of scopes available for any given character and use them for whatever
  things you might dream up.

  More details on all this to follow.

  For now, here is your quick getting-started guide to StormSync.  This all assumes a GSIV Prime character, the scope
  names mentioned below will differ slightly for other games/instances.

  0. AFTER you have read the rest of the repo information, type:
     ;stormsync dragons

     This confirms you've actually read anything and proceed at your own risk.

  1. On ONE character (probably the one you have the most complete set of highlights on), do the following:
     ;stormsync import

     This will set up that character with StormSync and automatically create groups of highlights based on those
     sharing a common color scheme.  Note that the groups will have automatically generated names like "Names-1", etc.
     which isn't particularly useful for identifying them, so.  You'll fix this later.

  2. Acquaint yourself with the following commands for managing backups:
     ;stormsync backup list
     ;stormsync backup restore <name>

  3. Launch ;stormsync by itself to open the GUI, which will allow you to manage all of your highlights in a more sane
     fashion.

     What you'll want to do is name all your groups sensibly and (probably) move them to the GS-GLOBAL or GSIV scopes
     on a case-by-case basis.  Note that you don't want to adjust colors yet, for reasons that'll be clear momentarily.

  4. Close the stormsync GUI, which will trigger all of your updated highlights to be resent to your current character.

  5. Once your groups are arranged and named intelligibly, exit StormSync and log in a second character, then do
     ;stormsync import

     If any of these highlights share settings with a group in GS-GLOBAL or GSIV, the resulting group they are in will
     be named accordingly.  So if you use the same colors for clerics across all characters but your list of clerics
     isn't always up to date, the new character you import will have a group named "Clerics" instead of "Names-1".

     Also, any highlights that already exist with the exact same settings as one already in the GS-GLOBAL or GSIV group
     will be skipped, since the 'global' version will be included when sending highlights to this character anyways.

  6. Repeat steps 3-5 until all characters have been imported.

  7. Adjust colors as desired

  Once your setup is at least somewhat stable, you can directly add highlights via the commandline.  To add a cleric
  named Ryndith, for instance:

        ;stormsync add Cleric Ryndith        # (Add to the 'most local' scope that has a Cleric group)
     or ;stormsync add GSIV\Cleric Ryndith   # (Add to the Cleric group of the GSIV scope, assuming it has one)

  Alternatively, you can always use the GUI -- just remember to do `;stormsync resend` after any changes as the GUI
  currently does not autosend.

  Some other options exist; look at the top of stormsync.lic for details.  This being a preview release, not all
  functionality is fully implemented.

  *-*-*-*  EXPERIMENTAL PREVIEW!  EXPERIMENTAL PREVIEW!  EXPERIMENTAL PREVIEW! *-*-*-*
  WARNING: This version of StormSync contains actual dragons.  Usage of this script is not for the faint of heart.
  While there is a backup mechanism, loss of StormFront settings MAY occur.
  Also, GUI crashes tend to take out the entire Ruby instance, so you may get disconnected without warning.

  READ ALL THE REPO INFO.  IT IS IMPORTANT.
  A VERSION OF LICH WITH GTK3 IS (PRACTICALLY) REQUIRED.

  STORING YOUR SETTINGS ON THE SERVER IS NOT SUPPORTED WITH STORMSYNC.
  *-*-*-*  EXPERIMENTAL PREVIEW!  EXPERIMENTAL PREVIEW!  EXPERIMENTAL PREVIEW! *-*-*-*

	  author: LostRanger (thisgenericname@gmail.com)
	  game: any
	  tags: utility
	  required: Lich >= 4.6.5.

  version: 0.0.2-PREVIEW (2022-03-07)

  changelog:
    version 0.0.2-PREVIEW (2022-03-07)
      * Updated preview release
      * Fix several issues with merging groups
      * Implemented ;stormsync delete, ;stormsync list, and ;stormsync group delete
      * Tried to relearn how to Ruby.

    version 0.0.1-PREVIEW (2020-04-27)
      * Initial PREVIEW release
=end

=begin
THIS DOCUMENTATION IS NOT COMPLETE AND NOT YET 100% ACCURATE.


StormSync allows you to manage and organize StormFront highlights, including syncing them between multiple characters.

Highlight strings are organized into groups.  Each group specifies the colors (and other attributes) for highlights in
that group -- for instance a "Cleric" group may contain all of your clerics.  Individual entries within a group MAY
override their attributes -- so a specific cleric may have different colors from your other clerics while still being
in the same group, or a specific dangerous spell message might have a unique warning sound from other dangerous spell
messages.

Each groups belong to a scope, like GLOBAL, GSIV, or Charactername.

A particular character has a list of scopes it will use and the order they are resolved in.  A given scope can be
associated with multiple characters.  A freshly imported character starts off with the following scopes:
GLOBAL, GSIV, Charactername.

A character's highlights are all highlights that are within a group in one of the scopes the character is associated
with.  If the same highlight string exists in multiple scopes, the last one processed (e.g. the one in the Charactername
scope) is applied.


Within the following list of commands:
SCOPE refers to a scope name
GROUP refers to a group name
GROUP names may be qualified:
    SCOPE\GROUP for a group in a specific scope
    .\GROUP for a group in the `local` scope (last one in the list)
    NYI: *\GROUP for groups named GROUP in all visible scopes (those associated with the character)
    NYI: **\GROUP for groups named GROUP in ALL scopes (including those not visible from the character)

PATTERNs are simple wildcard strings:
    * or % match any number of characters (Re*d matches Red, Read, etc.).
    _ matches any single character (Re_d matches Read, Reed, but not Red)
Patterns are always case-insensitive.

Commands beginning with ** are not yet implemented, but similar functionality may be available in the GUI.


Scope management:
scope [set] local           Makes commands only apply within the most local scope (the last one in the list)
scope [set] auto            Makes commands apply to the most local scope they are relevant in
scope [set] SCOPE           Makes commands apply to scope NAME
scope add SCOPE             Create a new scope named NAME
scope del SCOPE             Delete a scope named NAME.  (Requires lots of confirmation)
scope list                  List all scopes.
scope order SCOPE,SCOPE...  Set the scope order for this character to be the listed scopes.


Group management:
For these commands, TARGET refers to either a scope, or a scope + a group name.
group add GROUP [attrs]     Add a group to the current (or named) scope
group del GROUP             Delete group.  (Requires confirmation)
group set GROUP [attrs]     Set group attributes (name, bgcolor, line, partial, case, sound, type, origin)
                            > group set clerics color=COLOR bgcolor=none line=n partial=n case=y type=name
**group move GROUP TARGET     Move a group to the specified scope.
**group copy GROUP TARGET     Duplicate the group (and all of its highlights) into the specified scope.
**group clone GROUP TARGET    Duplicate a group (but not its highlights) into the specified scope.
**group info GROUP            Shows information about the group.
**group list [options]        List groups.  (FIXME)
**group merge GROUP GROUP2... Move all contents of group2 (and any other groups) into group, then delete the old groups.


Highlight string management:
Commands that refer to @GROUP *may* take a group parameter prefixed with @.
If not specified, the group is intelligently chosen if one can be found (limited to the current scope)
add GROUP [attrs;] text     Add the specified text to GROUP.  If no attributes are present, the semicolon is optional.
                            > add gms Wyrom
                            > add danger sound=redalert.wav;Bad things are happening!
list GROUP [PATTERN]        List highlights in the specified group, optionally matching PATTERN
del [@GROUP] PATTERN        Delete highlights matching the pattern [from the named group]
**info [@GROUP] PATTERN       Show information on highlights matching the pattern [in the named group]
**set [@GROUP] PATTERN        Set attributes on highlights matching the pattern [in the named group]
**inherit [@GROUP] PATTERN    Reset attributes on highlights [in the named] group to inherit the group's defaults.


StormFront settings backups:
backup list                 Show settings backups for the current character
backup create [NAME]        Create a backup for the current character with optional NAME
backup restore [WHAT] NAME  Restore from the most recent backup.  WHAT can be 'all' or 'highlights'
backup delete NAME          Delete the named backup


Database backups:
backup db list              Show known backups for the current database
backup db create [NAME]     Create a database backup
backup db restore NAME      Restore a database backup
backup db delete NAME       Delete a database backup.


Maintenance/setup:
All import commands do an automatic StormFront settings backup.
import                      Import all of the current character's highlights into the DB.  Must not already be imported.
import force                As above, but deletes any existing character reference and contents of the existing local scope.
import none                 Set up the character in the DB, but does not import it.
                            DANGER: This will effectively delete all highlights local to the character
                            (they will only get those from the global and game scopes)
resend                      Resend settings to StormFront
=end

#
# OndreianToday at 3:47 AM
# @LostRanger loaded gems are cached on start up of a Ruby process
# you have to do Gem.clear_paths or logout/in
begin
    Object.send(:remove_const, :StormSync)
rescue
end

begin
    Scripting.send(:remove_const, :StormSync)
rescue
end


class TrueClass
    def to_str
        return self.to_s
    end
end

class FalseClass
    def to_str
        return self.to_s
    end
end


unless $frontend == 'stormfront'
    echo "This script is only usable with StormFront."
    exit
end

unless $SAFE == 0
    echo "This script must be trusted in order to work."
    echo "To trust it, type '#{$lich_char}trust #{script.name}"
end



def require_deps
    [
        ['sequel', 'sequel', 'in order to manage its database of StormFront settings'],
        ['win32-sound', 'win32/sound', 'to preview sound effect triggers on highlight strings'],
    ].each do |gem, package, reason|
        Gem.clear_paths if Gem
        begin
            require package
        rescue ScriptError
            install_dep(gem, reason)
            Gem.clear_paths if Gem
        end
    end

    require 'fileutils'
end

def install_dep(package, reason)
    name = Script.current.name
    line = '-'*50
    msg = []
    msg << line
    msg << "#{name} requires the '#{package}' RubyGem #{reason}."
    msg << ''
    unless RUBY_VERSION =~ /^(\d+)\.(\d+)/
        msg << "It is not able to automatically install it because it cannot determine what version of Ruby you are running."
        msg << "The automatic install requires Ruby 2.4 or later.  Your current version is listed as #{RUBY_VERSION.inspect}"
        msg << ''
        msg << "Please update your Ruby install and/or install #{package} manually, then try again."
        msg << line
        respond msg
        exit
    end
    major = $1.to_i
    minor = $2.to_i

    unless Gem
        msg << "'Gem' does not appear to be available."
        msg << ''
        msg << "Please update your Ruby install, install gem', or install #{package} manually, then try again."
        msg << line
        respond msg
        exit
    end

    warning = nil

    if major == 2
        if minor < 4
            warning = "Your version of Ruby (#{RUBY_VERSION}) is probably too old for automatic installation to succeed."

        end
    elsif major < 2
        warning = "Your version of Ruby (#{RUBY_VERSION}) is too old for Lich(!) much less this script."
    else
        warning = "Your version of Ruby (#{RUBY_VERSION}) is too new and exotic, and the outcome of automatic installation is not guaranteed."
    end

    if warning
        msg << warning
        msg << "If you want to attempt automatic installation anyways:"
    else
        msg << "If you want to attempt automatic installation:"
    end
    msg << "    #{$lich_char}unpause #{name}"
    msg << ''
    msg << "Otherwise:"
    msg << "    #{$lich_char}kill #{name}"
    msg << line
    respond msg

    pause_script

    echo "Installing #{package}.  This may take a minute..."
    Gem.install(package, verbose: true)
    Gem.clear_paths
end
require_deps


module StormSync
    VERSION = '0.0.2-PREVIEW (2022-03-07)'
    VERSION_INT = 2
    UI_VERSION = 1

    GAME_MAPPINGS = {
        'GSIV' => 'GS4',
        'GSPlat' => 'GS4X',
    }
    GAME_MAPPINGS.default_proc = proc {|key| key}

    VALID_NAME_PATTERN = /^[^\s,;\/\\@]+$/  # Forbid whitespace, slashes, and separators in names.
    INVALID_NAME_CHARACTERS = /[\s,;\/\\@]+/
    VALID_NAME_ERROR = "Names may not include whitespace or any of the following characters: , ; / \\ @"

    TEXT_LINE = '-'*40

    IMAGE_ATLAS = (
        "iVBORw0KGgoAAAANSUhEUgAAANgAAAAYCAMAAACvFsNrAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8" +
        "YQUAAAMAUExURQAAAAYGAAUPAAgIAAcXAAkfABAQAA4uABA2ABI+ACkpACsrADk5ABVGABdNABlVABxd" +
        "ACN0ACV8AENDAExMAGVlAG1tAGBgYCeDACmLAC6bADCiADOqADe5ADrBADzJAD7RAEPgAEXoAEfwAEr3" +
        "AEz/AAD//4ODAIWFAJubAJ2dAKWlAKurAL6+AMHBAMTEAMbGANnZANvbAN7eAP/YAP39AP//AJCQkJKS" +
        "kpOTk5WVlZeXl5qamp+fn6CgoKKioqOjo6SkpKenp6mpqaqqqqysrK2tra+vr7Gxsbe3t7q6ury8vL+/" +
        "v8DAwMTExMbGxsnJycrKysvLy87OztHR0dPT09TU1NXV1dbW1tjY2Nvb297e3uDg4OPj4+Xl5ebm5ufn" +
        "5+np6fDw8PLy8v///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" +
        "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" +
        "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" +
        "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" +
        "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" +
        "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" +
        "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" +
        "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIDD" +
        "bjEAAAEAdFJOU///////////////////////////////////////////////////////////////////" +
        "////////////////////////////////////////////////////////////////////////////////" +
        "////////////////////////////////////////////////////////////////////////////////" +
        "////////////////////////////////////////////////////////////////////////////////" +
        "/////////////////////////////////wBT9wclAAAACXBIWXMAAA7DAAAOwwHHb6hkAAADrklEQVRY" +
        "R83XaVfTQBQG4CuiiLKKC0hQtqq4i8ooiMoughIFEVmsYv//X8D3Lm2nmSkECuf4fkjuNGmTp53cJlQv" +
        "rk5scxDbHMQ2B7HNQd5Jbkr8+sAP3m+VF/5UKxGiQjTkitE4uhsNuT/ROJqIhlwpmpywUimg0Uuk+qLB" +
        "mokGpBhKEikMNuXcuhTbaSpFGYZvRwtLGYbvXAsLwyiD4zHDXAbH4yNhAgIMNH2hnMNhvZeImjqHAtjK" +
        "e+cmF7ZPDuN5QnTlQRYm0899+JEXRuLBRwWyKKwfe7ZjncjhqXXUYGs46CzWqR5/Zq9BGNH1VzGYcyv5" +
        "YDwHK1Wt7FBYlx6dhjOwJT2622kYRo/iMLedB6YafEqlriYKa+FDDhaGibowHYm6DTbNh9wq7ji3hOno" +
        "3HIjsMcvnlwmuhbA9v7+wkT/aGNl+CSt5WRhYZiKMrLDYKNJcqdQGAxge2n6vVjcahA2PjHxFKsAtl8q" +
        "FbE6AsZnyC6FlWVHwAZAkR8LZZL0VWDroMiPhTJNVxuHjdeB7eeAiQrhqSirzE9WBzbYKrDeJv5mPNjW" +
        "jMBWJnHo/wVWIWFVlbDMHzGsHUv0jWFedHRiZLBZ57hv7PBifgGjRmEP68B+HhNmpBywDu70wyMXuNNX" +
        "r7FZN8+dfmf3LXf6Rq+x+2NjF4naAti3zU38Xc6dAUwkvLjNHaQKEwkvNriDBDCLjaswi42rMMn5ZwFM" +
        "8ua3jZXhk7Q+Iex2YaSFutFBMrCN4u60W0YHOSXYuXvROw/3+itO+dRhuLJuJQlaPv7HWpOktQzDlfUl" +
        "TdHy8T82k6YzDcLaenpuPI/cUs0tLn7GdXYcGA/ywTSAaSowDWCaMsw0Gn1FIKbR6CtVGJqHJgMTFCcv" +
        "LN7u2WIFB7AKh/pw04Gb4Gb0EsAqHLeKmw7cBE+hlwistnHISGC1jUNGpwdDZK96f9CZ1MJGrsI1wN2/" +
        "Frb7Ca517v4Ms729KMz29nKKMDlZ3qveLVUmMGjL4PuqZl5pANOWwfdVU7zSAKaW2jBMLbU5PkwZPklr" +
        "PVvsxVMx7spOxePCzvYX8zF+badbwURc2eZB1Iwny0Khk6hfUBzAnJvCk2WxuODcmqA4Z36N+Ri/Lp+v" +
        "aPBp2D9w+TKB8aOYPJRlYPwoJg9lGdgJuqIfH+YnD0znG7MyrggsGsCiUVgYhYVhWCwMi+VImIRnZMYl" +
        "MipZzbA6kWskEtscxDYHsc1BbHMQH+PXdr4avN8qP96LBwf/ACCjNxXqoYhsAAAAAElFTkSuQmCC"
    )

    DEFAULT_COLORS = %w(
        #4d0000 #800000 #bf0000 #ff0000 #ff4040 #ff8080 #ffb3b3 #bf4040
        #004c4d #007f80 #00bfbf #00ffff #40ffff #80ffff #b3ffff #40bfbf
        #000000 #000080 #008000 #008080 #800000 #800080 #808000 #c0c0c0

        #4d2600 #804000 #bf6000 #ff8000 #ff9f40 #ffbf80 #ffd9b3 #bf8040
        #00264d #004080 #0060bf #007fff #409fff #80bfff #b3d9ff #407fbf
        #ffffff #0000ff #00ff00 #00ffff #ff0000 #ff00ff #ffff00 #ffffff

        #4c4d00 #7f8000 #bfbf00 #ffff00 #ffff40 #ffff80 #ffffb3 #bfbf40
        #00004d #000080 #0000bf #0000ff #4040ff #8080ff #b3b3ff #4040bf
        #ffffff #ffffff #ffffff #ffffff #ffffff #ffffff #ffffff #ffffff

        #264d00 #408000 #60bf00 #80ff00 #9fff40 #bfff80 #d9ffb3 #80bf40
        #26004d #400080 #6000bf #7f00ff #9f40ff #bf80ff #d9b3ff #7f40bf
        #ffffff #ffffff #ffffff #ffffff #ffffff #ffffff #ffffff #ffffff

        #004d00 #008000 #00bf00 #00ff00 #40ff40 #80ff80 #b3ffb3 #40bf40
        #4d004c #80007f #bf00bf #ff00ff #ff40ff #ff80ff #ffb3ff #bf40bf
        #ffffff #ffffff #ffffff #ffffff #ffffff #ffffff #ffffff #ffffff

        #004d26 #008040 #00bf60 #00ff80 #40ff9f #80ffbf #b3ffd9 #40bf80
        #4d0026 #800040 #bf0060 #ff0080 #ff409f #ff80bf #ffb3d9 #bf4080

        #000000 #111111 #222222 #333333 #444444 #555555 #666666 #777777
        #888888 #999999 #aaaaaa #bbbbbb #cccccc #dddddd #eeeeee #ffffff
    )

    Dir.mkdir(DATA_DIR) unless File.exists?(DATA_DIR)
    DB = Sequel.sqlite(DATA_DIR + "/" + Script.current.name + ".db3")
    before_dying do
        begin
            DB.disconnect
            GC.collect(immediate_sweep: true)
        rescue
            nil
        end
    end

    module TimestampedModel
        def before_update
            now = Time.new
            self.updated_ts = Time.new
        end
        def before_create
            now = Time.new
            self.updated_ts = now
            self.created_ts = now
        end
    end

    @database_version = 0

    class FutureTimedOut < Exception
        def initialize(future, msg)
            super(msg)
            @future = future
        end
    end

    class FutureFinished < Exception
        def initialize(future, msg = 'Future completed.')
            super(msg)
            @future = future
        end
    end

    class Future
        def initialize
            @waiting = Set.new   # Threads currently blocked waiting for a result.
            @lock = Mutex.new    # Concurrent modification prevention
            @error = nil
            @value = nil
        end

        def done?
            return @done
        end

        def value=(new_value)
            @lock.synchronize {
                raise "Cannot assign a value to a completed Future." if @done
                @value = new_value
                make_done
            }
            @when_done.call(self)
        end

        def error=(new_error)
            @lock.synchronize {
                echo new_error.inspect
                echo new_error.backtrace.join("\n")
                raise "Cannot assign an exception to a completed Future." if @done
                @error = new_error
                make_done
            }
            @when_done.call(self)
        end

        def wait_result
            begin
                Thread.handle_interrupt(FutureFinished => :immediate) {
                    @lock.synchronize {
                        return if @done
                        @waiting << Thread.current
                    }
                    sleep
                    raise FutureTimedOut.new(self, "Operation timed out")
                }
            rescue FutureFinished
                return
            end
            # Shouldn't be reachable
            raise 'Thread awoke unexpectedly -- reached unreachable code in fetch_result.  FIXME.'
        end
        private(:wait_result)

        def value
            wait_result
            raise @error if @error
            return @value
        end

        def error
            wait_result
            return @error
        end

        def make_done()
            # Must already be locked!
            @done = true
            @waiting.each {|thr| thr.raise(FutureFinished.new(self, 'Future completed.')) }
            @waiting.clear
        end
        private(:make_done)

        def then(&block)
            @lock.synchronize {
                @when_done = block
                @when_done.call(self) if @done
            }
            @when_done = block
        end

        def execute(&block)
            @lock.synchronize {
                raise "Cannot execute a block on a completed Future." if @done

                begin
                    @value = block.call
                rescue => ex
                    @error = ex
                end
                make_done
            }
            @when_done.call(self)
        end
    end


    class << self
        def upgrade_db(version, &block)
            return unless @db_version < version
            echo "Upgrading database version from #{@db_version} to #{version}"

            DB.transaction do
                block.call
                DB[:settings].update(version: version)
            end
            @db_version = version
        end

        def initialize_db
            # Ensure the settings table exists.
            DB.transaction do
                unless DB.table_exists?(:settings)
                    DB.create_table?(:settings) do
                        Integer :id, primary_key: true     # Non-autoincrementing, since we should only have one row.
                        Integer :version, null: false      # Version integer.
                        check(id: 42)                      # Should only have one row.  This forces it.
                    end
                    DB.run("INSERT INTO settings (id, version) VALUES (42, 0)")
                end
            end
            # Determine database version
            @db_version = DB[:settings].first[:version]

            self.upgrade_db(1) do
                DB.create_table(:characters) do
                    primary_key :id
                    String :name, null: false
                    String :game, null: false
                    Integer :player_id, null: false
                    Time :created_ts, null: false, default: Sequel::CURRENT_TIMESTAMP
                    Time :updated_ts, null: false, default: Sequel::CURRENT_TIMESTAMP

                    unique [:name, :game]
                    unique [:player_id, :game]
                end

                DB.create_table(:scopes) do
                    primary_key :id
                    String :name, null: false
                    String :lower_name, null: false

                    Time :created_ts, null: false, default: Sequel::CURRENT_TIMESTAMP
                    Time :updated_ts, null: false, default: Sequel::CURRENT_TIMESTAMP

                    unique :lower_name
                end

                DB.create_table(:character_scopes) do
                    foreign_key :character_id, :characters, type: Integer, null: false, on_delete: :cascade, on_update: :cascade
                    foreign_key :scope_id, :scopes, type: Integer, null: false, on_delete: :cascade, on_update: :cascade
                    Integer :priority, null: false
                    primary_key [:character_id, :scope_id]
                end

                DB.create_table(:highlight_groups) do
                    primary_key :id
                    foreign_key :scope_id, :scopes, type: Integer, null: false, on_delete: :cascade, on_update: :cascade

                    String :name, null: false
                    String :lower_name, null: false
                    String :color, null: true
                    String :bgcolor, null: true
                    String :sound, null: true

                    Int :type_enum, null: false
                    Int :merge_policy_enum, null: false, default: 0

                    TrueClass :partial_word, null: true
                    TrueClass :entire_line, null: true
                    TrueClass :ignore_case, null: true

                    String :origin, null: true
                    Time :created_ts, null: false, default: Sequel::CURRENT_TIMESTAMP
                    Time :updated_ts, null: false, default: Sequel::CURRENT_TIMESTAMP
                    TrueClass :is_active, null: true, default: true

                    unique [:scope_id, :lower_name, :is_active]
                end

                DB.create_table(:highlight_strings) do
                    primary_key :id
                    foreign_key :highlight_group_id, :highlight_groups, type: Integer, null: false, on_delete: :cascade, on_update: :cascade

                    String :text, null: false
                    String :lower_text, null: false
                    String :color, null: true
                    String :bgcolor, null: true
                    String :sound, null: true

                    Int :type_enum, null: true
                    TrueClass :partial_word, null: true
                    TrueClass :entire_line, null: true
                    TrueClass :ignore_case, null: true

                    String :origin, null: true
                    String :comment, null: true
                    Time :created_ts, null: false, default: Sequel::CURRENT_TIMESTAMP
                    Time :updated_ts, null: false, default: Sequel::CURRENT_TIMESTAMP
                    TrueClass :is_active, null: true, default: true

                    unique [:highlight_group_id, :text, :is_active]
                end
            end

            self.upgrade_db(2) do
                DB.alter_table(:highlight_groups) do
                    add_index [:is_active]
                end
                DB.alter_table(:highlight_strings) do
                    add_index [:is_active]
                end
            end
            #
            # self.upgrade_db(3) do
            #     DB.alter_table(:highlight_strings) do
            #         # drop_index [:highlight_group_id, :lower_text], name: "sqlite_autoindex_highlight_strings_1"
            #         add_index [:highlight_group_id]
            #         add_index [:highlight_group_id, :text], unique: true, where: Sequel.~(:is_deleted)
            #     end
            # end

            # echo "Current database version: #{@db_version.inspect}"
        end
    end
    self.initialize_db
    Model = Class.new(Sequel::Model)
    Model.require_valid_table = false
    Model.def_Model(self)


    module LowercaseNameMixin
        def name=(value)
            super(value)
            if value
                self.lower_name = value.downcase
            else
                self.lower_name = nil
            end
        end

        def self.lower_name
            return self.name.downcase
        end

        def before_save
            self.lower_name = self.name.downcase
        end
    end


    module HighlightMixin
        TYPE_IGNORE = 0
        TYPE_STRING = 1
        TYPE_NAME = 2

        TYPE_NAMES = ['ignore', 'string', 'name'].freeze
        TYPE_TAGS = TYPE_NAMES.map{|k| k+'s'}.freeze
        TYPE_IDS = {
            'ignore' => TYPE_IGNORE, 'ignores' => TYPE_IGNORE, TYPE_IGNORE => TYPE_IGNORE,
            'string' => TYPE_STRING, 'strings' => TYPE_STRING, TYPE_STRING => TYPE_STRING,
            'name'   => TYPE_NAME,   'names'    => TYPE_NAME,   TYPE_NAME => TYPE_NAME,
        }

        def initialize(*args, type: nil, type_tag: nil, element: nil, **kwargs)
            super(*args, **kwargs)
            self.type = type if type
            self.type_tag = type_tag if type_tag
            read_element(element) if element
        end

        def has_text?; return false; end

        def type
            return TYPE_NAMES[self.type_enum] if self.type_enum
            return nil
        end

        def type=(name)
            unless name
                self.type_enum = nil
                return
            end
            value = TYPE_IDS[name]
            raise "Invalid type #{name.inspect}" unless value
            self.type_enum = value
        end

        def type_tag
            return TYPE_TAGS[self.type_enum] if self.type_enum
            return nil
        end

        def type_tag=(name)
            self.type=(name)
            return TYPE_TAGS[self.type_enum] if self.type_enum
            return nil
        end

        def remap_color(palette)
            if self.color and self.color =~ /^@(.+)$/
                self.color = palette[$1] or [self:color]
            end
            if self.bgcolor and self.bgcolor =~ /^@(.+)$/
                self.bgcolor = palette[$1] or self.bgcolor
            end
        end

        def flags
            n = (self.type_enum || TYPE_STRING)
            n |= 4 if self.entire_line
            n |= 8 if self.ignore_case
            n |= 16 if self.partial_word
            return n
        end

        def grouping
            "#{(self.color || '0').upcase}-#{(self.bgcolor || '0').upcase}-#{self.flags}".gsub('#', '')
        end

        def xml(name='h')
            e = REXML::Element.new(name)
            unless self.type_enum == TYPE_IGNORE
                e.add_attributes(
                    {
                        'color' => self.color,
                        'bgcolor' => self.bgcolor || ''
                    }
                )
                e.add_attribute('line', 'y') if self.entire_line
                e.add_attribute('sound', self.sound) if self.sound
            end
            e.add_attribute('case', 'y') if self.ignore_case
            e.add_attribute('word', 'y') if self.partial_word
            e.add_attribute('text', self.text) if self.has_text? and self.text
            return e
        end

        def read_element(element)
            a = element.attributes
            self.color = a['color']
            self.color = nil if self.color == ''
            self.bgcolor = a['bgcolor']
            self.bgcolor = nil if self.bgcolor == ''
            self.sound = a['sound']
            self.entire_line = ((a['line']== 'y') && true || false)
            self.ignore_case = ((a['case'] == 'y') && true || false)
            self.partial_word = ((a['word'] == 'y') && true || false)
        end

        def attrs
            return HighlightAttrs.new(source: self)
        end
    end


    class HighlightAttrs
        attr_accessor :color, :bgcolor, :sound, :entire_line, :ignore_case, :partial_word, :text, :type_enum
        include HighlightMixin

        def has_text?; return true; end
        def attrs; return self; end

        def initialize(source: nil, text: nil, type_enum: nil, type: nil, color: nil, bgcolor: nil, sound: nil, entire_line: nil, ignore_case: nil, partial_word: nil)
            @color = color
            @bgcolor = bgcolor
            @sound = sound
            @entire_line = entire_line
            @ignore_case = ignore_case
            @partial_word = partial_word
            @text = text
            @type_enum = type_enum
            self.type = type if type
            self.type_tag = type_tag if type_tag

            merge!(source) if source
        end

        def merge!(other)
            @text = other.text.dup if @text.nil? and other.has_text?
            unless @color
                @bgcolor = nil
                @color = other.color.dup if other.color
                @bgcolor = other.bgcolor.dup if other.bgcolor
            end
            @sound ||= other.sound.dup if other.sound and @sound.nil?
            @entire_line = other.entire_line if @entire_line.nil?
            @ignore_case = other.ignore_case if @ignore_case.nil?
            @partial_word = other.partial_word if @partial_word.nil?
            @type_enum ||= other.type_enum
            return self
        end

        def merge(other)
            return self.dup.merge!(other)
        end
    end


    class HighlightString < Model
        include HighlightMixin
        include TimestampedModel
        include LowercaseNameMixin

        # Convenience methods so things can take both a string and a group
        def name; self.text; end
        def name=(value)
            self.text = value
        end

        def group; self.highlight_group; end
        def group=(v); self.highlight_group=(v); end
        many_to_one :highlight_group

        def read_element(element)
            super
            self.text = element.attributes['text']
        end

        def merge(other)
            attrs = HighlightAttrs.new(source: self, text: self.text)
        end

        def has_text?; return true; end

        def self.text=(value)
            super(value)
            self.lower_text = value.downcase
        end

        def self.lower_text
            return self.text.downcase
        end

        def before_save
            self.lower_text = self.text.downcase
        end
    end

    class HighlightGroup < Model
        include HighlightMixin
        include TimestampedModel
        include LowercaseNameMixin

        # Merge policies
        # Groups with the same name in different scopes have special treatment.
        # This logic only applies when determining which highlights a particular character gets.
        # It does not permanently modify anything.

        MERGE_POLICY_NONE = 0               # Treat identically-named groups within different scopes as different scopes.
        MERGE_POLICY_SUPERCEDE = 1          # Supercede the parent group(s), if any.  (Pretend they are empty)
        MERGE_POLICY_CHANGE_PARENT = 2      # Change colors/attributes on the parent group to match this one
        MERGE_POLICY_CHANGE_SELF = 3        # Change colors/attributes on this group to match the parent
        MERGE_POLICY_MERGE_DOWN = 4         # Act like the parent group doesn't exist and all strings belong to this group instead.
        MERGE_POLICY_MERGE_UP = 5           # Act like this group doesn't exist and all strings belong to the parent instead.

        MERGE_POLICY_NAMES = ['none', 'replace parent', 'alter parent', 'mimic parent']

        many_to_one :scope
        one_to_many :highlight_strings

        def path
            return "#{self.scope.name}/#{self.name}"
        end
    end

    class Character < Model
        include TimestampedModel
        one_to_many :character_scopes, order: :priority, join_table: :character_scopes
        many_to_many :scopes, join_table: :character_scopes, order: :priority

        def qualified_name
            return self.game + "-" + self.name
        end

        def name=(value)
            value = value.capitalize if value
            return super(value)
        end

        def stormfront_settings
            return SFSettings.new(self.player_id, self.game)
        end

        def merged_highlights
            # Split highlights out correctly.
            highlights = Hash.new{|h,k| h[k]=[]}

            # Highlight merging:
            #
            # Partial-word highlights are treated entirely separate from non-partial-word highlights.
            # Case-insensitive highlights are treated entirely separate from case-sensitive ones.
            # Ignores are treated entirely separately from non-ignores
            #
            # Within each of these:
            #   Entire line highlights replace any non-entire-line highlights in the same priority
            #   Entire line highlights replace all highlights in lower priorities
            #   Other highlights replace regular highlights in all priorities.
            #
            # Then:
            # Optimize remaining ignores:
            #   If the same ignore exists as case-sensitive and case-insensitive with the same partial word behavior, drop the case-sensitive version.
            #   If the same ignore exists as a partial word and non-partial-word ignore with the same case sensitivity, drop the non-partial-word version.

            # Load everything and handle merge policies.  Also, create group pseudo-highlights
            groups = []
            parent_groups = {}
            index = 0
            priority = 0
            self.scopes.each do |scope|
                priority += 1
                scope.highlight_groups.each do |group|
                    next unless group.is_active
                    # attrs = group.attrs
                    # attrs.text = "GROUP[#{group.path}]"
                    # highlights[attrs.type_enum] << attrs
                    #
                    name = group.name.downcase
                    attrs = group.attrs
                    strings = group.highlight_strings.to_a
                    parent = parent_groups[name]


                    load = [group]
                    if parent
                        case group.merge_policy_enum
                        when HighlightGroup::MERGE_POLICY_CHANGE_PARENT
                            parent[:attrs] = attrs
                        when HighlightGroup::MERGE_POLICY_CHANGE_SELF
                            attrs = parent[:attrs]
                        when HighlightGroup::MERGE_POLICY_SUPERCEDE
                            parent[:strings] = nil
                        when HighlightGroup::MERGE_POLICY_MERGE_DOWN
                            strings += parent[:strings]
                            parent[:strings] = nil
                        when HighlightGroup::MERGE_POLICY_MERGE_UP
                            parent[:strings] += strings
                            next
                        else
                            # noop
                        end
                    end
                    entry = {
                        :name => name,
                        :attrs => attrs,
                        :strings => strings,
                        :priority => priority,
                        :index => (index += 1)
                    }
                    groups << entry
                    parent_groups[name] = entry
                end
            end

            groups.each do |g|
                attrs = g[:attrs]
                g[:strings].each do |s|
                    next unless s.is_active
                    # Resolve inheritance
                    s = s.attrs.merge(attrs)
                    # Add to strings
                    highlights[s.type_enum] << s
                end
            end

            return {
                'strings' => highlights[HighlightMixin::TYPE_STRING],
                'names' => highlights[HighlightMixin::TYPE_NAME],
                'ignores' => highlights[HighlightMixin::TYPE_IGNORE],
            }
        end

        def send_highlights(settings=nil)
            refresh
            settings ||= stormfront_settings
            settings.load?

            merged = merged_highlights
            merged.each do |tag, strings|
                settings.patch(tag, strings.map(&:xml))
            end
            settings.send(merged.keys)
        end
    end

    class Scope < Model
        include TimestampedModel
        include LowercaseNameMixin
        one_to_many :character_scopes, join_table: :character_scopes
        one_to_many :highlight_groups, join_table: :highlight_groups
        many_to_many :characters, join_table: :character_scopes
    end

    class CharacterScope < Model
        many_to_one :character
        many_to_one :scope, join_table: :scopes
    end

    class SFSettingsData
        def _deep_xml_copy(e)
            return REXML::Document.new(e.to_s).root
        end

        def initialize(copy=nil)
            @root_node = nil
            @sections = nil
            @palette = nil

            read_xml(copy.to_s) if copy
        end

        def read_xml(xml)
            root = REXML::Document.new(xml).root

            sections = {}
            root.each do |element|
                sections[element.name] = element
            end

            if sections['palette']
                palette = {}
                sections['palette'].each do |element|
                    next unless element.name == 'i'
                    a = element.attributes
                    palette[a['id']] = a['color']
                end
            end

            @root = root
            @sections = sections
            @palette = palette
        end

        def send(tags=nil)
            tags ||= @sections.keys

            major = ((@root.attributes['major']) || '1').to_i
            local_root = nil
            root = @root.clone

            tags.each do |tag|
                section = @sections[tag]
                next unless section

                if section.attributes['local']
                    local_root = @root.clone unless local_root
                    local_tag = section.clone
                    local_root.add_element(local_tag)
                end

                section = _deep_xml_copy(section)
                root.add_element(section)
                section.delete_attribute('local')
            end

            root.attributes['major'] = (major += 1).to_s
            local_root.attributes['major'] = (major += 1).to_s if local_root
            @root.attributes['major'] = major.to_s

            toggle_upstream if local_root
            _respond root.to_s, '<sentSettings/>'
            return
            return unless local_root
            nil until upstream_get =~ /^<db>|^<stgupd>/
            toggle_upstream
            _respond local_root.to_s, '<sentSettings/>'
        end

        def patch(tag, children=nil, optimize=true)
            load?
            node = @sections[tag]
            if node
                @root.delete_element(node)
                node = node.clone
                node.delete_attribute('local')
                @root.add_element(node)
            else
                node = @root.add_element(tag)
            end
            @sections[tag] = node

            return node unless children
            if optimize
                seen = Set.new
                children.each do |child|
                    next unless seen.add?(child.to_s)
                    node.add_element(child)
                end
            else
                children.each{|child| node.add_element(child)} if children
            end
            return node
        end
    end

    class SFSettingsBase < SFSettingsData
        attr_accessor :filename
        attr_reader :root, :sections, :palette

        GAME_MAPPINGS = {
            'GSIV' => 'GS4',
            'GSPlat' => 'GS4X',
        }

        def initialize(filename=nil)
            @filename = filename
            @mtime = nil

            super
        end

        def load(filename=nil)
            filename ||= @filename
            begin
                f = File.open(filename, "r")
                xml = f.read
            ensure
                f.close if f and not f.closed?
            end

            read_xml(xml)
            @filename = filename
        end

        def load?(filename=nil)
            load unless loaded?
        end

        def unload
            @root = nil
            @sections = nil
            @palette = nil
        end

        def loaded?
            @root and true or false
        end

        def dirname; File.dirname(@filename); end
        def basename; File.basename(@filename); end

        def mtime
            return @mtime if @mtime
            return mtime!
        end

        def mtime!
            return (@mtime = File.mtime(@filename))
        end
    end

    class SFSettings < SFSettingsBase
        GAME_MAPPINGS = {
            'GSIV' => 'GS4',
            'GSPlat' => 'GS4X',
        }

        def self.settings_dir(game=nil, root)
            root ||= "#{ENV['AppData']}/StormFront/"
            root += "/" unless root[-1] == '/'
            game ||= XMLData.game
            return File.realpath(root + GAME_MAPPINGS[game])
        end

        attr_accessor :player_id, :game

        def initialize(player_id=nil, game=nil, root: nil)
            game ||= XMLData.game
            player_id ||= XMLData.player_id

            @player_id = player_id
            @game = game
            super(SFSettings.settings_dir(game, root) + "/#{player_id}.xml")
        end

        def backups
            pattern = "#{self.dirname}/#{@player_id}-backup-*.xml"
            return Dir.glob(pattern).map{|fn| SFBackup.new(self, fn)}.sort_by(&:mtime)
        end

        def create_backup(name=nil, append_timestamp: nil)
            timestamp = Time.now.strftime("%Y%m%d-%H%M%S")
            if name
                if append_timestamp
                    name += "-#{timestamp}"
                end
            else
                name = timestamp
            end

            filename = "#{self.dirname}/#{@player_id}-backup-#{name}.xml"
            raise "File '#{filename}' already exists!" if File.exists?(filename)
            FileUtils.copy_file(self.filename, filename)
            return SFBackup.new(self, filename)
        end

        def _get_backup(backup)
            return backup if backup.is_a? SFBackup
            return SFBackup.new(self, backup) if File.exists?(backup)
            return SFBackup.new(self, "#{self.dirname}/#{@player_id}-backup-#{backup}.xml")
        end


        def restore_backup(backup, full=false)
            backup = _get_backup(backup)
            raise "File '#{backup.filename}' not found!" unless File.exists?(backup.filename)
            return backup.restore(full)
        end

        def delete_backup(backup)
            backup = _get_backup(backup)
            raise "File '#{backup.filename}' not found!" unless File.exists?(backup.filename)
            return backup.delete
        end
    end

    class SFBackup < SFSettingsBase
        attr_reader :parent
        def initialize(parent, filename)
            @parent = parent
            @mtime = nil
            super(filename)
        end

        def restore(full=false)
            # Full restore sends ALL tags
            # Partial restore sends only those related to highlights
            load?

            if full
                send
            else
                send(%w(names strings ignores))
            end

            return self
        end

        def delete
            File.delete(self.filename)
            return self
        end

        def name
            base = self.basename
            return base unless base =~ /^\d+-backup-(.+)\.xml$/i
            return $1
        end
    end

    class << self
        def get_character(player_id: nil, game: nil, path: nil, file: nil)
            player_id ||= XMLData.player_id
            game ||= XMLData.game
            return Character[game: game, player_id: player_id]
        end

        def import(player_id: nil, game: nil, name: nil, path: nil, file: nil, force: false, import_none: false, scopes: nil)
            player_id ||= XMLData.player_id
            game ||= XMLData.game
            name ||= XMLData.name
            imported_from = "Imported from #{game}-#{name}(#{player_id})"

            scope_name = "#{game}-#{name}"

            DB.transaction do
                # Make sure we can safely import this character.
                if (character = get_character(player_id: player_id, game: game))
                    if force
                        echo "Character '#{name}' was previously imported, but option 'force' specified.  Deleting the old character."
                        character.delete
                    else
                        raise "Character #{scope_name} (#{player_id}) is already imported."
                    end
                end

                if (scope = Scope[lower_name: scope_name.downcase])
                    if force
                        echo "Scope '#{name}' was previously imported, but option 'force' specified.  Deleting the old scope."
                        scope.delete
                    else
                        raise "A scope named '#{scope}' already exists.  Cannot import this character."
                    end
                end

                # Create the character
                character = Character.new(game: game, name: name, player_id: player_id)
                character.save
                echo "Created character '#{scope_name}' (player id: #{player_id}) with id=#{character.id}"

                # Associate and possibly create scopes.
                local_scope = nil

                priority = 0
                scopes ||= ["#{game[0..1]}-GLOBAL", game]
                scopes << scope_name

                scopes.each do |name|
                    priority += 100
                    if name.is_a?(Scope)
                        scope = name
                    else
                        scope = Scope[lower_name: name.downcase]
                        unless scope
                            scope = Scope.new(name: name)
                            scope.save
                            echo "Created scope '#{scope.name}' with id=#{scope.id}"
                            local_scope = scope
                        end
                    end
                    character.add_character_scope(scope: scope, priority: priority)
                end

                return if import_none  # Since we don't actually import highlights in this case.

                # Actually read Stormfront settings.
                settings = character.stormfront_settings
                settings.load?
                palette = settings.palette

                # Group highlights
                grouped_highlights = Hash.new{|h, k| h[k] = {}}
                seen_texts = Set.new  # Avoid more expensive lookups.

                grouping_names = {}

                HighlightString::TYPE_TAGS.each do |type_tag|
                    entries = settings.sections[type_tag]
                    next unless entries
                    entries.each do |e|
                        next unless e.name == 'h'
                        highlight = HighlightString.new(element: e, type_tag: type_tag)
                        seen_texts << highlight.text
                        highlight.remap_color(palette) if palette

                        grouping = highlight.grouping

                        if highlight[:text] =~ /^GROUP(?:[:=]([^\s]+)|\[([^\s]+)\])$/i
                            grouping_names[highlight.grouping] = ($1 or $2)
                        else
                            grouped_highlights[highlight.grouping][highlight[:text]] = highlight
                        end
                    end
                end

                duplicates = 0
                # Find identical highlights in scope.
                character.scopes.each do |scope|
                    scope.highlight_groups.each do |group|
                        grouping_names[group.grouping] ||= group.name
                        group.highlight_strings.each do |highlight|
                            next unless seen_texts.include?(highlight.text)
                            grouping = highlight.attrs.merge!(group).grouping
                            g = grouped_highlights[grouping]
                            next unless g
                            duplicates += 1 if g.delete(highlight.text)
                        end
                    end
                end

                standalone = {}
                group_numbers = {}
                bulk_insert = []
                grouped_highlights.each do |grouping, highlights|
                    values = highlights.values
                    next if values.length == 0
                    h = values[0]
                    type = h.type
                    typename = type.to_s.capitalize + "s"

                    if highlights.length == 1 and not grouping_names[grouping]
                        unless standalone[type]
                            g = standalone[type] = local_scope.add_highlight_group(
                                name: "Standalone-#{typename}",
                                type: type,
                                origin: imported_from,
                            )
                            echo "Created group '#{g.path}', id=#{g.id}"
                        end
                        h.type = nil
                        h.origin = imported_from
                        standalone[type].add_highlight_string(h)
                        next
                    end

                    name = grouping_names[grouping]
                    unless name
                        group_numbers[type] ||= 0
                        n = (group_numbers[type] += 1)
                        name = "#{typename}-#{n}"
                    end
                    g = local_scope.add_highlight_group(
                         name: name,
                         type: h.type,
                         color: h.color,
                         bgcolor: h.bgcolor,
                         entire_line: h.entire_line,
                         ignore_case: h.ignore_case,
                         partial_word: h.partial_word
                    )
                    echo "Created group '#{g.path}', id=#{g.id}"

                    bulk_insert += values.map{|h| [g.id, h.text, h.text.downcase, h.sound, imported_from]}
                    if bulk_insert.length > 1000
                        HighlightString.dataset.import(
                            [:highlight_group_id, :text, :lower_text, :sound, :origin], bulk_insert
                        )
                        echo "Wrote #{bulk_insert.length} highlight strings"
                        bulk_insert.clear
                    end
                end

                if bulk_insert.length > 0
                    HighlightString.dataset.import(
                        [:highlight_group_id, :text, :lower_text, :sound, :origin], bulk_insert
                    )
                    echo "Wrote #{bulk_insert.length} highlight strings"
                end

                bulk_insert = nil

                backup = settings.create_backup('before-import', append_timestamp: true)
                echo "Current settings backed up to #{backup.filename}"

                character.send_highlights
                #
                # merged.each do |tag, strings|
                #     settings.patch(tag, strings)
                # end
                #
                # settings.send(merged.keys)

                # msg = []
                # grouped_highlights.each do |category, entries|
                #     msg << category
                #     msg += entries.map{|x| "    #{x.inspect}"}[0..0]
                # end
                # respond msg
                return character
            end
        end


        def cmd_scope(args)
            unless args
                cmd_scope_list(nil)
                respond [
                    "",
                    "Type #{$lich_char}#{@script.name} SCOPE HELP for a list of scope commands.",
                    "Type #{$lich_char}#{@script.name} HELP for a list of all commands."
                ]
                return
            end

            cmd, subargs = args.strip.split(/\s+/, 2)
            case cmd.downcase
            when 'list'
                cmd_scope_list(subargs)
            when 'add'
                cmd_scope_add(subargs)
            when 'del', 'delete'
                cmd_scope_delete(subargs)
            when 'auto'
                cmd_scope_set('auto')
            when 'local'
                cmd_scope_set('local')
            when 'help'
                echo "FIXME"
            when 'set'
                cmd_scope_set(subargs)
            when 'order'
                cmd_scope_order(subargs)
            else
                cmd_scope_set(args)
            end
        end


        def cmd_scope_set(args)
            lower = args.downcase
            if lower == 'auto'
                @scope = :auto
                echo "Commands that require a scope will choose the most relevant scope by default."
            elsif lower == 'local'
                local_scope = @character.scopes[-1].name
                @scope = :local
                echo "Commands that require a scope will choose the most local scope ('#{local_scope}') by default."
            else
                scope = Scope[lower_name: lower]
                unless scope
                    echo "Scope '#{scope}' does not exist."
                    return
                end
                @scope = scope.name
                echo "Commands that require a scope will choose the '#{@scope}' scope by default."
            end
        end


        def cmd_scope_add(args)
            unless args =~ VALID_NAME_PATTERN
                echo VALID_NAME_ERROR
                return
            end

            DB.transaction do
                begin
                    scope = Scope.new(name: args).save
                rescue Sequel::UniqueConstraintViolation => ex
                    echo "A scope named '#{args}' already exists."
                    return
                end
                echo "Created scope '#{scope}'"
            end
        end


        def cmd_scope_delete(args, resend: true)
            unless args =~ VALID_NAME_PATTERN
                echo VALID_NAME_ERROR
                return
            end

            scope = nil
            DB.transaction do
                scope = Scope[lower_name: args.downcase]
                unless scope
                    echo "Scope '#{args}' not found!"
                    return
                end
                ngroups = scope.highlight_groups.count
                nstrings = HighlightGroup.where(scope_id: scope.id).association_inner_join(:highlight_strings).count
                used_by = scope.characters.map{|x| "#{x.game}-#{x.name}"}
                resend &&= scope.characters.include?(@character)

                msg = [TEXT_LINE]
                msg << "Scope '#{scope.name}' contains #{nstrings} string(s) within #{ngroups} highlight group(s)."
                if used_by.length > 0
                    msg << "Scope '#{scope.name}' is used by the following character(s):"
                    msg << "    #{used_by.sort.join(', ')}"
                else
                    msg << "Scope '#{scope.name}' is not currently used by any characters."
                end

                msg << ''
                msg << "#{monsterbold_start}WARNING: Deleting this scope will delete all groups from this scope, and all highlights that are in those groups.#{monsterbold_end}"
                msg << "#{monsterbold_start}WARNING: Other than restoring a database backup, this action is irreversible!#{monsterbold_end}"
                msg << ''
                msg << "To delete this scope anyways, unpause this script."
                msg << TEXT_LINE
                _respond msg
            end
            pause_script

            scope.destroy
            echo "Scope #{scope.name} deleted."
            @character.send_highlights if resend
        end


        def cmd_scope_order(args)
            DB.transaction do
                if args
                    scopenames = args.split(/[\s+;,]+/)
                    scopes = {}
                    scopenames.each do |name|
                        lower = name.downcase
                        if scopes[lower]
                            echo "Cannot specify scopes multiple times; scope '#{scopes[lower].name}' was specified more than once."
                            return
                        end
                        scope = Scope[lower_name: lower]
                        unless scope
                            echo "Scope '#{name}' not found!"
                            return
                        end
                        scopes[lower] = scope
                    end

                    @character.remove_all_scopes
                    priority = 0
                    scopes.values.each do |scope|
                        priority += 100
                        @character.add_character_scope(scope: scope, priority: priority)
                    end
                    @character.refresh
                    @character.send_highlights
                end

                my_scopes = @character.scopes.map(&:name).join(', ')
                msg = []
                msg << "The following scopes are currently active for character #{@character.name}:"
                msg << "    #{my_scopes}"
                respond msg
            end
        end


        def cmd_scope_list(args, resend: true)
            my_scopes = @character.scopes
            scope_set = Set.new(my_scopes.map(&:id))
            all_scopes = Scope.order(:name).map{|scope|
                next scope.name unless scope_set.include?(scope.id)
                next "*" + scope.name
            }.join(', ')
            local_scope = my_scopes[-1].name
            my_scopes = my_scopes.map(&:name).join(', ')
            msg = []
            msg << "The following scopes are currently active for character #{@character.name}:"
            msg << "    #{my_scopes}"
            msg << ''
            msg << "All available scopes:"
            msg << "    #{all_scopes}"
            msg << ''
            if @scope == :auto
                msg << "Commands that require a scope will choose the most relevant scope by default."
            elsif @scope == :local
                msg << "Commands that require a scope will choose the most local scope ('#{local_scope}') by default."
            else
                msg << "Commands that require a scope will choose the '#{@scope}' scope by default."
            end
            msg << "Use #{$lich_char}#{@script.name} SCOPE SET <scope> to change this."

            respond msg
        end


        def cmd_import(args)
            scopes = nil
            scopeset = Set.new
            force = false
            import_none = false

            args.strip.split(/[\s,]+/).each do |name|
                lower = name.downcase
                if lower == 'force'
                    force = true
                elsif lower == 'none'
                    import_none = true
                else
                    unless scopeset.add?(lower)
                        echo "Scope '#{name}' cannot be included more than once."
                        exit
                    end
                    sc = Scope[lower_name: lower]
                    unless sc
                        echo "Scope '#{name}' not found!"
                        exit
                    end
                    scopes ||= []
                    scopes << sc
                end
            end

            warnings = nil

            if import_none
                warnings << '' if warnings
                warnings ||= [TEXT_LINE]
                warnings << "#{monsterbold_start}WARNING: Any highlights currently associated with the current character WILL BE DELETED.#{monsterbold_end}"
                warnings << "After the import is completed, this character will only have highlights associated with the following scopes:"
                if scopes
                    warnings << "    #{scopes.map{|x| x.name}.join(', ')}"
                else
                    warnings << "    GLOBAL, #{XMLData.game}"
                end
            end

            if force
                warnings << '' if warnings
                warnings ||= ['-'*40]
                warnings << "#{monsterbold_start}WARNING: If this character has been previously imported, the previous copy will be deleted.#{monsterbold_end}"
                warnings << "Highlights in the following scope will also be deleted, if any:"
                warnings << "    #{XMLData.game}-#{XMLData.name}"
            end

            if warnings
                warnings << ''
                warnings << "To continue with this import anyways, unpause this script."
                warnings << TEXT_LINE
                _respond warnings
                pause_script
            end

            import(force: force, import_none: import_none, scopes: scopes)
        end

        def cmd_backup(args)
            cmd, args = args.split(/\s+/, 2)
            cmd.downcase!

            case cmd
            when 'create'
                cmd_backup_create(args)
            when 'list'
                cmd_backup_list(args)
            when 'restore'
                cmd_backup_restore(args)
            when 'del', 'delete'
                cmd_backup_delete(args)
            when 'db', 'database'
                echo "TODO: Database backups are not yet implemented."  # TODO: Database backups are not implemented.
            end
        end

        def cmd_group(args)
            cmd, args = args.split(/\s+/, 2)
            cmd.downcase!

            case cmd
            when 'add'
                cmd_group_add(args)
            when 'del', 'delete'
                cmd_group_delete(args)
            when 'set'
                cmd_group_set(args)
            when 'move'
                cmd_group_move(args)
            when 'copy'
                cmd_group_copy(args)
            when 'clone'
                cmd_group_clone(args)
            when 'info'
                cmd_group_info(args)
            when 'list'
                cmd_group_list(args)
            end
        end

        def cmd_add(args)
            args.strip!
            unless args
                echo "Usage: #{$lich_char}#{@script.name} add GROUP TEXT"
                echo "   or: #{$lich_char}#{@script.name} add GROUP [ATTRIBUTES;] TEXT"
                return
            end
            groupattrs, string = args.split(';', 2)
            group, attrstring = groupattrs.split(/\s+/, 2)

            if string
                attrs = parse_attrstring(attrstring, false)
                return unless attrs
                if attrs[:name]
                    string = attrs[:name]
                    attrs.delete(:name)
                end
            else
                string = attrstring
                attrstring = nil
                attrs = nil
            end

            string.strip!
            unless string
                echo "A highlight string must be specified."
                return
            end


            begin
                DB.transaction do
                    scope, group, name = scoped_group(group, exists: true)
                    return unless group

                    string = HighlightString.new(highlight_group: group, highlight_group_id: group.id, text: string)
                    apply_attrs(attrs, string) if attrs
                    string.save
                    @character.send_highlights
                    echo "Created string '#{string.name}' in '#{group.path}'."
                end
            rescue Sequel::UniqueConstraintViolation
                echo "A string '#{string.name}' already exists in group '#{group.path}'."
            end
            # cmd_group_set(attrstring) if attrs
        end


        def parse_pattern(pattern)
            begin
                match = /^\/(.+)\/(.*)$/.match(pattern)
                if match
                    options = 0
                    options |= Regexp::IGNORECASE if match[2].include?('i')
                    options |= Regexp::EXTENDED if match[2].include?('x')
                    return Regexp.new(match[1], options)
                end

                chunks = pattern.split(/\*+/).map!{|x| Regexp.escape(x)}
                if chunks[-1] then
                    postfix = '$'
                else
                    chunks.delete_at(-1)
                    postfix = ''
                end
                if chunks[0] then
                    prefix = '^'
                else
                    chunks.delete_at(0)
                    prefix = ''
                end
                return Regexp.new(prefix + chunks.join('.*') + postfix, Regexp::IGNORECASE)
            rescue RegexpError => ex
                echo "Invalid pattern: #{ex}"
                return nil
            end
        end


        def parse_like(pattern)
            pattern = pattern.gsub(/\*+/, '%')
            return pattern.gsub('\\', '\\\\')
        end


        def cmd_list(args)
            args.strip!
            unless args
                echo "A group name must be specified."
                return
            end
            name, pattern = args.split(/\s+/, 2)
            scope, group, name = scoped_group(name, exists: true)

            pattern = parse_like(pattern)
            echo pattern.inspect

            condition = Sequel[{highlight_group_id: group.id}]
            if pattern
                condition &= Sequel.like(:text, pattern)
            end
            strings = HighlightString.where(condition).order(Sequel[:text]).all()

            unless strings.count
                respond "No matches found in group #{group.path}."
                return
            end

            msg = []
            if strings.count == 1
                msg << "One match found in group #{group.path}:"
            else
                msg << "#{strings.count} matches found in group #{group.path}:"
            end
            msg << ""
            strings.each do |string|
                msg << "    #{string.text}"
            end
            msg << ""
            _respond msg
        end


        def cmd_delete(args, resend: true)
            args.strip!
            args, group = parse_optional_group(args)
            return unless args
            args.strip!
            if args.empty?
                echo "A pattern name must be specified."
            end

            # query = (
            #     CharacterScope.where({Sequel[:character_scopes][:character_id] => @character.id})
            #     .association_inner_join(scope: {highlight_groups: :highlight_strings})
            #     .where(Sequel.like(Sequel[:highlight_strings][:text], parse_like(args)))
            #     .select_all(:highlight_strings)
            #     .select_append(
            #         Sequel[:scope][:name].as('scope_name'),
            #         Sequel[:highlight_groups][:name].as('group_name')
            #     )
            # )
            query = (
                HighlightString
                .association_inner_join(highlight_group: {scope: :character_scopes})
                .where({ Sequel[:character_scopes][:character_id] => @character.id })
                .where(Sequel.like(Sequel[:highlight_strings][:text], parse_like(args)))
                .select_all(:highlight_strings)
                .select_append(
                    Sequel[:scope][:name].as('scope_name'),
                    Sequel[:highlight_group][:name].as('group_name')
                )
            )
            if group
                query = query.where({Sequel[:highlight_groups][:id] => group.id})
            end
            delete_statement = HighlightString.where(
                id: query.select(Sequel[:highlight_strings][:id])
            )

            strings = query.all()
            if strings.count == 0
                location = group && group.path || "any active scopes"
                echo "No strings were found matching the pattern in #{location}."
            elsif strings.count == 1  # No confirmation if deleting just one.
                string = strings[0]
                @character.send_highlights if resend
                echo "Deleted \"#{string.text}\" from #{string[:scope_name]}/#{string[:group_name]}"
                delete_statement.delete
            else
                location = group && group.path || "all active scopes"
                msg = ["Found #{strings.count} highlights in #{location}:"]
                msg << ""
                strings.each {|string|
                    if group
                        msg << "    #{string.text}"
                    else
                        msg << "    #{string.text}  (in #{string[:scope_name]}/#{string[:group_name]})"
                    end
                }
                msg << ""
                msg << "#{monsterbold_start}Found multiple highlight strings.#{monsterbold_end}"
                msg << ''
                msg << "If you want to delete all #{strings.count} strings listed above, unpause this script.  Otherwise, kill this script."
                _respond msg
                pause_script
                @character.send_highlights if resend
                echo "Deleted #{delete_statement.delete} highlight string(s)"
            end
        end
        

        def cmd_group_add(args)
            unless args
                echo "A group name must be specified."
                return
            end
            name, attrstring = args.split(/\s+/, 2)

            if attrstring
                attrs = parse_attrstring(attrstring)
                if attrs[:name]
                    name = attrs[:name]
                    attrs.delete(:name)
                end
            else
                attrs = {}
            end
            attrs[:type] ||= 'string'

            begin
                DB.transaction do
                    scope, group, name = scoped_group(name, exists: false)
                    return unless scope
                    if group
                        echo "Group '#{group.path}' already exists."
                        return
                    end
                    group = HighlightGroup.new(scope: scope, name: name)
                    apply_attrs(attrs, group) if attrs
                    group.save
                    echo "Created group '#{group.path}'."
                end
            rescue Sequel::UniqueConstraintViolation
                echo "A group named '#{name}' already exists in scope '#{scope.name}'."
            end
            # cmd_group_set(attrstring) if attrs
        end

        def parse_bool(what)
            if what =~ /^\d+$/
                what = what.to_i
                return what != 0
            end
            return false if what =~ /^(?:off|n|no|f|false)$/i
            return true if what =~ /^(?:on|y|yes|t|true)$/i
            return nil
        end

        def check_bool(value, field=nil)
            b = parse_bool(value)
            if b.nil?
                if field
                    echo "Invalid boolean value for #{field}: '#{value}'.  Try on/off/true/false/yes/no/t/f/y/n."
                else
                    echo "Invalid boolean value: '#{value}'.  Try on/off/true/false/yes/no/t/f/y/n."
                end
            end
            return b
        end


        def parse_attrstring(attrstring, is_group=nil)
            # Parse attributes
            attrmap = {
                'fg' => :color,
                'color' => :color,
                'bg' => :bgcolor,
                'bgcolor' => :bgcolor,
                'word' => :partial_word,
                'partial' => :partial_word,
                'partial_word' => :partial_word,
                'partialword' => :partial_word,
                'line' => :entire_line,
                'entire_line' => :entire_line,
                'entireline' => :entire_line,
                'case' => :ignore_case,
                'ignorecase' => :ignore_case,
                'ignore' => :ignore_case,
                'ignore_case' => :ignore_case,
                'text' => :name,
                'name' => :name,
                'string' => :name,
                'comment' => :comment,
                'type' => :type,
                'policy' => :merge_policy,
                'merge' => :merge_policy,
                'merge_policy' => :merge_policy,
            }
            attrs = {}

            remaining = attrstring
            while remaining
                unless remaining =~ /^(\w+)=((.+?)(?:\s+(\w+=.*))?)$/
                    echo "Unable to parse attributes: '#{remaining}'"
                    return nil
                end

                key = $1.downcase
                sym = attrmap[key]
                unless sym
                    echo "Unknown attribute '#{key}'"
                    return nil
                end
                if attrs.include?(sym)
                    echo "Attribute '#{key}' specified more than once."
                    return nil
                end

                if sym == :name or sym == :comment
                    value = $2
                    remaining = nil
                else
                    value = $3
                    remaining = $4
                end

                if sym == :color or sym == :bgcolor
                    value.upcase!
                    if value == 'NONE' or value == 'TRANSPARENT' or value == 'INHERIT'
                        attrs[sym] = nil
                        next
                    elsif value =~ /^#?([0-9A-F]{3}|[0-9A-F]{6})$/
                        if $1.length == 3
                            attrs[sym] = "##{$1[0]}#{$1[0]}#{$1[1]}#{$1[1]}#{$1[2]}#{$1[2]}"
                        else
                            attrs[sym] = "##{$1}"
                        end
                    else
                        echo "Invalid #{key}: '#{value}'"
                        return nil
                    end
                elsif sym == :partial_word or sym == :entire_line or sym == :ignore_case
                    value = check_bool(value, key)
                    return nil if value.nil?  # check_bool already outputs an error for us.
                    attrs[sym] = value
                elsif sym == :name
                    value.strip!
                    if value == ''
                        echo "A #{key} must be specified."
                        return nil
                    end
                    if is_group and value !~ VALID_NAME_PATTERN
                        echo VALID_NAME_ERROR
                        return nil
                    end
                    attrs[sym] = value
                elsif sym == :comment
                    if is_group
                        echo "Groups do not support comment fields."
                        return nil
                    end
                    value.strip!
                    value = nil if value == ''
                    attrs[sym] = value
                elsif sym == :type
                    value.downcase!
                    if 'ignores'.start_with?(value)
                        value = 'ignore'
                    elsif 'strings'.start_with?(value)
                        value = 'string'
                    elsif 'names'.start_with?(value)
                        value = 'name'
                    elsif 'inherit'.start_with?(value) or 'clear'.start_with?(value) or 'none'.start_with?(value) or 'default'.start_with?(value)
                        if is_group
                            echo "The default type of a group cannot be changed."
                            return nil
                        else
                            value = nil
                        end
                    else
                        echo "Unknown type: '#{value}'"
                        return nil
                    end
                    attrs[sym] = value
                elsif sym == :merge_policy
                    if is_group == false
                        echo "Highlight strings do not support merge policies."
                        return nil
                    end
                    value.downcase!
                    if value == ''
                        echo 'Value for merge policy cannot be blank.'
                        return nil
                    elsif value =~ /^\d+$/
                        value = value.to_i
                        unless value >= 0 or value <= 3
                            echo "Merge policy must be a number between 0 and 3 or one of 'none', 'replace', 'alter' or 'mimic'."
                            return nil
                        end
                    else
                        new_value = nil
                        HighlightGroup::MERGE_POLICY_NAMES.each_with_index do |name, ix|
                            if name.start_with?(value)
                                new_value = ix
                                break
                            end
                        end
                        if new_value.nil?
                            echo "Merge policy must be one of 'none', 'replace', 'alter', or 'mimic'"
                            return nil
                        end
                        value = new_value
                    end
                    attrs[sym] = value
                elsif sym == :sound
                    value = nil if value =~ /^none$|^off$/i
                    attrs[sym] = value
                end
            end
            return attrs
        end


        def apply_attrs(attrs, target, quiet=false)
            is_string = target.is_a?(HighlightString)
            if is_string
                group = target.highlight_group
            else
                group = target
            end

            attrs.each do |attr, value|
                if attr == :color
                    if is_string and target.color.nil? and target.bgcolor.nil?
                        target.bgcolor = group.bgcolor
                    end
                    target.color = value
                    next if quiet
                    if value
                        echo "Color set to #{value}"
                    else
                        echo "Color cleared."
                    end
                elsif attr == :bgcolor
                    if is_string and target.color.nil?
                        target.color = group.color
                    end
                    target.bgcolor = value
                    next if quiet
                    if value
                        echo "Background color set to #{value}."
                    else
                        echo "Background color set to transparent."
                    end
                elsif attr == :partial_word or attr == :entire_line or attr == :ignore_case
                    target[attr] = value
                    next if quiet
                    attrname = attr.to_s.gsub('_', ' ').capitalize
                    if value.nil?
                        echo "#{attrname} unset."
                    elsif value
                        echo "#{attrname} enabled."
                    else
                        echo "#{attrname} disabled."
                    end
                elsif attr == :type
                    target.type = value
                    next if quiet
                    if value
                        echo "Type set to #{value}."
                    else
                        echo "Type unset."
                    end
                elsif attr == :name
                    target.name = value
                    next if quiet
                    if is_string
                        echo "Text set to \"#{value}\"."
                    else
                        echo "Renamed to \"#{value}\"."
                    end
                elsif attr == :comment
                    target.comment = value
                    next if quiet
                    if value
                        echo "Comment set to \"#{value}\"."
                    else
                        echo "Comment cleared."
                    end
                elsif attr == :sound
                    target[attr] = value
                    next if quiet
                    if value
                        echo "Sound set to \"#{value}\"."
                        Win32::Sound.stop
                        Win32::Sound.play(target.sound, Win32::Sound::ASYNC)
                    else
                        echo "Sound cleared."
                    end
                elsif attr == :merge_policy
                    target.merge_policy_enum = value
                    next if quiet
                    echo "Merge policy set to #{HighlightGroup::MERGE_POLICY_NAMES[value]}."
                end
            end

            return target
        end


        def cmd_group_delete(args, resend: true)
            name, unused = args.split(/\s+/, 2)
            group = nil
            DB.transaction do
                scope, group, name = scoped_group(name, exists: true)
                return unless group
                used_by = scope.characters.map{|x| "#{x.game}-#{x.name}"}
                echo scope.characters.inspect
                resend &&= scope.characters.include?(@character)
                nstrings = HighlightString.where(highlight_group_id: group.id).count
    
                msg = [TEXT_LINE]
                msg << "Group '#{group.path}' contains #{nstrings} string(s)."
                if used_by.length > 0
                    msg << "It is used by the following character(s):"
                    msg << "    #{used_by.sort.join(', ')}"
                else
                    msg << "It is not not currently used by any characters."
                end
    
                msg << ''
                msg << "#{monsterbold_start}WARNING: Deleting this group will remove all #{nstrings} highlight(s) within it.#{monsterbold_end}"
                msg << "#{monsterbold_start}WARNING: Other than restoring a database backup, this action is irreversible!#{monsterbold_end}"
                msg << ''
                msg << "To delete this group anyways, unpause this script."
                msg << TEXT_LINE
                _respond msg
            end
            pause_script
            group.destroy
            echo "Group #{group.path} deleted."
            @character.send_highlights if resend 
        end


        def cmd_group_set(args)
            name, attrstring = args.split(/\s+/, 2)

            unless attrstring
                echo "A group name and attributes must be specified."
                return
            end

            attrs = parse_attrstring(attrstring)
            return unless attrs
            if attrs.length == 0
                echo "Nothing to do!"
                return nil
            end

            DB.transaction do
                scope, group, name = scoped_group(name, exists: true)
                return unless group

                if attrs[:name]
                    begin
                        group.name = attrs[:name]
                        group.save
                    rescue Sequel::UniqueConstraintViolation
                        echo "A group named '#{attrs[:name]}' already exists in scope '#{scope.name}'."
                        raise Sequel::Rollback
                    end
                end
                apply_attrs(attrs, group)
                group.save
                echo "Group '#{group.path}' updated."
                @character.send_highlights
            end
        end


        def cmd_backup_create(args)
            backup = @sfsettings.create_backup(args)
            echo "Current settings backed up to #{backup.filename}"
        end

        def cmd_backup_restore(args)
            unless args
                echo "A backup to restore must be specified."
            end
            if args =~ /^full\s+(.+)$/
                full = true
                args = $1
            else
                full = false
            end

            backup = @sfsettings.restore_backup(args, full)
            echo "Restored backup '#{backup.filename}'"
        end

        def cmd_backup_delete(args)
            unless args
                echo "A backup to delete must be specified."
            end

            backup = @sfsettings.delete_backup(args)
            echo "Deleted '#{backup.filename}'"
            echo
        end

        def cmd_backup_list(args)
            backups = @sfsettings.backups
            backups.reverse!

            unless backups.length > 0
                msg = ["No backups exist for this character"]
            else
                date_format = "%Y-%m-%d %H:%M:%S"
                date_width = Time.now.strftime(date_format).length
                msg = ["#{backups.count} backup(s) exist for this character: "]
                msg << ''
                msg << "#{'Date/Time'.ljust(date_width)}  Name"
                msg << "#{'-'*date_width}  #{'-'*40}"
                backups.each do |x|
                    msg << "#{x.mtime.strftime(date_format)}  #{x.name}"
                end
            end
            msg << ''
            msg << "Stormfront settings are located at: #{@sfsettings.dirname}"
            msg << " This character's settings file is: #{@sfsettings.filename}"
            msg << ''
            msg << " Create backups with: `#{@scriptname} BACKUP CREATE [<name>]`"
            msg << "Restore backups with: `#{@scriptname} BACKUP RESTORE [FULL] <name>`"
            msg << " Delete backups with: `#{@scriptname} BACKUP DELETE <name>`"
            respond msg
        end

        def cmd_resend(args)
            ch = get_character
            unless ch
                msg = []
                msg << "This character has not yet been imported into Stormsync."
                msg << "To import #{XMLData.name} into Stormsync, type: "
                msg << "    #{$lich_char}#{@script.name} import"
                respond msg
                return
            end
            ch.send_highlights
        end

        def scoped_group(name, exists: true)
            name = name[1..-1] if name[0] == '@'  # Strip leading @
            scope_name, group_name = name.split(/[\/\\]/, 2)
            unless group_name
                group_name = scope_name
                scope_name = @scope
            end

            scope_lower = scope_name.downcase
            group_lower = group_name.downcase
            if scope_lower == 'auto'
                scope_name == :auto
            elsif scope_lower == 'local' or scope_lower == '.'
                scope_name == :local
            end
            scope_name = :local if scope_name == :auto and !exists

            if scope_name == :auto
                @character.scopes.reverse.each do |scope|
                    group = HighlightGroup[scope_id: scope.id, lower_name: group_lower]
                    return scope, group, group_name if group
                end
                echo "Group '#{group_name}' not found in any current scopes."
                return nil
            elsif scope_name == :local
                scope = @character.scopes[-1]
                group = HighlightGroup[scope_id: scope.id, lower_name: group_lower]
                echo "Group '#{scope.name}/#{group_name}' not found." unless (group || !exists)
                return scope, group, group_name
            else
                scope = Scope[lower_name: scope_lower]
                unless scope
                    echo "Scope '#{scope_name}' not found."
                    return nil
                end
                group = scope.highlight_groups[lower_name: group_lower]
                echo "Group '#{scope.name}/#{group_name}' not found." unless (group || !exists)
                return scope, group, group_name
            end
        end


        def parse_optional_group(args)
            args = args.strip
            if args[0] == '@'
                group, args = args.split(/\s+/, 2)
                scope, group, group_name = scoped_group(group, exists: true)
                return nil unless group
                return args, group
            else
                return args, nil
            end
        end


        def send_help_formatted(msg)
            msg = REXML::Text.new(msg, respect_whitespace: true).to_s
            msg.gsub!(/\*\*(.*?)\*\*/, '<preset id="whisper">\1</preset>')
            msg.gsub!(/`(.*?)`/, '<preset id="speech">\1</preset>')
            msg.gsub!(/!!(.*?)!!/, '<pushBold />\1<popBold />')
            msg.gsub!("#{name} help", "</preset><d cmd=\"#{name} help\">#{name} help</d><preset id=\"whisper\">")
            _respond "<output class=\"mono\" />\n#{msg}\n<output class=\"\" />"
        end


        def send(what)
            if $frontend == 'stormfront'
                return _respond(what)
            end

            unless what.is_a?(Array)
                what = [what]
            end

            return _respond what.map{|line|
                if line =~ /^\s*<\/?output[^>]*>$/
                    nil
                else
                    line = line.gsub(/<preset.*?>(.*?)<\/preset>/, "\\1")
                    line.gsub!('<pushBold/>', monsterbold_start)
                    line.gsub!('<popBold/>', monsterbold_end)
                    line.gsub!(/<\/?d.*?>/, '')
                    line
                end
            }.keep_if{|x| x}
        end


        def show_changelog
            prev = Settings[:current_version] || 0

            changelog = {
                1 => [
                    "Version 0.0.1-PREVIEW changes:",
                    '',
                    "  * Initial PREVIEW release, with actual dragons.",
                ],
                2 => [
                    "Version 0.0.2-PREVIEW changes:",
                    '',
                    "  * Fix several issues with merging groups",
                    "  * Implemented ;stormsync delete, ;stormsync list, and ;stormsync group delete",
                    "  * Tried to relearn how to Ruby, GTK, and Sequel"
                ],
            }

            if prev != VERSION_INT
                msg = []
                msg << "<preset id='speech'>--------------------</preset>"
                msg << "<preset id='speech'>Welcome to #{$lich_char}#{@script.name}</preset> <preset id='whisper'>#{VERSION}</preset>"
                msg << ''
                changelog.each do |version, notes|
                    if version > prev or version == VERSION_INT
                        msg << "<preset id='whisper'>#{notes[0]}</preset>"
                        msg += notes[1..-1]
                        msg << ''
                    end
                end
                msg << '<output class="mono" />'
                msg << "For a more detailed changelog: <d>#{$lich_char}repo info #{@script.name}</d>."
                msg << "To enable automatic updates:   <d>#{$lich_char}repo set-updatable #{@script.name}</d>`."
                # msg << "For details on new features:   <d>#{$lich_char}#{@script.name} help</d>"
                # msg << "                   or visit:   #{HELP_URL}"
                msg << "For more LostRanger scripts:   https://bit.ly/lostranger-scripts"
                msg << '<output class="" />'
                msg << ''
                msg << "This message will only be displayed once unless a new version is downloaded."
                msg << "<preset id='speech'>--------------------</preset>"
                send msg
                Settings[:current_version] = VERSION_INT
                sleep 1.5
            end
        end


        def run(script)
            @script = script
            @scriptname = $lich_char + script.name
            @scope = :auto
            @character = get_character
            @sfsettings = SFSettings.new

            unless Settings[:dragon_level] == VERSION_INT
                _respond(
                    '<output class="mono"/>',
                    "#{monsterbold_start}*-*-*-*  EXPERIMENTAL PREVIEW!  EXPERIMENTAL PREVIEW!  EXPERIMENTAL PREVIEW! *-*-*-*#{monsterbold_end}",
                    "WARNING: This version of StormSync contains actual dragons.  Usage of this script is not for the faint of heart.",
                    "While there is a backup mechanism, loss of StormFront settings MAY occur.",
                    "Also, GUI crashes tend to take out the entire Ruby instance, so you may get disconnected without warning.",
                    "READ ALL THE REPO INFO.  IT IS IMPORTANT.",
                    "A VERSION OF LICH WITH GTK3 IS (PRACTICALLY) REQUIRED.",
                    "",
                    "STORING YOUR SETTINGS ON THE SERVER IS NOT SUPPORTED WITH STORMSYNC.",
                    "#{monsterbold_start}*-*-*-*  EXPERIMENTAL PREVIEW!  EXPERIMENTAL PREVIEW!  EXPERIMENTAL PREVIEW! *-*-*-*#{monsterbold_end}",
                    '<output class=""/>'
                )

                if @script.vars[0].strip.downcase == 'dragons'
                    echo "Your dragon has advanced to level #{VERSION_INT}!  World domination is soon to follow!"
                    Settings[:dragon_level] = VERSION_INT
                else
                    echo "You MUST read through #{$lich_char}repos info #{@script.name} before using StormSync."
                    echo "Instructions on how to continue past this warning are included there."
                    exit
                end
            end

            show_changelog

            unless Settings[:ui_version] == UI_VERSION
                echo "Updating StormSync UI file, one moment..."
                Script.run("repository", {force: true, quiet: true, args: 'download stormsync.glade'})
                Settings[:ui_version] = UI_VERSION
            end


            cmd, args = @script.vars[0].strip.split(/\s+/, 2)

            unless cmd
                gui = GUI.new
                before_dying { @character.send_highlights }
                gui.start
            end

            case cmd.downcase
            when 'import'
                cmd_import(args)
            when 'scope'
                cmd_scope(args)
            when 'backup'
                cmd_backup(args)
            when 'group'
                cmd_group(args)
            when 'resend'
                cmd_resend(args)
            when 'add'
                cmd_add(args)
            when 'list'
                cmd_list(args)
            when 'del', 'delete'
                cmd_delete(args)
            when '_image'
                msg = ["IMAGE_ATLAS = ("]
                chunks = []
                File.open("#{SCRIPT_DIR}/ssy-atlas.png", File::RDONLY | File::BINARY) do |f|
                    contents = f.read
                    b64 = [contents].pack('m0')
                    l = b64.length
                    echo b64.inspect

                    n = 0
                    while n < b64.length
                        chunks << b64[n..(n+79)].inspect
                        n += 80
                    end
                    msg << "\n\t#{chunks.join(" + \n\t")}"
                end
                respond "IMAGE_ATLAS = (\n\t#{chunks.join(" + \n\t")}\n)"
            end
        end
    end

    class GUI < Gtk::Builder
        module Fields
            # Global to everything
            ID = 0
            ENTITY = 1
            NAME = 2
            COLOR = 3
            BGCOLOR = 4

            SORT_COLOR = 5
            ICON_TRANSPARENT = 6

            SORT_SOUND = 7
            ICON_SOUND = 8

            SORT_IGNORE_CASE = 9
            ICON_IGNORE_CASE = 10

            SORT_ENTIRE_LINE = 11
            ICON_ENTIRE_LINE = 12

            SORT_PARTIAL_WORD = 13
            ICON_PARTIAL_WORD = 14

            CREATED = 15
            UPDATED = 16
            ORIGIN = 17
            TYPE = 18

            TOOLTIP = 19

            DELETED = 20

            # Groups only
            MERGE_POLICY_SORT = 21
            MERGE_POLICY_TEXT = 22

            # Strings only
            SORT_DIFF = 21
            ICON_DIFF = 22
            COMMENT = 23
            TYPE_WEIGHT = 24

            CORE_MODEL_TYPES = [
                Integer,   # ID       0
                Object,    # Entity   1
                String,    # Name     2
                String,    # Color    3
                String,    # BGColor  4

                String,                # Color sort key         5
                GdkPixbuf::Pixbuf,     # Transparency icon      6

                String,                # Sound sort key         7
                GdkPixbuf::Pixbuf,     # Sound icon             8

                Integer,               # Case sensitive sort key    9
                GdkPixbuf::Pixbuf,     # Case sensitive icon        10

                Integer,               # Entire line sort key       11
                GdkPixbuf::Pixbuf,     # Entire line icon           12

                Integer,               # Partial word sort key      13
                GdkPixbuf::Pixbuf,     # Partial word icon          14

                String,                # Creation timestamp (...)   15
                String,                # Modified timestamp (...)   16
                String,                # Origin info                17
                String,                # Type                       18
                String,                # Tooltip                    19
                TrueClass,             # Deleted                    20
            ]

            GROUP_MODEL_TYPES = CORE_MODEL_TYPES + [
                Integer,    # Merge policy sort     21
                String,     # Merge policy text     22
            ]

            STRING_MODEL_TYPES = CORE_MODEL_TYPES + [
                TrueClass,             # Diffs sort key       21
                GdkPixbuf::Pixbuf,     # Diffs icon           22
                String,                # Comment              23
                Integer                # Font weight          24
            ]
        end


        FLAG_SORTABILITY = {}
        FLAG_SORTABILITY[false] = 0
        FLAG_SORTABILITY[nil] = 1
        FLAG_SORTABILITY[true] = 2


        BOOLEAN_LOOKUP = {
            true => '<b>Yes</b>',
            false => 'No',
            nil => '<i>unset</i>'
        }


        def refresh_characters(clear: true)
            gtkq do
                next if @refreshing
                begin
                    @refreshing = true
                    menu = self["ssyMWMenuCharacterList"]
                    # Wipe out old character menu
                    @character_menu_entries.each(&:destroy)
                    @character_menu_entries.clear

                    # Produce new character menu and character model
                    group = nil
                    iter_to_select = nil
                     .clear

                    Character.order(:game, :name).each_with_index do |character, ix|
                        item = Gtk::RadioMenuItem.new(group, character.qualified_name) # group: group, label: character.qualified_name)
                        group ||= item.group
                        item.active = (character.id == @selected_character.id)
                        item.signal_connect('activate', character) {|_, ch| select_character(ch)}
                        @character_menu_entries << ix
                        menu.insert(item, ix)
                        item.visible = true

                        iter = @character_model.append
                        iter[0] = character
                        iter[1] = character.qualified_name
                        iter_to_select = iter if (character.id == @selected_character.id)
                    end
                    # echo iter_to_select.inspect
                    # echo @selected_character.inspect
                    # echo self["ssyMSCharacters"].inspect
                    self["ssyMSCharacters"].active_iter = iter_to_select
                ensure
                    @refreshing = false
                    refresh_scopes(clear: clear)
                end
            end
        end


        def refresh_scopes(clear: true)
            gtkq do
                next if @refreshing
                begin
                    @refreshing = true
                    @active_scope_model.clear
                    @inactive_scope_model.clear
                    @selected_scope = nil
                    @selected_group = nil
                    @selected_string = nil
                    update_editor

                    if @selected_character
                        my_scopes = @selected_character.scopes
                        my_scopes.each do |scope|
                            row = @active_scope_model.append
                            row[0] = scope
                            row[1] = scope.name
                            # row.set_value(0, scope.id)
                            # row.set_value(1, scope.name)
                        end
                        scope_set = Set.new(my_scopes.map(&:id))
                    else
                        scope_set = Set.new
                    end

                    Scope.order(:name).each do |scope|
                        next if scope_set.include?(scope.id)
                        row = @inactive_scope_model.append
                        row[0] = scope
                        row[1] = scope.name
                    end
                ensure
                    @refreshing = false
                    refresh_groups
                    self["ssyMWGroups"].selection.unselect_all if clear
                end
            end
        end


        def readable_color(against, default='#000000', threshold=0.5)
            if against and against =~ /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$|^#?([0-9a-fA-F])([0-9a-fA-F])(09-9a-fA-F])$/
                if $1
                    r = $1.to_i(16)/255.0
                    g = $2.to_i(16)/255.0
                    b = $3.to_i(16)/255.0
                else
                    r = $4.to_i(16)/15.0
                    g = $5.to_i(16)/15.0
                    b = $6.to_i(16)/15.0
                end
                brightness = 0.299*r + 0.587*g + 0.114*b
                return '#000000' if brightness > threshold
                return '#ffffff'
            else
                return default
            end
        end


        def escape_xml(input)
            input = input.gsub('<', '&lt;')
            input.gsub!('>', '&gt;')
            return input
        end


        def update_current_row
            return update_string_row(@selected_string) if @selected_string
            return update_group_row(@selected_group)
        end


        def update_string_row(row)
            return update_highlight_row(row, @selected_group[Fields::ENTITY], row[Fields::ENTITY])
        end


        def update_group_row(row)
            return update_highlight_row(row, row[Fields::ENTITY])
        end


        def update_highlight_row(row, group, string=nil)
            has_diffs = false
            entity = (string || group)
            row[Fields::ID] = (entity.id || 0)
            row[Fields::ENTITY] = entity
            row[Fields::NAME] = entity.name || (string && '<new string>') || '<new group>'

            tooltip = []

            if string.color
                has_diffs = true
                fg = string.color
                bg = string.bgcolor
                # row[19] = true
            else
                fg = group.color
                bg = group.bgcolor
            end

            row[Fields::COLOR] = (fg or '#ffffff')

            if bg
                row[Fields::BGCOLOR] = bg
                row[Fields::ICON_TRANSPARENT] = nil
            else
                row[Fields::BGCOLOR] = readable_color(fg)
                row[Fields::ICON_TRANSPARENT] = @atlas_images[:transparent]
            end

            # color sort
            row[Fields::SORT_COLOR] = "#{bg or ''}-#{fg or ''}"

            # Sound
            row[Fields::ICON_SOUND] = @atlas_images[:sound] if entity.sound
            row[Fields::SORT_SOUND] = entity.sound

            if string.ignore_case.nil?
                ignore_case = group.ignore_case
            else
                ignore_case = entity.ignore_case
                has_diffs = true
            end

            if string.entire_line.nil?
                entire_line = group.entire_line
            else
                entire_line = entity.entire_line
                has_diffs = true
            end

            if string.partial_word.nil?
                partial_word = group.partial_word
            else
                partial_word = entity.partial_word
                has_diffs = true
            end

            # Ignore Case
            row[Fields::ICON_IGNORE_CASE] = @atlas_images[:ignore_case][entity.ignore_case]
            row[Fields::SORT_IGNORE_CASE] = FLAG_SORTABILITY[entity.ignore_case]

            # Entire Line
            row[Fields::ICON_ENTIRE_LINE] = @atlas_images[:entire_line][entity.entire_line]
            row[Fields::SORT_ENTIRE_LINE] = FLAG_SORTABILITY[entity.entire_line]

            # Partial Word
            row[Fields::ICON_PARTIAL_WORD] = @atlas_images[:partial_word][entity.partial_word]
            row[Fields::SORT_PARTIAL_WORD] = FLAG_SORTABILITY[entity.partial_word]

            # Type
            row[Fields::TYPE] = entity.type || '<unset>'
            if string.type
                row[Fields::TYPE_WEIGHT] = Pango::Weight::BOLD
                has_diffs = true
            else
                row[Fields::TYPE_WEIGHT] = Pango::Weight::NORMAL if string
            end

            # Dates and origin
            row[Fields::CREATED] = entity.created_ts.to_s
            row[Fields::UPDATED] = entity.updated_ts.to_s
            row[Fields::ORIGIN] = entity.origin

            # Deleted status
            row[Fields::DELETED] = !(entity.is_active)

            if string
                # String only fields
                row[Fields::ICON_DIFF] = has_diffs && @atlas_images[:diff] || nil
                row[Fields::SORT_DIFF] = has_diffs
                row[Fields::COMMENT] = entity.comment
            else
                # Group only fields
                row[Fields::MERGE_POLICY_SORT] = group.merge_policy_enum
                row[Fields::MERGE_POLICY_TEXT] = HighlightGroup::MERGE_POLICY_NAMES[group.merge_policy_enum] || 'UNKNOWN'
            end

            tooltip << "#{string && 'String' || 'Group'} ##{entity.id} \"#{escape_xml(entity.name)}\""
            tooltip << "Comment: #{escape_xml(string.comment)}" if string && string.comment && string.comment != ''
            # tooltip << "#{string && 'String' || 'Group'} ##{entity.id}"
            if entity.created_ts == entity.updated_ts
                tooltip << "Created at #{entity.created_ts.to_s}, never updated"
            else
                tooltip << "Created at #{entity.created_ts.to_s}, updated at #{entity.updated_ts.to_s}"
            end
            row[Fields::TOOLTIP] = tooltip.join("\n")

            return row
        end


        def refresh_groups(clear: true)
            gtkq do
                begin
                    include_deleted = self["ssyMWMenuShowDeleted"].active?
                    select_group(nil)
                    @refreshing = true
                    @group_model.clear
                    # @selected_group = nil
                    # @selected_group = nil

                    menu = self["ssyMenuGroupContextMoveTo"]
                    menu.each(&:destroy)
                    next unless @selected_scope

                    @active_scope_model.each do |_, _, iter|
                        item = Gtk::MenuItem.new(label: iter[1])
                        item.sensitive = (iter != @selected_scope)
                        item.signal_connect('activate', iter[0]) do |item, scope|
                            next unless @selected_group
                            try_move_group(@selected_group, @selected_group[Fields::ENTITY].name, scope)
                        end
                        menu.append(item)
                    end
                    menu.show_all

                    @selected_scope[0].reload
                    @selected_scope[0].highlight_groups.each do |group|
                        next unless include_deleted || group.is_active
                        row = @group_model.append
                        update_highlight_row(row, group)
                    end
                ensure
                    @refreshing = false
                    refresh_strings
                    self["ssyMWStrings"].selection.unselect_all if clear
                end
            end
        end


        def refresh_strings(clear: true)
            gtkq do
                begin
                    include_deleted = self["ssyMWMenuShowDeleted"].active?
                    select_string(nil)
                    @refreshing = true
                    group = @selected_group[Fields::ENTITY]
                    @string_model.clear
                    @selected_string = nil
                    next unless group

                    group.highlight_strings.each do |string|
                        next unless include_deleted || string.is_active
                        row = @string_model.append
                        update_highlight_row(row, group, string)
                    end
                ensure
                    @refreshing = false
                end
            end
        end
        #
        # def hsl_to_rgb(h, s, l)
        #     # Ported from https://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion
        #     l = l.to_f
        #     return '#ffffff' if l == 1.0
        #     return '#000000' if l == 0.0
        #
        #     s = s.to_f
        #     if s == 0.0
        #         r = g = b = (l*255).round
        #     else
        #         def hue_to_rgb(p, q, t)
        #             t += 1.0 if t < 0.0
        #             t -= 1.0 if t > 1.0
        #             # echo "t=#{t}"
        #             return p + (q - p) * 6.0 * t if t < 1.0/6.0
        #             return q if t < 0.5
        #             return p + (q - p) * (2.0/3.0 - t) * 6.0 if t < 2.0/3.0
        #             return p
        #         end
        #
        #         h = h.to_f
        #
        #         if l < 0.5
        #             q = l * (1.0+s)
        #         else
        #             q = (l+s) - (l*s)
        #         end
        #         p = 2.0 * l - q
        #         # echo "h=#{h}"
        #         r = hue_to_rgb(p, q, h + (1/3.0))
        #         g = hue_to_rgb(p, q, h)
        #         b = hue_to_rgb(p, q, h - (1/3.0))
        #
        #         r = (r*255).round
        #         g = (g*255).round
        #         b = (b*255).round
        #     end
        #
        #     return ('%02x%02x%02x' % [r, g, b])
        # end

        def update_colors
            css = [
                "* { background-image: none; border-radius: 0px; border: 0px; padding: 0px; margin: 2px; min-width: 20px; min-height: 20px; }",
                "*:hover { box-shadow: inherit; text-shadow: inherit; border-color: #ffffff; }",
                # "#default { background-color: #000000; color: #c0c0c0; }",
                "#transparent { background-color: #000000; color: #c0c0c0; }"
            ]
            @css_colors.each_with_index{|color, ix| css << "\#color#{ix} { background-color: #{color}; }" }
            @css[:colorgrid].load(data: css.join)
            update_color_selections
        end


        def update_color_selections
            gtkq do
                iter = (@selected_string || @selected_group)
                entity = (iter && iter[Fields::ENTITY]) || nil

                @color_buttons_state.each_with_index do |prev, ix|
                    color = @css_colors[ix]
                    # echo color
                    css = nil
                    if entity
                        if entity.color == color
                            css = @css[:selected_fg]
                        elsif entity.bgcolor == color
                            css = @css[:selected_bg]
                        end
                    end
                    if css != prev
                        # echo "Prev: #{prev.inspect} -- New: #{css.inspect}"
                        @color_buttons[ix].style_context.remove_provider(prev) if prev
                        @color_buttons[ix].style_context.add_provider(css) if css
                        @color_buttons_state[ix] = css
                    end
                end

                c = self["ssyMWColorDefault"].style_context
                if entity.color.nil?
                    self["ssyMWColorDefault"].style_context.add_provider(@css[:selected_fg])
                    self["ssyMWColorTransparent"].style_context.remove_provider(@css[:selected_bg])
                elsif entity.bgcolor.nil?
                    self["ssyMWColorDefault"].style_context.remove_provider(@css[:selected_fg])
                    self["ssyMWColorTransparent"].style_context.add_provider(@css[:selected_bg])
                else
                    self["ssyMWColorDefault"].style_context.remove_provider(@css[:selected_fg])
                    self["ssyMWColorTransparent"].style_context.remove_provider(@css[:selected_bg])
                end
            end
        end


        def apply_color(color, bg)
            gtkq do
                iter = (@selected_string || @selected_group)
                next unless iter
                entity = (iter && iter[Fields::ENTITY]) || nil
                next unless entity

                group = (@selected_group && @selected_group[Fields::ENTITY]) || nil
                string = (@selected_string && @selected_string[Fields::ENTITY]) || nil

                mainq_exclusive do
                    if bg
                        # Background Color
                        entity.color = group.color if string and entity.color.nil?
                        entity.bgcolor = color
                    else entity
                        entity.bgcolor = group.bgcolor if string and entity.color.nil?
                        entity.color = color
                    end
                    entity.save if entity.id  # Don't commit an unsaved group.
                end

                # update_highlight_row(iter, group, string)
                update_current_row
                update_editor
                # update_highlight_row(iter, group, string)

                unless string
                    @string_model.each do |_, _, siter|
                        update_highlight_row(siter, group, siter[Fields::ENTITY])
                    end
                end
                update_color_selections
            end
        end


        def popup_error_dialog(message, title="Error", parent=nil)
            parent ||= self["ssyMainWindow"]
            dialog = Gtk::MessageDialog.new(
                :title => title,
                :parent => nil,
                :flags => :destroy_with_parent,
                :type => :error,
                :buttons => :close,
                :message => message
            )
            dialog.run
            dialog.destroy
        end


        def init_colorgrid
            update_colors
            colorgrid = self["ssyMWColorGrid"]
            # echo colorgrid.inspect
            self["ssyMWColorTransparent"].style_context.add_provider(@css[:colorgrid])
            self["ssyMWColorDefault"].style_context.add_provider(@css[:colorgrid])


            ix = 0
            7.times do |r|
                ((r < 5 && 24) || 16).times do |c|
                    button = Gtk::Button.new
                    @color_buttons << button
                    @color_buttons_state << nil
                    button.relief = Gtk::RELIEF_NONE
                    button.style_context.add_provider(@css[:colorgrid])
                    button.name = "color#{ix}"
                    colorgrid.attach(button, c, r, 1, 1)


                    button.signal_connect('button-press-event', ix) do |who, event, ix|
                        Gtk.queue do
                            if event.state == Gdk::Window::CONTROL_MASK || event.button == 2 || event.event_type == Gdk::Event::BUTTON2_PRESS
                                # EDIT
                                color_picker(@css_colors[ix]) do |color|
                                    Gtk.queue do
                                        next unless color
                                        @css_colors[ix] = color
                                        update_colors
                                    end
                                end
                                #
                                # self["ssyCPPicker"].rgba = Gdk::RGBA.parse(@css_colors[ix])
                                # self["ssyCPTransparent"].visible = false
                                # self["ssyColorPicker"].show_all
                            end

                            bg = (event.state == Gdk::Window::SHIFT_MASK || event.button == 3)

                            self.apply_color(@css_colors[ix], bg)
                        end
                    end

                    button.has_tooltip = true
                    button.signal_connect('query-tooltip', ix) do |widget, x, y, keyboard_tip, tooltip, ix|
                        tooltip.text = @css_colors[ix]
                        next true
                    end

                    ix += 1
                end
            end
        end


        def color_picker(color, transparent: false, default: false, &block)
            @edit_color_proc = block
            color ||= '#000000'  # So transparent will default to black, the most common background color...
            # The color picker seems to be a little 'sticky'
            # If it was previously initialized with one color, and then changed, future attempts to initialize it with
            # that same color will pull the earlier color instead.  It only seems to apply for the most recent color.
            # This is an attempt to unstick it, and looks wrong as a result.
            self["ssyCPPicker"].rgba = Gdk::RGBA.parse('#000000')
            self["ssyCPPicker"].rgba = Gdk::RGBA.parse('#111111')
            self["ssyCPPicker"].rgba = Gdk::RGBA.parse(color)

            self["ssyCPTransparent"].visible = transparent
            self["ssyCPDefault"].visible = default
            self["ssyColorPicker"].show_all
        end


        def on_transparent_clicked(*unused)
            gtkq do
                self.apply_color(nil, true)  # Transparency
            end
        end


        def on_default_clicked(*unused)
            return unless @selected_string
            gtkq do
                @selected_string[Fields::ENTITY].color = nil
                @selected_string[Fields::ENTITY].bgcolor = nil
                update_string_row(@selected_string)
                # self.update_highlight_row(@selected_string, @selected_group[Fields::ENTITY], @selected_string[Fields::ENTITY])
                update_color_selections
            end
        end


        def mainq(&block)
            if Thread.current == @main_thread
                block.call
            else
                @main_thread_queue << block
            end
        end


        def mainq_exclusive(&block)
            future = Future.new
            mainq do
                future.execute(&block)
            end
            return future.value
        end


        def gtkq_exclusive(&block)
            if Thread.current == @gtk_thread
                return gtkq(&block)
            end
            future = Future.new
            gtkq do
                future.value = block.call
            end
            return future.value
        end


        def gtkq(&block)
            begin
                if Thread.current == @gtk_thread
                    begin
                        block.call
                    rescue
                        respond "error in Gtk.queue: #{$!}\n\t#{$!.backtrace.join("\n\t")}"
                    rescue SyntaxError
                        respond "error in Gtk.queue: #{$!}\n\t#{$!.backtrace.join("\n\t")}"
                    rescue SystemExit
                        nil
                    rescue SecurityError
                        respond "error in Gtk.queue: #{$!}\n\t#{$!.backtrace.join("\n\t")}"
                    rescue ThreadError
                        respond "error in Gtk.queue: #{$!}\n\t#{$!.backtrace.join("\n\t")}"
                    rescue SystemStackError
                        respond "error in Gtk.queue: #{$!}\n\t#{$!.backtrace.join("\n\t")}"
                    rescue Exception
                        respond "error in Gtk.queue: #{$!}\n\t#{$!.backtrace.join("\n\t")}"
                    rescue ScriptError
                        respond "error in Gtk.queue: #{$!}\n\t#{$!.backtrace.join("\n\t")}"
                    rescue LoadError
                        respond "error in Gtk.queue: #{$!}\n\t#{$!.backtrace.join("\n\t")}"
                    rescue NoMemoryError
                        respond "error in Gtk.queue: #{$!}\n\t#{$!.backtrace.join("\n\t")}"
                    rescue
                        respond "error in Gtk.queue: #{$!}\n\t#{$!.backtrace.join("\n\t")}"
                    end
                else
                    Gtk.queue(&block)
                end
            end
        end


        def init_css
            gtkq do
                @css[:colorgrid] = Gtk::CssProvider.new
                @css[:selected_fg] = t = Gtk::CssProvider.new
                t.load(data: "* { border: 2px solid #ffff00; margin: 0px; }")
                @css[:selected_bg] = t = Gtk::CssProvider.new
                t.load(data: "* { border: 2px solid #3333ff; margin: 0px; }")

                @css[:editor_colors] = t = Gtk::CssProvider.new
                self["ssyMWEditColor"].style_context.add_provider(t)
                self["ssyMWEditBGColor"].style_context.add_provider(t)
            end
        end


        def init_atlas
            gtkq do
                atlas = GdkPixbuf::PixbufLoader.new("image/png")
                atlas.write(StormSync::IMAGE_ATLAS.unpack('m*')[0])
                atlas.close
                atlas = atlas.pixbuf
                # echo "Atlas: #{atlas.inspect}"

                [:ignore_case, :entire_line, :partial_word].each_with_index do |sym, ix|
                    @atlas_images[sym] = {
                        false => nil,
                        nil => atlas.subpixbuf(ix*48 + 24, 0, 24, 24),
                        true => atlas.subpixbuf(ix*48 + 0, 0, 24, 24),
                        # true => atlas,
                    }
                end
                @atlas_images[:transparent] = atlas.subpixbuf(6*24, 0, 24, 24)
                @atlas_images[:sound]       = atlas.subpixbuf(7*24, 0, 24, 24)
                @atlas_images[:diff]        = atlas.subpixbuf(8*24, 0, 24, 24)
            end
        end


        def select_character(character)
            gtkq do
                character.reload
                next if character == @selected_character
                @selected_character = character
                self["ssyMainWindow"].title = "StormSync - #{character.qualified_name}"

                @character_model.each do |_, _, iter|
                    if iter[0].id == character.id
                        @refreshing = true
                        self["ssyMSCharacters"].active_iter = iter
                        @refreshing = false
                        break
                    end
                end

                refresh_scopes
            end
            return true
        end


        def select_scope(iter)
            gtkq do
                next if @refreshing
                select_group(nil)
                self["ssyMWCreateGroup"].sensitive = (iter != nil)
                # echo "select_scope"
                next if @selected_scope == iter
                @selected_scope = iter
                @selected_scope[0].refresh
                refresh_groups
                # select_string(nil)
            end
            return true
        end


        def should_remove_iter(iter)
            return false unless iter
            entity = iter[Fields::ENTITY]
            # echo entity.inspect
            return true if entity.id.nil?
            return false if entity.is_active
            return !self["ssyMWMenuShowDeleted"].active?
        end


        def select_group(iter)
            # echo "Select group: #{iter[Fields::ID]} #{iter[Fields::NAME]}  "
            gtkq do
                next if @refreshing
                entity = iter && iter[Fields::ENTITY]
                self["ssyMWCreateString"].sensitive = self["ssyMWDeleteGroup"].sensitive = (entity && entity.is_active) || false
                self["ssyMWUndeleteGroup"].sensitive = (entity && !entity.is_active) || false
                unless iter == @selected_group
                    @refreshing = true
                    @group_model.remove(@selected_group) if should_remove_iter(@selected_group)
                    @refreshing = false
                    @selected_group = iter
                    @selected_group[Fields::ENTITY].refresh if @selected_group[Fields::ENTITY].id
                    refresh_strings
                    update_color_selections
                end
                select_string(nil)
            end
            return true
        end


        def select_string(iter)
            gtkq do
                next if @refreshing
                entity = iter && iter[Fields::ENTITY]
                self["ssyMWDeleteString"].sensitive = (iter != nil)
                if iter == nil
                    @selected_string = nil
                    update_editor
                end
                next if @selected_string == iter
                @refreshing = true
                @string_model.remove(@selected_string) if should_remove_iter(@selected_string)
                @refreshing = false
                @selected_string = iter
                update_editor
            end
            return true
        end


        def update_editor
            gtkq do
                next if @editor_updating
                begin
                    @editor_updating = true
                    iter = @selected_string || @selected_group
                    entity = (iter && iter[Fields::ENTITY]) || nil
                    is_string = (@selected_string && true) || false
                    group = @selected_group[Fields::ENTITY]

                    self["ssyMWEditor"].sensitive = (iter && true) || false
                    self["ssyMWEditStringLabel"].label = is_string && "String:" || "Group:"
                    self["ssyMWEditMergePolicy"].visible = !is_string
                    self["ssyMWEditMergePolicyLabel"].visible = !is_string
                    self["ssyMWEditComment"].visible = is_string
                    self["ssyMWEditCommentLabel"].visible = is_string

                    unless iter
                        self["ssyMWEditString"].buffer.text = ''
                        self["ssyMWEditComment"].buffer.text = ''
                        self["ssyMWEditLine"].each{|c| c.markup = '<i>Unset</i>'}
                        self["ssyMWEditCase"].each{|c| c.markup = '<i>Unset</i>'}
                        self["ssyMWEditWord"].each{|c| c.markup = '<i>Unset</i>'}
                        self["ssyMWEditSound"].unselect_all
                        # self["ssyMWEditType"].active_iter = @types_entries[nil]
                        self["ssyMWEditType"].active_iter = nil
                        return
                    end

                    unless is_string
                        self["ssyMWEditMergePolicy"].active_iter = @policy_entries[entity.merge_policy_enum]
                    end

                    self["ssyMWEditString"].buffer.text = (entity.name || '')
                    self["ssyMWEditComment"].buffer.text = (entity.comment || '') if is_string
                    self["ssyMWEditLine"].each{|c| c.markup = BOOLEAN_LOOKUP[entity.entire_line]}
                    self["ssyMWEditCase"].each{|c| c.markup = BOOLEAN_LOOKUP[entity.ignore_case]}
                    self["ssyMWEditWord"].each{|c| c.markup = BOOLEAN_LOOKUP[entity.partial_word]}
                    self["ssyMWEditType"].active_iter = @types_entries[entity.type]

                    has_sound = (entity.sound && true) || false
                    if has_sound
                        self["ssyMWEditSound"].filename = entity.sound
                    else
                        self["ssyMWEditSound"].unselect_all
                    end
                    self["ssyMWEditPlaySound"].sensitive = self["ssyMWEditClearSound"].sensitive = has_sound

                    @types_entries[nil][1] = is_string

                    type = entity.type || group.type || 'string'

                    %w(ssyMWEditSoundLabel ssyMWEditSound).each do |ctl|
                        self[ctl].sensitive = (type == 'string')
                    end

                    %w(ssyMWEditLine ssyMWEditLineLabel).each do |ctl|
                        self[ctl].sensitive = (type != 'ignore')
                    end

                    css = ["* { background-image: none; text-shadow: none; }"]
                    if entity.color
                        self["ssyMWEditColor"].label = entity.color
                        self["ssyMWEditBGColor"].label = (entity.bgcolor or 'transparent')
                        readable = readable_color(entity.color)
                        css << "#editor_fg { background-image: none; color: #{readable}; background-color: #{entity.color}; }"

                        if entity.bgcolor
                            readable = readable_color(entity.bgcolor)
                            css << "#editor_bg { background-image: none; color: #{readable}; background-color: #{entity.bgcolor}; }"
                        end
                    else
                        self["ssyMWEditColor"].label = self["ssyMWEditBGColor"].label = 'inherit'
                    end

                    @css[:editor_colors].load(data: css.join("\n"))
                ensure
                    @editor_updating = false
                end
            end
        end


        def update_character_scope_order
            gtkq do
                id = @selected_character.id
                next unless id

                import = []
                priority = 0
                @active_scope_model.each do |_, _, iter|
                    import << [id, iter[0].id, priority += 100]
                end

                DB.transaction do
                    CharacterScope.dataset.where(character_id: id).delete
                    CharacterScope.dataset.import([:character_id, :scope_id, :priority], import)
                end
                @selected_character.reload
                refresh_scopes
            end
        end


        def on_manage_scopes(*unused)
            gtkq do
                self["ssyMWScopes"].selection.unselect_all
                self["ssyManageScopesWindow"].show_all
            end
        end


        def on_ms_doubleclick(widget, event)
            return false unless event.event_type == Gdk::Event::BUTTON2_PRESS
            on_ms_toggle
        end


        def on_ms_toggle(*unused)
            gtkq do
                active = self["ssyMSActiveScopes"].selection.selected
                inactive = self["ssyMSInactiveScopes"].selection.selected

                if active
                    src_model = @active_scope_model
                    src_ctl = self["ssyMWActiveScopes"]
                    dst_model = @inactive_scope_model
                    dst_ctl = self["ssyMWInactiveScopes"]
                    src_iter = active
                elsif inactive
                    src_model = @inactive_scope_model
                    src_ctl = self["ssyMWInactiveScopes"]
                    dst_model = @active_scope_model
                    dst_ctl = self["ssyMWActiveScopes"]
                    src_iter = inactive
                else
                    return
                end

                scope = src_iter[0]
                dst_iter = dst_model.append
                dst_iter[0] = scope
                dst_iter[1] = scope.name
                src_ctl.selection.unselect_all
                src_model.remove(src_iter)
                dst_ctl.selection.select_iter(dst_iter)
            end
        end


        def on_ms_character_changed(widget)
            return if @refreshing
            return unless widget.active_iter
            update_character_scope_order
            select_character(widget.active_iter[0])
        end


        def on_ms_active_changed(widget)
            is_selected = (widget.selected) && true || false
            self["ssyMSRemove"].visible = is_selected
            if is_selected
                self["ssyMSDelete"].sensitive = true
                self["ssyMSInactiveScopes"].selection.unselect_all
            end
        end


        def on_ms_inactive_changed(widget)
            is_selected = (widget.selected) && true || false
            self["ssyMSAdd"].visible = is_selected
            if is_selected
                self["ssyMSDelete"].sensitive = true
                self["ssyMSActiveScopes"].selection.unselect_all
            end
        end


        def on_ms_rename(*unused)
            gtkq do
                iter = self["ssyMSActiveScopes"].selection.selected || self["ssyMSInactiveScopes"].selection.selected
                next unless iter
                scope = iter[0]

                @manage_scope_proc = proc do |newname|
                    begin
                        scope.name = newname
                        scope.save
                        iter[1] = scope.name
                        next true
                    rescue Sequel::UniqueConstraintViolation
                        scope.reload

                        popup_error_dialog(
                            "A scope named '#{newname}' already exists.",
                            "Scope already exists",
                            self["ssyRenameScopeDialog"]
                        )
                        next false
                    end
                end

                self["ssyRSName"].label = scope.name
                self["ssyRSNameConfirm"].buffer.text = scope.name
                self["ssyRenameScopeDialog"].title = "Rename Scope"
                self["ssyRenameScopeDialog"].show_all
                # FIXME: Select all text in the confirm dialog
                self["ssyRSNameConfirm"].grab_focus
            end
        end


        def on_ms_new(*unused)
            gtkq do
                @manage_scope_proc = proc do |newname|
                    begin
                        echo "Creating new scope."
                        # sleep 1
                        scope = Scope.new(name: newname)
                        echo "Saving new scope."
                        # sleep 1
                        scope.save
                        echo "Creating iter."
                        # sleep 1
                        iter = @active_scope_model.append
                        iter[0] = scope
                        iter[1] = scope.name
                        echo "Selecting iter."
                        # sleep 1
                        self["ssyMSActiveScopes"].selection.select_iter(iter)
                        next true
                    rescue Sequel::UniqueConstraintViolation
                        echo "Popping up error dialog."
                        # sleep 1
                        popup_error_dialog(
                            "A scope named '#{newname}' already exists.",
                            "Scope already exists",
                            self["ssyRenameScopeDialog"]
                        )
                        next false
                    rescue => ex
                        respond "error in on_ms_new: #{$!}\n\t#{$!.backtrace.join("\n\t")}"
                    end
                end

                self["ssyRSName"].label = "<new scope>"
                self["ssyRSNameConfirm"].buffer.text = ''
                self["ssyRenameScopeDialog"].title = "New Scope"
                self["ssyRenameScopeDialog"].show_all
                # FIXME: Select all text in the confirm dialog
                self["ssyRSNameConfirm"].grab_focus
            end
        end


        def on_ms_delete(*unused)
            gtkq do
                active = self["ssyMSActiveScopes"].selection.selected
                inactive = self["ssyMSInactiveScopes"].selection.selected

                if active
                    model = @active_scope_model
                    ctl = self["ssyMWActiveScopes"]
                    iter = active
                elsif inactive
                    model = @inactive_scope_model
                    ctl = self["ssyMWInactiveScopes"]
                    iter = inactive
                else
                    next
                end

                next unless iter
                scope = iter[0]

                @manage_scope_proc = proc do |newname|
                    if newname.downcase != scope.name.downcase
                        popup_error_dialog(
                            "The specified name '#{newname}' does not match the scope name of '#{scope.name}'",
                            "Scope name incorrect",
                            self["ssyDeleteScopeDialog"]
                        )
                        next false
                    end



                    ctl.selection.unselect_all
                    model.remove(iter)
                    scope.delete
                end

                self["ssyDSName"].label = scope.name
                self["ssyDSNameConfirm"].buffer.text = ''
                self["ssyDeleteScopeDialog"].show_all
                # FIXME: Select all text in the confirm dialog
                self["ssyDSNameConfirm"].grab_focus
            end
        end


        def on_ds_cancel(*unused)
            self["ssyDeleteScopeDialog"].hide
            return true
        end


        def on_rs_cancel(*unused)
            self["ssyRenameScopeDialog"].hide
            return true
        end


        def on_rs_ok(widget)
            if @manage_scope_proc
                widget.toplevel.hide if @manage_scope_proc.call(self["ssyRSNameConfirm"].buffer.text)
            else
                widget.toplevel.hide
            end
        end


        def on_ds_ok(widget)
            if @manage_scope_proc
                widget.toplevel.hide if @manage_scope_proc.call(self["ssyDSNameConfirm"].buffer.text)
            else
                widget.toplevel.hide
            end
        end


        def on_rs_changed(widget, *unused)
            sensitive = (widget.buffer.text.strip != '')
            self["ssyRSOK"].sensitive = sensitive
            if sensitive
                self["ssyRSOK"].grab_default
            else
                self["ssyRSCancel"].grab_default
            end
        end


        def on_ds_changed(widget, *unused)
            sensitive = (widget.buffer.text.downcase == self["ssyDSName"].label.downcase)
            self["ssyDSOK"].sensitive = sensitive
            if sensitive
                self["ssyDSOK"].grab_default
            else
                self["ssyDSCancel"].grab_default
            end
        end


        def on_ms_close(*unused)
            gtkq do
                update_character_scope_order
                self["ssyMSDelete"].sensitive = false
                self["ssyMSActiveScopes"].selection.unselect_all
                self["ssyMSInactiveScopes"].selection.unselect_all
                self["ssyManageScopesWindow"].hide
            end
            return true
        end


        def on_editor_play_sound(*unused)
            gtkq do
                iter = @selected_string || @selected_group
                next unless iter
                entity = iter[Fields::ENTITY]
                next unless entity.sound
                Win32::Sound.stop
                Win32::Sound.play(entity.sound, Win32::Sound::ASYNC)
            end
        end


        def on_editor_clear_sound(*unused)
            gtkq do
                iter = @selected_string || @selected_group
                next unless iter
                entity = iter[Fields::ENTITY]
                entity.sound = nil
                entity.save if entity.id
                update_current_row
                update_editor
            end
        end


        def on_editor_change_sound(widget)
            gtkq do
                iter = @selected_string || @selected_group
                next unless iter
                entity = iter[Fields::ENTITY]
                entity.sound = widget.filename
                entity.save if entity.id
                update_current_row
                update_editor
            end
        end


        def on_editor_set_name(widget, *unused)
            gtkq do
                next if @editor_updating
                text = widget.buffer.text
                echo "Text is #{text}"
                if @selected_string
                    echo "Selected string is #{@selected_string[Fields::NAME]}"
                    next if text == @selected_string[Fields::NAME]  # No change.
                    try_rename_string(@selected_string, text)
                elsif @selected_group
                    echo "Selected group is #{@selected_group[Fields::NAME]}"
                    next if text == @selected_group[Fields::NAME]  # No change.
                    try_move_group(@selected_group, text)
                end
            end
            return false
        end


        def on_editor_set_comment(widget, *unused)
            gtkq do
                next if @editor_updating
                next unless @selected_string
                text = widget.buffer.text.strip
                entity = @selected_string[Fields::ENTITY]
                next if text == entity.comment
                entity.comment = text
                entity.save if entity.id  # Don't save until we've been named.
                update_string_row(@selected_string)
            end
            return false
        end


        def on_editor_toggle(widget, attr)
            gtkq do
                iter = @selected_string || @selected_group
                next unless iter
                entity = iter[Fields::ENTITY]
                value = entity[attr]

                if value == false
                    # If false, toggle to true
                    value = true
                elsif @selected_string == nil || value == nil
                    # If there's no source string or value is nil, toggle to false
                    value = false
                else
                    # Otherwise, toggle to unset
                    value = nil
                end

                entity[attr] = value
                entity.save if entity.id
                widget.each{|c| c.markup = BOOLEAN_LOOKUP[value]}
                update_current_row
            end
            return true
        end


        def on_editor_toggle_case(widget)
            return on_editor_toggle(widget, :ignore_case)
        end


        def on_editor_toggle_word(widget)
            return on_editor_toggle(widget, :partial_word)
        end


        def on_editor_toggle_line(widget)
            return on_editor_toggle(widget, :entire_line)
        end


        def on_editor_set_color(*unused)
            gtkq do
                iter = @selected_string || @selected_group
                next unless iter
                entity = iter[Fields::ENTITY]
                group = @selected_group[Fields::ENTITY]
                color = (entity.color || group.color) || '#ffffff'
                color_picker(color, default: true) do |color|
                    if color == :default
                        entity.color = entity.bgcolor = nil
                    else
                        entity.bgcolor = group.bgcolor unless entity.color  # May be a noop.
                        entity.color = color
                    end
                    entity.save if entity.id
                    update_current_row
                    update_editor
                end
            end
            return true
        end


        def on_editor_set_bgcolor(*unused)
            gtkq do
                iter = @selected_string || @selected_group
                next unless iter
                entity = iter[Fields::ENTITY]
                group = @selected_group[Fields::ENTITY]
                if entity.color
                    color = entity.bgcolor
                else
                    color = group.bgcolor || '#000000'
                end
                color_picker(color, transparent: true, default: true) do |color|
                    if color === :default
                        entity.color = entity.bgcolor = nil
                    else
                        entity.color = group.color unless entity.color  # May be a noop.
                        entity.bgcolor = color
                    end
                    entity.save if entity.id
                    update_current_row
                    update_editor
                end
            end
            return true
        end


        def on_editor_change_type(widget)
            gtkq do
                next if @editor_updating
                iter = @selected_string || @selected_group
                next unless iter
                entity = iter[Fields::ENTITY]
                type = widget.active_iter[0]
                type = nil if type == ''
                entity.type = type
                entity.save if entity.id
                update_current_row
                update_editor
            end
        end


        def on_editor_change_policy(widget)
            gtkq do
                next if @editor_updating
                iter = @selected_group
                next unless iter
                entity = iter[Fields::ENTITY]
                policy = widget.active_iter[0]
                entity.merge_policy_enum = policy || 0
                entity.save if entity.id
                update_current_row
                update_editor
            end
        end


        def on_create_group(*unused)
            gtkq do
                next unless @selected_scope
                group = HighlightGroup.new(
                    partial_word: false,
                    entire_line: false,
                    ignore_case: false,
                    color: '#ffff00',
                    bgcolor: nil,
                    type: 'string',
                    merge_policy_enum: HighlightGroup::MERGE_POLICY_NONE,
                    scope: @selected_scope[0],
                    scope_id: @selected_scope[0].id
                )
                row = @group_model.append
                path = row.path
                update_highlight_row(row, group)
                self["ssyMWGroups"].selection.select_iter(row)
                self["ssyMWGroups"].scroll_to_cell(path, nil, false, 0.0, 0.0)
                update_editor
                self["ssyMWEditString"].grab_focus
            end
        end


        def on_delete_group(*unused)
            gtkq do
                next unless @selected_group
                entity = @selected_group[Fields::ENTITY]

                if entity.id
                    entity.is_active = nil
                    entity.save
                    update_current_row
                    update_editor
                    select_group(@selected_group)
                else  # Just discard unsaved group
                    self["ssyMWGroups"].selection.unselect_all
                end
            end
        end


        def on_undelete_group(*unused)
            gtkq do
                begin
                    next unless @selected_group
                    entity = @selected_group[Fields::ENTITY]
                    next unless entity.id
                    entity.is_active = true
                    entity.save
                    update_current_row
                    update_editor
                    select_group(@selected_group)
                rescue Sequel::UniqueConstraintViolation
                    # Failed to undelete the group because it already exists in an undeleted state.
                    popup_error_dialog(
                        "Unable to undelete this group because another group already exists with this name.  Try renaming this or the other group first.",
                        "Group already exists"
                    )
                    entity.reload
                end
            end
        end


        def on_create_string(*unused)
            gtkq do
                next unless @selected_group
                next unless @selected_group[Fields::ENTITY].id
                group = @selected_group[Fields::ENTITY]
                string = HighlightString.new(
                    partial_word: nil,
                    entire_line: nil,
                    ignore_case: nil,
                    color: nil,
                    bgcolor: nil,
                    type: nil,
                    highlight_group: group,
                    highlight_group_id: group.id,
                    )
                row = @string_model.append
                path = row.path
                update_highlight_row(row, group, string)
                self["ssyMWStrings"].selection.select_iter(row)
                self["ssyMWStrings"].scroll_to_cell(path, nil, false, 0.0, 0.0)
                update_editor
                self["ssyMWEditString"].grab_focus
            end
        end



        def on_delete_string(*unused)
            gtkq do
                next unless @selected_string
                entity = @selected_string[Fields::ENTITY]

                if entity.id
                    entity.is_active = nil
                    entity.save
                    update_current_row
                    update_editor
                    select_string(@selected_string)
                else  # Just discard unsaved group
                    self["ssyMWGroups"].selection.unselect_all
                end
            end
        end


        def on_undelete_string(*unused)
            gtkq do
                begin
                    next unless @selected_string
                    entity = @selected_string[Fields::ENTITY]
                    next unless entity.id
                    entity.is_active = true
                    entity.save
                    update_current_row
                    update_editor
                    select_string(@selected_string)
                rescue Sequel::UniqueConstraintViolation
                    # Failed to undelete the group because it already exists in an undeleted state.
                    popup_error_dialog(
                        "Unable to undelete this string because another string already exists with the same text.  Try renaming this or the other string first.",
                        "String already exists"
                    )
                    entity.reload
                end
            end
        end


        def on_toggle_wide_mode(widget)
            gtkq do
                box = self["ssyMWMainBox"]
                if widget.active?
                    box.orientation = Gtk::Orientation::HORIZONTAL
                else
                    box.orientation = Gtk::Orientation::VERTICAL
                end
            end
        end


        def on_toggle_deleted_items(widget)
            refresh_groups
        end


        def on_toggle_column_visibility(widget)
            gtkq do
                label = widget.label
                [self["ssyMWGroups"], self["ssyMWStrings"]].each do |treeview|
                    treeview.columns.each do |col|
                        next unless col.title == label
                        col.visible = widget.active?
                        break
                    end
                end
            end
        end

        def on_scope_changed
            refresh_groups
        end


        def on_main_exit(*unused)
            mainq { save_settings; @script.exit }
            return true
        end


        def initialize
            super()

            @script = script = Script.current

            # Figure out what character to initially have selected
            character_to_select = StormSync::get_character
            unless character_to_select
                character_to_select = Character.first
                if character_to_select
                    echo "Your current character is not yet imported into Stormsync.  Selecting a different one."
                else
                    echo "No characters are imported into Stormsync yet.  Try importing one first."
                    exit
                end
            end

            # Figure out what thread the 'main' thread is
            future = Future.new
            Gtk.queue { future.value = Thread.current }
            @gtk_thread = future.value
            @main_thread = Thread.current
            # echo @gtk_thread.inspect
            # echo Thread.current.inspect
            @main_thread_queue = Queue.new

            # Proper cleanup
            before_dying do
                save_settings
                gtkq do
                    %w(
                        ssyMergeGroupsWindow ssyMergeStringsWindow
                        ssySoundFileChooser
                        ssyManageScopesWindow ssyDeleteScopeDialog
                        ssyMainWindow
                    ).each do |ctl|
                        # echo "Destroying #{ctl}..."
                        # sleep 1
                        self[ctl].destroy
                    end
                end
                # n = HighlightString.where(is_active: nil).delete
                # echo "Purged #{n} deleted highlight string(s)"
                # n = HighlightGroup.where(is_active: nil).delete
                # echo "Purged #{n} deleted highlight group(s)"
            end

            # Rest in queue.
            gtkq do
                # Load model and connect signals
                self.add_from_file("#{SCRIPT_DIR}/stormsync.glade")
                self.connect_signals do |handler|
                    # echo handler.inspect
                    begin
                        next method(handler)
                    rescue
                        echo "No method found for handler '#{handler}'"
                        raise
                    end
                end

                #
                # dialog = Gtk::FileChooserNative.new({
                #                                         title: "Select Sound",
                #                                         parent: self["ssyMainWindow"],
                #                                         action: Gtk::FileChooserAction::OPEN,
                #                                         accept_label: "Choose",
                #                                         cancel_label: "Cancel"
                #                                     })

                # dialog = Gtk::FileChooserNative.new("Select Sound", self["ssyMainWindow"], Gtk::FileChooserAction::OPEN, "Choose", "Cancel")
                # self["ssyMWEditSound"].dialog = dialog
                #
                # Initialize class variables.
                @css_colors = DEFAULT_COLORS.dup
                @css = {}
                @selected_character = nil
                @character_menu_entries = []
                @selected_scope = nil
                @selected_group = nil
                @selected_string = nil
                @atlas_images = {}
                @refreshing = false
                @color_buttons = []
                @color_buttons_state = []
                @editor_iter = nil
                @edit_color_proc = nil
                @manage_scope_proc = nil

                @types_model = Gtk::ListStore.new(String, TrueClass, String)
                @types_entries = {}
                ['string', 'name', 'ignore', nil].each do |n|
                    iter = @types_model.append
                    iter[0] = n || ''
                    iter[1] = true
                    iter[2] = (n || '<i>unset</i>')
                    @types_entries[n] = iter
                end

                @policy_model = Gtk::ListStore.new(Integer, String)
                @policy_entries = []
                [
                    '<b>none</b>: No merging.  The groups are treated separately.',
                    '<b>replace parent</b>: The parent group will be replaced by this one; highlights in the parent group are not sent to SF.',
                    '<b>alter parent</b>: Highlights on the parent use the same colors and settings as this group.',
                    '<b>mimic parent</b>: Highlights on this group use the parent\'s colors and settings.',
                ].each_with_index do |name, ix|
                    iter = @policy_model.append
                    iter[0] = ix
                    iter[1] = name
                    @policy_entries << iter
                end

                @character_model = Gtk::ListStore.new(Object, String)
                @active_scope_model = Gtk::ListStore.new(Object, String)
                @inactive_scope_model = Gtk::ListStore.new(Object, String)
                @group_model = Gtk::ListStore.new(*Fields::GROUP_MODEL_TYPES)
                @string_model = Gtk::ListStore.new(*Fields::STRING_MODEL_TYPES)

                init_css
                init_atlas
                init_colorgrid
                load_settings

                select_scope(nil)
                select_group(nil)
                select_string(nil)

                {
                    'ssyMWScopes' => @active_scope_model,
                    'ssyMSActiveScopes' => @active_scope_model,
                    'ssyMSInactiveScopes' => @inactive_scope_model,
                    'ssyMSCharacters' => @character_model,
                    'ssyMWGroups' => @group_model,
                    'ssyMWStrings' => @string_model,
                    'ssyMWEditType' => @types_model,
                    'ssyMWEditMergePolicy' => @policy_model,
                }.each {|ctl, model| self[ctl].set_model(model) }

                refresh_characters
                select_character(character_to_select)

                groups = self["ssyMWGroups"]
                groups.height_request = 100
                #
                self["ssyMWScopes"].selection.signal_connect('changed') do |ctl|
                    select_scope(ctl.selected)
                end

                self["ssyMWGroups"].selection.signal_connect('changed') do |ctl|
                    select_group(ctl.selected)
                end

                self["ssyMWStrings"].selection.signal_connect('changed') do |ctl|
                    select_string(ctl.selected)
                end

                update_editor
            end
        end


        def on_colorpicker_cancel(widget, *unused)
            gtkq do self["ssyColorPicker"].hide end
            return true
        end

    
        def on_colorpicker_transparent(widget)
            gtkq do
                @edit_color_proc.call(nil) if @edit_color_proc
                self["ssyColorPicker"].hide
            end
            return true
        end

    
        def on_colorpicker_apply(widget)
            gtkq do
                rgba = self["ssyCPPicker"].rgba
                color = '#%02x%02x%02x' % [(rgba.red*255).round, (rgba.green*255).round, (rgba.blue*255).round]
                @edit_color_proc.call(color) if @edit_color_proc
                self["ssyColorPicker"].hide
            end
            return true
        end

    
        def on_colorpicker_default(widget)
            gtkq do
                @edit_color_proc.call(:default) if @edit_color_proc
                self["ssyColorPicker"].hide
            end
            return true
        end
    

        def on_rename_group(ctl, path, value)
            # echo "Edited!  New text: #{value}"
            # echo "Path: #{path.inspect}"
            try_move_group(@group_model.get_iter(path), value)
        end


        def on_rename_string(ctl, path, value)
            # echo "Edited!  New text: #{value}"
            # echo "Path: #{path.inspect}"
            try_rename_string(@string_model.get_iter(path), value)
        end


        def on_group_list_button_press(widget, event)
            self["ssyMWStrings"].selection.unselect_all
            return false unless event.kind_of? Gdk::EventButton and event.button == 3
            path = widget.get_path_at_pos(event.x, event.y)[0]
            # echo widget.get_path_at_pos(event.x, event.y).inspect
            # echo path.inspect
            return false unless path
            iter = @group_model.get_iter(path)
            return false unless iter
            widget.selection.select_iter(iter)
            self["ssyMenuGroupContext"].popup(nil, nil, event.button, event.time)
            return true
        end


        def gui_duplicated_setup(*targets, window_id: nil, css_id: nil, prefix: nil, is_group: true, remaining_elements: nil)
            future = Future.new
            @duplicated_gui_future = future
            # echo "window_id: #{window_id} -- css_id: #{css_id} -- prefix: #{prefix}"
            # echo "GUI FUTURE IS: "
            # echo future.inspect
            # sleep 1
            gtkq do
                window = self[window_id]
                # echo window.inspect
                window.sensitive = true

                checkbox = nil
                checkbox = self["#{prefix}ApplyToAll"] unless is_group

                css_provider = @css[css_id]

                unless css_provider  # Cue to do first-time setup.
                    css_provider = Gtk::CssProvider.new
                    self["#{prefix}Color0"].style_context.add_provider(css_provider)
                    self["#{prefix}Color1"].style_context.add_provider(css_provider)
                    self["#{prefix}BGColor0"].style_context.add_provider(css_provider)
                    self["#{prefix}BGColor1"].style_context.add_provider(css_provider)
                    @css[css_id] = css_provider

                    window.signal_connect('delete-event') do
                        self[prefix + "CancelMerge"].signal_emit('clicked')
                        next true
                    end

                    self[prefix + "CancelMerge"].signal_connect('clicked') do
                        window.sensitive = false
                        next if @duplicated_gui_future.done?
                        echo "Trying to set future value."
                        @duplicated_gui_future.value = nil unless @duplicated_gui_future.done?
                        echo "Set future value."
                    end

                    2.times do |ix|
                        self["#{prefix}Keep#{ix}"].signal_connect('clicked', ix) do
                            window.sensitive = false
                            next if @duplicated_gui_future.done?
                            echo "Trying to set future value."
                            @duplicated_gui_future.value = { :keep => ix, :all => (checkbox && checkbox.active?) || false }
                            echo "Set future value."
                        end
                    end
                end

                # echo "window_id: #{window_id} -- css_id: #{css_id} -- prefix: #{prefix}"
                #
                #
                # self[prefix + "CancelMerge"].signal_connect('clicked') do
                #     window.sensitive = false
                #     future.value = nil unless future.done?
                # end

                checkbox = nil
                unless is_group
                    checkbox = self["#{prefix}ApplyToAll"]
                    checkbox.active = false
                    if remaining_elements and remaining_elements > 0
                        checkbox.no_show_all = false
                        checkbox.show

                        label = self["ssyDSApplyToAllLabel"]
                        if remaining_elements == 1
                            label.markup = "Also do this for <b>1 other string</b>"
                        else
                            label.markup = "Also do this for <b>#{remaining_elements} other strings</b>"
                        end
                    else
                        checkbox.no_show_all = true
                        checkbox.hide
                    end
                end

                css = ["* { background: none; text-shadow: none; }\n"]
                targets.each_with_index do |entity, ix|
                    self["#{prefix}Name#{ix}"].label = entity.name
                    self["#{prefix}Type#{ix}"].markup = entity.type || '<i>inherit</i>'
                    self["#{prefix}Case#{ix}"].markup = BOOLEAN_LOOKUP[entity.ignore_case]
                    self["#{prefix}Line#{ix}"].markup = BOOLEAN_LOOKUP[entity.entire_line]
                    self["#{prefix}Word#{ix}"].markup = BOOLEAN_LOOKUP[entity.partial_word]
                    self["#{prefix}Color#{ix}"].markup = entity.color || (is_group && 'unset' || '<i>inherit</i>')
                    self["#{prefix}BGColor#{ix}"].markup = entity.bgcolor || (is_group && 'transparent' || '<i>inherit</i>')

                    if entity.color
                        readable = readable_color(entity.color)
                        css << "#color#{ix} { color: #{readable}; background-color: #{entity.color}; }\n"
                    end
                    if entity.bgcolor
                        readable = readable_color(entity.bgcolor)
                        css << "#bgcolor#{ix} { color: #{readable}; background-color: #{entity.bgcolor}; }\n"
                    end
                    #
                    # button = self["#{prefix}Keep#{ix}"]
                    # button.signal_connect('clicked') do
                    #     window.sensitive = false
                    #     future.value = { :keep => ix, :all => (checkbox && checkbox.active?) || false }
                    # end
                end
                css_provider.load(data: css.join)
                window.show_all
            end
            return future
        end


        def try_rename_string(iter, newname)
            return unless iter
            return if newname.strip == ''
            gtkq do
                # return if newname == ''

                source = iter[Fields::ENTITY]
                oldname = source.name
                # echo source.inspect

                begin
                    source.name = newname
                    source.save
                rescue Sequel::UniqueConstraintViolation => ex
                    source.name = oldname
                    update_editor
                    popup_error_dialog(
                        "Another string in this group already exists with this name.",
                        "String already exists"
                    )
                    return
                end
                source.reload if source.id
                update_editor
                update_string_row(iter)
            end
        end


        def try_move_group(iter, newname, newscope=nil)
            return if @duplicated_gui_future
            return unless iter
            return if newname.strip == ''
            # echo "in try_move_group.  Hopefully we only see this once."
            gtkq do
                source = iter[Fields::ENTITY]
                oldname = source.name
                # echo source.inspect

                oldscope = source.scope
                newscope ||= oldscope
                return unless source

                while true
                    lowname = newname.downcase
                    begin
                        source.name = newname
                        source.scope_id = newscope.id if oldscope.id != newscope.id
                        source.save

                        if oldscope.id != newscope.id
                            if @selected_group == iter
                                @selected_group = nil
                                self["ssyMWGroups"].selection.unselect_all
                                oldscope.reload
                                newscope.reload
                                source.reload
                                refresh_strings
                            end
                            @group_model.remove(iter)  # Group is now part of another scope.
                        else
                            if source.id
                                source.reload
                            else
                                source.name = source.oldname
                            end
                            update_highlight_row(iter, source)
                            update_editor
                        end
                        return
                    rescue Sequel::UniqueConstraintViolation => ex
                        unless source.id
                            source.name = source.oldname
                            update_highlight_row(iter, source)
                            update_editor
                            return
                        end

                        # Find the duplicate
                        dest = HighlightGroup[lower_name: lowname, scope_id: newscope.id]
                        redo unless dest
                        break
                    end
                end
                # If we're still here, we need to resolve merge conflicts.  Fun!  (NOT)
                future = gui_duplicated_setup(
                        source, dest,
                        window_id: "ssyDuplicatedGroupWindow",
                        css_id: :duplicated_groups,
                        prefix: "ssyDG",
                        is_group: true
                )
                # echo "MY FUTURE IS"
                # echo future.inspect
                mainq do
                    begin
                        sleep 1
                        echo "In MainQ, waiting for result"
                        sleep 1
                        result = future.value
                        echo "Result: #{result.inspect}"
                        sleep 1
                        @duplicated_gui_future = nil

                        unless result
                            # Cancelled!
                            source.reload
                            update_editor
                            next
                        end

                        DB.transaction(rollback: :reraise) do
                            # echo result.inspect
                            # sleep 1
                            if result[:keep] == 0
                                dest.name = source.name
                                dest.type_enum = source.type_enum
                                dest.merge_policy_enum = source.merge_policy_enum
                                dest.color = source.color
                                dest.bgcolor = source.bgcolor
                                dest.partial_word = source.partial_word
                                dest.entire_line = source.entire_line
                                dest.ignore_case = source.ignore_case
                                dest.save
                            end

                            # Attempt to merge highlight strings
                            while true
                                # Remove identical-ish strings
                                dupe = DB["
                                    DELETE FROM highlight_strings AS a
                                    WHERE a.highlight_group_id=?
                                    AND EXISTS(
                                        SELECT 1 FROM highlight_strings AS b
                                        WHERE b.highlight_group_id=?
                                        AND a.text = b.text
                                        AND a.color        IS b.color
                                        AND a.bgcolor      IS b.bgcolor
                                        AND a.ignore_case  IS b.ignore_case
                                        AND a.partial_word IS b.partial_word
                                        AND a.sound        IS b.sound
                                        AND a.type_enum    IS b.type_enum
                                        AND a.comment      IS b.comment
                                    )
                               ", source.id, dest.id].delete

                                echo "Had #{dupe} duplicate strings."

                                updated = DB["UPDATE OR IGNORE highlight_strings SET highlight_group_id=?, updated_ts=? WHERE highlight_group_id=?", dest.id, Sequel::CURRENT_TIMESTAMP, source.id].update
                                remaining = DB["SELECT COUNT(*) FROM highlight_strings WHERE highlight_group_id=?", source.id].get

                                echo "Re-parented #{updated} strings, #{remaining} remaining."
                                # sleep 1
                                # sleep 5
                                break if remaining == 0

                                keep_all = nil

                                HighlightString.where_each(highlight_group_id: source.id) do |sstring|
                                    dstring = HighlightString[highlight_group_id: dest.id, text: sstring.text, is_deleted: false]
                                    remaining -= 1
                                    next unless dstring

                                    # echo sstring.inspect
                                    # echo dstring.inspect

                                    future = gui_duplicated_setup(
                                        sstring, dstring,
                                        window_id: "ssyDuplicatedStringWindow",
                                        css_id: :duplicated_strings,
                                        prefix: "ssyDS",
                                        is_group: false,
                                        remaining_elements: remaining
                                    )

                                    result = future.value
                                    # echo result.inspect
                                    # sleep 1

                                    unless result
                                        raise Sequel::Rollback
                                    end

                                    if result[:all]
                                        if result[:keep] == 0
                                            updated = DB["UPDATE OR REPLACE highlight_strings SET highlight_group_id=?, updated_ts=? WHERE highlight_group_id=?", dest.id, Sequel::CURRENT_TIMESTAMP, source.id].update
                                            echo "Overwrote #{updated} highlight strings"
                                            break
                                        else
                                            deleted = DB["DELETE FROM highlight_strings WHERE highlight_group_id=?", source.id].delete
                                            echo "Discarded #{deleted} highlight strings"
                                            break
                                        end
                                    elsif result[:keep] == 0
                                        DB["UPDATE OR REPLACE highlight_strings SET highlight_group_id=?, updated_ts=? WHERE id=?", dest.id, Sequel::CURRENT_TIMESTAMP, sstring.id].update
                                    elsif result[:keep] == 1
                                        DB["DELETE FROM highlight_strings WHERE id=?", sstring.id].delete
                                    end
                                end
                            end
                            # source.delete
                            echo DB["DELETE FROM highlight_groups WHERE id=?", source.id].delete
                            echo "Committing transaction"
                            # raise Sequel::Rollback
                        end  # Commit the transaction
                        # Reload target group


                        # echo "Entering GTK land"
                        # sleep 1
                        # Refresh GTK
                        gtkq do
                            # echo "Removing from model"
                            # sleep 1
                            if newscope == oldscope    # Try to select the merged group instead
                                # echo "Finding new iter"
                                # sleep 1
                                newiter = nil          # But first we have to find it...
                                dest.reload
                                # echo dest.inspect
                                @group_model.each do |_, _, i|
                                    if i[Fields::ENTITY].id == dest.id
                                        newiter = i
                                        echo "Updating highlight row"
                                        sleep 1
                                        update_highlight_row(i, dest)
                                        break
                                    end
                                end
                                # echo "Updating selection"
                                # sleep 1
                                if newiter
                                    self["ssyMWGroups"].selection.select_iter(newiter)
                                else
                                    self["ssyMWGroups"].selection.unselect_all
                                end
                            else
                                # echo "Clearing selection"
                                # sleep 1
                                self["ssyMWGroups"].selection.unselect_all
                            end
                            @group_model.remove(iter)  # Group is gone
                        end
                    rescue Sequel::Rollback
                        source.reload
                    rescue => ex
                        echo ex
                        echo ex.backtrace
                    ensure
                        gtkq do
                            self["ssyDuplicatedGroupWindow"].hide
                            self["ssyDuplicatedStringWindow"].hide
                        end
                    end
                end
            end
        end


        def start
            gtkq do
                self["ssyMainWindow"].show_all
                self["ssyMainWindow"].present
            end

            while (p = @main_thread_queue.pop)
               p.call
            end
        end


        def reset_settings
            # echo "Resetting settings!"
            mainq do
                Settings[:gui_settings] = {
                    :wide_mode => false,
                    :show_deleted => false,
                    :visible_columns => {
                        "ID" => true,
                        "Updated" => true,
                        "Created" => true,
                        "Comment" => true,
                        "Origin" => true
                    },
                    :group_columns => {
                        :widths => nil,
                        :order => ['ID', 'C', 'S', 'Group', 'Type', 'A', 'L', 'P', 'Policy', 'Created', 'Updated', 'Origin'],
                    },
                    :string_columns => {
                        :widths => nil,
                        :order => ['ID', '!', 'C', 'S', 'Group', 'Type', 'A', 'L', 'P', 'Comment', 'Created', 'Updated', 'Origin'],
                    }
                }
            end
        end


        def load_settings
            settings = nil
            mainq do
                reset_settings unless Settings[:gui_settings]
                settings = Settings[:gui_settings]

                gtkq do
                    settings[:colors] ||= DEFAULT_COLORS
                    @css_colors = settings[:colors].dup
                    self["ssyMWMenuWideMode"].active = (settings[:wide_mode] || false)
                    self["ssyMWMenuShowDeleted"].active = (settings[:show_deleted] || false)
                    on_toggle_wide_mode(self["ssyMWMenuWideMode"])
                    visible = settings[:visible_columns]
                    [["ssyMWGroups", :group_columns], ["ssyMWStrings", :string_columns]].each do |ctl, key|
                        ctl = self[ctl]
                        columns = {}
                        widths = settings[key][:widths]
                        ctl.columns.each do |col|
                            title = col.title
                            columns[title] = col
                            col.visible = (visible[title] != false)  # Allow true and nil both to count for visibility
                            col.fixed_width = widths[title] if (widths && widths[title] && widths[title] > 0)
                        end

                        prev = nil
                        settings[key][:order].each do |title|
                            this = columns[title]
                            next unless this
                            ctl.move_column_after(this, prev)
                            prev = this
                        end
                    end

                    self["ssyMWMenuColumnList"].each do |submenu|
                        submenu.active = (visible[submenu.label] != false)
                    end

                    update_colors
                end
            end
        end


        def save_settings
            mainq do
                reset_settings unless Settings[:gui_settings]
                settings = Settings[:gui_settings]

                gtkq_exclusive do
                    self["ssyMWMenuColumnList"].each do |submenu|
                        settings[:visible_columns][submenu.label] = submenu.active?
                    end
                    settings[:wide_mode] = self["ssyMWMenuWideMode"].active?
                    settings[:show_deleted] = self["ssyMWMenuShowDeleted"].active?

                    [["ssyMWGroups", :group_columns], ["ssyMWStrings", :string_columns]].each do |ctl, key|
                        ctl = self[ctl]
                        widths = {}
                        order = []
                        ctl.columns.each do |col|
                            title = col.title
                            order << title
                            widths[title] = col.fixed_width if col.fixed_width > 0
                        end
                        settings[key][:widths] = widths
                        settings[key][:order] = order
                    end

                    settings[:colors] = @css_colors.dup
                end

                Settings[:gui_settings] = settings
                # echo Settings[:gui_settings].inspect
            end
            # echo "Saving settings..."
            # echo future.value.inspect
        end


        def on_restricted_edit(widget, text, bytes, position)
            if text.gsub!(StormSync::INVALID_NAME_CHARACTERS, '')
                widget.signal_emit_stop('insert-text')
                widget.signal_emit('insert-text', text, text.length, position) if text != ''
                return true
            end
            return false
        end


        def on_partially_restricted_edit(*args)
            return false if @selected_string
            return on_restricted_edit(*args)
        end


        def on_group_name_cell_editing_started(renderer, editable, path)
            editable.signal_connect('insert-text') {|*args| next on_restricted_edit(*args)}
            # editable.signal_connect('insert-text', &:on_restricted_edit)
            # echo editable.inspect
            return false
        end
    end
end


StormSync.run(script)
