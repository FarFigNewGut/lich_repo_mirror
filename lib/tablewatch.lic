# Handle command line arguments
if defined?(Script) && Script.current && Script.current.vars
  case Script.current.vars[0].to_s.downcase
  when 'help', '-h', '--help'
    respond <<~HELP
      
      Tablewatch - Simple Table Protection Script
      
      USAGE:
        ;tablewatch          Start monitoring your table
        ;tablewatch help     Show this help message
        ;tablewatch test     Run diagnostic tests of all functions
      
      WHAT IT DOES:
        - Blocks the EXIT command while your table is deployed
        - Tracks which room you deployed your table in
        - Warns when you leave the table room behind
        - Reminds you every 5 minutes if you stay away
        - Automatically shuts down when you TINKER to pack the table
        - Restores normal exit functionality when done
      
      HOW TO USE:
        1. Deploy your table in a room
        2. Start the script: ;tablewatch
        3. Script blocks exit and tracks your location
        4. When done, TINKER your table to pack it up
        5. Script automatically removes exit blocking
      
      TIP:
        I recommend adding an alias like:
        ;alias add prod my basket=fput "prod my basket"; start_script("tablewatch")
        This will make sure to start the script whenever you turn your 
        basket into a table.
      
      ALERTS:
        - Visual warning when you leave the table room
        - Audio beep to get your attention  
        - Speech window notification for visibility
        - Repeated reminders every 5 minutes while away
        - Timer warnings every 15 minutes
        - Critical warning at 15 minutes remaining
      
      The script prevents accidental logouts while your valuable table
      is deployed, ensuring you don't lose it by exiting carelessly.
      
    HELP
    exit
  when 'test', 'diagnostic'
    # Run diagnostic tests
    echo "=== TABLEWATCH DIAGNOSTIC TEST ==="
    echo "Testing all script functions without real timers..."
    echo ""
    
    # Test 1: Exit alias installation
    echo "Test 1: Exit alias installation"
    test_alias = 'echo "TEST: Exit command blocked by tablewatch diagnostic"'
    do_client(";alias add --global exit=;e #{test_alias}")
    echo "- Exit alias installed (test version)"
    echo "- Try typing 'exit' to test blocking"
    sleep 2
    
    # Test 2: Location warning simulation
    echo ""
    echo "Test 2: Location warning simulation"
    warning_msg = "WARNING: You left your table behind in room 12345!"
    echo warning_msg
    if defined?(Lich) && defined?(Lich::Messaging)
      Lich::Messaging.stream_window(warning_msg, "speech")
    end
    print "\a"
    echo "- Location warning displayed with audio beep and speech window"
    sleep 2
    
    # Test 3: Timer reminders
    echo ""
    echo "Test 3: Timer reminder simulation"
    echo "Table timer: 75 minutes remaining"
    sleep 1
    echo "Table timer: 30 minutes remaining" 
    sleep 1
    critical_msg = "WARNING: Only 15 minutes left on table! HUG your table now or it will disappear!"
    echo critical_msg
    if defined?(Lich) && defined?(Lich::Messaging)
      Lich::Messaging.stream_window(critical_msg, "speech")
    end
    print "\a"
    echo "- Timer warnings displayed including critical 15-minute alert"
    sleep 2
    
    # Test 4: HUG reset simulation
    echo ""
    echo "Test 4: HUG reset simulation"
    echo "Table timer reset to 120 minutes by HUG"
    echo "- HUG detection and timer reset confirmed"
    sleep 2
    
    # Test 5: Table packing simulation
    echo ""
    echo "Test 5: Table packing simulation"
    echo "Table packed! Shutting down..."
    echo "- Table packing detection confirmed"
    sleep 1
    
    # Test 6: Cleanup
    echo ""
    echo "Test 6: Cleanup and exit alias removal"
    do_client(";alias delete --global exit")
    echo "Exit blocking removed. You can now exit normally."
    echo "- Cleanup completed successfully"
    
    echo ""
    echo "=== DIAGNOSTIC COMPLETE ==="
    echo "All tablewatch functions tested successfully!"
    echo "The script is ready for normal use."
    echo "Start with: ;tablewatch"
    exit
  end
end

# Simple Tablewatch Script
# Blocks exit command while table is deployed, auto-removes when table is packed

VERSION = "1.0"

class SimpleTablewatch
  def initialize
    @table_room = Room.current.id if defined?(Room) && Room.current
    @current_room = @table_room
    @away_from_table = false
    @last_reminder_time = Time.now
    @table_start_time = Time.now
    @last_timer_reminder = Time.now
    @critical_warning_given = false
    @shutting_down = false
    
    # Set global reference
    $tablewatch_active = true
    $tablewatch_room = @table_room
    
    setup_exit_alias
    setup_table_detection
    
    echo "Started. Table deployed in room #{@table_room}"
    echo "Exit command blocked until table is packed"
    echo "Table timer: 120 minutes remaining"
  end

  def setup_exit_alias
    # Simple alias that blocks exit if tablewatch is active
    alias_cmd = 'if $tablewatch_active; echo "Exit blocked - table still deployed in room #{$tablewatch_room}! TINKER table to pack it up first."; else; exit; end'
    
    do_client(";alias add --global exit=;e #{alias_cmd}")
    echo "Exit blocking alias installed"
  end

  def setup_table_detection
    # Simple downstream hook to detect table packing and HUG resets
    hook_proc = proc { |line|
      if line && line =~ /you trigger the transformation|you pick the basket up|table.*folds.*into.*basket/i
        echo "Table packed! Shutting down..."
        shutdown
      elsif line && line =~ /you (?:nudge|hug).*table.*(?:refreshing|reset).*120\s+minutes/i
        echo "Table timer reset to 120 minutes by HUG"
        @table_start_time = Time.now
        @last_timer_reminder = Time.now
        @critical_warning_given = false  # Reset critical warning flag
      end
      line
    }
    
    DownstreamHook.add('simple_tablewatch', hook_proc)
  end

  def shutdown
    return if @shutting_down
    @shutting_down = true
    
    # Remove exit alias
    do_client(";alias delete --global exit")
    
    # Remove hook
    DownstreamHook.remove('simple_tablewatch')
    
    # Clear globals
    $tablewatch_active = false
    $tablewatch_room = nil
    
    echo "Exit blocking removed. You can now exit normally."
    # Don't call exit here - just let the script end naturally
  end

  def run
    # Simple monitoring loop with location checks and timer reminders
    while !@shutting_down
      check_location
      check_timer_reminder
      sleep 5
    end
  rescue Interrupt
    shutdown
  end

  def check_timer_reminder
    remaining_minutes = calculate_remaining_time
    
    # Special warning at 15 minutes remaining (only once until reset by HUG)
    if remaining_minutes <= 15 && !@critical_warning_given
      warning_msg = "WARNING: Only 15 minutes left on table! HUG your table now or it will disappear!"
      echo warning_msg
      
      # Send to speech window and audio alert for this critical warning
      if defined?(Lich) && defined?(Lich::Messaging)
        Lich::Messaging.stream_window(warning_msg, "speech")
      end
      print "\a"
      
      @critical_warning_given = true
      @last_timer_reminder = Time.now
      return
    end
    
    # Regular 15-minute reminders
    time_since_timer_reminder = Time.now - @last_timer_reminder
    if time_since_timer_reminder >= 900  # 900 seconds = 15 minutes
      if remaining_minutes > 0
        echo "Table timer: #{remaining_minutes} minutes remaining"
      else
        echo "Table timer: EXPIRED! Your table may collapse soon!"
      end
      @last_timer_reminder = Time.now
    end
  end

  def calculate_remaining_time
    # Tables last 120 minutes (7200 seconds)
    elapsed_seconds = Time.now - @table_start_time
    remaining_seconds = 7200 - elapsed_seconds
    remaining_minutes = (remaining_seconds / 60).floor
    [remaining_minutes, 0].max  # Don't return negative numbers
  end

  def check_location
    return unless @table_room
    
    current = Room.current.id if defined?(Room) && Room.current
    return unless current
    
    if current != @table_room && !@away_from_table
      # First time leaving the table
      @away_from_table = true
      @last_reminder_time = Time.now
      warning_msg = "WARNING: You left your table behind in room #{@table_room}!"
      echo warning_msg
      
      # Send to speech window as well
      if defined?(Lich) && defined?(Lich::Messaging)
        Lich::Messaging.stream_window(warning_msg, "speech")
      end
      
      # Audio alert
      print "\a"
    elsif current != @table_room && @away_from_table
      # Still away from table - check if 5 minutes have passed
      time_since_reminder = Time.now - @last_reminder_time
      if time_since_reminder >= 300  # 300 seconds = 5 minutes
        echo "REMINDER: Your table is still deployed in room #{@table_room}!"
        @last_reminder_time = Time.now
      end
    elsif current == @table_room && @away_from_table
      # Returned to table
      @away_from_table = false
      echo "You are back at your table."
    end
  end
end

# Handle cleanup on script exit
before_dying { 
  if $tablewatch_active
    do_client(";alias delete --global exit")
    DownstreamHook.remove('simple_tablewatch') rescue nil
    $tablewatch_active = false
    $tablewatch_room = nil
    echo "Cleanup completed"
  end
}

# Run the script
tablewatch = SimpleTablewatch.new
tablewatch.run