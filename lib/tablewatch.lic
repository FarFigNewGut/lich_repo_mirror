# Enhanced Tablewatch Script
# Comprehensive table protection with advanced features
# Author: Fulmen

VERSION = "2.0"

# Handle command line arguments
if defined?(Script) && Script.current && Script.current.vars
  case Script.current.vars[0].to_s.downcase
  when 'help', '-h', '--help'
    respond <<~HELP
      
      Tablewatch - Enhanced Table Protection Script v#{VERSION}
      
      USAGE:
        ;tablewatch                Start monitoring your table
        ;tablewatch help           Show this help message
        ;tablewatch timer <min>    Set timer reminder interval (default: 15)
        ;tablewatch location <min> Set location reminder interval (default: 5)
        ;tablewatch quiet          Disable audio alerts
        ;tablewatch noisy          Enable audio alerts
      
      WHAT IT DOES:
        - Blocks the EXIT command while your table is deployed
        - Tracks which room you deployed your table in
        - Warns when you leave the table room behind
        - Reminds you regularly if you stay away
        - Automatically shuts down when you TINKER to pack the table
        - Restores normal exit functionality when done
      
      HOW TO USE:
        1. Deploy your table in a room
        2. Start the script: ;tablewatch
        3. Script blocks exit and tracks your location
        4. When done, TINKER your table to pack it up
        5. Script automatically removes exit blocking
      
      TIP:
        I recommend adding an alias like:
        ;alias add prod=;e  start_script("tablewatch"); fput "prod my basket"
        This will make sure to start the script whenever you turn your 
        basket into a table.
      
      ALERTS:
        - Visual warning when you leave the table room
        - Audio beep to get your attention (can be disabled)
        - Speech window notification for visibility
        - Repeated reminders while away (customizable intervals)
        - Timer warnings (customizable intervals)
        - Critical warning at 15 minutes remaining
      
      The script prevents accidental logouts while your valuable table
      is deployed, ensuring you don't lose it by exiting carelessly.
      
    HELP
    exit
  end
end

class EnhancedTablewatch
  def initialize(args = [])
    # Simple v1 approach - just track the current room
    @table_room = get_current_room
    @table_room_name = get_room_name(@table_room)
    @table_name = get_table_name(@table_room)
    @away_from_table = false
    @last_reminder_time = Time.now
    @table_start_time = Time.now
    @last_timer_reminder = Time.now
    @critical_warning_given = false
    @paused = false
    @quiet_mode = false
    @shutting_down = false
    
    # Customizable intervals (in minutes, converted to seconds)
    @timer_interval = 15 * 60     # 15 minutes default
    @location_interval = 5 * 60   # 5 minutes default
    
    # Handle command line arguments
    handle_runtime_commands(args)
    if @shutting_down
      return
    end
    
    # Set global references like v1
    $enhanced_tablewatch = self
    $tablewatch_active = true
    $tablewatch_room = @table_room
    
    echo "Enhanced Tablewatch v#{VERSION} ready"
    echo "Started. Table deployed in #{@table_room_name}"
    echo "Exit command blocked until table is packed"
    echo "Table timer: 120 minutes remaining"
    
    setup_exit_alias
    setup_table_detection
  end

  def handle_runtime_commands(args)
    return unless args && args.length > 0
    
    case args[0].to_s.downcase
    when 'timer'
      if args[1] && args[1].to_i > 0
        @timer_interval = args[1].to_i * 60
        echo "Timer reminder interval set to #{args[1]} minutes"
      else
        echo "Usage: ;tablewatch timer <minutes>"
      end
      @shutting_down = true
    when 'location'
      if args[1] && args[1].to_i > 0
        @location_interval = args[1].to_i * 60
        echo "Location reminder interval set to #{args[1]} minutes"
      else
        echo "Usage: ;tablewatch location <minutes>"
      end
      @shutting_down = true
    when 'quiet'
      @quiet_mode = true
      echo "Audio alerts disabled"
      @shutting_down = true
    when 'noisy'
      @quiet_mode = false
      echo "Audio alerts enabled"
      @shutting_down = true
    end
  end

  def get_current_room
    if defined?(Room) && Room.current
      Room.current.id
    else
      nil
    end
  end

  def get_room_name(room_id)
    return "Unknown Room" unless room_id
    
    if defined?(Room) && Room[room_id] && Room[room_id].title
      title = Room[room_id].title.to_s.strip
      # Clean up any array formatting or brackets
      title = title.gsub(/^\[+|]+$/, '').gsub(/^"|"$/, '')
      
      # Ensure room number is included
      if title.include?(room_id.to_s)
        return title
      else
        return "#{title} - #{room_id}"
      end
    else
      "Room #{room_id}"
    end
  end

  def get_table_name(room_id)
    return "table" unless room_id
    
    # Try multiple times with delays to handle GameObj lag
    3.times do |attempt|
      if get_current_room == room_id
        tables = GameObj.loot.find_all { |obj| obj.noun == 'table' }
        if tables.length == 1
          return tables.first.name
        elsif tables.length > 1
          return "table (multiple found)"
        end
      end
      
      # Wait before retry, except on last attempt
      sleep 0.5 if attempt < 2
    end
    
    "table"
  end

  def table_name
    # Lazy loading - refresh table name if it's still generic
    if @table_name == "table" && @table_room
      refreshed_name = get_table_name(@table_room)
      @table_name = refreshed_name if refreshed_name != "table"
    end
    @table_name
  end

  def setup_exit_alias
    # Exit blocking with enhanced room and table names
    alias_cmd = 'if $tablewatch_active; $enhanced_tablewatch.show_exit_blocked_message; else; exit; end'
    
    do_client(";alias add exit=;e #{alias_cmd}")
    echo "Exit blocking alias installed"
  end

  def show_exit_blocked_message
    echo "Exit blocked - Your '#{table_name}' is still deployed at #{@table_room_name}! TINKER table to pack it up first."
  end

  def setup_table_detection
    # Simple hook like v1 - exactly the patterns that worked
    hook_proc = proc { |line|
      if line
        # Capture table name from deployment text
        if line =~ /transforms into a (.*? table)/i || line =~ /becomes.*?(.*? table)/i
          captured_name = $1.strip
          if captured_name && captured_name.length > 0
            @table_name = captured_name
            echo "Captured table name from deployment: '#{@table_name}'"
          end
        end
        
        # Existing detection patterns
        if line =~ /you trigger the transformation|you pick.*basket.*up|table.*folds.*into.*basket/i
          echo "Your '#{table_name}' at #{@table_room_name} packed! Shutting down..."
          shutdown
        elsif line =~ /you (?:nudge|hug).*table.*(?:refreshing|reset).*120\s+minutes/i
          echo "Your '#{table_name}' timer reset to 120 minutes by HUG - timer refreshed!"
          @table_start_time = Time.now
          @last_timer_reminder = Time.now
          @critical_warning_given = false
        end
      end
      line
    }
    
    DownstreamHook.add('enhanced_tablewatch', hook_proc)
  end

  def run
    # Simple monitoring loop like v1
    while !@shutting_down
      check_location unless @paused
      check_timer_reminder unless @paused
      sleep 1  # Fast checking for immediate warnings
    end
  rescue Interrupt
    shutdown
  end

  def check_location
    return unless @table_room
    
    current = get_current_room
    return unless current
    
    if current != @table_room && !@away_from_table
      # First time leaving the table
      @away_from_table = true
      @last_reminder_time = Time.now
      warning_msg = "WARNING: You just left your '#{table_name}' behind at #{@table_room_name}!"
      echo warning_msg
      
      # Send to speech window
      if defined?(Lich) && defined?(Lich::Messaging)
        Lich::Messaging.stream_window(warning_msg, "speech")
      end
      
      # Audio alert
      print "\a" unless @quiet_mode
      
    elsif current != @table_room && @away_from_table
      # Still away from table - check for reminder
      time_since_reminder = Time.now - @last_reminder_time
      if time_since_reminder >= @location_interval
        echo "REMINDER: Your '#{table_name}' is still deployed at #{@table_room_name}!"
        @last_reminder_time = Time.now
      end
      
    elsif current == @table_room && @away_from_table
      # Returned to table
      @away_from_table = false
      echo "You are back at your '#{table_name}' at #{@table_room_name}"
    end
  end

  def check_timer_reminder
    remaining_minutes = calculate_remaining_time
    
    # Critical warning at 15 minutes or less
    if remaining_minutes <= 15 && !@critical_warning_given
      warning_msg = "WARNING: Only #{remaining_minutes} minutes left on your '#{table_name}' at #{@table_room_name}! HUG your table now or it will disappear!"
      echo warning_msg
      
      # Send to speech window and audio alert
      if defined?(Lich) && defined?(Lich::Messaging)
        Lich::Messaging.stream_window(warning_msg, "speech")
      end
      print "\a" unless @quiet_mode
      
      @critical_warning_given = true
      @last_timer_reminder = Time.now
      return
    end
    
    # Regular timer reminders
    time_since_timer_reminder = Time.now - @last_timer_reminder
    if time_since_timer_reminder >= @timer_interval
      if remaining_minutes > 0
        echo "Table timer: #{remaining_minutes} minutes remaining on your '#{table_name}' at #{@table_room_name}"
      else
        echo "Table timer: EXPIRED! Your '#{table_name}' at #{@table_room_name} may collapse soon!"
      end
      @last_timer_reminder = Time.now
    end
  end

  def calculate_remaining_time
    # Tables last 120 minutes (7200 seconds)
    elapsed_seconds = Time.now - @table_start_time
    remaining_seconds = 7200 - elapsed_seconds
    remaining_minutes = (remaining_seconds / 60).floor
    [remaining_minutes, 0].max
  end

  def shutdown
    return if @shutting_down
    @shutting_down = true
    
    # Remove exit alias
    do_client(";alias delete exit")
    
    # Remove hook
    DownstreamHook.remove('enhanced_tablewatch')
    
    # Clear globals
    $enhanced_tablewatch = nil
    $tablewatch_active = false
    $tablewatch_room = nil
    
    echo "Exit blocking removed. You can now exit normally."
  end
end

# Handle cleanup on script exit
before_dying { 
  if $tablewatch_active
    do_client(";alias delete exit")
    DownstreamHook.remove('enhanced_tablewatch') rescue nil
    $enhanced_tablewatch = nil
    $tablewatch_active = false
    $tablewatch_room = nil
    echo "Cleanup completed"
  end
}

# Run the script
args = []
if defined?(Script) && Script.current && Script.current.vars
  args = Script.current.vars[1..-1] || []
end

tablewatch = EnhancedTablewatch.new(args)
tablewatch.run unless tablewatch.instance_variable_get(:@shutting_down)