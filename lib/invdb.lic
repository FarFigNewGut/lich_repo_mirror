=begin
  Cross-character searching & tracking of inventory, lockers, bank accounts, and other data.

  If you have questions or need help, message me on lnet or discord.

  Thank you to those who help test and provide feedback:
    Soliere, Tawariell, Dirvy, Rovvigen, Veni, Selema, Shaelethe and more.

  Thank you to those on discord that help answer questions:
    Luxelle, Ondreian, LostRanger, Tillmen, Tysong, Rinualdo, and many others.

  This does not use hooks or watch your actions to update.

  To update the database, run ;inv, and/or add it to autostart, etc.

  Special thanks to Tysong for permission to include the bonus from ;resource

  Special thanks to LostRanger for permission for loglore, inspect, jarserve, and more.

  player's corner forum post: https://tinyurl.com/gs4-invdb

          author: Xanlin (Xanlin#4407 on discord)
            game: GS
            tags: inventory, utility, database
  requires_trust: true
        required: Lich >= 4.6.4
         version: 0.3.7.2
  sqlite_version: 3.8.3+  (lich installs version 3.8.11.1 on windows which meets the requirement)
  +---------------------------------------------------------------+
  ;inv help      > help text
  ;inv menu      > basic starter menu
  ;inv examples  > examples
  ;inv changelog > changelog
=end
=begin
  todo:
    add other stack item types & contents
    add wealth/notes
    implement worn
    print limit / offset / paging
  +---------------------------------------------------------------+
=end
module Inv_db;
  start_time = Time.now;
  # skip test server
  (respond "#{Script.current.name}: skipping test server"; exit;) if XMLData.game == 'GST' and (Script.current.vars[0] !~ /^[qcs]/ or Script.current.vars.size == 0);
  #------------------------------------------------------------------------------#
  # requires trust on Ruby < 2.5
  #------------------------------------------------------------------------------#
  if Gem::Version.new(RUBY_VERSION) < Gem::Version.new('2.5.0') and $SAFE != 0;
    _respond "
    #{$clean_lich_char}#{Script.current.name} requires trust to create and use a database file, to write files for export.\n
    <d cmd=\"#{$clean_lich_char}trust #{Script.current.name}\">#{$clean_lich_char}trust #{Script.current.name}</d>\n\n";
    exit;
  end;
  #------------------------------------------------------------------------------#
  # settings
  #------------------------------------------------------------------------------#
  # TODO: add character level settings to override globals
  default_settings = {
    'autofit'               => { :type => "boolean", :default_value => true,       :internal => false, :description => "table output will autofit columns" },
    'confirm_large_output'  => { :type => "boolean", :default_value => true,       :internal => false, :description => "require unpause script when output rows > 100" },
    'jar'                   => { :type => "boolean", :default_value => true,       :internal => false, :description => "check contents of jars" },
    'stack'                 => { :type => "boolean", :default_value => false,      :internal => false, :description => "check number of stacked notes" },
    'silence_stack'         => { :type => "boolean", :default_value => true,       :internal => false, :description => "silences lines from checking jars, notes, etc." },
    'use_old_quiet_command' => { :type => "boolean", :default_value => false,      :internal => true, :description => "fallback to old quiet command for scanning issue, created for an isolated case that was repeatable for a single user." },
    'container_noopen'      => { :type => "Array",   :default_value => ['locket'], :internal => false, :description => "names or nouns of containers not to try to open." },
    'open_containers'       => { :type => "boolean", :default_value => true,       :internal => false, :description => "opens and closes containers for inventory check" },
    'boh'                   => { :type => "Array",   :default_value => ['large treasure sack with a blood crystal clasp'], :internal => false, :description => "names of bags of holding." },
    'last_vacuum'           => { :type => "Time",    :default_value => Time.now,   :internal => true, :description => "internal tracking of the last sqlite vacuum operation." },
    'date_format'           => { :type => "string",  :default_value => "%m/%d/%y", :internal => false, :description => "date format, e.g. %m/%d/%y  or %Y-%m-%d" },
    'lumnis'                => { :type => "boolean", :default_value => true,       :internal => false, :description => "includes lumnis tracking in 'refresh all'" },
    'resource'              => { :type => "boolean", :default_value => true,       :internal => false, :description => "includes resource tracking in 'refresh all'" },
    'account '              => { :type => "boolean", :default_value => false, :internal => false, :description => "includes account level simucoin and premium point tracking in 'refresh all'" },
  };

  Settings.load
  @settings_hash = Settings.to_hash;
  ns = (default_settings.keys - @settings_hash.keys);
  if ns.size > 0
    ns.each { |s|
      Settings[s]       = default_settings[s][:default_value];
      @settings_hash[s] = default_settings[s][:default_value];
    };
  end;

  if Script.current.vars[0] =~ /^--settings/i
    row_format = "  %-15s | %-8s | %s"
    row_size   = (row_format % ["", "", ""]).size - 2
    row_size  += default_settings.values.map { |v| v[:description] if v[:internal] == false }.compact.max_by { |d| d.size if d }.length
    output = []
    output <<  "  invdb settings:"
    output <<  "  #{"-" * row_size}"
    output << row_format % ["setting", "value", "description"]
    default_settings.each { |s, d|
      next if d[:internal] == true
      v = @settings_hash[s]
      if v.class != Array
        output << row_format % [s, v, d[:description]]
      end
    }
    output << "  #{"-" * 45}"
    default_settings.each { |s, d|
      v = @settings_hash[s]
      if v.class == Array
        output << "  %s: %s" % [s, d[:description]]
        v.each_with_index { |i, x|
          output << "    #{x + 1}. #{i}"
        }
        output << "           add to this list using: ;#{Script.current.name} +#{s} thing to add"
        output << "      remove from this list using: ;#{Script.current.name} -#{s} thing to remove"
      end
    }
    output << "  #{"-" * 45}"
    respond output
    exit
  end

  boolean_settings_pattern = /--(#{default_settings.each_with_object([]) { |k, a| a << k[0] if k[1][:type] == "boolean"; }.join('|')})(?: ?[=: ] ?)(\w+)/i
  if Script.current.vars[0] =~ boolean_settings_pattern;
    Script.current.vars[0].scan(boolean_settings_pattern).each { |n, v|
      setting_name = n.downcase
      setting_value_string = v
      if setting_value_string =~ /true|false|on|off/i
        setting_value = setting_value_string =~ /true|on/i ? true : false;
        if @settings_hash[setting_name] != setting_value
          Settings[setting_name] = setting_value;
          Settings.save;
          _respond "invdb: #{setting_name} is now #{setting_value.inspect}"
        else
          _respond "invdb: #{setting_name} was already set to #{setting_value.inspect}"
        end
      else
        _respond "invdb: unknown value '#{setting_value_string}' for #{setting_name}. Try true, false, on, or off.";
      end;
    }
    exit;
  end

  string_settings_pattern = /--(#{default_settings.each_with_object([]) { |k, a| a << k[0] if k[1][:type] == "string"; }.join('|')})(?: ?[=: ] ?)(.*?)(?:$| +--)/i
  if Script.current.vars[0] =~ string_settings_pattern;
    Script.current.vars[0].scan(string_settings_pattern).each { |n, v|
      setting_name = n.downcase
      setting_value_string = v
      if setting_value_string.length > 0
        setting_value = setting_value_string
        if @settings_hash[setting_name] != setting_value
          Settings[setting_name] = setting_value;
          Settings.save;
          _respond "invdb: #{setting_name} is now #{setting_value.inspect}"
        else
          _respond "invdb: #{setting_name} was already set to #{setting_value.inspect}"
        end
      else
        _respond "invdb: unknown value '#{setting_value_string}' for #{setting_name}.";
      end;
    }
    exit;
  end

  array_settings_list = default_settings.each_with_object([]) { |k, a| a << k[0] if k[1][:type] == "Array"; }.join('|')
  if Script.current.vars[0] =~ /([\+-])+(#{array_settings_list})(.*)/;
    prefix = $1
    setting_name = $2
    entries = $3.split(/(?:\s*[,;|]\s*)+/);
    if entries.length > 0;
      if prefix == "+"
        entries.each { |c|;
          next if c.strip.length == 0;
          if !@settings_hash[setting_name].include?(c.strip);
            Settings[setting_name].push(c.strip);
            Settings.save;
            _respond "invdb: #{c.strip} added to the #{setting_name} list";
          else;
            _respond "invdb: #{c.strip} is already on the #{setting_name} list";
          end;
        };
      elsif prefix == "-"
        entries.each { |c|;
          next if c.strip.length == 0;
          if @settings_hash[setting_name].include?(c.strip);
            Settings[setting_name].delete(c.strip);
            Settings.save;
            _respond "invdb: #{c.strip} removed from the #{setting_name} list";
          else
            _respond "invdb: #{c.strip} is not on the #{setting_name} list";
          end;
        };
      end
    end;
    exit;
  end;

  if Script.current.vars[0] =~ /--noopen(.*)/;
    noopen = $1.split(/(?:\s*[,;|]\s*)+/);
    if noopen.length > 0;
      noopen.each { |c|;
        next if c.strip.length == 0;
        if !@settings_hash["container_noopen"].include?(c.strip);
          Settings["container_noopen"].push(c.strip);
          Settings.save;
          _respond "invdb: #{c.strip} added to the noopen list";
        else;
          _respond "invdb: #{c.strip} is already on the noopen list";
        end;
      };
    else
      _respond "invdb: noopen list:";
      Settings["container_noopen"].each_with_index { |c, i|;
        _respond "#{i + 1}: #{c}";
      };
    end;
    exit;
  end;

  if Script.current.vars[0] =~ /--open (.+)/;
    noopen = $1.split(/(?:\s*[,;|]\s*)+/);
    if noopen.length > 0;
      noopen.each { |c|;
        next if c.strip.length == 0;
        if @settings_hash["container_noopen"].include?(c.strip);
          Settings["container_noopen"].delete(c.strip);
          Settings.save;
          _respond "invdb: #{c.strip} removed from the noopen list";
        else
          _respond "invdb: #{c.strip} is not on the noopen list";
        end;
      };
    end;
    exit;
  end;

  #------------------------------------------------------------------------------#
  # basic db methods
  #------------------------------------------------------------------------------#
  def self.open;
    require 'sqlite3';
    db = SQLite3::Database.open "#{$lich_dir}data/inv.db3";
    db.execute('PRAGMA temp_store = MEMORY');
    return db;
  end;

  def self.sqlite_version;
    require 'sqlite3';
    db = Inv_db.open;
    sqlite_version = db.get_first_value('select sqlite_version()');
    db.close;
    return sqlite_version;
  end;

  def self.pass_thru(sql, qargs = {}, db = nil, quiet = true);
    close_db = false
    (close_db = true; db = Inv_db.open) if db.nil?
    changes = nil
    rows = []
    begin
      if qargs.empty?
        rows = db.execute2(sql)
      else
        rows = db.execute2(sql, qargs)
      end
      passthru_changes = db.changes;
      respond "rows returned: #{rows.length}; changes: #{passthru_changes}" if !quiet
    rescue SQLite3::BusyException
      sleep 0.1
      retry
    rescue SQLite3::Exception => e
      # Inv_db.gs_print "Exception occured. Please contact Xanlin#4407 on discord with error details."
      Inv_db.gs_print "Exception: #{e}"
      Inv_db.gs_print "sql: #{sql}" if e.to_s =~ /syntax error/
      Inv_db.gs_print "qargs:#{qargs.inspect}" if e.to_s =~ /syntax error/
    ensure
      db.close if close_db;
    end
    return rows, changes
  end;

  def self.execute(sql, hash_args = {}, db = nil)
    close_db = false; changes = 0;
    (close_db = true; db = Inv_db.open) if db.nil?
    begin
      respond sql if @debug_sql
      respond "hash_args:#{hash_args.inspect}" if @debug_sql
      rows = db.execute(sql, hash_args)
      changes = db.changes
    rescue SQLite3::BusyException
      sleep 0.1
      retry
    rescue SQLite3::Exception => e
      Inv_db.gs_print "Exception occured. Please contact #{self.format_monsterbold("Xanlin#4407")} on discord with error details."
      Inv_db.gs_print "Exception: #{e}"
      Inv_db.gs_print sql if e.to_s =~ /syntax error|no such bind/
      Inv_db.gs_print "hash_args:#{hash_args.inspect}" if e.to_s =~ /syntax error|no such bind/
    ensure
      db.close if close_db
    end
    return rows, changes
  end

  def self.execute2(sql, hash_args = {}, db = nil)
    close_db = false;
    (close_db = true; db = Inv_db.open) if db.nil?
    begin
      respond sql if @debug_sql
      respond "hash_args:#{hash_args.inspect}" if @debug_sql
      rows = db.execute2(sql, hash_args)
    rescue SQLite3::BusyException
      sleep 0.1
      retry
    rescue SQLite3::Exception => e
      Inv_db.gs_print "Exception occured. Please contact #{self.format_monsterbold("Xanlin#4407")} on discord with error details."
      Inv_db.gs_print "Exception: #{e}"
      Inv_db.gs_print sql if e.to_s =~ /syntax error|no such bind/
      Inv_db.gs_print "hash_args:#{hash_args.inspect}" if e.to_s =~ /syntax error|no such bind/
    ensure
      db.close if close_db
    end
    return rows
  end
  #------------------------------------------------------------------------------#
  # instance variables - newbie debugging
  #------------------------------------------------------------------------------#
  @debug                 = false;
  @debug_sql             = false;
  @debug_hook            = false;
  @debug_input           = false;
  @debug_print           = false;
  @benchmark             = false;
  @no_squelch            = false;
  @quiet                 = true;
  @use_old_quiet_command = @settings_hash["use_old_quiet_command"]
  @slower                = ($frontend =~ /wizard|avalon/ ? true : false)
  @empty_string          = "".encode("UTF-8")
  @calling_proc          = nil;
  @current_proc          = nil;
  #------------------------------------------------------------------------------#
  # helpers
  #------------------------------------------------------------------------------#
  def self.db_timestamp_integer(); return Time.now.to_i; end
  def self.int_to_comma(var) return (var.is_a? Integer) ? var.to_s.reverse.scan(/(?:\d*\.)?\d{1,3}-?/).join(',').reverse.to_s : var; end;
  def self.int_to_time(var) return (var.is_a? Integer) ? Time.at(var.to_i).strftime("%Y-%m-%d %H:%M") : var; end;
  def self.int_to_ustime(var) return (var.is_a? Integer) ? Time.at(var.to_i).strftime("%x %I:%M%p") : var; end;
  def self.int_to_usdate(var) return (var.is_a? Integer) ? Time.at(var.to_i).strftime("%x") : var; end;

  def self.int_to_date(var, style = nil);
    style = "%x" if style.nil?;
    return (var.is_a? Integer) ? Time.at(var.to_i).strftime(style) : var;
  end;

  @mono_start = %{<output class="mono" />}; @mono_end = %{<output class="" />};
  def self.format_mono(msg) return "<output class=\"mono\" />\n#{msg}\n<output class=\"\" />"; end;

  @monsterbold_start = $fake_stormfront ? "\034GSL\r\n " : "<pushBold\/>";
  @monsterbold_end   = $fake_stormfront ? "\034GSM\r\n " : "<popBold\/>";
  def self.format_monsterbold(msg); return "#{@monsterbold_start}#{msg}#{@monsterbold_end}"; end;
  def self.format_whisper(msg); return "<preset id=\"whisper\">#{msg}</preset>"; end;

  def self.gs_print(msg)
    if $frontend =~ /stormfront|wrayth/i
      puts msg # _respond will go to script output, puts doesn't, reduces ;log of output
    elsif $frontend =~ /profanity/i
      _respond msg
    elsif $frontend =~ /wizard|avalon/i
      respond sf_to_wiz(msg)
    else
      _respond msg
    end
  end
  #------------------------------------------------------------------------------#
  # item scraping helpers
  #------------------------------------------------------------------------------#
  @deplural = {
    "blades" => "blade", "branches" => "branch", "cabochons" => "cabochon",
    "essences" => "essence", "fans" => "fan", "globes" => "globe", "motes" => "mote",
    "pieces" => "piece", "rose gold fire" => "rose-gold fire", "shards" => "shard",
    "slices" => "slice", "teeth" => "tooth",
  }

  def self.deplural(str)
    str = str.strip =~ /^(containing )?(.*?)(ies|(?<=onyx)es|(?<=z)es|(?<!mos|glas)s)?$/ ? "#{$2}#{$3 == 'ies' ? 'y' : ''}" : str;
    str.gsub(/\b(#{@deplural.keys.join("|")})\b/, @deplural);
  end

  def self.get_item_type(name, noun)
    return GameObj.new(0, noun, name).type.sub(/^uncommon,|,uncommon/, '')
  end

  #------------------------------------------------------------------------------#
  # for a strange new issue for one user, including option to use old quiet_command
  #------------------------------------------------------------------------------#
  def self.old_quiet_command(command, start_pattern, end_pattern = /<prompt/, include_end = true, timeout = 5)
    hook = self.mask_output(start_pattern, end_pattern, include_end)
    xml = dothistimeout(command, timeout, start_pattern)
    unless xml
      DownstreamHook.remove(hook)
      return nil
    end
    result = [xml]
    while true
      xml = get
      if xml =~ end_pattern
        result << xml if include_end
        return result
      end
      result << xml
    end
  end

  def self.mask_output(start_pattern, end_pattern = /<prompt/, include_end = true)
    filter = false
    name = self.anon_hook
    DownstreamHook.add(name, proc { |xml|
      if filter
        if xml =~ end_pattern
          DownstreamHook.remove(name)
          filter = false
          next(include_end ? nil : xml)
        else
          next(nil)
        end
      elsif xml =~ start_pattern
        filter = true
        next(nil)
      else
        xml
      end
    })
    return name
  end
  #------------------------------------------------------------------------------#
  # @stack_type pattern should capture id, amount, optionally status (empty/partial/full)
  @stack_type = Hash.new
  @stack_type["jar"]    = { :command => "look in", :pattern => /Inside the <a exist="(?<id>\d+)" noun=".*?">.*?<\/a> you see (?<amount>\d+) portions? of .*?\.  It is (?<status>.*?)\./ }
  # measuring bundles currently breaks hiding
  @stack_type["bundle"] = { :command => "measure", :pattern => /You glance through your bundle and count a total of (?<amount>\d+) <a exist="(?<id>\d+).*/ }
  @stack_type["stack"]  = { :command => "read", :pattern => /This <a exist="(?<id>\d+)" noun=".*?">.*?<\/a> has (?<amount>[\d,]+) uses?./ }
  @stack_type["pack"]   = { :command => "read", :pattern => /This <a exist="(?<id>\d+)" noun=".*?">.*?pack<\/a> entitles the presenter to (?<amount>\d+).*$/ }
  @patterns[:stack] = /In the Common language, it reads:|You glance through your bundle and count a total of (?<amount>\d+)|Inside the .*? you see (?<amount>\d+) portions? of .*?\. *It is (?<status>.*?)\./

  def self.peek_stack(id, path, stack_type = "jar")
    stack_amount = 0
    stack_status = @empty_string
    stack_status = 'empty' if stack_type == "jar"

    s = @stack_type[stack_type]
    return false if s[:command].nil?;

    command = "#{s[:command]} ##{id} #{path}"
    respond command if @debug
    start_pattern = /In the Common language, it reads:|^(?:The|This|Inside the) <a exist=\"#{id}"/
    quiet         = @settings_hash['silence_stack']
    end_pattern   = /^<output class=""\/>|(<popBold\/>)?<prompt/;
    timeout       = 5;
    peek_result   = self.client_command(command, start_pattern, end_pattern, quiet, timeout).join("\n")
    _respond peek_result if @debug

    m = s[:pattern].match(peek_result)
    if m
      # stack_id     = m[:id] if m[:id]
      stack_amount = m[:amount].to_i if m[:amount]
      stack_status = m[:status] if s[:pattern].to_s =~ /status/ and m[:status]
    end
    return stack_amount, stack_status
  end

  def self.noun_type_check(str, _debug = nil); # TODO: remove after schema refactor
    sql = "
    select noun,type
    from item o
    where o.name = '#{str.strip.gsub("'", "''")}'
      and o.stack = ''
      and o.type not like 'unknown'
      and o.location_id < 10
    limit 1"
    rows = Inv_db.execute2(sql)
    noun = rows[1][0]
    type = rows[1][1]
    return noun, type
  end;

  def self.noun_test(str, debug = nil);
    noun = nil;
    if str.length > 35
      respond "  pattern_long" if debug
      # pattern_long = /^(?:pair of)?([\w'\- ]{5})?.*? (?<noun>[^ \n]+(?<! of| and)(?! reed| casting))(?<post>(?: drawn by| of| set withi?n?| in| that| \(.*| [^ \n-]*?(?:ed with|-laced|ed|(?<!fletch|hunt|sl|drawstr|climb|smudg|fish)ing|[io]n an?|bound|held|hung|strung|strewn|caught|fraught|inset|inlaid|split|side-secured|aglisten|swept|woven|with ?a?n?|shot through)))(?: .*?)?$/;
      pattern_long = /^(?:pair of)?([\w'\- ]{5})?.*? ([^ \n]+(?<! of| and)(?! reed| casting))((?: drawn by| of| set withi?n?| in| that| \(.*| [^ \n-]*?(?:ed with|-laced|ed|(?<!fletch|hunt|sl|drawstr|climb|smudg|fish)ing|[io]n an?|bound|held|hung|strung|strewn|caught|fraught|inset|inlaid|split|side-secured|aglisten|swept|woven|with ?a?n?|shot through)))(?: .*?)?$/;
      # respond pattern_long.match(str).inspect if @debug
      noun = str.scan(pattern_long).flatten[0];
      noun = nil if noun == '';
      if noun.nil?;
        pattern_medium = /^.*?(Hammer of Kai)$|^(?:[^ ]+[ \b])*([^ \b]*?)[ \b](?:with|an?|[io]n)[ \b]/;
        noun = str.scan(pattern_medium).flatten.join('');
      end;
    else
      respond "  pattern_short" if debug
      pattern_short = /^.*?(Hammer of Kai)$|^(?:.*?) ([^\s]+)$|^([^ ]+)$/;
      noun = str.strip.scan(pattern_short).flatten.join('');
      noun = "lapis" if str =~ /lapis lazuli$/;
    end
    noun = nil if noun == '';
    if noun.nil?;
      noun = str.split(' ')[-1];
    end;
    respond "  '#{str}' => noun:#{noun.inspect}" if debug;
    return noun;
  end;

  def self.peek_boh(id, location_id, level, path, boh_noun, verb = 'look in');
    command = "#{verb} ##{id} #{path}";
    respond command if @debug;
    start_pattern = Regexp.union(
      %r[This <a exist=\"#{id}" noun="[^"]*?">[^<]*?<\/a> has multiple pockets],
      %r[^Fashioned (?:from|of)],
      %r[^Crafted from],
      %r[^(?:<popBold\/>)?\d+\. +(?:an? )?(?<name>.*?)],
      %r[^There is nothing in there\.],
      %r[^You realize],
      %r[^Sifting through],
    )
    end_pattern   = /^(?:<popBold\/>)?<prompt/;
    peek_result   = self.client_command(command, start_pattern, end_pattern);
    respond "#{peek_result.join("\n")}" if @debug
    boh_item_pattern = %r[^(?:<popBold\/>)?\d+\. +(?:an? )?(?<name>.*?)(?:<pushBold/>)? \((?<amount>\d+|unlimited)(?<extra>.*?)$];
    boh_items = [];
    if path.nil? or path == "";
      path = boh_noun;
    else
      path = "#{path} > #{boh_noun}";
    end;
    intro = peek_result[0]
    peek_result.each { |r|
      if (m = boh_item_pattern.match(r));
        name = m[:name].strip;
        noun, type = Inv_db.noun_type_check(name);
        noun      = Inv_db.noun_test(name) if noun.nil?;
        type      = Inv_db.get_item_type(name, noun) if type.nil?;
        type      = 'unknown' if type.nil?;
        if m[:extra] =~ /(fishing \w*)/
          type = $1.sub(/s$/, '')
        elsif m[:extra] =~ /specimen/
          type = 'specimen'
        elsif intro =~ /gemstones/
          type = 'gemstone'
        end
        amount = nil
        if m[:amount] =~ /doses/
          amount = 1
        else
          amount = m[:amount].to_i
        end
        boh_items << {
          :id          => nil,
          :location_id => location_id.to_i,
          :level       => level + 1,
          :path        => path.encode('UTF-8'),
          :type        => type.encode('UTF-8'),
          :name        => name.encode('UTF-8'),
          :noun        => noun.encode('UTF-8'),
          :amount      => amount,
          :stack       => 'boh'.encode('UTF-8'),
          :status      => '',
          :marked      => '',
          :registered  => '',
          :hidden      => '',
          :worn        => '',
          :update_noun => 0
        };
      end;
    };
    return boh_items;
  end;
  #------------------------------------------------------------------------------#
  # Inv_db.traverse_container
  #------------------------------------------------------------------------------#
  @locker_items = [];
  def self.traverse_container(_parent, child, level, path);
    @locker_items = [] if @locker_items.nil?;
    empty_string = "".encode('UTF-8');
    location_id = 10;
    level += 1;
    # this is the path style I need for looking in items while traversing;
    path = "in #{child} #{path}";
    # respond "+-----#{level}:#{path}:#{parent}:#{child.noun}" if @debug;
    child.contents.each { |i|;
      prename       = i.before_name;
      id            = i.id;
      noun          = i.noun.strip;
      name          = i.name;
      postname      = i.after_name;
      attrs         = empty_string;
      registered    = attrs =~ /registered/ ? "Y" : empty_string;
      marked        = attrs =~ /marked/ ? "Y" : empty_string;
      hidden        = attrs =~ /hidden/ ? "Y" : empty_string;
      amount        = 1;
      type = Inv_db.get_item_type(name, noun) || 'unknown' # empty_string
      stack         = empty_string;
      stack_name    = empty_string;
      stack_noun    = empty_string;
      stack_type    = empty_string;
      stack_amount  = 0;
      status        = empty_string;
      stk = /^(?<stack>jar)/i.match(type);
      if stk;
        stack           = empty_string;
        stack_name      = Inv_db.deplural(postname).strip;
        stack_noun      = stack_name =~ /(.*?) ([\w\-]+)$/ ? $2 : empty_string;
        stack_noun      = stack_noun =~ /lazuli/ ? "lapis" : stack_noun;
        stack_type      = Inv_db.get_item_type(stack_name, stack_noun) || empty_string if postname != "";
        stack_amount, status = Inv_db.peek_stack(id, path, "jar") # if postname =~ /containing/
        status          = status =~ /^(full|empty)/ ? status : "partial";
        stack           = stk[:stack] if stack_amount > 0;
      end;
      prename       = prename =~ /^(an ?|a ?)(.*)? ?/ ? $2 : prename;
      name          = "#{prename} #{name =~ /^(some )?(.*)/ ? $2 : name} #{stack == empty_string ? postname : "(#{stack_name}) (#{stack_amount})"}".strip;
      @locker_items.push({
        :id          => id,
        :location_id => location_id.to_i,
        :level       => level.to_i,
        :path        => path.gsub(/locker */, ''),
        :type        => type ? type : empty_string,
        :name        => name,
        :noun        => noun,
        :amount      => amount.to_i,
        :stack       => empty_string,
        :status      => status,
        :marked      => marked,
        :registered  => registered,
        :hidden      => hidden,
        :worn        => empty_string,
        :update_noun => id ? 1 : 0
      });
      if stack != empty_string;
        @locker_items.push({
          :id          => id,
          :location_id => location_id.to_i,
          :level       => level + 1,
          :path        => "#{path} > #{stack}".gsub(/locker *> */, ''),
          :type        => stack_type ? stack_type : empty_string,
          :name        => stack_name,
          :noun        => stack_noun,
          :amount      => stack_amount.to_i,
          :stack       => stack,
          :status      => empty_string,
          :marked      => empty_string,
          :registered  => empty_string,
          :hidden      => empty_string,
          :worn        => empty_string,
          :update_noun => id ? 1 : 0
        });
      end;
      if i.type =~ /clothing|container/
        close_this = false;
        if @settings_hash['open_containers'] == true;
          open_result = self.object_open(i, path)
          close_this = true if open_result.join("\n") !~ /That is already open/
        end
        self.object_look(i, 'in', path)
        sleep 0.1;
        Inv_db.traverse_container(child.noun, i, level, path) if i.contents;
        if close_this == true;
          self.object_close(i, path)
        end
      end;
    };
  end;
  #------------------------------------------------------------------------------#
  # column and printing helpers
  #------------------------------------------------------------------------------#
  @columns = Hash.new;
  @columns["name"]         = { :justify => "-", :width => 12, :pad => 1 };
  @columns["game"]         = { :justify => "-", :width =>  4, :pad => 0 }; # GSPlat
  @columns["prof"]         = { :justify => "-", :width =>  8, :pad => 1 }; # Sorcerer
  @columns["pro"]          = { :justify => "-", :width =>  3, :pad => 1 }; # Sorcerer
  @columns["race"]         = { :justify => "-", :width =>  4, :pad => 1 }; # Bu
  @columns["rc"]           = { :justify => "-", :width =>  2, :pad => 1 }; # Bu
  @columns["level"]        = { :justify => "", :width =>  5, :pad => 1 };
  @columns["lvl"]          = { :justify => "", :width =>  3, :pad => 1 };
  @columns["lv"]           = { :justify => "", :width =>  2, :pad => 0 };
  @columns["exp"]          = { :justify => "", :width => 13, :pad => 1 };
  @columns["area"]         = { :justify => "-", :width => 20, :pad => 1 }; # Northern Caravansary
  @columns["location"]     = { :justify => "-", :width => 10, :pad => 1 }; # Northern Caravansary
  @columns["loc"]          = { :justify => "-", :width => 6, :pad => 0 }; # locker|teras|hands
  @columns["account"] = { :justify => "-", :width => 12, :pad => 1 }; #
  @columns["acc"]          = { :justify => "-", :width => 3, :pad => 1 }; #
  @columns["act"]          = { :justify => "-", :width => 3, :pad => 1 }; #
  @columns["subscription"] = { :justify => "-", :width => 12, :pad => 1 }; #
  @columns["sub"]          = { :justify => "-", :width => 3, :pad => 1 }; #
  @columns["locker"]       = { :justify => "-", :width => 18, :pad => 1 }; # Wehnimer's Landing
  @columns["lockr"]        = { :justify => "-", :width => 5, :pad => 1 }; # Wehnimer's Landing
  @columns["timestamp"]    = { :justify => "-", :width => 16, :pad => 1 }; # 2018-05-06 11:43
  # @columns["last_update"]  = { :justify => "-", :width => 16, :pad => 0}; #2018-05-06 11:43
  @columns["bank"]         = { :justify => "-", :width => 28, :pad => 1 }; # Bank of Kharag 'doth Dzulthu
  @columns["source"]       = { :justify => "-", :width => 16, :pad => 1 }; # Bank of Kharag 'doth Dzulthu
  @columns["currency"]     = { :justify => "-", :width => 28, :pad => 1 }; # Bank of Kharag 'doth Dzulthu
  @columns["silver"]       = { :justify => "", :width => 13, :pad => 1 }; # 3,109,765,321
  @columns["balance"]      = { :justify => "", :width => 13, :pad => 1 }; # 3,109,765,321
  @columns["amount"]       = { :justify => "", :width => 13, :pad => 1 }; # 3,109,765,321
  @columns["count"]        = { :justify => "", :width =>  5, :pad => 1 }; # 3,109,765,321
  @columns["boxes"]        = { :justify => "", :width =>  5, :pad => 1 }; # 3,109,765,321
  @columns["qty"]          = { :justify => "", :width =>  4, :pad => 0 }; # 65,321
  @columns["loose"]        = { :justify => "", :width =>  6, :pad => 1 }; # 65,321
  @columns["jarred"]       = { :justify => "", :width =>  6, :pad => 1 }; # 65,321
  @columns["noun"]         = { :justify => "-", :width => 16, :pad => 1 }; # item name goes to end
  @columns["item"]         = { :justify => "-", :width => 32, :pad => 1 }; # item name goes to end
  @columns["abbr"]         = { :justify => "-", :width =>  6, :pad => 1 }; # item name goes to end
  @columns["path"]         = { :justify => "-", :width => 16, :pad => 1 }; # not sure yet
  @columns["type"]         = { :justify => "-", :width => 10, :pad => 0 }; # clothing armor gem weapon
  @columns["stack"]        = { :justify => "-", :width =>  7, :pad => 1 }; # bundle
  @columns["stk"]          = { :justify => "-", :width =>  3, :pad => 0 }; # bundle
  @columns["status"]       = { :justify => "-", :width =>  7, :pad => 1 }; # full|empty|partial
  @columns["epf"]          = { :justify => "-", :width =>  3, :pad => 0 }; # full|empty|partial
  @columns["marked"]       = { :justify => "-", :width =>  6, :pad => 1 }; # Y
  @columns["mark"]         = { :justify => "-", :width =>  4, :pad => 1 }; # Y
  @columns["m"]            = { :justify => "-", :width =>  1, :pad => 0 }; # Y
  @columns["registered"]   = { :justify => "-", :width =>  6, :pad => 1 }; # Y
  @columns["reg"]          = { :justify => "-", :width =>  3, :pad => 1 }; # Y
  @columns["r"]            = { :justify => "-", :width =>  1, :pad => 0 }; # Y
  @columns["h"]            = { :justify => "-", :width =>  1, :pad => 0 }; # Y
  @columns["worn"]         = { :justify => "-", :width =>  1, :pad => 1 }; # shoulders
  @columns["table"]        = { :justify => "-", :width =>  8, :pad => 1 }; #
  @columns["inserted"]     = { :justify => "", :width =>  8, :pad => 1 }; #
  @columns["updated"]      = { :justify => "", :width =>  8, :pad => 1 }; #
  @columns["deleted"]      = { :justify => "", :width =>  8, :pad => 1 }; #
  @columns["character_id"] = { :justify => "", :width =>  1, :pad => 1 }; #
  @columns["location_id"]  = { :justify => "", :width =>  1, :pad => 1 }; #
  @columns["update_noun"]  = { :justify => "", :width =>  12, :pad => 1 }; #
  @columns["gs_id"]        = { :justify => "", :width =>  12, :pad => 1 }; #
  @columns["characters"]   = { :justify => "", :width =>  12, :pad => 1 }; #
  @columns["character"]    = { :justify => "", :width =>  12, :pad => 1 }; #
  @columns["inv"]          = { :justify => "", :width => 3, :pad => 1 }; #


  @abbrs = Hash.new;
  # q item;
  @abbrs["loc"]    = "location of the item (hands|inv|alongside|locker|town abbr if multi locker)";
  @abbrs["path"]   = "the path to an item, e.g. `backpack > box` is in a box, in a backpack";
  @abbrs["type"]   = "object type, per GameObj.type_data"; # , `;e _respond GameObj.type_data.keys` for your list of types"
  @abbrs["stk"]    = "stack, a non-standard container, e.g. jar|bundle|voucher pack";
  @abbrs["epf"]    = "status (empty|partial|full) for jars/stacks";
  @abbrs["m"]      = "marked (Y or blank)";
  @abbrs["r"]      = "registered (Y or blank)";
  @abbrs["h"]      = "hidden (Y or blank)";
  # q char;
  @abbrs["pro"]    = "profession";
  @abbrs["rc"]     = "race abbreviation";
  @abbrs["lvl"]    = "level";
  @abbrs["area"]   = "location character was when last updated";
  @abbrs["sub"]    = "account type (f2p|standard|premium)";
  @abbrs["locker"] = "town locker is in, multi if multiple";
  @abbrs["lockr"]  = "town locker is in, multi if multiple (will show starting town for f2p)";
  @abbrs["inv"]    = "item count for carried items";

  def self.format_table(headers, column_delimiter = "|", column_padding_char = " ");
    _respond "headers:#{headers.inspect}" if @debug_print;
    pad_char = column_padding_char;
    table_format  = "";
    table_hl      = "";
    headers.each { |h|;
      h = h.split('.')[-1];
      i = @columns[h];
      table_format += "#{pad_char * i[:pad]}%#{i[:justify]}#{i[:width]}s#{pad_char * i[:pad]}#{column_delimiter unless h == headers[-1]}";
      table_hl += "-" * (i[:pad] + i[:width] + i[:pad] + column_delimiter.length);
    };
    return table_format, table_hl;
  end;

  def self.output_table(rows, target, iparams = nil, highlight = nil, regex_highlight = false, date_format = "%m/%d/%y", autofit = true)
    to_print    = [];
    autofit     = @settings_hash['autofit'] if !@settings_hash.nil?;
    date_format = @settings_hash['date_format'] if !@settings_hash.nil?;
    sum_qty = 0
    if rows.length > 1;
      headers          = rows.shift;
      otimestamp       = headers.index("timestamp");
      oupdated         = headers.index("updated");
      ohighlight       = headers.index(highlight) if highlight;
      osum_qty         = headers.index("qty");
      filter_highlight = iparams[:search_filter].gsub(/(?!^)[\*|%](?!$)/, '.*').gsub('%', '') if iparams[:search_filter] && regex_highlight == false;
      filter_highlight = iparams[:search_filter] if iparams[:search_filter] && regex_highlight == true;
      rows.each do |row|;
        row.each_with_index { |col, x|
          next if [otimestamp, oupdated].include?(x)
          row[x] = Inv_db.int_to_comma(col) if col.class.to_s =~ /Fixnum|Integer/
        }
        row[otimestamp] = Inv_db.int_to_date(row[otimestamp], date_format) if otimestamp;
        row[oupdated]   = Inv_db.int_to_date(row[oupdated], date_format) if oupdated;
        sum_qty += row[osum_qty].to_i if osum_qty;
      end;

      if autofit == true
        table_format, table_hl = Inv_db.format_table2(headers, rows);
      else
        table_format, table_hl = Inv_db.format_table(headers);
      end

      abbrs = @abbrs.clone;
      abbrs.keep_if { |k, _v| headers.include?(k) };
      to_print << @mono_start;
      abbrs.each { |k, v| to_print << "... %5s: %5s" % [k, v] } if abbrs.length > 0;
      to_print << table_hl;
      to_print << table_format % headers;
      to_print << table_hl;
      rows.each do |row|;
        row[ohighlight] = row[ohighlight].sub(/(#{filter_highlight})/i, Inv_db.format_whisper($1)) if ohighlight && filter_highlight && row[ohighlight] =~ /(#{filter_highlight})/i;
        to_print << table_format % row;
      end;
      to_print << table_hl;
      if sum_qty > 0
        to_print << Inv_db.format_whisper("matched #{sum_qty} total items in #{rows.length} row#{rows.length > 1 ? "s" : ""} from #{target}.");
      else
        to_print << Inv_db.format_whisper("matched #{rows.length} row#{rows.length > 1 ? "s" : ""} from #{target}.");
      end
      to_print << @mono_end;
    else;
      to_print << Inv_db.format_monsterbold("no results found in #{target}");
    end;
    Inv_db.gs_print(to_print.join("\n"));
  end;

  def self.format_table2(headers, rows = [], column_delimiter = "|", column_padding_char = " ");
    table_border  = "";
    pad_char      = column_padding_char;
    table_format  = "";
    table_hl      = "";
    maxlen        = [];
    just          = [];
    if !rows.nil?;
      c = rows.clone.unshift(headers).transpose;
      c.each { |v|
        maxlen << v.max_by { |i| i.to_s.gsub(/<[^>]*?>/, '').length }.to_s.length || 1
        is_string = !v[1..-1].find { |i| i.to_s.match(/[a-zA-Z]/) }.nil?
        just << (is_string ? '-' : '').to_s
      };
    end;
    headers.each_with_index { |h, ix|
      if (ix == (headers.size - 1))
        i = { :pad => 1, :width => (h.length > maxlen[ix].to_s.length ? h.length : maxlen[ix].to_s.length), :justify => just[ix] };
        table_format += "#{pad_char * i[:pad]}%#{i[:justify]}#{i[:justify] == "" ? maxlen[ix] : ""}s";
        max_width = (i[:pad] + maxlen[ix] + column_delimiter.length)
        table_hl += "-" * (max_width > 20 ? 20 : max_width);
      else
        i = { :pad => 1, :width => (h.length > maxlen[ix].to_s.length ? h.length : maxlen[ix].to_s.length), :justify => just[ix] };
        table_format += "#{pad_char * i[:pad]}%#{i[:justify]}#{maxlen[ix]}s#{pad_char * i[:pad]}#{column_delimiter unless h == headers[-1]}";
        max_width = (i[:pad] + maxlen[ix] + i[:pad] + column_delimiter.length)
        table_hl += "-" * max_width
      end
    };
    table_format = "#{table_border}#{table_format}#{table_border}";
    return table_format, table_hl;
  end;

  #------------------------------------------------------------------------------#
  # external call helpers:
  #
  # Inv_db.pass_thru returns two variables, one is the array of arrays with the rows,
  #   and another with a change count.
  # Inv_db.to_table can be used to print rows, and assumes the first position in the array are headers
  #
  # e.g. >;e r,c=Inv_db.pass_thru("select * from character limit 1");Inv_db.to_table(r)
  # e.g. >;e r,c=Inv_db.pass_thru("select sql from sqlite_master where type='table'");Inv_db.to_table(r)
  # e.g. >;e r,c=Inv_db.pass_thru("select sql from sqlite_master where type='table'");r.each{|a| respond a[0]}
  #------------------------------------------------------------------------------#
  def self.to_table(rows)
    to_print = [];
    if rows.length > 1;
      headers = rows[0];
      table_format, table_hl = format_table2(headers, rows);
      to_print << @mono_start;
      to_print << table_hl;
      to_print << table_format % headers;
      to_print << table_hl;
      rows.shift;
      rows.each do |row|
        to_print << table_format % row;
      end;
      to_print << table_hl;
      to_print << @mono_end;
    else;
      to_print << " nothing to print ";
      return nil;
    end;
    _respond to_print.join("\n");
  end;

  #------------------------------------------------------------------------------#
  # dynamic-ish sql
  #------------------------------------------------------------------------------#
  def self.query_bank_sql(params, style = "");
    respond "+---------------- proc_start: #{@current_proc}" if @debug_sql && !@debug;
    respond "+----params:#{params.inspect}" if @debug_sql && !@debug;
    respond "+----style:#{style.inspect}" if @debug_sql && !@debug;

    groupby = having = orderby = limit = "";
    where, qargs, extras = self.where_builder(params, 'bank')
    query_extras = { :orderby => "c.name, b.id" }
    query_extras.merge!(extras) if !extras.empty?

    select = %{
    select
        c.name as character
      , b.name as bank
      , s.amount
      , s.timestamp as updated};
    from = %{
    from silver s
      inner join bank b on s.bank_id = b.id
      inner join character c on s.character_id = c.id};

    orderby = "\n    order by #{query_extras[:orderby]}" if query_extras.key?(:orderby);
    limit   = "\n    limit #{query_extras[:limit]}" if query_extras.key?(:limit);
    sql = "#{select} #{from} #{where} #{groupby} #{having} #{orderby} #{limit}";
    _respond sql if @debug_sql;
    return sql.encode('UTF-8'), qargs;
  end;

  def self.sum_bank_sql(params, style = "");
    respond "+---------------- proc_start: #{@current_proc}" if @debug_sql; # && !@debug
    respond "+----params:#{params.inspect}" if @debug_sql;
    respond "+----style:#{style.inspect}" if @debug_sql;

    having = orderby = limit = "";
    where, qargs, extras = self.where_builder(params, 'bank')
    query_extras = { :orderby => "bank" }
    query_extras.merge!(extras) if !extras.empty?

    select = %{
    select
        b.name as bank
      , sum(s.amount) as amount
      , replace(group_concat(distinct c.name),',',', ') as characters };
    from = %{
    from silver s
      inner join bank b on s.bank_id = b.id
      inner join character c on s.character_id = c.id};
    where  += "\n      and b.name <> 'Total'" if !qargs.key?(:search_filter);
    groupby = "\n    group by b.name";
    groupby += extras[:groupby]
    orderby = "\n    order by #{query_extras[:orderby]}" if query_extras.key?(:orderby);
    limit   = "\n    limit #{query_extras[:limit]}" if query_extras.key?(:limit);
    sql = "#{select} #{from} #{where} #{groupby} #{having}";
    sql += "\n    union all #{select.gsub('b.name', '"grand total"')} #{from} #{where} " if !qargs.key?(:search_filter) and !query_extras.key?(:limit)
    sql += " #{orderby} #{limit}";
    return sql.encode('UTF-8'), qargs;
  end;

  def self.query_tickets_sql(params, style = "");
    respond "+---------------- proc_start: #{@current_proc}" if @debug_sql && !@debug;
    respond "+----params:#{params.inspect}" if @debug_sql
    respond "+----style:#{style.inspect}" if @debug_sql && !@debug;

    groupby = having = orderby = limit = "";
    where, qargs, extras = self.where_builder(params, 'tickets')
    query_extras = { :orderby => "t.source, c.name" }
    query_extras.merge!(extras) if !extras.empty?

    select = %{
    select
        c.name as character
      , c.game
      , t.source
      , t.amount
      , t.currency
      , t.timestamp as updated};
    from = %{
    from tickets t
      inner join character c on t.character_id = c.id};

    orderby = "\n    order by #{query_extras[:orderby]}" if query_extras.key?(:orderby);
    limit   = "\n    limit #{query_extras[:limit]}" if query_extras.key?(:limit);
    sql = "#{select} #{from} #{where} #{groupby} #{having} #{orderby} #{limit}";
    _respond sql if @debug_sql;
    return sql.encode('UTF-8'), qargs;
  end;

  def self.sum_tickets_sql(params, style = "");
    respond "+---------------- proc_start: #{@current_proc}" if @debug_sql # && !@debug;
    respond "+----params:#{params.inspect}" if @debug_sql;
    respond "+----style:#{style.inspect}" if @debug_sql;

    having = orderby = limit = "";
    where, qargs, extras = self.where_builder(params, 'tickets')
    query_extras = { :orderby => "source" }
    query_extras.merge!(extras) if !extras.empty?

    select = %{
      select
          t.source as source
        , sum(t.amount) as amount
        , t.currency as currency
        , replace(group_concat(distinct c.name),',',', ') as characters };
    from = %{
    from tickets t
      inner join character c on t.character_id = c.id};

    groupby = "\n    group by t.source, t.currency";
    orderby = "\n    order by #{query_extras[:orderby]}" if query_extras.key?(:orderby);
    limit   = "\n    limit #{query_extras[:limit]}" if query_extras.key?(:limit);
    sql = "#{select} #{from} #{where} #{groupby} #{having} #{orderby} #{limit}";
    _respond sql if @debug_sql;
    return sql.encode('UTF-8'), qargs;
  end;

  def self.query_char_sql(params, style = "");
    respond "+---------------- proc_start: #{@current_proc}" if @debug_sql # && !@debug;
    respond "+----params:#{params.inspect}" if @debug_sql;
    respond "+----style:#{style.inspect}" if @debug_sql;

    groupby = having = orderby = limit = "";
    where, qargs, extras = self.where_builder(params, 'character')
    query_extras = { :orderby => "c.game, c.name" }
    query_extras.merge!(extras) if !extras.empty?

    select = %{
      select
          c.account
        , c.name
        , lower(c.game) as game
        , substr(c.prof,1,3) as pro
        , substr(replace(c.race,'alf-',''),1,2) as rc
        , c.level as lvl
        --, c.exp
        , c.area
        , substr(c.subscription,1,3) as sub
        --, coalesce(l.abbr,c.locker) as lockr
        , coalesce(l.locker_abbr,c.locker) as lockr
        , c.citizenship
        , c.society
        , c.society_rank as rank
        , c.timestamp as updated
        , i.inv
    };
    from = %{
      from character c
        left join ( select l.name as locker_name, l.abbr as locker_abbr from location l) as l
          on c.locker = l.locker_name
        left join (
          select
              i.character_id
            , sum(amount) as inv
          from item as i
          where i.stack=''
            and i.location_id < 3
          group by i.character_id
            ) i on c.id = i.character_id
    };

    where += "#{@where_prefix}c.name not like '%\\_' ESCAPE '\\'" if !qargs.key?(:character_filter)

    orderby = "\n    order by #{query_extras[:orderby]}" if query_extras.key?(:orderby);
    limit   = "\n    limit #{query_extras[:limit]}" if query_extras.key?(:limit);
    sql = "#{select} #{from} #{where} #{groupby} #{having} #{orderby} #{limit}";
    _respond sql if @debug_sql;
    return sql.encode('UTF-8'), qargs;
  end;

  def self.query_item_sql(params, style = "");
    respond "+---------------- proc_start: #{@current_proc}" if @debug_sql
    respond "+----params:#{params.inspect}" if @debug_sql;
    respond "+----style:#{style.inspect}" if @debug_sql;

    groupby = having = orderby = limit = "";
    where, qargs, extras = self.where_builder(params, 'item')
    query_extras = { :orderby => "c.name, l.type, l.name, i.level, i.path, i.noun, i.name" }
    query_extras.merge!(extras) if !extras.empty?

    select = "
    select
          c.name
        , l.abbr as loc
        , i.path
        , i.amount as qty
        , i.type
        , substr(i.stack,1,3) as stk
        , ' ' || substr(i.status,1,1) as epf
        , i.marked as m
        , i.registered as r
        , i.hidden as h";
    select += "\n      , i.noun as noun" if orderby =~ /noun/;
    select += "\n      , i.name as item";

    export_select = %{
    select
        c.account, c.name, l.name as location, l.abbr as loc
      , i.level, i.path, i.amount as qty
      , i.type, i.stack, i.status
      , i.name as item
      , i.timestamp
    };
    select = export_select if style == 'export'

    from = %{
      from item i
        inner join location l on i.location_id = l.id
        inner join character c on i.character_id = c.id};

    orderby = "\n    order by #{query_extras[:orderby]}" if query_extras.key?(:orderby);
    limit   = "\n    limit #{query_extras[:limit]}" if query_extras.key?(:limit);
    sql = "#{select} #{from} #{where} #{groupby} #{having} #{orderby} #{limit}";
    _respond sql if @debug_sql;
    return sql.encode('UTF-8'), qargs;
  end;

  def self.sum_item_sql(params, style = "");
    respond "+---------------- proc_start: #{@current_proc}" if @debug_sql; # && !@debug;
    respond "+----params:#{params.inspect}" if @debug_sql || @debug_input;
    respond "+----style:#{style.inspect}" if @debug_sql;

    having = orderby = limit = "";
    where, qargs, extras = self.where_builder(params, 'item')
    query_extras = { :orderby => "i.type, amount" }
    query_extras.merge!(extras) if !extras.empty?

    select = %{
    select
        i.type as type
      , sum(i.amount) as amount};
    select += "\n      , sum(case when stack='' then amount else 0 end) as loose" if qargs[:type_filter] =~ /gem|reagent/;
    select += "\n      , sum(case when stack='jar' then amount else 0 end) as jarred" if qargs[:type_filter] =~ /gem|reagent/;
    select += "\n      , c.name as name" if groupby =~ /char/;
    select += "\n      , l.abbr as loc" if groupby =~ /loc/;
    select += "\n      , i.noun as noun" if groupby =~ /noun/ or orderby =~ /noun/;
    select += "\n      , i.name as item";

    from = %{
      from item i
        inner join location l on i.location_id = l.id
        inner join character c on i.character_id = c.id};
    default_groupby = "\n    group by i.type, i.name";
    default_groupby += ", c.name" if groupby =~ /char/;
    default_groupby += ", l.abbr" if groupby =~ /loc/;
    default_groupby += ", i.noun" if groupby =~ /noun/;
    groupby = default_groupby;

    orderby = "\n    order by #{query_extras[:orderby]}" if query_extras.key?(:orderby);
    limit   = "\n    limit #{query_extras[:limit]}" if query_extras.key?(:limit);
    sql = "#{select} #{from} #{where} #{groupby} #{having}";
    sql += "\nunion all\n #{select.gsub(/[lic].(?:name|noun|abbr)/, "'total'")} #{from} #{where}\ngroup by i.type";
    sql += " #{orderby} #{limit}";
    _respond sql if @debug_sql;
    return sql.encode('UTF-8'), qargs;
  end;

  def self.count_item_sql(params, style = "");
    respond "+---------------- proc_start: #{@current_proc}" if @debug_sql;
    respond "+----params:#{params.inspect}" if @debug_sql || @debug_input;
    respond "+----style:#{style.inspect}" if @debug_sql;

    having = orderby = limit = "";
    where, qargs, extras = self.where_builder(params, 'item')
    query_extras = { :orderby => "c.name, l.id" }
    query_extras.merge!(extras) if !extras.empty?

    select = "
    select
        c.name as character
      , l.abbr as location
      , sum(case when i.stack='' then i.amount else 0 end) as count";
    select += "\n      , sum(case when i.type='box' then i.amount else 0 end) as boxes" if !qargs[:search_filter] && !qargs[:search_regex] && !qargs[:type_filter] && !qargs[:noun_filter];
    select += "\n      , i.name as item" if qargs.key?(:search_filter)
    from = %{
      from character c
        cross join location l
        left join item i on i.location_id = l.id and i.character_id = c.id  };

    default_groupby = "\n    group by c.name, l.id, l.abbr";
    default_groupby += ", i.name" if qargs.key?(:search_filter)
    groupby = default_groupby;

    orderby = "\n    order by #{query_extras[:orderby]}" if query_extras.key?(:orderby);
    sql = "#{select} #{from} #{where} #{groupby} #{having} #{orderby} #{limit}";
    return sql.encode('UTF-8'), qargs;
  end
  #------------------------------------------------------------------------------#
  # locations -- really should be pulled from the database, but meh.
  #------------------------------------------------------------------------------#
  @locations       = Hash.new;
  @locations["1"]  = { :id => "1", :name => 'hands', :abbr => 'hands', :type => 'inv' };
  @locations["2"]  = { :id => "2", :name => 'inventory', :abbr => 'inv', :type => 'inv' };
  @locations["6"]  = { :id => "6", :name => 'alongside', :abbr => 'alongside', :type => 'inv' };
  @locations["10"] = { :id => "10", :name => 'locker', :abbr => 'lo', :type => 'locker' };
  @locations["11"] = { :id => "11", :name => 'Wehnimer\'s Landing', :abbr => 'wl', :type => 'locker' };
  @locations["12"] = { :id => "12", :name => 'Teras Isle', :abbr => 'teras', :type => 'locker' };
  @locations["13"] = { :id => "13", :name => 'Solhaven', :abbr => 'sol', :type => 'locker' };
  @locations["14"] = { :id => "14", :name => 'River\'s Rest', :abbr => 'rr', :type => 'locker' };
  @locations["15"] = { :id => "15", :name => 'Icemule Trace', :abbr => 'im', :type => 'locker' };
  @locations["16"] = { :id => "16", :name => 'Zul Logoth', :abbr => 'zul', :type => 'locker' };
  @locations["17"] = { :id => "17", :name => 'Ta\'Illistim', :abbr => 'ti', :type => 'locker' };
  @locations["18"] = { :id => "18", :name => 'Ta\'Vaalor', :abbr => 'tv', :type => 'locker' };
  @locations["19"] = { :id => "19", :name => 'Mist Harbor', :abbr => 'fwi', :type => 'locker' };
  @locations["20"] = { :id => "20", :name => 'Cysaegir', :abbr => 'cy', :type => 'locker' };
  @locations["21"] = { :id => "21", :name => 'Kraken\'s Fall', :abbr => 'kf', :type => 'locker' };
  @locations["30"] = { :id => "30", :name => 'Astral Vault', :abbr => 'av', :type => 'locker' };
  @locations["40"] = { :id => "40", :name => 'Family Vault', :abbr => 'fam', :type => 'locker' };

  #------------------------------------------------------------------------------#
  # instance variables
  #------------------------------------------------------------------------------#
  @subscription         = nil;
  @character_id         = nil;
  @lumnis_status        = nil;
  @inventory_count      = 0;
  @manifest_count       = 0;
  @inv_retry            = 1;
  @manifest_retry       = 1;
  @containers           = [];
  @containers_noopen    = @settings_hash["container_noopen"];
  @containers_noopen_pattern = nil;
  @containers_noopen_pattern = /(#{@containers_noopen.join("|")})$/i if @containers_noopen.length > 0;
  @container_list_pattern = /<a exist="(?<id>\d+)" noun="(?<noun>[^"]+)">(?<name>[^<]+)</;
  @containers_to_close  = [];
  @empty_string         = ""; @empty_string = @empty_string.encode('UTF-8');
  @gui                  = false;
  @inv_items            = [];
  @inv_scan             = [];
  @locker_items         = [];

  @script                     = Script.current;
  @script.want_downstream     = false;
  @script.want_downstream_xml = true;
  #------------------------------------------------------------------------------#
  # thanks to LostRanger for this fix for missing lines in invfull:
  #------------------------------------------------------------------------------#
  @script.downstream_buffer.instance_variable_set(:@max_size, 4000)
  #------------------------------------------------------------------------------#
  # quiet_command by LostRanger, modded tiny bit by Xanlin
  #------------------------------------------------------------------------------#
  @script_name = Script.current.name;
  def self.anon_hook(prefix = '')
    now = Time.now
    return "#{@script_name}::#{prefix}_#{now.strftime("%Y-%m-%d_%H:%M:%S.%6N")}_#{Random.rand(10000)}";
  end

  def self.cleanup; [DownstreamHook, UpstreamHook].each { |provider| provider.list.find_all { |name| name.start_with?("#{@script_name}::") }.each { |name| provider.remove(name) }; }; end;

  def self.issue_command(command, start_pattern, end_pattern = /<prompt/, include_end = true, timeout = 5, silent = nil, usexml = true, quiet = true)
    result = []
    name = self.anon_hook(command.gsub(' ', '_'))
    filter = false

    save_script_silent = Script.current.silent
    save_want_downstream = Script.current.want_downstream
    save_want_downstream_xml = Script.current.want_downstream_xml

    Script.current.silent = silent if !silent.nil?
    Script.current.want_downstream = !usexml
    Script.current.want_downstream_xml = usexml

    begin
      Timeout::timeout(timeout, Interrupt) {
        DownstreamHook.add(name, proc { |line|
          if filter
            if line =~ end_pattern
              DownstreamHook.remove(name)
              filter = false
            else
              next(nil) if quiet
              line
            end
          elsif line =~ start_pattern
            filter = true
            next(nil) if quiet
            line
          else
            line
          end
        })
        fput command
        until (line = get) =~ start_pattern; end
        result << line.rstrip
        until (line = get) =~ end_pattern
          result << line.rstrip
        end
        if include_end
          result << line.rstrip
        end
      }
    rescue Interrupt
      DownstreamHook.remove(name);
      nil
    ensure
      DownstreamHook.remove(name)
      Script.current.silent = save_script_silent if !silent.nil?
      Script.current.want_downstream = save_want_downstream
      Script.current.want_downstream_xml = save_want_downstream_xml
    end
    return result
  end

  def self.client_command(command, start_pattern, end_pattern = /^(?:<pop(?:Bold|Stream)\/>)?<prompt/, quiet = @quiet, timeout = 5, include_end = true, silent = nil)
    return self.old_quiet_command(command, start_pattern, end_pattern, include_end, timeout) if @use_old_quiet_command == true;
    return self.issue_command(command, start_pattern, end_pattern, include_end, timeout, silent, true, quiet)
  end;

  #------------------------------------------------------------------------------#
  # quickdo -- with output
  #------------------------------------------------------------------------------#
  def self.quickdo(command_queue, success_pattern, speed = 3)
    return if command_queue.length < 1;
    queue    = command_queue;
    pattern  = success_pattern;
    flock    = speed;
    inflight = 0;
    output   = [];
    timeout  = queue.length * 2;
    begin;
      Timeout::timeout(timeout, Interrupt) {
        while queue.length > 0;
          put queue.pop;
          inflight += 1;
          while inflight > flock;
            nil until (m = pattern.match(get));
            output << m[0];
            inflight -= 1;
          end;
        end;
        inflight.times { nil until (m = pattern.match(get)); output << m[0] };
      }
    rescue Interrupt
      nil;
    end;
    return output;
  end;

  #------------------------------------------------------------------------------#
  # help & related
  #------------------------------------------------------------------------------#
  help_text = %{  ;inv help      > help text (this)       ;inv examples  > examples
    ;inv menu      > basic starter menu     ;inv changelog > changelog

    first parameter: action (default to refresh all if no parameters provided)
      options: refresh, query, sum (or total), export, reset, delete, drop
        refresh   load/update your database
        query     prints out results to your story window
        sum       less detail than query, aggregates by type and item
        count     shows totals by character and location
        export    export table or query to a file
        reset     clear everything and start over
        delete    delete stuff, can be complicated, more on this later

    second parameter: target (defaults to all or item)
      options: bank, char, item, inv, locker, tickets
        bank      bank account & silvers
        char      character info
        item      both inventory and lockers
        inv       inventory, but not lockers
        locker    locker(s), but not inventory
        tickets   ticket balance information

    optional parameters:
      char=name                      # supports wildcards
      game=gsiv                      # defaults to the current game
      type=gem                       # based on your GameObj type data.
      amount(<|<=|=|>|>=)42          # amount greater than, equal to, etc a number
      qty(<|<=|=|>|>=)42             # qty greater than, equal to, etc a number
      noun=stone                     # filter by item noun
      path=backpack                  # all items that start in a backpack
      stack=(jar|bundle|stack|pack)  # only jars implemented so far
      status=(empty|partial|full)    # to help find empty or full jars
      marked=Y                       # not recorded in standard lockers
      registered=Y                   # not recorded in standard lockers
      worn=                          # not yet implemented
      groupby=char                   # adds char column to sum/total queries
      orderby="path asc, qty desc"   # customize result order
      delay=6                        # delay N seconds before doing stuff (e.g. autostart)

    All other input is used as a search string in the primary name in the target.
    If no parameters are provided, defaults to `refresh all`
    If no applicable action & target are specified, defaults to searching items
    +---------------------------------------------------------------+
    exporting:
      ;inv export (char|item|inv|locker|bank|tickets|sbank|stickets) (optional parameters)
      - additional optional export parameters:
        format=(csv|txt|pipe)         default = csv
        dir="c:\\users\me\\desktop"   default = $lich_dir\\inv\\
        file="filename.ext"           default = target_(params)_timestamp.csv
    +---------------------------------------------------------------+
    most commands have abbreviations:
      q  = query      c = char        m = marked
      i  = item       g = game        r = registered
      in = inv        t = type        s = stack
      l  = locker     n = noun        status = status
      b  = bank       p = path        w = worn
    +---------------------------------------------------------------+
    settings (on/off is converted into true/false)
      ;inv --settings lists your current settings
      ;inv --jar=on/off will turn on/off looking in jars
      ;inv --stack=on/off will turn on/off reading stacks of notes (light and deep notes)
      ;inv --autofit=on/off will turn on/off table columns adjusting to fit content (on) or being ragged (off)
    };
  help_examples = %{
    examples:
      ;inv                           # refresh all
      ;inv query item golden glim    # contains the phrase golden glim
      ;inv q i golden glim           # contains the phrase golden glim
      ;inv q i n glim                # contains the phrase n glim
      ;inv q i gold*glim             # * is a wildcard, contains gold and glim
      ;inv q i =golden wand          # = exact match (not just contains)
      ;inv gold*                    # = can be used with wildcards
      ;inv type=wand gold            # all wands with gold in the name
      ;inv gold type=wand            # all wands with gold in the name
      ;inv gold t=wand               # all wands with gold in the name
      ;inv sapphire char=xanlin      # all sapphires in Xanlin's inv & lockers
      ;inv path=backpack char=xanlin # all items in Xanlin's backpack
      ;inv path=*sack                # all items in any sack
      ;inv count locker char=xanlin  # show locker item count for each of Xanlin's lockers};
  help_menu = "
      #{Inv_db.format_monsterbold("Run #1 first if your database is empty:")}
       1: <d cmd=\"#{$clean_lich_char}eq Script.run('inv_db','refresh all');Script.start('inv_db','menu')\">#{$clean_lich_char}inv_db refresh all</d> to create/update the database

       other examples:
       2: character list       <d cmd=\"#{$clean_lich_char}eq Script.run('inv_db','q char');Script.start('inv_db','menu')\">#{$clean_lich_char}inv_db query char</d>
       3: bank accounts        <d cmd=\"#{$clean_lich_char}eq Script.run('inv_db','q bank');Script.start('inv_db','menu')\">#{$clean_lich_char}inv_db q bank</d>
       4: landing bank total   <d cmd=\"#{$clean_lich_char}eq Script.run('inv_db','sum bank amount&gt;100000 elan');Script.start('inv_db','menu')\">#{$clean_lich_char}inv_db sum bank amount&gt;100000 elan</d>
       5: all gems in inv(s)   <d cmd=\"#{$clean_lich_char}eq Script.run('inv_db','q inv type=gem');Script.start('inv_db','menu')\">#{$clean_lich_char}inv_db q inv type=gem</d>
       6: your stuff           <d cmd=\"#{$clean_lich_char}eq Script.run('inv_db','q item char=#{XMLData.name}');Script.start('inv_db','menu')\">#{$clean_lich_char}inv_db q item c=#{XMLData.name}</d>
       7: all locker stuff     <d cmd=\"#{$clean_lich_char}eq Script.run('inv_db','q locker');Script.start('inv_db','menu')\">#{$clean_lich_char}inv_db q locker</d>
       8: all empty jars       <d cmd=\"#{$clean_lich_char}eq Script.run('inv_db','type=jar status=empty');Script.start('inv_db','menu')\">#{$clean_lich_char}inv_db type=jar status=empty</d>
       9: total gems           <d cmd=\"#{$clean_lich_char}eq Script.run('inv_db','sum type=gem');Script.start('inv_db','menu')\">#{$clean_lich_char}inv_db sum type=gem</d>
      10: total uncut diamonds <d cmd=\"#{$clean_lich_char}eq Script.run('inv_db','sum type=gem =uncut dia*');Script.start('inv_db','menu')\">#{$clean_lich_char}inv_db sum type=gem =uncut dia*</d>
      11: locker counts        <d cmd=\"#{$clean_lich_char}eq Script.run('inv_db','count char=#{XMLData.name}');Script.start('inv_db','menu')\">#{$clean_lich_char}inv_db count char=#{XMLData.name}</d>

      Add an optional delay for autostart:
          <d cmd=\"#{$clean_lich_char}autostart add --global #{Script.current.name} delay=6 @no_squelch\r\">#{$clean_lich_char}autostart add --global #{Script.current.name} delay=6 @no_squelch</d>
      To set autostart #{$clean_lich_char}repository to download updates:
          <d cmd=\"#{$clean_lich_char}autostart add --global repository download-updates\r\">#{$clean_lich_char}autostart add --global repository download-updates</d>
      To set #{Script.current.name} to auto-update:
          <d cmd=\"#{$clean_lich_char}repository set-updatable #{Script.current.name}\r\">#{$clean_lich_char}repository set-updatable inv_db</d>
      To update just your character info on logout:
          <d cmd=\"#{$clean_lich_char}alias add --global quit=;eq Script.run('#{Script.current.name}','refresh char');fput 'quit';\r\">;alias add --global quit=#{$clean_lich_char}eq Script.run('#{Script.current.name}','refresh char');fput 'quit'</d>
  ";
  help_changelog = %{  changelog:
      0.3.7.2 (2023-04-10)
        - fix to always update lumnis resource will reset weekly when lumnis is ready to reset
      0.3.7.1 (2023-04-09)
        - skip updating resource for those with no profession resource or favor
      0.3.7.0 (2023-04-09)
        - added lumnis
        - added resource
        - added society and citizenship to character
        - all filters now support regex
        - switch from duskruin view account to account verb
        - significant refactor of parameter handling and query generation
      0.3.6.7 (2023-03-31)
        - fix for reset
      0.3.6.6 (2023-03-31)
        - fix for schema update
      0.3.6.5 (2023-03-31)
        - fix family vault manifest inside locker on standard accounts
      0.3.6.4 (2023-03-27)
        - added astral vault, family vault
      0.3.6.3 (2023-03-14)
        - container open adjustment
      0.3.6.2 (2023-02-22)
        - settings_hash update
      0.3.6.1 (2023-02-22)
        - ruby 3.2 fix, File.exists? => File.exist?
      0.3.6 (2023-02-22)
        - refactoring code, ruby 3.2 fix
      0.3.5 (2023-01-23)
        - add version check before safe
};
=begin
      0.3.4 (2022-10-15)
        - fixed bug with bag of boldings skipping some lines
        - boh can now scan other types of bags of holding like vasculums, caboodles, tackle boxes
      0.3.3.06 (2022-07-26)
        - fixed f2p bank account bugs
      0.3.3.05 (2022-06-12)
        - inv_full pattern fix for mounts (monsterbold)
      0.3.3.04
        - added date format setting
        - fix for change to inventory container
      0.3.3.03 (2022-03-14)
        - fix for account type on f2ps being set to standard if they hadn't opened a bank account yet
      0.3.3.02 (2022-03-11)
        - fix for autostart sending an empty string in an array instead of an empty array
      0.3.3.01 (2022-03-03)
        - typo fix
      0.3.3.0 (2022-02-26)
        - updated ;invdb --settings
        - added handling for bags of holding -- Thanks Nisugi!
        - add custom bag of holdings names with ;invdb +boh Nisgui's special sack with things
        - remove custom bag of holdings names with ;invdb -boh Nisgui's special sack with things
        - tries to find nouns in locker items
      0.3.2.9 (2021-05-31)
        - added --use_old_quiet_command=true for strange issues that break current versions.
      0.3.2.8 (2021-05-25)
        - silence reading notes
      0.3.2.7 (2021-05-25)
        - set current area unknown if nil
        - remove bundle checking, since it breaks hiding and is noisy as fuck
      0.3.2.6 (2021-05-25)
        - only look for current area when refreshing character info, skip using location verb if room window is disabled or more than 2 people there
        - added bundles and stacks to stack types.  Only counts them when in inventory though.
        - removed locker refresh from default for f2ps
        - removed extra call to bank info on f2ps for character info
        - fixed nosquelch typo
      0.3.2.4 (2020-09-07)
      0.3.2.3 (2020-09-07)
        - fix for commas in bank account
      0.3.2.2 (2020-09-03)
        - oops, added Cysaegir to the lockers
      0.3.2.19 (2021-12-09)
        - jar pattern correction
      0.3.2.18 (2021-12-09)
        - because Naiken is rearranging things again...
      0.3.2.17 (2021-12-07)
        - added --silence_stack=off option to unsilence the results of peeking in jars/stacks
      0.3.2.16 (2021-12-07)
        - update to fix default settings
      0.3.2.15 (2021-12-05)
        - update for (Items: \d+) instead of displayed items
        - update for inventory full no longer saying 'wearing and carrying'
      0.3.2.14 (2021-12-01)
        - update for Naiken's new alongside inventory commands
        - added settings to turn on/off scanning stacks and jars
        - ;invdb --jar=on/off will turn on/off looking in jars
        - ;invdb --stack=on/off will turn on/off reading stacks of notes (light and deep notes)
        - ;invdb --autofit=on/off will turn on/off table columns adjusting to fit content (on) or being ragged (off)
      0.3.2.13 (2021-12-01)
        - updated to adjust for missing . in \(\d+ items displayed.\) for inventory full.
      0.3.2.12 (2021-11-14)
        - added export filename replacement keyword timestamp to be replaced with current timestamp
      0.3.2.11 (2021-11-13)
        - added export for sum bank, with target sbank,e.g. ;invdb export sbank
        - added export for sum tickets, with target stickets,e.g. ;invdb export stickets
        - switched peek_jar usage to peek_stack
      0.3.2.10 (2021-10-10)
        - disabling drop
        - added race and profession filter for querying characters
      0.3.2.1 (2020-09-03)
        - added Kraken's Fall bank
      0.3.2.0 (2020-09-03)
        - added Kraken's Fall locker
        - some merge logic updates
      0.3.1.9 (2020-06-15)
        - fix for locker info... again (?).
      0.3.1.8 (2020-05-23)
        - fix for user input confusion while getting inventory container
        - added hidden attribute for items (badges, soulstone, hairbeads, etc)
      0.3.1.7 (2020-04-21)
        - fix for feature concealing veils
      0.3.1.6 (2020-04-09)
        - fix for Vyrshkana's custom gameobj-data.xml file
      0.3.1.5 (2020-04-07)
        - added locker info fix for the warning when downgrading from premium to standard
        - added some basic callable methods for pass_thru and formatting output
      0.3.1.4 (2020-02-28)
        - added more logic to find area
        - fixed puts instead of gs_print
      0.3.1.2 (2019-12-01)
        - bugfix for miscounting items
      0.3.1.01 (2019-12-01)
        - messing with the exit conditions for dead LostRangers.
      0.3.1.0 (2019-11-21)
        - fix for missing lines in inventory full, credit to LostRanger: Script.current.downstream_buffer.instance_variable_set(:@max_size, 1000)
      0.3.0.9b (2019-11-16)
        - adjusted inv full regex
      0.3.0.9a (2019-11-16)
        - adjusted opening containers pattern for 'You pick at'
      0.3.0.8 (2019-11-16)
        - adjusted jarserve check to wait before opening containers
      0.3.0.7 (2019-11-13)
        - adjusted deplural for jar update
        - moved jarserve integration to only fire on inventory refresh instead of all the time
      0.3.0.6 (2019-11-13)
        - added jarserve2 wait and import
      0.3.0.5 (2019-11-11)
        - switch most of everything over to quiet_command to avoid squelching issues
        - add vacuum once every 12 hours (that's often, but it's quick -- and didn't help what I had hoped it would)
        - switched some variable (level,game) to XMLData instead of Char (infomon)
      0.3.0.4 (2019-09-24)
        - adjust already open pattern for 'doesn't seem to be any way...'
      0.3.0.3 (2019-09-21)
        - fixed count for f2p
      0.3.0.2
        - slowed down container actions on wizard
      0.3.0.1
        - added count action
      0.3.0.0
        - adjusted open/closing containers
      0.2.9.9 (2019-08-10)
        - query tickets (ticket_balance)
        - some stuff that isn't done yet
        - probably some other tweaks I forgot about
      0.2.9.8 (2019-06-27)
        - use inventory instead of inv to use commands in roundtime (per LostRanger tip)
      0.2.9.5 (2019-05-30)
        - container opening blacklist:
        - This is a global list, so you won't need to do the same containers on each character.
        - ;invdb --noopen <item name without long to add to noopen list>
        - ;invdb --open  <item name to remove from noopen list>
        - ;invdb --noopen
        - lists the containers on the noopen list
      0.2.9.4 (2019-05-26)
        - adjusted results highlight for regex searches
      0.2.9.3 (2019-05-26)
        - testing regex matching for items
        - multiple characters in search with pipe
      0.2.9 (2018-09-08)
        - open uncommon type for containers
        - stop opening my locket.
      0.2.8 (2018-08-31)
        - added inventory item counts to query character screen
        - changed character update to timestamp every update
      0.2.7 (2018-08-16)
        - just adding the fix for the change in collectibles
      0.2.6 (2018-08-08)
        - added more scripts for open/close checking
        - fixed untyped gems in jars with hyphens, untyped essences in jars
      0.2.5 (2018-08-05)
        - catch some additional open patterns
        - close containers before exit if failing to scrape
        - fix some options broken in prior update
      0.2.4 (2018-07-13)
        - removed other types from collectibles
        - wait until GameObjAdd etc is done
      0.2.3 (2018-07-08)
        - fix spacing issue with standard locker prename
        - made it easier to delete characters from the database
        - patched in collectible type
        - set type filter to have leading wildcard
      0.2.2 (2018-07-07):
        - fix rr / twilight locker inside the counter issue
      0.2.1 (2018-07-06):
        - fix safe puts for profanity
        - fix wizard fe output
        - break up help txt
      0.2.0 (2018-07-06):
        - added location filter, searches location name or abbr
        - game filter will now default to the current game (so gstest info doesn't get mixed in)
      0.1.9 (2018-07-05):
        - fixed stormfront inv window being empty after refresh
        - fixed jar issue on standard locker
        - fixed bank searching that I broke
        - improved profanity support (probably)
      0.1.8 (2018-07-01):
        - fixed not closing after opening secure gem pouches
        - started implementation of groupby
      0.1.7 (2018-06-29):
        - tweaked sql generation
        - added pivot columns for sum type=gem and reagent -- more for other stacks soon
        - started implementation of other stacks
        - started implementation of orderby
      0.1.6 (2018-06-29):
        - fix for startup abort to also accept delay parameter
        - cleanup some patterns, fixed locker bug?
        - fix premium 'you must visit your local locker' hanging
      0.1.5 (2018-06-28):
        - fix for peek_jar, now always includes a path
      0.1.4 (2018-06-28):
        - bugfix for :inv_full pattern
        - fix for export text/pipe
        - fix for only one bank account transfer stalling bank scrape
      0.1.3 (2018-06-27):
        - added option for sum|total. Like query, but aggregated
      0.1.2 (2018-06-26):
        - added abbreviation definitions before query output
        - made filters more flexible
      0.1.1 (2018-06-25):
        - Fixed some over squelching on premium accounts
        - Fixed profanity output
      0.1.0 (2018-06-22): Beta - first version on the repo
=end

  menu_width = 62 + (Script.current.name.length % 2 == 0 ? 0 : 1).to_i;
  help_hl = "  +#{"-" * menu_width}+";

  print_menu = proc {
    help_menu.gsub!('inv_db', Script.current.name);
    to_print = [];
    to_print << @mono_start;
    to_print << help_hl;
    center_spaces = " " * ((menu_width / 2) - (Script.current.name.length / 2)).to_i;
    to_print <<  "  |#{center_spaces}#{Script.current.name}#{center_spaces}|";
    to_print <<  help_hl;
    to_print <<  help_menu;
    to_print <<  help_hl;
    to_print <<  @mono_end;
    Inv_db.gs_print to_print.join("\n");
  }
  print_help = proc {
    help_text.gsub!(';inv', "#{$clean_lich_char}#{Script.current.name}");
    to_print = [];
    to_print << @mono_start;
    to_print << help_text;

    to_print << @mono_end;
    Inv_db.gs_print to_print.join("\n");
  };
  print_examples = proc {
    help_examples.gsub!(';inv', "#{$clean_lich_char}#{Script.current.name}");
    to_print = [];
    to_print << @mono_start;
    to_print << help_hl;
    to_print << help_examples;
    to_print << help_hl;
    to_print << @mono_end;
    Inv_db.gs_print to_print.join("\n");
  };
  print_changelog = proc {
    help_changelog.gsub!(';inv', "#{$clean_lich_char}#{Script.current.name}");
    to_print = [];
    to_print << @mono_start;
    to_print << help_hl;
    to_print << help_changelog;
    to_print << help_hl;
    to_print << @mono_end;
    Inv_db.gs_print to_print.join("\n");
  };
  (print_help.call; exit) if Script.current.vars[1] =~ /help|setup|\?/i;
  (print_menu.call; exit) if Script.current.vars[1] =~ /menu/i;
  (print_examples.call; exit) if Script.current.vars[1] =~ /examples/i;
  (print_changelog.call; exit) if Script.current.vars[1] =~ /changelog/i;
  #------------------------------------------------------------------------------#
  # startup delay for autostart
  # ;autostart add inv_db delay=6
  #------------------------------------------------------------------------------#
  startup_delay = ((Time.now - $login_time) < 12 ? 8 : 0);
  startup_delay = $2.to_i if Script.current.vars[0] =~ /\b(delay)=(\d+).*/i;
  _respond "invdb startup_delay = #{startup_delay}" if startup_delay > 0 && @debug;
  sleep startup_delay;

  if Script.current.vars[0] !~ /^[qcse]/ and Script.current.vars[0] !~ /\bchar\b/
    waiton_scripts = ["updater", "repository", "GameObjAdd", "GameObjAddMore", "xmlpatch", "box", "go2"]
    waiton_scripts.each { |s|
      if Script.running?(s)
        respond "Waiting for #{s} to finish"
        sleep 1 while Script.running?(s);
      end
    }
  end
  # sleep 1 while Script.running?("updater") || Script.running?("repository") || Script.running?("go2") || Script.running?("GameObjAdd") || Script.running?("GameObjAddMore") || Script.running?("xmlpatch") || Script.running?("box");
  #------------------------------------------------------------------------------#
  # start infomon if it's not running
  #------------------------------------------------------------------------------#
  Script.start('infomon') if !running?('infomon');
  #------------------------------------------------------------------------------#
  # check conditions are conducive to running -- not dead/stunned/etc
  # for those who autostart the script but might be reconnecting
  #------------------------------------------------------------------------------#
  if XMLData.indicator["IconDEAD"] == "y" or dead? or stunned? or checkrt > 0;
    # should still be able to query and junk in roundtime or while dead
    if Script.current.vars[0] !~ /^[qcse]/ and Script.current.vars[0] !~ /\bchar\b/
      _respond "This seems like a bad time...";
      exit;
    end;
  end;
  #------------------------------------------------------------------------------#
  # for whatever reason, sometimes type_data is empty for some people
  #------------------------------------------------------------------------------#
  if GameObj.type_data.keys.length < 2 and File.exist?("#{$lich_dir}data/gameobj-data.xml");
    GameObj.load_data;
    sleep 1;
  end;
  #------------------------------------------------------------------------------#
  # local variables
  #------------------------------------------------------------------------------#
  start_sorter = nil
  refresh_bank = refresh_char = refresh_item = refresh_locker = refresh_inv = nil
  open_containers = close_containers = nil
  scrape_bank = nil;
  bank_accounts = Hash.new(0); total_from_feed = 0;
  insert_temp_item_inv = insert_temp_item_locker = nil
  scan_parse_item_lines = nil
  locker = locker_info = locker_info_result = nil;
  @locker_info_run = false
  @locker_location = nil
  locker_item_capacity = locker_look_count = nil
  not_in_locker = true;
  locker_standard = locker_standard_debug = nil;
  locker_premium = nil
  locker_manifest_scrape = nil; parse_manifest = nil;
  scan_parse_item_lines = nil;
  table_format = table_hl = table_headers = nil
  action = target = nil
  input_params = character_filter = location_type_filter = nil
  style = nil
  item_path = nil
  match_fail_lines = []
  match_fail_count = 0
  db = nil
  stmt = nil
  #------------------------------------------------------------------------------#
  # variables
  #------------------------------------------------------------------------------#
  empty_string = String.new.encode('UTF-8')
  # Todo:Move pattern: current_area replace
  # current_area = Room.current.location.to_s.gsub(/the (town|city|village|plains|free port|lowlands|tunnels and caverns|foothills|holdings|southern part|northern slopes) of /i,"").encode('UTF-8')
  # .gsub(/(the |\s?"the)?(town|hamlet|city|village|plains|free port|lowlands|tunnels and caverns|foothills|holdings|southern part|northern slopes|northern reaches|environs|somewhere)( o[fn] )?|,.*$|^ ?"?the |"$/i,"")

  def self.current_area();
    current_area = nil
    if !Room.current.id.nil?;
      if !Room.current.location.nil?;
        current_area = Room.current.location.to_s;
      else; # room not tagged with location
        current_area = "#{Room[Room.current.find_nearest_by_tag("town")].location}";
      end;
    else; # unmapped room
      if XMLData.room_window_disabled == false and GameObj.pcs.size < 3
        location_result = dothistimeout 'location', 1, /^You carefully survey your surroundings and guess that your current location is (.*?) or somewhere close to it\.$|^You can't do that while submerged under water\.$|^You can't do that\.$|^It would be rude not to give your full attention to the performance\.$|^You can't do that while hanging around up here!$|^You are too distracted by the difficulty of staying alive in these treacherous waters to do that\.$|^You carefully survey your surroundings but are unable to guess your current location\.$|^Not in pitch darkness you don't\.$|^That is too difficult to consider here\.$/
        if location_result =~ /^You carefully survey your surroundings and guess that your current location is (.*?) or somewhere close to it\.$/
          current_area = $1
        end
      end
    end;
    current_area = current_area.gsub(/(the )?(town|hamlet|city|village|plains|free port|lowlands|tunnels and caverns|foothills|holdings|southern part|northern slopes|northern reaches|environs|somewhere)( o[fn] )?|,.*$|^the /i, "").encode('UTF-8')
    current_area = "unknown" if current_area.nil?
    return current_area;
  end

  sql = String.new.encode('UTF-8')
  @db_changes = Hash.new
  changes_template = { :inserted => 0, :updated => 0, :deleted => 0 }
  @db_changes[:account]  = {}.merge(changes_template)
  @db_changes[:bank]     = {}.merge(changes_template)
  @db_changes[:tickets]  = {}.merge(changes_template)
  @db_changes[:char]     = {}.merge(changes_template)
  @db_changes[:item]     = {}.merge(changes_template)
  @db_changes[:lumnis]   = {}.merge(changes_template)
  @db_changes[:resource] = {}.merge(changes_template)

  start_sorter = false
  sorter_handler = proc { (Script.kill("sorter"); wait_until { !running? "sorter" }; start_sorter = true;) if Script.running? "sorter" }
  #------------------------------------------------------------------------------#
  # Silencers/Squelchers
  #------------------------------------------------------------------------------#
  (@no_squelch = true;) if Script.current.vars[0] =~ /@no_?squelch/
  (@autofit = true;) if Script.current.vars[0] =~ /@autofit/
  @quiet = true; @quiet = false if @no_squelch;

  inv_open_close_squelch_pattern = /It appears to be locked|There doesn't seem to be any way to do that|^Try holding it first|You need to be holding|You are holding.*|You are wearing.*|You (open|close|push|pull|flip).*|^You absentmindedly fiddle with your|already open|open already|^You pick at the knot holding|^You tie your|^You carefully unwind|^You flip the cover|^Hooking a finger into|^Lightly brushing your fingers|^Brushing your fingers against|^Pinching the toggle|^As you reach for the flap|^You rub your hand across|^You focus for a moment/i

  squelch_remove = proc {
    respond "HookRemoved" if @debug_hook
    respond if @debug_hook
    DownstreamHook.remove('inv_db')
    sleep 0.05
  }

  squelch = proc { |squelch_pattern|
    respond "HookStart: #{squelch_pattern}" if @debug_hook
    respond if @debug_hook
    squelch_remove.call
    hook_action = proc { |server_string|
      next if server_string.strip.length == 0
      next if server_string =~ squelch_pattern
      server_string
    }
    DownstreamHook.add("inv_db", hook_action) if !@no_squelch
    sleep 0.05
  };

  before_dying {
    squelch_remove.call
    start_script "sorter" if start_sorter
  }
  # need to move patterns to inv_db
  # patterns[:container_open] =
  patterns = Hash.new
  patterns[:bank]             = / *(?<bank>\w[^:]+): (?<amount>[,\d]+)/
  patterns[:bank_single]      = /You currently have an account with the (?<bank>.*?) in the amount of (?<amount>[,\d]+) silver/i
  patterns[:bank_transfers]   = /You currently have (?<transfers>[,\d]+) inter-town bank transfer options? available/i
  patterns[:bank_break]       = /You currently have (?<transfers>[,\d]+) inter-town bank transfer options? available/i
  patterns[:bank_f2p]         = /You can deposit up to a maximum of (?<max>[,\d]+)/i
  patterns[:bank_none]        = /You haven't opened a bank account yet/
  patterns[:debt]             = /In the back of your mind you remember you owe a debt of (?<debt>[,\d]+) silvers? in the town of (?<town>.*)\./

  patterns[:inv_count]        = /\((?:Items: )?(?<count>\d+)(?: items? displayed.?)?\)|^You have nothing|^You are carrying nothing/
  patterns[:inv_look]         = /(?:(?:Peering into|[IO]n) .* <a exist="(-?\d+)"[^>]*>([^<]*)<\/a>,? you see )|(?:[OI]n the <a exist="(-?\d+)"[^>]*>([^<]*)<\/a>:\s*$)|There is nothing [io]n there|That is closed.|I could not find what you were referring to\./
  patterns[:inv_break]        = /\((?:Items: )?(?<count>\d+)(?: items? displayed.?)?\)|Obvious items?: *(?<count>\d+)|^Your locker is currently holding (?<count>\d+) items? out of a maximum of (?<locker_max>\d+)|^You have nothing|^You are carrying nothing/
  patterns[:inv_start]        = /You are (carrying|currently|holding|wearing|currently mounted)/
  patterns[:inv_full]         = /^(?<depth> +)(?:<pushBold\/>)?(?<pre>[^<]+)? ?<a exist="(?<exist>-?\d+)" noun="(?<noun>[^"]*?)">(?<name>[^<]*?)<\/a>(?:<popBold\/>)?(?<post>[^\(\r\n]*)?(?<attrs>\(.*)?/i
  patterns[:inv_full_noxml]   = /^(?<depth> +)(?<name>[^\(]+?)(?<attrs>\(.*)?$/
  patterns[:jar]              = /^Inside the (?<pre>.*?)<a exist="(?<exist>-?\d+)" noun="(?<noun>[^"]*)">[^<]*<\/a>.*? you see (?<count>\d+) portions? of (?<name>.*?)\. *It is (?<status>.*?)\./i
  patterns[:jar_simple]       = /^Inside the .*? you see (?<amount>\d+) portions? of .*?\. *It is (?<status>.*?)\./

  patterns[:locker_info]      = /You possess locker(?<multi>s)|Your locker(?<multi>s)? in .* are currently being swapped|Your locker is currently located in the town of (?<town>.*?)\.|Your locker(?<town> )/
  patterns[:locker_open]      = /Your locker is currently holding (?<count>[,\d]+) items? out of a maximum of (?<max>[,\d]+)|That is already open/
  patterns[:locker_count]     = /Your locker is currently holding (?<count>[,\d]+) items? out of a maximum of (?<locker_max>[,\d]+)/

  patterns[:locker_container] = /[IO]n a.*?(?:armor|weapon|clothing|deep|magical item) (?<noun>stand|rack|wardrobe|chest|bin)/i
  patterns[:manifest_count]   = /Obvious items?: *(?<count>\d+)/
  patterns[:manifest_break]   = /Obvious items?: *(?<count>\d+)|You must have a Premium subscription|There are no items in this locker|Your lockers in .*?are currently being swapped|You must first visit your local locker before using the LOCKER MANIFEST command in this town./
  patterns[:manifest_start]   = /^Thinking back, you recall|^Looking in front of you, you see the contents of your locker/
  patterns[:manifest_outside] = /^(?:<popBold\/>)?(?<depth> <d.*?d> +|  +)(?<pre>an |a )?(?<name>[^\(]*?)(?:containing (?<post>[^\(]*?))?(?<attrs>\(.*)?$/
  patterns[:manifest_inside]  = /^(?:<popBold\/>)?(?<depth> +)(?<pre>[^<]+ ?)?<a exist="(?<exist>-?\d+)" noun="(?<noun>[^"]*)">(?<name>[^<]*)<\/a>(?<post>[^\(]*)?(?<attrs>\(.*)?/
  patterns[:manifest]         = Regexp.union(patterns[:manifest_outside], patterns[:manifest_inside])

  #------------------------------------------------------------------------------#
  # sqlite
  #------------------------------------------------------------------------------#
  sqlite_version = Inv_db.sqlite_version
  if Gem::Version.new(sqlite_version) < Gem::Version.new('3.8.3')
    Inv_db.gs_print "#{Script.current.name} requires sqlite_version: 3.8.3+ ... exiting"
    exit
  end

  db = Inv_db.open

  db.create_function('regexp', 2) do |func, pattern, expression|
    regexp = Regexp.new(pattern.to_s, Regexp::IGNORECASE)
    if expression.to_s.match(regexp)
      func.result = 1
    else
      func.result = 0
    end
  end
  #------------------------------------------------------------------------------#
  # Reset / Drop tables
  #------------------------------------------------------------------------------#
  def self.drop_tables(target = nil)
    db = Inv_db.open();
    begin
      (db.execute("drop table if exists silver");) if target =~ /bank|all/i
      (db.execute("drop table if exists bank");) if target =~ /bank|all/i
      (db.execute("drop table if exists tickets");) if target =~ /tickets|all/i
      (db.execute("drop table if exists location");) if target =~ /all/i

      (db.execute("drop table if exists item");) if target =~ /item|all/i
      (db.execute("drop table if exists item_detail");) if target =~ /detail|all/
      # (db.execute("drop table if exists item_property");) if target =~ /all/
      (db.execute("drop table if exists item_note");) if target =~ /note|all/
      # (db.execute("drop table if exists item_recall") ;) if target =~ /recall|all/

      # (db.execute("drop table if exists profile") ;) if target =~ /all|profile/
      # (db.execute("drop table if exists simucoin") ;) if target =~ /all|simucoin/
      (db.execute("drop table if exists resource");) if target =~ /all|resource/
      (db.execute("drop table if exists lumnis");) if target =~ /all|lumnis/
      (db.execute("drop table if exists account");) if target =~ /all/
      (db.execute("drop table if exists character");) if target =~ /all/i

      db.execute('pragma user_version=0')
      Inv_db.instance_variables.each do |i|
        Inv_db.remove_instance_variable(i)
      end
    rescue SQLite3::BusyException
      sleep 0.1
      retry
    ensure
      db.close() if db;
    end
    Inv_db.gs_print Inv_db.format_monsterbold(target == "all" ? "invdb database reset." : "#{target} table(s) dropped")
    exit
  end;
  #------------------------------------------------------------------------------#
  # schema
  #   todo: db.execute_batch instead? => didn't work as expected
  #   todo: database and schema versioning => upgrade/alter handling
  #------------------------------------------------------------------------------#
  user_version = db.get_first_value('pragma user_version;')

  if user_version == 0
    begin
      sql = %{
      create table if not exists character (
          id            integer not null primary key autoincrement
        , name          text    not null            --# XMLData.name
        , game          text    not null default '' --# XMLData.game
        , account       text    not null default '' --#
        , prof          text    not null default '' --# Stats.prof
        , race          text    not null default '' --# Stats.race
        , level         integer not null default 0  --# XMLData.level.to_i
        , exp           integer not null default 0  --# Stats.exp
        , area          text    not null default '' --# Room.current.location
        , subscription  text    not null default '' --# from locker info
        , locker        text    not null default '' --# from locker info
        , citizenship   text    not null default '' --# Char.citizenship
        , society       text    not null default '' --# Society.status
        , society_rank  text    not null default '' --# Society.rank
        , timestamp     integer not null default 0
        , unique (name,game)
      );};
      db.execute(sql)

      sql = %{
      create table if not exists bank (
          id      integer not null primary key autoincrement
        , name    text    not null unique
        , abbr    text    not null unique
      );};
      db.execute(sql)

      sql = %{
        with defaults(id,name,abbr) as (values
           (1, 'First Elanith Secured Bank'   ,'wl')
          ,(2, 'Great Bank of Kharam-Dzu'     ,'teras')
          ,(3, 'Vornavis Bank of Solhaven'    ,'sol')
          ,(4, 'Bank of Torre County'         ,'rr')
          ,(5, 'Icemule Trace Bank'           ,'im')
          ,(6, 'Bank of Kharag ''doth Dzulthu','zul')
          ,(7, 'United City-States Bank'      ,'en')
          ,(8, 'Four Winds Bank'              ,'fwi')
          ,(9, 'Cysaegir Bank'                ,'cy')
          ,(11,'Kraken''s Fall Bank'          , 'kf')
          ,(99,'Total'                        ,'total')
        )
        insert into bank(id,name,abbr)
        select id,name,abbr
        from defaults d
        where not exists (
          select 1
          from bank b
          where b.name = d.name
        )
        order by id;
      };
      db.execute(sql)

      sql = %{
      create table if not exists silver (
          character_id integer not null references character(id)
        , bank_id      integer not null references bank(id)
        , amount       integer not null
        , timestamp    integer not null
        , unique (character_id, bank_id)
      );};
      db.execute(sql)

      sql = %{
      create table if not exists location (
          id      integer not null primary key
        , type    text    not null
        , name    text    not null unique
        , abbr    text    not null unique
      );};
      db.execute(sql)

      sql = %{
        with defaults(id,type,name,abbr) as (values
           (1 ,'inv'   ,'hands'              ,'hands')
          ,(2 ,'inv'   ,'inv'                ,'inv')
          ,(3 ,'inv'   ,'location'           ,'loc')
          ,(4 ,'inv'   ,'container'          ,'con')
          ,(5 ,'inv'   ,'worn'               ,'worn')
          ,(6 ,'inv'   ,'alongside'          ,'alongside')
          ,(10,'locker','locker'             ,'locker')
          ,(11,'locker','Wehnimer''s Landing','wl')
          ,(12,'locker','Teras Isle'         ,'teras')
          ,(13,'locker','Solhaven'           ,'sol')
          ,(14,'locker','River''s Rest'      ,'rr')
          ,(15,'locker','Icemule Trace'      ,'im')
          ,(16,'locker','Zul Logoth'         ,'zul')
          ,(17,'locker','Ta''Illistim'       ,'ti')
          ,(18,'locker','Ta''Vaalor'         ,'tv')
          ,(19,'locker','Mist Harbor'        ,'fwi')
          ,(20,'locker','Cysaegir'           ,'cy')
          ,(21,'locker','Kraken''s Fall'     ,'kf')
          ,(30,'locker','Astral Vault'       ,'av')
          ,(40,'locker','Family Vault'       ,'fam')
        )
        insert into location(id,type,name,abbr)
        select id,type,name,abbr
        from defaults d
        where not exists (
          select 1
          from location l
          where l.name = d.name
        )
        order by id
      };
      db.execute(sql)

      sql = %{
      create table if not exists item (
          character_id   integer not null references character(id)
        , location_id    integer not null references location(id)
        , level          integer not null default 0
        , path           text    not null default ''
        , type           text    not null default ''
        , name           text    not null
        , noun           text    not null default ''
        , amount         integer not null
        , stack          text    not null default ''
        , status         text    not null default ''
        , marked         text    not null default ''
        , registered     text    not null default ''
        , worn           text    not null default ''
        , hidden         text    not null default ''
        , timestamp      integer not null
        , unique(name, character_id, location_id, path, marked, registered)
      );};
      db.execute(sql)

      sql = "create index if not exists ix_item_name on item(name);";
      db.execute(sql)

      respond "initial schema confirmed" if @debug
    rescue SQLite3::BusyException
      sleep 0.1
      retry
      #  ensure
      #    #db.close if db
    end
    db.execute('pragma user_version=1')
    user_version = db.get_first_value('pragma user_version;')
  end

  if user_version == 1
    db.execute('pragma user_version=2');
    user_version = db.get_first_value('pragma user_version;')
  end;

  if user_version == 2
    sql = %{
      create table if not exists tickets (
           character_id   integer not null
         , source         text    not null
         , amount         integer not null
         , currency       text    not null
         , timestamp      integer not null
         , unique(character_id, source)
    );
    };
    db.execute(sql)

    db.execute('pragma user_version=3')
    user_version = db.get_first_value('pragma user_version;')
  end

  if user_version == 3
    if !db.execute2("select * from item limit 0")[0].include?("hidden")
      sql = %{
        alter table item add column hidden text default ''
        };
      db.execute(sql)
    end
    db.execute('pragma user_version=4')
    user_version = db.get_first_value('pragma user_version;')
  end

  if user_version == 4
    sql = %{
        with defaults(id,type,name,abbr) as (values
          (21,'locker','Kraken''s Fall'      ,'kf')
        )
        insert into location(id,type,name,abbr)
        select id,type,name,abbr
        from defaults d
        where not exists (
          select 1
          from location l
          where l.name = d.name or l.id = d.id
        )
        order by id
      };
    db.execute(sql)
    db.execute('pragma user_version=5')
    user_version = db.get_first_value('pragma user_version;')
  end
  if user_version == 5
    sql = %{
        with defaults(id,name,abbr) as (values
          (11,'Kraken''s Fall Bank', 'kf')
        )
        insert into bank(id,name,abbr)
        select id,name,abbr
        from defaults d
        where not exists (
          select 1
          from bank b
          where b.name = d.name or b.id = d.id
        )
        order by id;
      };
    db.execute(sql)
    sql = "update bank set id = 99 where name='Total'"
    db.execute(sql)
    db.execute('pragma user_version=6')
    user_version = db.get_first_value('pragma user_version;')
  end
  if user_version == 6
    sql = "delete from location where id >= 20"
    db.execute(sql)
    sql = %{
        with defaults(id,type,name,abbr) as (values
          (20,'locker','Cysaegir'      ,'cy'),
          (21,'locker','Kraken''s Fall'      ,'kf')
        )
        insert into location(id,type,name,abbr)
        select id,type,name,abbr
        from defaults d
        where not exists (
          select 1
          from location l
          where l.name = d.name or l.id = d.id
        )
        order by id
      };
    db.execute(sql)
    db.execute('pragma user_version=7')
    user_version = db.get_first_value('pragma user_version;')
  end
  if user_version == 7
    sql = %{
      with defaults(id,type,name,abbr) as (values (6 ,'inv' ,'alongside' ,'alongside'))
      insert into location(id,type,name,abbr)
      select id,type,name,abbr
      from defaults d
      where not exists (
        select 1
        from location l
        where l.name = d.name
      )
    };
    db.execute(sql)
    db.execute('pragma user_version=8')
    user_version = db.get_first_value('pragma user_version;')
  end
  if user_version == 8
    db.execute("delete from location where abbr in ('av','fam')")
    sql = %{
      with defaults(id,type,name,abbr) as (values
          (30,'locker' ,'Astral Vault' ,'av')
         ,(40,'locker' ,'Family Vault' ,'fam')
        )
      insert into location(id,type,name,abbr)
      select id,type,name,abbr
      from defaults d
      where not exists (
        select 1
        from location l
        where l.id = d.id
      )
    };
    db.execute(sql)

    if !db.execute2("select * from character limit 0")[0].include?("subscription")
      db.execute("alter table character rename to old_character_table")
      sql = %{
        create table if not exists character (
          id            integer not null primary key autoincrement
        , name          text    not null            --# XMLData.name
        , game          text    not null default '' --# XMLData.game
        , account       text    not null default '' --# Account.name or account_verb
        , prof          text    not null default '' --# Stats.prof
        , race          text    not null default '' --# Stats.race
        , level         integer not null default 0  --# XMLData.level.to_i
        , exp           integer not null default 0  --# Stats.exp
        , area          text    not null default '' --# Room.current.location
        , subscription  text    not null default '' --# Account.subscription or locker info
        , locker        text    not null default '' --# from locker info # for non premium
        , timestamp     integer not null default 0
        , unique (name,game)
      );};
      db.execute(sql)
      sql = %{
        insert into character(id, name, game, account, prof, race, level, exp, area, subscription, locker, timestamp)
        select id, name, game, '', prof, race, level, exp, area, account_type, locker, timestamp from old_character_table
      }
      db.execute(sql)
      db.execute("drop table old_character_table")
    end

    db.execute('pragma user_version=9')
    user_version = db.get_first_value('pragma user_version;')
  end
  if user_version == 9
    respond "Updating database schema"
    sql = %{
        create table if not exists lumnis (
          character_id integer  not null primary key references character(id)
        , status        text    not null default ''
        , double        text    not null default 0
        , triple        text    not null default 0
        , total         text    not null default 0
        , start_day     text    not null default ''
        , start_time    text    not null default ''
        , last_schedule text    not null default ''
        , timestamp     integer not null default 0
      );};
    db.execute(sql)

    sql = %{
        create table if not exists resource (
          character_id  integer not null primary key references character(id)
        , energy        text    not null default ''
        , weekly        integer not null default 0
        , total         integer not null default 0
        , suffused      integer not null default 0
        , favor         integer not null default 0
        , bonus         integer not null default 0
        , timestamp     integer not null default 0
      );};
    db.execute(sql)

    sql = %{
        create table if not exists account (
          account        text    not null primary key
        , premium_points integer not null default 0
        , simucoin       integer not null default 0
        , timestamp      integer not null default 0
      );};
    db.execute(sql)

    db.execute("alter table character add citizenship text not null default ''")  if !db.execute2("select * from character limit 0")[0].include?("citizenship")
    db.execute("alter table character add society text not null default ''")      if !db.execute2("select * from character limit 0")[0].include?("society")
    db.execute("alter table character add society_rank text not null default ''") if !db.execute2("select * from character limit 0")[0].include?("society_rank")

    db.execute('pragma user_version=10')
    user_version = db.get_first_value('pragma user_version;')
  end
  # if user_version == 10
  # end
  #------------------------------------------------------------------------------#
  # temp tables for refresh
  #------------------------------------------------------------------------------#
  if user_version
    sql = %{
    create temporary table if not exists temp_item (
        character_id   integer not null references character(id)
      , location_id    integer not null references location(id)
      , level          integer not null default 0
      , path           text    not null default ''
      , type           text    not null default ''
      , name           text    not null
      , noun           text    not null default ''
      , amount         integer not null
      , stack          text    not null default ''
      , status         text    not null default ''
      , marked         text    not null default ''
      , registered     text    not null default ''
      , hidden         text    not null default ''
      , worn           text    not null default ''
      , update_noun    int     not null default 0
      , gs_id          int     null
      , timestamp      integer not null
      --, unique(name, character_id, location_id, path, marked, registered)
    );}
    db.execute(sql)

    sql = %{
    create temporary table if not exists temp_silver (
         character_id   integer not null
       , bank           text    not null
       , amount         integer not null
       , timestamp      integer not null
       , unique(character_id, bank)
    );};
    db.execute(sql)

    sql = %{
      create temporary table if not exists temp_tickets (
           character_id   integer not null
         , source         text    not null
         , amount         integer not null
         , currency       text    not null
         , timestamp      integer not null
         , unique(character_id, source)
    );};
    db.execute(sql)
  end

  #------------------------------------------------------------------------------#
  # deletes
  #------------------------------------------------------------------------------#
  delete_bank = proc { |params|
    @calling_proc = @current_proc
    @current_proc = "delete_bank"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    _where, qargs, _extras = self.where_builder(params)
    sql = %{
      delete from silver
      where character_id = (
        select id
        from character
        where name like :character_filter
          and game like :game_filter
        )
    }
    _rows, changes = self.execute(sql, qargs, db)
    @db_changes[:bank][:deleted] += changes
  }

  delete_tickets = proc { |params|
    @calling_proc = @current_proc
    @current_proc = "delete_bank"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    _where, qargs, _extras = self.where_builder(params)
    sql = %{
      delete from tickets
      where character_id = (
        select id
        from character
        where name like :character_filter
          and game like :game_filter
        )
    }
    _rows, changes = self.execute(sql, qargs, db)
    @db_changes[:tickets][:deleted] += changes
  }
  delete_item = proc { |params|
    @calling_proc = @current_proc
    @current_proc = "delete_inv"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    _where, qargs, _extras = self.where_builder(params)
    sql = %{
    delete from item}
    if qargs
      sql += "\n    where 1=1"
      sql += "\n      and exists ( select 1 from character c where item.character_id = c.id " if qargs[:character_filter] || qargs[:game_filter]
      sql += "\n        and c.name like :character_filter" if qargs[:character_filter] && !qargs[:char_array]
      sql += "\n        and c.name in ('#{qargs[:char_array].join("','")}')" if qargs[:char_array]
      sql += "\n        and c.game like :game_filter " if qargs[:game_filter]
      sql += "\n      )"                              if qargs[:character_filter] || qargs[:game_filter]
      sql += "\n      and exists ( select 1 from location l where item.location_id = l.id " if qargs[:location_type_filter]
      sql += "\n        and l.type like :location_type_filter" if qargs[:location_type_filter]
      sql += "\n      )" if qargs[:location_type_filter]
      sql += "\n      and item.amount #{qargs[:amount_filter]}" if qargs[:amount_filter]
      sql += "\n      and item.type like :type_filter"   if qargs[:type_filter]
      sql += "\n      and item.path like :path_filter "  if qargs[:path_filter]
      sql += "\n      and item.noun like :noun_filter"   if qargs[:noun_filter]
      sql += "\n      and item.name like :search_filter" if qargs[:search_filter]
      sql += "\n      and item.stack like :stack_filter" if qargs[:stack_filter]
      sql += "\n      and item.status like :status_filter"   if qargs[:status_filter]
      sql += "\n      and item.marked like :marked_filter"   if qargs[:marked_filter]
      sql += "\n      and item.registered like :registered_filter" if qargs[:registered_filter]
      # sql += "\n      and i.worn like :worn_filter"   if qargs[:worn_filter]
    end
    _rows, changes = self.execute(sql, qargs, db)
    @db_changes[:item][:deleted] += changes
  }

  delete_char = proc { |params|
    @calling_proc = @current_proc
    @current_proc = "delete_char"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    _where, qargs, _extras = self.where_builder(params)
    sql = %{
    delete from character
    where name like :character_filter
      and game like :game_filter}
    _rows, changes = self.execute(sql, qargs, db)
    @db_changes[:char][:deleted] += changes
  }
  #------------------------------------------------------------------------------#
  # account
  #------------------------------------------------------------------------------#

  def self.account_get()
    if defined?(Account)
      @account_name = Account.name if Account.name.to_s.length > 2
      @subscription = Account.subscription.downcase
      @subscription = 'f2p' if @subscription =~ /^free/i
      @locker_location = 'multi' if @subscription == 'premium'
    end
    if @account_name.nil? or @subscription.nil?
      @account_name, @subscription = self.account_verb
    end
    return @account_name, @subscription
  end

  def self.account_lookup(db = nil, name = nil, game = nil)
    close_db = false
    (close_db = true; db = Inv_db.open) if db.nil?
    name = XMLData.name if name.nil?
    game = XMLData.game if game.nil?
    qargs = { :name => name, :game => game }
    sql = %{ select account, subscription from character where name = :name and game = :game limit 1 }
    account_name, subscription = self.execute2(sql, qargs, db)[1]
    db.close if close_db
    return account_name, subscription
  end

  def self.account_verb();
    command       = "account";
    start_pattern = /^Game|^Account/i
    data          = self.client_command(command, start_pattern);
    account_name, subscription, instance = nil
    data.each { |l|
      a = l.split(/: */)
      instance = a.last.downcase if a.first =~ /Game Instance/
      account_name = a.last if a.first =~ /Account Name/
      subscription = a.last.downcase if a.first =~ /Account Type|Subscription/
    }
    return account_name, subscription
  end;

  #------------------------------------------------------------------------------#
  # character
  #   todo: Soliere wants all the things (stats,skills,profile,society)
  #------------------------------------------------------------------------------#
  def self.citizenship_info
    if defined?(Char.citizenship)
      citizenship = Char.citizenship
    else
      citizenship = "error"
    end
    return citizenship;
  end

  def self.society_info
    societies = {
      "Council of Light"     => "CoL",
      "Order of Voln"        => "Voln",
      "Guardians of Sunfist" => "GoF",
      "None"                 => "none"
    }
    society_status = (defined?(Society.status) ? Society.status : "")
    society = societies[society_status] if !Society.status.nil?
    society = society_status if society.nil?
    society_rank = (defined?(Society.rank) ? Society.rank : "")
    return society.encode('UTF-8'), society_rank.to_s.encode('UTF-8')
  end

  def self.character_insert(name = nil, game = nil, db = nil)
    Inv_db.gs_print("intial character_insert") if @debug
    close_db = false
    (close_db = true; db = Inv_db.open) if db.nil?
    name = XMLData.name if name.nil?
    game = XMLData.game if game.nil?
    current_area = self.current_area;
    @account_name, @subscription = self.account_get if @account_name.nil? or @subscription.nil?
    @locker_location = "" if @locker_location.nil?
    society, society_rank = self.society_info
    citizenship = self.citizenship_info
    cparams = {
      :name         => name.encode('UTF-8'),
      :game         => game.encode('UTF-8'),
      :account      => @account_name,
      :prof         => (defined?(Stats.prof) ? Stats.prof.encode('UTF-8') : ""),
      :race         => (defined?(Stats.race) ? Stats.race.encode('UTF-8') : ""),
      :level        => XMLData.level.to_i,
      :exp          => (defined?(Stats.exp) ? Stats.exp.to_i : ""),
      :area         => current_area.encode('UTF-8'),
      :subscription => @subscription,
      :locker       => @locker_location,
      :citizenship  => citizenship.encode('UTF-8'),
      :society      => society,
      :society_rank => society_rank,
      :timestamp    => self.db_timestamp_integer
    }

    sql = %{
      insert into character (name, game, account, prof, race, level, exp, area, subscription, locker, citizenship, society, society_rank, timestamp)
      select :name, :game, :account, :prof, :race, :level, :exp, :area, :subscription, :locker, :citizenship, :society, :society_rank, :timestamp
      where not exists (
        select 1
        from character
        where name = :name
          and game = :game
        );
    }
    # cparams = { :game => game, :name => name}
    # sql = "insert into character (name, game) select :name, :game where not exists (select 1 from character where name = :name and game = :game)"
    _rows, changes = self.execute(sql, cparams, db)
    @db_changes[:char][:inserted] += changes

    qargs = { :name => name, :game => game }
    sql = %{ select id from character where name = :name and game = :game }
    character_id = db.get_first_value(sql, qargs)
    db.close if close_db
    return character_id
  end

  def self.character_id_get(db = nil, name = nil, game = nil)
    close_db = false
    (close_db = true; db = Inv_db.open) if db.nil?
    name = XMLData.name.encode('UTF-8') if name.nil?
    game = XMLData.game.encode('UTF-8') if game.nil?
    qargs = { :name => name, :game => game }
    sql = %{ select id from character where name = :name and game = :game }
    character_id = db.get_first_value(sql, qargs)
    character_id = self.character_insert(name, game, db) if character_id.nil?
    db.close if close_db;
    return character_id
  end

  def self.insert_fake_character(db, account_name)
    name_spoof = "#{account_name}_"
    cparams = {
      :name         => name_spoof,
      :game         => XMLData.game.encode('UTF-8'),
      :account      => account_name.encode('UTF-8'),
      :prof         => "".encode('UTF-8'),
      :race         => "".encode('UTF-8'),
      :level        => 0,
      :exp          => 0,
      :area         => "",
      :subscription => @subscription.encode('UTF-8') || "".encode('UTF-8'),
      :locker       => "",
      :timestamp    => self.db_timestamp_integer
    }
    sql = %{
    insert into character (name, game, account, prof, race, level, exp, area, subscription, locker, timestamp)
      select :name, :game, :account, :prof, :race, :level, :exp, :area, :subscription, :locker, :timestamp
      where not exists (
        select 1
        from character
        where name = :name
          and game = :game
        );
    }
    _rows, changes = self.execute(sql, cparams, db)
    @db_changes[:char][:updated] += changes
    qargs = { :name => name_spoof, :game => XMLData.game }
    sql = %{ select id from character where name = :name and game = :game }
    character_id = db.get_first_value(sql, qargs)
    return character_id
  end

  refresh_char = proc {
    @calling_proc = @current_proc
    @current_proc = "refresh_char"
    respond "+---------------- proc_start: #{@current_proc}" if @debug

    society, society_rank = self.society_info
    citizenship = self.citizenship_info
    current_area = self.current_area;

    qargs = {
      :name         => XMLData.name.encode('UTF-8'),
      :game         => XMLData.game.encode('UTF-8'),
      :account      => @account_name.encode('UTF-8'),
      :prof         => (defined?(Stats.prof) ? Stats.prof.encode('UTF-8') : ""),
      :race         => (defined?(Stats.race) ? Stats.race.encode('UTF-8') : ""),
      :level        => XMLData.level.to_i,
      :exp          => (defined?(Stats.exp) ? Stats.exp.to_i : ""),
      :area         => current_area.encode('UTF-8'),
      :subscription => @subscription.encode('UTF-8'),
      :locker       => @locker_location.encode('UTF-8'),
      :citizenship  => citizenship.encode('UTF-8'),
      :society      => society.encode('UTF-8'),
      :society_rank => society_rank,
      :timestamp    => self.db_timestamp_integer
    }
    sql = %{
      update character set
          account      = :account
        , prof         = :prof
        , race         = :race
        , level        = :level
        , exp          = :exp
        , area         = :area
        , subscription = :subscription
        , locker       = :locker
        , citizenship  = :citizenship
        , society      = :society
        , society_rank = :society_rank
        , timestamp    = :timestamp
      where name = :name and game = :game
    }
    respond qargs.inspect if @debug_sql
    respond sql if @debug_sql
    _rows, changes = self.execute(sql, qargs, db)
    @db_changes[:char][:updated] += changes
  }
  query_char = proc { |params|
    @calling_proc = @current_proc
    @current_proc = "query_char"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    respond params.to_s if @debug
    sql, qargs = Inv_db.query_char_sql(params, style)
    Inv_db.gs_print sql if @debug_sql
    begin
      rows = db.execute2(sql, qargs)
    rescue SQLite3::BusyException
      sleep 0.1
      retry
    end
    Inv_db.output_table(rows, target, qargs)
  }
  #------------------------------------------------------------------------------#
  # lumnis
  #------------------------------------------------------------------------------#
  def self.lumnis_status_lookup(db = nil, character_id = nil)
    close_db = false
    (close_db = true; db = Inv_db.open) if db.nil?
    character_id = @character_id if character_id.nil?
    character_id = self.character_id_get(db) if character_id.nil?
    qargs = { :character_id => character_id }
    sql = %{ select status, timestamp from lumnis where character_id = :character_id limit 1 }
    lumnis_status, updated = self.execute2(sql, qargs, db)[1]
    db.close if close_db
    return lumnis_status, updated
  end

  def self.lumnis_info()
    command       = "lumnis info";
    start_pattern = /^You have \d+|Your Gift of Lumnis|^Because your account is free/;
    data = self.client_command(command, start_pattern)
    (Inv_db.gs_print("error checking lumnis info"); return nil) if data.nil?

    exp_pattern           = /(?<value>\d[\d,]*) points of (?<key>triple|double)/
    status_pattern        = /Your Gift of Lumnis (?:has|will) (?<status>expired|restart)/
    f2p_pattern           = /Because your account is free, you do not have access to the weekly Gift of Lumnis./
    scheduled_pattern     = /Your Gift of Lumnis is scheduled to start on (?<start_day>\w+)s at (?<start_time>\d\d:\d\d)/
    last_schedule_pattern = /You last used a Lumnis scheduling option on (?<last_schedule>[^\.]+)\./

    lumnis_info = {
      :status        => '',
      :double        => 0,
      :triple        => 0,
      :total         => 0,
      :start_day     => '',
      :start_time    => '',
      :last_schedule => '',
    }

    data.each { |line|
      if line =~ f2p_pattern
        break
      elsif line =~ exp_pattern
        line.scan(exp_pattern).each { |value, key| lumnis_info[key.to_sym] = value.to_i }
        lumnis_info[:total] = (lumnis_info[:triple] * 2) + lumnis_info[:double]
      elsif (m = line.match(status_pattern))
        lumnis_info[:status] = m[:status]
        if m[:status] == 'restart'
          lumnis_info[:double] = 7300
          lumnis_info[:triple] = 7300
          lumnis_info[:total]  = 21900
        end
      elsif (m = line.match(scheduled_pattern))
        lumnis_info[:start_day]  = m[:start_day]
        lumnis_info[:start_time] = m[:start_time]
      elsif (m = line.match(last_schedule_pattern))
        lumnis_info[:last_schedule] = Time.parse(m[:last_schedule]).strftime("%Y-%m-%d %H:%M:%S")
      end
    }
    @lumnis_status = lumnis_info[:status]
    return lumnis_info
  end

  def self.lumnis_update(db, qargs)
    iargs = { :character_id => qargs[:character_id] }
    if db.get_first_value("select character_id from lumnis where character_id = :character_id", iargs).nil?
      sql = "insert into lumnis (character_id) values (:character_id)"
      _rows, changes = self.execute(sql, iargs, db)
      @db_changes[:lumnis][:inserted] += changes
    end
    sql = %{
      update lumnis set
          status        = :status
        , double        = :double
        , triple        = :triple
        , total         = :total
        , start_day     = :start_day
        , start_time    = :start_time
        , last_schedule = :last_schedule
        , timestamp     = :timestamp
      where character_id = :character_id
    }
    _rows, changes = self.execute(sql, qargs, db)
    @db_changes[:lumnis][:updated] += changes
  end

  def self.lumnis_refresh(db = nil, character_id = nil)
    close_db = false
    (close_db = true; db = Inv_db.open) if db.nil?
    qargs = self.lumnis_info
    character_id = @character_id if character_id.nil?
    character_id = self.character_id_get(db) if character_id.nil?
    qargs[:character_id] = character_id
    qargs[:timestamp] = self.db_timestamp_integer
    self.lumnis_update(db, qargs)
    db.close if close_db;
  end

  def self.lumnis_query(db = nil, params = {})
    groupby = having = orderby = limit = "";
    where, qargs, _extras = self.where_builder(params, 'lumnis')
    select = %{
        select
            c.account
          , c.name
          , lower(c.game) as game
          , u.status
          , u.double
          , u.triple
          , u.total
          , u.start_day
          , u.start_time
          , u.last_schedule
          , u.timestamp as updated
      };
    from = %{
        from lumnis u
          inner join character c on u.character_id = c.id
      };
    sql = "#{select} #{from} #{where} #{groupby} #{having} #{orderby} #{limit}";
    _respond sql if @debug_sql;
    rows = self.execute2(sql, qargs, db)
    self.output_table(rows, 'lumnis', qargs)
  end

  #------------------------------------------------------------------------------#
  # resource
  #------------------------------------------------------------------------------#
  def self.resource()
    command       = "resource";
    start_pattern = /^<output class="mono/;
    data = self.client_command(command, start_pattern)
    (Inv_db.gs_print("error checking resource"); return nil) if data.nil?
    resource_pattern = /(?<key>[A-Z](?!old).*?:|\(Weekly\)) *(?<value>[^\(]*?)(?: +|$)/
    resource = { :weekly => '', :total => '', :suffused => '', :energy => '', :favor => '' }
    data.each { |line|
      line.scan(resource_pattern).each { |key, value|
        values    = value.gsub(/<(?:push|pop)Bold\/>/, '').split(/\/|\(/)
        value     = values[0]
        max_value = values[1]
        key       = key.sub(/(Suffused)(.*?)$/, '\1').sub(/^Voln /, '').delete(':').downcase
        if max_value == "50,000"
          resource[:energy] = key.downcase
          resource[:weekly] = value.delete(',').to_i
        elsif max_value == "200,000"
          resource[:total] = value.delete(',').to_i
        elsif ['favor', 'suffused'].include?(key)
          resource[key.to_sym] = value.delete(',').to_i
        else
          resource[key.to_sym] = value.delete(',').downcase
        end
      }
    }
    return resource
  end

  def self.resource_update(db, qargs)
    return nil if qargs[:energy] == '' and ['', 0].include?(qargs[:favor])
    iargs = { :character_id => qargs[:character_id] }
    if db.get_first_value("select character_id from resource where character_id = :character_id", iargs).nil?
      sql = "insert into resource (character_id) values (:character_id)"
      _rows, changes = self.execute(sql, iargs, db)
      @db_changes[:resource][:inserted] += changes
    end
    qargs[:timestamp] = self.db_timestamp_integer
    qargs[:bonus] = Resource.load_bonuses["#{XMLData.game}:#{Char.name}"][:bonus] if defined?(Resource::load_bonuses)
    lumnis_status, updated = self.lumnis_status_lookup(db, qargs[:character_id])
    if !updated.nil? and Time.at(updated.to_i)+60 > Time.now and lumnis_status == 'restart'
      qargs[:weekly] = 0
    else
      self.lumnis_refresh(db, qargs[:character_id])
      lumnis_status, updated = self.lumnis_status_lookup(db, qargs[:character_id])
      qargs[:weekly] = 0 if lumnis_status == 'restart'
    end
    qargs[:bonus] = nil if !qargs.key?(:bonus)
    qargs[:favor] = 0 if !qargs.key?(:favor)
    qargs.delete_if { |key, _value| !key.to_s.match(/energy|weekly|total|suffused|bonus|favor|timestamp|character_id/) }
    sql = %{
      update resource set
          energy    = coalesce(:energy,'')
        , weekly    = :weekly
        , total     = :total
        , suffused  = :suffused
        , bonus     = coalesce(:bonus,bonus)
        , favor     = :favor
        , timestamp = :timestamp
      where character_id = :character_id
        and (weekly <> :weekly
          or total <> :total
          or bonus <> :bonus
          or favor <> :favor
        )
    }
    _rows, changes = self.execute(sql, qargs, db)
    @db_changes[:resource][:updated] += changes
  end

  def self.resource_refresh(db = nil, character_id = nil)
    close_db = false
    (close_db = true; db = Inv_db.open) if db.nil?
    qargs = self.resource
    character_id = @character_id if character_id.nil?
    character_id = self.character_id_get(db) if character_id.nil?
    qargs[:character_id] = character_id
    self.resource_update(db, qargs)
    db.close if close_db;
  end

  def self.resource_query(db = nil, params = {})
    groupby = having = orderby = limit = "";
    where, qargs, _extras = self.where_builder(params, 'resource')
    select = %{
    select
        c.account
      , c.name
      , lower(c.game) as game
      , substr(c.prof,1,3) as pro
      , c.level as lvl
      , e.energy
      , e.weekly
      , e.total
      , e.suffused
      , e.bonus
      , e.favor
      , e.timestamp as updated};
    from = %{
    from resource e
      inner join character c on e.character_id = c.id};
    sql = "#{select} #{from} #{where} #{groupby} #{having} #{orderby} #{limit}";
    rows = self.execute2(sql, qargs, db)
    self.output_table(rows, 'resource', qargs)
  end
  #------------------------------------------------------------------------------#
  # banks
  #   todo: add silvers/notes
  # You have 2351 coins with you.
  # You are carrying City-States promissory notes valued at a total of 10216 silver.
  # You are carrying 12567 silver between notes and coins.
  # In the back of your mind you remember you owe a debt of 85 silvers in the town of Icemule Trace.
  #------------------------------------------------------------------------------#

  scrape_bank = proc {
    @calling_proc = @current_proc
    @current_proc = "scrape_bank"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    command         = "bank account";
    start_pattern   = /^You currently have the following amounts on deposit:|You currently have an account|You haven't opened a bank account yet/i;
    end_pattern     = /^(?:<popBold\/>)?<prompt/;
    bank_account_result = self.client_command(command, start_pattern, end_pattern)

    bank_account_result.each { |l|
      if patterns[:bank] =~ l
        bank = $1
        amount = $2.gsub(',', '').to_i
        bank_accounts[bank] = amount
        total_from_feed = amount if bank == "Total"
      elsif patterns[:bank_single] =~ l
        bank = $1
        amount = $2.gsub(',', '').to_i
        bank_accounts[bank] = amount
        bank_accounts["Total"] = amount
        total_from_feed = amount
      elsif patterns[:bank_f2p] =~ l
        bank_max = $1.gsub(',', '')
        respond "bank_max:#{bank_max.inspect}" if @debug
        break
      elsif patterns[:bank_none] =~ l
        break
      end
    }
  }
  save_bank = proc {
    @calling_proc = @current_proc
    @current_proc = "save_bank"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    begin
      stmt = db.prepare("insert into temp_silver (character_id, bank, amount, timestamp) values(#{@character_id}, ?, ?, #{self.db_timestamp_integer})")
      bank_accounts.each { |k, v|
        stmt.execute(k.encode('UTF-8'), v)
      }
      #  ----delete
      sql = %{
      delete
      from silver
      where silver.character_id = :character_id
        and not exists (
          select 1
          from temp_silver t
            inner join bank b on t.bank = b.name
          where t.character_id = silver.character_id
            and b.id           = silver.bank_id
          )
      }
      qargs = { :character_id => @character_id }
      _rows, changes = self.execute(sql, qargs, db)
      @db_changes[:bank][:deleted] += changes
      #  ----update: sqlites doesn't support joins in updates
      sql = %{
      with cte (character_id, bank_id, amount, timestamp) as (
        select t.character_id, b.id, t.amount, t.timestamp
        from temp_silver t
          inner join bank b on t.bank=b.name
      )
      update silver set
          amount    = (
            select amount
            from cte
            where silver.character_id = cte.character_id
              and silver.bank_id = cte.bank_id
              and silver.amount <> cte.amount
          )
        , timestamp = (
            select timestamp
            from cte
            where silver.character_id = cte.character_id
              and silver.bank_id = cte.bank_id
              and silver.amount <> cte.amount
          )
      where exists (
        select 1
        from cte
        where silver.character_id = cte.character_id
          and silver.bank_id = cte.bank_id
          and silver.amount <> cte.amount
        )
      }
      _rows, changes = self.execute(sql, qargs = {}, db)
      @db_changes[:bank][:updated] += changes
      sql = %{
      with cte (character_id, bank_id, amount, timestamp) as (
        select t.character_id, b.id, t.amount, t.timestamp
        from temp_silver t
          inner join bank b on t.bank=b.name
      )
      insert into silver (character_id, bank_id, amount, timestamp)
        select character_id, bank_id, amount, timestamp
        from cte
        where not exists (
          select 1
          from silver i
          where i.character_id = cte.character_id
            and i.bank_id      = cte.bank_id
          )
        order by character_id, bank_id
      }
      _rows, changes = self.execute(sql, qargs = {}, db)
      @db_changes[:bank][:inserted] += changes
    rescue SQLite3::BusyException
      sleep 0.1
      retry
    rescue SQLite3::Exception => e
      Inv_db.gs_print "Exception occured. Please contact Xanlin#4407 on discord with error details."
      Inv_db.gs_print "Exception: #{e}"
      Inv_db.gs_print "character_id: #{@character_id.inspect}"
      Inv_db.gs_print "bank_accounts: #{bank_accounts.inspect}"
      Inv_db.gs_print sql if e.to_s =~ /syntax error/
    ensure
      stmt.close if stmt
    end
  }

  query_bank = proc { |params|
    @calling_proc = @current_proc
    @current_proc = "query_bank"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    respond "+----params:#{params.inspect}" if @debug
    sql, qargs = Inv_db.query_bank_sql(params, style)
    begin
      rows = db.execute2(sql, qargs)
    rescue SQLite3::BusyException
      sleep 0.1
      retry
    end
    Inv_db.output_table(rows, target, qargs, "name")
  };

  query_tickets = proc { |params|
    @calling_proc = @current_proc
    @current_proc = "query_tickets"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    respond "+----params:#{params.inspect}" if @debug
    sql, qargs = Inv_db.query_tickets_sql(params, style)
    begin
      rows = db.execute2(sql, qargs)
    rescue SQLite3::BusyException
      sleep 0.1
      retry
    end
    Inv_db.output_table(rows, target, qargs, "name")
  };
  sum_bank = proc { |params|
    @calling_proc = @current_proc
    @current_proc = "query_bank"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    respond "+----params:#{params.inspect}" if @debug
    begin
      sql, qargs = Inv_db.sum_bank_sql(params)
      Inv_db.gs_print sql if @debug_sql
      rows = db.execute2(sql, qargs)
    rescue SQLite3::BusyException
      sleep 0.1
      retry
    end
    Inv_db.output_table(rows, target, qargs, "name")
  };

  sum_tickets = proc { |params|
    @calling_proc = @current_proc
    @current_proc = "query_tickets"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    respond "+----params:#{params.inspect}" if @debug
    begin
      sql, qargs = Inv_db.sum_tickets_sql(params)
      Inv_db.gs_print sql if @debug_sql
      rows = db.execute2(sql, qargs)
    rescue SQLite3::BusyException
      sleep 0.1
      retry
    end
    Inv_db.output_table(rows, target, qargs, "name")
  };
  refresh_bank = proc {
    @calling_proc = @current_proc
    @current_proc = "refresh_bank"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    scrape_bank.call
    save_bank.call
  }
  refresh_tickets = proc {
    @calling_proc = @current_proc
    @current_proc = "refresh_tickets"
    respond "+---------------- proc_start: #{@current_proc}" if @debug

    @ticket_patterns = Hash.new
    @ticket_patterns[:balance_start] = /You take a moment to recall the alternative currencies you've collected.../
    @ticket_patterns[:balance_split] = /^ +(?<source>.*?) - (?<amount>[,\d]+) (?<currency>.*?)\./
    @ticket_patterns[:balance_none] = /You haven't collected any alternative currencies./
    @ticket_balance = []
    command        = "ticket balance"
    start_pattern  = @ticket_patterns[:balance_start]
    ticket_data    = self.client_command(command, start_pattern)
    # because it goes mono before saying anything:
    _respond "<output class=\"\"/>" if $frontend =~ /storm|wrayth/i
    if @ticket_patterns[:balance_none].match(ticket_data.join("\n"))
      delete_tickets.call
    else
      ticket_data.each { |l|
        m = @ticket_patterns[:balance_split].match(l)
        if m
          ticket = {
            :source   => m[:source],
            :amount   => m[:amount],
            :currency => m[:currency]
          }
          @ticket_balance.push(ticket)
        end
      }
      @ticket_balance.each { |t| echo "#{t[:source]}, #{t[:amount]}, #{t[:currency]}" } if @debug
    end

    # ##save tickets

    # save_tickets = proc {
    @calling_proc = @current_proc
    @current_proc = "save_tickets"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    begin
      stmt = db.prepare("insert into temp_tickets (character_id, source, amount, currency, timestamp) values(#{@character_id}, ?, ?, ?, #{self.db_timestamp_integer})")
      @ticket_balance.each { |t|
        stmt.execute(t[:source].encode('UTF-8'), t[:amount].gsub(',', '').to_i, t[:currency].encode('UTF-8'))
      }
      #  ----delete
      sql = %{
      delete
      from tickets
      where tickets.character_id = :character_id
        and not exists (
          select 1
          from temp_tickets t
          where t.character_id = tickets.character_id
            and t.source = tickets.source
            and t.currency = tickets.currency
          )
      }
      qargs = { :character_id => @character_id }
      _rows, changes = self.execute(sql, qargs = {}, db)
      @db_changes[:tickets][:deleted] += changes
      #  ----update: sqlites doesn't support joins in updates
      sql = %{
      with cte (character_id, source, amount, currency, timestamp) as (
        select t.character_id, t.source, t.amount, t.currency, t.timestamp
        from temp_tickets t
      )
        update tickets set
            amount    = (
              select amount
              from cte
              where tickets.character_id = cte.character_id
                and tickets.source = cte.source
                and tickets.amount <> cte.amount
                and tickets.currency = cte.currency
            )
          , timestamp = (
              select timestamp
              from cte
              where tickets.character_id = cte.character_id
                and tickets.source = cte.source
                and tickets.amount <> cte.amount
            )
        where exists (
          select 1
          from cte
          where tickets.character_id = cte.character_id
            and tickets.source = cte.source
            and tickets.amount <> cte.amount
            and tickets.currency = cte.currency
          )
      }
      _rows, changes = self.execute(sql, qargs, db)
      @db_changes[:tickets][:updated] += changes

      sql = %{
      with cte (character_id, source, amount, currency, timestamp) as (
        select t.character_id, t.source, t.amount, t.currency, t.timestamp
        from temp_tickets t
      )
      insert into tickets (character_id, source, amount, currency, timestamp)
        select character_id, source, amount, currency, timestamp
        from cte
        where not exists (
          select 1
          from tickets i
          where i.character_id = cte.character_id
            and i.source       = cte.source
            and i.currency     = cte.currency
          )
        order by character_id, source
      }
      _rows, changes = self.execute(sql, nil, db)
      @db_changes[:tickets][:inserted] += changes
    rescue SQLite3::BusyException
      sleep 0.1
      retry
    rescue SQLite3::Exception => e
      Inv_db.gs_print "Exception occured. Please contact Xanlin#4407 on discord with error details."
      Inv_db.gs_print "Exception: #{e}"
      Inv_db.gs_print "character_id: #{@character_id.inspect}"
      Inv_db.gs_print "tickets_accounts: #{@ticket_balance.inspect}"
    ensure
      stmt.close if stmt
    end
    # }
  }
  #------------------------------------------------------------------------------#
  # item
  #    todo: scrape & capture parent/path of nested items
  #    todo: locker manifest might not have all lockers (simucoin)
  #------------------------------------------------------------------------------#

  insert_temp_item_inv = proc { |location_id| # |location_id,contents|
    @calling_proc = @current_proc
    @current_proc = "insert_temp_item_inv.call(#{location_id})"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    temp_item_time = Benchmark.realtime do;
      begin
        sql = "insert into temp_item (
            character_id, location_id
          , level, path
          , type, name, noun, amount
          , stack, status
          , marked, registered, hidden, worn
          , timestamp, update_noun, gs_id
          )
        values(#{@character_id}, :location_id
          , :level, :path
          , :type, :name, :noun, :amount
          , :stack, :status
          , :marked, :registered, :hidden, :worn
          , #{self.db_timestamp_integer}, :update_noun, :id )"
        stmt = db.prepare(sql)
        respond "@inv_items.count: #{@inv_items.count}" if @debug
        @inv_items.each { |item|
          stmt.execute item
        }
      rescue SQLite3::BusyException
        sleep 0.1
        retry
      rescue SQLite3::Exception => e
        Inv_db.gs_print "Exception occured. Please contact Xanlin#4407 on discord with error details."
        Inv_db.gs_print "Exception: #{e}"
        Inv_db.gs_print sql if e.to_s =~ /syntax error/
      ensure
        stmt.close if stmt
      end
    end;
    Inv_db.gs_print "+----insert_temp_item_inv time elapsed #{(temp_item_time * 1000).round(2)} milliseconds" if @benchmark;
  }

  insert_temp_item_locker = proc { # |location_id,contents|
    @calling_proc = @current_proc
    @current_proc = "insert_temp_item_locker"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    insert_temp_item_locker_time = Benchmark.realtime do;
      begin
        stmt = db.prepare("insert into temp_item (
              character_id, location_id
            , level, path
            , type, name, noun, amount
            , stack, status
            , marked, registered, worn
            , timestamp, update_noun, gs_id
            )
          values(#{@character_id}, :location_id
            , :level, :path
            , :type, :name, :noun, :amount
            , :stack, :status
            , :marked, :registered, :worn
            , #{self.db_timestamp_integer}, :update_noun, :id )")
        @locker_items.each { |v|
          sparams = v
          sparams.delete_if { |key, _value| !key.to_s.match(/location_id|level|path|type|name|noun|amount|stack|status|marked|registered|worn/) }
          stmt.execute sparams
        }
      rescue SQLite3::BusyException
        sleep 0.1
        retry
      rescue SQLite3::Exception => e
        Inv_db.gs_print "Exception occured. Please contact Xanlin#4407 on discord with error details."
        Inv_db.gs_print "Exception: #{e}"
        Inv_db.gs_print sql if e.to_s =~ /syntax error/
      end
    end;
    Inv_db.gs_print "+----insert_temp_item_locker_time time elapsed #{(insert_temp_item_locker_time * 1000).round(2)} milliseconds" if @benchmark;
  }

  insert_temp_item_premium_locker = proc { |location_id|
    @calling_proc = @current_proc
    @current_proc = "insert_temp_item_premium_locker"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    insert_temp_item_premium_locker_time = Benchmark.realtime do;
      begin
        character_id = @character_id
        if location_id.to_i == 40
          @account_name, @subscription = self.verb_account if @account_name.nil?
          character_id = self.insert_fake_character(db, @account_name)
        end
        stmt = db.prepare("insert into temp_item (
              character_id, location_id
            , level, path
            , type, name, noun, amount
            , stack, status
            , marked, registered, worn
            , timestamp, update_noun, gs_id
            )
          values(#{character_id}, :location_id
            , :level, :path
            , :type, :name, :noun, :amount
            , :stack, :status
            , :marked, :registered, :worn
            , #{self.db_timestamp_integer}, :update_noun, :id )")
        @locker_items.each { |v|
          sparams = v
          sparams.delete_if { |key, _value| !key.to_s.match(/location_id|level|path|type|name|noun|amount|stack|status|marked|registered|worn/) }
          stmt.execute sparams
        }
      rescue SQLite3::BusyException
        sleep 0.1
        retry
      rescue SQLite3::Exception => e
        Inv_db.gs_print "Exception occured. Please contact Xanlin#4407 on discord with error details."
        Inv_db.gs_print "Exception: #{e}"
        Inv_db.gs_print sql if e.to_s =~ /syntax error/
      ensure
        stmt.close if stmt
      end
    end;
    Inv_db.gs_print "+----insert_temp_item_premium_locker_time time elapsed #{(insert_temp_item_premium_locker_time * 1000).round(2)} milliseconds" if @benchmark;
  }

  merge_item_by_location = proc { |location_id|
    @calling_proc = @current_proc
    @current_proc = "merge_item_by_location.call(#{location_id})"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    character_id = @character_id
    character_id = self.insert_fake_character(db, @account_name) if location_id.to_i == 40
    merge_params = { :character_id => character_id, :location_id => location_id.to_i }
    # respond "merge_params:#{merge_params.inspect}" if @debug
    # if @debug;
    #  location_item_count = db.execute2("select count(*) as item_count from temp_item where location_id = #{location_id}")[1]
    #  respond "location #{location_id} item_count: #{location_item_count.inspect}"
    #  db.execute2("select * from temp_item where location_id = #{location_id} limit 10").each{|r| respond r.inspect}
    # end
    temp_item_cte = %{
    with cte as (
      select
          character_id, location_id
        , level, path
        , type , name, noun, sum(amount) as amount
        , stack, status
        , marked, registered, hidden, worn
        , timestamp, update_noun
      from temp_item
      where character_id = :character_id
        and location_id = :location_id
      group by
          character_id, location_id
        , level, path
        , type , name, noun
        , stack, status
        , marked, registered, hidden, worn
        , timestamp, update_noun
    )
    }
    # if @debug;
    #  respond db.execute2(temp_item_cte + "select count(*) as item_count from cte",merge_params)
    #  location_item_count = db.execute2(temp_item_cte + "select count(*) as item_count from cte",merge_params)
    #  #respond "cte: location #{location_id} item_count: #{location_item_count.inspect}"
    # end

    respond "+----#{@current_proc}: delete" if @debug
    sql = %{
    delete
    from item
    where item.character_id = :character_id
      and item.location_id = :location_id
      and not exists (
        select 1
        from temp_item t
        where t.character_id = :character_id
          and t.location_id  = :location_id
          and t.path         = item.path
          and t.name         = item.name
          and t.stack        = item.stack
          and t.status       = item.status
          and t.marked       = item.marked
          and t.registered   = item.registered
          and t.hidden       = item.hidden
          and t.worn         = item.worn
        )
    }

    _rows, changes = self.execute(temp_item_cte + sql, merge_params, db)
    @db_changes[:item][:deleted] += changes

    #  ----update: sqlite doesn't support joins in updates
    respond "+----#{@current_proc}: update" if @debug
    sql = %{
    update item set
        amount = (
          select amount
          from cte t
          where t.character_id = :character_id
            and t.location_id  = :location_id
            and t.path         = item.path
            and t.name         = item.name
            and t.stack        = item.stack
            and t.status       = item.status
            and t.marked       = item.marked
            and t.registered   = item.registered
            and t.worn         = item.worn
        )
      , type = coalesce((
          select type
          from cte t
          where t.character_id = :character_id
            and t.location_id  = :location_id
            and t.path         = item.path
            and t.name         = item.name
            and t.stack        = item.stack
            and t.status       = item.status
            and t.marked       = item.marked
            and t.registered   = item.registered
            and t.worn         = item.worn
            --and t.update_noun  = 1
            and t.type        <> 'unknown'
            and t.type        <> ''
        ),item.type)
      , noun = coalesce((
          select noun
          from cte t
          where t.character_id = :character_id
            and t.location_id  = :location_id
            and t.path         = item.path
            and t.name         = item.name
            and t.stack        = item.stack
            and t.status       = item.status
            and t.marked       = item.marked
            and t.registered   = item.registered
            and t.worn         = item.worn
            and t.update_noun  = 1
        ),item.noun)
      , timestamp = (
          select timestamp
          from cte t
          where t.character_id = :character_id
            and t.location_id  = :location_id
            and t.path         = item.path
            and t.name         = item.name
            and t.stack        = item.stack
            and t.status       = item.status
            and t.marked       = item.marked
            and t.registered   = item.registered
            and t.worn         = item.worn
        )
    where item.character_id = :character_id
      and item.location_id = :location_id
      and exists (
        select 1
        from cte t
        where t.character_id = :character_id
          and item.location_id  = :location_id
          and t.path         = item.path
          and t.name         = item.name
          and t.stack        = item.stack
          and t.status       = item.status
          and t.marked       = item.marked
          and t.registered   = item.registered
          and t.worn         = item.worn
          and (
            item.amount  <> t.amount
            or item.type <> coalesce((
              select type
              from cte t
              where t.character_id = :character_id
                and t.location_id  = :location_id
                and t.path         = item.path
                and t.name         = item.name
                and t.stack        = item.stack
                and t.status       = item.status
                and t.marked       = item.marked
                and t.registered   = item.registered
                and t.worn         = item.worn
                --and t.update_noun  = 1
                and t.type        <> 'unknown'
                and t.type        <> ''
              ),item.type)
            or item.noun <> coalesce((
              select noun
              from cte t
              where t.character_id = :character_id
                and t.location_id  = :location_id
                and t.path         = item.path
                and t.name         = item.name
                and t.stack        = item.stack
                and t.status       = item.status
                and t.marked       = item.marked
                and t.registered   = item.registered
                and t.worn         = item.worn
                and t.update_noun  = 1
              ),item.noun)
            )
        )
    }
    _rows, changes = self.execute(temp_item_cte + sql, merge_params, db)
    @db_changes[:item][:updated] += changes

    #  ----insert items
    respond "+----#{@current_proc}: insert" if @debug
    sql = %{
    insert into item (
        character_id, location_id
      , level, path
      , type, name, noun, amount
      , stack, status
      , marked, registered, hidden, worn
      , timestamp
    )
      select
        character_id, location_id
      , level, path
      , type, name, noun, amount
      , stack, status
      , marked, registered, hidden, worn
      , timestamp
      from cte t
      where not exists (
        select 1
        from item i
        where i.character_id = :character_id
          and i.location_id  = :location_id
          and i.path         = t.path
          and i.name         = t.name
          and i.stack        = t.stack
          and i.status       = t.status
          and i.marked       = t.marked
          and i.registered   = t.registered
          and i.hidden       = t.hidden
          and i.worn         = t.worn
        )
      order by character_id, location_id, path, name
    }
    _rows, changes = self.execute(temp_item_cte + sql, merge_params, db)
    @db_changes[:item][:inserted] += changes


    # todo:remove
    # testing performance impact of clearing temp table
    sql = %{
    delete from temp_item
    where character_id = :character_id
      and location_id = :location_id}
    _rows, _changes = self.execute(sql, merge_params, db)
  }

  refresh_item = proc { |params|
    @calling_proc = @current_proc;
    @current_proc = "refresh_item";
    respond "+---------------- proc_start: #{@current_proc}" if @debug;
    respond "+----params:#{params.inspect}" if @debug;
    location_type_filter = params.find { |h| h[:name] == "location_type" }[:value];
    location_type_filter = "all" if location_type_filter.nil?;
    if location_type_filter =~ /all|inv/;
      Inv_db.gs_print "updating inventory..." if !@benchmark;
      inv_time = Benchmark.realtime do;
        refresh_inv.call;
      end;
      Inv_db.gs_print "+--refresh_inv combined time elapsed #{(inv_time * 1000).round(2)} milliseconds" if @benchmark;
    end;
    if location_type_filter =~ /all|locker/ and not (location_type_filter =~ /all/ and @subscription == "f2p");
      Inv_db.gs_print "updating locker(s)..." if !@benchmark;
      locker_time = Benchmark.realtime do;
        refresh_locker.call;
      end;
      Inv_db.gs_print "+--refresh_locker time elapsed #{(locker_time * 1000).round(2)} milliseconds" if @benchmark;
    end;
  };

  #------------------------------------------------------------------------------#
  # waitfor jarserve2 if it's running
  #------------------------------------------------------------------------------#
  @js2 = Hash.new

  check_jarserve2 = proc {
    if Script.running?("jarserve2");
      respond "jarserve2 is running, waiting until ready:"
      $jarserve2.wait_until_ready
      $jarserve2.do_query().value[:jars].each do |gem, jars|
        jars.each do |jar|
          @js2[jar.id] = {
            :name   => jar.gem.to_s,
            :noun   => gem.noun_first =~ /^([^,]+),/ ? $1 : "?",
            :amount => jar.count.to_i,
            :status => (jar.status.to_s =~ /^(full|empty)/ ? $1 : "partial")
          }
        end
      end
    end
  }

  def self.inventory_container();
    command       = "inventory container";
    start_pattern = /^(?:<popBold\/>)?You are wearing (?:(?!, which conceals).)+$|^(?:<popBold\/>)?You are holding/;
    end_pattern   = /^(<popBold\/>)?<prompt/;
    data          = self.client_command(command, start_pattern, end_pattern)
    popbold       = (data[0] =~ /^<popBold\/>/ ? true : false;)
    _respond '<popBold/>' if popbold == true;
    respond "inventory container #{data}" if @debug;
    # this should only return one line, without the inventory help line
    # if it has that line, then someone ran >inven at the right time to get caught here
    if data.size > 1 and data[1..-1].join('') =~ /Click <d cmd='invento help'>INVENTORY HELP<\/d> for more options./
      echo "caught bad inventory result:\n #{data.join("\n")}\n" if @debug;
      data = self.inventory_container;
    end;
    return data;
  end;
  #------------------------------------------------------------------------------#
  #
  #------------------------------------------------------------------------------#
  open_containers = proc {
    @calling_proc = @current_proc
    @current_proc = "open_containers"
    respond "+---------------- proc_start: #{@current_proc}" if @debug

    data = self.inventory_container
    echo "data:#{data.inspect}" if @debug
    echo "@containers_noopen_pattern:#{@containers_noopen_pattern.inspect}" if @debug
    data.each { |d|
      d.scan(@container_list_pattern).each { |id, _noun, name|
        @containers << id if name !~ @containers_noopen_pattern;
      };
    };
    echo "@containers:#{@containers.inspect}" if @debug

    command_queue = @containers.map { |c| "open ##{c}" };
    if !command_queue.empty?
      echo "command_queue:#{command_queue.inspect}" if @debug
      squelch.call(inv_open_close_squelch_pattern);
      success_pattern = /^It appears to be locked.|^That is already open|^There doesn't seem to be any way to do that|(?<already_open>already open|open already|resists opening|absentmindedly fiddle with your)|(?<not_holding>Try holding it first|You need to be holding)|(?:You|Hooking|Lightly|Pinching|Sliding|With|focus) (?:flip|open|pull|push|throw|unwind|unfasten|unsnap|unhitch|unclasp|a finger|a flick|pick at|brushing|the toggle|the lever|rub|for).*?(?:<a exist="(?<id>#{@containers.join("|")})" noun="(?<noun>[^"]+)">(?<name>[^<]+)<.*?)|<exposeContainer|<container/
      speed           = (@slower == true ? 1 : 2)
      open_output = quickdo(command_queue, success_pattern, speed)
      echo "open_output:#{open_output.inspect}" if @debug
      container_id_pattern = /<a exist="(?<id>#{@containers.join("|")})" noun="(?<noun>[^"]+)">/
      open_output.each { |o|
        m = container_id_pattern.match(o)
        if m
          @containers_to_close.push(m[:id]) if m[:id]
        end
      }
      echo "@containers_to_close:#{@containers_to_close.inspect}" if @debug
      squelch_remove.call
    end
  }

  close_containers = proc {
    @calling_proc = @current_proc
    @current_proc = "close_containers"
    respond "+---------------- proc_start: #{@current_proc}" if @debug

    command_queue = @containers_to_close.reverse.map { |c| "close ##{c}" }
    if !command_queue.empty?
      squelch.call(inv_open_close_squelch_pattern) if @quiet
      echo "command_queue:#{command_queue.inspect}" if @debug
      success_pattern = /You.*?(?:"#{@containers_to_close.join("|")}")/
      speed           = (@slower == true ? 1 : 2)
      quickdo(command_queue, success_pattern, speed)
      squelch_remove.call if @quiet
    end
  }

  #------------------------------------------------------------------------------#
  #
  #------------------------------------------------------------------------------#
  refresh_inv = proc {
    @calling_proc = @current_proc
    @current_proc = "refresh_inv"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    location_type_filter = "all" if location_type_filter.nil?
    check_jarserve2.call
    if @settings_hash["open_containers"] == true
      open_time = Benchmark.realtime do
        open_containers.call
      end
      Inv_db.gs_print "+--open_containers time elapsed #{(open_time * 1000).round(2)} milliseconds" if @benchmark
    end
    if location_type_filter =~ /inv|item|all/i
      respond "+---------------- #{@current_proc}: scan inv" if @debug

      # Usage:
      # meh#     INVENTORY                         - Show the items you're currently wearing
      # meh#     INVENTORY HANDS                   - Show the items you're currently holding
      # meh#     INVENTORY {option}                - Show the items of a specific type that you're currently wearing
      # neat#     INVENTORY FULL [option]           - Show items in your inventory, including the contents of containers, optionally only showing those of a specific type
      # neat#     INVENTORY LOCATION                - Show items you are currently wearing and where they are located.  Also indicates whether the items are functional or not.
      # meh#     INVENTORY QUANTITY [option]       - Count items in your inventory, including the contents of containers, optionally only counting those of a specific type
      # neat#     INVENTORY HANDS FULL [option]     - Show items in your hands, including the contents of containers, optionally only showing those of a specific type
      # meh#     INVENTORY HANDS QUANTITY [option] - Count items in your hands, including the contents of containers, optionally only counting those of a specific type
      # hm#     INVENTORY ENHANCIVE [ON| OFF]     - Toggle whether your enhancive items provide their benefits (and thus expend charges) or not.
      #
      # Where {option} is one of the following:
      # hm#     ARMOR      - List armor
      # hm#     WEAPONS    - List weapons
      # hm#     COMBAT     - List weapons, armor, and unarmed combat equipment
      # neat#     CONTAINERS - List items that can hold other items
      # meh#     FLUFF      - List non-combat, non-container items
      # meh#     REGISTERED - List items that were most recently registered by you
      #------------------------------------------------------------------------------#
      @inv_scan = [
        { :command => 'inventory hands full', :id => 1, :squelch => nil, :path => '', :lines => [], :name => 'hands' }, # You are carrying
        { :command => 'inventory full alongside', :id => 6, :squelch => nil, :path => '', :lines => [], :name => 'alongside' }, # You are carrying
        { :command => 'inventory full', :id => 2, :squelch => nil, :path => '', :lines => [], :name => 'inven' } # , #You are currently wearing and carrying:
        # {:command => 'inventory location', :id => 3}, #You are currently wearing:
        # inv full con doesn't see containers in closed containers, just sayin'
        # inv full container may require multiple loops if containers aren't already open
        # alternately, open all containers before running the scan -- seems simpler
        # keep track of the opened containers and close them again in reverse order
        # {:command => 'inv full containers', :id => 0, :path => 'container', :contents => Hash.new(0), :squelch => inv_hands_squelch_pattern}, #You are carrying
        # {:command => 'inv full fluff', :id => 9, :path => 'container', :contents => Hash.new(0), :squelch => inv_hands_squelch_pattern}, #You are carrying
        # don't need registered
        # {:command => 'inv full registered', :id => , :path => 'container', :contents => Hash.new(0), :squelch => inv_hands_squelch_pattern}, #You are carrying
      ];
      @inv_scan.each { |scan|
        scan_time = Benchmark.realtime do;
          @inv_items = []
          scan_parse_item_lines.call(scan)
          insert_temp_item_inv.call(scan[:id])
          merge_item_by_location.call(scan[:id])
        end;
        Inv_db.gs_print "+----scan #{scan[:name]} time elapsed #{(scan_time * 1000).round(2)} milliseconds" if @benchmark;
      }
      close_time = Benchmark.realtime do
        if @settings_hash["open_containers"] == true
          close_containers.call
        end
      end
      Inv_db.gs_print "+----close_containers time elapsed #{(close_time * 1000).round(2)} milliseconds" if @benchmark
      # debug_parsed_items.call
    end
  };

  scan_parse_item_lines = proc { |scan|
    @calling_proc = @current_proc
    @current_proc = "scan_parse_item_lines"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    respond "+---------------- scan:#{scan.inspect}" if @debug
    temp_items       = []
    other_lines      = []
    pattern          = patterns[:inv_full]
    location_id      = scan[:id]
    match_fail_lines = []
    match_fail_count = 0
    ############
    command         = scan[:command]
    start_pattern   = /^(?:<popBold\/>)?(?:You are currently (?:wearing and )?(?:carrying)?(?:(?!, which conceals).)+$|^(?:<popBold\/>)?You are carrying nothing at this time|^(?:<popBold\/>)?You are holding)|^You currently have placed alongside you|^You have nothing placed alongside you.|That's not a valid option|^You are currently mounted on/i;
    end_pattern     = /^(?:<popBold\/>)?<prompt/;
    sp_lines        = self.client_command(command, start_pattern, end_pattern)
    # resend captured popBold
    _respond '<popBold/>' if (sp_lines[0] =~ /^<popBold\/>/ ? true : false;)

    count_line      = sp_lines.find { |line| patterns[:inv_count].match(line) }
    displayed_count = 0
    if count_line !~ /nothing/
      displayed_count = patterns[:inv_count].match(count_line).captures[0].to_i
    end
    _respond "command: #{scan[:command]}, count_line: #{count_line.inspect}, displayed_count: #{displayed_count.inspect}" if @debug
    ############
    prev_id     = empty_string
    prev_noun   = empty_string
    prev_level  = 0
    item_path   = []
    item_path_ids = []
    matched_count = 0
    # matched_count = -1 if XMLData.name =~ /Xanlin/
    sp_lines.each { |line|
      m = pattern.match(line)
      if m
        matched_count += 1
        leading_space = m[:depth]
        prename       = m[:pre]
        id            = m[:exist]
        noun          = m[:noun]
        name          = m[:name].strip
        postname      = m[:post].strip
        other         = m[:attrs]
        registered    = other =~ /registered/ ? "Y" : empty_string
        marked        = other =~ /marked/ ? "Y" : empty_string
        hidden        = other =~ /hidden/ ? "Y" : empty_string;
        amount        = 1
        type          = name == "some blue lapis lazuli" ? "gem" : Inv_db.get_item_type(name, noun) || "unknown";
        level         = ((leading_space.length.to_i - 2) / 4).to_i
        item_path.push(prev_noun) if level > prev_level
        item_path_ids.push("##{prev_id}") if level > prev_level # should turn this into a hash since i need both now?
        if level < prev_level
          n_pop = prev_level - level;
          n_pop.times { item_path.pop; item_path_ids.pop; }
        end
        path = "#{item_path.join(' > ')}" if !item_path.nil?

        stack           = empty_string
        stack_name      = empty_string
        stack_noun      = empty_string
        stack_type      = empty_string
        stack_amount    = 0
        status          = empty_string
        # respond "------------------------------------notes" if line =~ /notes/
        # stk = /^(?<stack>stack) of .*? notes|^(?<stack>bundle) of .*(?!arrows|bolts)$/i.match(name);
        stk = /^(?<stack>stack) of .*? notes$/i.match(name);
        stk = /^(?<stack>jar)/i.match(type) if !stk;
        # stk = /^(?<stack>jar|beaker|bottle)$/i.match(type);
        # stk[:stack] = 'jar' if stk and stk[:stack] =~ /(?:jar|beaker|bottle)$/i;
        if stk
          if stk[:stack] =~ /jar/i and @js2 and @js2[id][:amount] > 0
            # jarserve2 removes parts of the name, so let's not use that version.
            stack_name      = Inv_db.deplural(m[:post]).strip
            stack_noun      = @js2[id][:noun] =~ /lazuli/ ? "lapis" : @js2[id][:noun]
            stack_type      = (Inv_db.get_item_type(stack_name, stack_noun) || empty_string) if !postname.nil?
            status          = @js2[id][:status]
            stack_amount    = @js2[id][:amount]
            stack           = stk[:stack] if stack_amount > 0
            # stack           = 'jar' if stack =~ /(?:jar|beaker|bottle)$/i;
            respond "#{stack_name}|#{stack_noun}|#{stack_type}|#{status}|#{stack_amount}" if @debug
          elsif stk[:stack] =~ /jar/i and @settings_hash[stk[:stack].downcase] == true
            # respond "@settings_hash['#{stk[:stack].downcase}']: #{@settings_hash[stk[:stack].downcase]}" if @debug
            # stack_name      = Inv_db.deplural($6).strip
            stack_name      = Inv_db.deplural(m[:post]).strip
            stack_noun      = stack_name =~ /(.*?) ([\w\-]+)$/ ? $2 : empty_string
            stack_noun      = stack_noun =~ /lazuli/ ? "lapis" : stack_noun
            stack_type      = (Inv_db.get_item_type(stack_name, stack_noun) || empty_string) if postname != ''
            status          = "empty"
            # stack_amount, status = Inv_db.peek_jar(id, item_path.length > 0 ? "in #{item_path_ids.reverse.join(" in ")}" : "" ) if postname =~ /containing/
            stack_amount, status = Inv_db.peek_stack(id, item_path.length > 0 ? "in #{item_path_ids.reverse.join(" in ")}" : "", "jar") if postname =~ /containing/
            status          = status =~ /^(full|empty)/ ? status : "partial"
            stack           = stk[:stack] if stack_amount > 0
          elsif @settings_hash[stk[:stack].downcase] == true
            # respond "@settings_hash['#{stk[:stack].downcase}']: #{@settings_hash[stk[:stack].downcase]}" if @debug
            # respond "stk.inspect: #{stk.inspect}"
            stack_name      = Inv_db.deplural(name.gsub(/^(?:bundle|stack) of/, '')).strip
            stack_noun      = Inv_db.deplural(noun).strip
            stack_type      = (Inv_db.get_item_type(stack_name, stack_noun) || empty_string)
            stack_path      = (item_path.length > 0 ? "in #{item_path_ids.reverse.join(" in ")}" : "") if postname =~ /containing/ or stk[:stack] !~ /jar/i
            # respond "name, id, stack_path, stack_type, stack_name:#{name.inspect}, ##{id}, #{stack_path}, #{stack_type}, #{stack_name}"
            stack_amount, status = Inv_db.peek_stack(id, stack_path, stk[:stack])
            respond "stack_amount, status: #{stack_amount}, #{status}" if @debug
            stack = stk[:stack] if stack_amount > 0
          end
        end
        prename       = prename =~ /^(an ?|a ?)(.*)?/ ? $2 : prename
        name          = "#{prename}#{name =~ /^(some )?(.*)/ ? $2 : name} #{stack == "" ? postname : (stack_name == "" ? "" : "(#{stack_name}) ") + "(#{stack_amount})"}".strip
        type          = 'boh' if @settings_hash['boh'].include?(name)
        prev_id       = id
        prev_level    = level.to_i
        prev_noun     = noun
        temp_items.push({
          # :rn           => rn,
          :id          => id,
          :location_id => location_id.to_i,
          :level       => level.to_i,
          :path        => path.encode('UTF-8'),
          :type        => type.encode('UTF-8'),
          :name        => name.encode('UTF-8'),
          :noun        => noun.encode('UTF-8'),
          :amount      => amount.to_i,
          :stack       => empty_string,
          :status      => status,
          :marked      => marked.encode('UTF-8'),
          :registered  => registered.encode('UTF-8'),
          :hidden      => hidden.encode('UTF-8'),
          :worn        => empty_string,
          :update_noun => 1
        })

        temp_items.push({
          :id          => id,
          :location_id => location_id.to_i,
          :level       => level + 1,
          :path        => item_path.length > 0 ? "#{path} > #{stack}" : "#{stack}",
          :type        => stack_type.encode('UTF-8'),
          :name        => stack_name.encode('UTF-8'),
          :noun        => stack_noun.encode('UTF-8'),
          :amount      => stack_amount.to_i,
          :stack       => stack.encode('UTF-8'),
          :status      => empty_string,
          :marked      => empty_string,
          :registered  => empty_string,
          :hidden      => empty_string,
          :worn        => empty_string,
          :update_noun => 1
        }) if stack != "";

        if @settings_hash['boh'].include?(name)
          respond "#{name} is a boh" if @debug
          verb = 'look in'
          if name =~ /tackle/
            verb = 'gaze'
          end
          respond "Inv_db.peek_boh(#{id.inspect},#{location_id.inspect},#{level.inspect},#{path.inspect},#{noun.inspect},#{verb.inspect})" if @debug
          boh_items = Inv_db.peek_boh(id, location_id, level, path, noun, verb)
          if boh_items.size > 1
            temp_items.concat(boh_items)
          end
        end
      else
        match_fail_lines << line
        match_fail_count += 1
      end
    }
    if matched_count == displayed_count
      @inv_items = @inv_items + temp_items
      @inventory_count += displayed_count if displayed_count > 0
    else
      _respond "total lines scanned: #{sp_lines.count}"
      _respond "parse count: #{matched_count} != displayed count: #{displayed_count}"
      _respond "failed on lines:\n\n#{match_fail_lines.join('\n')}\n\n"
      if @inv_retry < 4
        _respond "retrying after error in scan & parse: #{scan[:command]}"
        _respond "match_fail_count = #{match_fail_count}"
        _respond "match_fail_lines: #{match_fail_lines.join("\n")}"
        @inv_retry += 1
        _respond "starting attempt ##{@inv_retry}"
        scan_parse_item_lines.call(scan)
      else
        _respond "something is fucky, let's dump the lines:\n\n"
        sp_lines.each_with_index { |line, index|
          respond "#{index}:#{line}"
        }
        _respond "\n\n"
        _respond "giving up on inventory scan, exiting."
        _respond other_lines.join("\n")
        _respond "giving up on inventory scan, exiting."
        close_containers.call
        exit
      end
    end
  }

  # debug_parsed_items = proc {
  #   table_headers =  ["location_id", "level", "path", "type", "noun", "name", "amount", "stack", "status"]
  #   table_format = "| % -12s | %-5s | %-20s | %-9s | %-8s | %-36s | %-8s | %-8s | %-8s |"
  #   respond table_format % table_headers
  #   @inv_items.each { |v|
  #     respond table_format % [v[:location_id], v[:level], v[:path], v[:type], v[:noun], v[:name], v[:amount], v[:stack], v[:status]]
  #   }
  # }

  locker_info = proc {
    @calling_proc = @current_proc
    @current_proc = "locker_info"
    respond "+---------------- proc_start: #{@current_proc}" if @debug

    command         = "locker info"
    start_pattern   = /^#{XMLData.name}, your locker information is as follows:|(?:You possess locker(?<multi>s)|Your locker(?<multi>s)? in .* are currently being swapped|Your locker is currently located in the town of (?<town>.*?)\.|Your locker(?<town> )|(?<town>WARNING).*?: *You currently possess lockers in multiple towns.  However, you are no longer eligible for them.)/i;
    end_pattern     = /^(?:<popBold\/>)?<prompt/;
    locker_info_result = self.client_command(command, start_pattern, end_pattern).join("\n")

    m = patterns[:locker_info].match(locker_info_result)
    if m[:multi] == "s"
      @locker_location = "multi"
      # @subscription   = "premium" if @subscription.nil?
    end
    if m[:town]
      @locker_location = m[:town]
      # @subscription   = "standard" if @subscription.nil?
    end
    @locker_location = @locker_location || "transit"
    # @subscription   =  "standard"  if @subscription.nil?
    # respond "locker_info: @subscription:#{@subscription.inspect}" if @debug

    @locker_info_run = true
  }

  refresh_locker = proc {
    @calling_proc = @current_proc
    @current_proc = "refresh_locker"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    locker_info.call if !@locker_info_run
    locker_premium.call  if @subscription == "premium"
    locker_standard.call if @subscription != "premium"
  }

  def self.object_close(o, path = nil)
    command       = "close #{o.class == String ? o : "##{o.id}"}#{path.nil? ? "" : " #{path}"}"
    start_pattern = /#{o.class == String ? "" : "#{o.id}|"}You close .*|That is already closed|What were you referring to|seem to be any way to do that|You tie/
    quiet         = @quiet;
    end_pattern   = /(<popBold\/>)?<prompt/;
    timeout       = 3
    return self.client_command(command, start_pattern, end_pattern, quiet, timeout)
  end

  def self.object_open(o, path = nil)
    command       = "open #{o.class == String ? o : "##{o.id}"}#{path.nil? ? "" : " #{path}"}"
    start_pattern = /#{o.class == String ? "" : "#{o.id}|"}<exposeContainer|That is already open|<container|There doesn't seem to be any way to do that.|You open|What were you referring to/i
    quiet         = @quiet;
    end_pattern   = /(<popBold\/>)?<prompt/;
    timeout       = 3
    return self.client_command(command, start_pattern, end_pattern, quiet, timeout)
  end

  def self.object_look(o, preposition = 'in', path = nil)
    command       = "look #{preposition} #{o.class == String ? o : "##{o.id}"}#{path.nil? ? "" : " #{path}"}"
    start_pattern = /#{o.class == String ? "" : "#{o.id}|"}<container|That is closed|You see the shifting form/
    quiet         = @quiet;
    end_pattern   = /(<popBold\/>)?<prompt/;
    timeout       = 3
    return self.client_command(command, start_pattern, end_pattern, quiet, timeout)
  end

  locker_open = proc {
    @calling_proc = @current_proc
    @current_proc = "locker_open"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    # open_locker = dothistimeout "open ##{locker.id}", 3, patterns[:locker_open] #/Your locker is currently holding (\d+) items? out of a maximum of (\d+)|That is already open/i
    open_locker = self.object_open(locker).join("/n")
    (self.object_close(locker); locker_open.call;) if open_locker =~ /That is already open/

    if open_locker =~ patterns[:locker_open] # /Your locker is currently holding (\d+) items? out of a maximum of (\d+)/i
      locker_look_count    = $1
      locker_item_capacity = $2
    end
    self.object_look(locker, "in")
  }

  locker_standard = proc {
    @calling_proc = @current_proc
    @current_proc = "locker_standard"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    not_in_locker = true;
    respond "-----Looking for locker by name" if @debug
    locker = GameObj.loot.find { |i| locker = i if i.name =~ /your locker/i }
    if !locker
      respond "-----Looking for locker by noun" if @debug
      locker = GameObj.loot.find { |i| locker = i if i.noun =~ /locker/i }
    end
    if !locker
      respond "-----Looking for locker by interaction" if @debug
      close_result = self.object_close("locker").join("/n")
      if close_result !~ /What were you referring/
        open_result = self.object_open("locker")
        if open_result.join("\n") =~ /<a exist="(\-?\d+)" noun="(locker)">locker<\/a>(.*?)$/i
          _respond "#{$1} | #{$2} | #{$3}" if @debug
          locker = GameObj.new(GameObj.new($1, $2, $3))
        end
      end
    end
    if !locker
      not_in_locker = true;
      respond "Couldn't find your locker" if target == "locker"
    end
    if locker
      sorter_handler.call
      not_in_locker = false;
      locker_open.call
      respond "locker_look_count:#{locker_look_count.inspect}  |  locker_item_capacity:#{locker_item_capacity.inspect}" if @debug
      Inv_db.traverse_container("", locker, -1, "")
      respond "locker_items.count: #{@locker_items.count} " if @debug
      normalize_path = true
      if normalize_path
        @locker_items.each { |h|
          npath = h[:path].gsub(/^ ?in /, '')
          npath = npath.split(' in ')
          npath.each { |i| i.strip! }
          npath = npath.reverse.join(' > ')
          h[:path] = npath
        }
      end
      locker_standard_debug.call if @debug
      insert_temp_item_locker.call if @locker_items.count > 0
      merge_item_by_location.call(10)
    end

    if @subscription != 'f2p'
      scan_time = Benchmark.realtime do;
        locker_manifest_scrape.call(40, 'family vault')
      end;
      Inv_db.gs_print "+----locker manifest family vault total time elapsed #{(scan_time * 1000).round(2)} milliseconds" if @benchmark;
      insert_temp_item_premium_locker.call(40)
      merge_item_by_location.call(40)
    end
  }

  locker_standard_debug = proc {
    @calling_proc = @current_proc
    @current_proc = "locker_standard_debug"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    table_hl     = "+------------------------+-------+------------------------+-------------------+-------------------+"
    table_format = "| %-22s | %-3s | %-32s | %-22s| %-32s "
    table_headers = ["type", "lvl", "path", "noun", "name"]
    output = []
    rows = []
    rows << table_headers
    # output << table_hl
    # output << table_format % table_headers
    # output << table_hl
    @locker_items.each { |i|
      rows << [i[:type], i[:level], i[:path], i[:noun], i[:name]]
    }
    # output << table_hl
    self.to_table(rows)
    output << "+-------- Item count != listed item count." if locker_look_count.to_i != @locker_items.count.to_i
    output << "+-------- Item count == listed item count." if locker_look_count.to_i == @locker_items.count.to_i
    respond output
  }

  locker_premium = proc {
    @calling_proc = @current_proc
    @current_proc = "locker_premium"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    @locations.each { |k, v|
      if k.to_i > 10 and v[:type] == 'locker'
        @locker_items = []
        scan_time = Benchmark.realtime do;
          locker_manifest_scrape.call(k.to_i, v)
        end;
        insert_temp_item_premium_locker.call(k.to_i)
        merge_item_by_location.call(k.to_i)
        Inv_db.gs_print "+----locker manifest #{v[:name]} total time elapsed #{(scan_time * 1000).round(2)} milliseconds" if @benchmark;
      end
    }
  }

  locker_manifest_scrape = proc { |location_id|
    @calling_proc = @current_proc
    @current_proc = "locker_manifest_scrape"
    respond "+---------------- proc_start: #{@current_proc} #{location_id}" if @debug

    lm_lines        = []
    other_lines     = []
    location        = @locations[location_id.to_s][:name]
    displayed_count = 0

    command         = "locker manifest #{location}"
    start_pattern   = /^Thinking back, you recall|^Looking in front of you|^You must first visit your local locker before using the LOCKER MANIFEST command in this town.|^You must have a Premium|Unknown town specified|You do not currently have a.*? vault.|^Unknown town specified/
    end_pattern     = /^(?:<popBold\/>)?<prompt/;
    locker_manifest_command_time = Benchmark.realtime do;
      lm_lines = self.client_command(command, start_pattern, end_pattern)
      lm_lines = self.client_command(command, start_pattern, end_pattern) if lm_lines.nil?
    end;
    Inv_db.gs_print "+--------locker_manifest_command #{location_id} time elapsed #{(locker_manifest_command_time * 1000).round(2)} milliseconds" if @benchmark
    count_line      = lm_lines.find { |line| patterns[:manifest_count].match(line) }
    displayed_count = 0
    if count_line !~ /nothing/
      displayed_count = patterns[:manifest_count].match(count_line).captures[0].to_i
    end

    locker_manifest_parse_time = Benchmark.realtime do;
      if lm_lines.join("\n") !~ /You must have a Premium|You must first visit your local locker before using the LOCKER MANIFEST command in this town.|You do not currently have a.*? vault./
        parse_manifest.call(lm_lines, location_id, displayed_count, other_lines) if lm_lines.size > 0
      end
    end;
    Inv_db.gs_print "+--------locker_manifest_parse #{location_id} time elapsed #{(locker_manifest_parse_time * 1000).round(2)} milliseconds" if @benchmark
  }

  parse_manifest = proc { |pm_lines, location_id, displayed_count, other_lines|
    temp_items = []
    matched_count = 0
    match_fail_lines = []
    match_fail_count = 0
    if pm_lines.size > 0
      Inv_db.gs_print("+-------- #{pm_lines.size} pm_lines to parse") if @debug or @benchmark
    end

    prev_name   = ""
    prev_noun   = ""
    prev_level  = 0
    item_path   = []
    base_path   = nil

    pm_lines.each { |line|
      if (c = patterns[:locker_container].match(line));
        base_path = c[:noun]
        item_path = [base_path.clone]
      elsif (m = patterns[:manifest].match(line));
        matched_count += 1
        leading_space = m[:depth] =~ /<d/ ? m[:depth].gsub!(/<[^>]+>/, "").gsub!(" ", "-") : m[:depth].gsub!(" ", "-")
        prename       = m[:pre] =~ /^(an ?|a ?)(.*)?/ ? $2 : m[:pre]
        id            = m[:exist]
        name          = m[:name].strip
        # noun          = !m[:noun].nil? ? m[:noun] : name.strip.scan(/^(?:.*?) ([^\s]+)$|^([^ ]+)$/).flatten.join('')
        noun          = Inv_db.noun_test(name)
        postname      = m[:post]
        attrs         = m[:attrs]
        registered    = attrs =~ /registered/ ? "Y" : empty_string
        marked        = attrs =~ /marked/     ? "Y" : empty_string
        hidden        = attrs =~ /hidden/     ? "Y" : empty_string
        amount        = 1
        # type          = name == "some blue lapis lazuli" ? "gem" : Inv_db.get_item_type(name,noun) || 'unknown' #empty_string
        type = Inv_db.get_item_type(name, noun) || 'unknown' # empty_string
        level = ((leading_space.length.to_i - 6) / 2).to_i
        item_path.push(prev_noun) if level > prev_level
        if level < prev_level
          n_pop = prev_level - level;
          n_pop.times { item_path.pop; }
          item_path = [base_path] if item_path.length == 0
        end

        path = "#{item_path.join(' > ')}" if !item_path.nil?
        stack         = empty_string
        stack_name    = empty_string
        stack_noun    = empty_string
        stack_type    = empty_string
        stack_amount  = 0
        status        = empty_string

        if type =~ /\bjar\b/
          # if type =~ stack_pattern
          stack_name      = Inv_db.deplural(postname).strip
          stack_noun      = stack_name =~ /(.*?) ([^\s]+)$/ ? $2 : empty_string
          stack_noun      = stack_noun =~ /lazuli/ ? "lapis" : stack_noun
          stack_type      = Inv_db.get_item_type(stack_name, stack_noun) if !postname.nil?
          stack_manifest  = attrs =~ /(\((\d+)\/\d+\))/ ? $1 : nil
          stack_amount    = attrs =~ /\((\d+)\/\d+\)/ ? $1 : nil
          status          = stack_amount.nil? ? "empty" : attrs =~ /\((\d+)\/\1\)/ ? "full" : "partial"
          stack           = "jar" if stack_amount.to_i > 0
        end

        name          = "#{prename}#{name =~ /^(some )?(.*)/ ? $2 : name} #{stack == "" ? postname.strip : "(#{postname.strip}) #{stack_manifest.strip}"}".strip
        prev_level    = level.to_i
        prev_noun     = noun
        prev_name     = name

        temp_items.push({
          :id          => id,
          :location_id => location_id.to_i,
          :level       => level + 1,
          :path        => path.encode('UTF-8'),
          :type        => type ? type : empty_string,
          :name        => name.encode('UTF-8'),
          :noun        => noun.encode('UTF-8'),
          :amount      => amount.to_i,
          :stack       => empty_string,
          :status      => status.encode('UTF-8'),
          :marked      => marked.encode('UTF-8'),
          :registered  => registered.encode('UTF-8'),
          :hidden      => hidden.encode('UTF-8'),
          :worn        => empty_string,
          :update_noun => id ? 1 : 0
        })

        temp_items.push({
          :id          => id,
          :location_id => location_id.to_i,
          :level       => level + 1,
          :path        => "#{path} > #{stack}".to_s.encode('UTF-8'),
          :type        => stack_type ? stack_type : empty_string,
          :name        => stack_name.encode('UTF-8'),
          :noun        => stack_noun.encode('UTF-8'),
          :amount      => stack_amount.to_i,
          :stack       => stack.encode('UTF-8'),
          :status      => empty_string,
          :marked      => empty_string,
          :registered  => empty_string,
          :hidden      => empty_string,
          :worn        => empty_string,
          :update_noun => 0
        }) if stack != "";
      else
        match_fail_lines << line
        match_fail_count += 1
      end
    }
    if matched_count == displayed_count
      @manifest_retry = 1;
      @manifest_count += displayed_count
      matched_count = 0;
      @locker_items = @locker_items + temp_items
    else
      _respond "parse count: #{matched_count} != displayed count: #{displayed_count}"
      if @manifest_retry < 4
        _respond "retrying after missing lines in manifest: #{location_id}"
        _respond "match_fail_count = #{match_fail_count}"
        _respond "match_fail_lines: #{match_fail_lines.join("\n")}"
        @manifest_retry += 1
        _respond "starting attempt ##{@manifest_retry}"
        locker_manifest_scrape.call(location_id)
      else
        _respond other_lines.join("\n")
        _respond "giving up on manifest scan, exiting."
        exit
      end
    end
  }

  query_item = proc { |params|
    @calling_proc = @current_proc
    @current_proc = "query_item"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    respond "+----params:#{params.inspect}" if @debug
    sql, qargs = Inv_db.query_item_sql(params.clone, style)
    Inv_db.gs_print sql if @debug_sql
    begin
      rows = db.execute2(sql, qargs)
    rescue SQLite3::BusyException
      sleep 0.1
      retry
    end
    exit if @debug_sql
    regex_highlight = !params.find { |h| h[:name] == 'search_filter' and h[:operator] == 'REGEXP' }.nil?
    if rows.size > 100 and @settings_hash['confirm_large_output'] == true
      Inv_db.gs_print("#{Script.current.name}: large output requires unpausing the script before flooding the screen.")
      Inv_db.gs_print("  You can change this setting with <d>#{$clean_lich_char}#{Script.current.name} --confirm_large_output=false</d>")
      Inv_db.gs_print("  <d>#{$clean_lich_char}u #{Script.current.name}</d> to print the #{rows.size} row result.")
      pause_script
      Inv_db.output_table(rows, target, qargs, "item", regex_highlight)
    else
      Inv_db.output_table(rows, target, qargs, "item", regex_highlight)
    end
  };

  #------------------------------------------------------------------------------#
  # sum / aggregate queries
  #------------------------------------------------------------------------------#
  sum_item = proc { |params|
    @calling_proc = @current_proc
    @current_proc = "sum_item"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    respond "+----params:#{params.inspect}" if @debug
    sql, qargs = Inv_db.sum_item_sql(params.clone, "")
    Inv_db.gs_print sql if @debug_sql
    begin
      rows = db.execute2(sql, qargs)
    rescue SQLite3::BusyException
      sleep 0.1
      retry
    end
    Inv_db.output_table(rows, target, qargs, "item")
  };
  count_item = proc { |params|
    @calling_proc = @current_proc
    @current_proc = "count_item"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    respond "+----params:#{params.inspect}" if @debug
    sql, qargs = Inv_db.count_item_sql(params.clone, "")
    Inv_db.gs_print sql if @debug_sql
    begin
      rows = db.execute2(sql, qargs)
    rescue SQLite3::BusyException
      sleep 0.1
      retry
      #    ensure
      #      #db.close if db
    end
    Inv_db.output_table(rows, target, qargs, "item")
  };
  #------------------------------------------------------------------------------#
  # export helpers
  #------------------------------------------------------------------------------#
  export_formats = Hash.new
  export_formats["csv"]  = { :type => 'csv', :delimiter => ',',   :extension => 'csv' }
  export_formats["txt"]  = { :type => 'txt', :delimiter => 9.chr, :extension => 'txt' }
  export_formats["text"] = { :type => 'txt', :delimiter => 9.chr, :extension => 'txt' }
  export_formats["pipe"] = { :type => 'txt', :delimiter => '|',   :extension => 'txt' }
  #------------------------------------------------------------------------------#
  # Export
  #------------------------------------------------------------------------------#
  export = proc { |_target, qparams, xparams|
    # where, qargs, extra = self.where_builder(params, '')

    export_format = xparams[:format].nil? ? export_formats["csv"] : export_formats[xparams[:format]]

    dir_delim = $lich_dir =~ /(\\|\/)/ ? $1 : "/"
    export_dir = xparams[:dir] || "#{$lich_dir}inv"
    export_dir = export_dir.gsub(/\$lich_dir/i, $lich_dir)

    respond "export_dir:#{export_dir.inspect}" if @debug
    Dir.mkdir(export_dir) unless File.exist?(export_dir)
    export_dir = "#{export_dir}#{dir_delim}" if export_dir.slice(-1) !~ /\/\\$/

    datetimestamp = "#{Time.now.strftime("%Y-%m-%d_%H-%M-%S")}"

    respond "qparams:#{qparams.inspect}" if @debug

    params_for_export = []
    qparams.each { |h|
      if @filters.include?(h[:name]) and h[:operator] !~ /REGEX/
        params_for_export << "#{h[:operator][0] == '!' ? "not_" : ""}#{h[:value].downcase}"
      end
    }
    query_params = (params_for_export.empty? ? "" : (params_for_export.join('_'))).gsub(' ', '_')
    respond "query_params:#{query_params.inspect}" if @debug

    export_filename = xparams[:file] || "#{target}_#{query_params}_#{datetimestamp}.#{export_format[:extension]}"
    export_filename = export_filename.sub('timestamp', datetimestamp)
    export_file = "#{export_dir}#{export_filename}"

    style = xparams[:style] || "export"

    sql, qargs = Inv_db.query_bank_sql(qparams, style) if target == "bank"
    sql, qargs = Inv_db.sum_bank_sql(qparams, style)   if target == "sbank"
    sql, qargs = Inv_db.query_tickets_sql(qparams, style) if target == "tickets"
    sql, qargs = Inv_db.sum_tickets_sql(qparams, style) if target == "stickets"

    sql, qargs = Inv_db.query_char_sql(qparams, style) if target == "character"
    sql, qargs = Inv_db.query_item_sql(qparams, style) if target =~ /item|inv|loc/
    rows = db.execute2(sql, qargs)

    if rows.length > 1
      if export_format[:type] !~ /csv/
        begin
          file = File.open(export_file, "w+")
          rows.each { |row|
            file.puts row.join(export_format[:delimiter])
          }
        ensure
          file.close
        end
      end
      if export_format[:type] =~ /csv/
        begin
          require 'csv'
          csv = CSV.open(export_file, "w+")
          rows.each { |row|
            csv << row
          }
        ensure
          csv.close
        end
      end
      export_file = export_file.gsub("/", "\\") if export_file =~ /^\w:/i
      Inv_db.gs_print Inv_db.format_whisper("exported #{rows.length - 1} row#{rows.length > 2 ? "s" : ""} from #{target} to #{export_file}.")
    else
      Inv_db.gs_print Inv_db.format_monsterbold("no rows to export for #{target}")
    end
  }

  #------------------------------------------------------------------------------#
  # dynamic where sql
  #------------------------------------------------------------------------------#
  def self.extras_processor(h)
    e = {}
    key = h[:name].to_sym
    if h[:name] == 'orderby'
      h[:value] = h[:value].to_s.gsub(/['"]/, "").gsub(/[,]+/, ", ").gsub("-", " desc ").gsub("+", " asc ")
    end
    e[key] = h[:value]
    return e
  end

  def self.where_expression(h)
    return nil if !h.key?(:value)
    expression = nil
    if h[:operator] == "REGEXP"
      operator = "REGEXP"
      expression = "#{operator} :#{h[:name]}_filter"
    elsif h[:value].class == String
      operator = "like"
      operator = "not like" if h[:operator] =~ /^(?:!=|<>)$/
      expression = "#{operator} :#{h[:name]}_filter"
    elsif h[:value].class.to_s =~ /Fixnum|Integer/
      operator = h[:operator]
      expression = "#{operator} :#{h[:name]}_filter"
    elsif h[:value].class == Array
      operator = "in"
      operator = "not in" if h[:operator] =~ /^(?:!=|<>)$/
      expression = "#{operator} ( '#{h[:value].map { |s| s.gsub("'", "''") }.join("','")}' )"
    end
    return expression
  end

  @filter_operator_pattern = /^(?:\!=|<=?|>=?|<>|=|!?REGEXP)$/

  @query_types = {
    "account" => "a", "bank" => "b", "character" => "c", "detail" => "d", "item" => "i", "lumnis" => "u",
    "note" => "n", "property" => "p", "resource" => "e", "room" => "r", "tickets" => "t"
  }
  @filter_map = {
    # char
    "account" => "c", "area" => "c", "char" => "c", "citizenship" => "c", "game" => "c", "level" => "c", "race" => "c",
    "rank" => "c", "society" => "c", "subscription" => "c",
    # item
    "hidden" => "i", "marked" => "i", "noun" => "i", "path" => "i", "qty" => "i", "registered" => "i", "stack" => "i", "status" => "i", "type" => "i", "worn" => "i",
    # location
    "location" => "l",
    # lumnis
    "double" => "u", "triple" => "u", "start_day" => "u", "start_time" => "u", "last_schedule" => "u",
    # resource
    "energy" => "e", "weekly" => "e", "suffused" => "e", "bonus" => "e", "favor" => "e",
  }
  @special_filters = { "account" => nil, "amount" => nil, "chararacter" => nil, "name" => nil, "character" => nil, "search" => nil, "location_type" => nil, "total" => nil, "status" => nil }

  @amount_map = { "bank" => "s", "item" => "i", "tickets" => "t" }
  @search_map = { "account" => "account", "bank" => "name", "tickets" => "source", "character" => "name", "item" => "name" }
  @dealias = { "rank" => "society_rank" }
  @where_prefix = "\n      and "

  def self.where_expression_special(h, query_type, _aggregate)
    where = ""
    qargs = {}
    (respond "---#{Script.current.name}: error: unknown operator #{h[:operator].inspect}"; exit) if !@filter_operator_pattern.match(h[:operator]);
    h[:value] = h[:value].gsub('*', '%') if h[:value].class == String
    if h[:name] == 'location'
      where += "#{@where_prefix}(l.name #{self.where_expression(h)} or l.abbr #{self.where_expression(h)})"
      qargs[:location_filter] = h[:value] if h[:value].class != Array
    elsif h[:name] == 'location_type'
      where += "#{@where_prefix}(l.type #{self.where_expression(h)} )" if h[:value].to_s.downcase != 'all'
      qargs[:location_type_filter] = h[:value] if h[:value].class != Array
    elsif h[:name] == 'search'
      if query_type == 'tickets'
        where += "#{@where_prefix}(t.source #{self.where_expression(h)} or t.currency #{self.where_expression(h)})"
      else
        where += "#{@where_prefix}#{@query_types[query_type]}.#{@search_map[query_type]} #{self.where_expression(h)}"
      end
      qargs[:search_filter] = h[:value].gsub(/^=/, '')
      qargs[:search_filter] = "%#{h[:value]}%" if h[:operator] == "=" and h[:value] !~ /^=/
      respond "qargs[:search_filter]:#{qargs[:search_filter].inspect}" if @debug_sql
    elsif h[:name] == 'character'
      where += "#{@where_prefix}c.name #{self.where_expression(h)}"
      qargs[:character_filter] = h[:value] if h[:value].class != Array
    elsif h[:name] == 'amount'
      where += "#{@where_prefix}#{@amount_map[query_type]}.amount #{self.where_expression(h)}"
      qargs[:amount_filter] = h[:value]
    elsif h[:name] == 'account'
      where += "#{@where_prefix}#{query_type == 'account' ? 'a' : 'c'}.account #{self.where_expression(h)}"
    elsif h[:name] == 'total'
      where += "#{@where_prefix}#{@query_types[query_type]}.total #{self.where_expression(h)}"
    end
    return where, qargs
  end

  def self.where_builder(filter_array = [], query_type = 'item', aggregate = false)
    (respond "---#{Script.current.name}: error: unknown query_type #{query_type.inspect}"; exit) if !@query_types.key?(query_type)
    where = "";
    qargs = {};
    extras = {};
    filter_array.each { |h|
      respond h.inspect if @debug_sql
      next if @export_options.include?(h[:name])
      if @extras.include?(h[:name])
        extra = self.extras_processor(h, query_type)
        extras.merge!(extra)
        next
      end
      (respond "---#{Script.current.name}: error: unknown operator #{h[:operator].inspect}"; exit) if !@filter_operator_pattern.match(h[:operator]);
      if @special_filters.key?(h[:name])
        w, qarg = self.where_expression_special(h, query_type, aggregate)
        where += w
        qargs.merge!(qarg)
        next
      end
      if !@filter_map.key?(h[:name])
        respond "--- #{Script.current.name}: error: unknown filter #{h[:name].inspect}"
      else
        h[:value] = h[:value].gsub('*', '%') if h[:value].class == String
        table_alias = @filter_map[h[:name]] if @filter_map.key?(h[:name])
        h[:name] = @dealias[h[:name]] if @dealias.key?(h[:name])
        table_alias = @filter_map[h[:name]] if @filter_map.key?(h[:name])

        where += "#{@where_prefix}#{table_alias}.#{h[:name]} #{self.where_expression(h)}"
        key = "#{h[:name]}_filter".to_sym
        qargs[key] = h[:value] if h[:value].class != Array
      end
    }
    where = "\n    where #{where[11..-1]}" if where[0..10] == "#{@where_prefix}"
    respond "where:#{where.inspect}\nqargs:#{qargs.inspect}\nextras:#{extras.inspect}" if @debug_sql
    return where, qargs, extras
  end

  #------------------------------------------------------------------------------#
  # messy user input helper
  #------------------------------------------------------------------------------#
  def self.generate_partials(arr, min_length = 1, concat = "");
    h = Hash.new;
    arr.each { |a|
      temp_str = a.clone;
      matchto_str = a == "inventory" ? "inv" : a;
      iter = (temp_str.length - min_length);
      h["#{temp_str}#{concat}"] = matchto_str;
      iter.times {
        temp_str.slice!(-1);
        h["#{temp_str}#{concat}"] = matchto_str if !h.key?("#{temp_str}#{concat}");
      };
    };
    return h;
  end;
  #------------------------------------------------------------------------------#
  # Parse user input
  #------------------------------------------------------------------------------#
  # exit if api load
  exit if Script.current.vars[0] =~ /^(?:@|\-+)api/;

  (@benchmark   = true;) if Script.current.vars[0] =~ /@ben/
  (@debug       = true;) if Script.current.vars[0] =~ /@debug/
  (@debug_sql   = true;) if Script.current.vars[0] =~ /@sql|@debug_sql/
  (@debug_hook  = true;) if Script.current.vars[0] =~ /@hook/
  (@debug_input = true;) if Script.current.vars[0] =~ /@input|@debug_input/
  (@debug_print = true;) if Script.current.vars[0] =~ /@print|@debug_print/
  (@no_squelch  = true;) if Script.current.vars[0] =~ /@no_?squelch/
  (@autofit     = true;) if Script.current.vars[0] =~ /@autofit/
  (@slower      = true;) if Script.current.vars[0] =~ /@slower/

  silence_me if !@debug && !@no_squelch

  actions = ["query", "refresh", "report", "count"]
  targets = ["all", "account", "bank", "character", "inventory", "item", "locker", "lumnis", "notes", "property", "resource", "room", "sbank", "silver", "stickets", "tickets"]
  @filters = ["account", "amount", "area", "character", "game", "hidden",
              "location", "marked", "noun", "name", "path", "qty", "race",
              "registered", "society", "stack", "status", "subscription", "type", "worn",
              "society", "citizenship", "rank", "suffused", "weekly", "total", "favor", "energy"]
  @extras = ["select", "include", "groupby", "orderby", "limit"]

  @export_options = ["format", "style", "dir", "file"]
  # todo: abbreviations for columns in additional groupby
  # groupbys = ["character", "name", "noun", "amount", "qty", "type", "stack", "status", "location", "path", "marked", "registered", "worn" ]

  partials = Hash.new
  partials[:actions] = self.generate_partials(actions, 1)
  partials[:actions]["export"] = "export"
  partials[:actions]["reset"]  = "reset"
  partials[:actions]["delete"] = "delete"
  partials[:actions]["drop"]   = "drop"
  partials[:actions]["sum"]    = "sum"
  partials[:actions]["count"]  = "count"
  partials[:actions]["total"]  = "sum"

  partials[:actions]["update"] = "update"
  partials[:actions]["add"]    = "add"
  partials[:actions]["remove"] = "remove"


  partials[:targets] = self.generate_partials(targets, 1)
  partials[:targets]["scrip"] = "tickets"

  partials[:filters] = self.generate_partials(@filters, 1)
  partials[:filters]["epf"] = "status"
  partials[:filters]["stk"] = "stack"
  partials[:filters]["act"] = "account"
  partials[:filters]["lvl"] = "level"
  partials[:filters]["char"] = "character"

  partials[:extras] = self.generate_partials(@extras, 5)

  partials[:export]

  # print_partials = proc {
  #   table_headers = ["partial", "target"]
  #   table_format = "| %-22s | %-22s"
  #   respond table_format % table_headers
  #   partials.each { |type, h|
  #     respond "-----#{type}"
  #     h.each { |k, v|
  #       respond table_format % [k, v]
  #     }
  #   }
  # }
  # print_partials.call
  vars = Script.current.vars
  vars.delete_if { |i| i =~ /^(@|delay=)/ }
  _respond "invdb vars:#{vars.inspect}" if @debug_input

  if @debug_input
    if vars.empty?
      respond "no input"
    else
      i = 0
      vars.each {
        respond "#{i}: #{Script.current.vars[i]}"
        i += 1
      }
    end
  end
  if vars.select { |v| v =~ /^[^@]/ }.compact.empty?
    action = "refresh"
    target = "all"
  else
    reparse_vars = []
    regex_join = []
    regex_index_start = nil

    action = partials[:actions][vars[1]]
    vars.slice!(1) if action
    target = partials[:targets][vars[1].to_s] if action
    item_filter = target if target =~ /^(inv|locker|item|all)/i
    vars.slice!(1) if action && target

    action = action.nil? ? "query" : action
    target = target.nil? ? (action =~ /query|sum|count/ ? "item" : "all") : target

    ## reparse vars
    vars.each_with_index { |v, x|
      next if x == 0
      if !regex_index_start.nil?
        regex_join << v
        if v =~ /[^\\]\/$/
          reparse_vars << regex_join.join(' ')
          regex_index_start = nil
        end
      elsif v =~ /=\/[^\/]+$/
        regex_join = []
        regex_join << v
        regex_index_start = x
      else
        reparse_vars << v
      end
    }

    respond "--- #{Script.current.name}: error: unclosed regex expression" if !regex_index_start.nil?

    filter_pattern = /(?<filter_key>..*?)(?<operator>[!<>=]+)(?<filter_value>..*)$/
    search_expression = []
    filters = []

    reparse_vars.each_with_index { |v, _x|
      captures = v.match(filter_pattern).captures
      if captures[2][0] == '/' and captures[2][-1] == '/'
        captures[1] = (captures[1] =~ /!=|<>/ ? '!REGEXP' : 'REGEXP')
        captures[2] = "#{captures[2][1..-2]}"
      elsif captures[2] =~ /^[\d,]+$/
        captures[2] = captures[2].delete(',').to_i
      elsif captures[2] =~ /\|/
        captures[2] = captures[2].split(/\| */)
      elsif captures[2] =~ /,/
        captures[2] = captures[2].split(/, */)
      elsif captures[2] == "''"
        captures[2] = ""
      elsif v !~ filter_pattern
        search_expression << v
      end
      if !captures.nil?
        name = captures[0]
        name = partials[:filters][captures[0].downcase] if partials[:filters].key?(captures[0].downcase)
        name = partials[:extras][captures[0].downcase] if partials[:extras].key?(captures[0].downcase)
        captures[0] = name
        h = Hash[[:name, :operator, :value].zip(captures)]
        respond h.inspect if @debug_input
        filters << h
      end
    }

    if search_expression.size > 0
      search_value = search_expression.join(' ')
      operator = "="
      if search_value[0] == '/' and search_value[-1] == '/'
        operator = "REGEXP"
        search_value = "#{search_value[1..-2]}"
      end
      search_hash = Hash[[:name, :operator, :value].zip(['search', operator, search_value])]
      respond "search_hash:#{search_hash.inspect}" if @debug
      filters << search_hash
    end
    if !filters.find { |h| h[:name] == 'game' }
      filters << Hash[[:name, :operator, :value].zip(['game', '=', XMLData.game])]
    end
    filters << Hash[[:name, :operator, :value].zip(['location_type', '=', item_filter])] if item_filter.to_s =~ /^(?:inv|locker)/
    input_params = filters
  end
  #------------------------------------------------------------------------------#
  # do stuff
  #------------------------------------------------------------------------------#
  if action == "refresh"
    require "benchmark"

    @character_id = self.character_id_get(db)

    # need account for character, family vault
    if target =~ /cha|item|locker|all/ || target.nil?

      if @account_name.nil? or @subscription.nil? or @locker_location.nil?
        Inv_db.gs_print "fetching account info" if @debug
        account_time = Benchmark.realtime do
          @account_name, @subscription = self.account_get
        end
        Inv_db.gs_print "account time elapsed #{(account_time * 1000).round(2)} milliseconds" if @benchmark
        locker_info_time = Benchmark.realtime do
          locker_info.call if @locker_location.nil?
        end
        Inv_db.gs_print "locker info time elapsed #{(locker_info_time * 1000).round(2)} milliseconds" if @benchmark
      end
    end

    if target =~ /cha|all/i || target.nil?
      Inv_db.gs_print "updating character..." if !@benchmark
      char_time = Benchmark.realtime do
        refresh_char.call()
      end
      Inv_db.gs_print "refresh_char time elapsed #{(char_time * 1000).round(2)} milliseconds" if @benchmark
    end

    if (target == 'lumnis' or (target == 'all' and @settings_hash['lumnis'] == true))
      if @subscription.nil?
        @account_name, @subscription = self.account_lookup(db)
      end
      if @subscription == 'f2p'
        Inv_db.gs_print "skipping lumnis on f2p..."
      else
        Inv_db.gs_print "updating lumnis..." if !@benchmark
        lumnis_time = Benchmark.realtime do
          self.lumnis_refresh(db)
        end
        Inv_db.gs_print "refresh_lumnis time elapsed #{(lumnis_time * 1000).round(2)} milliseconds" if @benchmark
      end
    end

    if (target == 'resource' or (target == 'all' and @settings_hash['lumnis'] == true))
      if @subscription.nil?
        @account_name, @subscription = self.account_lookup(db)
      end
      if @subscription == 'f2p'
        Inv_db.gs_print "skipping resource on f2p..."
      else
        Inv_db.gs_print "updating resource..." if !@benchmark
        resource_time = Benchmark.realtime do
          self.resource_refresh(db)
        end
        Inv_db.gs_print "refresh_resource time elapsed #{(resource_time * 1000).round(2)} milliseconds" if @benchmark
      end
    end

    # if target == 'account' or (target == 'all' and @settings_hash['resource'] == true)
    #
    # end

    if target =~ /bank|all/i || target.nil?
      Inv_db.gs_print "updating bank account..." if !@benchmark
      bank_time = Benchmark.realtime do
        refresh_bank.call()
      end
      Inv_db.gs_print "refresh_bank time elapsed #{(bank_time * 1000).round(2)} milliseconds" if @benchmark
    end

    if target =~ /tickets|all/i || target.nil?
      Inv_db.gs_print "updating ticket balance..." if !@benchmark
      ticket_time = Benchmark.realtime do
        refresh_tickets.call()
      end
      Inv_db.gs_print "refresh_tickets time elapsed #{(ticket_time * 1000).round(2)} milliseconds" if @benchmark
    end

    if target =~ /inv|locker|item|all/i || target.nil?
      item_time = Benchmark.realtime do
        refresh_item.call(input_params)
      end
      Inv_db.gs_print "+refresh_item time elapsed #{(item_time * 1000).round(2)} milliseconds" if @benchmark
    end
  end # end refresh

  if action == "query"
    target = target.nil? ? "item" : target
    query_char.call(input_params)         if target =~ /char/i
    query_bank.call(input_params)         if target =~ /wealth|bank|silver/i
    query_tickets.call(input_params)      if target =~ /tickets/i
    query_item.call(input_params)         if target =~ /inv|locker|item/i
    self.lumnis_query(db, input_params)   if target == 'lumnis'
    self.resource_query(db, input_params) if target == 'resource'
  end

  if action == "sum"
    target = target.nil? ? "item" : target
    sum_bank.call(input_params) if target =~ /wealth|bank|silver/i
    sum_tickets.call(input_params) if target =~ /tickets/i
    sum_item.call(input_params) if target =~ /inv|locker|item/i
  end

  if action == "count"
    target = target.nil? ? "item" : target
    count_item.call(input_params) if target =~ /inv|locker|item/i
  end

  if action == "export"
    xparams = {}
    xparams[:style]  = "export"
    xparams[:format] = input_params.find { |h| h[:name] = "format" }[:value] if input_params.find { |h| h[:name] == "format" }
    xparams[:dir]    = input_params.find { |h| h[:name] = "dir" }[:value]    if input_params.find { |h| h[:name] == "dir" }
    xparams[:file]   = input_params.find { |h| h[:name] = "file" }[:value]   if input_params.find { |h| h[:name] == "file" }
    export.call(target, input_params, xparams)
  end

  if action == "delete"
    character_filter = input_params.find { |h| h[:name] == "character" }[:value];
    _respond "character_filter = #{character_filter}" if @debug
    _respond "target = #{target}" if @debug
    delete_bank.call(input_params)    if target =~ /all|char|bank|silver|wealth/i && character_filter
    delete_tickets.call(input_params) if target =~ /all|tickets/i && character_filter
    delete_item.call(input_params)    if target =~ /all|char|inv|item|locker/i && character_filter
    delete_char.call(input_params)    if target =~ /all|char/i && character_filter
  end

  if action == "reset"
    target = target.nil? ? "all" : target
    if Script.current.vars[0] =~ /confirm$/i
      Inv_db.drop_tables(target)
    else
      echo "Warning:  This will drop all the tables related to '#{target}' in the inv.db3 database.  If you wish to continue, enter the command with CONFIRM at the end."
    end
  end

  #------------------------------------------------------------------------------#
  # sum up, if did stuff
  #------------------------------------------------------------------------------#
  has_changes = 0
  @db_changes.each { |k, v|
    v.each { |_l, w|
      has_changes = w if w > has_changes
    } if k !~ /char/
  }
  Inv_db.gs_print "action:#{action.inspect} | has_changes:#{has_changes.inspect}" if @debug

  if action =~ /^(r|d)/i && has_changes > 0
    to_print = []
    changes_hl = "+----------+----------+----------+----------+"
    to_print << empty_string
    to_print << @mono_start
    to_print <<  changes_hl
    to_print <<  "| %-8s | %-8s | %-8s | %-8s |" % ["table", "inserted", "updated", "deleted"]
    to_print <<  changes_hl
    @db_changes.each { |k, v|
      to_print << "| %-8s | %8s | %8s | %8s |" % [k, v[:inserted], v[:updated], v[:deleted]] if v.values.max > 0
    }
    to_print << changes_hl
    to_print << @mono_end
    Inv_db.gs_print to_print.join("\n")
  end
  final_output = []
  final_output << "Total inventory items: #{@inventory_count}" if @inventory_count > 0
  final_output << "Total manifest items: #{@manifest_count}" if @manifest_count > 0
  Inv_db.gs_print Inv_db.format_whisper(final_output.join("\n")) if final_output.length > 0
  #------------------------------------------------------------------------------#
  # close db
  # added sqlite VACUUM every 12 hours.  That's often, but it's fast.
  #------------------------------------------------------------------------------#

  begin
    retries ||= 0
    stmt.close if !stmt.closed?
    if has_changes > 0
      last_vacuum = @settings_hash["last_vacuum"]
      respond "last_vacuum:#{last_vacuum.inspect}" if @debug
      if (last_vacuum + 36000) < Time.now # vacuum once every ten hours
        db.execute('VACUUM') if has_changes > 0
        Settings["last_vacuum"] = Time.now;
        Settings.save;
      end
    end
    db.close if db
    _respond "invdb: db closed" if @debug
  rescue SQLite3::BusyException
    sleep 0.4
    retry if (retries += 1) < 3
  end

  if XMLData.name == 'Xanlin' or @benchmark
    end_time = Time.now;
    total_run_time = (end_time.to_r - start_time.to_r).to_f
    respond "total run time: #{sprintf("%d:%02d:%06.3f", (total_run_time / 3600), (total_run_time / 60) % 60, total_run_time % 60)}"
  end;
end; # end module Inv_db
