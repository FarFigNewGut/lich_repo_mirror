=begin
  Cross-character searching & tracking of inventory, lockers, bank accounts, and other data.
  
  If you have questions, message me on lnet or discord.
  
  Thank you to those who help test and provide feedback:
    Soliere, Tawariell, Dirvy, Rovvigen, Veni, Selema, Shaelethe and more
    
  Thank you to those on discord that help answer questions:
    Luxelle, Ondreian, LostRanger, Tillmen, Tysong, and many others.

  This does not (yet) use hooks or watch your actions to update. 
  
  To update the database, run ;inv, and/or add it to autostart, etc.
  
  Special thanks to LostRanger for permission for loglore, inspect, jarserve, and more.
  
  player's corner forum post: https://tinyurl.com/gs4-invdb

          author: Xanlin (Xanlin#4407 on discord)
            game: GS
            tags: inventory, utility, database
  requires_trust: true
        required: Lich >= 4.6.4
         version: 0.3.2.15
  sqlite_version: 3.8.3+  (lich installs version 3.8.11.1 on windows which meets the requirement)
  +---------------------------------------------------------------+
  ;inv help      > help text 
  ;inv menu      > basic starter menu
  ;inv examples  > examples 
  ;inv changelog > changelog
=end
=begin
  todo:
    user feedback on documentation, options, etc.
    faster jar reads
    add other stack item types & contents
    add wealth/notes
    add profile info, stats, skills, society
    fix manifest nouns against list of known item/nouns?
    implement worn
    
    print limit / offset / paging
  +---------------------------------------------------------------+
=end
#------------------------------------------------------------------------------#
# Settings
#------------------------------------------------------------------------------#
(echo "skipping test server";exit;) if XMLData.game == 'GST' and (script.vars[0] !~ /^[qcs]/ or script.vars.size == 0)

Settings.load;
(Settings["container_noopen"] = [];Settings.save) if Settings["container_noopen"] == nil;
(Settings["last_vacuum"] = Time.now-3600000;Settings.save) if Settings["last_vacuum"] == nil;

boolean_settings = Hash.new
  ['use_old_quiet_command','stack','autofit'].each { |s| boolean_settings[s]=false}
  ['jar'].each { |s| boolean_settings[s]=false}

if script.vars[0] =~ /--settings/i
  Settings_hash = Settings.to_hash
  Settings_hash.each { |s,v|
    respond "#{s}: #{v}"
  }
  exit
end

@use_old_quiet_command = Settings["use_old_quiet_command"];

boolean_settings_pattern = /--(#{boolean_settings.keys.join('|')})(?: ?[=: ] ?)(\w+)/i
if script.vars[0] =~ boolean_settings_pattern;
  script.vars[0].scan(boolean_settings_pattern).each { | n,v |
    setting_name = n.downcase
    setting_value_string = v
    if setting_value_string =~ /true|false|on|off/i
      setting_value = setting_value_string =~ /true|on/i ? true : false;
      if Settings[setting_name] != setting_value
        respond "invdb: #{setting_name}: #{setting_value}"
        Settings[setting_name] = setting_value;
        Settings.save;
      else
        respond "invdb: #{setting_name} was already set to #{setting_value}"
      end
    else 
      respond "invdb: unknown value '#{setting_value_string}' for #{setting_name}. Try true, false, on, or off.";
    end;
  }
  exit;
end

if script.vars[0] =~ /--noopen(.*)/;
  noopen = $1.split(/(?:\s*[,;|]\s*)+/);
  if noopen.length > 0;
    noopen.each {|c|;
      next if c.strip.length == 0;
      if !Settings["container_noopen"].include?(c.strip);
        Settings["container_noopen"].push(c.strip);
        _respond "invdb: #{c.strip} added to the noopen list";
      else;
        _respond "invdb: #{c.strip} is already on the noopen list";
      end;
    };
    Settings.save;
  else noopen.length == 0;
    _respond "invdb: noopen list:";
    Settings["container_noopen"].each_with_index {|c,i|;
      _respond "#{i+1}: #{c}";
      };
  end;
  exit;
end;

if script.vars[0] =~ /--open (.+)/;
  noopen = $1.split(/(?:\s*[,;|]\s*)+/);
  if noopen.length > 0;
    noopen.each {|c|;
      next if c.strip.length == 0;
      if Settings["container_noopen"].include?(c.strip);
        Settings["container_noopen"].delete(c.strip);
        _respond "invdb: #{c.strip} removed from the noopen list";
      else
        _respond "invdb: #{c.strip} is not on the noopen list";
      end;
    };
    Settings.save;
  end;
  exit;
end;
#------------------------------------------------------------------------------#
# Module to wrap up methods so as not to pollute the global object
#------------------------------------------------------------------------------#
module Inv_db;
  def self.open;
    require 'sqlite3';
    db = SQLite3::Database.open "#{$lich_dir}data/inv.db3";
    db.execute('PRAGMA temp_store = MEMORY');
    return db;
  end;
  def self.sqlite_version;
    require 'sqlite3';
    db = Inv_db.open;
    sqlite_version = db.get_first_value('select sqlite_version()');
    db.close;
    return sqlite_version;
  end;
  #------------------------------------------------------------------------------#
  # instance variables - newbie debugging
  # I know I shouldn't have instance variables on both sides of 
  # the module; I'll have to refactor this more as I learn more.
  #------------------------------------------------------------------------------#
  @debug = false; @debug_sql = false; @debug_hook = false; @debug_input = false; @debug_print = false; @no_squelch = false; 
  @slower = false; @quiet = true; @use_old_quiet_command = false; @autofit=false
  @slower = true if $frontend !~ /stormfront|profanity/
  def self.debug=(bool)       @debug       = bool == true ? true : false end
  def self.debug_sql=(bool)   @debug_sql   = bool == true ? true : false end
  def self.debug_hook=(bool)  @debug_hook  = bool == true ? true : false end
  def self.debug_print=(bool) @debug_print = bool == true ? true : false end
  def self.debug_input=(bool) @debug_input = bool == true ? true : false end
  def self.no_squelch=(bool)  @no_squelch  = bool == true ? true : false end
  def self.autofit=(bool)     @autofit     = bool == true ? true : false end
  def self.slower=(bool)      @slower      = bool == true ? true : false end
  def self.use_old_quiet_command=(bool) @use_old_quiet_command = bool == true ? true : false end
  @empty_string = "".encode("UTF-8")
  #------------------------------------------------------------------------------#
  # output formatting helpers
  #------------------------------------------------------------------------------#
  def self.int_to_comma(var) (var.is_a? Integer) ? var.to_s.reverse.scan(/(?:\d*\.)?\d{1,3}-?/).join(',').reverse.to_s : var end;
  def self.int_to_time(var) (var.is_a? Integer) ? Time.at(var.to_i).strftime("%Y-%m-%d %H:%M") : var end
  def self.int_to_ustime(var) (var.is_a? Integer) ? Time.at(var.to_i).strftime("%x %I:%M%p") : var end
  def self.int_to_usdate(var) (var.is_a? Integer) ? Time.at(var.to_i).strftime("%x") : var end
  @mono_start = %{<output class="mono" />}
  @mono_end   = %{<output class="" />}
  def self.format_mono(msg) "<output class=\"mono\" />\n#{msg}\n<output class=\"\" />"; end;
  @monsterbold_start = $fake_stormfront ? "\034GSL\r\n " : "<pushBold\/>"
  @monsterbold_end   = $fake_stormfront ? "\034GSM\r\n " : "<popBold\/>"
  def self.format_monsterbold(msg) "#{@monsterbold_start}#{msg}#{@monsterbold_end}"end
  def self.format_whisper(msg) "<preset id=\"whisper\">#{msg}</preset>"; end
  def self.gs_print(msg) 
     if $frontend =~ /stormfront/
       puts msg
     elsif $frontend =~ /profanity/
       _respond msg
    else
      $stdout.puts msg.gsub!(/<.*?>/, '')
    end
  end
  #------------------------------------------------------------------------------#
  # item scraping helpers
  #------------------------------------------------------------------------------#
  @deplural = Hash.new
  @deplural["essences"] = "essence"
  @deplural["teeth"]    = "tooth"
  @deplural["motes"]    = "mote" 
  @deplural["pieces"]   = "piece"
  @deplural["shards"]   = "shard"
  @deplural["globes"]   = "globe"
  @deplural["blades"]   = "blade"
  @deplural["branches"] = "branch"
  @deplural["fans"]     = "fan"
  @deplural["cabochons"]= "cabochon"
  @deplural["rose gold fire"] = "rose-gold fire"
  @deplural["slices"] = "slice"
  def self.deplural(str) 
    str = str.strip =~ /^(containing )?(.*?)(ies|(?<=onyx)es|(?<=z)es|(?<!mos|glas)s)?$/ ? "#{$2}#{$3 == 'ies' ? 'y' : ''}" : str;
    str.gsub(/\b(#{@deplural.keys.join("|")})\b/,@deplural); 
  end
  #need to move @patterns into inv_db -- one place for all patterns.
  container_patterns = Hash.new
  container_patterns[:container_already_open] = /^There doesn't seem to be any way to do that|^It appears to be locked|(?<already_open>already open|open already|resists opene?ing|absentmindedly fiddle with your)/
  container_patterns[:container_opened] = /(You .*?|Hooking |Lightly |Pinching |Sliding)?(?<opened>open|push|pull|flip|unwind|unfasten|unsnap|unhitch|unclasp|a finger|pick at|brushing|the toggle|the lever|rub your hand across)/i
  container_patterns[:container_not_holding] = /(?<not_holding>Try holding it first|You need to be holding)/
  @open_container_pattern = /#{container_patterns.collect{|k,v| v.to_s}.join("|")}/
  Invdb.gs_print(@open_container_pattern) if @debug
  
  def self.container_open(container_id)
    #open_container_pattern results named matches: m[:opened], m[:already_open], m[:not_holding]
    result = dothistimeout  "open ##{container_id}", 1, @open_container_pattern
    m = @open_container_pattern.match(result)
    return container_id if m[:opened] && !m[:already_open]
  end
  
  @invdb_type_data_exclude = /,?(uncommon|pennant chase|pennant|chase|companion|npc|undead|noncorporeal|bandit|familiar|grimswarm|consignment|gemshop|pawnshop|furrier),?/i
  @invdb_type_data = GameObj.type_data.select{ |k,v| k !~ @invdb_type_data_exclude }

  def self.get_item_type(name,noun)
    list = @invdb_type_data.keys.find_all { |t| (name =~ @invdb_type_data[t][:name] or noun =~ @invdb_type_data[t][:noun]) and (@invdb_type_data[t][:exclude].nil? or name !~ @invdb_type_data[t][:exclude]) }
    return nil if list.empty?
    type = list.include?('collectible') ? 'collectible' : list.join(',');
    return type
  end
  
  def self.peek_jar(id, path)
    jar_amount = 0
    jar_status = 'empty'
    peek = "look in ##{id} #{path}"
    _respond peek if @debug
    look = dothistimeout peek, 3, /^Inside the|is empty.|^Your .*? has (\d+) of a maximum (\d+) applications|^There is a good bit left|There is just a little left/i
    #patterns[:jar_simple]  = /^Inside the .*? you see (?<amount>\d+) portions? of .*?\. *It is (?<status>.*?)\./
    if look =~ /Inside the .*? you see (\d+) portions? of .*?\. *It is (.*?)\./i
      jar_amount = $1.to_i
      jar_status = $2
    end
    return jar_amount, jar_status
  end
  #------------------------------------------------------------------------------#
  # This is crappy, but I need this in here too
  # quiet_command by LostRanger, modded a bit by Xanlin
  #------------------------------------------------------------------------------#
  @script_name = 'Inv_db';
  def self.anon_hook(prefix = '');now = Time.now;"#{@script_name}::#{prefix}-#{now.tv_sec}.#{now.tv_usec}-#{Random.rand(10000)}";end;
  def self.hook_cleanup(); [DownstreamHook, UpstreamHook].each{|provider| provider.list.find_all{|name| name.start_with?("#{@script_name}::")}.each{|name| provider.remove(name)};  };end;
  def self.dothisquiet(command, timeout=5, start_pattern=/.*?/, quiet = true, end_pattern = /^(?:<popBold\/>)?<prompt/, include_end = false)result = [];name   = self.anon_hook;filter = false;begin;Timeout::timeout(timeout, Interrupt) {DownstreamHook.add(name, proc {|xml|if filter;if xml =~ end_pattern;DownstreamHook.remove(name);filter = false;else;next(nil) if quiet;xml if !quiet;end;elsif xml =~ start_pattern;filter = true;next(nil) if quiet;xml if !quiet;else;next(nil) if xml.strip.length == 0;xml;end;});fput command;until (xml = get) =~ start_pattern; end;result << xml.rstrip;until (xml = get) =~ end_pattern;result << xml.rstrip;end;if include_end;result << xml.rstrip;end;};rescue Interrupt;DownstreamHook.remove(name);nil;end;return result;end;
  def self.quiet_command(command, start_pattern, quiet = true, end_pattern = /^(?:<popBold\/>)?<prompt/, include_end = true, timeout=5);return self.old_quiet_command(command, start_pattern, end_pattern, include_end, timeout) if @use_old_quiet_command == true;result = [];name   = self.anon_hook;filter = false;begin;Timeout::timeout(timeout, Interrupt) {DownstreamHook.add(name, proc {|xml|if filter;if xml =~ end_pattern;DownstreamHook.remove(name);filter = false;else;next(nil) if quiet;xml if !quiet;end;elsif xml =~ start_pattern;filter = true;next(nil) if quiet;xml if !quiet;else;next(nil) if xml.strip.length == 0;xml;end;});fput command;until (xml = get) =~ start_pattern; end;result << xml.rstrip;until (xml = get) =~ end_pattern;result << xml.rstrip;end;if include_end;result << xml.rstrip;end;};rescue Interrupt;DownstreamHook.remove(name);nil;end;return result;end;
  #------------------------------------------------------------------------------#
  # for a strange new issue for one user, including option to use ancient quiet_command 
  #------------------------------------------------------------------------------#
  def self.old_quiet_command(command, start_pattern, end_pattern = /<prompt/, include_end = true, timeout=5)
      hook = self.mask_output(start_pattern, end_pattern, include_end)
      xml = dothistimeout(command, timeout, start_pattern)
      unless xml
          DownstreamHook.remove(hook)
          return nil
      end
      result = [xml]
      while true
          xml = get
          if xml =~ end_pattern
              result << xml if include_end
              return result
          end
          result << xml
      end
  end
  def self.mask_output(start_pattern, end_pattern = /<prompt/, include_end = true)
      filter = false
      name = self.anon_hook
      DownstreamHook.add(name, proc {|xml|
          if filter
              if xml =~ end_pattern
                  DownstreamHook.remove(name)
                  filter = false
                  next(include_end ? nil : xml)
              else
                  next(nil)
              end
          elsif xml =~ start_pattern
              filter = true
              next(nil)
          else
              xml
          end
      })
      return name
  end
  #------------------------------------------------------------------------------#
  # @stack_type pattern should capture id, amount, optionally status (empty/partial/full)
  @stack_type = Hash.new
  @stack_type["jar"]    = { :command => "look in", :pattern => /Inside the <a exist="(?<id>\d+)" noun=".*?">.*?<\/a> you see (?<amount>\d+) portions? of .*?\.  It is (?<status>.*?)./}
  #measuring bundles currently breaks hiding
  @stack_type["bundle"] = { :command => "measure", :pattern => /You glance through your bundle and count a total of (?<amount>\d+) <a exist="(?<id>\d+).*/}
  @stack_type["stack"]  = { :command => "read", :pattern => /This <a exist="(?<id>\d+)" noun=".*?">.*?<\/a> has (?<amount>[\d,]+) uses?./}
  @stack_type["pack"]   = { :command => "read", :pattern => /This <a exist="(?<id>\d+)" noun=".*?">.*?pack<\/a> entitles the presenter to (?<amount>\d+).*$/}
  @patterns[:stack] = /In the Common language, it reads:|You glance through your bundle and count a total of (?<amount>\d+)|Inside the .*? you see (?<amount>\d+) portions? of .*?\. *It is (?<status>.*?)\./
  def self.peek_stack(id, path, stack_type = "jar")
    stack_amount = 0
    stack_status = @empty_string
    stack_status = 'empty' if stack_type == "jar"
    
    s = @stack_type[stack_type]
    return false if s[:command].nil?;

    command = "#{s[:command]} ##{id} #{path}"
    respond command if @debug
    start_pattern = /In the Common language, it reads:|^(?:The|This|Inside the) <a exist=\"#{id}"/
    quiet         = !@debug;
    end_pattern   = /^<output class=""\/>|(<popBold\/>)?<prompt/;
    include_end   = false;
    timeout       = 5;
    peek_result   = self.quiet_command(command, start_pattern, quiet, end_pattern, include_end, timeout).join("\n")
    _respond peek_result if @debug
    
    m = s[:pattern].match(peek_result)
    if m
      stack_id     = m[:id] if m[:id]
      stack_amount = m[:amount].to_i if m[:amount]
      stack_status = m[:status] if s[:pattern].to_s =~ /status/ and m[:status]
    end
    return stack_amount, stack_status
  end
  #------------------------------------------------------------------------------#
  # Inv_db.traverse_container
  #------------------------------------------------------------------------------#
  @locker_items = [];
  def self.locker_items;
    @locker_items;
  end;
  
  def self.traverse_container(parent,child,level,path);
    empty_string = "".encode('UTF-8');
    location_id = 10;
    level +=1;
    #this is the path style I need for looking in items while traversing;
    path = "in #{child} #{path}";
    #respond "+-----#{level}:#{path}:#{parent}:#{child.noun}" if @debug;
    child.contents.each { |i|;
        prename       = i.before_name;
        id            = i.id;
        noun          = i.noun.strip;
        name          = i.name;
        postname      = i.after_name;
        attrs         = empty_string;
        registered    = attrs =~ /registered/ ? "Y" : empty_string;
        marked        = attrs =~ /marked/ ? "Y" : empty_string;
        hidden        = attrs =~ /hidden/ ? "Y" : empty_string;
        amount        = 1;
        type          = i.type.gsub(@invdb_type_data_exclude,"") || empty_string;
        stack         = empty_string;
        stack_name    = empty_string;
        stack_noun    = empty_string;
        stack_type    = empty_string;
        stack_amount  = 0;
        status        = empty_string;
      stk = /^(?<stack>jar)/i.match(type);
      #stk = /^(?<stack>jar|beaker|bottle)$/i.match(type);
      #stk[:stack]= 'jar' if stk[:stack] =~ /(?:jar|beaker|bottle)$/i;
      if stk;
        stack           = empty_string;
        stack_path      = "#{path} > #{stack}".to_s;
        stack_name      = Inv_db.deplural(postname).strip;
        stack_noun      = stack_name =~ /(.*?) ([\w\-]+)$/ ? $2 : empty_string;
        stack_noun      = stack_noun =~ /lazuli/ ? "lapis" : stack_noun;
        stack_type      = Inv_db.get_item_type(stack_name,stack_noun) || empty_string;
        stack_amount, status = Inv_db.peek_jar(id,path);
        status          = status =~ /^(full|empty)/ ? status : "partial";
        stack           = stk[:stack] if stack_amount > 0;
        #stack           = 'jar' if stack =~ /(?:jar|beaker|bottle)$/i;
      end;
      prename       = prename =~ /^(an ?|a ?)(.*)? ?/ ? $2 : prename;
      name          = "#{prename} #{name =~ /^(some )?(.*)/ ? $2 : name} #{stack == empty_string ? postname : "(#{stack_name}) (#{stack_amount})"}".strip;
          @locker_items.push( {
          :id           => id,
          :location_id  => location_id.to_i,
          :level        => level.to_i,
          :path         => path.gsub(/locker */,''),
          :type         => type ? type : empty_string,
          :name         => name,
          :noun         => noun,
          :amount       => amount.to_i,
          :stack        => empty_string,
          :status       => status,
          :marked       => marked,
          :registered   => registered,
          :hidden       => hidden,
          :worn         => empty_string,
          :update_noun  => id ? 1 : 0
        });
        if stack != empty_string;
          @locker_items.push( {
            :id           => id,
            :location_id  => location_id.to_i,
            :level        => level+1,
            :path         => "#{path} > #{stack}".gsub(/locker *> */,''),
            :type         => stack_type ? stack_type : empty_string,
            :name         => stack_name,
            :noun         => stack_noun,
            :amount       => stack_amount.to_i,
            :stack        => stack,
            :status       => empty_string,
            :marked       => empty_string,
            :registered   => empty_string,
            :hidden       => empty_string,
            :worn         => empty_string,
            :update_noun  => id ? 1 : 0
          });
        end;
      if i.type =~/clothing/;
        open_result = dothistimeout "open ##{i.id} #{path}", 1, /There doesn't seem to be any way to do that|You .*?open|That is already open/i;
        if open_result =~ /You .*?open|That is already open|absentmindedly fiddle with your/i;
          fput "look in ##{i.id} #{path}";
          sleep 0.06;
          Inv_db.traverse_container(child.noun,i,level,path) if i.contents;
        end;
      end;
    };
  end;
  #------------------------------------------------------------------------------#
  # column and printing helpers
  #------------------------------------------------------------------------------#
  @columns = Hash.new;
  @columns["name"]         = { :justify => "-", :width => 12, :pad => 1};
  @columns["game"]         = { :justify => "-", :width =>  4, :pad => 0}; #GSPlat
  @columns["prof"]         = { :justify => "-", :width =>  8, :pad => 1}; #Sorcerer
  @columns["pro"]          = { :justify => "-", :width =>  3, :pad => 1}; #Sorcerer
  #@columns["race"]         = { :justify => "-", :width => 14, :pad => 1}; #Burghal gnome
  @columns["race"]         = { :justify => "-", :width =>  4, :pad => 1}; #Bu
  @columns["rc"]           = { :justify => "-", :width =>  2, :pad => 1}; #Bu
  @columns["level"]        = { :justify => "" , :width =>  5, :pad => 1};
  @columns["lvl"]          = { :justify => "" , :width =>  3, :pad => 1};
  @columns["lv"]           = { :justify => "" , :width =>  2, :pad => 0};
  @columns["exp"]          = { :justify => "" , :width => 13, :pad => 1};
  @columns["area"]         = { :justify => "-", :width => 20, :pad => 1}; #Northern Caravansary
  @columns["location"]     = { :justify => "-", :width => 10, :pad => 1}; #Northern Caravansary
  @columns["loc"]          = { :justify => "-", :width => 6 , :pad => 0}; #locker|teras|hands
  @columns["account_type"] = { :justify => "-", :width => 12, :pad => 1}; #Standard
  @columns["acct_type"]    = { :justify => "-", :width => 9 , :pad => 1}; #Standard
  @columns["act"]          = { :justify => "-", :width => 3 , :pad => 1}; #Standard
  @columns["locker"]       = { :justify => "-", :width => 18, :pad => 1}; #Wehnimer's Landing
  @columns["lockr"]        = { :justify => "-", :width =>  5, :pad => 1}; #Wehnimer's Landing
  @columns["timestamp"]    = { :justify => "-", :width => 16, :pad => 1}; #2018-05-06 11:43
  #@columns["last_update"]  = { :justify => "-", :width => 16, :pad => 0}; #2018-05-06 11:43
  @columns["bank"]         = { :justify => "-", :width => 28, :pad => 1}; #Bank of Kharag 'doth Dzulthu
  @columns["source"]       = { :justify => "-", :width => 16, :pad => 1}; #Bank of Kharag 'doth Dzulthu
  @columns["currency"]     = { :justify => "-", :width => 28, :pad => 1}; #Bank of Kharag 'doth Dzulthu
  @columns["silver"]       = { :justify => "" , :width => 13, :pad => 1}; #3,109,765,321
  @columns["balance"]      = { :justify => "" , :width => 13, :pad => 1}; #3,109,765,321
  @columns["amount"]       = { :justify => "" , :width => 13, :pad => 1}; #3,109,765,321
  @columns["count"]        = { :justify => "" , :width =>  5, :pad => 1}; #3,109,765,321
  @columns["boxes"]        = { :justify => "" , :width =>  5, :pad => 1}; #3,109,765,321
  @columns["qty"]          = { :justify => "" , :width =>  4, :pad => 0}; #65,321
  @columns["loose"]        = { :justify => "" , :width =>  6, :pad => 1}; #65,321
  @columns["jarred"]       = { :justify => "" , :width =>  6, :pad => 1}; #65,321
  @columns["noun"]         = { :justify => "-", :width => 16, :pad => 1}; #item name goes to end
  @columns["item"]         = { :justify => "-", :width => 32, :pad => 1}; #item name goes to end
  @columns["abbr"]         = { :justify => "-", :width =>  6, :pad => 1}; #item name goes to end
  @columns["path"]         = { :justify => "-", :width => 16, :pad => 1}; #not sure yet
  @columns["type"]         = { :justify => "-", :width => 10, :pad => 0}; #clothing armor gem weapon 
  @columns["stack"]        = { :justify => "-", :width =>  7, :pad => 1}; #bundle
  @columns["stk"]          = { :justify => "-", :width =>  3, :pad => 0}; #bundle
  @columns["status"]       = { :justify => "-", :width =>  7, :pad => 1}; #full|empty|partial
  @columns["epf"]          = { :justify => "-", :width =>  3, :pad => 0}; #full|empty|partial
  @columns["marked"]       = { :justify => "-", :width =>  6, :pad => 1}; #Y
  @columns["mark"]         = { :justify => "-", :width =>  4, :pad => 1}; #Y
  @columns["m"]            = { :justify => "-", :width =>  1, :pad => 0}; #Y
  @columns["registered"]   = { :justify => "-", :width =>  6, :pad => 1}; #Y
  @columns["reg"]          = { :justify => "-", :width =>  3, :pad => 1}; #Y
  @columns["r"]            = { :justify => "-", :width =>  1, :pad => 0}; #Y
  @columns["h"]            = { :justify => "-", :width =>  1, :pad => 0}; #Y
  @columns["worn"]         = { :justify => "-", :width =>  1, :pad => 1}; #shoulders
  @columns["table"]        = { :justify => "-", :width =>  8, :pad => 1}; #
  @columns["inserted"]     = { :justify => "" , :width =>  8, :pad => 1}; #
  @columns["updated"]      = { :justify => "" , :width =>  8, :pad => 1}; #
  @columns["deleted"]      = { :justify => "" , :width =>  8, :pad => 1}; #
  @columns["character_id"] = { :justify => "" , :width =>  1, :pad => 1}; #
  @columns["location_id"]  = { :justify => "" , :width =>  1, :pad => 1}; #
  @columns["update_noun"]  = { :justify => "" , :width =>  12, :pad => 1}; #
  @columns["gs_id"]        = { :justify => "" , :width =>  12, :pad => 1}; #
  @columns["characters"]   = { :justify => "" , :width =>  12, :pad => 1}; #
  @columns["character"]    = { :justify => "" , :width =>  12, :pad => 1}; #
  @columns["inv"]    = { :justify => "" , :width =>  3, :pad => 1}; #
  
  def self.columns;
    @columns;
  end;
;
  @abbrs = Hash.new;
  #q item;
  @abbrs["loc"]   = "location of the item (hands|inv|alongside|locker|town abbr if multi locker)";
  @abbrs["path"]  = "the path to an item, e.g. `backpack > box` is in a box, in a backpack";
  @abbrs["type"]  = "object type, per GameObj.type_data";#, `;e _respond GameObj.type_data.keys` for your list of types"
  @abbrs["stk"]   = "stack, a non-standard container, e.g. jar|bundle|voucher pack";
  @abbrs["epf"]   = "status (empty|partial|full) for jars/stacks";
  @abbrs["m"]     = "marked (Y or blank)";
  @abbrs["r"]     = "registered (Y or blank)";
  @abbrs["h"]     = "hidden (Y or blank)";
  #q char;
  @abbrs["pro"]   = "profession";
  @abbrs["rc"]    = "race abbreviation";
  @abbrs["lvl"]   = "level";
  @abbrs["area"]  = "location character was when last updated";
  @abbrs["act"]   = "account type (f2p|standard|premium)";
  @abbrs["locker"]= "town locker is in, multi if multiple";
  @abbrs["lockr"] = "town locker is in, multi if multiple (will show starting town for f2p)";
  @abbrs["inv"]   = "item count for carried items";
;
  def self.abbrs;
    @abbrs;
  end;
;
  def self.format_table (headers, border="|", column_delimiter="|", column_padding=1, column_padding_char=" ", hl_edge = "+", hl_char = "-");
    _respond "headers: #{headers}" if @debug_print;
    column_border = border;
    table_border  = "";
    table_headers = headers;
    column_pad    = column_padding_char * column_padding #" "*column_padding;
    pad_char       = column_padding_char;
    table_format  = "";
    table_hl      = "";
    headers.each { |h|;
      h = h.split('.')[-1];
      i = @columns[h];
      #echo "h: #{h}; i:#{i}}" if @debug;
      table_format += "#{pad_char*i[:pad]}%#{i[:justify]}#{i[:width]}s#{pad_char*i[:pad]}#{column_delimiter unless h == headers[-1]}";
      table_hl += "-" * (i[:pad]+i[:width]+i[:pad]+column_delimiter.length);
      };
    table_format = "#{table_border}#{table_format}#{table_border}";
    return table_format, table_hl;
  end;

  def self.output_table (rows, target, iparams=nil, highlight=nil);
    to_print = [];
    if rows.length > 1;
      headers          = rows.shift;
      oexp             = headers.index("exp");
      oamount          = headers.index("amount");
      oloose           = headers.index("loose");
      ojarred          = headers.index("jarred");
      otimestamp       = headers.index("timestamp");
      #olast_update    = headers.index("last_update");
      oupdated         = headers.index("updated");
      ohighlight       = headers.index(highlight) if highlight;
      filter_highlight = iparams[:search_filter].gsub(/(?!^)[\*|%](?!$)/,'.*').gsub('%','') if iparams[:search_filter] && iparams[:search_regex] == false;
      filter_highlight = iparams[:search_filter] if iparams[:search_regex] == true;
      
      if @autofit == true
        table_format, table_hl = Inv_db.format_table2(headers,rows);
      else
        table_format, table_hl = Inv_db.format_table(headers);
      end
      
      abbrs            = @abbrs.clone;
      abbrs.keep_if { |k, v| headers.include? k};
      to_print << @mono_start;
      abbrs.each {|k, v| to_print << "... %5s: %5s" % [k, v] } if abbrs.length > 0;
      to_print << table_hl;
      to_print << table_format % headers;
      to_print << table_hl;
      rows.each do |row|;
        row[oexp]         = Inv_db.int_to_comma(row[oexp]) if oexp;
        row[oamount]      = Inv_db.int_to_comma(row[oamount]) if oamount;
        row[oloose]       = Inv_db.int_to_comma(row[oloose]) if oloose;
        row[ojarred]      = Inv_db.int_to_comma(row[ojarred]) if ojarred;
        row[otimestamp]   = Inv_db.int_to_ustime(row[otimestamp]) if otimestamp;
        #row[olast_update] = Inv_db.int_to_ustime(row[olast_update]) if olast_update;
        row[oupdated]     = Inv_db.int_to_usdate(row[oupdated]) if oupdated;
        row[ohighlight]   = row[ohighlight].sub(/(#{filter_highlight})/i,Inv_db.format_whisper($1)) if ohighlight && filter_highlight && row[ohighlight] =~ /(#{filter_highlight})/i;
        to_print << table_format % row;
      end;
      to_print << table_hl;
      to_print << Inv_db.format_whisper("matched #{rows.length} row#{rows.length > 2 ? "s" : ""} from #{target}.");
      to_print << @mono_end;
    else;
      to_print << Inv_db.format_monsterbold("no results found in #{target}");
    end;
    Inv_db.gs_print to_print.join("\n");
  end;

  #------------------------------------------------------------------------------#
  # dynamic-ish sql
  #------------------------------------------------------------------------------#
  def self.query_bank_sql (qargs, style = "", orderby = "");
    respond "+---------------- proc_start: #{@current_proc}" if @debug_sql && !@debug;
    respond "+----qargs:#{qargs}" if @debug_sql  && !@debug;
    respond "+----style:#{style}" if @debug_sql  && !@debug;
    respond "+----orderby:#{orderby}" if @debug_sql  && !@debug;
    select = "select name as character, bank, amount, updated";
    from = %{
      from
      (select c.name, c.game, b.name as bank, s.amount, s.timestamp as updated, b.id as bank_id
      from silver s
        inner join bank b on s.bank_id = b.id
        inner join character c on s.character_id = c.id
     };
    from +="\n      and c.account_type like :account_type_filter" if qargs[:account_type_filter];
    from += "\n) x";
    where = "";
    if qargs;
      where +="  where 1=1";
      where +="\n      and x.name like :char_filter"    if qargs[:char_filter] && !qargs[:char_array];
      where +="\n      and x.name in ('#{qargs[:char_array].join("','")}')" if qargs[:char_array];
      where +="\n      and x.game like :game_filter"    if qargs[:game_filter];
      where +="\n      and x.amount #{qargs[:amount_filter]}"  if qargs[:amount_filter];
      where +="\n      and x.bank #{qargs[:search_regex] == true ? 'REGEXP' : 'like'} :search_filter"  if qargs[:search_filter];
      where +="\n      and c.account_type like :account_type_filter" if qargs[:account_type_filter];
    end;
    default_orderby = "name, bank_id";
    orderby = "\n    order by #{orderby == "" ? default_orderby : orderby}";
    sql = "#{select} #{from} #{where} #{orderby}";
    valid_args = { :char_filter => "", :game_filter => "", :search_filter => "", :account_type_filter => ""};
    qargs.keep_if { |k, v| valid_args.key? k};
    _respond sql if @debug_sql;
    return sql.encode('UTF-8'),qargs;
  end;
  
  def self.sum_bank_sql (qargs, style = "", orderby = "");
    respond "+---------------- proc_start: #{@current_proc}" if @debug_sql;# && !@debug
    respond "+----qargs:#{qargs}" if @debug_sql;
    respond "+----style:#{style}" if @debug_sql;
    respond "+----orderby:#{orderby}" if @debug_sql;
    select = %{
      select 
          x.bank as bank
        , sum(x.amount) as amount
        , replace(group_concat(distinct x.name),',',', ') as characters };
    from = %{
      from
      (select c.name, c.game, b.name as bank, s.amount, s.timestamp as updated, b.id as bank_id
      from silver s
        inner join bank b on s.bank_id = b.id
        inner join character c on s.character_id = c.id
     };
    from +="\n      and c.account_type like :account_type_filter" if qargs[:account_type_filter];
    from += "\n) x";
    where = "";
    if qargs;
      where +="  where 1=1";
      where +="\n      and x.name like :char_filter"    if qargs[:char_filter] && !qargs[:char_array];
      where +="\n      and x.name in ('#{qargs[:char_array].join("','")}')" if qargs[:char_array];
      where +="\n      and x.game like :game_filter"    if qargs[:game_filter];
      where +="\n      and x.amount #{qargs[:amount_filter]}"  if qargs[:amount_filter];
      where +="\n      and x.bank like :search_filter"  if qargs[:search_filter];
      where +="\n      and x.bank <> 'Total' "          if !qargs[:search_filter];
    end;
    groupby = "\n    group by x.bank";
    having  = "";
    default_orderby = "bank";
    orderby = "\n    order by #{orderby == "" ? default_orderby : orderby}";
    sql = "#{select} #{from} #{where} #{groupby} #{having}";
    sql += "\nunion all\n #{select.gsub('x.bank','"grand total"')} #{from} #{where} "  if !qargs[:search_filter];
    sql +=" #{orderby}";
    valid_args = { :char_filter => "", :game_filter => "", :search_filter => "", :account_type_filter => ""};
    qargs.keep_if { |k, v| valid_args.key? k};
    return sql.encode('UTF-8'),qargs;
  end;
  
  def self.query_tickets_sql (qargs, style = "", orderby = "");
    respond "+---------------- proc_start: #{@current_proc}" if @debug_sql && !@debug;
    respond "+----qargs:#{qargs}" if @debug_sql  && !@debug;
    respond "+----style:#{style}" if @debug_sql  && !@debug;
    respond "+----orderby:#{orderby}" if @debug_sql  && !@debug;
    select = "select name as character, source, amount, currency, updated";
    from = %{
      from
      (select c.name, c.game, t.source, t.amount, t.currency, t.timestamp as updated
      from tickets t
        inner join character c on t.character_id = c.id
     };
    from +="\n      and c.account_type like :account_type_filter" if qargs[:account_type_filter];
    from += "\n) x";
    where = "";
    if qargs;
      where +="  where 1=1";
      where +="\n      and x.name like :char_filter"    if qargs[:char_filter] && !qargs[:char_array];
      where +="\n      and x.name in ('#{qargs[:char_array].join("','")}')" if qargs[:char_array];
      where +="\n      and x.game like :game_filter"    if qargs[:game_filter];
      where +="\n      and x.amount #{qargs[:amount_filter]}"  if qargs[:amount_filter];
      where +="\n      and (x.source #{qargs[:search_regex] == true ? 'REGEXP' : 'like'} :search_filter or x.currency #{qargs[:search_regex] == true ? 'REGEXP' : 'like'} :search_filter)"  if qargs[:search_filter];
      where +="\n      and c.account_type like :account_type_filter" if qargs[:account_type_filter];
    end;
    default_orderby = "source, name";
    orderby = "\n    order by #{orderby == "" ? default_orderby : orderby}";
    sql = "#{select} #{from} #{where} #{orderby}";
    valid_args = { :char_filter => "", :game_filter => "", :search_filter => "", :account_type_filter => ""};
    qargs.keep_if { |k, v| valid_args.key? k};
    _respond sql if @debug_sql;
    return sql.encode('UTF-8'),qargs;
  end;
;
  def self.sum_tickets_sql (qargs, style = "", orderby = "");
    respond "+---------------- proc_start: #{@current_proc}" if @debug_sql# && !@debug;
    respond "+----qargs:#{qargs}" if @debug_sql;
    respond "+----style:#{style}" if @debug_sql;
    respond "+----orderby:#{orderby}" if @debug_sql;
    select = %{
      select 
          x.source as source
        , sum(x.amount) as amount
        , x.currency as currency
        , replace(group_concat(distinct x.name),',',', ') as characters };
    from = %{
      from
      (select c.name, c.game, t.source, t.amount, t.currency, t.timestamp as updated
      from tickets t
        inner join character c on t.character_id = c.id
     };
    from +="\n      and c.account_type like :account_type_filter" if qargs[:account_type_filter];
    from += "\n) x";
    where = "";
    if qargs;
      where +="  where 1=1";
      where +="\n      and x.name like :char_filter"    if qargs[:char_filter] && !qargs[:char_array];
      where +="\n      and x.name in ('#{qargs[:char_array].join("','")}')" if qargs[:char_array];
      where +="\n      and x.game like :game_filter"    if qargs[:game_filter];
      where +="\n      and x.amount #{qargs[:amount_filter]}"  if qargs[:amount_filter];
      where +="\n      and (x.source like :search_filter or x.currency like :search_filter)"  if qargs[:search_filter];
      where +="\n      and x.source <> 'Total' "          if !qargs[:search_filter];
    end;
    groupby = "\n    group by x.source, x.currency";
    having  = "";
    default_orderby = "source";
    orderby = "\n    order by #{orderby == "" ? default_orderby : orderby}";
    sql = "#{select} #{from} #{where} #{groupby} #{having}";
    sql +=" #{orderby}";
    valid_args = { :char_filter => "", :game_filter => "", :search_filter => "", :account_type_filter => ""};
    qargs.keep_if { |k, v| valid_args.key? k};
    return sql.encode('UTF-8'),qargs;
  end;
  
  def self.query_char_sql (qargs, style = "", orderby = "");
    respond "+---------------- proc_start: #{@current_proc}" if @debug_sql# && !@debug;
    respond "+----qargs:#{qargs}" if @debug_sql;
    respond "+----style:#{style}" if @debug_sql;
    respond "+----orderby:#{orderby}" if @debug_sql;
    select = %{
      select
          c.name
        , lower(c.game) as game
        , substr(c.prof,1,3) as pro
        , substr(replace(c.race,'alf-',''),1,2) as rc
        , c.level as lvl
        --, c.exp
        , c.area
        , substr(c.account_type,1,3) as act
        --, coalesce(l.abbr,c.locker) as lockr
        , coalesce(l.locker_abbr,c.locker) as lockr
        , timestamp as updated
        , i.inv
    };
    from = %{
      from character c
        left join ( select l.name as locker_name, l.abbr as locker_abbr from location l) as l 
          on c.locker = l.locker_name
        left join (
          select 
              i.character_id
            , sum(amount) as inv 
            from item as i 
            where i.stack='' 
              and i.location_id <3
            group by i.character_id
            ) i on c.id = i.character_id
    };
    where = "";
    if qargs;
      where +="  where 1=1" if qargs;
      where +="\n    and c.name like :char_filter"    if qargs[:char_filter] && !qargs[:char_array];
      where +="\n    and c.name in ('#{qargs[:char_array].join("','")}') " if qargs[:char_array];
      where +="\n    and c.game like :game_filter"   if qargs[:game_filter];
      where +="\n    and c.area like :area_filter"   if qargs[:area_filter];
      where +="\n    and c.name like :search_filter" if qargs[:search_filter] && !qargs[:char_filter] && !qargs[:char_array];
      where +="\n    and c.account_type like :account_type_filter" if qargs[:account_type_filter];
      where +="\n    and c.prof like :profession_filter" if qargs[:profession_filter];
      where +="\n    and c.race like :race_filter" if qargs[:race_filter];
    end;
    default_orderby = "c.game, c.name";
    orderby = "\n    order by #{orderby == "" ? default_orderby : orderby}";
    sql = "#{select} #{from} #{where} #{orderby} COLLATE NOCASE";
    valid_args = { :char_filter => nil, :game_filter => nil, :area_filter => nil, :search_filter => nil, :account_type_filter => nil, :profession_filter => nil, :race_filter => nil };
    qargs.keep_if { |k, v| valid_args.key? k};
    return sql.encode('UTF-8'),qargs;
  end;
  
  def self.query_item_sql (qargs, style = "", orderby = "");
    respond "+---------------- proc_start: #{@current_proc}" if @debug_sql
    respond "+----qargs:#{qargs}" if @debug_sql;
    respond "+----style:#{style}" if @debug_sql;
    respond "+----orderby:#{orderby}" if @debug_sql;
    default = %{
    select 
          c.name, l.name as location
        , i.level, i.path, i.amount as qty
        , i.type, i.stack, i.status
        , i.name as item
    };
    select ="
    select 
          c.name
        , l.abbr as loc
        --, i.level as lv
        , i.path
        , i.amount as qty
        , i.type
        , substr(i.stack,1,3) as stk
        , ' ' || substr(i.status,1,1) as epf
        , i.marked as m
        , i.registered as r
        , i.hidden as h";
    select += "\n      , i.noun as noun" if orderby =~ /noun/;
    select += "\n      , i.name as item";
    default += ", i.marked as mark, i.registered as reg, i.timestamp" if style == "export";
    from = %{
      from item i
        inner join location l on i.location_id = l.id
        inner join character c on i.character_id = c.id
    };
    sql = "#{select} #{from}";
    if qargs;
      where  = "  where 1=1";
      where += "\n    and i.amount #{qargs[:amount_filter]}" if qargs[:amount_filter];
      where +="\n     and c.name like :char_filter"    if qargs[:char_filter] && !qargs[:char_array];
      where +="\n     and c.name in ('#{qargs[:char_array].join("','")}')" if qargs[:char_array];
      where += "\n    and c.game like :game_filter "    if qargs[:game_filter];
      where += "\n    and (l.name like :location_filter or l.abbr like :location_filter)"  if qargs[:location_filter];
      where += "\n    and l.type like :item_filter"     if qargs[:item_filter];
      where += "\n    and i.type like :type_filter"     if qargs[:type_filter] && qargs[:type_filter] =~ /\w/;
      where += "\n    and i.type = ''"                  if qargs[:type_filter] && qargs[:type_filter] =~ /^%?['"N]*%?$/i;
      where += "\n    and i.path #{qargs[:path_filter] == "''" ? " = ''" : "like :path_filter "}"    if qargs[:path_filter];
      where += "\n    and i.noun like :noun_filter"     if qargs[:noun_filter];
      where +="\n     and i.name #{qargs[:search_regex] == true ? 'REGEXP' : 'like'} :search_filter"  if qargs[:search_filter];
      where += "\n    and i.stack like :stack_filter"   if qargs[:stack_filter] && qargs[:stack_filter] =~ /\w/;
      where += "\n    and i.stack = ''"                 if qargs[:stack_filter] && qargs[:stack_filter] =~ /^%?['"N]*%?$/i;
      where += "\n    and i.status like :status_filter" if qargs[:status_filter] && qargs[:status_filter] =~ /\w/;
      where += "\n    and i.status = ''"                if qargs[:status_filter] && qargs[:status_filter] =~ /^%?['"N]*%?$/i;
      where += "\n    and i.marked like :marked_filter" if qargs[:marked_filter] && qargs[:marked_filter] =~ /\w/;
      where += "\n    and i.marked = ''"                if qargs[:marked_filter] && qargs[:marked_filter] =~ /^%?['"N]*%?$/i;
      where += "\n    and i.registered like :registered_filter"   if qargs[:registered_filter] && qargs[:registered_filter] =~ /\w/;
      where += "\n    and i.registered = ''"            if qargs[:registered_filter] && qargs[:registered_filter] =~ /^%?['"N]*%?$/i;
      where += "\n    and i.hidden like :hidden_filter"   if qargs[:hidden_filter] && qargs[:hidden_filter] =~ /\w/;
      where += "\n    and i.hidden = ''"            if qargs[:hidden_filter] && qargs[:hidden_filter] =~ /^%?['"N]*%?$/i;
      where +="\n    and c.account_type like :account_type_filter" if qargs[:account_type_filter];
      #sql += "\n    and i.worn like :worn_filter"   if qargs[:worn_filter];
    end;
    default_orderby = "c.name, l.type, l.name, i.level, i.path, i.noun, i.name";
    orderby = "\n    order by #{orderby == "" ? default_orderby : orderby}";
    sql = "#{style == "" ? select : default} #{from} #{where} #{orderby}";
    qargs.delete(:amount_filter);
    qargs.delete(:search_regex);
    qargs.delete(:char_array);
    qargs.delete_if{|k,v| /^%?['"N]*%?$/i =~ v};
    _respond "qargs: #{qargs}" if @debug;
    return sql.encode('UTF-8'),qargs;
  end;
  
  def self.sum_item_sql (qargs, style = "", groupby = "", orderby = "");
    respond "+---------------- proc_start: #{@current_proc}" if @debug_sql;# && !@debug;
    respond "+----qargs:#{qargs}" if @debug_sql || @debug_input;
    respond "+----style:#{style}" if @debug_sql;
    respond "+----orderby:#{orderby}" if @debug_sql;
    select = "
    select
        i.type as type
      , sum(i.amount) as amount";
    select += "\n      , sum(case when stack='' then amount else 0 end) as loose" if qargs[:type_filter] =~ /gem|reagent/;
    select += "\n      , sum(case when stack='jar' then amount else 0 end) as jarred" if qargs[:type_filter] =~ /gem|reagent/;
    select += "\n      , c.name as name" if groupby =~ /\bcha\w*/;
    select += "\n      , l.abbr as loc" if groupby =~ /\bloc\w*/;
    select += "\n      , i.noun as noun" if groupby =~ /noun/ || orderby =~ /noun/;
    select += "\n      , i.name as item";
    from = %{
      from item i
        inner join location l on i.location_id = l.id
        inner join character c on i.character_id = c.id
    };
    where = "";
    if qargs;
      where += "  where 1=1";
      where += "\n    and i.amount #{qargs[:amount_filter]}" if qargs[:amount_filter];
      where += "\n    and c.name like :char_filter"    if qargs[:char_filter] && !qargs[:char_array];
      where += "\n    and c.name in ('#{qargs[:char_array].join("','")}')" if qargs[:char_array];
      where += "\n    and c.game like :game_filter "    if qargs[:game_filter];
      where += "\n    and l.type like :item_filter"     if qargs[:item_filter];
      where += "\n    and (l.name like :location_filter or l.abbr like :location_filter)"  if qargs[:location_filter];
      where += "\n    and i.type like :type_filter"     if qargs[:type_filter] && qargs[:type_filter] =~ /\w/;
      where += "\n    and i.type = ''"                  if qargs[:type_filter] && qargs[:type_filter] =~ /^%?['"N]*%?$/i;
      where += "\n    and i.path like :path_filter "    if qargs[:path_filter];
      where += "\n    and i.noun like :noun_filter"     if qargs[:noun_filter];
      where += "\n     and i.name #{qargs[:search_regex] == true ? 'REGEXP' : 'like'} :search_filter"  if qargs[:search_filter];
      where += "\n    and i.stack like :stack_filter"   if qargs[:stack_filter] && qargs[:stack_filter] =~ /\w/;
      where += "\n    and i.stack = ''"                 if qargs[:stack_filter] && qargs[:stack_filter] =~ /^%?['"N]*%?$/i;
      where += "\n    and i.status like :status_filter" if qargs[:status_filter] && qargs[:status_filter] =~ /\w/;
      where += "\n    and i.status = ''"                if qargs[:status_filter] && qargs[:status_filter] =~ /^%?['"N]*%?$/i;
      where += "\n    and i.marked like :marked_filter" if qargs[:marked_filter] && qargs[:marked_filter] =~ /\w/;
      where += "\n    and i.marked = ''"                if qargs[:marked_filter] && qargs[:marked_filter] =~ /^%?['"N]*%?$/i;
      where += "\n    and i.registered like :registered_filter"   if qargs[:registered_filter] && qargs[:registered_filter] =~ /\w/;
      where += "\n    and i.registered = ''"            if qargs[:registered_filter] && qargs[:registered_filter] =~ /^%?['"N]*%?$/i;
      where += "\n     and c.account_type like :account_type_filter" if qargs[:account_type_filter];
    end;
    default_groupby = "\n    group by i.type, i.name";
    default_groupby += ", c.name" if groupby =~ /\bcha\w*/;
    default_groupby += ", l.abbr" if groupby =~ /\bloc\w*/;
    groupby = default_groupby;
    having  = "";
    default_orderby = "i.type, amount";
    orderby = "\n    order by #{orderby == "" ? default_orderby : orderby}";
    sql = "#{select} #{from} #{where} #{groupby} #{having}";
    sql += "\nunion all\n #{select.gsub(/[ic].name/,"'total'")} #{from} #{where}\ngroup by i.type";
    sql +=" #{orderby}";
    qargs.delete(:amount_filter);
    qargs.delete(:search_regex);
    qargs.delete(:char_array);
    qargs.delete_if{|k,v| /^%?['"N]*%?$/i =~ v};
    return sql.encode('UTF-8'),qargs;
  end;
  def self.count_item_sql (qargs, style = "", groupby = "", orderby = "");
    respond "+---------------- proc_start: #{@current_proc}" if @debug_sql;
    respond "+----qargs:#{qargs}" if @debug_sql || @debug_input;
    respond "+----style:#{style}" if @debug_sql;
    respond "+----orderby:#{orderby}" if @debug_sql;
    select = "
    select
       c.name as character
      , l.abbr as location
      , sum(case when i.stack='' then i.amount else 0 end) as count";
    select += "\n      , sum(case when i.type='box' then i.amount else 0 end) as boxes" if !qargs[:search_filter] && !qargs[:search_regex] && !qargs[:type_filter] && !qargs[:noun_filter];
    select += "\n      , i.name as item" if qargs[:search_filter] || qargs[:search_regex];
    from = %{
      from character c 
        cross join location l
        left join item i on i.location_id = l.id and i.character_id = c.id  }
    where = "";
    if qargs;
      where += "\n  where 1=1";
      where += "\n    and l.id not in (3,4,5)";
      where += "\n    and ( (c.account_type = 'f2p' and l.id < 10 ) or (l.abbr  = 'locker' and c.account_type = 'standard') or (l.abbr <> 'locker' and c.account_type = 'premium') )";
      where += "\n    and c.name like :char_filter"    if qargs[:char_filter] && !qargs[:char_array];
      where += "\n    and c.name in ('#{qargs[:char_array].join("','")}')" if qargs[:char_array];
      where += "\n    and c.game like :game_filter "    if qargs[:game_filter];
      where += "\n    and l.type like :item_filter"     if qargs[:item_filter];
      where += "\n    and (l.name like :location_filter or l.abbr like :location_filter)"  if qargs[:location_filter];
      where += "\n    and i.type like :type_filter"     if qargs[:type_filter] && qargs[:type_filter] =~ /\w/;
      where += "\n    and i.type = ''"                  if qargs[:type_filter] && qargs[:type_filter] =~ /^%?['"N]*%?$/i;
      where += "\n    and i.path like :path_filter "    if qargs[:path_filter];
      where += "\n    and i.noun like :noun_filter"     if qargs[:noun_filter];
      where += "\n     and i.name #{qargs[:search_regex] == true ? 'REGEXP' : 'like'} :search_filter"  if qargs[:search_filter];
      where += "\n    and i.status like :status_filter" if qargs[:status_filter] && qargs[:status_filter] =~ /\w/;
      where += "\n    and i.status = ''"                if qargs[:status_filter] && qargs[:status_filter] =~ /^%?['"N]*%?$/i;
      where += "\n    and i.marked like :marked_filter" if qargs[:marked_filter] && qargs[:marked_filter] =~ /\w/;
      where += "\n    and i.marked = ''"                if qargs[:marked_filter] && qargs[:marked_filter] =~ /^%?['"N]*%?$/i;
      where += "\n    and i.registered like :registered_filter"   if qargs[:registered_filter] && qargs[:registered_filter] =~ /\w/;
      where += "\n    and i.registered = ''"            if qargs[:registered_filter] && qargs[:registered_filter] =~ /^%?['"N]*%?$/i;
      where += "\n    and i.hidden like :hidden_filter"   if qargs[:hidden_filter] && qargs[:hidden_filter] =~ /\w/;
      where += "\n    and i.hidden = ''"            if qargs[:hidden_filter] && qargs[:hidden_filter] =~ /^%?['"N]*%?$/i;
      where += "\n     and c.account_type like :account_type_filter" if qargs[:account_type_filter];
    end;
    default_groupby = "\n    group by c.name, l.id, l.abbr";
    default_groupby += ", i.name" if qargs[:search_filter] || qargs[:search_regex];
    groupby = default_groupby;
    having  = "\n  having 1=1";
    having += "\n    and count #{qargs[:amount_filter]}" if qargs[:amount_filter];
    default_orderby = "c.name, l.id";
    orderby = "\n    order by #{orderby == "" ? default_orderby : orderby}";
    sql = "#{select} #{from} #{where} #{groupby} #{having}";
    sql +=" #{orderby}";
    qargs.delete(:amount_filter);
    qargs.delete(:search_regex);
    qargs.delete(:char_array);
    qargs.delete_if{|k,v| /^%?['"N]*%?$/i =~ v};
    return sql.encode('UTF-8'),qargs;
  end
  #------------------------------------------------------------------------------#
  # messy user input helper thing
  #------------------------------------------------------------------------------#
  def self.generate_partials (arr, concat = "");
    hret = Hash.new;
    arr.each { |a| 
      temp_str = a.clone;
      matchto_str = a == "inventory" ? "inv" : a;
      iter = (temp_str.length-1);
      hret["#{temp_str}#{concat}"] = matchto_str;
      iter.times {
        temp_str.slice!(-1);
        hret["#{temp_str}#{concat}"] = matchto_str if hret["#{temp_str}#{concat}"].nil?;
        };
    };
    return hret;
  end; 
  #------------------------------------------------------------------------------#
  # locations -- really should be pulled from the database, but meh.
  #------------------------------------------------------------------------------#
  # :jusify = "-" for text, "" for numbers
  @locations       = Hash.new;
  @locations["1"]  = { :id => "1" , :name => 'hands'              , :abbr =>'hands' , :type => 'inv'    };
  @locations["2"]  = { :id => "2" , :name => 'inventory'          , :abbr =>'inv'   , :type => 'inv'    };
  @locations["3"]  = { :id => "6" , :name => 'alongside'          , :abbr =>'alongside', :type => 'inv'    };
  @locations["10"] = { :id => "10", :name => 'locker'             , :abbr =>'lo'    , :type => 'locker' };
  @locations["11"] = { :id => "11", :name => 'Wehnimer\'s Landing', :abbr =>'wl'    , :type => 'locker' };
  @locations["12"] = { :id => "12", :name => 'Teras Isle'         , :abbr =>'teras' , :type => 'locker' };
  @locations["13"] = { :id => "13", :name => 'Solhaven'           , :abbr =>'sol'   , :type => 'locker' };
  @locations["14"] = { :id => "14", :name => 'River\'s Rest'      , :abbr =>'rr'    , :type => 'locker' }; 
  @locations["15"] = { :id => "15", :name => 'Icemule Trace'      , :abbr =>'im'    , :type => 'locker' };
  @locations["16"] = { :id => "16", :name => 'Zul Logoth'         , :abbr =>'zul'   , :type => 'locker' };
  @locations["17"] = { :id => "17", :name => 'Ta\'Illistim'       , :abbr =>'ti'    , :type => 'locker' };
  @locations["18"] = { :id => "18", :name => 'Ta\'Vaalor'         , :abbr =>'tv'    , :type => 'locker' };
  @locations["19"] = { :id => "19", :name => 'Mist Harbor'        , :abbr =>'fwi'   , :type => 'locker' };
  @locations["20"] = { :id => "20", :name => 'Cysaegir'           , :abbr =>'cy'    , :type => 'locker' };
  @locations["21"] = { :id => "21", :name => 'Kraken\'s Fall'     , :abbr =>'kf'    , :type => 'locker' };

  def self.locations
    @locations;
  end;
  #------------------------------------------------------------------------------#
  # external call helpers:
  #
  # Inv_db.pass_thru returns two variables, one is the array of arrays with the rows, 
  #   and another with a change count.
  # Inv_db.to_table can be used to print rows, and assumes the first position in the array are headers
  #
  # e.g. >;e r,c=Inv_db.pass_thru("select * from character limit 1");Inv_db.to_table(r)
  # e.g. >;e r,c=Inv_db.pass_thru("select sql from sqlite_master where type='table'");Inv_db.to_table(r)
  # e.g. >;e r,c=Inv_db.pass_thru("select sql from sqlite_master where type='table'");r.each{|a| respond a[0]}
  #------------------------------------------------------------------------------#
  def self.pass_thru(sql,db=nil);
    db = Inv_db.open if db.nil?
    rows = []
    changes = 0
      begin
        rows = db.execute2(sql)
        changes = db.changes;
        echo "rows returned: #{rows.length}; changes: #{changes}"
      rescue SQLite3::BusyException;sleep 0.1;retry;
      end
    return rows, changes
  end;
  def self.format_table2 (headers, rows=[], border="|", column_delimiter="|", column_padding=1, column_padding_char=" ", hl_edge = "+", hl_char = "-");
  column_border = border;
  table_border  = "";
  table_headers = headers;
  column_pad    = column_padding_char * column_padding;
  pad_char      = column_padding_char;
  table_format  = "";
  table_hl      = "";
  maxlen        = [];
  just          = [];
  if !rows.nil?;
    c = rows.clone.unshift(headers).transpose;
    c.each{|v|
      maxlen << v.max_by{|i| i.to_s.gsub(/<[^>]+>/,'').length}.to_s.length || 1
      just << (v[1..-1].find{|i| i.class.to_s == 'String'}.nil? ? '' : '-').to_s
      };
  end;
  headers.each_with_index { |h,ix|
    h = h.split('.')[-1];
    i = @columns[h] || { :pad=> 1, :width => (h.length > maxlen[ix].to_s.length ? h.length : maxlen[ix].to_s.length), :justify => just[ix]};
    table_format += "#{pad_char*i[:pad]}%#{i[:justify]}#{maxlen[ix]}s#{pad_char*i[:pad]}#{column_delimiter unless h == headers[-1]}";
    table_hl += "-" * (i[:pad]+maxlen[ix]+i[:pad]+column_delimiter.length);
    };
  table_format = "#{table_border}#{table_format}#{table_border}";
  return table_format, table_hl;
end;
  def self.to_table (rows)
    to_print = [];
    if rows.length > 1;
      headers = rows[0];
      table_format, table_hl = format_table2(headers,rows);
      to_print << @mono_start;
      to_print << table_hl;
      to_print << table_format % headers;
      to_print << table_hl;
      rows.shift;
      rows.each do |row|
        to_print << table_format % row;
      end;
      to_print << table_hl;
      to_print << @mono_end;
    else; 
      to_print << " nothing to print ";
      return nil;
    end;
    _respond to_print.join("\n");
  end;
end; # end module Inv_db

#------------------------------------------------------------------------------#
# requires trust
#------------------------------------------------------------------------------#
if $SAFE != 0;
  Inv_db.gs_print "\n     #{$clean_lich_char}#{script.name} requires trust to create and use a database file, to write files for export.\n
     <d cmd=\"#{$clean_lich_char}trust #{script.name}\">#{$clean_lich_char}trust #{script.name}</d>\n\n";
  exit;
end;
#------------------------------------------------------------------------------#
# instance variables - newbie debugging
#------------------------------------------------------------------------------#
@benchmark = false;
@debug = false; @debug_sql = false; @debug_hook = false; @debug_delete = false; @debug_input = false; @debug_print = false; @no_squelch = false;
@autofit = false;
@calling_proc = nil;@current_proc = nil;
#------------------------------------------------------------------------------#
# instance variables
#------------------------------------------------------------------------------#  
@account_type         = nil;
@character_id         = nil;
@inventory_count      = 0;
@manifest_count       = 0;
@inv_retry            = 1;
@manifest_retry       = 1;
@containers           = [];
@containers_noopen    = Settings["container_noopen"];
@containers_noopen_pattern = nil;
@containers_noopen_pattern = /(#{@containers_noopen.join("|")})$/i if @containers_noopen.length > 0;
@container_list_pattern = /<a exist="(?<id>\d+)" noun="(?<noun>[^"]+)">(?<name>[^<]+)</;
@containers_to_close  = [];
@empty_string         = "";@empty_string= @empty_string.encode('UTF-8');
@gui                  = false;
@inv_items            = [];
@inv_scan             = [];
@locker_items         = [];
@locations            = Inv_db.locations;
@mono_start        = %{<output class ="mono" />};
@mono_end          = %{<output class="" />};
@monsterbold_start = $fake_stormfront ? "\034GSL\r\n " : "<pushBold\/>";
@monsterbold_end   = $fake_stormfront ? "\034GSM\r\n " : "<popBold\/>";
@timestamp         = Time.now.to_i/60*60;  #truncating because I want to

@script                     = script;
@script.want_downstream     = false;
@script.want_downstream_xml = true;
#------------------------------------------------------------------------------#
# thanks to LostRanger for this fix for missing lines in invfull: 
#------------------------------------------------------------------------------#
@script.downstream_buffer.instance_variable_set(:@max_size, 4000)
#------------------------------------------------------------------------------#
# quiet_command by LostRanger, modded tiny bit by Xanlin
#------------------------------------------------------------------------------#
@script_name = script.name;
def self.anon_hook(prefix = '');now = Time.now;"#{@script_name}::#{prefix}-#{now.tv_sec}.#{now.tv_usec}-#{Random.rand(10000)}";end;
def self.cleanup;[DownstreamHook, UpstreamHook].each{|provider| provider.list.find_all{|name| name.start_with?("#{@script_name}::")}.each{|name| provider.remove(name)};};end;
def self.quiet_command(command, start_pattern, quiet = true, end_pattern = /^(?:<pop(?:Bold|Stream)\/>)?<prompt/, include_end = true, timeout=5)
  return self.old_quiet_command(command, start_pattern, end_pattern, include_end, timeout) if @use_old_quiet_command == true;
  result = [];
  name   = self.anon_hook;
  filter = false;
  begin;
    Timeout::timeout(timeout, Interrupt) {
      DownstreamHook.add(name, proc {|xml|
        if filter;
          if xml =~ end_pattern;
            DownstreamHook.remove(name);
            filter = false;
          else;
            next(nil) if quiet;
            xml if !quiet;
          end;
        elsif xml =~ start_pattern;
          filter = true;
          next(nil) if quiet;
          xml if !quiet;
        else;
          next(nil) if xml.strip.length == 0; #stop blank lines because.
          xml;
        end;
      });
      fput command;
      until (xml = get) =~ start_pattern; end;
      result << xml.rstrip;
      until (xml = get) =~ end_pattern;
        result << xml.rstrip;
      end;
      if include_end;
        result << xml.rstrip;
      end;
    };
  rescue Interrupt;
    DownstreamHook.remove(name);
    nil;
  end;
  #echo "quiet_command result.length: #{result.length}"
  return result;
end;

#------------------------------------------------------------------------------#
# for a strange new issue for one user, including option to use ancient quiet_command 
#------------------------------------------------------------------------------#
  def self.old_quiet_command(command, start_pattern, end_pattern = /<prompt/, include_end = true, timeout=5)
      hook = self.mask_output(start_pattern, end_pattern, include_end)
      xml = dothistimeout(command, timeout, start_pattern)
      unless xml
          DownstreamHook.remove(hook)
          return nil
      end
      result = [xml]
      while true
          xml = get
          if xml =~ end_pattern
              result << xml if include_end
              return result
          end
          result << xml
      end
  end
  def self.mask_output(start_pattern, end_pattern = /<prompt/, include_end = true)
      filter = false
      name = self.anon_hook
      DownstreamHook.add(name, proc {|xml|
          if filter
              if xml =~ end_pattern
                  DownstreamHook.remove(name)
                  filter = false
                  next(include_end ? nil : xml)
              else
                  next(nil)
              end
          elsif xml =~ start_pattern
              filter = true
              next(nil)
          else
              xml
          end
      })
      return name
  end
#------------------------------------------------------------------------------#
# quiet_command by LostRanger, per findshop v0.3 (with rescue hookremove)
#------------------------------------------------------------------------------#
  def self.classic_quiet_command(command, start_pattern, end_pattern = /<prompt/, include_end = true, timeout=5)
      result = []
      name = self.anon_hook
      filter = false
      begin
          Timeout::timeout(timeout, Interrupt) {
              DownstreamHook.add(name, proc {|xml|
                  if filter
                      if xml =~ end_pattern
                          DownstreamHook.remove(name)
                          filter = false
                          # result << xml.rstrip if include_end
                          # thread.raise(Interrupt)
                          # next(include_end ? nil : xml)
                      else
                          # result << xml.rstrip
                          next(nil)
                      end
                  elsif xml =~ start_pattern
                      filter = true
                      # result << xml.rstrip
                      next(nil)
                  else
                      xml
                  end
              })
              fput command

              until (xml = get) =~ start_pattern; end
              result << xml.rstrip
              until (xml = get) =~ end_pattern
                  result << xml.rstrip
              end
              if include_end
                  result << xml.rstrip
              end
          }
      rescue Interrupt
          DownstreamHook.remove(name)
          nil
      end
      #echo "classic_quiet_command result.length: #{result.length}"
      return result
  end
#------------------------------------------------------------------------------#
# quickdo -- with output
#------------------------------------------------------------------------------#
  def self.quickdo(command_queue, success_pattern, speed = 3)
    return if command_queue.length < 1;
    queue    = command_queue;
    pattern  = success_pattern ;
    flock    = speed ;
    inflight = 0;
    output   = [];
    timeout  = queue.length*2;
    begin;
      Timeout::timeout(timeout, Interrupt) {
        while queue.length > 0;
            put queue.pop;
            inflight += 1;
            while inflight > flock;
                nil until (m = pattern.match(get));
                output << m[0];
                inflight -= 1;
            end;
        end;
        inflight.times { nil until (m = pattern.match(get)); output << m[0]};
      }
      rescue Interrupt
        nil;
    end;
    return output;
  end;
#------------------------------------------------------------------------------#
# column and printing helpers
#------------------------------------------------------------------------------#
@columns = Inv_db.columns;
#------------------------------------------------------------------------------#
# help & related
#------------------------------------------------------------------------------#
help_text = %{  ;inv help      > help text (this)       ;inv examples  > examples 
  ;inv menu      > basic starter menu     ;inv changelog > changelog

  first parameter: action (default to refresh all if no parameters provided)
    options: refresh, query, sum (or total), export, reset, delete, drop
      refresh   load/update your database
      query     prints out results to your story window
      sum       less detail than query, aggregates by type and item
      count     shows totals by character and location
      export    export table or query to a file
      reset     clear everything and start over
      delete    delete stuff, can be complicated, more on this later

  second parameter: target (defaults to all or item)
    options: bank, char, item, inv, locker, tickets
      bank      bank account & silvers
      char      character info
      item      both inventory and lockers
      inv       inventory, but not lockers
      locker    locker(s), but not inventory
      tickets   ticket balance information

  optional parameters: 
    char=name                      # supports wildcards
    game=gsiv                      # defaults to the current game
    type=gem                       # based on your GameObj type data.
    amount(<|<=|=|>|>=)42          # amount greater than, equal to, etc a number
    qty(<|<=|=|>|>=)42             # qty greater than, equal to, etc a number
    noun=stone                     # filter by item noun
    path=backpack                  # all items that start in a backpack
    stack=(jar|bundle|stack|pack)  # only jars implemented so far
    status=(empty|partial|full)    # to help find empty or full jars
    marked=Y                       # not recorded in standard lockers
    registered=Y                   # not recorded in standard lockers
    worn=                          # not yet implemented
    groupby=char                   # adds char column to sum/total queries
    orderby="path asc, qty desc"   # customize result order
    delay=6                        # delay N seconds before doing stuff (e.g. autostart)

  All other input is used as a search string in the primary name in the target.
  If no parameters are provided, defaults to `refresh all`
  If no applicable action & target are specified, defaults to searching items
  +---------------------------------------------------------------+
  exporting:
    ;inv export (char|item|inv|locker|bank|tickets|sbank|stickets) (optional parameters)
    - additional optional export parameters:
      format=(csv|txt|pipe)         default = csv
      dir="c:\\users\me\\desktop"   default = $lich_dir\\inv\\   
      file="filename.ext"           default = (params)_target_timestamp.csv
  +---------------------------------------------------------------+
  most commands have abbreviations:
    q  = query      c = char        m = marked
    i  = item       g = game        r = registered
    in = inv        t = type        s = stack
    l  = locker     n = noun        status = status
    b  = bank       p = path        w = worn
  +---------------------------------------------------------------+
  settings (on/off is converted into true/false)
    ;inv --settings lists your current settings
    ;inv --jar=on/off will turn on/off looking in jars
    ;inv --stack=on/off will turn on/off reading stacks of notes (light and deep notes)
    ;inv --autofit=on/off will turn on/off table columns adjusting to fit content (on) or being ragged (off)
  };
help_examples = %{
  examples:
    ;inv                           # refresh all
    ;inv query item golden glim    # contains the phrase golden glim
    ;inv q i golden glim           # contains the phrase golden glim
    ;inv q i n glim                # contains the phrase n glim
    ;inv q i gold*glim             # * is a wildcard, contains gold and glim
    ;inv q i =golden wand          # = exact match (not just contains)
    ;inv =gold*                    # = can be used with wildcards
    ;inv type=wand gold            # all wands with gold in the name
    ;inv gold type=wand            # all wands with gold in the name
    ;inv gold t=wand               # all wands with gold in the name
    ;inv sapphire char=xanlin      # all sapphires in Xanlin's inv & lockers
    ;inv path=backpack char=xanlin # all items in Xanlin's backpack
    ;inv path=*sack                # all items in any sack                    
    ;inv count locker char=xanlin  # show locker item count for each of Xanlin's lockers};
help_menu = "
    #{Inv_db.format_monsterbold("Run #1 first if your database is empty:")}
     1: <d cmd=\"#{$clean_lich_char}eq Script.run('inv_db','refresh all');Script.start('inv_db','menu')\">#{$clean_lich_char}inv_db refresh all</d> to create/update the database

     other examples: 
     2: character list       <d cmd=\"#{$clean_lich_char}eq Script.run('inv_db','q char');Script.start('inv_db','menu')\">#{$clean_lich_char}inv_db query char</d>
     3: bank accounts        <d cmd=\"#{$clean_lich_char}eq Script.run('inv_db','q bank');Script.start('inv_db','menu')\">#{$clean_lich_char}inv_db q bank</d>
     4: landing bank total   <d cmd=\"#{$clean_lich_char}eq Script.run('inv_db','sum bank amount&gt;100000 elan');Script.start('inv_db','menu')\">#{$clean_lich_char}inv_db sum bank amount&gt;100000 elan</d>
     5: all gems in inv(s)   <d cmd=\"#{$clean_lich_char}eq Script.run('inv_db','q inv type=gem');Script.start('inv_db','menu')\">#{$clean_lich_char}inv_db q inv type=gem</d>
     6: your stuff           <d cmd=\"#{$clean_lich_char}eq Script.run('inv_db','q item char=#{XMLData.name}');Script.start('inv_db','menu')\">#{$clean_lich_char}inv_db q item c=#{XMLData.name}</d>
     7: all locker stuff     <d cmd=\"#{$clean_lich_char}eq Script.run('inv_db','q locker');Script.start('inv_db','menu')\">#{$clean_lich_char}inv_db q locker</d>
     8: all empty jars       <d cmd=\"#{$clean_lich_char}eq Script.run('inv_db','type=jar status=empty');Script.start('inv_db','menu')\">#{$clean_lich_char}inv_db type=jar status=empty</d>
     9: total gems           <d cmd=\"#{$clean_lich_char}eq Script.run('inv_db','sum type=gem');Script.start('inv_db','menu')\">#{$clean_lich_char}inv_db sum type=gem</d>
    10: total uncut diamonds <d cmd=\"#{$clean_lich_char}eq Script.run('inv_db','sum type=gem =uncut dia*');Script.start('inv_db','menu')\">#{$clean_lich_char}inv_db sum type=gem =uncut dia*</d>
    11: locker counts        <d cmd=\"#{$clean_lich_char}eq Script.run('inv_db','count char=#{XMLData.name}');Script.start('inv_db','menu')\">#{$clean_lich_char}inv_db count char=#{XMLData.name}</d>
    
    Add an optional delay for autostart: 
        <d cmd=\"#{$clean_lich_char}autostart add --global #{script.name} delay=6 @no_squelch\r\">#{$clean_lich_char}autostart add --global #{script.name} delay=6 @no_squelch</d>
    To set autostart #{$clean_lich_char}repository to download updates: 
        <d cmd=\"#{$clean_lich_char}autostart add --global repository download-updates\r\">#{$clean_lich_char}autostart add --global repository download-updates</d>
    To set #{script.name} to auto-update: 
        <d cmd=\"#{$clean_lich_char}repository set-updatable #{script.name}\r\">#{$clean_lich_char}repository set-updatable inv_db</d>
    To update just your character info on logout:
        <d cmd=\"#{$clean_lich_char}alias add --global quit=;eq Script.run('#{script.name}','refresh char');fput 'quit';\r\">;alias add --global quit=#{$clean_lich_char}eq Script.run('#{script.name}','refresh char');fput 'quit'</d>
";
help_changelog = %{  changelog:
    0.1.0 (2018-06-22): Beta - first version on the repo
    0.1.1 (2018-06-25):
      - Fixed some over squelching on premium accounts
      - Fixed profanity output
    0.1.2 (2018-06-26): 
      - added abbreviation definitions before query output
      - made filters more flexible
    0.1.3 (2018-06-27): 
      - added option for sum|total. Like query, but aggregated
    0.1.4 (2018-06-28): 
      - bugfix for :inv_full pattern
      - fix for export text/pipe
      - fix for only one bank account transfer stalling bank scrape
    0.1.5 (2018-06-28): 
      - fix for peek_jar, now always includes a path
    0.1.6 (2018-06-29):
      - fix for startup abort to also accept delay parameter
      - cleanup some patterns, fixed locker bug?
      - fix premium 'you must visit your local locker' hanging
    0.1.7 (2018-06-29):
      - tweaked sql generation
      - added pivot columns for sum type=gem and reagent -- more for other stacks soon
      - started implementation of other stacks
      - started implementation of orderby
    0.1.8 (2018-07-01):
      - fixed not closing after opening secure gem pouches
      - started implementation of groupby
    0.1.9 (2018-07-05):
      - fixed stormfront inv window being empty after refresh
      - fixed jar issue on standard locker
      - fixed bank searching that I broke
      - improved profanity support (probably)
    0.2.0 (2018-07-06):
      - added location filter, searches location name or abbr
      - game filter will now default to the current game (so gstest info doesn't get mixed in)
    0.2.1 (2018-07-06):
      - fix safe puts for profanity
      - fix wizard fe output
      - break up help txt
    0.2.2 (2018-07-07):
      - fix rr / twilight locker inside the counter issue
    0.2.3 (2018-07-08)
      - fix spacing issue with standard locker prename
      - made it easier to delete characters from the database
      - patched in collectible type
      - set type filter to have leading wildcard
    0.2.4 (2018-07-13)
      - removed other types from collectibles
      - wait until GameObjAdd etc is done
    0.2.5 (2018-08-05)
      - catch some additional open patterns
      - close containers before exit if failing to scrape
      - fix some options broken in prior update
    0.2.6 (2018-08-08)
      - added more scripts for open/close checking 
      - fixed untyped gems in jars with hyphens, untyped essences in jars
    0.2.7 (2018-08-16)
      - just adding the fix for the change in collectibles
    0.2.8 (2018-08-31)
      - added inventory item counts to query character screen
      - changed character update to timestamp every update
    0.2.9 (2018-09-08)
      - open uncommon type for containers
      - stop opening my locket. 
    0.2.9.3 (2019-05-26)
      - testing regex matching for items
      - multiple characters in search with pipe
    0.2.9.4 (2019-05-26)
      - adjusted results highlight for regex searches
    0.2.9.5 (2019-05-30)
      - container opening blacklist:
          This is a global list, so you won't need to do the same containers on each character. 
        ;invdb --noopen <item name without long to add to noopen list>
        ;invdb --open  <item name to remove from noopen list>
        ;invdb --noopen
          - lists the containers on the noopen list
    0.2.9.8 (2019-06-27)
      - use inventory instead of inv to use commands in roundtime (per LostRanger tip)
    0.2.9.9 (2019-08-10)
      - query tickets (ticket_balance)
      - some stuff that isn't done yet
      - probably some other tweaks I forgot about
    0.3.0.0
      - adjusted open/closing containers 
    0.3.0.1
      - added count action
    0.3.0.2
      - slowed down container actions on wizard
    0.3.0.3 (2019-09-21)
      - fixed count for f2p
    0.3.0.4 (2019-09-24)
      - adjust already open pattern for 'doesn't seem to be any way...'
    0.3.0.5 (2019-11-11)
      - switch most of everything over to quiet_command to avoid squelching issues
      - add vacuum once every 12 hours (that's often, but it's quick -- and didn't help what I had hoped it would)
      - switched some variable (level,game) to XMLData instead of Char (infomon)
    0.3.0.6 (2019-11-13)
      - added jarserve2 wait and import
    0.3.0.7 (2019-11-13)
      - adjusted deplural for jar update
      - moved jarserve integration to only fire on inventory refresh instead of all the time
    0.3.0.8 (2019-11-16)
      - adjusted jarserve check to wait before opening containers
    0.3.0.9a (2019-11-16)
      - adjusted opening containers pattern for 'You pick at'
    0.3.0.9b (2019-11-16)
      - adjusted inv full regex
    0.3.1.0 (2019-11-21)
      - fix for missing lines in inventory full, credit to LostRanger:
        script.downstream_buffer.instance_variable_set(:@max_size, 1000)
    0.3.1.01 (2019-12-01)
      - messing with the exit conditions for dead LostRangers.
    0.3.1.2 (2019-12-01)
      - bugfix for miscounting items
    0.3.1.4 (2020-02-28)
      - added more logic to find area
      - fixed puts instead of gs_print
    0.3.1.5 (2020-04-07)
      - added locker info fix for the warning when downgrading from premium to standard
      - added some basic callable methods for pass_thru and formatting output
    0.3.1.6 (2020-04-09)
      - fix for Vyrshkana's custom gameobj-data.xml file
    0.3.1.7 (2020-04-21)
      - fix for feature concealing veils
    0.3.1.8 (2020-05-23)
      - fix for user input confusion while getting inventory container
      - added hidden attribute for items (badges, soulstone, hairbeads, etc)
    0.3.1.9 (2020-06-15)
      - fix for locker info... again (?).
    0.3.2.0 (2020-09-03)
      - added Kraken's Fall locker
      - some merge logic updates
    0.3.2.1 (2020-09-03)
      - added Kraken's Fall bank
    0.3.2.2 (2020-09-03)  
      - oops, added Cysaegir to the lockers 
    0.3.2.3 (2020-09-07)
      - fix for commas in bank account
    0.3.2.4 (2020-09-07)
    ...
    0.3.2.6 (2021-05-25)
      - only look for current area when refreshing character info, skip using location verb if room window is disabled or more than 2 people there
      - added bundles and stacks to stack types.  Only counts them when in inventory though.
      - removed locker refresh from default for f2ps
      - removed extra call to bank info on f2ps for character info
      - fixed @nosquelch 
    0.3.2.7 (2021-05-25)
      - set current area unknown if nil
      - remove bundle checking, since it breaks hiding and is noisy as fuck
    0.3.2.8 (2021-05-25)
      - silence reading notes
    0.3.2.9 (2021-05-31)
      - added --use_old_quiet_command=true for strange issues that break current versions.
    0.3.2.10 (2021-10-10)
      - disabling drop
      - added race and profession filter for querying characters
    0.3.2.11 (2021-11-13)
      - added export for sum bank, with target sbank,e.g. ;invdb export sbank
      - added export for sum tickets, with target stickets,e.g. ;invdb export stickets
      - switched peek_jar usage to peek_stack
    0.3.2.12 (2021-11-14)
      - added export filename replacement keyword timestamp to be replaced with current timestamp
    0.3.2.13 (2021-12-01)  
      - updated to adjust for missing . in \(\d+ items displayed.\) for inventory full.
    0.3.2.14 (2021-12-01)  
      - update for Naiken's new alongside inventory commands
      - added settings to turn on/off scanning stacks and jars
      - ;invdb --jar=on/off will turn on/off looking in jars
      - ;invdb --stack=on/off will turn on/off reading stacks of notes (light and deep notes)
      - ;invdb --autofit=on/off will turn on/off table columns adjusting to fit content (on) or being ragged (off)
    0.3.2.15 (2021-12-05)
      - update for (Items: \d+) instead of displayed items
      - update for inventory full no longer saying 'wearing and carrying'
  +---------------------------------------------------------------+
  known issues: 
    + locker manifest: guessing nouns by last word in the item name
      unless inside the locker (then noun is from the item link)  };

menu_width = 62 + (script.name.length % 2 == 0 ? 0 : 1).to_i;
help_hl = "  +#{"-"*menu_width}+";

print_menu = proc {
  help_menu.gsub!('inv_db',script.name);
  to_print = [];
  to_print << @mono_start;
  to_print << help_hl;
  center_spaces=" "*((menu_width/2)-(script.name.length/2)).to_i;
  to_print <<  "  |#{center_spaces}#{script.name}#{center_spaces}|";
  to_print <<  help_hl;
  to_print <<  help_menu;
  to_print <<  help_hl;
  to_print <<  @mono_end;
  Inv_db.gs_print to_print.join("\n");
}
print_help = proc { 
  help_text.gsub!(';inv',"#{$clean_lich_char}#{script.name}");
  to_print = [];
  to_print << @mono_start;
  to_print << help_text;
  
  to_print << @mono_end;
  Inv_db.gs_print to_print.join("\n");
};
print_examples = proc { 
  help_examples.gsub!(';inv',"#{$clean_lich_char}#{script.name}");
  to_print = [];
  to_print << @mono_start;
  to_print << help_hl;
  to_print << help_examples;
  to_print << help_hl;
  to_print << @mono_end;
  Inv_db.gs_print to_print.join("\n");
};
print_changelog = proc { 
  help_changelog.gsub!(';inv',"#{$clean_lich_char}#{script.name}");
  to_print = [];
  to_print << @mono_start;
  to_print << help_hl;
  to_print << help_changelog;
  to_print << help_hl;
  to_print << @mono_end;
  Inv_db.gs_print to_print.join("\n");
};
(print_help.call;exit) if script.vars[1] =~ /help|setup|\?/i;
(print_menu.call;exit) if script.vars[1] =~ /menu/i;
(print_examples.call;exit) if script.vars[1] =~ /examples/i;
(print_changelog.call;exit) if script.vars[1] =~ /changelog/i;
#------------------------------------------------------------------------------#
# startup delay for autostart
# ;autostart add inv_db delay=6
#------------------------------------------------------------------------------#
startup_delay = ((Time.now - $login_time) < 12 ? 8 : 0);
startup_delay = $2.to_i if script.vars[0] =~ /\b(delay)=(\d+).*/i;
_respond "invdb startup_delay = #{startup_delay}" if startup_delay > 0 && @debug;
sleep startup_delay;

if script.vars[0] !~ /^[qcse]/ and script.vars[0] !~ /\bchar\b/
  waiton_scripts = ["updater","repository","GameObjAdd","GameObjAddMore","xmlpatch","box","go2"]
  waiton_scripts.each { |s|
  if Script.running?(s)
    respond "Waiting for #{s} to finish"
    sleep 1 while Script.running?(s);
  end
  }
end
#sleep 1 while Script.running?("updater") || Script.running?("repository") || Script.running?("go2") || Script.running?("GameObjAdd") || Script.running?("GameObjAddMore") || Script.running?("xmlpatch") || Script.running?("box");
#------------------------------------------------------------------------------#
# start infomon if it's not running
#------------------------------------------------------------------------------#
Script.start('infomon') if !running?('infomon');
#------------------------------------------------------------------------------#
# check conditions are conducive to running -- not dead/stunned/etc
# for those who autostart the script but might be reconnecting
#------------------------------------------------------------------------------#
if XMLData.indicator["IconDEAD"] == "y" or dead? or stunned? or checkrt > 0 ;
  #should still be able to query and junk in roundtime or while dead
  #if script.vars[0].length == 0 || script.vars[0] =~ /^delay=\d+$/i || ( script.vars[0] =~/^re?f?r?e?s?h?\b/ && script.vars[0] !~ /\bchar\b/ );
  if script.vars[0] !~ /^[qcse]/ and script.vars[0] !~ /\bchar\b/
    _respond "This seems like a bad time...";
    exit;
  end;
end;
#------------------------------------------------------------------------------#
# for whatever reason, sometimes type_data is empty for some people
#------------------------------------------------------------------------------#
if GameObj.type_data.keys.length < 2 and File.exists?("#{$lich_dir}data/gameobj-data.xml");
  GameObj.load_data;
  sleep 1;
end;
#------------------------------------------------------------------------------#
# time to wake up
#------------------------------------------------------------------------------#
#fput "wake"
#------------------------------------------------------------------------------#
# local variables
#------------------------------------------------------------------------------#
  start_sorter = nil
  query_bank  = query_char  = query_item  = query_locker  = nil
  refresh_bank= refresh_char= refresh_item= refresh_locker= refresh_inv= nil
  open_containers = close_containers = nil
  bank_info = scrape_bank = nil; @bank_info_run = false
  search_bank = search_char = search_item = search_locker = nil
  delete_bank = delete_char = delete_item = delete_locker = nil
  export_bank = export_char = export_item= nil
  bank_accounts = Hash.new(0);bank_accounts_total = 0;total_from_feed = 0;
  parse_item_lines = scrape_item = insert_temp_item = insert_temp_item_inv = insert_temp_item_locker = merge_item = nil
  scan_parse_item_lines = nil
  debug_parsed_items = nil
  locker = locker_info = locker_info_result = nil; @locker_info_run = false
  locker_location = locker_item_capacity = locker_look_count = locker_contents_count = nil
  not_in_locker = true;
  locker_standard = locker_standard_debug = nil;
  locker_premium = locker_premium_debug = nil
  locker_manifest_scrape = nil;parse_manifest = nil; locker_manifest = nil; locker_manifest_result = nil; locker_manifest_location = nil;
  filter_highlight = nil; scan_parse_item_lines = nil;
  print_table = table_format = table_hl = table_headers = nil
  column_delimiter = hl_delimiter = column_padding = nil
  action = target = nil
  params = char_filter = item_filter = search_filter = nil
  char_array = []
  noun_filter = stack_filter = status_filter = nil
  format = style = nil
  style = groupby = orderby = ""
  item_type = item_name = item_amount = item_marked = item_registered = item_level = item_path = item_worn = nil
  match_fail_lines = []
  match_fail_count = 0
  db = nil
  stmt = nil
#------------------------------------------------------------------------------#
# variables
#------------------------------------------------------------------------------#
char_name    = XMLData.name.to_str.encode('UTF-8')
game_name    = XMLData.game.to_str.encode('UTF-8')
empty_string = String.new.encode('UTF-8')
#Todo:Move pattern: current_area replace
#current_area = Room.current.location.to_s.gsub(/the (town|city|village|plains|free port|lowlands|tunnels and caverns|foothills|holdings|southern part|northern slopes) of /i,"").encode('UTF-8')
#.gsub(/(the |\s?"the)?(town|hamlet|city|village|plains|free port|lowlands|tunnels and caverns|foothills|holdings|southern part|northern slopes|northern reaches|environs|somewhere)( o[fn] )?|,.*$|^ ?"?the |"$/i,"")
current_area = "";
room_id = ""

def self.current_area();
  current_area = nil
  if !Room.current.id.nil? ;
    room_id = "#{Room.current.id}"
    if !Room.current.location.nil?;
      current_area = Room.current.location.to_s;
    else; #room not tagged with location
      current_area = "#{Room[Room.current.find_nearest_by_tag("town")].location}";
    end;
  else; #unmapped room
    #scrape location
    if XMLData.room_window_disabled == false and GameObj.pcs.size < 3
      location_result = dothistimeout 'location', 1, /^You carefully survey your surroundings and guess that your current location is (.*?) or somewhere close to it\.$|^You can't do that while submerged under water\.$|^You can't do that\.$|^It would be rude not to give your full attention to the performance\.$|^You can't do that while hanging around up here!$|^You are too distracted by the difficulty of staying alive in these treacherous waters to do that\.$|^You carefully survey your surroundings but are unable to guess your current location\.$|^Not in pitch darkness you don't\.$|^That is too difficult to consider here\.$/
      if location_result =~ /^You carefully survey your surroundings and guess that your current location is (.*?) or somewhere close to it\.$/
        current_area = $1
      end
    end
  end;
  current_area = current_area.gsub(/(the )?(town|hamlet|city|village|plains|free port|lowlands|tunnels and caverns|foothills|holdings|southern part|northern slopes|northern reaches|environs|somewhere)( o[fn] )?|,.*$|^the /i,"").encode('UTF-8')
  current_area = "unknown" if current_area.nil?
  return current_area;
end
#current_area = self.current_area 
#current_area = "#{current_area}#{current_area == "" ? "" : " "} - #{room_id}" if room_id != ""
#current_area = Room.current.location.to_s.gsub(/(the )?(town|hamlet|city|village|plains|free port|lowlands|tunnels and caverns|foothills|holdings|southern part|northern slopes|northern reaches|environs|somewhere)( o[fn] )?|,.*$|^the /i,"").encode('UTF-8')

sql = String.new.encode('UTF-8')
changes = Hash.new
changes_template = {:inserted => 0, :updated => 0, :deleted => 0}
changes[:bank]    = {}.merge(changes_template)
changes[:tickets] = {}.merge(changes_template)
changes[:char]    = {}.merge(changes_template)
changes[:item]    = {}.merge(changes_template)
start_sorter = false
sorter_handler = proc { (Script.kill("sorter"); wait_until { !running? "sorter" };start_sorter = true;) if Script.running? "sorter" }
#------------------------------------------------------------------------------#
# Silencers/Squelchers 
#------------------------------------------------------------------------------#
(@no_squelch  = true; Inv_db.no_squelch  = true;) if script.vars[0] =~ /@no_?squelch/
(@autofit = true;Inv_db.autofit = true) if script.vars[0] =~ /@autofit/
@quiet = true; @quiet = false if @no_squelch;
#respond "@no_squelch:#{@no_squelch}, @quiet: #{@quiet}"

bank_squelch_pattern            = /^   +(.*?:) (\d+)|You currently have |^You can deposit up|^You haven't opened|^You have no silver coins with you.|^In the back of your mind you remember you owe a debt/i;
inv_full_squelch_pattern        = /^<streamWindow id='inv'|^( {2,})([^<]*)<a exist="(-?\d+)" noun=|Inside the|^You are currently|^You are holding.*|^  +(an|a|some) .*|^ *<a exist="[^"]+" noun="[^"]+">some.*|^\(\d+ items? displayed.?\)|^You are carrying nothing at this time/i
inv_hands_squelch_pattern       = /^( {2,})([^<]*)<a exist="(-?\d+)" noun=|Inside the|^You are currently|^You are holding.*|^  +(an|a|some) .*|^ *<a exist="[^"]+" noun="[^"]+">some.*|^\(\d+ items? displayed.?\)|^You are carrying nothing at this time/i
inv_squelch_pattern             = /^You are holding|^You are wearing|^Click/
inv_open_close_squelch_pattern  = /It appears to be locked|There doesn't seem to be any way to do that|^Try holding it first|You need to be holding|You are holding.*|You are wearing.*|You (open|close|push|pull|flip).*|^You absentmindedly fiddle with your|already open|open already|^You pick at the knot holding|^You tie your|^You carefully unwind|^You flip the cover|^Hooking a finger into|^Lightly brushing your fingers|^Brushing your fingers against|^Pinching the toggle|^As you reach for the flap|^You rub your hand across/i
locker_info_squelch_pattern     = /^You currently have |<a exist="[^"]+" noun="#{XMLData.name}">#{XMLData.name}<\/a>, your locker.*|^Your locker is currently|^You possess lockers|What were you referring to|.*being swapped|.*being moved/i
locker_standard_squelch_pattern = /^In the .*? you see|^Your locker is currently holding (\d+) items? out of a maximum of (\d+)|already open|^You close|^You open|^You can expand|^There doesn't seem to be any way to do that|^There is nothing|^What were you referring to|Inside the|^The .*? is empty/i
locker_premium_squelch_pattern  = /^(<popBold\/>)? (a|an|some|<d|<a|  ).*|Your locker is currently|^You possess lockers|^Thinking back|^Looking in front of you|There are no items|^Obvious items|[IO]n a.*?(armor stand|weapon rack|clothing wardrobe|deep chest|magical item bin)|You must have a Premium subscription|You must first visit your local locker before using the LOCKER MANIFEST command in this town./i

squelch_remove = proc {
  respond "HookRemoved" if @debug_hook
  respond if @debug_hook
  DownstreamHook.remove('inv_db') 
  sleep 0.05
}

squelch = proc { |squelch_pattern|
  respond "HookStart: #{squelch_pattern}" if @debug_hook
  respond if @debug_hook
  squelch_remove.call
  hook_action = proc { |server_string|
    if server_string.strip.length == 0
      nil
      next
    end
    if server_string =~ squelch_pattern
      nil
    else
      server_string
    end
  }
  DownstreamHook.add("inv_db", hook_action) if !@no_squelch
  sleep 0.05
};

before_dying { 
  squelch_remove.call
  start_script "sorter" if start_sorter
  }

#premium_locker_container_pattern = /[IO]n a.*?(armor stand|weapon rack|clothing wardrobe|deep chest|magical item bin)/i

manifest_pattern_outside = /^(<popBold\/>)?(?<depth>( <d.*?d> +|  +))(?<pre>(an |a ))?(?<name>[^\(]*?)(?:containing (?<post>[^\(]*?))?(?<attrs>\(.*)?$/
manifest_pattern_inside  = /^(<popBold\/>)?(?<depth> +)(?<pre>[^<]+ ?)?<a exist="(?<exist>-?\d+)" noun="(?<noun>[^"]*)">(?<name>[^<]*)<\/a>(?<post>[^\(]*)?(?<attrs>\(.*)?/
#manifest_pattern = /#{manifest_pattern_inside}|#{manifest_pattern_outside}/

patterns = Hash.new
patterns[:bank]       = / *(?<bank>\w[^:]+): (?<amount>[,\d]+)/
patterns[:bank_single]= /You currently have an account with the (?<bank>.*?) in the amount of (?<amount>[,\d]+)/i
patterns[:bank_transfers] = /You currently have (?<transfers>[,\d]+) inter-town bank transfer options? available/i
patterns[:bank_break] = /You currently have (?<transfers>[,\d]+) inter-town bank transfer options? available/i
patterns[:bank_f2p]   = /You can deposit up to a maximum of (?<max>[,\d]+)/i
patterns[:bank_none]  = /You haven't opened a bank account yet/
patterns[:debt]       = /In the back of your mind you remember you owe a debt of (?<debt>[,\d]+) silvers? in the town of (?<town>.*)\./

#need to move patterns to inv_db
#patterns[:container_open] = 
patterns[:inv_count]   = /\((?:Items: )?(?<count>\d+)(?: items? displayed.?)?\)|^You have nothing|^You are carrying nothing/
patterns[:inv_look]    = /(?:(?:Peering into|[IO]n) .* <a exist="(-?\d+)"[^>]*>([^<]*)<\/a>,? you see )|(?:[OI]n the <a exist="(-?\d+)"[^>]*>([^<]*)<\/a>:\s*$)|There is nothing [io]n there|That is closed.|I could not find what you were referring to\./
patterns[:inv_break]   = /\((?:Items: )?(?<count>\d+)(?: items? displayed.?)?\)|Obvious items?: *(?<count>\d+)|^Your locker is currently holding (?<count>\d+) items? out of a maximum of (?<locker_max>\d+)|^You have nothing|^You are carrying nothing/
patterns[:inv_start]   = /You are (carrying|currently|holding|wearing)/
#patterns[:inv_full_js] = /^(?<depth> +)(?:(?<pre>[^<]+) )?<a exist="(?<exist>-?\d+)" noun="(?<noun>[^"]*)">(?<name>[^<]*)<\/a>(?: (?<post>.+?))?(?: (?<attrs>\(.*\)))? *$/
#patterns[:inv_full]    = /^(?<depth> +)(?<pre>[^<]+)? ?<a exist="(?<exist>-?\d+)" noun="(?<noun>[^"]*)">(?<name>[^<]*)<\/a>(?<post>[^\(]*)?(?<attrs>\(.*)?/
patterns[:inv_full]    = /^(?<depth> +)(?<pre>[^<]+)? ?<a exist="(?<exist>-?\d+)" noun="(?<noun>[^"]*?)">(?<name>[^<]*?)<\/a>(?<post>[^\(\r\n]*)?(?<attrs>\(.*)?/i
patterns[:inv_full_noxml] = /^(?<depth> +)(?<name>[^\(]+?)(?<attrs>\(.*)?$/
patterns[:jar]         = /^Inside the (?<pre>.*?)<a exist="(?<exist>-?\d+)" noun="(?<noun>[^"]*)">[^<]*<\/a>.*? you see (?<count>\d+) portions? of (?<name>.*?)\. *It is (?<status>.*?)\./i
patterns[:jar_simple]  = /^Inside the .*? you see (?<amount>\d+) portions? of .*?\. *It is (?<status>.*?)\./

patterns[:locker_info] = /You possess locker(?<multi>s)|Your locker(?<multi>s)? in .* are currently being swapped|Your locker is currently located in the town of (?<town>.*?)\.|Your locker(?<town> )/
patterns[:locker_open] = /Your locker is currently holding (?<count>[,\d]+) items? out of a maximum of (?<max>[,\d]+)|That is already open/
patterns[:locker_count] = /Your locker is currently holding (?<count>[,\d]+) items? out of a maximum of (?<locker_max>[,\d]+)/

patterns[:locker_container] = /[IO]n a.*?(armor stand|weapon rack|clothing wardrobe|deep chest|magical item bin)/i
patterns[:manifest_count] = /Obvious items?: *(?<count>\d+)/
patterns[:manifest_break] = /Obvious items?: *(?<count>\d+)|You must have a Premium subscription|There are no items in this locker|Your lockers in .*?are currently being swapped|You must first visit your local locker before using the LOCKER MANIFEST command in this town./
patterns[:manifest_start] = /^Thinking back, you recall|^Looking in front of you, you see the contents of your locker/
patterns[:manifest]       = /^#{manifest_pattern_inside}|#{manifest_pattern_outside}/

#patterns[:lumnis]         = /^Your Gift of Lumnis is currently in effect.  It is scheduled to refresh in (?<refresh_days>\d days?, )?(?<refresh_hours>\d+ hours? and )?(?<refresh_minutes>\d+ minutes?)\.|Your Gift of Lumnis is scheduled to start on (?<scheduled_day>\w+s?) at (?<scheduled_time\d+:\d+), in-game time\./
#You have no available uses of LUMNIS SCHEDULE.  You can purchase uses from the SimuCoins Store./i

# 1 = id
# 2 = jar noun
# 3 = qty
# 4 = item/i
# 5 = empty/full etc.
#jar_pattern_nonxml = /^Inside the .*? you see (\d+) portions? of .*?\. *It is (.*?)\./i
#------------------------------------------------------------------------------#
# scraping hook
#------------------------------------------------------------------------------#
#TODO
#------------------------------------------------------------------------------#
# sqlite 
#------------------------------------------------------------------------------#
db_version = Inv_db.sqlite_version
db_version = db_version.split(".")
if db_version[0].to_i < 4 && db_version[1].to_i < 9 && db_version[2].to_i < 3
  Inv_db.gs_print "#{script.name} requires sqlite_version: 3.8.3+ ... exiting"
  exit
end

db = Inv_db.open

db.create_function('regexp', 2) do |func, pattern, expression|
   regexp = Regexp.new(pattern.to_s, Regexp::IGNORECASE)
   if expression.to_s.match(regexp)
     func.result = 1
   else
     func.result = 0
   end
 end
#------------------------------------------------------------------------------#
# Reset / Drop tables -- this caused more problems than it solved, disabled
#------------------------------------------------------------------------------#
drop_tables = proc {
  begin
      (db.execute ("drop table if exists item")     ;) if action == "reset" #|| target =~ /item|all/i
      (db.execute ("drop table if exists silver")   ;) if action == "reset" #|| target =~ /bank|all/i
      (db.execute ("drop table if exists bank")     ;) if action == "reset" #|| target =~ /bank|all/i
      (db.execute ("drop table if exists tickets")  ;) if action == "reset" #|| target =~ /tickets|all/i
      (db.execute ("drop table if exists location") ;) if action == "reset" #|| target =~ /item|all/i
      (db.execute ("drop table if exists character");) if action == "reset" #|| target == "all"
      db.execute('pragma user_version=0')
    rescue SQLite3::BusyException
      sleep 0.1
      retry
#    ensure
#      #db.close if db
  end
  Inv_db.gs_print Inv_db.format_monsterbold(action == "reset" ? "inv database reset." : "table(s) dropped")
  exit
}
#------------------------------------------------------------------------------#
# schema
#   todo: db.execute_batch instead? => didn't work as expected
#   todo: database and schema versioning => upgrade/alter handling
#------------------------------------------------------------------------------#
user_version = db.get_first_value('pragma user_version;')

if user_version == 0  
  begin
    sql = %{
    create table if not exists character (
        id            integer not null primary key autoincrement
      , name          text    not null         --# XMLData.name
      , game          text    not null default '' --# XMLData.game
      , prof          text    not null default ''--# Char.prof
      , race          text    not null default ''--# Char.race
      , level         integer not null default 0 --# XMLData.level.to_i
      , exp           integer not null default 0 --# Char.exp
      , area          text    not null default ''--# Room.current.location
      , account_type  text    not null default ''--# from locker info
      , locker        text    not null default ''--# from locker info
      , timestamp     integer not null default 0
      , unique (name,game)
    );};
    db.execute (sql)
    
    sql = %{
    create table if not exists bank (
        id      integer not null primary key autoincrement
      , name    text    not null unique
      , abbr    text    not null unique
    );};
    db.execute (sql)
    
    sql = %{
      with defaults(id,name,abbr) as (values 
         (1, 'First Elanith Secured Bank'   ,'wl')
        ,(2, 'Great Bank of Kharam-Dzu'     ,'teras')
        ,(3, 'Vornavis Bank of Solhaven'    ,'sol')
        ,(4, 'Bank of Torre County'         ,'rr')
        ,(5, 'Icemule Trace Bank'           ,'im')
        ,(6, 'Bank of Kharag ''doth Dzulthu','zul')
        ,(7, 'United City-States Bank'      ,'en')
        ,(8, 'Four Winds Bank'              ,'fwi')
        ,(9, 'Cysaegir Bank'                ,'cy')
        ,(99,'Total'                        ,'total')
        ,(11,'Kraken''s Fall Bank', 'kf')
      )
      insert into bank(id,name,abbr)
      select id,name,abbr
      from defaults d
      where not exists (
        select 1
        from bank b
        where b.name = d.name
      )
      order by id;
    };
    db.execute (sql)
    
    sql = %{
    create table if not exists silver (
        character_id integer not null references character(id)
      , bank_id      integer not null references bank(id)
      , amount       integer not null
      , timestamp    integer not null 
      , unique (character_id, bank_id)
    );};
    db.execute (sql)

    sql = %{
    create table if not exists location (
        id      integer not null primary key
      , type    text    not null 
      , name    text    not null unique
      , abbr    text    not null unique
    );};
    db.execute (sql)
    
    sql = %{
      with def(id,type,name,abbr) as (values 
         (1 ,'inv'   ,'hands'              ,'hands')
        ,(2 ,'inv'   ,'inv'                ,'inv')
        ,(3 ,'inv'   ,'location'           ,'loc')
        ,(4 ,'inv'   ,'container'          ,'con')
        ,(5 ,'inv'   ,'worn'               ,'worn')
        ,(6 ,'inv'   ,'alongside'          ,'alongside')
        ,(10,'locker','locker'             ,'locker')
        ,(11,'locker','Wehnimer''s Landing','wl')
        ,(12,'locker','Teras Isle'         ,'teras')
        ,(13,'locker','Solhaven'           ,'sol')
        ,(14,'locker','River''s Rest'      ,'rr') 
        ,(15,'locker','Icemule Trace'      ,'im')
        ,(16,'locker','Zul Logoth'         ,'zul')
        ,(17,'locker','Ta''Illistim'       ,'ti')
        ,(18,'locker','Ta''Vaalor'         ,'tv')
        ,(19,'locker','Mist Harbor'        ,'fwi')
        ,(20,'locker','Cysaegir'           ,'cy')
        ,(21,'locker','Kraken''s Fall'     ,'kf')
      )
      insert into location(id,type,name,abbr)
      select id,type,name,abbr
      from def d
      where not exists (
        select 1
        from location l
        where l.name = d.name
      )
      order by id
    };
    db.execute (sql)
    
    sql = %{
    create table if not exists item (
        character_id   integer not null references character(id)
      , location_id    integer not null references location(id)
      , level          integer not null default 0
      , path           text    not null default ''
      , type           text    not null default ''
      , name           text    not null 
      , noun           text    not null default ''
      , amount         integer not null 
      , stack          text    not null default ''
      , status         text    not null default ''
      , marked         text    not null default ''
      , registered     text    not null default ''
      , worn           text    not null default ''
      , timestamp      integer not null
      , unique(name, character_id, location_id, path, marked, registered)
    );};
    db.execute (sql)
    
    sql = "create index if not exists ix_item_name on item(name);";
    db.execute (sql)
    
    respond "initial schema confirmed" if @debug
    rescue SQLite3::BusyException
      sleep 0.1
      retry
  #  ensure
  #    #db.close if db
  end
  db.execute('pragma user_version=1')
  user_version = db.get_first_value('pragma user_version;')
end

if user_version == 1
  db.execute('pragma user_version=2');
  user_version = db.get_first_value('pragma user_version;');
  sql = %{
    alter table character add column dreavening text
  };
  db.execute (sql);
end;

if user_version == 2
  sql = %{
    create table if not exists tickets (
         character_id   integer not null
       , source         text    not null
       , amount         integer not null
       , currency       text    not null
       , timestamp      integer not null
       , unique(character_id, source)
  );
  };
  db.execute (sql)
  
  db.execute('pragma user_version=3')
  user_version = db.get_first_value('pragma user_version;')  
end

if user_version == 3
  sql = %{
    alter table item add column hidden text default ''
    };
  db.execute (sql)
  db.execute('pragma user_version=4')
  user_version = db.get_first_value('pragma user_version;')  
end

if user_version == 4
  sql = %{
      with def(id,type,name,abbr) as (values 
        (21,'locker','Kraken''s Fall'      ,'kf')
      )
      insert into location(id,type,name,abbr)
      select id,type,name,abbr
      from def d
      where not exists (
        select 1
        from location l
        where l.name = d.name or l.id = d.id
      )
      order by id
    };
  #respond sql
  db.execute (sql)
  db.execute('pragma user_version=5')
  user_version = db.get_first_value('pragma user_version;')  
end
if user_version == 5
  sql = %{
      with defaults(id,name,abbr) as (values 
        (11,'Kraken''s Fall Bank', 'kf')
      )
      insert into bank(id,name,abbr)
      select id,name,abbr
      from defaults d
      where not exists (
        select 1
        from bank b
        where b.name = d.name or b.id = d.id
      )
      order by id;
    };
  db.execute (sql)
  sql = "update bank set id = 99 where name='Total'"
  db.execute (sql)
  db.execute('pragma user_version=6')
  user_version = db.get_first_value('pragma user_version;')  
end
if user_version == 6
  sql = "delete from location where id >= 20"
  db.execute (sql)
  sql = %{
      with def(id,type,name,abbr) as (values 
        (20,'locker','Cysaegir'      ,'cy'),
        (21,'locker','Kraken''s Fall'      ,'kf')
      )
      insert into location(id,type,name,abbr)
      select id,type,name,abbr
      from def d
      where not exists (
        select 1
        from location l
        where l.name = d.name or l.id = d.id
      )
      order by id
    };
  db.execute (sql)
  db.execute('pragma user_version=7')
  user_version = db.get_first_value('pragma user_version;')
end
if user_version == 7
  sql = %{
    with def(id,type,name,abbr) as (values (6 ,'inv' ,'alongside' ,'alongside'))
    insert into location(id,type,name,abbr)
    select id,type,name,abbr
    from def d
    where not exists (
      select 1
      from location l
      where l.name = d.name
    )
  };
  db.execute (sql)
  db.execute('pragma user_version=8')
  user_version = db.get_first_value('pragma user_version;')
end
#------------------------------------------------------------------------------#
# temp tables for refresh
#------------------------------------------------------------------------------#
if user_version
  sql = %{
  create temporary table if not exists temp_item (
      character_id   integer not null references character(id)
    , location_id    integer not null references location(id)
    , level          integer not null default 0
    , path           text    not null default ''
    , type           text    not null default ''
    , name           text    not null 
    , noun           text    not null default ''
    , amount         integer not null
    , stack          text    not null default ''
    , status         text    not null default ''
    , marked         text    not null default ''
    , registered     text    not null default ''
    , hidden         text    not null default ''
    , worn           text    not null default ''
    , update_noun    int     not null default 0
    , gs_id          int     null
    , timestamp      integer not null
    --, unique(name, character_id, location_id, path, marked, registered)
  );}
  db.execute (sql)
  
  sql = %{
  create temporary table if not exists temp_silver (
       character_id   integer not null
     , bank           text    not null
     , amount         integer not null
     , timestamp      integer not null
     , unique(character_id, bank)
  );};
  db.execute (sql)
  
  sql = %{
    create temporary table if not exists temp_tickets (
         character_id   integer not null
       , source         text    not null
       , amount         integer not null
       , currency       text    not null
       , timestamp      integer not null
       , unique(character_id, source)
  );};
  db.execute (sql)
end

#------------------------------------------------------------------------------#
# deletes
#------------------------------------------------------------------------------#
delete_bank  = proc { |params|
  @calling_proc = @current_proc
  @current_proc = "delete_bank"
  respond "+---------------- proc_start: #{@current_proc}" if @debug
  sql = %{
    delete from silver
    where character_id = (
      select id
      from character
      where name like :char_filter
        and game like :game_filter
      )
  }
  respond sql if @debug_sql
  respond params.to_s if @debug_sql
  begin
    db.execute(sql,params)
    changes[:bank][:deleted] += db.changes
    rescue SQLite3::BusyException
      sleep 0.1
      retry
  end
}

delete_tickets  = proc { |params|
  @calling_proc = @current_proc
  @current_proc = "delete_bank"
  respond "+---------------- proc_start: #{@current_proc}" if @debug
  sql = %{
    delete from tickets
    where character_id = (
      select id
      from character
      where name like :char_filter
        and game like :game_filter
      )
  }
  respond sql if @debug_sql
  respond params.to_s if @debug_sql
  begin
    db.execute(sql,params)
    changes[:tickets][:deleted] += db.changes
    rescue SQLite3::BusyException
      sleep 0.1
      retry
  end
}
delete_item   = proc { |qargs|
  @calling_proc = @current_proc
  @current_proc = "delete_inv"
  respond "+---------------- proc_start: #{@current_proc}" if @debug
  sql = %{
    delete
      from item
  }
  if qargs
    sql += "  where 1=1"
    sql += "\n    and exists ( select 1 from character c where item.character_id = c.id "  if qargs[:char_filter] || qargs[:game_filter]
    sql += "\n      and c.name like :char_filter"    if qargs[:char_filter] && !qargs[:char_array]
    sql += "\n      and c.name in ('#{qargs[:char_array].join("','")}')" if qargs[:char_array]
    sql += "\n      and c.game like :game_filter "  if qargs[:game_filter]
    sql += "\n    )"                              if qargs[:char_filter] || qargs[:game_filter]
    sql += "\n    and exists ( select 1 from location l where item.location_id = l.id "   if qargs[:item_filter]
    sql += "\n      and l.type like :item_filter"   if qargs[:item_filter]
    sql += "\n    )"                              if qargs[:item_filter]
    sql += "\n    and item.amount #{qargs[:amount_filter]}" if qargs[:amount_filter]
    sql += "\n    and item.type like :type_filter"   if qargs[:type_filter]
    sql += "\n    and item.path like :path_filter "  if qargs[:path_filter]
    sql += "\n    and item.noun like :noun_filter"   if qargs[:noun_filter]
    sql += "\n    and item.name like :search_filter" if qargs[:search_filter]
    sql += "\n    and item.stack like :stack_filter"   if qargs[:stack_filter]
    sql += "\n    and item.status like :status_filter"   if qargs[:status_filter]
    sql += "\n    and item.marked like :marked_filter"   if qargs[:marked_filter]
    sql += "\n    and item.registered like :registered_filter"   if qargs[:registered_filter]
    #sql += "\n    and i.worn like :worn_filter"   if qargs[:worn_filter]
  end
  respond sql if @debug_sql
  respond params.to_s if @debug_sql
  begin
    if qargs
      qargs.delete(:amount_filter)
      qargs.delete(:search_regex)
      qargs.delete(:char_array)
      db.execute(sql,params) 
      changes[:item][:deleted] += db.changes
    else
      _respond "no arguments specified for delete -- to drop the table use drop instead"
    end
    rescue SQLite3::BusyException
      sleep 0.1
      retry
  end
}

delete_char  = proc { |params|
  @calling_proc = @current_proc
  @current_proc = "delete_char"
  respond "+---------------- proc_start: #{@current_proc}" if @debug
  sql = %{
    delete from character
    where name like :char_filter
      and game like :game_filter
  }
  respond sql if @debug_sql
  respond params.to_s if @debug_sql
  respond db.errmsg if db.errcode != 0 && @debug_sql
  begin
    db.execute(sql,params)
    changes[:char][:deleted] += db.changes
  rescue SQLite3::BusyException
    sleep 0.1
    retry
end
}
#------------------------------------------------------------------------------#
# character
#   todo: Soliere wants all the things (stats,skills,profile,society)
#   todo: include inv quantity on char?
#------------------------------------------------------------------------------#
#--------add current character
begin
  bank_info.call if !@bank_info_run
  locker_info.call if !@locker_info_run
  current_area = self.current_area; #testing
  cparams = {
    :name         =>  XMLData.name.encode('UTF-8'),
    :game         =>  game_name.encode('UTF-8'), 
    :prof         =>  Char.prof.encode('UTF-8'),
    :race         =>  Char.race.encode('UTF-8'),
    :level        =>  Char.level.to_i,
    :exp          =>  Char.exp.to_i,
    :area         =>  current_area.encode('UTF-8'),
    :account_type =>  @account_type.encode('UTF-8') || "".encode('UTF-8'),
    :locker       =>  locker_location.encode('UTF-8') || "".encode('UTF-8'),
    :timestamp    =>  @timestamp.to_i
  }
  sql = %{
  insert into character (name, game, prof, race, level, exp, area, account_type, locker, timestamp)
    select :name, :game, :prof, :race, :level, :exp, :area, :account_type, :locker, :timestamp
    where not exists (
      select 1
      from character
      where name = :name
        and game = :game
      );
  }
  db.execute(sql, cparams)
  changes[:char][:inserted] += db.changes
  sql = %{ select id from character where name=?1 and game=?2 }
  result = db.get_first_row(sql, XMLData.name, game_name)
  @character_id = result[0]
  rescue SQLite3::BusyException
    sleep 0.1
    retry
end

refresh_char = proc{|params|
  @calling_proc = @current_proc
  @current_proc = "refresh_char"
  respond "+---------------- proc_start: #{@current_proc}" if @debug
  bank_info.call if !@bank_info_run
  locker_info.call  if !@locker_info_run
  current_area = self.current_area; #testing
  cparams = {
    :name         =>  XMLData.name.encode('UTF-8'),
    :game         =>  XMLData.game.encode('UTF-8'),#game_name.encode('UTF-8'), 
    :prof         =>  Char.prof.encode('UTF-8'),
    :race         =>  Char.race.encode('UTF-8'),
    :level        =>  XMLData.level.to_i, #Char.level.to_i,
    :exp          =>  Char.exp.to_i,
    :area         =>  current_area.encode('UTF-8'),
    :account_type =>  @account_type.encode('UTF-8'),
    :locker       =>  locker_location.encode('UTF-8'),
    :timestamp    =>  @timestamp.to_i
    }
  sql = %{
    update character set
        prof        = :prof         
      , race        = :race         
      , level       = :level        
      , exp         = :exp          
      , area        = :area         
      , account_type= :account_type 
      , locker      = :locker       
      , timestamp   = :timestamp    
    where name = :name and game = :game 
  }
  begin
    db.execute(sql.encode('UTF-8'), cparams)
    changes[:char][:updated] += db.changes
    rescue SQLite3::BusyException
      sleep 0.1
      retry
  end
  if script.vars[0] =~ /^refresh char/i
    qparams = {:char_filter => char_name, :game_filter => game_name}
  end
}
query_char = proc {|iparams|
  @calling_proc = @current_proc
  @current_proc = "query_char"
  respond "+---------------- proc_start: #{@current_proc}" if @debug
  respond iparams.to_s if @debug
  sql,qargs = Inv_db.query_char_sql(iparams.clone,style,orderby)
  Inv_db.gs_print sql if @debug_sql
  begin
    rows = db.execute2(sql,qargs)
  rescue SQLite3::BusyException
    sleep 0.1
    retry
  end
  Inv_db.output_table(rows,target,iparams,"name")
}
#------------------------------------------------------------------------------#
# banks
#   todo: add silvers/notes
#You have 2351 coins with you.
#You are carrying City-States promissory notes valued at a total of 10216 silver.
#You are carrying 12567 silver between notes and coins.
#In the back of your mind you remember you owe a debt of 85 silvers in the town of Icemule Trace.
#------------------------------------------------------------------------------#
bank_info = proc {
  @calling_proc = @current_proc
  @current_proc = "bank_info"
  respond "+---------------- proc_start: #{@current_proc}" if @debug
  @bank_info_run = true

  command         = "bank account";
  start_pattern   = /^You currently have the following amounts on deposit:|You currently have an account|You haven't opened a bank account yet/i;
  quiet           = @quiet;
  end_pattern     = /^Tones marked with an asterisk may be used with TONE SET.|^(?:<popBold\/>)?<prompt/;
  include_end     = true;
  timeout         = 5;
  bank_account_result = quiet_command(command, start_pattern, quiet, end_pattern, include_end, timeout)
  
  bank_account_result.each { |line| 
    if line =~ / *(\w[^:]+): (\d+)/i
      bank = $1
      @account_type = "premium" if bank =~/Four Winds Bank/i
      break if @account_type == "premium"
    elsif line =~ /You currently have \d+ inter-town bank transfer options? available/i
      break
    elsif line =~/(You can deposit up to a maximum of) (\d+)/i
      @account_type = "f2p" if $1
      bank_max = $2
      break
    elsif line =~ /You haven't opened a bank account yet/
      @account_type = "f2p"
      break
    end
  }
}

bank_retry = 0
scrape_bank = proc {
  @calling_proc = @current_proc
  @current_proc = "scrape_bank"
  respond "+---------------- proc_start: #{@current_proc}" if @debug
  command         = "bank account";
  
  start_pattern   = /^You currently have the following amounts on deposit:|You currently have an account|You haven't opened a bank account yet/i;
  quiet           = @quiet;
  end_pattern     = /^(?:<popBold\/>)?<prompt/;
  include_end     = true;
  timeout         = 5;
  bank_account_result = quiet_command(command, start_pattern, quiet, end_pattern, include_end, timeout)
  
  @bank_info_run = true
  
  bank_account_result.each { |l|
    if patterns[:bank] =~ l
      bank = $1
      amount = $2.gsub(',','').to_i
      bank_accounts[bank] = amount
      @account_type = "premium" if bank =~/Four Winds Bank/i
      total_from_feed = amount if bank == "Total"
    elsif patterns[:bank_single] =~ l
      bank = $1
      amount = $2.to_i
      bank_accounts[bank] = amount
      bank_accounts["Total"] = amount
      total_from_feed = amount
    elsif patterns[:bank_f2p] =~ l
      @account_type = "f2p" if $2
      bank_max = $2
      break
    elsif patterns[:bank_none] =~ l
      #_respond "What bank account? You don't have one. Go get one. Seriously." #less cheeky now
      break
    end
  }

#  ----- scrape bank account
#  squelch.call(bank_squelch_pattern)
#  fput "bank account"
#  while line = get
#    if patterns[:bank] =~ line
#      bank = $1
#      amount = $2.to_i
#      bank_accounts[bank] = amount
#      @account_type = "premium" if bank =~/Four Winds Bank/i
#      total_from_feed = amount if bank == "Total"
#    elsif patterns[:bank_single] =~ line
#      bank = $1
#      amount = $2.to_i
#      bank_accounts[bank] = amount
#      bank_accounts["Total"] = amount
#      total_from_feed = amount
#    elsif patterns[:bank_break] =~ line
#      break
#    elsif patterns[:bank_f2p] =~ line
#      @account_type = "f2p" if $2
#      bank_max = $2
#      break
#    elsif patterns[:bank_none] =~ line
#      _respond "What bank account? You don't have one. Go get one. Seriously."
#      break
#    end
#  end
#  squelch_remove.call
##  ----- check totals
#  bank_accounts.each { |k,v| 
#    bank_accounts_total+=v if k != "Total"
#    } 
#
#  if bank_accounts_total != total_from_feed
#    (_respond 'invdb: bank totals are not matching, something is wrong.';exit) if bank_retry > 0
#    bank_retry += 1
#    scrape_bank.call
#    break
#  end
}
save_bank = proc {
  @calling_proc = @current_proc
  @current_proc = "save_bank"
  respond "+---------------- proc_start: #{@current_proc}" if @debug
  begin
    stmt = db.prepare("insert into temp_silver (character_id, bank, amount, timestamp) values(#{@character_id}, ?, ?, #{@timestamp})")
    bank_accounts.each { |k,v| 
      stmt.execute(k.encode('UTF-8'),v)
    }
    #  ----delete
    sql = %{
    delete 
    from silver
    where silver.character_id = ?
      and not exists (
        select 1
        from temp_silver t
          inner join bank b on t.bank = b.name
        where t.character_id = silver.character_id
          and b.id           = silver.bank_id
        )
    }
    db.execute(sql,@character_id)
    changes[:bank][:deleted] += db.changes
    #  ----update: sqlites doesn't support joins in updates
    sql = %{
    with cte (character_id, bank_id, amount, timestamp) as (
      select t.character_id, b.id, t.amount, t.timestamp
      from temp_silver t
        inner join bank b on t.bank=b.name
    )
      update silver set 
          amount    = (
            select amount 
            from cte 
            where silver.character_id = cte.character_id
              and silver.bank_id = cte.bank_id
              and silver.amount <> cte.amount
          )
        , timestamp = (
            select timestamp 
            from cte 
            where silver.character_id = cte.character_id
              and silver.bank_id = cte.bank_id
              and silver.amount <> cte.amount
          )
      where exists (
        select 1 
        from cte 
        where silver.character_id = cte.character_id
          and silver.bank_id = cte.bank_id
          and silver.amount <> cte.amount
        )
    }
    db.execute(sql)
    changes[:bank][:updated] += db.changes
    sql = %{
    with cte (character_id, bank_id, amount, timestamp) as (
      select t.character_id, b.id, t.amount, t.timestamp
      from temp_silver t
        inner join bank b on t.bank=b.name
    )
    insert into silver (character_id, bank_id, amount, timestamp)
      select character_id, bank_id, amount, timestamp
      from cte
      where not exists (
        select 1
        from silver i
        where i.character_id = cte.character_id
          and i.bank_id      = cte.bank_id
        )
      order by character_id, bank_id
    }
    db.execute(sql)
    changes[:bank][:inserted] += db.changes
  rescue SQLite3::BusyException
    sleep 0.1
    retry
  rescue SQLite3::Exception => e 
    Inv_db.gs_print "Exception occurred"
    Inv_db.gs_print "Exception: #{e}"
    Inv_db.gs_print "character_id: #{@character_id}"
    Inv_db.gs_print "bank_accounts: #{bank_accounts.to_s}"
  ensure
    stmt.close if stmt
  end
}


query_bank = proc {|iparams|
  @calling_proc = @current_proc
  @current_proc = "query_bank"
  respond "+---------------- proc_start: #{@current_proc}" if @debug
  respond "+----iparams:#{iparams.to_s}" if @debug
  sql,qargs = Inv_db.query_bank_sql(iparams.clone,style,orderby)
  begin
    rows = db.execute2(sql,qargs)
    rescue SQLite3::BusyException
      sleep 0.1
      retry
  end
  Inv_db.output_table(rows,target,iparams,"name")
};

query_tickets = proc {|iparams|
  @calling_proc = @current_proc
  @current_proc = "query_tickets"
  respond "+---------------- proc_start: #{@current_proc}" if @debug
  respond "+----iparams:#{iparams.to_s}" if @debug
  sql,qargs = Inv_db.query_tickets_sql(iparams.clone,style,orderby)
  begin
    rows = db.execute2(sql,qargs)
    rescue SQLite3::BusyException
      sleep 0.1
      retry
  end
  Inv_db.output_table(rows,target,iparams,"name")
};
sum_bank = proc {|iparams|
  @calling_proc = @current_proc
  @current_proc = "query_bank"
  respond "+---------------- proc_start: #{@current_proc}" if @debug
  respond "+----iparams:#{iparams.to_s}" if @debug
  begin
    sql,qargs = Inv_db.sum_bank_sql(iparams.clone)
    Inv_db.gs_print sql if @debug_sql
    rows = db.execute2(sql,qargs)
    rescue SQLite3::BusyException
      sleep 0.1
      retry
  end
  Inv_db.output_table(rows,target,iparams,"name")
};

sum_tickets = proc {|iparams|
  @calling_proc = @current_proc
  @current_proc = "query_tickets"
  respond "+---------------- proc_start: #{@current_proc}" if @debug
  respond "+----iparams:#{iparams.to_s}" if @debug
  begin
    sql,qargs = Inv_db.sum_tickets_sql(iparams.clone)
    Inv_db.gs_print sql if @debug_sql
    rows = db.execute2(sql,qargs)
    rescue SQLite3::BusyException
      sleep 0.1
      retry
  end
  Inv_db.output_table(rows,target,iparams,"name")
};
refresh_bank = proc {
  @calling_proc = @current_proc
  @current_proc = "refresh_bank"
  respond "+---------------- proc_start: #{@current_proc}" if @debug
  scrape_bank.call
  save_bank.call
  #If just refreshing bank, query too
  if action == "refresh" and target == "bank"
    qparams  = {}
    qparams[:char_filter] = char_name if !params[:char_filter]
    #query_bank.call(qparams)
  end
}
refresh_tickets = proc {
  @calling_proc = @current_proc
  @current_proc = "refresh_tickets"
  respond "+---------------- proc_start: #{@current_proc}" if @debug
  
  @ticket_patterns = Hash.new
  @ticket_patterns[:balance_start] = /You take a moment to recall the alternative currencies you've collected.../
  @ticket_patterns[:balance_split] =  /^ +(?<source>.*?) - (?<amount>[,\d]+) (?<currency>.*?)\./
  @ticket_patterns[:balance_none] = /You haven't collected any alternative currencies./
  @ticket_balance = []
  command        = "ticket balance"
  start_pattern  = @ticket_patterns[:balance_start]
  quiet          = @quiet
  end_pattern    = /^(<popBold\/>)?<prompt/
  include_end    = true
  #end_pattern    = /^<output class=""\/>/
  #include_end    = false
  timeout        = 5
  ticket_data    = nil
  ticket_data    = quiet_command(command, start_pattern, quiet, end_pattern, include_end, timeout)
  #because it goes mono before saying anything:
  Inv_db.gs_print "<output class=\"\"/>"
  #because it goes mono before saying anything ^^^
  if @ticket_patterns[:balance_none].match(ticket_data.join("\n"))
    delete_tickets.call
  else
    ticket_data.each { |l|
      m = @ticket_patterns[:balance_split].match(l)
        if m
          ticket = { :source => m[:source], :amount => m[:amount], :currency => m[:currency]}
          @ticket_balance.push(ticket)
        end
    }
    @ticket_balance.each { |t| echo "#{t[:source]}, #{t[:amount]}, #{t[:currency]}"} if @debug
  end
  
  ###save tickets
  
  #save_tickets = proc {
  @calling_proc = @current_proc
  @current_proc = "save_tickets"
  respond "+---------------- proc_start: #{@current_proc}" if @debug
  begin
    stmt = db.prepare("insert into temp_tickets (character_id, source, amount, currency, timestamp) values(#{@character_id}, ?, ?, ?, #{@timestamp})")
    @ticket_balance.each { |t| 
      stmt.execute(t[:source].encode('UTF-8'), t[:amount].gsub(',','').to_i, t[:currency].encode('UTF-8'))
    }
    #  ----delete
    sql = %{
    delete 
    from tickets
    where tickets.character_id = ?
      and not exists (
        select 1
        from temp_tickets t
        where t.character_id = tickets.character_id
          and t.source = tickets.source
          and t.currency = tickets.currency
        )
    }
    db.execute(sql,@character_id)
    changes[:tickets][:deleted] += db.changes
    #  ----update: sqlites doesn't support joins in updates
    sql = %{
    with cte (character_id, source, amount, currency, timestamp) as (
      select t.character_id, t.source, t.amount, t.currency, t.timestamp
      from temp_tickets t
    )
      update tickets set 
          amount    = (
            select amount 
            from cte 
            where tickets.character_id = cte.character_id
              and tickets.source = cte.source
              and tickets.amount <> cte.amount
              and tickets.currency = cte.currency
          )
        , timestamp = (
            select timestamp 
            from cte 
            where tickets.character_id = cte.character_id
              and tickets.source = cte.source
              and tickets.amount <> cte.amount
          )
      where exists (
        select 1 
        from cte 
        where tickets.character_id = cte.character_id
          and tickets.source = cte.source
          and tickets.amount <> cte.amount
          and tickets.currency = cte.currency
        )
    }
    db.execute(sql)
    changes[:tickets][:updated] += db.changes
    sql = %{
    with cte (character_id, source, amount, currency, timestamp) as (
      select t.character_id, t.source, t.amount, t.currency, t.timestamp
      from temp_tickets t
    )
    insert into tickets (character_id, source, amount, currency, timestamp)
      select character_id, source, amount, currency, timestamp
      from cte
      where not exists (
        select 1
        from tickets i
        where i.character_id = cte.character_id
          and i.source       = cte.source
          and i.currency     = cte.currency
        )
      order by character_id, source
    }
    db.execute(sql)
    changes[:tickets][:inserted] += db.changes
  rescue SQLite3::BusyException
    sleep 0.1
    retry
  rescue SQLite3::Exception => e 
    Inv_db.gs_print "Exception occurred"
    Inv_db.gs_print "Exception: #{e}"
    Inv_db.gs_print "character_id: #{@character_id}"
    Inv_db.gs_print "tickets_accounts: #{@ticket_balance.to_s}"
  ensure
    stmt.close if stmt
  end
#}
}
#------------------------------------------------------------------------------#
# item
#    todo: scrape & capture parent/path of nested items
#    todo: locker manifest might not have all lockers (simucoin)
#------------------------------------------------------------------------------#

insert_temp_item_inv = proc {#|location_id,contents|
  @calling_proc = @current_proc
  @current_proc = "insert_temp_item_inv"
  respond "+---------------- proc_start: #{@current_proc}" if @debug
  begin
    stmt = db.prepare("insert into temp_item (
        character_id, location_id
      , level, path
      , type, name, noun, amount
      , stack, status
      , marked, registered, hidden, worn
      , timestamp, update_noun, gs_id 
      )
    values(#{@character_id}, :location_id
      , :level, :path
      , :type, :name, :noun, :amount
      , :stack, :status
      , :marked, :registered, :hidden, :worn
      , #{@timestamp}, :update_noun, :id )"
      )
   @inv_items.each { |v|
     stmt.execute v
   }
   rescue SQLite3::BusyException
     sleep 0.1
     retry
   ensure
    stmt.close if stmt
  end
}

insert_temp_item_locker = proc {#|location_id,contents|
  @calling_proc = @current_proc
  @current_proc = "insert_temp_item_locker"
  respond "+---------------- proc_start: #{@current_proc}" if @debug
  #@locker_items = Inv_db.locker_items
  begin
    #@locker_items.each { |v| v.tap { |k| k.delete(:id) } } 
    stmt = db.prepare("insert into temp_item (
          character_id, location_id
        , level, path
        , type, name, noun, amount
        , stack, status
        , marked, registered, worn
        , timestamp, update_noun, gs_id
        )
      values(#{@character_id}, :location_id
        , :level, :path
        , :type, :name, :noun, :amount
        , :stack, :status
        , :marked, :registered, :worn
        , #{@timestamp}, :update_noun, :id )")
    @locker_items.each { |v|
        sparams = v
        sparams.delete_if { |key, value| !key.to_s.match(/location_id|level|path|type|name|noun|amount|stack|status|marked|registered|worn/) }
        stmt.execute sparams
    }
  #  rescue SQLite3::Exception => e 
  #    Inv_db.gs_print "Exception occurred"
  #    Inv_db.gs_print e
  #
    rescue SQLite3::BusyException
      sleep 0.1
      retry
    ensure
      #stmt.close if stmt
  end
}

insert_temp_item_premium_locker = proc {#|location_id,contents|
  @calling_proc = @current_proc
  @current_proc = "insert_temp_item_locker"
  respond "+---------------- proc_start: #{@current_proc}" if @debug
  begin
  #@locker_items = Inv_db.locker_items
  sql = %{ 
    insert into temp_item (
        character_id, location_id
      , level, path
      , type, name, noun, amount
      , stack, status
      , marked, registered, worn
      , timestamp, update_noun
      )
  }
  @locker_items.each { |v| v.tap { |k| k.delete(:id) } } 
  stmt = db.prepare("insert into temp_item (
        character_id, location_id
      , level, path
      , type, name, noun, amount
      , stack, status
      , marked, registered, worn
      , timestamp, update_noun, gs_id
      )
    values(#{@character_id}, :location_id
      , :level, :path
      , :type, :name, :noun, :amount
      , :stack, :status
      , :marked, :registered, :worn
      , #{@timestamp}, :update_noun, :id )")
    @locker_items.each { |v|
        sparams = v
        sparams.delete_if { |key, value| !key.to_s.match(/location_id|level|path|type|name|noun|amount|stack|status|marked|registered|worn/) }
        stmt.execute sparams
    }

  rescue SQLite3::BusyException
    sleep 0.1
    retry
  ensure
    stmt.close if stmt
  end
}

merge_item = proc {|mparams = {}, preview_only = false|
  @calling_proc = @current_proc
  @current_proc = "merge_item"
  respond "+---------------- proc_start: #{@current_proc}" if @debug
  respond "+----#{@current_proc}: mparams:#{mparams}" if @debug
  #item_filter = params[:item_filter]
  mparams = mparams || Hash.new
  #if doing refresh all, don't delete locker if we aren't there and are standard
  if @account_type == "standard" && @debug
    respond "  item_filter: #{item_filter}"
    respond "not_in_locker: #{not_in_locker}"
    respond " account_type: #{@account_type}"
  end
  item_filter = "inv" if (not_in_locker && @account_type != "premium" && item_filter == "all")
  mparams[:item_filter] = item_filter if item_filter != "all"
  
  respond "+----#{@current_proc}: mparams:#{mparams}" if @debug
  #preview_only = true if @debug
  respond "+----#{@current_proc}: delete" if @debug
  begin
  temp_item_cte = %{
  with cte as (
    select 
        character_id, location_id
      , level, path
      , type , name, noun, sum(amount) as amount
      , stack, status
      , marked, registered, hidden, worn
      , timestamp, update_noun
    from temp_item
    where character_id = ?1
    group by
        character_id, location_id
      , level, path
      , type , name, noun
      , stack, status
      , marked, registered, hidden, worn
      , timestamp, update_noun
  )
  }
  sql = %{
  delete 
  from item 
  where item.character_id = ?1
    and not exists (
      select 1
      from temp_item t
      where t.character_id = ?1
        and t.location_id  = item.location_id
        and t.path         = item.path
        and t.name         = item.name
        and t.stack        = item.stack
        and t.status       = item.status
        and t.marked       = item.marked
        and t.registered   = item.registered
        and t.hidden       = item.hidden
        and t.worn         = item.worn
        --and case when item.type = 'unknown' then item.type else t.type end = t.type
      )
  }
  sql += "\n    and exists (
    select 1 
    from location l
    where l.id = item.location_id 
      and l.type like :item_filter
    )" if mparams[:item_filter] =~ /inv|locker/i 
  # don't need cte for the exists clause
  #sql = "#{temp_item_cte} #{sql}"
  #respond "+----sql:#{sql}" if @debug_sql
  if preview_only
    sql = sql.gsub('delete','select *') 
    #respond "+----sql:#{sql}"
    rows = db.execute2(sql,@character_id,mparams)
    Inv_db.output_table(rows,target = "")
  else 
    respond "+----sql:#{sql}" if @debug_sql
    db.execute(sql,@character_id,mparams)
    changes[:item][:deleted] += db.changes
  end
  
#  ----update: sqlite doesn't support joins in updates
  respond "+----#{@current_proc}: update" if @debug
  sql = %{
  update item set 
      amount = (
        select amount 
        from cte t
        where t.character_id = ?1
          and t.location_id  = item.location_id
          and t.path         = item.path
          and t.name         = item.name
          and t.stack        = item.stack
          and t.status       = item.status
          and t.marked       = item.marked
          and t.registered   = item.registered
          and t.worn         = item.worn
      )
    , type = coalesce((
        select type 
        from cte t
        where t.character_id = ?1
          and t.location_id  = item.location_id
          and t.path         = item.path
          and t.name         = item.name
          and t.stack        = item.stack
          and t.status       = item.status
          and t.marked       = item.marked
          and t.registered   = item.registered
          and t.worn         = item.worn
          --and t.update_noun  = 1
          and t.type        <> 'unknown'
          and t.type        <> ''
      ),item.type)
    , noun = coalesce((
        select noun 
        from cte t
        where t.character_id = ?1
          and t.location_id  = item.location_id
          and t.path         = item.path
          and t.name         = item.name
          and t.stack        = item.stack
          and t.status       = item.status
          and t.marked       = item.marked
          and t.registered   = item.registered
          and t.worn         = item.worn
          and t.update_noun  = 1
      ),item.noun)
    , timestamp = (
        select timestamp
        from cte t
        where t.character_id = ?1
          and t.location_id  = item.location_id
          and t.path         = item.path
          and t.name         = item.name
          and t.stack        = item.stack
          and t.status       = item.status
          and t.marked       = item.marked
          and t.registered   = item.registered
          and t.worn         = item.worn
      )
  where item.character_id = ?1
    and exists (
      select 1 
      from cte t 
      where t.character_id = ?1
        and item.location_id  = t.location_id
        and item.path         = t.path
        and item.name         = t.name
        and item.stack        = t.stack
        and item.status       = t.status
        and item.marked       = t.marked
        and item.registered   = t.registered
        and item.worn         = t.worn
        and (
          item.amount  <> t.amount
          or item.type <> coalesce((
            select type 
            from cte t
            where t.character_id = ?1
              and t.location_id  = item.location_id
              and t.path         = item.path
              and t.name         = item.name
              and t.stack        = item.stack
              and t.status       = item.status
              and t.marked       = item.marked
              and t.registered   = item.registered
              and t.worn         = item.worn
              --and t.update_noun  = 1
              and t.type        <> 'unknown'
              and t.type        <> ''
            ),item.type)
          or item.noun <> coalesce((
            select noun 
            from cte t
            where t.character_id = ?1
              and t.location_id  = item.location_id
              and t.path         = item.path
              and t.name         = item.name
              and t.stack        = item.stack
              and t.status       = item.status
              and t.marked       = item.marked
              and t.registered   = item.registered
              and t.worn         = item.worn
              and t.update_noun  = 1
            ),item.noun)
          )
      )
  }
  sql = "#{temp_item_cte} #{sql}"
  if preview_only #or true
    _respond "?????????????????????"
        sql = %{
    --update item set 
    select item.noun, item.type, item.amount
        , (
          select amount 
          from cte t
          where t.character_id = ?1
            and t.location_id  = item.location_id
            and t.path         = item.path
            and t.name         = item.name
            and t.stack        = item.stack
            and t.status       = item.status
            and t.marked       = item.marked
            and t.registered   = item.registered
            and t.worn         = item.worn
        ) as amount
      , coalesce((
          select type 
          from cte t
          where t.character_id = ?1
            and t.location_id  = item.location_id
            and t.path         = item.path
            and t.name         = item.name
            and t.stack        = item.stack
            and t.status       = item.status
            and t.marked       = item.marked
            and t.registered   = item.registered
            and t.worn         = item.worn
            --and t.update_noun  = 1
            and t.type        <> 'unknown'
            and t.type        <> ''
        ),item.type) as type
      , coalesce((
          select noun 
          from cte t
          where t.character_id = ?1
            and t.location_id  = item.location_id
            and t.path         = item.path
            and t.name         = item.name
            and t.stack        = item.stack
            and t.status       = item.status
            and t.marked       = item.marked
            and t.registered   = item.registered
            and t.worn         = item.worn
            and t.update_noun  = 1
        ),item.noun) as noun
      , (
          select timestamp
          from cte t
          where t.character_id = ?1
            and t.location_id  = item.location_id
            and t.path         = item.path
            and t.name         = item.name
            and t.stack        = item.stack
            and t.status       = item.status
            and t.marked       = item.marked
            and t.registered   = item.registered
            and t.worn         = item.worn
        ) as timestamp
        , name
        from item
    where item.character_id = ?1
      and exists (
        select 1 
        from cte t 
        where t.character_id = ?1
          and item.location_id  = t.location_id
          and item.path         = t.path
          and item.name         = t.name
          and item.stack        = t.stack
          and item.status       = t.status
          and item.marked       = t.marked
          and item.registered   = t.registered
          and item.worn         = t.worn
          and (
            item.amount  <> t.amount
            or item.type <> coalesce((
              select type 
              from cte t
              where t.character_id = ?1
                and t.location_id  = item.location_id
                and t.path         = item.path
                and t.name         = item.name
                and t.stack        = item.stack
                and t.status       = item.status
                and t.marked       = item.marked
                and t.registered   = item.registered
                and t.worn         = item.worn
                --and t.update_noun  = 1
                and t.type        <> 'unknown'
                and t.type        <> ''
              ),item.type)
            or item.noun <> coalesce((
              select noun 
              from cte t
              where t.character_id = ?1
                and t.location_id  = item.location_id
                and t.path         = item.path
                and t.name         = item.name
                and t.stack        = item.stack
                and t.status       = item.status
                and t.marked       = item.marked
                and t.registered   = item.registered
                and t.worn         = item.worn
                and t.update_noun  = 1
              ),item.noun)
            )
        )
    }
    sql = "#{temp_item_cte} #{sql}"
    respond sql
    rows = db.execute2(sql,@character_id) 
    #rows.each {|r| echo r}
    Inv_db.output_table(rows,target)
    exit
    
    
    #respond "+----sql:#{sql}"
    #rows = db.execute2(sql,@character_id)
    #Inv_db.output_table(rows,"")
  else 
    respond "+----sql:#{sql}" if @debug_sql
    db.execute(sql,@character_id)
    changes[:item][:updated] += db.changes
  end
  #  ----insert items
  respond "+----#{@current_proc}: insert" if @debug
  sql = %{
  insert into item (
      character_id, location_id
    , level, path
    , type, name, noun, amount
    , stack, status
    , marked, registered, hidden, worn
    , timestamp 
  )
    select 
      character_id, location_id
    , level, path
    , type, name, noun, amount
    , stack, status    
    , marked, registered, hidden, worn
    , timestamp 
    --from temp_item t
    from cte t
    where not exists (
      select 1
      from item i
      where i.character_id = ?1
        and i.location_id  = t.location_id
        and i.path         = t.path
        and i.name         = t.name
        and i.stack        = t.stack
        and i.status       = t.status
        and i.marked       = t.marked
        and i.registered   = t.registered
        and i.hidden       = t.hidden
        and i.worn         = t.worn
      )
    order by character_id, location_id, path, name
  }
  sql = "#{temp_item_cte} #{sql}"
  
  if preview_only
    #sql = sql.gsub(/insert.*?\)/m,'')

  else 
    respond "+----sql:#{sql}" if @debug_sql
    db.execute(sql,@character_id) 
    changes[:item][:inserted] += db.changes
  end
    rescue SQLite3::BusyException
      sleep 0.1
      retry
  end
}

refresh_item = proc {|params|
  @calling_proc = @current_proc;
  @current_proc = "refresh_item";
  respond "+---------------- proc_start: #{@current_proc}" if @debug;
  respond "+----params:#{params}" if @debug;
  item_filter = params[:item_filter] ;
  item_filter = "all"  if item_filter.nil?;
  if item_filter =~ /all|inv/;
  Inv_db.gs_print "updating inventory..." if !@benchmark;
    inv_time = Benchmark.realtime do;
      refresh_inv.call;
    end;
    Inv_db.gs_print "+--refresh_inv combined time elapsed #{(inv_time*1000).round(2)} milliseconds" if @benchmark;
  end;
  if item_filter =~ /all|locker/ and not (item_filter =~ /all/ and @account_type == "f2p" );
    Inv_db.gs_print "updating locker(s)..." if !@benchmark;
    locker_time = Benchmark.realtime do;
      refresh_locker.call;
    end;
    Inv_db.gs_print "+--refresh_locker time elapsed #{(locker_time*1000).round(2)} milliseconds" if @benchmark;
  end;
  if !(item_filter == "locker" && not_in_locker && @account_type != "premium");
    merge_time = Benchmark.realtime do;
      merge_item.call;
    end;
    Inv_db.gs_print "+--merge_item time elapsed #{(merge_time*1000).round(2)} milliseconds" if @benchmark;
  end;
};
=begin
  open_containers = proc {
    @calling_proc = @current_proc
    @current_proc = "open_containers"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    squelch.call(inv_open_close_squelch_pattern)
    #use inv container full instead
    noopen_pattern = /(#{@containers_noopen.join("|")})$/i
    _respond noopen_pattern if @debug
    fput "inventory container"
    containers_str = matchtimeout(3, "You are wearing")
    GameObj.inv.each { |i|
      _respond "#{i.name}" if @debug
      @containers_to_close.push(Inv_db.container_open(i.id)) if ((i.type.nil? || i.type =~ /clothing|uncommon/i) && containers_str =~ /#{i.name}/i && i.name !~ /locket$/i && i.name !~ noopen_pattern )
    }
  }

  close_containers = proc {
    @calling_proc = @current_proc
    @current_proc = "close_containers"
    respond "+---------------- proc_start: #{@current_proc}" if @debug
    squelch.call(inv_open_close_squelch_pattern)
    @containers_to_close.each{ |id| fput "close ##{id}" if id};
    squelch_remove.call
  }
=end

#------------------------------------------------------------------------------#
# waitfor jarserve2 if it's running
#------------------------------------------------------------------------------#
@js2 = Hash.new

check_jarserve2 = proc {
if Script.running?("jarserve2");
  respond "jarserve2 is running, waiting until ready:"
    $jarserve2.wait_until_ready
    $jarserve2.do_query().value[:jars].each do |gem, jars|
    jars.each do |jar|
      @js2[jar.id] = { 
        #:name => jar.name,  #ERROR
        :name => jar.gem.to_s, 
        :noun => gem.noun_first =~ /^([^,]+),/ ? $1 : "?",
        :amount => jar.count.to_i, 
        :status => (jar.status.to_s =~ /^(full|empty)/ ? $1 : "partial") 
      }
      # jar.id has the exist ID of the jar which you can match against your own INV FULL or whatnot
      # jar.count has the number of gems.
      # jar.status has the "less than half full" etc messaging.
      # jar.name  or just gem has the depluralized name of the gem.  (No a/an)
      # note:  jar.name doesn't work
      # --- Lich: error: undefined method `name' for #<Jarserve2::ReadOnlyJar:0x1339ee70>
      # jarserve_status:14:in `block (2 levels) in script'
      # C:/Ruby200/lib/ruby/2.0.0/set.rb:232:in `each_key  
    end
  end
end
}
def self.inventory_container();
  command       = "inventory container";
  start_pattern = /^(?:<popBold\/>)?You are wearing (?:(?!, which conceals).)+$|^(?:<popBold\/>)?You are holding/;
  quiet         = @quiet;
  end_pattern   = /^(<popBold\/>)?<prompt/;
  include_end   = false;
  timeout       = 5;
  data          = quiet_command(command, start_pattern, quiet, end_pattern, include_end, timeout);
  popbold       = (data[0] =~ /^<popBold\/>/ ? true : false;)
  _respond '<popBold/>' if popbold == true;
  respond "inventory container #{data}" if @debug;
  # this should only return one line, without the inventory help line 
  # if it has that line, then someone ran >inven at the right time to get caught here
  if data.size > 1 and data[1..-1].join('') =~ /Click <d cmd='invento help'>INVENTORY HELP<\/d> for more options./
    echo "caught bad inventory result:\n #{data.join("\n")}\n" if @debug;
    data = self.inventory_container;
  end;
  return data;
end;
#------------------------------------------------------------------------------#
# 
#------------------------------------------------------------------------------#
open_containers = proc {
  @calling_proc = @current_proc
  @current_proc = "open_containers"
  respond "+---------------- proc_start: #{@current_proc}" if @debug
  
  check_jarserve2.call
  
  data = self.inventory_container
  echo "data: #{data}" if @debug
  echo "@containers_noopen_pattern: #{@containers_noopen_pattern}" if @debug
  data[0].scan(@container_list_pattern).each { |id,noun,name| 
    @containers << id if name !~ @containers_noopen_pattern;
  };
  #open containers  
  
  squelch.call(inv_open_close_squelch_pattern);
  echo "@containers: #{@containers}" if @debug
  command_queue = @containers.map { |c| "open ##{c}"};
  echo "command_queue: #{command_queue}" if @debug

  success_pattern = /^It appears to be locked.|^That is already open|^There doesn't seem to be any way to do that|(?<already_open>already open|open already|resists opening|absentmindedly fiddle with your)|(?<not_holding>Try holding it first|You need to be holding)|(?:You|Hooking|Lightly|Pinching|Sliding) (?:open|push|pull|flip|unwind|unfasten|unsnap|unhitch|unclasp|a finger|pick at|brushing|the toggle|the lever|rub).*?(?:<a exist="(?<id>#{@containers.join("|")})" noun="(?<noun>[^"]+)">(?<name>[^<]+)<.*?)/
  speed           = (@slower == true ? 1 : 2)
  open_output = quickdo(command_queue, success_pattern, speed)
  echo "open_output: #{open_output}" if @debug
  open_output.each { |o|
    m = @container_list_pattern.match(o)
    if m 
      @containers_to_close.push(m[:id]) if m[:id]
    end
  }
  echo "@containers_to_close: #{@containers_to_close}" if @debug
  
  squelch_remove.call
}

close_containers = proc {
  @calling_proc = @current_proc
  @current_proc = "close_containers"
  respond "+---------------- proc_start: #{@current_proc}" if @debug
  squelch.call(inv_open_close_squelch_pattern)

  command_queue = @containers_to_close.reverse.map { |c| "close ##{c}"}
  echo "command_queue: #{command_queue}" if @debug
  success_pattern = /You.*?(?:"#{@containers_to_close.join("|")}")/
  speed           = (@slower == true ? 1 : 2)
  quickdo(command_queue, success_pattern, speed)

  squelch_remove.call
}

#------------------------------------------------------------------------------#
# 
#------------------------------------------------------------------------------#
fix_inv_window = proc {
  #not needed  with switch to quiet_command -- probably
  #@calling_proc = @current_proc
  #@current_proc = "fix_inv_window"
  #respond "+---------------- proc_start: #{@current_proc}" if @debug
  #squelch.call(inv_squelch_pattern)
  #fput "inv"
  #squelch_remove.call
}

refresh_inv = proc{
  @calling_proc = @current_proc
  @current_proc = "refresh_inv"
  respond "+---------------- proc_start: #{@current_proc}" if @debug
  item_filter = "all" if item_filter.nil?
  #open_containers.call
    open_time = Benchmark.realtime do
      open_containers.call
    end
    Inv_db.gs_print "+--open_containers time elapsed #{(open_time*1000).round(2)} milliseconds" if @benchmark
  
  if item_filter =~ /inv|item|all/i
    respond "+---------------- #{@current_proc}: scan inv" if @debug
    
    # Usage:
    #meh#     INVENTORY                         - Show the items you're currently wearing
    #meh#     INVENTORY HANDS                   - Show the items you're currently holding
    #meh#     INVENTORY {option}                - Show the items of a specific type that you're currently wearing
    #neat#     INVENTORY FULL [option]           - Show items in your inventory, including the contents of containers, optionally only showing those of a specific type
    #neat#     INVENTORY LOCATION                - Show items you are currently wearing and where they are located.  Also indicates whether the items are functional or not.
    #meh#     INVENTORY QUANTITY [option]       - Count items in your inventory, including the contents of containers, optionally only counting those of a specific type
    #neat#     INVENTORY HANDS FULL [option]     - Show items in your hands, including the contents of containers, optionally only showing those of a specific type
    #meh#     INVENTORY HANDS QUANTITY [option] - Count items in your hands, including the contents of containers, optionally only counting those of a specific type
    #hm#     INVENTORY ENHANCIVE [ON| OFF]     - Toggle whether your enhancive items provide their benefits (and thus expend charges) or not.
    # 
    # Where {option} is one of the following:
    #hm#     ARMOR      - List armor
    #hm#     WEAPONS    - List weapons
    #hm#     COMBAT     - List weapons, armor, and unarmed combat equipment
    #neat#     CONTAINERS - List items that can hold other items
    #meh#     FLUFF      - List non-combat, non-container items 
    #meh#     REGISTERED - List items that were most recently registered by you
    #------------------------------------------------------------------------------#
    @inv_scan =[
        {:command => 'inventory hands full', :id => 1, :squelch => nil, :path => '', :lines => [] , :name => 'hands'},  #You are carrying
        {:command => 'inventory alongside full', :id => 6, :squelch => nil, :path => '', :lines => [], :name => 'alongside' },  #You are carrying
        {:command => 'inventory full'      , :id => 2, :squelch => nil , :path => '', :lines => [], :name => 'inven'} #, #You are currently wearing and carrying: 
        #{:command => 'inventory location', :id => 3}, #You are currently wearing:
        # inv full con doesn't see containers in closed containers, just sayin'
        # inv full container may require multiple loops if containers aren't already open
        # alternately, open all containers before running the scan -- seems simpler
        # keep track of the opened containers and close them again in reverse order
        #{:command => 'inv full containers', :id => 0, :path => 'container', :contents => Hash.new(0), :squelch => inv_hands_squelch_pattern}, #You are carrying
        #{:command => 'inv full fluff', :id => 9, :path => 'container', :contents => Hash.new(0), :squelch => inv_hands_squelch_pattern}, #You are carrying
        #don't need registered
        #{:command => 'inv full registered', :id => , :path => 'container', :contents => Hash.new(0), :squelch => inv_hands_squelch_pattern}, #You are carrying
      ];
    @inv_scan.each { |scan| 
      scan_time = Benchmark.realtime do;
        scan_parse_item_lines.call(scan)
      end;
      Inv_db.gs_print "+----scan #{scan[:name]} time elapsed #{(scan_time*1000).round(2)} milliseconds" if @benchmark;
    }
    close_time = Benchmark.realtime do
    beginning_time = Time.now if @debug
      close_containers.call
    end
    Inv_db.gs_print "+----close_containers time elapsed #{(close_time*1000).round(2)} milliseconds" if @benchmark
    #debug_parsed_items.call
    insert_temp_item_inv.call if @inv_items.count > 0
  end
  
  fix_inv_window.call if $front_end != /profanity/
};

scan_parse_item_lines = proc {|scan|
#parse_item_lines = proc {|location_id, lines|
  @calling_proc = @current_proc
  @current_proc = "scan_parse_item_lines"
  respond "+---------------- proc_start: #{@current_proc}" if @debug
  respond "+---------------- scan: #{scan}" if @debug
  displayed_count  = 0
  start            = false
  line_count       = 0
  sp_lines         = []
  temp_items       = []
  other_lines      = []
  pattern          = patterns[:inv_full]
  location_id      = scan[:id]
  match_fail_lines = []
  match_fail_count = 0
  ############
  command         = scan[:command]
  start_pattern   = /^(?:<popBold\/>)?(?:You are currently (?:wearing and )?(?:carrying)?(?:(?!, which conceals).)+$|^(?:<popBold\/>)?You are carrying nothing at this time|^(?:<popBold\/>)?You are holding)|^You currently have placed alongside you|^You have nothing placed alongside you.|That's not a valid option/i;
  quiet           = @quiet;
  end_pattern     = /^(?:<popBold\/>)?<prompt/;
  include_end     = true;
  timeout         = 5;
  sp_lines        = quiet_command(command, start_pattern, quiet, end_pattern, include_end, timeout)
  #resend captured popBold
  popbold         = (sp_lines[0] =~ /^<popBold\/>/ ? true : false;)
  _respond '<popBold/>' if popbold == true;
  #
  count_line      = sp_lines.find { |line| patterns[:inv_count].match(line) }
  displayed_count = 0
  if count_line !~ /nothing/
    displayed_count = patterns[:inv_count].match(count_line).captures[0].to_i 
  end
  _respond "command: #{scan[:command]}, count_line: #{count_line}, displayed_count: #{displayed_count}" if @debug
  line_count = sp_lines.length
  ############
  prev_id     = empty_string
  prev_name   = empty_string
  prev_noun   = empty_string
  prev_level  = 0
  item_path   = []
  item_path_ids = []
  matched_count = 0
  #matched_count = -1 if XMLData.name =~ /Xanlin/
  sp_lines.each { |line|
      m = pattern.match(line)
      if m
        matched_count    += 1
        leading_space = m[:depth]
        prename       = m[:pre]
        id            = m[:exist]
        noun          = m[:noun]
        name          = m[:name].strip
        postname      = m[:post].strip
        other         = m[:attrs]
        registered    = other =~ /registered/ ? "Y" : empty_string
        marked        = other =~ /marked/ ? "Y" : empty_string
        hidden        = other =~ /hidden/ ? "Y" : empty_string;
        amount        = 1
        type          = name == "some blue lapis lazuli" ? "gem" : Inv_db.get_item_type(name,noun) || empty_string
        level         = ((leading_space.length.to_i - 2) / 4).to_i
        item_path.push(prev_noun)  if level > prev_level
        item_path_ids.push("##{prev_id}")     if level>prev_level #should turn this into a hash since i need both now?
        if level < prev_level
          n_pop = prev_level - level;
          n_pop.times { item_path.pop; item_path_ids.pop;} 
        end
        path          = "#{item_path.join(' > ')}" if !item_path.nil?
        
        stack           = empty_string
        stack_name      = empty_string
        stack_noun      = empty_string
        stack_type      = empty_string
        stack_amount    = 0
        status          = empty_string
        stk = nil;
        #respond "------------------------------------notes" if line =~ /notes/
        #stk = /^(?<stack>stack) of .*? notes|^(?<stack>bundle) of .*(?!arrows|bolts)$/i.match(name);
        stk = /^(?<stack>stack) of .*? notes$/i.match(name);
        #respond "stk:#{stk.inspect}" if line =~ /notes|bundle/
        #respond "#{name}" if line =~ /notes|bundle/
        stk = /^(?<stack>jar)/i.match(type) if !stk;
        #stk = /^(?<stack>jar|beaker|bottle)$/i.match(type);
        #stk[:stack] = 'jar' if stk and stk[:stack] =~ /(?:jar|beaker|bottle)$/i;
        if stk
          if stk[:stack] =~ /jar/i and @js2 and @js2[id][:amount] > 0
            #jarserve2 removes parts of the name, so let's not use that version.
            stack_name      = Inv_db.deplural(m[:post]).strip #@js2[id][:name]
            stack_noun      = @js2[id][:noun] =~ /lazuli/ ? "lapis" : @js2[id][:noun]
            #stack_noun      = stack_noun =~ /lazuli/ ? "lapis" : stack_noun
            stack_type      = (Inv_db.get_item_type(stack_name,stack_noun) || empty_string) if postname
            status          = @js2[id][:status]
            stack_amount    = @js2[id][:amount]
            stack           = stk[:stack] if stack_amount > 0
            #stack           = 'jar' if stack =~ /(?:jar|beaker|bottle)$/i;
            respond "#{stack_name}|#{stack_noun}|#{stack_type}|#{status}|#{stack_amount}" if @debug
          elsif stk[:stack] =~ /jar/i and Settings[stk[:stack].downcase]
            respond "Settings['#{stk[:stack].downcase}']: #{Settings[stk[:stack].downcase]}" if @debug
            #stack_name      = Inv_db.deplural($6).strip
            stack_name      = Inv_db.deplural(m[:post]).strip
            stack_noun      = stack_name =~ /(.*?) ([\w\-]+)$/ ? $2 : empty_string
            stack_noun      = stack_noun =~ /lazuli/ ? "lapis" : stack_noun
            stack_type      = (Inv_db.get_item_type(stack_name,stack_noun) || empty_string) if postname
            status          = "empty"
            #stack_amount, status = Inv_db.peek_jar(id, item_path.length > 0 ? "in #{item_path_ids.reverse.join(" in ")}" : "" ) if postname =~ /containing/
            stack_amount, status = Inv_db.peek_stack(id, item_path.length > 0 ? "in #{item_path_ids.reverse.join(" in ")}" : "", "jar" ) if postname =~ /containing/
            status          = status =~ /^(full|empty)/ ? status : "partial"
            stack           = stk[:stack] if stack_amount > 0
          elsif Settings[stk[:stack].downcase]
            respond "Settings['#{stk[:stack].downcase}']: #{Settings[stk[:stack].downcase]}" if @debug
            #respond "stk.inspect: #{stk.inspect}"
            stack_name      = Inv_db.deplural(name.gsub(/^(?:bundle|stack) of/,'')).strip
            stack_noun      = Inv_db.deplural(noun).strip
            stack_type      = (Inv_db.get_item_type(stack_name,stack_noun) || empty_string)
            status          = ""
            stack_path      = (item_path.length > 0 ? "in #{item_path_ids.reverse.join(" in ")}" : "" ) if postname =~ /containing/ or stk[:stack] !~ /jar/i
            #respond "name, id, stack_path, stack_type, stack_name: #{name}, ##{id}, #{stack_path}, #{stack_type}, #{stack_name}"
            stack_amount, status = Inv_db.peek_stack(id, stack_path, stk[:stack]) 
            respond "stack_amount, status: #{stack_amount}, #{status}" if @debug
            stack           = stk[:stack] if stack_amount > 0
          end
        end
        prename       = prename =~ /^(an ?|a ?)(.*)?/ ? $2 : prename
        #name          = "#{prename}#{name =~ /^(some )?(.*)/ ? $2 : name} #{stack == "" ? postname : "(#{stack_name}) (#{stack_amount})"}".strip
        name          = "#{prename}#{name =~ /^(some )?(.*)/ ? $2 : name} #{stack == "" ? postname : (stack_name == "" ? "" : "(#{stack_name}) ")+"(#{stack_amount})"}".strip
        prev_id       = id
        prev_level    = level.to_i
        prev_noun     = noun
        prev_name     = name
        temp_items.push( {
          #:rn           => rn,
          :id           => id,
          :location_id  => location_id.to_i,
          :level        => level.to_i, 
          :path         => path.encode('UTF-8'), 
          :type         => type.encode('UTF-8'), 
          :name         => name.encode('UTF-8'), 
          :noun         => noun.encode('UTF-8'), 
          :amount       => amount.to_i, 
          :stack        => empty_string, 
          :status       => status,
          :marked       => marked.encode('UTF-8'), 
          :registered   => registered.encode('UTF-8'), 
          :hidden       => hidden.encode('UTF-8'), 
          :worn         => empty_string,
          :update_noun  => 1
        })
          
        temp_items.push( {
          :id           => id,
          :location_id  => location_id.to_i,
          :level        => level+1,
          :path         => item_path.length > 0 ? "#{path} > #{stack}" : "#{stack}",
          :type         => stack_type.encode('UTF-8'),
          :name         => stack_name.encode('UTF-8'), 
          :noun         => stack_noun.encode('UTF-8'),
          :amount       => stack_amount.to_i,
          :stack        => stack.encode('UTF-8'), 
          :status       => empty_string, 
          :marked       => empty_string, 
          :registered   => empty_string, 
          :hidden       => empty_string, 
          :worn         => empty_string,
          :update_noun  => 1
        }) if stack != "";
    else
      match_fail_lines << line
      match_fail_count += 1
    end
  }
  if matched_count == displayed_count 
    @inv_items = @inv_items + temp_items
    @inventory_count += displayed_count if displayed_count > 0
  else
    _respond "total lines scanned: #{sp_lines.count}"
    _respond "parse count: #{matched_count} != displayed count: #{displayed_count}"
    _respond "failed on lines:\n\n#{match_fail_lines.join('\n')}\n\n"
    if @inv_retry < 4
      _respond "retrying after error in scan & parse: #{scan[:command]}"
      _respond "match_fail_count = #{match_fail_count}"
      _respond "match_fail_lines: #{match_fail_lines.join("\n")}"
      @inv_retry += 1
      _respond "starting attempt ##{@inv_retry}"
      scan_parse_item_lines.call(scan)
    else
      _respond "something is fucky, let's dump the lines:\n\n"
      sp_lines.each_with_index { |line,index| 
        respond "#{index}:#{line}"
      }
      _respond "\n\n"
      _respond "giving up on inventory scan, exiting."
      _respond other_lines.join("\n")
      _respond "giving up on inventory scan, exiting."
      close_containers.call
      exit
    end
  end
}

debug_parsed_items = proc {
  table_headers =  ["location_id", "level", "path" , "type", "noun" , "name", "amount", "stack" , "status" ]
  table_format = "| % -12s | %-5s | %-20s | %-9s | %-8s | %-36s | %-8s | %-8s | %-8s |"
    respond table_format % table_headers
  @inv_items.each { |v|
    respond table_format % [ v[:location_id], v[:level], v[:path], v[:type], v[:noun], v[:name], v[:amount], v[:stack], v[:status]  ]
  }
}

locker_info = proc {
  @calling_proc = @current_proc
  @current_proc = "locker_info"
  respond "+---------------- proc_start: #{@current_proc}" if @debug

  command         = "locker info"
  start_pattern   = /^#{XMLData.name}, your locker information is as follows:|(?:You possess locker(?<multi>s)|Your locker(?<multi>s)? in .* are currently being swapped|Your locker is currently located in the town of (?<town>.*?)\.|Your locker(?<town> )|(?<town>WARNING).*?: *You currently possess lockers in multiple towns.  However, you are no longer eligible for them.)/i;
  quiet           = @quiet;
  end_pattern     = /^(?:<popBold\/>)?<prompt/;
  include_end     = true;
  timeout         = 5;
  locker_info_result = quiet_command(command, start_pattern, quiet, end_pattern, include_end, timeout).join("\n")
  
  m = patterns[:locker_info].match(locker_info_result)
  if m[:multi] == "s"
    locker_location = "multi"
    @account_type   = @account_type || "premium"
  end
  if m[:town] 
    locker_location = m[:town]
    @account_type   = @account_type || "standard" 
  end
  locker_location = locker_location || "transit"
  @account_type   = @account_type || "standard" 
  respond "account_type: #{@account_type}" if @debug

  @locker_info_run = true
}

refresh_locker = proc {
  @calling_proc = @current_proc
  @current_proc = "refresh_locker"
  respond "+---------------- proc_start: #{@current_proc}" if @debug
  locker_info.call if !@locker_info_run
  locker_premium.call  if @account_type == "premium"
  locker_standard.call if @account_type != "premium"
}

locker_open = proc {
  @calling_proc = @current_proc
  @current_proc = "locker_open"
  respond "+---------------- proc_start: #{@current_proc}" if @debug
  open_locker = dothistimeout "open ##{locker.id}", 3, patterns[:locker_open] #/Your locker is currently holding (\d+) items? out of a maximum of (\d+)|That is already open/i
  (fput "close ##{locker.id}";locker_open.call;) if open_locker =~ /That is already open/
  if open_locker =~ patterns[:locker_open] #/Your locker is currently holding (\d+) items? out of a maximum of (\d+)/i
    locker_look_count    = $1
    locker_item_capacity = $2
  end
  fput "look in ##{locker.id}"
  sleep 0.05
}

locker_standard = proc { 
  @calling_proc = @current_proc
  @current_proc = "locker_standard"
  respond "+---------------- proc_start: #{@current_proc}" if @debug
  #container_pattern = /swordbelt|locker|pack|bag|wardrobe|chest|trunk|coffer|strongbox|pouch|cloak|satchel|stand|bin|rack|kit|bandolier/
  not_in_locker = true;
  squelch.call(locker_standard_squelch_pattern)
  level = -1
  path = ""
  locker = nil;
  respond "Looking for locker by name" if @debug
  locker = GameObj.loot.find{|i| locker = i if i.name =~ /your locker/i }
  
  if !locker 
    respond "Looking for locker by noun" if @debug
    locker = GameObj.loot.find{|i| locker = i if i.noun =~ /locker/i } 
  end
  if !locker 
    counter = nil
    GameObj.room_desc.each{ |d| counter = d if d.name =~ /counter/i }
    if counter
      fput "look on counter"
      sleep 0.01
      counter.contents.each { |c| locker = c if c.name =~/locker/i }
      fput "open ##{locker.id}"
      fput "look in ##{locker.id}"
      Inv_db.gs_print "locker found" if locker.contents && @debug
    else
      Inv_db.gs_print "Looking for locker by interaction" if @debug
      fput "close locker"
      result = nil
      #Can't see locker in room -- e.g. public lockers in RR @ movers
      #open_result = dothistimeout "open locker", 5, /You .*?open|That is already open/i
      #if open_result

      #You open the <a exist="749707" noun="locker">locker</a>.
      #result = dothistimeout "look in locker", 5, /^<.*?>(In the) .*?exist="(\-?\d+)" noun="(.*?)">(.*?)<\/a/i
      #In the <a exist="749707" noun="locker">locker</a> you see a <a exist="40090908" noun="pin">white leaf-shaped pin</a>, a <a exist="40090904" noun="trunk">dented brass trunk</a>, a <a
      #result = dothistimeout "look in locker", 5, /^<.*?>(In the) .*?exist="(\-?\d+)" noun="(.*?)">(.*?)<\/a/
      
      #Script.current.want_downstream_xml = true
      result = dothistimeout "open locker", 1, /(In the) <a exist="(\-?\d+)" noun="(locker)">locker<\/a>(.*?)$/i
      if result
        locker_id = $2
        locker_noun = $3
        xml_contents = $4
        _respond "#{$2} | #{$3} | #{$4}" if @debug
        locker = GameObj.new(GameObj.new($2, $3, $4)) if locker_id.to_i < 0
      end
    end
  end
  if !locker
    not_in_locker = true;
    respond "Couldn't find your locker" if target == "locker"
  end
  if locker
    sorter_handler.call
    not_in_locker = false;
    locker_open.call
    respond "locker_look_count: #{locker_look_count}  |  locker_item_capacity: #{locker_item_capacity}" if @debug
    Inv_db.traverse_container("", locker,-1,"")
    @locker_items = Inv_db.locker_items
    respond "locker_items.count: #{@locker_items.count} "  if @debug
    location_id = 10
    normalize_path = true
    if normalize_path 
      @locker_items.each { |h|
        npath = h[:path].gsub(/^ ?in /,'')
        npath = npath.split(' in ')
        npath.each{ |i| i.strip! }
        npath = npath.reverse.join(' > ')
        h[:path] = npath 
      }
    end
    locker_standard_debug.call if @debug
    insert_temp_item_locker.call if @locker_items.count > 0
  end
}

locker_standard_debug = proc {
  @calling_proc = @current_proc
  @current_proc = "locker_standard_debug"
  respond "+---------------- proc_start: #{@current_proc}" if @debug
  table_hl     = "+------------------------+-------+------------------------+-------------------+-------------------+"
  table_format = "| %-22s | %-3s | %-32s | %-22s| %-32s "
  table_headers =  ["type","lvl","path","noun","name"]
  respond table_hl
  respond table_format % table_headers
  respond table_hl
  @locker_items.each { |i| 
    respond table_format % [i[:type], i[:level], i[:path], i[:noun], i[:name] ]
  }
  respond table_hl
  
  respond "+-------- Item count != listed item count." if locker_look_count.to_i != @locker_items.count.to_i
  respond "+-------- Item count == listed item count." if locker_look_count.to_i == @locker_items.count.to_i
}

locker_premium = proc {
  @calling_proc = @current_proc
  @current_proc = "locker_premium"
  respond "+---------------- proc_start: #{@current_proc}" if @debug
  @locations.each { |k,v|
      if k.to_i > 10
        scan_time = Benchmark.realtime do;
          locker_manifest_scrape.call(k,v)
        end;
        Inv_db.gs_print "+----locker manifest #{v[:name]} time elapsed #{(scan_time*1000).round(2)} milliseconds" if @benchmark;
      end
    }
  insert_temp_item_premium_locker.call
}

locker_manifest_scrape = proc {|location_id|
  @calling_proc = @current_proc
  @current_proc = "locker_manifest_scrape"
  respond "+---------------- proc_start: #{@current_proc} #{location_id}" if @debug

  line_count      = 0
  lm_lines        = []
  other_lines     = []
  location        = @locations[location_id.to_s][:name]
  
  displayed_count = 0
  matched_count   = 0
  start           = false
  
  command         = "locker manifest #{location}"
  start_pattern   = /^Thinking back, you recall|^Looking in front of you, you see the contents of your locker|^You must first visit your local locker before using the LOCKER MANIFEST command in this town./
  quiet           = @quiet;
  end_pattern     = /^(?:<popBold\/>)?<prompt/;
  include_end     = true;
  timeout         = 5;
  lm_lines        = quiet_command(command, start_pattern, quiet, end_pattern, include_end, timeout)
  
  if lm_lines.nil? 
    lm_lines       = quiet_command(command, start_pattern, quiet, end_pattern, include_end, timeout)
  end
  
  count_line      = lm_lines.find { |line| patterns[:manifest_count].match(line) }
  displayed_count = 0
  if count_line !~ /nothing/
    displayed_count = patterns[:manifest_count].match(count_line).captures[0].to_i 
  end

  if lm_lines.join("\n") !~ /You must first visit your local locker before using the LOCKER MANIFEST command in this town./
    parse_manifest.call(lm_lines, location_id, displayed_count, other_lines ) if lm_lines.size > 0
  #else
    #_respond Inv_db.format_monsterbold("You must first visit your locker in #{location} to be able to scan it")
  end
}

parse_manifest = proc { |pm_lines, location_id, displayed_count, other_lines |
  line_count = pm_lines.size
  temp_items = []
  matched_count = 0
  match_fail_lines = []
  match_fail_count = 0
  if pm_lines.size > 0
    Inv_db.gs_print Inv_db.format_monsterbold("#{pm_lines.size} pm_lines to parse") if @debug
  end

  prev_name   = ""
  prev_noun   = ""
  prev_level  = 0
  item_path   = []
  base_path   = nil

  pm_lines.each_with_index { |line,index|
    if line =~ patterns[:locker_container]
      capt = $1
      base_path = "#{capt =~ /(.*?) (\w+)$/ ? $2 : capt}"
      item_path = [ base_path.clone ] if line =~ patterns[:locker_container]
    elsif patterns[:manifest] =~ line
    m = patterns[:manifest].match(line)
      matched_count += 1
      leading_space = m[:depth] =~ /<d/ ? m[:depth].gsub!(/<[^>]+>/,"").gsub!(" ","-") : m[:depth].gsub!(" ","-")
      prename       = m[:pre] =~ /^(an ?|a ?)(.*)?/ ? $2 : m[:pre]
      id            = m[:exist]
      name          = m[:name].strip
      noun          = !m[:noun].nil? ? m[:noun] : name.strip.scan(/^(?:.*?) ([^\s]+)$|^([^ ]+)$/).flatten.join('')
      postname      = m[:post]
      attrs         = m[:attrs]
      registered    = attrs =~ /registered/ ? "Y" : empty_string
      marked        = attrs =~ /marked/     ? "Y" : empty_string
      hidden        = attrs =~ /hidden/     ? "Y" : empty_string
      amount        = 1
      type          = name == "some blue lapis lazuli" ? "gem" : Inv_db.get_item_type(name,noun) || 'unknown' #empty_string
      level         = ((leading_space.length.to_i - 6) / 2).to_i
      item_path.push(prev_noun)  if level > prev_level
      if level < prev_level
        n_pop = prev_level - level;
        n_pop.times { item_path.pop; } 
        item_path = [ base_path ] if item_path.length == 0
      end
      
      path          = "#{item_path.join(' > ')}" if !item_path.nil?
        stack         = empty_string
        stack_name    = empty_string
        stack_noun    = empty_string
        stack_type    = empty_string
        stack_amount  = 0
        status        = empty_string
        
      if type =~ /\bjar\b/
      #if type =~ stack_pattern 
        stack_name      = Inv_db.deplural(postname).strip
        stack_noun      = stack_name =~ /(.*?) ([^\s]+)$/ ? $2 : empty_string
        stack_noun      = stack_noun =~ /lazuli/ ? "lapis" : stack_noun
        stack_type      = Inv_db.get_item_type(stack_name,stack_noun) 
        stack_manifest  = attrs =~ /(\((\d+)\/\d+\))/ ? $1 : nil
        stack_amount    = attrs =~ /\((\d+)\/\d+\)/ ? $1 : nil
        status          = stack_amount.nil? ? "empty" : attrs =~ /\((\d+)\/\1\)/ ? "full" : "partial"
        stack           = "jar" if stack_amount.to_i > 0
      end
      
      name          = "#{prename}#{name =~ /^(some )?(.*)/ ? $2 : name} #{stack == "" ? postname.strip : "(#{postname.strip}) #{stack_manifest.strip}"}".strip        

      prev_level    = level.to_i
      prev_noun     = noun
      prev_name     = name

      temp_items.push( {
        :id           => id,
        :location_id  => location_id.to_i,
        :level        => level+1, 
        :path         => path.encode('UTF-8'), 
        :type         => type ? type : empty_string,
        :name         => name.encode('UTF-8'), 
        :noun         => noun.encode('UTF-8'), 
        :amount       => amount.to_i, 
        :stack        => empty_string, 
        :status       => status.encode('UTF-8'), 
        :marked       => marked.encode('UTF-8'), 
        :registered   => registered.encode('UTF-8'), 
        :hidden       => hidden.encode('UTF-8'), 
        :worn         => empty_string,
        :update_noun  => id ? 1 : 0
        })

      temp_items.push( {
        :id           => id,
        :location_id  => location_id.to_i,
        :level        => level+1,
        :path         => "#{path} > #{stack}".to_s.encode('UTF-8'), 
        :type         => stack_type ? stack_type : empty_string,
        :name         => stack_name.encode('UTF-8'), 
        :noun         => stack_noun.encode('UTF-8'),
        :amount       => stack_amount.to_i,
        :stack        => stack.encode('UTF-8'), 
        :status       => empty_string, 
        :marked       => empty_string, 
        :registered   => empty_string, 
        :hidden       => empty_string,
        :worn         => empty_string,
        :update_noun  => 0
      }) if stack != "";
    else
      match_fail_lines << line
      match_fail_count += 1
    end
  }
  if matched_count == displayed_count 
    @manifest_retry = 1;
    @manifest_count += displayed_count
    matched_count   = 0;
    displayed_count = 0;
    @locker_items = @locker_items + temp_items
  else
    _respond "parse count: #{matched_count} != displayed count: #{displayed_count}"
    if @manifest_retry < 4
      _respond "retrying after missing lines in manifest: #{location_id}"
      _respond "match_fail_count = #{match_fail_count}"
      _respond "match_fail_lines: #{match_fail_lines.join("\n")}"
      @manifest_retry += 1
      _respond "starting attempt ##{@manifest_retry}"
      locker_manifest_scrape.call(location_id)
    else
      _respond other_lines.join("\n")
      _respond "giving up on manifest scan, exiting."
      close_containers.call
      exit
    end
  end
}

query_item = proc {|iparams|
  @calling_proc = @current_proc
  @current_proc = "query_item"
  respond "+---------------- proc_start: #{@current_proc}" if @debug
  respond "+----iparams:#{iparams}" if @debug
  sql,qargs = Inv_db.query_item_sql(iparams.clone,style,orderby)
  Inv_db.gs_print sql if @debug_sql
  begin
    rows = db.execute2(sql,qargs)
    rescue SQLite3::BusyException
      sleep 0.1
      retry
#    ensure
#      #db.close if db
  end
  Inv_db.output_table(rows,target,iparams,"item")
};

#------------------------------------------------------------------------------#
# sum / aggregate queries
#------------------------------------------------------------------------------#
sum_item = proc {|iparams|
  @calling_proc = @current_proc
  @current_proc = "query_item"
  respond "+---------------- proc_start: #{@current_proc}" if @debug
  respond "+----iparams:#{iparams}" if @debug
  sql,qargs = Inv_db.sum_item_sql(iparams.clone,"",groupby, orderby)
  Inv_db.gs_print sql if @debug_sql
  begin
    rows = db.execute2(sql,qargs)
    rescue SQLite3::BusyException
      sleep 0.1
      retry
#    ensure
#      #db.close if db
  end
  Inv_db.output_table(rows,target,iparams,"item")
};
count_item = proc {|iparams|
  @calling_proc = @current_proc
  @current_proc = "query_item"
  respond "+---------------- proc_start: #{@current_proc}" if @debug
  respond "+----iparams:#{iparams}" if @debug
  sql,qargs = Inv_db.count_item_sql(iparams.clone,"",groupby, orderby)
  Inv_db.gs_print sql if @debug_sql
  begin
    rows = db.execute2(sql,qargs)
    rescue SQLite3::BusyException
      sleep 0.1
      retry
#    ensure
#      #db.close if db
  end
  Inv_db.output_table(rows,target,iparams,"item")
};
#------------------------------------------------------------------------------#
# export helpers
#------------------------------------------------------------------------------#
export_formats = Hash.new
export_formats["csv"]  = {:type => 'csv', :delimiter => ',',   :extension => 'csv'}
export_formats["txt"]  = {:type => 'txt', :delimiter => 9.chr, :extension => 'txt'}
export_formats["text"] = {:type => 'txt', :delimiter => 9.chr, :extension => 'txt'}
export_formats["pipe"] = {:type => 'txt', :delimiter => '|',   :extension => 'txt'}
#------------------------------------------------------------------------------#
# Export
#------------------------------------------------------------------------------#
export = proc {|target, qparams, xparams|
  
  export_format = xparams[:format] ? export_formats[xparams[:format]] : export_formats["csv"]
  
  dir_delim = $lich_dir =~ /(\\|\/)/ ? $1 : "/"
  export_dir = xparams[:dir] || "#{$lich_dir}inv"
  export_dir = export_dir.gsub(/\$lich_dir/i,$lich_dir)
  
  respond "export_dir:#{export_dir}" if @debug
  Dir.mkdir(export_dir) unless File.exists?(export_dir)
  export_dir = "#{export_dir}#{dir_delim}" if export_dir.slice(-1) !~ /\/\\$/
  
  datetimestamp = "#{Time.now.strftime("%Y-%m-%d_%H-%M-%S")}"
  export_qparams = qparams.collect {|k,v| v if k.to_s !~ /search_regex/}.compact
  echo qparams.inspect 
  export_filename = xparams[:file] || "#{export_qparams.empty? ? "" : (export_qparams.join('_') + "_")}#{target}_#{datetimestamp}.#{export_format[:extension]}"
  export_filename = export_filename.sub('timestamp',datetimestamp)
  export_file = "#{export_dir}#{export_filename}"
  
  style = xparams[:style] || "export"
  
  sql,qargs = Inv_db.query_bank_sql(qparams,style,orderby) if target == "bank"
  sql,qargs = Inv_db.sum_bank_sql(qparams,style,orderby)   if target == "sbank"
  sql,qargs = Inv_db.query_tickets_sql(qparams,style,orderby) if target == "tickets"
  sql,qargs = Inv_db.sum_tickets_sql(qparams,style,orderby) if target == "stickets"
  
  sql,qargs = Inv_db.query_char_sql(qparams,style,orderby) if target == "char"
  sql,qargs = Inv_db.query_item_sql(qparams,style,orderby) if target =~ /item|inv|loc/
  rows = db.execute2(sql, qargs)
  
  if rows.length > 1
    if export_format[:type] !~ /csv/
      begin
        file = File.open(export_file, "w+")
        rows.each { |row|
          file.puts row.join(export_format[:delimiter])
        } 
      ensure
        file.close rescue()
      end
    end
    if export_format[:type] =~ /csv/
      begin
        require 'csv'
        csv = CSV.open(export_file, "w+")
        rows.each { |row|
          csv << row
        } 
      ensure
        csv.close rescue()
      end
    end
    export_file = export_file.gsub("/","\\") if export_file =~ /^\w:/i
    Inv_db.gs_print Inv_db.format_whisper("exported #{rows.length-1} row#{rows.length > 2 ? "s" : ""} from #{target} to #{export_file}.")
  else 
    Inv_db.gs_print Inv_db.format_monsterbold("no rows to export for #{target}")
  end
}

#------------------------------------------------------------------------------#
# todo:profile
#------------------------------------------------------------------------------#
=begin
<output class="mono"/>
<pushBold/>PERSONAL INFORMATION
<popBold/>Name: Ivvy
Profession: Warrior   Level: 0
Race: Giantman   Gender: Female
Age: very young (0)
Clan: Issimir Clan
He is average height.  He appears to be very young.
He has large hazel eyes and tanned skin.
He has raggedly cut, shaggy dark brown hair with grey at the temples.
He has an unshaven face, a freckled nose and bushy eyebrows.
<pushBold/>
AFFILIATIONS
<popBold/>Not a citizen of any known realm
No House affiliation
No MHO affiliation
No Society affiliation
No Guild affiliation
No Deity chosen
<pushBold/>
ACHIEVEMENTS
<popBold/>Most difficult lock picked: None
Most difficult trap disarmed: None
Number of warcamps destroyed: None
<output class=""/>
<prompt time="1527787070">&gt;</prompt>
=end
#------------------------------------------------------------------------------#
# todo:society
#------------------------------------------------------------------------------#
=begin
<c>society
<pushBold/>
Current society status:
<popBold/>   You are a Master in the Order of Voln.
<pushBold/>
You have learned and are able to use the following abilities:
<popBold/>   <a exist="-11127597" coord="2524,1757" noun="recognition">Symbol of Recognition</a>
   Symbol of Blessing
   <a exist="-11127597" coord="2524,1827" noun="symbol thought">Symbol of Thought</a>
   Symbol of Diminishment
   <a exist="-11127597" coord="2524,1757" noun="courage">Symbol of Courage</a>
   <d>Symbol of Protection</d>
   Symbol of Submission
   Kai's Strike
   Symbol of Holiness
   <d>Symbol of Recall</d>
   <a exist="-11127597" coord="2524,1757" noun="sleep">Symbol of Sleep</a>
   <d>Symbol of Transcendence</d>
   <a exist="-11127597" coord="2524,1757" noun="mana">Symbol of Mana</a>
   <a exist="-11127597" coord="2524,1827" noun="symbol sight">Symbol of Sight</a>
   <d>Symbol of Retribution</d>
   <d>Symbol of Supremacy</d>
   <a exist="-11127597" coord="2524,1757" noun="restoration">Symbol of Restoration</a>
   <a exist="-11127597" coord="2524,1757" noun="need">Symbol of Need</a>
   <d>Symbol of Renewal</d>
   <d>Symbol of Disruption</d>
   Kai's Smite
   <a exist="-11127597" coord="2524,1757" noun="turning">Symbol of Turning</a>
   <a exist="-11127597" coord="2524,1757" noun="preservation">Symbol of Preservation</a>
   <a exist="-11127597" coord="2524,1757" noun="dreams">Symbol of Dreams</a>
   <a exist="-11127597" coord="2524,1757" noun="return">Symbol of Return</a>
   <d>Symbol of Seeking</d>
<pushBold/>
Past society affiliations (resigned or cast out):
<popBold/>   You have no past society affiliations.
You may reset your society status one time.  Enter <a exist="-11127597" coord="2524,1931" noun="">SOCIETY RESET</a> for details.
You may view your society task information via the <d>SOCIETY TASK</d> command.
<prompt time="1527787308">&gt;</prompt>
=end

#------------------------------------------------------------------------------#
# Parse user input
#------------------------------------------------------------------------------#
(@benchmark   = true;                           ) if script.vars[0] =~ /@ben/
(@debug       = true; Inv_db.debug = true;      ) if script.vars[0] =~ /@debug/
(@debug_sql   = true; Inv_db.debug_sql = true;  ) if script.vars[0] =~ /@sql|@debug_sql/
#(@debug_hook  = true; Inv_db.debug_hook = true; ) if script.vars[0] =~ /@hook/
(@debug_input = true; Inv_db.debug_input = true;) if script.vars[0] =~ /@input|@debug_input/
(@debug_print = true; Inv_db.debug_print = true;) if script.vars[0] =~ /@print|@debug_print/
(@no_squelch  = true; Inv_db.no_squelch  = true;) if script.vars[0] =~ /@no_?squelch/
(@autofit  = true; Inv_db.autofit  = true;) if script.vars[0] =~ /@autofit/
(@slower      = true; Inv_db.slower      = true;) if script.vars[0] =~ /@slower/
Inv_db.use_old_quiet_command = @use_old_quiet_command;
Inv_db.autofit = Settings["autofit"]

#respond "@no_squelch:#{@no_squelch}"

silence_me if $SAFE == 0 && !@debug && !@no_squelch
actions = [ "query", "refresh", "report", "count"]
targets = ["bank", "char", "item", "inventory", "locker", "silver", "all", "character","tickets","sbank","stickets"]
filters = ["char", "name", "noun", "amount", "qty", "type", "stack", "status", 
           "location", "path", "marked", "registered", "worn" ]
options = ["select", "group", "order" ]
export_options = ["format", "style", "dir" ]
#todo: abbreviations for columns in additional groupby
#groupbys = ["char", "name", "noun", "amount", "qty", "type", "stack", "status", "location", "path", "marked", "registered", "worn" ]

partials = Hash.new
partials[:actions] = Inv_db.generate_partials(actions)
partials[:actions]["export"] = "export"
partials[:actions]["reset"]  = "reset"
partials[:actions]["delete"] = "delete"
partials[:actions]["drop"]   = "drop"
partials[:actions]["sum"]    = "sum"
partials[:actions]["count"]  = "count"
partials[:actions]["total"]  = "sum"
partials[:targets] = Inv_db.generate_partials(targets)
partials[:filters] = Inv_db.generate_partials(filters)#,"=")
#extra aliases
partials[:filters]["epf"] = "status"
partials[:filters]["stk"] = "stack"
#partials[:options] = Inv_db.generate_partials(options,":")

print_partials = proc {
  table_headers = ["partial", "target"]
  table_format = "| %-22s | %-22s"
  respond table_format % table_headers
  partials.each { |k,v|
      respond "-----#{k}"
    v.each { |k,v|
      respond table_format % [k,v]
    }
  }
}
#print_partials.call
vars = script.vars
vars.delete_if { |i| i =~ /^(@|delay=)/ }
_respond "invdb vars:#{vars}" if @debug_input

  if @debug_input 
    if !vars[0]
      respond "no input"
    else
      i = 0
      vars.each {
      respond "#{i}: #{script.vars[i]}"
      i += 1
      }
    end
  end

  if vars[0]
    action = partials[:actions][vars[1]]
    vars.slice!(1) if action
    target = partials[:targets][vars[1].to_s] if action
    vars.slice!(1) if action && target
    action = action.nil? ? "query" : action
    target = target.nil? ? (action =~ /query|sum|count/ ? "item" : "all") : target
    
    #(column)(operation)(value|values)
    char_filter   = "#{$2.to_s.gsub(/\*/,"%")}" if vars[0] =~ /\b(ch?a?r?a?c?t?e?r?s?|name)=([^\s]+).*/i
    char_array    = char_filter.split("|")
    char_filter   = nil if char_array.length > 1
    char_array  = nil if char_array.length < 2
    char_array.each{ |c| c = c.capitalize! } if char_array 
    game_filter   = "#{$2.to_s}%" if vars[0] =~ /\b(ga?m?e?)=([^\s]+)/i
    game_filter   = game_filter ? game_filter : XMLData.game.to_str.encode('UTF-8')
    account_type_filter = "#{$2.to_s}%" if vars[0] =~ /\b(act|account)=([^\s]+)/i
    profession_filter = "#{$2.to_s}%" if vars[0] =~ /\b(prof?|profession|class|p)=([^\s]+)/i
    race_filter = "#{$2.to_s}%" if vars[0] =~ /\b(rc|race)=([^\s]+)/i
    location_filter   = "#{$2.to_s.gsub("*","%")}%" if vars[0] =~ /\b(#{partials[:filters].select{|k,v| k if v == "location"}.keys.join("|")})=([^\s]+)/i
    location_filter = "alongside" if location_filter =~ /feet$/i
    path_filter = nil 
    if vars[0] =~ /\b(pa?t?h?)=([^\s]+)/i
      p = $2
      if  p =~ /^(?:''|""|blank|empty|none|null)$/i 
        path_filter  = "''"
      else
        path_filter = p.gsub("*","%")
      end
    end
    area_filter   = "#{$2.to_s.gsub("*","%")}%" if vars[0] =~ /\b(ar?e?a?)=([^\s]+)/i
    item_filter   = target if target =~/^(inv|locker|item|all)/i
    #item_filter   = vars[2] =~/^(inv|locker|item|worn|loca|all)/i ? $1 : nil
    type_filter   = "%#{$2.to_s.gsub("*","%")}%" if vars[0] =~ /\b(y|ty?p?e?)=(lm trap|[^\s]+)/i
    type_filter   = "#{$2.to_s.gsub("*","%")}" if vars[0] =~ /\b(y|ty?p?e?)="([^\"]+)"/i
    #type_filter   = $2.to_s.gsub("*","%") if vars[0] =~ /\b(ma?r?k?e?d?)=([^\s]+)/i
    noun_filter   = "#{$2.to_s}%" if vars[0] =~ /\b(no?u?n?)=([^\s]+)/i
    amount_filter = $2.to_s if vars[0] =~ /\b(am?o?u?n?t?)([<=>]+\d+)/i
    amount_filter = $2.to_s if vars[0] =~ /\b(qt?y?)([<=>]+\d+)/i  #just another name for amount
    amount_filter = amount_filter.gsub(/(=)([<>])/,/#{$2}#{$1}/) if amount_filter =~ /(=)([<>])/
    stack_filter  = "#{$2.to_s}%" if vars[0] =~ /\b(sta?c?ke?d?)=([^\s]+)/i
    #status_filter = "#{$2.to_s}%" if vars[0] =~ /\b(statu?s?)=([^\s]+)/i
    status_filter = "#{$2.to_s}%" if vars[0] =~ /\b(#{partials[:filters].select{|k,v| k if v == "status"}.keys.join("|")})=([^\s]+)/i
    marked_filter = "#{$2.to_s}%" if vars[0] =~ /\b(ma?r?k?e?d?)=([^\s]+)/i
    registered_filter = "#{$2.to_s}%" if vars[0] =~ /\b(re?g?i?s?t?e?r?e?d?)=([^\s]+)/i
    hidden_filter = "#{$2.to_s}%" if vars[0] =~ /\b(hi?d?d?e?n?)=([^\s]+)/i
    orderby       = $2.to_s.gsub(/['"]/,"").gsub(/[,]+/,", ").gsub("-"," desc ").gsub("+"," asc ") if vars[0] =~ /\b(ord?e?r?b?y?)=(['"][^"']+['"]|[^\s]+).*/i
    groupby       = $2.to_s.gsub(/['"]/,"").gsub(/[,]+/,", ") if vars[0] =~ /\b(gr?o?u?p?b?y?)=(['"][^"']+['"]|[^\s]+).*/i
    #export_options = ["format", "style", "dir" ]
    format = $2.to_s if vars[0] =~ /\b(format)=(#{export_formats.keys.join('|')}).*/i
    style  = $2.to_s if vars[0] =~ /\b(style)=([^s]+).*/i
    dir    = $2.to_s if vars[0] =~ /\b(dir)=("[^"]+"|[^s]+).*/i
    dir    = dir.gsub('"','') if dir =~ /"/i
    file   = $2.to_s if vars[0] =~ /\b(file)=("[^"]+"|.*?\b).*/i
    file    = file.gsub('"','') if file =~ /"/i
    
    search_filter = vars[1..-1].find_all{ |v| v !~ /^\w+[<=>]+.+|^@/i }.join(' ').strip.encode('UTF-8')
    search_regex = false;
    search_regex = true if search_filter[0] == "/";
    search_filter[0] = ''   if search_regex
    search_filter[-1] = ''  if search_regex
    if search_filter =~ /^=.+/  && !search_regex
      _respond 'eq' if @debug_input
      search_filter ="#{search_filter.gsub("*","%").delete('=')}"
    else
      search_filter = search_filter.length == 0 ? nil : "%#{search_filter.gsub(/[\*\s]/,"%").strip}%" if !search_regex
    end
    _respond "search_filter: #{search_filter}" if @debug_input

    if @debug_input
      respond "| action            = #{action}"
      respond "| target            = #{target}"
      respond "| char_filter       = #{char_filter}"
      respond "| char_array        = #{char_array}"
      respond "| game_filter       = #{game_filter}"
      respond "| location_filter   = #{location_filter}"
      respond "| area_filter       = #{area_filter}"
      respond "| profession_filter = #{profession_filter}"
      respond "| race_filter       = #{race_filter}"
      respond "| path_filter       = #{path_filter}"
      respond "| item_filter       = #{item_filter}"
      respond "| type_filter       = #{type_filter}"
      respond "| noun_filter       = #{noun_filter}"
      respond "| amount_filter     = #{amount_filter}"
      respond "| search_filter     = #{search_filter}"
      respond "| stack_filter      = #{stack_filter}"
      respond "| status_filter     = #{status_filter}"
      respond "| marked_filter     = #{marked_filter}"
      respond "| registered_filter = #{registered_filter}"
      respond "| hidden_filter     = #{hidden_filter}"
      respond "| groupby           = #{groupby}"
      respond "| orderby           = #{orderby}"
      respond "| format            = #{format}"
      respond "| style             = #{style}"
      respond "| dir               = #{dir}"
      respond "| file              = #{file}"
      _respond "vars: #{vars.to_s}" if @debug_input
    end

    params = Hash.new
    params[:char_filter]       = char_filter.encode('UTF-8')       if char_filter != "" && char_filter.nil? == false
    params[:char_array]        = char_array                        if char_array.length > 1
    params[:game_filter]       = game_filter.encode('UTF-8')       if game_filter != "" && game_filter.nil? == false
    params[:account_type_filter] = account_type_filter.encode('UTF-8') if account_type_filter != "" && account_type_filter.nil? == false
    params[:profession_filter] = profession_filter.encode('UTF-8') if profession_filter != "" && profession_filter.nil? == false
    params[:race_filter] = race_filter.encode('UTF-8') if race_filter != "" && race_filter.nil? == false
    params[:location_filter]   = location_filter.encode('UTF-8')   if location_filter != "" && location_filter.nil? == false
    params[:area_filter]       = area_filter.encode('UTF-8')       if area_filter != "" && area_filter.nil? == false
    params[:path_filter]       = path_filter.encode('UTF-8')       if path_filter != "" && path_filter.nil? == false
    params[:item_filter]       = item_filter.encode('UTF-8')       if item_filter.encode('UTF-8')=~ /inv|locker|items/i
    params[:type_filter]       = type_filter.encode('UTF-8')       if type_filter
    params[:noun_filter]       = noun_filter.encode('UTF-8')       if noun_filter
    params[:amount_filter]     = amount_filter.encode('UTF-8')     if amount_filter
    params[:search_filter]     = search_filter.encode('UTF-8')     if search_filter
    params[:search_regex]      = search_regex
    params[:stack_filter]      = stack_filter.encode('UTF-8')      if stack_filter
    params[:status_filter]     = status_filter.encode('UTF-8')     if status_filter
    params[:marked_filter]     = marked_filter.encode('UTF-8')     if marked_filter
    params[:registered_filter] = registered_filter.encode('UTF-8') if registered_filter
    params[:hidden_filter]     = hidden_filter.encode('UTF-8')     if hidden_filter

    params.each { |k,v|
      v.gsub!(/^(nil|null|\"\")$/ , '""') if v =~ /^(nil|null|\"\")$/
      respond "new values: #{k}: #{v}" if @debug
    }
    
    xparams = Hash.new
    xparams[:format] = format.encode('UTF-8') if format
    xparams[:style]  = style.encode('UTF-8')  if style
    xparams[:dir]    = dir.encode('UTF-8')    if dir
    xparams[:file]   = file.encode('UTF-8')   if file

    if @debug
      params.each { |k,v| 
        respond "#{k}: #{v}"
      }
      xparams.each { |k,v| 
        respond "#{k}: #{v}"
      }
      _respond vars.to_s
      pause_script if @debug_input
    end
    else 
      action = "refresh"
      target = "all"
  end

if vars[0] =~ /\bgui\b/i  
  unless defined?(Gtk)
    _respond "invdb: error: no gtk"
    exit
  end
  @gui = true
end

#------------------------------------------------------------------------------#
# do stuff
#------------------------------------------------------------------------------#
if action == "refresh"

=begin
  #sorter_handler.call       if target =~ /locker/i
  refresh_bank.call(params) if target =~ /wealth|bank|silver|all/i || target.nil?
  scrape_bank.call          if target =~ /char/i  || target.nil?
  refresh_char.call(params) if target =~ /char|all/i  || target.nil?
  refresh_item.call(params) if target =~ /inv|locker|item|all/i || target.nil?
=end

  require "benchmark" 

  if target =~ /bank|all/i || target.nil?
    Inv_db.gs_print "updating bank account..." if !@benchmark
    bank_time = Benchmark.realtime do
      refresh_bank.call(params) 
    end
    Inv_db.gs_print "refresh_bank time elapsed #{(bank_time*1000).round(2)} milliseconds" if @benchmark
  end

  if target =~ /tickets|all/i || target.nil?
    Inv_db.gs_print "updating ticket balance..." if !@benchmark
    ticket_time = Benchmark.realtime do
      refresh_tickets.call(params) 
    end
    Inv_db.gs_print "refresh_tickets time elapsed #{(ticket_time*1000).round(2)} milliseconds" if @benchmark
  end

  if target =~ /cha|all/i  || target.nil?
    Inv_db.gs_print "updating character..." if !@benchmark
    char_time = Benchmark.realtime do
      refresh_char.call(params) 
    end
    Inv_db.gs_print "refresh_char time elapsed #{(char_time*1000).round(2)} milliseconds" if @benchmark
  end
  
  if target =~ /inv|locker|item|all/i || target.nil?
    item_time = Benchmark.realtime do
      refresh_item.call(params) 
    end
    Inv_db.gs_print "+refresh_item time elapsed #{(item_time*1000).round(2)} milliseconds" if @benchmark
  end

end

if action == "query"
  target = target.nil? ? "item" : target
  query_char.call(params) if target =~ /char/i
  query_bank.call(params) if target =~ /wealth|bank|silver/i
  query_tickets.call(params) if target =~ /tickets/i
  query_item.call(params) if target =~ /inv|locker|item/i
end

if action == "sum"
  target = target.nil? ? "item" : target
  sum_bank.call(params) if target =~ /wealth|bank|silver/i
  sum_tickets.call(params) if target =~ /tickets/i
  sum_item.call(params) if target =~ /inv|locker|item/i
end
if action =="count"
  target = target.nil? ? "item" : target
  count_item.call(params) if target =~ /inv|locker|item/i
end

if action == "export"
    export.call(target, params, xparams)
end

if action == "delete"
  _respond "char_filter = #{char_filter}" if @debug
  _respond "target = #{target}" if @debug
  params.delete_if{ |k,v| k.to_s.match(/search_regex/i) }
  delete_bank.call(params)    if target =~ /all|char|bank|silver|wealth/i && char_filter 
  delete_tickets.call(params) if target =~ /all|tickets/i && char_filter 
  delete_item.call(params)    if target =~ /all|char|inv|item|locker/i && char_filter 
  delete_char.call(params)    if target =~ /all|char/i && char_filter 
end

#if action == "reset"
  #drop_tables.call
#end

#------------------------------------------------------------------------------#
# sum up, if did stuff
#------------------------------------------------------------------------------#
has_changes = 0
changes.each { |k,v|
  v.each { |l,w|
    has_changes = w if w > has_changes 
  } if k !~ /char/
}
Inv_db.gs_print "action: #{action} | has_changes: #{has_changes}" if @debug

if action =~ /^(r|d)/i && has_changes > 0
  to_print = []
  changes_hl = "+----------+----------+----------+----------+"
  to_print << empty_string
  to_print << @mono_start
  to_print <<  changes_hl
  to_print <<  "| %-8s | %-8s | %-8s | %-8s |" % ["table", "inserted", "updated", "deleted"]
  to_print <<  changes_hl
  changes.each {|k,v| 
    to_print <<  "| %-8s | %8s | %8s | %8s |" % [k, v[:inserted], v[:updated], v[:deleted] ] if v.values.max > 0
  }
  to_print <<  changes_hl
  to_print << @mono_end
  Inv_db.gs_print to_print.join("\n")
end
final_output = []
final_output << "Total inventory items: #{@inventory_count}" if @inventory_count > 0
final_output << "Total manifest items: #{@manifest_count}" if @manifest_count > 0
Inv_db.gs_print Inv_db.format_whisper(final_output.join("\n")) if final_output.length > 0
#------------------------------------------------------------------------------#
# close db
# added sqlite VACUUM every 12 hours.  That's often, but it's fast.
#------------------------------------------------------------------------------#
begin
  retries ||= 0
  stmt.close if !stmt.closed?
  if has_changes > 0
    last_vacuum = Settings["last_vacuum"] 
    respond "last_vacuum: #{last_vacuum}" if @debug
    if (last_vacuum + 36000) < Time.now  #vacuum once every twelve hours
      db.execute('VACUUM') if has_changes > 0
      Settings["last_vacuum"] = Time.now;
      Settings.save;
    end
  end
  db.close if db
  _respond "invdb: db closed" if @debug
  rescue SQLite3::BusyException
    sleep 0.4
    retry if (retries += 1) < 3
end
#------------------------------------------------------------------------------#
# stuff done
#------------------------------------------------------------------------------#
exit;