=begin
  Squelch the Locksmith Pool!
  - created by Wolenthor

  Squelch common unnecessary (global, not just your own) messages at the locksmithpool. You can add any additional messages to the array below or simply message Wolenthor on discord with any messaging you think would be beneficial to remove in future updates.

  Hides all messages that are explicitly set in the script:
  -- Usage: ;squelch_pool

  If you ever want to see what is being squelched, you can use the following command instead:
  -- Usage: ;squelch_pool showme

  Just end the script to stop the squelching. 

  v. 1.0.0 - Initial release
  v. 1.0.1 - Added more squelch patterns
  v. 1.0.2 - Added... more squelch patterns
=end

@squelch_hook_name ||= :squelch_pool_hook

begin
  DownstreamHook.remove(@squelch_hook_name)
rescue
end

# Lines that should be squelched (Ruby Regexp)
# easier to manage: put each pattern/string in an array and build a single regexp
SQUELCH_PATTERNS = [
  'speaks briefly with the worker',
  'speaks briefly with',
  'professional calipers a bit',
  'carefully bends the tip of his',
  'removes a pair of',
  'removes a pair of metal grips',
  'Please rephrase that command',
  /tries to empty the contents of/i,
  /takes.*?some.*?coins/i,
  /removes.*?calipers/i,
  /moths takes.*?calipers/i,
  /dropping.*?calipers.*?in.*?hand/i,
  /refines (?:his|her) professional calipers a bit/i,
  /attaches an?\b.*?keyring/i,
  /(?:removes|grabs?|puts?|produces)\s+(?:some|an?)\b.*?\b(?:box|strongbox|chest|trunk|coffer)s?/i,
  /(?:removes|grabs?|puts?)\s+(?:some|an?)\b.*?\b(?:caliper|calipers)s?/i,
  /(?:box|strongbox|chest|trunk|coffer) vanishes into the depths/i,
  /just opened\s+an?\b.*?\b(caliper|calipers|box|strongbox|chest|trunk|coffer)s?/i,
  /to carefully measure the lock.../i,
  /glass vial/i,
  /green-tinted vial filled with thick acrid smoke/i,
  /(?:attaches|removes) an?.*?toolkit/i,
  /put a pair of small steel jaws in (?:his|her)/i,
  /detaches a.*?keyring/i,
  /no longer appears focused/i,
  /searches through a/i,
  /appears extremely focused/i,
  /briefly outlined by the woven yarn as/i,
  /and removes one item of note/i,
  /and carefully works it back and forth until it is firmly seated/i,
  /, which takes off in search of silvers inside/i,
  /unties (?:his|her) pouch,.*?then reties it quickly/i,
  /Suddenly it seems to spring to life as a tiny mechanical arm extends/i,
  /, causing its bronze gears to whirl./i,
  /begins to glow with a white light for a few moments as a tiny/i,
  /moment later the gears spring to life as the/i,
  /moments before retreating back into the/i,
  /begins to glow with a white light for a few moments/i,
  /removes(?:some|an?)\b.*?\b(?:caliper|calipers)s?/i,
  /removes .*?from in a large wastebasket/i,
]


MASTER_SQUELCH = Regexp.union(
  SQUELCH_PATTERNS.map { |p| p.is_a?(Regexp) ? p : Regexp.new(Regexp.escape(p)) }
  )
  
begin
  params = Script.current.vars rescue []
  _respond "#{monsterbold_start}Params: #{params} #{monsterbold_end}\n"
end

squelch_action = proc { |server_string|
  if server_string =~ MASTER_SQUELCH
    # optional notification to your UI (comment out to be completely silent)
    begin
      if params[0].downcase == 'showme'
        _respond "#{monsterbold_start}Squelched: #{server_string.strip}#{monsterbold_end}\n"
      end
    rescue
      # ignore if _respond unavailable
    end
    nil    # returning nil squelches the line (prevents it reaching `get`)
  else
    server_string
  end
}

DownstreamHook.add(@squelch_hook_name, squelch_action)
at_exit { DownstreamHook.remove(@squelch_hook_name) rescue nil }
[:INT, :TERM].each do |sig|
  trap(sig) { DownstreamHook.remove(@squelch_hook_name) rescue nil; exit }
end

cleanup = proc {
  begin
    DownstreamHook.remove(@squelch_hook_name)
  rescue => _
    nil
  end
}

begin
  while line = get        
    if line =~ MASTER_SQUELCH
      next
    end
  end
ensure
  cleanup.call
end
