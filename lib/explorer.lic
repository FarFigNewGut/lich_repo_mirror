=begin
 
        explorer.lic: Bigshot fork by Alastir
 
              author: Alastir
                tags: hunting
             version: 1.0
 
		Instructions for setup at https://gswiki.play.net/Script_Bigshot


		Previous Version Notes:
		-Explorer will on first run for a Ranger with a companion set your companion to a variable. 
			 You can reset this variable with ;explorer ranger or ;explorer companion

		-Added option to use Celerity (506) for any command.
			 Will cast if you dont have it on you or you have less than 6 seconds or so left on haste.
			 Just add haste or 506 to the front of any command you want it to be cast before.
			 example: "506 kill target" or "haste kill target(x3),525(pcs)"
			
=end
=begin
		Edits by Hazado: (2016-06-01)
		V3.3 (2016-06-01)
			-Added UAC combat! Start it with hunting command "unarmed punch/jab/kick/grapple"
		v3.31 (2016-06-02)
			-Changed up the ambush command so it ambushes what you said to ambush first, then attempts right leg, left leg, then chest
		v3.32 (2016-06-02)
			-Added Voln Smite to command, use Smite in your hunting commands
			-Rewrote Ambush again! Now has the option to pick locations you want to ambush at on the hunting page
			 Also supports it from the hunting command i.e. "ambush head"
			 If left blank without picking any options in setup will default to Head, Right Leg, Left Leg, Chest
		v3.34 (2016-06-08)
			-Added aiming for archery to the Hunting tab in setup.
			 Will change location once you stick the place your aiming at, looping until the creature is dead
		v3.35 (2016-06-14)
			-Added option for attacks to only trigger when certain number of creatures are in the room.
			 Just add (mob#) to the attack you want to do
		v3.36 (2016-06-23)
			-Added option for adjusting wander time between rooms (Found on Hunting Map Tab)
		v3.37 (2016-06-24)
			-can now have two or more checks for a command. i.e kill(mob3 s20 h80) 3 mobs in room, stamina is above 20, health is above 80%
			 must all be inside the () and seperated with a space
			 current checks are mana/stamina/health(percentage)/encumbrance/unarmed tiering/mobs in room
			 m/s/h/e/tier/mob respectively
		v3.38 (2016-06-25)
			-added command check for target not being prone or target being undead
			 current checks are mana/stamina/health(percentage)/encumbrance/unarmed tiering/mobs in room/target not prone/target undead
			 m/s/h/e/tier/mob/prone/undead respectively
			 Prone means target is sleeping|webbed|stunned|kneeling|sitting|lying down|prone|frozen|held in place
		V3.39 (2016-06-26)
			-Quick Hunting mode added - Just start bigshot with the variable quick - ;bigshot quick
			 Quick Mode overrides your currently setup targets and targets the current room npcs
			 Uses Quick Hunting Commands
			-Supports up to 10 (A-J) different attack routines now.
			 Moved all the attack routines to new tab, Commands
			-Moved few options to the attacking tab
		V3.40 (2016-06-30)
			-Mstrike will now cast 1107 and 1607 when appropriate
			-Quick Hunting mode tweaked so that it works when your in a group, or in a room that isn't mapped
			-added inverse command checks, put a ! in front of the command check, i.e kill(!h60)
			-Doesn't count escorts anymore for NPC checks
		v3.42 (2016-06-30)
			-Fix for mob command check due to recent change
			-Optimized the escort npc check
		v3.44 (2016-07-01)
			-Added a check for spell 608 to skip if already hidden
			-Added hidden and !hidden a command check, hidden only works when your hiding, !hidden when your not hiding
		v3.45 (2016-07-09)
			-better code for checking for an escort, less error prone now (:
			-UAC Bless option changed so that you can leave it blank and it wont stop hunting. Has tooltip explaining different options.
		v3.46 (2016-07-19)
			-Rewrote the bless option to bless anything that runs out of a bless.
			 Now located on Attacking Tab as a checkbox
			 Returns you to your resting area if you can't bless things.
			-Added a priority targeting option to hunting tab.
			 Will switch target based on the order of your valid targets, whenever its attacking.
			-Added Quickhunt targets, These always are first in terms of priority (Quickhunt targets, room targets)
			 You can use the (a)|(b)|(etc) in here instead of just the Quickhunt routine every time.
		v3.47 (2016-07-19)
			-fix for blessing weapons
		v3.48 (2016-07-20)
			-Added Consecrate(1604) to bless routine
			-Quickhunt targets code update and fixes
			-Made bless work with identical weapons
		v3.49 (2016-07-24)
			-Updated berserk to use Spell.cast functionality, should now use STOP BERSERK when no alive mobs in the room.
			-Command check added for poison and disease
			-Fixed some options that were out of place, oops
			-Tail should now use scripts when performing pre-hunt commands
			-Head should wait for tails to be out of RT before heading to rest now
			-Incant should no longer fry your nerves when you dont have enough mana.
			-Changed incant to use wands when you dont have enough mana.
			 Also checks your target before incanting, so you always target the correct creature
			-Changed wand routine to be able to use multiple wand types, "use this wand type" now takes comma seperated wands
			 "use this wand type" example: "aquamarine wand, bloodwood wand, etc"
			-Changed incant, spell and wand routines to return to attack stance option instead of stance defensive.
			-Fixed bug with bless routine, maybe
			-Option to use Voln SMITE in UAC routine now, instead of always doing it.
		v3.50 (2016-07-24)
			-Untargetable and Targetable lists now use the name instead of noun.
			 Option to clear these so they can start fresh using ;bigshot reset. This will fix the issue for being unable to target guards in warcamps.
			-Targetable and Untargetable are now listed in ;bigshot display
			-Fix for Head/Tail Routine. Head wasn't waiting for the tail members to join bigshot group.
		v3.51 (2016-07-25)
			-Special coding for 1700. Wont stance offensive for "incant 1700", Will stance offensive for "incant 1700 evoke"
			-Fix for ;Bigshot quick not working when your quickhunt targets was empty
		v3.52 (2016-07-27)
			-Changed variable tracking to be downstream hook instead of exec script
			 Please let me know if anything doesn't work like it did in the previous versions
			-Tracking added for Corrupt Essence (703), will no longer repeatedly cast and waste that precious mana
			 You can also cast it open as "incant 703 open"
			-Added flee from vines option to first tab of ;bigshot setup
		v3.53 (2016-07-29)
			-Incant should now work for any incant combination
			-Bless can now bless two weapons that lose bless in same attack
		v3.54 (2016-07-30)
			-REIM! Quick update for some support for reim creatures
			-Smite tracks individual mobs now, So if you switch creatures before killing it, will smite the new one
			-Fixed the lag issue
		v3.55 (2016-07-31)
			-Target tracking for Aura of the Arkati (1614). Wont cast again on something that is affected.
			-More Reim creatures added, Still missing creatures from the gypsy camp probably, celestial types
			-New Command check: noncorporeal - Will see if current creature is non-corporeal undead
			-New Command check: pcs - Will check for other non-grouped players in the room
		v3.56 (2016-08-02)
			-Think I have all the Reim mobs handled
			-Fix for Multi-account hunting...oops
			-other minor tweaks
			
		To do:
			Haste (506) routine - http://forum.gsplayers.com/showthread.php?51794-Bigshot-The-New-Optimus-Prime&p=1876474#post1876474
			Add more messaging for ambush checks (snipe, etc.)
			Add Stun Relief (108)|Undisease (113)|Unpoison (114) option for stunned group members
=end

unless Script.exists?('GameObjAdd')
	while !Script.exists?('GameObjAdd')
		do_client(";repository download GameObjAdd")
		wait_while { running?('repository') }
	end
	do_client(";autostart add --global GameObjAdd")
	wait_while { running?('autostart') }
	pause 0.5
	do_client(";autostart add --global repository download-updates")
	wait_while { running?('autostart') }
	pause 0.5
	do_client(";repository set-updatable GameObjAdd")
	wait_while { running?('repository') }
	pause 0.5
	do_client(";GameObjAdd")
	wait_while { running?('GameObjAdd') }
	pause 0.5
end


$bigshot_debug = false
$current_script_name = script.name
 
if $SAFE > 0
        echo "error: This script needs to be trusted to work. (;trust #{script.name})"
        exit
end

require 'drb'

BIGSHOT_VERSION = '2.0'
RALLY_TIME = 1
REST_INTERVAL = 30
$bigshot_quick = false
$rest_reason = nil
$not_hunting_reason = nil
$bigshot_status = nil
$bigshot_should_rest = false
$bigshot_aim = 0
$bigshot_ambush = 0
$bigshot_archery_aim = 0
$bigshot_archery_stuck_location = []
$bigshot_archery_location = nil
$bigshot_wand = 0
$bigshot_unarmed_tier = 1
$bigshot_unarmed_followup = false
$bigshot_unarmed_followup_attack = ""
$bigshot_flee = false
$bigshot_bless=[]
$bigshot_smite_list=[]
$companion ||= nil
$familiar = ""
$bigshot_adrenal_surge = Time.now + 301
$grouplist=[]
$bigshot_703_list=[]
$bigshot_1614_list=[]
 
def spam
    def waitcastrt?
        return if Spell[515].active?
        if (XMLData.cast_roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f) > 0
            sleep((XMLData.cast_roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f).abs)
        end
    end
 
    def waitrt?
        if (XMLData.roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f) > 0
            sleep((XMLData.roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f).abs)
        end
    end
end
 
def unspam
    def waitcastrt?
        if (XMLData.cast_roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f) > 0
            sleep((XMLData.cast_roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f + "0.6".to_f).abs)
        end
    end
 
    def waitrt?
        if (XMLData.roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f) > 0
            sleep((XMLData.roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f + "0.6".to_f).abs)
        end
    end
end

bigshot_monitor = proc { |server_string|
	if server_string =~ /<a exist=".*" noun="(.*)">.*<\/a> leaps from hiding to attack!/i
		temp = $1
		if !$grouplist.any?{|s| s =~ /#{temp}/i}
			$ambusher_here = true
		end
	elsif server_string =~ /flies out of the shadows toward/i
		if server_string =~ /flies out of the shadows toward you/i
		elsif $grouplist.size == 0
			$ambusher_here = true
		end
	elsif server_string =~ /obvious signs of someone hiding/i
		$obvious_hiding_player = true
	elsif server_string =~ /crimson mist.*?surround.*?<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?(?:corporeal plane!|vulnerable!)/i
		$bigshot_smite_list.push($1)
	elsif server_string =~ /crimson mist.*?<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?(?:returns to an ethereal state.|appears less vulnerable.)/i
		$bigshot_smite_list.delete($1)
	elsif server_string =~ /<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?is suddenly surrounded by a blood red haze./i
		$bigshot_703_list.push($1)
	elsif server_string =~ /The blood red haze dissipates from around.*?<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?\./i
		$bigshot_703_list.delete($1)
	elsif server_string =~ /<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?(?:visibly struggling against|in awe of) your radiant aura!/i
		$bigshot_1614_list.push($1)
	elsif server_string =~ /<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?recovers from being rebuked/i
		$bigshot_1614_list.delete($1)
	elsif server_string =~ /The.*sticks in.*\'s (.*)\!/i
		$bigshot_archery_stuck_location.push($1)
	elsif server_string =~ /You're now aiming at the (.*) of/i
		$bigshot_archery_location = $1
	elsif server_string =~ /You're now no longer aiming at anything in particular/i
		$bigshot_archery_location = nil
	elsif server_string =~ /but your attack has no effect!/i
		$bigshot_should_rest = true
		$rest_reason = "No blessing on weapon"
	elsif server_string =~ /Your <a exist="(.*?)" noun=".*?">.*?<\/a> returns to normal\./i
		$bigshot_bless.push($1)
	elsif server_string =~ /^You bolt/i
		$ambusher_here = false
		$bigshot_smite_list = []
		$bigshot_aim = 0
		$bigshot_ambush = 0
		$bigshot_archery_aim = 0
		$bigshot_archery_stuck_location = []
		$bigshot_unarmed_tier = 1
		$bigshot_unarmed_followup = false
		$bigshot_unarmed_followup_attack = ""
		$bigshot_703_list = []
		$bigshot_1614_list = []
		$bigshot_flee = false
	elsif server_string =~ /#{UserVars.op["flee_message"]}/i && UserVars.op["flee_message"] != ""
		$bigshot_flee = true
	end
	server_string
}
DownstreamHook.remove("#{script.name}_monitor")
DownstreamHook.add("#{script.name}_monitor", bigshot_monitor)
before_dying { DownstreamHook.remove("#{script.name}_monitor") }
before_dying { unspam() }
#before_dying { $bigshot.gather_ammo }

class Event
    attr_accessor :type, :created_at, :room_id
    @@RECOGNIZED = [ :HUNTING_PREP_COMMANDS, :HUNTING_SCRIPTS_START, :CAST_SIGNS, :ATTACK, :PREP_REST, 
        :HUNTING_SCRIPTS_STOP, :RESTING_SCRIPTS_START, :RESTING_PREP_COMMANDS, :DISPLAY_WATCH ]
 
    def initialize( type, time_stamp, room_id )
        raise "Event type not recognized" unless @@RECOGNIZED.include?(type)
        @type       = type
        @created_at = time_stamp
        @room_id    = room_id
    end
 
    def stale?
        if( Room.current.id != @room_id || Time.now.to_i - @created_at > 15 )
            return true
        else
            return false
        end
    end
 
    def type
        return @type
    end
end
 
class Group
    include DRbUndumped
    attr_accessor :leader, :members
 
    def initialize()
        @members = Hash.new
    end
 
    def set_leader(leader)
        @leader = leader
    end
 
    def add_member(member)
        @members[member.name()] = member
    end
 
    def size()
        return @members.size
    end
 
    def get_names
        return @members.keys + [@leader.name]
    end
 
    def room_id()
        return @leader.room_id()
    end
 
    def add_event(type)
        @members.each_pair { |k,v|
            begin
                v.add_event( type, Time.now.to_i, Room.current.id )
            rescue
                @leader.message("Error adding #{type.to_s} event to members stack: #{$!}")
                @leader.message($!.backtrace.join("\n"))
            end
        }
    end
 
    def add_leader_event(event)
        @leader.add_event( Event.new(event) ) unless @leader.event_stack.size > 5
    end
 
    def roundtime?()
        @members.each_pair { |k,v|
            begin
                return true if v.rt? > 0
            rescue
                @leader.message("Error polling member for RT. Removing!")
                @members.delete(k)
            end
        }
        return false
    end
 
    def should_hunt?()
        emergency = @leader.event_stack.size == 0 ? nil : @leader.event_stack.shift
        if(emergency)
            @leader.clear_events
            return false
        end
 
        @members.each_pair { |k,v|
            begin
                return false if !v.should_hunt?
            rescue
                @leader.message("Error polling member. Removing!")
                @members.delete(k)
            end
        }
                $bigshot_status = :hunting
        return true
    end
 
    def should_rest?()
        @members.each_pair { |k,v|
            begin
                return false if !v.should_rest?
            rescue
                @leader.message("Error polling member. Removing!")
                @members.delete(k)
            end
        }
        return true
    end
   
    def emergency_rest?()
        @members.each_pair { |k,v|
            begin
                return true if v.wounded?
            rescue
                @leader.message("Error polling member. Removing!")
                @members.delete(k)
            end
        }
        return false
    end
end
 
class Bigshot
    include DRbUndumped
    attr_accessor :BIRTH_TIME, :START_TIME, :STORED_TIMES, :FRIED, :OOM,
        :SIGNS, :TARGETS, :INVALID_TARGETS, :FLEE_COUNT, :ALWAYS_FLEE_FROM,
        :USE_WRACKING, :AMMO, :AMMO_CONTAINER, :HIDE_FOR_AMMO,
        :REST_TILL_EXP, :REST_TILL_MANA, :USE_HERBS, :DEAD_MAN_SWITCH,
        :RESTING_ROOM_ID, :RESTING_COMMANDS, :RESTING_SCRIPTS, :HUNTING_ROOM_ID,
        :HUNTING_BOUNDARIES, :HUNTING_SCRIPTS, :HUNTING_COMMANDS,
        :DISABLE_COMMANDS, :HUNTING_STANCE, :HUNTING_PREP_COMMANDS,
        :MONITOR_INTERACTION, :FLEE_CLOUDS, :FLEE_VINES, :WRACKING_SPIRIT,
        :REST_TILL_SPIRIT, :BOUNTY_MODE, :AMBUSH, :ARCHERY_AIM,
        :event_stack, :followers, :BLESS, :AIM, :TIER3, 
		:MSTRIKE_COOLDOWN, :MSTRIKE_STAMINA_COOLDOWN, :MSTRIKE_MOB, 
		:MSTRIKE_QUICKSTRIKE, :MSTRIKE_STAMINA_QUICKSTRIKE,
		:UAC_MSTRIKE, :WANDER_WAIT, :QUICK_COMMANDS, :PRIORITY,
		:QUICKHUNT_TARGETS, :UAC_SMITE, :FOG_RETURN
 
    PRONE = /sleeping|webbed|stunned|kneeling|sitting|^lying|prone|frozen|held in place/
 
    def add_event( type, time_stamp, room_id )
		echo "add_event" if $bigshot_debug
        unless( @event_stack.size > 5 && type == :ATTACK )
            @event_stack.push( Event.new( type, time_stamp, room_id ) )
        end
    end
 
    def grab_event()
		echo "grab_event" if $bigshot_debug
        @event_stack.shift()
    end
 
    def clear_events()
		echo "clear_events" if $bigshot_debug
        @event_stack.clear
    end
 
    def initialize(bounty_mode=nil)
		echo "initialize" if $bigshot_debug
        $bigshot = self
        if bounty_mode
            @BOUNTY_MODE = true
        end
               
        UserVars.op ||= Hash.new
        CharSettings['targetable']   ||= Array.new
        CharSettings['untargetable'] ||= Array.new
        @BIRTH_TIME   = Time.now.to_i
        @START_TIME   = 1
        @STORED_TIMES = Array.new
 
        @followers = nil
        @event_stack = Array.new
 
        load_settings()
        dead_man_switch()
 
        # this is mainly for azbounty:
        before_dying {
	
			#HACK - 11/1/2020 - Waits for hurled weapon.
			if Char.prof == /Warrior/
				if $weapon_lost == true
					wait_while {$weapon_lost == true}
				elsif $weapon_lost == false
					nil
				end
			end

            @HUNTING_SCRIPTS.each { |i|
                echo "Cleaning up hunting scripts: #{i}."
                stop_script(i) if running?(i)
            }
        }
               
    end
       
    def load_settings()
        set_value_required( 'hunting_commands',     'split_xx' )
        set_value_required( 'fried',                'to_i'     )
        set_value_required( 'oom',                  'to_i'     )
        set_value_required( 'rest_till_mana',       'to_i'     )
        set_value_required( 'rest_till_exp',        'to_i'     )
 
        set_value( 'hunting_room_id',      'to_i',  4 )
        set_value( 'resting_room_id',      'to_i',  4 )
        set_value( 'hunting_boundaries',   'split',    Array.new )
        set_value( 'hunting_commands_b',   'split_xx', Array.new )
        set_value( 'hunting_commands_c',   'split_xx', Array.new )
		set_value( 'hunting_commands_d',   'split_xx', Array.new )
		set_value( 'hunting_commands_e',   'split_xx', Array.new )
		set_value( 'hunting_commands_f',   'split_xx', Array.new )
		set_value( 'hunting_commands_g',   'split_xx', Array.new )
		set_value( 'hunting_commands_h',   'split_xx', Array.new )
		set_value( 'hunting_commands_i',   'split_xx', Array.new )
		set_value( 'hunting_commands_j',   'split_xx', Array.new )
        set_value( 'disable_commands',     'split_xx', Array.new )
		set_value( 'quick_commands',       'split_xx', Array.new )
               
        set_value( 'targets',          'targets',         nil       )
		set_value( 'quickhunt_targets','targets',         nil       )
        set_value( 'dead_man_switch',     '',             false     )
        set_value( 'monitor_interaction', '',             false     )
        set_value( 'depart_switch',       '',             false     )
        set_value( 'encumbered',       'to_i',            200       )
        set_value( 'signs',            'split',           Array.new )
        set_value( 'spam',             '',                true      )
        set_value( 'flee_count',       'to_i',            10        )
        set_value( 'wracking_spirit',  'to_i',            0         )
        set_value( 'invalid_targets',  'split',           Array.new )
        set_value( 'always_flee_from', 'split',           Array.new )
		set_value( 'flee_message',     '',                nil       )
        set_value( 'flee_clouds',      '',                false     )
		set_value( 'flee_vines',       '',                false     )
        set_value( 'use_wracking',     '',                false     )
        set_value( 'lone_targets_only', '',               false     )
        set_value( 'rest_till_spirit', 'to_i',            0         )
        set_value( 'ammo',             '',                nil       )
        set_value( 'ammo_container',   '',                nil       )
        set_value( 'fresh_wand_container',   '',          nil       )
        set_value( 'dead_wand_container',    '',          nil       )
        set_value( 'wand',             'split',           nil       )
        set_value( 'wand_if_oom',            '',          false     )
        set_value( 'hide_for_ammo',    '',                nil       )
        set_value( 'wounded_eval',     '',                nil       )
        set_value( 'resting_scripts',  'split',           Array.new )
        set_value( 'hunting_scripts',  'split',           Array.new )
        set_value( 'loot_script',      '',                nil       )
        set_value( 'hunting_stance',   '',               'defensive')
        set_value( 'resting_commands',   'split_xx',      Array.new )
        set_value( 'hunting_prep_commands','split_xx',    Array.new )
		set_value( 'mstrike_mob',       'to_i',           2         )
		set_value( 'mstrike_cooldown',  '',				  nil   	)
		set_value( 'mstrike_stamina_cooldown','to_i',	  maxstamina)
		set_value( 'mstrike_quickstrike','',              nil       )
		set_value( 'mstrike_stamina_quickstrike','to_i',  maxstamina)
		set_value( 'aim',				'split',		  Array.new )
		set_value( 'ambush',            'split',          Array.new )
		set_value( 'archery_aim',		'split',          Array.new )
		set_value( 'tier3',				'',			      'punch'   )
		set_value( 'bless',				'',			      nil       )
		set_value( 'uac_mstrike',       'to_i',           1         )
		set_value( 'uac_smite',         '',               false     )
		set_value( 'wander_wait',		'to_f',			  0.3		)
		set_value( 'priority',          '',               false     )
		set_value( 'fog_return',        '',               false     )
    end
 
    def clean_value( clean, value )
        if( clean == 'to_i' )
            return value.to_i
		elsif ( clean == 'to_f' )
			return value.to_f
        elsif( clean == 'split' )
            return value.split(/,\s*/)
        elsif( clean == 'split_xx' )
            cleaned = Array.new
            value.split(/,\s*/).each { |i|
                rep = 1
                cmd = ''
                if( i =~ /(.*)\(x(\d+)\)$/i )
                    rep = $2.to_i
                    cmd = $1
                elsif( i =~ /(.*)\(xx\)/i )
                    rep = 5
                    cmd = $1
                else
                    cmd = i
                end
                and_tokens = cmd.split(/\sand\s/)
                cmd = and_tokens.size == 1 ? and_tokens[0] : and_tokens
                rep.times do cleaned.push(cmd) end
            }
            return cleaned
        elsif( clean == 'targets' )
            targets = Hash.new
            tokens = value.split(/,/)
            tokens.each do |i|
                if( i =~ /(.*)\(([a|b|c|d|e|f|g|h|i|j|A|B|C|D|E|F|G|H|I|J])\)/ )
                    targets[$1.downcase.strip] = $2.downcase.strip
                else
                    targets[i.downcase.strip] = 'a'
                end
            end
            return targets
        else
            return value
        end
    end
 
    def set_value( key, clean, default )
        if( !UserVars.op[key].nil? && UserVars.op[key] !~ /^\s*$/ )
            cleaned = clean_value( clean, UserVars.op[key] )
            instance_variable_set( "@#{key.upcase}", cleaned )
        else
            instance_variable_set( "@#{key.upcase}", default )
        end
    end
 
    def set_value_required( key, clean )
        if( !UserVars.op[key].nil? && UserVars.op[key] !~ /^\s*$/ )
            set_value( key, clean, nil )
        else
            message("ERROR: Missing required setting: #{key}")
            message("(fried? is percenthealth and oom is percentmana)")
            Script.self.kill
        end
    end
 
	#HACK
	def manacheck
		respond "Checking mana status"
		target = GameObj.npcs.find{ |npc| npc.name =~ /adept|herald|initiate|scout|seer/ }
		if checkmana > 16
			echo "You have enough mana to cast Mana Leech."
			current_knockdown_routine = nil
			list_of_targets = /seer|adept/
			routine = [516]
			if target.name =~ list_of_targets and Spell[9516].timeleft < 15 and (percentmana < 70)
				current_knockdown_routine = routine
				unless target.status =~ /dead|gone/
					current_knockdown_routine.each { |i|
					waitrt?
					waitcastrt?
					Spell[i].cast
				}
				end
			end
		elsif checkstamina (50)
			echo "You have enough stamina to use Sigil of Power."
			fput "sigil of power"
		else
			$bigshot_should_rest = true
			$rest_reason = "out of mana"
			kill_script "explorer"
			return
		end
	end
 
    def cmd( command, npc = nil, stance_dance = true )
		echo "cmd" if $bigshot_debug
		#GameObj.pcs.each {|s| if s.status =~ /kneeling|sitting|^lying|prone/;fput "pull #{s.noun}";end;}
        command = command.dup
		
        if( command.class.to_s == 'Array' )
            stance_dance = false if command.any? { |j| j =~ /stance/ }
            command.each do |i|
                break if npc.status =~ /dead/ || !GameObj.npcs.any? {|s| s.id == npc.id}
                echo i if $bigshot_debug
                cmd( i, npc, stance_dance )
            end
            return
        end
		
        # check mana/stamina/health(percentage)/encumbrance/unarmed tiering/mobs in room/target not prone/target undead
		# ! means the inverse/opposite effect
        if( command =~ /(.*)\((.*?(?:s|!s|m|!m|h|!h|e|!e|tier|!tier|mob|!mob|prone|!prone|undead|!undead|hidden|!hidden|poison|!poison|disease|!disease|noncorporeal|!noncorporeal|pcs|!pcs).*?)\)$/i )
			command = $1
			commandcheckreturn = false
			$2.split(" ").each{|s|
				if s =~ /((?:s|!s|m|!m|h|!h|e|!e|tier|!tier|mob|!mob))(\d+)/i
					if( $1 == 's' )
						commandcheckreturn = true if !checkstamina($2.to_i)
					elsif( $1 == '!s' )
						commandcheckreturn = true if checkstamina($2.to_i)
					elsif( $1 == 'm' )
						commandcheckreturn = true if !checkmana($2.to_i)
					elsif( $1 == '!m' )
						commandcheckreturn = true if checkmana($2.to_i)
					elsif( $1 == 'h' )
						commandcheckreturn = true if !percenthealth($2.to_i)
					elsif( $1 == '!h' )
						commandcheckreturn = true if percenthealth($2.to_i)
					elsif( $1 == 'e' )
						commandcheckreturn = true if !checkencumbrance($2.to_i)
					elsif( $1 == '!e' )
						commandcheckreturn = true if checkencumbrance($2.to_i)
					elsif( $1 == 'tier' )
						commandcheckreturn = true if $bigshot_unarmed_tier < $2.to_i
					elsif( $1 == '!tier' )
						commandcheckreturn = true if $bigshot_unarmed_tier > $2.to_i
					elsif ( $1 == 'mob' )
						mobcheck = $2
						commandcheckreturn = true if GameObjNpcCheck() < mobcheck.to_i
					elsif ( $1 == '!mob' )
						mobcheck = $2
						commandcheckreturn = true if GameObjNpcCheck() > mobcheck.to_i
					end
				elsif s =~ /((?:prone|!prone|undead|!undead|hidden|!hidden|poison|!poison|disease|!disease|noncorporeal|!noncorporeal|pcs|!pcs))/i
					if( $1 == 'prone' )
						commandcheckreturn = true if npc.status =~ PRONE
					elsif( $1 == '!prone' )
						commandcheckreturn = true if npc.status !~ PRONE
					elsif( $1 == 'undead' )
						commandcheckreturn = true if !npc.type.split(',').any?{|a| a == "undead"}
					elsif( $1 == '!undead' )
						commandcheckreturn = true if npc.type.split(',').any?{|a| a == "undead"}
					elsif( $1 == 'hidden' )
						commandcheckreturn = true if !hiding?
					elsif( $1 == '!hidden' )
						commandcheckreturn = true if hiding?
					elsif( $1 == 'poison' )
						commandcheckreturn = true if !checkpoison?
					elsif( $1 == '!poison' )
						commandcheckreturn = true if checkpoison?
					elsif( $1 == 'disease' )
						commandcheckreturn = true if !checkdisease?
					elsif( $1 == '!disease' )
						commandcheckreturn = true if checkdisease?
					elsif( $1 == 'noncorporeal' )
						commandcheckreturn = true if !npc.type.split(',').any?{|a| a == "noncorporeal"}
					elsif( $1 == '!noncorporeal' )
						commandcheckreturn = true if npc.type.split(',').any?{|a| a == "noncorporeal"}
					elsif( $1 == 'pcs' )
						commandcheckreturn = true if !((checkpcs - $grouplist).count > 0)
					elsif( $1 == '!pcs' )
						commandcheckreturn = true if ((checkpcs - $grouplist).count > 0)
					end
				end
			}
			return if commandcheckreturn
        end
		
        if( command =~ /force\s+(.*)\s+(?:till|until)\s+(\d+)/i )
            cmd_force( $1, $2.to_i, npc )
            return
        end
       
        # sub id
        command.gsub!( /target/, "##{npc.id}" ) if !npc.nil?
       
		# Soothe routine
		if Spell[1205].known? && Spell[1205].affordable?
			if (Spell[201].active? || Spell[216].active? || Spell[1015].active? || Spell[1016].active? || Spell[1108].active? || Spell[1120].active?)
				waitrt?
				waitcastrt?
				Spell[1205].cast
			end
		end
		
		cmd_bless() if @BLESS && $bigshot_bless.count > 0
		
        # waitrt/waitcastrt
        unless( command =~ /^nudgeweapons?/ )
            waitrt?
            waitcastrt? if command =~ /^\d+|incant/
        end
		
        # change_stance
        stand() if !standing?
        unless( command =~ /^(?:\d+|wait|sleep|wand|berserk|script|hide|nudgeweapon)/ )
            change_stance(@HUNTING_STANCE) if stance_dance
        end
 
        return if (npc && !valid_target?(npc)) or npc.status =~ /dead/
		return if @PRIORITY && !priority(npc)
 
 		if ( command =~ /^(haste|506)\s+(.*)/i )
			command = $2
			if Spell[506].known? and Spell[506].affordable?
				if (Spell[506].active? and Spell[506].timeleft <= 0.1) || (!Spell[506].active?)
					Spell[506].cast
				end
			end
		end
 
        if( command =~ /^(incant)?\s?(\d+)\s?((?:open|closed)?\s?(?:cast|channel|evoke)?\s?(?:cast|channel|evoke)?\s?(?:open|closed)?\s?(?:air|earth|fire|lightning|water)?)?.*$/i )
            cmd_spell( $1, $2.to_i, $3, npc )
#WIZARD CUSTOM ATTACKS
		elsif( command =~ /^abolish/i )
			cmd_abolish( command, npc )
		elsif( command =~ /^bolt/i )
			cmd_bolt( command, npc )
		elsif( command =~ /^cone/i )
			cmd_cone( command, npc )
		elsif( command =~ /^firebolt/i )
			cmd_firebolt( command, npc )
		elsif( command =~ /^fury/i )
			cmd_fury( npc )
		elsif( command =~ /^hasteattack/i )
			cmd_hasteattack( command, npc )
		elsif( command =~ /^leech/i )
			cmd_leech( command, npc )
		elsif( command =~ /^waterbolt/i )
			cmd_waterbolt( command, npc )
#KNOCKDOWN CUSTOM ATTACKS
		elsif( command =~ /^ewave/i )
			cmd_ewave( command, npc )
		elsif( command =~ /^grasp/i )
			cmd_grasp()
		elsif( command =~ /^stomp/i )
			cmd_stomp()
#SORCERER CUSTOM ATTACKS
		elsif( command =~ /^dc/i )
			cmd_dc( command, npc )
		elsif( command =~ /^pain/i )
			cmd_pain( command, npc )			
#RANGER CUSTOM ATTACKS
		elsif( command =~ /^ebow/i )
            cmd_ebow( npc )
		elsif( command =~ /^spike/i )
			cmd_spike( command, npc )
		elsif( command =~ /^weedmage/i )
			cmd_weedmage( command, npc )
#BARD CUSTOM ATTACKS
		elsif( command =~ /^disrupt/i )
			cmd_disrupt( command, npc )
#WARRIOR CUSTOM ATTACKS
        elsif( command =~ /^dattack/i )
            cmd_dattack( command, npc )
        elsif( command =~ /^dhurl/i )
            cmd_dhurl( command, npc )
		#Defaults
		elsif( command =~ /^throw/i )
			cmd_throw( npc )
		elsif( command =~ /^k?weed/i )
			cmd_weed( command, npc )
        elsif( command =~ /^wand\s+(.*)/i )
            cmd_wand(npc)
        elsif( command =~ /^hide/i )
            cmd_hide()
        elsif( command =~ /^mstrike/i )
            cmd_mstrike( command, npc )
        elsif( command =~ /^fire/i )
            cmd_ranged(npc)
        elsif( command =~ /^berserk/i )
            cmd_berserk()
        elsif( command =~ /^script\s+(.*?)(\s|$)(.*)/i )
            cmd_run_script( $1, $3 )
        elsif( command =~ /^sleep\s+(\d+)/i )
            cmd_sleep( $1, npc )
        elsif( command =~ /^stance\s+(.*)/i )
            change_stance($1)
        elsif( command =~ /^wait\s+(\d+)/i )
            wait_for_swing( $1.to_i, npc )
            $stop_wait = true
        elsif( command =~ /^nudgeweapons?\s*/i )
            cmd_nudge_weapons
        elsif( command =~ /^ambush\s?(.*)?/i )
            cmd_ambush( $1, npc )
		elsif( command =~ /^unarmed\s+(.*)/i )
			unarmed( $1, npc )
		elsif( command =~ /^smite/i )
			volnsmite( npc )
        else
            return if $ambusher_here
            echo "inside cmd: #{command}" if $hunt_debug
            bs_put command
        end
    end

#WIZARD CUSTOM ATTACKS:

	def cmd_smarthunt( command, target )
		return if target.status =~ /dead|gone/ || !GameObj.npcs.any? {|s| s.id == target.id}
		#Step #1 - Determine how many creatures are in the room. 
		# - Disable if > 2
		# - Bolt or Attack based upon which creature it is.
		if GameObj.npcs.count > 2
			if GameObj.npcs.find { |npc| npc.name =~ /adept|champion/ }
				cmd_stomp
			end
		end
		if target.name =~ /seer/
			cmd_leech
			cmd_hasteattack
		elsif target.name =~ /griffin/
			cmd_bolt
		elsif target.name =~ /champion/
			cmd_stomp
			cmd_hasteattack
		elsif target.name =~ /adept/
			cmd_stomp
			cmd_hasteattack
		elsif target.name =~ /construct/
			cmd_hasteattack
		elsif target.name =~ /scout/
			cmd_hasteattack
		end
	end

	def cmd_abolish( command, target )
		return if target.status =~ /dead|gone/ || !GameObj.npcs.any? {|s| s.id == target.id}
		#fput "target ##{target.id}"
			if Spell[530].known? and Spell[530].affordable?
				waitrt?
				waitcastrt?
				Spell[530].cast("##{target.id}")
			else
				manacheck
#				if checkmana > 16
#					current_knockdown_routine = nil
#					list_of_targets = /seer|adept/
#					routine = [516]
#					if target.name =~ list_of_targets and Spell[9516].timeleft < 15 and (percentmana < 70)
#						current_knockdown_routine = routine
#						unless target.status =~ /dead|gone/
#							current_knockdown_routine.each { |i|
#							waitrt?
#							waitcastrt?
#							Spell[i].cast
#						}
#						end
#					end
#				else
#					$bigshot_should_rest = true
#					$rest_reason = "out of mana"
#					kill_script "explorer"
#					return
#				end
			end
	end

	def cmd_bolt( command, target )
		return if target.status =~ /dead|gone/ || !GameObj.npcs.any? {|s| s.id == target.id}
		#fput "target ##{target.id}"
			if GameObj.loot.find { |loot| loot.name =~ /muck/ }
				if Spell[510].known? and Spell[510].affordable?
					waitcastrt?
					Spell[510].cast("##{target.id}")
				elsif(!Spell[510].affordable?)
					manacheck
#					if checkmana > 16
#						current_knockdown_routine = nil
#						list_of_targets_a = /seer|adept/
#						routine_a = [516]
#						if target.name =~ list_of_targets_a and Spell[9516].timeleft < 15 and (percentmana < 70)
#							current_knockdown_routine = routine_a
#							unless target.status =~ /dead|gone/
#								current_knockdown_routine.each { |i|
#								waitrt?
#								waitcastrt?
#								Spell[i].cast
#							}
#							end
#						end
#					else
#						$bigshot_should_rest = true
#						$rest_reason = "out of mana"
#						kill_script "explorer"
#						return
#					end
				end
			else 
				if Spell[910].known? and Spell[910].affordable?
					waitcastrt?
					Spell[910].cast("##{target.id}")
				elsif(!Spell[910].affordable?)
					manacheck
#					if checkmana > 16
#						current_knockdown_routine = nil
#						list_of_targets_a = /seer|adept/
#						routine_a = [516]
#						if target.name =~ list_of_targets_a and Spell[9516].timeleft < 15 and (percentmana < 70)
#							current_knockdown_routine = routine_a
#							unless target.status =~ /dead|gone/
#								current_knockdown_routine.each { |i|
#								waitrt?
#								waitcastrt?
#								Spell[i].cast
#							}
#							end
#						end
#					else
#						$bigshot_should_rest = true
#						$rest_reason = "out of mana"
#						kill_script "explorer"
#						return
#					end
				end
			end
	end

	def cmd_cone( command, target )
		return if target.status =~ /dead|gone/ || !GameObj.npcs.any? {|s| s.id == target.id}
		#fput "target ##{target.id}"
			if( GameObjNpcCheck() >= 2 || target.nil? )
				if Spell[518].known? and Spell[518].affordable?
					waitrt?
					waitcastrt?
					Spell[518].cast("##{target.id}")
				elsif(!Spell[518].affordable?)
					manacheck
#					if checkmana > 16
#						current_knockdown_routine = nil
#						list_of_targets_a = /seer|adept/
#						routine_a = [516]
#						if target.name =~ list_of_targets_a and Spell[9516].timeleft < 15 and (percentmana < 70)
#							current_knockdown_routine = routine_a
#							unless target.status =~ /dead|gone/
#								current_knockdown_routine.each { |i|
#								waitrt?
#								waitcastrt?
#								Spell[i].cast
#							}
#							end
#						end
#					else
#						$bigshot_should_rest = true
#						$rest_reason = "out of mana"
#						kill_script "explorer"
#						return
#					end
				end
			end
	end

	def cmd_firebolt( command, target )
		return if target.status =~ /dead|gone/ || !GameObj.npcs.any? {|s| s.id == target.id}
		#fput "target ##{target.id}"
			if Spell[906].known? and Spell[906].affordable?
				waitcastrt?
				Spell[906].cast("##{target.id}")
			else
				manacheck
#				$bigshot_should_rest = true
#				$rest_reason = "out of mana"
#				kill_script "explorer"
#				return
			end
	end

	def cmd_fury( target )
		return if target.status =~ /dead|gone/ || !GameObj.npcs.any? {|s| s.id == target.id}
		#fput "target ##{target.id}"
		if Spell[917].known? and Spell[917].affordable?
			waitrt?
			waitcastrt?
			Spell[917].cast("##{target.id}")
        elsif(!Spell[917].affordable?)
			manacheck
#			if checkmana > 16
#				current_knockdown_routine = nil
#				list_of_targets_a = /seer|adept/
#				routine_a = [516]
#				if target.name =~ list_of_targets_a and Spell[9516].timeleft < 15 and (percentmana < 70)
#					current_knockdown_routine = routine_a
#					unless target.status =~ /dead|gone/
#						current_knockdown_routine.each { |i|
#						waitrt?
#						waitcastrt?
#						Spell[i].cast
#					}
#					end
#				end
#			else
#				$bigshot_should_rest = true
#				$rest_reason = "out of mana"
#				kill_script "explorer"
#				return
#			end
		end
	end

	def cmd_hasteattack( command, target )
		return if target.status =~ /dead|gone/ || !GameObj.npcs.any? {|s| s.id == target.id}
			Spell[506].cast if Spell[506].affordable? unless Spell[506].active?
			waitrt?
			waitcastrt?
			change_stance('offensive')
			fput "attack ##{target.id}"
	end

	def cmd_leech( command, target )
		return if target.status =~ /dead|gone/ || !GameObj.npcs.any? {|s| s.id == target.id}
			current_knockdown_routine = nil
			list_of_targets_a = /seer|adept/
			routine_a = [516]
			if target.name =~ list_of_targets_a and Spell[9516].timeleft < 15 and (percentmana < 70)
				fput "target ##{target.id}"
				current_knockdown_routine = routine_a
				unless target.status =~ /dead|gone/
					current_knockdown_routine.each { |i|
					waitrt?
					waitcastrt?
					Spell[i].cast
				}
				end
			end
	end

	def cmd_waterbolt( command, target )
		return if target.status =~ /dead|gone/ || !GameObj.npcs.any? {|s| s.id == target.id}
		#fput "target ##{target.id}"
			if Spell[903].known? and Spell[903].affordable?
				waitcastrt?
				Spell[903].cast("##{target.id}")
			else
				manacheck
#				$bigshot_should_rest = true
#				$rest_reason = "out of mana"
#				kill_script "explorer"
#				return
			end
	end

#KNOCKDOWN CUSTOM ATTACKS

	def cmd_ewave( command, target )
		if GameOb.npcs.count > 2
		#return if target.status =~ /dead|gone/ || !GameObj.npcs.any? {|s| s.id == target.id}
		#fput "target ##{target.id}"
			if Spell[410].known? and Spell[410].affordable?
				waitcastrt?
				Spell[410].cast("##{target.id}")
			else
				manacheck
#				$bigshot_should_rest = true
#				$rest_reason = "out of mana"
#				kill_script "explorer"
#				return
			end
		end
	end

	def cmd_grasp()
		return if GameObj.npcs.find { |loot| loot.name =~ /arm/ }
		return if GameObj.npcs.find { |loot| loot.name =~ /arms/ }
			if Spell[709].known? and Spell[709].affordable?
				Spell[709].cast
			end
	end
    
	def cmd_stomp()
		#return if GameObj.npcs.find { |npc| npc.name =~ /construct/ }
			if Spell[909].active?
				waitrt?
				waitcastrt?
					fput "stomp" if checkmana(5)
			else
				if Spell[909].known? and Spell[909].affordable?
					waitrt?
					waitcastrt?
					fput "incant 909" if checkmana(9)
					waitrt?
					waitcastrt?
					fput "stomp" if checkmana(5)
				end
			end
		
	end


#SORCERER CUSTOM ATTACKS
	def cmd_dc( command, target )
		return if target.status =~ /dead|gone/ || !GameObj.npcs.any? {|s| s.id == target.id}
		fput "target ##{target.id}"
		if GameObj.loot.find { |loot| loot.name =~ /muck/ }
			if Spell[711].known? and Spell[711].affordable?
				waitcastrt?
				Spell[711].cast if Spell[711].affordable?
			elsif(!Spell[711].affordable?)
				if Spell[9918].known? and not Spell[9012].active? and checkspirit >= 8
					Spell[9918].cast
				else
					$bigshot_should_rest = true
					$rest_reason = "out of mana"
					kill_script "explorer"
					return
				end
			end
		else 
			if Spell[719].known? and Spell[719].affordable?
				waitcastrt?
				Spell[719].cast if Spell[719].affordable?
			elsif(!Spell[719].affordable?)
				if Spell[9918].known? and not Spell[9012].active? and checkspirit >= 8
					Spell[9918].cast
				else
					$bigshot_should_rest = true
					$rest_reason = "out of mana"
					kill_script "explorer"
					return
				end
			end
		end
	end

	def cmd_pain( command, target )
		return if target.status =~ /dead|gone/ || !GameObj.npcs.any? {|s| s.id == target.id}
		fput "target ##{target.id}"
		if Spell[711].known? and Spell[711].affordable?
			waitcastrt?
			Spell[711].cast if Spell[711].affordable?
		elsif(!Spell[711].affordable?)
			if Spell[9918].known? and not Spell[9012].active? and checkspirit >= 8
				Spell[9918].cast
			else
				$bigshot_should_rest = true
				$rest_reason = "out of mana"
				kill_script "explorer"
				return
			end
		end
	end

#RANGER CUSTOM ATTACKS

    def cmd_ebow(npc)
        waitrt?
		waitcastrt?
		result = dothistimeout("fire ##{npc.id}", 2, /You fire|You cannot|Could not find|seconds|Get what?/)
	end	

	def cmd_spike( command, target )
		return if target.status =~ /dead/ || !GameObj.npcs.any? {|s| s.id == target.id}
		fput "target ##{target.id}"
		if Spell[616].known? and Spell[616].affordable?
			return if target.name =~ /griffin/
			waitcastrt?
			fput "incant 616 ##{target.id}"
			waitcastrt?
        elsif(!Spell[616].affordable?)
			if Spell[9918].known? and not Spell[9012].active? and checkspirit >= 8
				Spell[9918].cast
			else
				$bigshot_should_rest = true
				$rest_reason = "out of mana"
				kill_script "explorer"
				return
			end
		end
	end

	def cmd_weedmage( command, target )
		return if target.status =~ /dead|gone/ || !GameObj.npcs.any? {|s| s.id == target.id}
		fput "target ##{target.id}"
		if( GameObjNpcCheck() >= 2 || target.nil? )			
			waitrt?
			waitcastrt?
			if Spell[635].known? and Spell[635].affordable?
				waitcastrt?
				Spell[635].cast
				waitcastrt?
			elsif(!Spell[635].affordable?)
				if Spell[9918].known? and not Spell[9012].active? and checkspirit >= 8
					Spell[9918].cast
				else
					$bigshot_should_rest = true
					$rest_reason = "out of mana"
					kill_script "explorer"
					return
				end
			end
		else
			if Spell[616].known? and Spell[616].affordable?
				waitcastrt?
				Spell[616].cast("##{target.id}")
				waitcastrt?
			elsif(!Spell[616].affordable?)
				if Spell[9918].known? and not Spell[9012].active? and checkspirit >= 8
					Spell[9918].cast
				else
					$bigshot_should_rest = true
					$rest_reason = "out of mana"
					kill_script "explorer"
					return
				end
			end
		end
	end

#BARD ATTACK METHODS

	def cmd_disrupt( command, target )
		return if target.status =~ /dead|gone/ || !GameObj.npcs.any? {|s| s.id == target.id}
		#fput "target ##{target.id}"
		if Spell[1030].known? and Spell[1030].affordable?
				waitcastrt?
				Spell[1030].cast("##{target.id}")
		elsif(!Spell[1030].affordable?)
			if Spell[9918].known? and not Spell[9012].active? and checkspirit >= 8
				Spell[9918].cast
			else
				$bigshot_should_rest = true
				$rest_reason = "out of mana"
				kill_script "explorer"
				return
			end
		end
	end

#WARRIOR ATTACK METHODS

    def cmd_dattack( command, target )
		return if target.status =~ /dead|gone/ || !GameObj.npcs.any? {|s| s.id == target.id}
		if !Spell[9005].active? and !Spell[9699].active?
			waitrt?
			fput "mstrike ##{target.id}"
		elsif checkstamina(70) and !Spell[9699].active?
			return if Spell[9699].active?
			fput "mstrike ##{target.id}"
		else
			waitrt?
			fput "attack ##{target.id}"
		end
    end
	
	def recover
		#A high steel harpoon rises out of the shadows and flies back to your waiting hand!
		#You know a high steel harpoon is around here somewhere, but you don't see it.
		#You spy a high steel harpoon and recover it.
		#A high steel harpoon rises out of the shadows and flies back to your waiting hand!
		loop {

			if $frontend == 'stormfront'
				fam_window_begin = "<pushStream id=\"death\" ifClosedStyle=\"watching\"/>"
				fam_window_end   = "<popStream/>\r\n"
			end

			waitrt?
			res = dothistimeout "recover hurl", 1, /You know (.*) is around here somewhere, but you don't see it.|You spy (.*) and recover it.|A (.*) rises out of the shadows and flies back to your waiting hand!|In order to recover your hurled weapon, you'll need to have a free hand./
			if res =~ /You know (.*) is around here somewhere, but you don't see it./
				$weapon_lost = true
			elsif res =~ /You spy (.*) and recover it.|A (.*) rises out of the shadows and flies back to your waiting hand!/
				$weapon_lost = false
				puts("#{fam_window_begin} *!* Recovered Weapon *!*\r\n #{fam_window_end}")
				break
			elsif res =~ /In order to recover your hurled weapon, you'll need to have a free hand./
				$weapon_lost = false
				puts("#{fam_window_begin} *!* Recovered Weapon *!*\r\n #{fam_window_end}")
				break
			end
			}
	end

	def cmd_dhurl( command, target)
		return if target.status =~ /dead|gone/ || !GameObj.npcs.any? {|s| s.id == target.id}

		if $frontend == 'stormfront'
			fam_window_begin = "<pushStream id=\"death\" ifClosedStyle=\"watching\"/>"
			fam_window_end   = "<popStream/>\r\n"
		end


		#You throw a high steel harpoon at a war griffin!
		res = dothistimeout "hurl ##{target.id}", 1, /^Roundtime|^What were you referring to\?$|^You throw|That's not going to do much.  Try using a weapon./
		if res =~ /You throw/
			puts("#{fam_window_begin} *!* HURLing at #{Room.current.id} *!*\r\n #{fam_window_end}")
			$weapon_lost = true
			$weapon_hurled_room = Room.current.id
			waitrt?
			recover
		elsif res =~ /^Roundtime/
		elsif res =~ /^What were you referring to\?$/
		elsif res =~ /That's not going to do much.  Try using a weapon./
			start_script ("go2"), [$weapon_hurled_room]
			wait_while { running?('go2') }
			recover
			return
		end
    end

#DEFAULT ATTACK METHODS

	def volnsmite(npc)
		echo "volnsmite" if $bigshot_debug
		while !$bigshot_smite_list.any?{|a| a.to_i == npc.id.to_i} && npc.status !~ /dead/ && GameObj.npcs.any? {|s| s.id == npc.id} && !should_flee? && (npc.type.split(',').any?{|a| a == "undead"} || npc.type.split(',').any?{|a| a == "noncorporeal"})
			res = dothistimeout "smite ##{npc.id}", 1, /^Roundtime|^What were you referring to\?$/
			if res =~ /^What were you referring to\?$/i
				break
			end
			sleep 1
		end
	end
	
	def unarmed( command , npc)
		echo "unarmed" if $bigshot_debug
		return if npc.status =~ /dead/ || !GameObj.npcs.any? {|s| s.id == npc.id}
		mstrike_taken = false
		volnsmite(npc) if !$bigshot_smite_list.any?{|a| a.to_i == npc.id.to_i} && npc.type.split(',').any?{|a| a == "noncorporeal"} && $bigshot_unarmed_tier == 3 && Spell[9821].known? && @UAC_SMITE
		mstrike_spell_check()
		if Skills.multiopponentcombat >= 5 && GameObj.npcs.all? { |i| i.noun !~ /nest/i }
			#9005 - Mstrike recovery
			#9699 - popped muscles
			if (!Spell[9005].active? || (@MSTRIKE_COOLDOWN && checkstamina >= @MSTRIKE_STAMINA_COOLDOWN))
				if (GameObjNpcCheck() >= @UAC_MSTRIKE)
					if (checkstamina >= @MSTRIKE_STAMINA_QUICKSTRIKE || GameObjNpcCheck() >= @UAC_MSTRIKE) && !Spell[9699].active?
						mstrike_taken = true
						if command =~ /jab/ && $bigshot_unarmed_tier == 3 && $bigshot_unarmed_followup == false
							cmd("mstrike #{@TIER3}", npc)
						elsif $bigshot_unarmed_followup == true
							cmd("mstrike #{$bigshot_unarmed_followup_attack}", npc)
						else
							cmd("mstrike #{command}", npc)
						end
					end
				end
			end
		end
		if mstrike_taken == false
			if command =~ /jab/ && $bigshot_unarmed_tier == 3 && $bigshot_unarmed_followup == false
				if !@AIM[$bigshot_aim].nil?
					cmd("#{@TIER3} ##{npc.id} #{@AIM[$bigshot_aim]}", npc)
				else
					cmd("#{@TIER3} ##{npc.id}", npc)
				end
			elsif $bigshot_unarmed_followup == true
				command = $bigshot_unarmed_followup_attack
				if !@AIM[$bigshot_aim].nil?
					cmd("#{$bigshot_unarmed_followup_attack} ##{npc.id} #{@AIM[$bigshot_aim]}", npc)
				else
					cmd("#{$bigshot_unarmed_followup_attack} ##{npc.id}", npc)
				end
			else
				if !@AIM[$bigshot_aim].nil?
					cmd("#{command} ##{npc.id} #{@AIM[$bigshot_aim]}", npc)
				else
					cmd("#{command} ##{npc.id}", npc)
				end
			end
		end
		timeNow = Time.now + 5
		while line = get
			if line =~ /You have (decent|good|excellent) positioning/
				tier = $1
				if tier =~ /decent/
					$bigshot_unarmed_tier = 1
				elsif tier =~ /good/
					$bigshot_unarmed_tier = 2
				elsif tier =~ /excellent/
					$bigshot_unarmed_tier = 3
				end
			elsif line =~ /.* = .* d100: .* = \-?(\d+)$/ && $bigshot_unarmed_followup == true
				endroll = $1
				if endroll.to_i > 100
					$bigshot_unarmed_followup = false
				end
			elsif line =~ /Strike leaves foe vulnerable to a followup (.*) attack!/
				$bigshot_unarmed_followup = true
				$bigshot_unarmed_followup_attack = $1
			elsif line =~ /You fail to find an opening for your strike\./
				$bigshot_aim += 1
			elsif line =~ /You cannot aim that high!|is already missing that!/
				$bigshot_aim += 1
				cmd("#{command} ##{npc.id} #{@AIM[$bigshot_aim]}", npc)
			elsif line =~ /does not have/
				$bigshot_aim += 10
				cmd("#{command} ##{npc.id} #{@AIM[$bigshot_aim]}", npc)
			elsif line =~ /Roundtime:/i
				$bigshot_aim = 0
				break
			elsif line =~ /^Try standing up first\.$|[wW]ait \d+ sec.*|You currently have no valid target\.  You will need to specify one\.|^It looks like somebody already did the job for you\.$|^What were you referring to\?$|Sorry,|You can't do that while entangled in a web|You are still stunned|from here\.  Perhaps you should try throwing or shooting something at it\./
				break
			elsif line =~ /You don't seem to be able to move to do that\./
				pause 2
				break
			elsif line =~ /You are unable to muster the will to attack anything\.|Your rage causes you to use all of your skill in an all out attack!/
				Spell[1205].cast if Spell[1205].known? && Spell[1205].affordable?
				break
			elsif npc.status =~ /dead/ || !GameObj.npcs.any? {|s| s.id == npc.id} || should_flee? || should_rest?
				break
			elsif timeNow < Time.now
				break
			end
		end
		mstrike_taken = false
	end
       
	def cmd_bless()
		echo "cmd_bless" if $bigshot_debug
		while $bigshot_bless.count > 0
			if Spell[1604].known? && Spell[1604].affordable?
				waitrt?
				waitcastrt?
				Spell[1604].cast("##{$bigshot_bless[$bigshot_bless.count-1]}")
			end
			if Spell[304].known? && Spell[304].affordable?
				waitrt?
				waitcastrt?
				Spell[304].cast("##{$bigshot_bless[$bigshot_bless.count-1]}")
				$bigshot_bless.delete($bigshot_bless[$bigshot_bless.count-1])
			elsif Spell[9802].known?
				waitrt?
				waitcastrt?
				fput "symbol bless ##{$bigshot_bless[$bigshot_bless.count-1]}"
				$bigshot_bless.delete($bigshot_bless[$bigshot_bless.count-1])
			else
				$bigshot_should_rest = true
				$rest_reason = "No blessing on weapon"
				$bigshot_bless = []
				return
			end
		end
	end
	   
	def cmd_throw( npc )
		echo "cmd_throw" if $bigshot_debug
		unless npc.status == 'lying down'
			empty_hands
			dothistimeout "throw ##{npc.id}", 1, /^You attempt to throw a .*\!$/
			waitrt?
			fill_hands
		end
	end
   
    def cmd_force( force_this, goal, npc )
		echo "cmd_force" if $bigshot_debug
        start = Time.now
        loop {
            cmd( force_this, npc )
            buffer = reget(20)
            buffer.each_with_index { |line, i|
                if( line =~ /^You.*(#{checknpcs.join('|')})(\.|!)|^You feint (high|low|(to the (left|right)))/ )
                    if (buffer[i + 1] && buffer[i + 1] =~ /== \+(\d+)/) || (buffer[i + 2] && buffer[i + 2] =~ /== \+(\d+)/)
                        return if $1.to_i >= goal # spell/swing
                    elsif (buffer[i - 1] && buffer[i - 1] =~ /^\[Roll result: (\d+)/) || (buffer[i - 2] && buffer[i - 2] =~ /^\[Roll result: (\d+)/)
                        return if $1.to_i >= goal # cman
                    elsif (buffer[i + 1] =~ /^As you focus on your magic, your vision swims with a swirling haze of crimson/) || (buffer[i + 2] =~ /^As you focus on your magic, your vision swims with a swirling haze of crimson/)
                        return
                    end
                elsif( line =~ /^You do not have enough stamina to attempt this maneuver\./ )
                    return
                elsif( line =~ /^Your magic fizzles ineffectually\./ )
                    return
                end
            }
            if ( force_this =~ /^(\d+) / && !Spell[$1.to_i].affordable? )
                message("Force ran out of mana. Giving up."); return;
            end
            return if GameObj.npcs.size.nil? || GameObjNpcCheck() == 0
            return if should_flee?
            return if should_rest?
            return if npc.status =~ /dead/ || !GameObj.npcs.any? {|s| s.id == npc.id}
            return if ( Time.now - start ) > 30
        }
    end
       
	def cmd_weed( command, target )
		echo "cmd_weed" if $bigshot_debug
		return if target.status =~ /dead/ || !GameObj.npcs.any? {|s| s.id == target.id}
		return if GameObj.loot.find { |loot| loot.name =~ /vine/ }
		return unless Spell[610].known? and Spell[610].affordable?
	   
		waitcastrt?
		change_stance('offensive') if command == 'kweed'
		Spell[610].cast("##{target.id}")
		change_stance('guarded') if command == 'kweed'
		waitcastrt?
	end
 
    def cmd_spell( incant = nil, id, extra, target )
		echo "cmd_spell" if $bigshot_debug
        selfcast = false
		if ( checkprep != "None" and checkprep != Spell[id].name )
            fput 'release'
        end
		
        return if id == 506 and Spell[506].active?
        return if id == 9605 and Spell[9606].active? # surge cooldown
		return if id == 608 and hiding?
		return if id == 703 and $bigshot_703_list.any? {|s| s == target.id}
		return if id == 1614 and $bigshot_1614_list.any? {|s| s == target.id}
        return if target.status =~ /dead/ || !GameObj.npcs.any? {|s| s.id == target.id}
        unless( Spell[id].affordable? )
            if(@WAND_IF_OOM)
                cmd_wand(target); return;
            end
            if(@USE_WRACKING)
                wrack()
            end
        end
               
		if ( !Spell[id].affordable? and id != 9605 and id != 506 )
			$bigshot_should_rest = true
			$rest_reason = "out of mana"
		end
		selfcast = true if id =~ /^(?:106|109|115|117|120|130|140|205|206|211|213|215|218|219|220|240|303|307|309|310|313|314|319|350|401|402|403|404|405|406|414|418|419|425|430|503|506|507|508|509|511|513|515|517|520|535|540|601|602|603|604|605|606|608|611|612|613|617|618|620|625|630|640|650|707|712|905|911|913|916|919|1003|1006|1007|1009|1010|1011|1012|1014|1017|1018|1019|1020|1025|1035|1040|1109|1119|1125|1130|1150|1202|1204|1208|1213|1214|1215|1216|1220|1235|1601|1603|1605|1606|1607|1608|1609|1610|1611|1612|1613|1616|1617|1618|1619|1635)$/
        waitcastrt?
		if !incant.nil?
			if XMLData.current_target_id != target.id && selfcast == false
				fput "target ##{target.id}"
			end
			change_stance('offensive') if ((id.to_s !~ /1700/i) || (id.to_s =~ /1700/i && extra =~ /evoke/i))
			bs_put "incant #{id} #{extra}"
			change_stance(@HUNTING_STANCE)
		else
			if selfcast == false
				Spell[id].cast("##{target.id}")
			else
				Spell[id].cast()
			end
		end
    end
 
    def cmd_wand(target)
		echo "cmd_wand" if $bigshot_debug
        if(@FRESH_WAND_CONTAINER)
            hands = GameObj.right_hand.name.to_s + GameObj.left_hand.name.to_s
            until( (GameObj.right_hand.name.to_s + GameObj.left_hand.name.to_s) =~ /#{@WAND[$bigshot_wand]}/i)
                result = dothistimeout( "get #{@WAND[$bigshot_wand]} from my #{@FRESH_WAND_CONTAINER}", 3, /You remove|You slip|Get what/ )
                if( result =~ /Get what/ )
					$bigshot_wand += 1
					if @WAND[$bigshot_wand].nil?
						message("ERROR: Couldn't find fresh wand. Gonna rest."); $bigshot_should_rest = true; return;
					end
                elsif(result.nil?)
                    message("ERROR: Timed out looking for wand."); return;
                end
            end
 
            change_stance('offensive')
            result = dothistimeout( "wave my #{@WAND[$bigshot_wand]} at ##{target.id}", 2, /d100|You hurl|is already dead|You do not see that here|You are in no condition|I could not find|Wait/ )
            change_stance(@HUNTING_STANCE)
           
            if( result =~ /You are in no condition/ )
                message("ERROR: Wounded. Gonna rest."); $bigshot_should_rest = true; return;
            elsif(result.nil?)
                if(@DEAD_WAND_CONTAINER)
                    bs_put "put my #{@WAND[$bigshot_wand]} in my #{@DEAD_WAND_CONTAINER}"
                else
                    bs_put "drop my #{@WAND[$bigshot_wand]}"
                end
            end
        else
            message("ERROR: Wand command called but fresh wand container not defined.")
        end
    end
 
    def cmd_hide()
		echo "cmd_hide" if $bigshot_debug
        tries = 0
        until(hiding?)
            break if tries > 3 || should_flee?
            change_stance('defensive')
            bs_put 'hide'; tries += 1;
        end
    end
 
	def mstrike_spell_check()
		echo "mstrike_spell_check" if $bigshot_debug
		#Rejuvenation
		if (Spell[1607].known? && !Spell[1607].active? && Spell[1607].affordable? && (checkstamina < (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE)))
			if ((checkstamina + (15+(bonus=0;[1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190].each { |n| bonus += 1 if Skills.slblessings >= n }; bonus*3))) >= (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE))
				waitcastrt?
				Spell[1607].cast
			end
		end
		#Adrenal Surge
		if (Spell[1107].known? && Spell[1107].affordable? && !Spell[9010].active? && (Time.now >= $bigshot_adrenal_surge))
			if (Spell[9699].active? || ((maxstamina if Skills.slblessings >= 65 ) >= (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE)))
				waitcastrt?
				spell[1107].cast
				$bigshot_adrenal_surge = Time.now + 301
			elsif (Spell[9699].active? || ((checkstamina + (50 if Skills.slblessings >= 35 )) >= (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE)))
				waitcastrt?
				spell[1107].cast
				$bigshot_adrenal_surge = Time.now + 301
			elsif (Spell[9699].active? || ((checkstamina + (25 if Skills.slblessings >= 35 )) >= (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE)))
				waitcastrt?
				spell[1107].cast
				$bigshot_adrenal_surge = Time.now + 301
			end
		end
	end
 
 
    def cmd_mstrike( command, target )
		echo "cmd_mstrike" if $bigshot_debug
		mstrike_spell_check() if Char.prof =~ /Paladin|Empath/i
		#Mstrike checks
		if Skills.multiopponentcombat >= 30 && GameObj.npcs.all? { |i| i.noun !~ /nest/i }
			if (!Spell[9005].active? || (@MSTRIKE_COOLDOWN && checkstamina >= @MSTRIKE_STAMINA_COOLDOWN))
				if @MSTRIKE_QUICKSTRIKE && checkstamina >= @MSTRIKE_STAMINA_QUICKSTRIKE && !Spell[9699].active?
					if( GameObjNpcCheck() >= @MSTRIKE_MOB || target.nil? )
						bs_put "quickstrike 1 #{command}"
					else
						bs_put "quickstrike 1 #{command} ##{target.id}"
					end
				else
					if( GameObjNpcCheck() >= @MSTRIKE_MOB || target.nil? )
						bs_put "#{command}"
					else
						bs_put "#{command} ##{target.id}"
					end
				end
			end
		elsif Skills.multiopponentcombat >= 5 && GameObj.npcs.all?{ |i| i.noun !~ /nest/i }
			if (!Spell[9005].active? || (@MSTRIKE_COOLDOWN && checkstamina >= @MSTRIKE_STAMINA_COOLDOWN))
				if @MSTRIKE_QUICKSTRIKE && checkstamina >= @MSTRIKE_STAMINA_QUICKSTRIKE && !Spell[9699].active?
					bs_put "quickstrike 1 #{command}"
				else
					bs_put "#{command}"
				end
			end
		end
    end
 
    def cmd_ranged(npc)
		echo "cmd_ranged" if $bigshot_debug
		if !@ARCHERY_AIM[$bigshot_archery_aim].nil?
			if $bigshot_archery_stuck_location.any? { |s| s =~ /#{$bigshot_archery_location}/i }
				$bigshot_archery_aim += 1
				if $bigshot_archery_aim > @ARCHERY_AIM.length
					$bigshot_archery_aim = 0
					$bigshot_archery_stuck_location = []
				end
			end
			if @ARCHERY_AIM[$bigshot_archery_aim] !~ /#{$bigshot_archery_location.to_s}/i || $bigshot_archery_location.nil?
				fput "aim #{@ARCHERY_AIM[$bigshot_archery_aim]}"
			end
		end
		
		waitrt?
		waitcastrt?		
#        result = dothistimeout "get 1 my #{@AMMO.sub(/s$/, '')}", 2, /You remove|Get what\?|You already/
#		if( result =~ /Get what\?/ )
#			$bigshot_should_rest = true
#            $rest_reason = "Out of ammo"
#			return
#		end
               
#        waitrt?
#		waitcastrt?
		if checkspirit < 8
			$bigshot_should_rest = true
			$rest_reason = "Spirit too low"
		end
		change_stance('offensive')
		result = dothistimeout("fire ##{npc.id}", 2, /You fire|You cannot|Could not find|seconds|Get what?/)
        if( result =~ /^Could not find/ )
#			gather_ammo()
		elsif( result =~ /You cannot fire/ )
			unless GameObj.right_hand.id.nil?
				line = dothistimeout "stow ##{GameObj.right_hand.id}", 3, /put|closed/
				if line =~ /closed/
					container = GameObj.inv.find { |obj| obj.name =~ /#{@AMMO_CONTAINER}/ }
					fput "open my ##{container.id}"
					fput "put ##{GameObj.right_hand.id} in my ##{container.id}"
				end
			end
		elsif( result =~ /but it has no effect/ )
			$bigshot_should_rest = true
			$rest_reason = "Ammo had no effect (need blessed or magical)"
		elsif ( result == false )
			$bigshot_should_rest = true
			$rest_reason = "Unknown result from fire routine: #{result}"
        end
    end
 
    def cmd_berserk()
		echo "cmd_berserk" if $bigshot_debug
        if( checkstamina(20) )
            change_stance('defensive')
			Spell[9607].cast
			pause 5
			wait_until( !Spell[9607].active?)
        else
            bs_put 'target random'; bs_put 'kill';
        end
    end
 
    def cmd_run_script( name, args )
		echo "cmd_run_script" if $bigshot_debug
        if( args == nil || args =~ /^\s*$/ )
            run_script( name, true )
        else
            args = args.split(/ /)
            run_script( name, true, args )
        end
    end
 
    def cmd_sleep( time, npc )
		echo "cmd_sleep" if $bigshot_debug
        change_stance('defensive')
        time.to_i.times do
            sleep 1
            break if should_rest?
            break if npc && npc.status =~ /dead/
        end
    end

    def cmd_ambush(command, target)
		echo "cmd_ambush" if $bigshot_debug
		return if target.status =~ /dead/ || !GameObj.npcs.any? {|s| s.id == target.id}
		command = ["head", "right leg", "left leg", "chest"] if (command == "" || command.nil?) && @AMBUSH == []
		command = @AMBUSH if (command == "" || command == [] || command.nil?) && @AMBUSH != []
		command = [command] if command.class == String
		waitrt?
		result = dothistimeout "ambush ##{target.id} #{command[$bigshot_ambush]}", 2, /round(time)?|You cannot aim that high!|is already missing that!/i
		if result =~ /You cannot aim that high!|is already missing that!/i
			$bigshot_ambush += 1
			cmd_ambush(nil, target)
		elsif result =~ /round(time)?/i
			$bigshot_ambush = 0
		end
    end
   
    def cmd_nudge_weapons()
		echo "cmd_nudge_weapons" if $bigshot_debug
        return if checkpaths.size == 0
 
        GameObj.loot.each { |i|
            next unless i.noun =~ /axe|scythe|pitchfork|falchion|sword|lance|sword|dagger|estoc|falchion|handaxe|katana|katar|gauche|rapier|scimitar|whip-blade|cudgel|crowbill|whip|mace|star|hammer|claidhmore|flail|flamberge|maul|pick|staff|mattock/
            change_stance('defensive')
           
            sheathed = false
            unless( righthand.nil? || lefthand.nil? )
                sheathed = true
                fput 'sheath'
                unless( righthand.nil? || lefthand.nil? )
                    message("Unable to empty hands via sheath.")
                    return
                end
            end
       
            dirs = checkpaths
            dir  = checkpaths.shift
            fput "get ##{i.id}"
            put dir
            put "drop ##{i.id}"
            fput reverse_direction(dir)
            fput "gird" if sheathed
        }
    end
 
    def message(text)
        string = ''
        if $fake_stormfront then string.concat("\034GSL\r\n ") else string.concat("<pushBold\/>") end
        if( text.index('\n') )
            text.split('\n').each { |line| string.concat("| #{line}") }
        else
            string.concat('| ' + text)
        end
        if $fake_stormfront then string.concat("\034GSM\r\n ") else string.concat("<popBold\/>") end
        puts string
    end
 
    def dead_man_switch()
		echo "dead_man_switch" if $bigshot_debug
        if @DEAD_MAN_SWITCH
            Thread.new {
                while( running?($current_script_name) )
                    if( dead? ||  percenthealth < 40 )
                        echo 'AUTOBOT ALERT: Your character is in trouble!'
                        fput 'quit'
                    end
                    sleep 2
                end
            };
        elsif @DEPART_SWITCH
            start_exec_script( <<-EOF
                while( running?($current_script_name) );
                    if(dead?);
                        stop_script($current_script_name);
                        fput 'depart'; fput 'depart';
                        fput 'depart confirm'; fput 'depart confirm';
                        start_script('waggle');
                        15.times { sleep 60; fput info; };
                        sleep 1 until percentspirit == 100 && !running?('waggle');
                        start_script( "#{$current_script_name}", ['solo'] );
                        Script.self.kill;
                    end;
                    sleep 5;
                end;
                EOF
            );
        else
            Thread.new {
                loop { Script.self.kill if dead?; sleep 5; }
            }
        end
    end
 
    def keep_awake()
		echo "keep_awake" if $bigshot_debug
        Thread.new {
            while( running?($current_script_name) )
                sleep 150; put 'look';
            end
        }
    end
 
    def monitor_interaction()
		echo "monitor_interaction" if $bigshot_debug
        if @MONITOR_INTERACTION
            start_exec_script( <<-eos
                def show_window(line);
                    window_title = Char.name + ':' + line;
                    Gtk.queue {
                        $myWindow = Gtk::Window.new;
                        $myWindow.title = "Autobot Alert!";
                        $myWindow.set_size_request(450, 25);
                        label = Gtk::Label.new window_title;
                        $myWindow.add(label);
                        $myWindow.show_all;
                    };
                end;
                while(line = get);
                    break unless running?($current_script_name);
                    if(line =~ /SEND|POLICY|[Rr](\s)*[Ee](\s)*[Pp](\s)*[Oo](\s)*[Rr](\s)*[Tt]|peaking to you|unresponsive|taps you|nods to you|lease respond|not in control|character|violation|lease speak|peak out loud|Y U SHOU D|whispers,|speaking to you|smiles at you|waves to you|grins at you|hugs you|takes hold your hand|grabs your hand|clasps your hand|trying to drag you/);
                        unless(line =~ /LNet/);
                            show_window(line);
                            echo "AUTOBOT ALERT: " + line;
                        end;
                    end;
                end;
            eos
            )
        end
    end
	
	def GameObjNpcCheck()
		return (GameObj.npcs.size.to_i - GameObj.npcs.count{|s| s.type =~ /escort|companion|familiar/}.to_i - GameObj.npcs.count{|s| s.noun =~ /^(?:arm|arms|grik|grik'trak|grik'mlar|grik'pwal|grik'tval|verlok|verlok'asha|verlok'cina|verlok'ar|imp|abyran|abyran'a|abyran'sa|grantris|igaesha|haze|rouk|brume|haar|murk|nyle|mist|smoke|vapor|fog|aishan|shien|darkling|shadowling|arashan)$/i}.to_i - GameObj.npcs.count{|s| s.status =~ /dead|gone/}.to_i)
	end
 
 #HACK
    def wrack()
        spirit_count = 0
        [ Spell['Sign of Swords'], Spell['Sign of Shields'], Spell['Sign of Dissipation'] ].each do |sn|
            spirit_count += 1 if sn.active?
        end

        if maxspirit - Spell['Sign of Wracking'].spirit_cost <= spirit_count
            return
        end

        Spell['Sign of Wracking'].cast()
    end
 
#    def wrack()
#		echo "wrack" if $hunt_debug
#        if Spell[9918].known? and not Spell[9012].active?
#            Spell[9918].cast if checkspirit >= @WRACKING_SPIRIT
#        elsif Spell[9718].known?
#            ( checkstamina / 50 ).times { Spell[9718].cast }
#        end
#    end
 
    def change_stance( new_stance, force = true )
        return if Spell[1617].active? || Spell[216].active? || dead?
 
        if( stance() =~ /#{new_stance}/ )
            return
        elsif( checkcastrt() > 0 && new_stance =~ /def/ )
            return if stance() == 'guarded'
        end
 
        if(force)
            result = dothistimeout( "stance #{new_stance}", 3, /You are now in an?|Cast Round Time in effect|You are unable to change/ )
        else
            fput "stance #{new_stance}"
        end
    end
 
    def wait_for_swing( seconds, target = nil )
		echo "wait_for_swing" if $bigshot_debug
        start = Time.now
        swung = false
        $stop_wait = false
        $global_target = target.id
        $pcs = checkpcs ? ' you(\.|!|r? )|' + checkpcs.join('|') : 'you(\.|!|r? )'
     
        wait_for_swing_exec = <<-eos
        status_tags
        while line = get
            $stop_wait = true if line =~ /#{$global_target}.*#{$pcs}/ and line !~ /style id="".*style id="roomDesc"|(?:component|compDef) id='room objs'/
            break if $stop_wait
            break if !running?($current_script_name)
        end
        status_tags
        eos
 
        ExecScript.start(wait_for_swing_exec, :quiet => true)
       
        while(1)
            change_stance( 'defensive', false ) unless target && target.status =~ PRONE
            stand() if !standing?
            break if $stop_wait.call
            break if GameObj.npcs.size.nil? || GameObjNpcCheck() == 0
            break if should_flee?
            break if target && target.status =~ PRONE
            break if ( Time.now - start ) > seconds
            sleep 0.25
        end
    end
 
    def croak(message)
		echo "croak" if $bigshot_debug
        message(message);
        croak_scripts( ["#{$current_script_name}"] )
    end
 
    def run_script( name, pause_bigshot = false, args = [] )
		echo "run_script" if $bigshot_debug
        if Script.running.find { |s| s.name.downcase == name.downcase }.paused or running? name
            stop_script name
            wait_while { running? name }
        end
 
        start_script name, args
        if pause_bigshot
            wait_until { !running? name }
        end
    end
 
    def run_scripts( scripts, pause_bigshot = false )
		echo "run_scripts" if $bigshot_debug
        scripts.each do |i|
            tokens = i.split(/\s+/)
            if( tokens.size > 1 )
                run_script( tokens[0], pause_bigshot, tokens[1..-1] )
            else
                run_script( tokens[0], pause_bigshot )
            end
        end
    end
 
    def croak_script(name)
		echo "croak_script" if $bigshot_debug
        kill_script(name) if running?(name)
    end
 
    def croak_scripts(scripts)
		echo "croak_scripts" if $bigshot_debug
        scripts.each { |i| croak_script(i) }
    end
 
    def stand()
		echo "stand" if $bigshot_debug
        until(standing?)
            change_stance('defensive')
            bs_put 'stand'
        end
    end
 
	 def groupcheck()
		echo "groupcheck" if $bigshot_debug
		def checkgroupline(line)
			line =~ /exist="\-[0-9]+" noun=".*">(.*)<\/a> is (?:following you|the leader of your group|also a member of your group)/i
			if !$1.nil? then $grouplist.push($1); end
		end

		action = proc { |server_string|
			if checkgroupline(server_string) or server_string =~ /group status is currently|to set your group status|^.$|You are not currently in a group/m then nil
			else server_string
			end
		}
		DownstreamHook.add('grouphook',action)
		$_SERVER_.puts "group"
		waitfor "group status is currently", "to set your group status", "You are not currently in a group"
		pause 0.5
		DownstreamHook.remove('grouphook')
		echo $grouplist if $bigshot_debug
	end
 
    def lead( my_group = nil )
		echo "lead" if $bigshot_debug
        monitor_interaction()
        @followers = my_group || Group.new()
		if (!my_group.nil? || $bigshot_quick)
			groupcheck()
		end
 
        if(should_rest? && !$bigshot_quick)
            rest()
        else
            hunt()
        end
    end
 
    def find_routine(target)
		echo "find_routine" if $bigshot_debug
		if( !solo? && fried? )
            return @DISABLE_COMMANDS
        else
			key = @TARGETS.keys.find { |k| target.name =~ /^#{k}$/i or target.noun =~ /^#{k}$/i }
			if key.nil?
					routine_letter = 'a'
			else
					routine_letter = @TARGETS[key]
			end
		   
		    #Original
			#if routine_letter == 'quick'
			#Hack
			if routine_letter == 'quick' || $bigshot_quick
				return @QUICK_COMMANDS unless @QUICK_COMMANDS.size == 0
			elsif routine_letter == 'j'
				return @HUNTING_COMMANDS_J unless @HUNTING_COMMANDS_J.size == 0
			elsif routine_letter == 'i'
				return @HUNTING_COMMANDS_I unless @HUNTING_COMMANDS_I.size == 0
			elsif routine_letter == 'h'
				return @HUNTING_COMMANDS_H unless @HUNTING_COMMANDS_H.size == 0
			elsif routine_letter == 'g'
				return @HUNTING_COMMANDS_G unless @HUNTING_COMMANDS_G.size == 0
			elsif routine_letter == 'f'
				return @HUNTING_COMMANDS_F unless @HUNTING_COMMANDS_F.size == 0
			elsif routine_letter == 'e'
				return @HUNTING_COMMANDS_E unless @HUNTING_COMMANDS_E.size == 0
			elsif routine_letter == 'd'
				return @HUNTING_COMMANDS_D unless @HUNTING_COMMANDS_D.size == 0
			elsif routine_letter == 'c'
				return @HUNTING_COMMANDS_C unless @HUNTING_COMMANDS_C.size == 0
			elsif routine_letter == 'b'
				return @HUNTING_COMMANDS_B unless @HUNTING_COMMANDS_B.size == 0
			end
		   
			return @HUNTING_COMMANDS
        end
    end
 
    def solo?
        # tails wont have followers
        if( @followers && @followers.size == 0 )
            return true
        else
            return false
        end
    end
 
    def leading?
        return !following?
    end
   
    def following?
        return @followers.nil?
    end
   
    def no_players()
		echo "no_players" if $bigshot_debug
        return false if GameObj.loot.find { |obj| obj.noun == 'disk' and obj.name !~ /#{Char.name}/}
        return false if ((checkpcs - $grouplist).count > 0) or $ambusher_here
        return true
    end
	
	def no_players_hunt()
		echo "no_players_hunt" if $bigshot_debug
        return false if $ambusher_here
        return true
    end
 
    def pre_hunt()
		echo "pre_hunt" if $bigshot_debug
        # prep/go
        @followers.add_event(:HUNTING_PREP_COMMANDS)
        @HUNTING_PREP_COMMANDS.each { |i|
            if i =~ /^script\s+(.*?)(\s|$)(.*)/i
               cmd_run_script( $1, $3 )
            else
                fput(i)
            end
        }
 
        @followers.add_event(:CAST_SIGNS)
        cast_signs()
 
        @followers.add_event(:HUNTING_SCRIPTS_START)
        run_scripts( @HUNTING_SCRIPTS, false )
		
		if !$bigshot_quick
			#HACK THIS
			if $mount_active == true
			end
			#echo 'BIGSHOT IS CONTROLING THE GO TO'	
			goto(@HUNTING_ROOM_ID)
		end
        if( !solo? && @followers.get_names.any? { |i| !checkpcs.include?(i) } )
            @followers.add_event(:CAST_SIGNS) # trigger rubber band
            sleep 10 # wait for followers
        end
    end
   
    def do_hunt()
		echo "do_hunt" if $bigshot_debug
        spam() if UserVars.op['spam']
       
        start_watch()
        message('Explorer activated')
 
        # loop
        target = nil
        just_arrived = true
        last_attack = 0
		reset_variables()
   
		while true
			while( (target = find_target(target, just_arrived)) && !should_rest? && no_players_hunt == true && !$bigshot_flee)
				echo "inside do_hunt loop" if $bigshot_debug
				echo target if $bigshot_debug
				target = find_target(nil) if !priority(target) && @PRIORITY
				echo "Priority target switch to #{target}" if $bigshot_debug && @PRIORITY
				if( (Time.now.to_i - last_attack > 15) || just_arrived )
					@followers.add_event(:ATTACK)
					last_attack = Time.now.to_i
				end
				waitrt?
				waitcastrt?
				attack(target)
				just_arrived = false
				loot() if $ambusher_here == false
			end
       
			echo "Exiting attack loop" if $bigshot_debug
#			gather_ammo()
 
			if(should_rest?)
				break
			else
				prepare_for_movement()
				target = bs_wander()
				just_arrived = true
			end
		end
 
        unspam()
    end
 
    # this is a leader method
    def hunt()
		echo "hunt" if $bigshot_debug
        pre_hunt()
        do_hunt()
        rest()
    end
 
    # this is a leader method
    def rest()
		echo "rest" if $bigshot_debug
        message("Explorer resting: #{$rest_reason}")
        $bigshot_should_rest = nil
        if @BOUNTY_MODE # bounty script should take over from here
          echo "Bounty mode. Killing self. Reason: #{$rest_reason}"
          Script.self.kill
        end
         
        stop_watch()
 
        # prep/go
		prepare_for_movement()
		if (@FOG_RETURN)
			if Spell[130].known? && Spell[130].affordable?
				Spell[130].cast()
			elsif Spell[9825].known?
				fput "symbol of return"
			end
		end
        goto(@RESTING_ROOM_ID)
 
        @followers.add_event(:HUNTING_SCRIPTS_STOP)
        croak_scripts(@HUNTING_SCRIPTS)
       
        @followers.add_event(:RESTING_PREP_COMMANDS)
        @RESTING_COMMANDS.each { |i| fput(i) }
 
        @followers.add_event(:RESTING_SCRIPTS_START)
        run_scripts( @RESTING_SCRIPTS, true )
		
		if($rest_reason =~ /No blessing on weapon|Ammo had no effect \(need blessed or magical\)/i)
			echo "Need a blessing on weapon to continue hunting"
			Script.self.kill
		end
        # loop
        until(should_hunt?)
			@followers.add_event(:DISPLAY_WATCH)
            fput 'exp'
            display_watch_current()
            display_watch_average()
            display_watch_total()
            message( "Explorer last rested because: #{$rest_reason}" ) if $rest_reason
            message( "Explorer isn't hunting because: #{$not_hunting_reason}" ) if $not_hunting_reason
            sleep REST_INTERVAL
        end
 
        hunt()
    end
 
    def attack(target)
		echo "attack" if $bigshot_debug
        commands = find_routine(target)
        echo "Inside attack(target) #{commands}" if $bigshot_debug
 
        commands.each do |i|
            break unless valid_target?(target)
            break if wounded? || $bigshot_should_rest
            #break if $ambusher_here
            break if target.status =~ /dead/ || !GameObj.npcs.any? {|s| s.id == target.id}
			break if should_flee?
			break if should_rest?
			break if !priority(target) && @PRIORITY
            stand() if !standing?
            cast_signs()
           
            cmd( i, target )
        end
        echo commands.size if $bigshot_debug
        #sleep 1 if commands.size == 0
    end
 
    def goto(id)
		echo "goto" if $bigshot_debug
        prepare_for_movement()
        until( Room.current.id == id )
            run_script( 'go2', true, [ id, '_disable_confirm_' ] )
        end
    end
 
    def start_watch()
		echo "start_watch" if $bigshot_debug
        @START_TIME = Time.now.to_i
    end
 
    def stop_watch()
		echo "stop_watch" if $bigshot_debug
        if( @START_TIME > 100 )
            @STORED_TIMES.push( Time.now.to_i - @START_TIME )
        end
        @START_TIME = 0
    end
 
    def display_watch_current()
		echo "display_watch_current" if $bigshot_debug
        if( @STORED_TIMES.size > 0 )
            seconds = @STORED_TIMES[-1]
            message( sprintf( "Explorer: Last Hunt: %d min. %0.2f secs.",
                seconds / 60, seconds % 60 ) )
        end
    end
 
    def display_watch_average()
		echo "display_watch_average" if $bigshot_debug
        average = 0
        if( @STORED_TIMES.size == 1 )
            average = @STORED_TIMES[0]
        elsif( @STORED_TIMES.size > 1 )
            @STORED_TIMES.each { |i| average += i }
            average /= @STORED_TIMES.size
        else
            return
        end
        message( sprintf( "Explorer: Average Hunt: %d min. %0.2f secs.",
            average / 60, average % 60 ) )
    end
 
    def display_watch_total()
		echo "display_watch_total" if $bigshot_debug
        total = Time.now.to_i - @BIRTH_TIME
        message( sprintf( "Explorer: Total Time Running: %d min.  %0.2f secs.",
            total / 60, total % 60 ) )
    end
 
    def room_id()
		echo "room_id" if $bigshot_debug
        return Room.current.id()
    end
 
    def name()
        return Char.name
    end
 
    def poaching?()
		echo "poaching?" if $bigshot_debug
		if($bigshot_quick && $grouplist.size > 0)
			return false
        elsif(leading?)
            checkpcs.each { |i| return true unless @followers.get_names.include?(i) }
			if solo?
				GameObj.npcs.each { |i| return true if i.type =~ /companion/ && i.name !~ /#{$companion}/i } 
				GameObj.npcs.each { |i| return true if i.type =~ /familiar/ && i.name !~ /#{$familiar}/i }
			end
            return false
        else
            return false
        end
    end
 
    def should_flee?( just_entered = false )
		return false if $bigshot_quick
		return true if $bigshot_flee
        GameObj.loot.each { |i| return true if i.noun =~ /cloud|breath/ } if @FLEE_CLOUDS
		GameObj.loot.each { |i| return true if i.noun =~ /vine/ } if @FLEE_VINES
        return true if GameObj.npcs.any?  { |i| @ALWAYS_FLEE_FROM.include?(i.noun) or @ALWAYS_FLEE_FROM.include?(i.name) }
        return true if checkpcs.any?      { |i| @ALWAYS_FLEE_FROM.include?(i) }
        return true if !leading? && checkpcs.empty?
 
        npcs = GameObj.npcs.find_all { |i| i.status !~ /dead/ }
		npcs.delete_if { |npc| (@INVALID_TARGETS.include?(npc.name) or @INVALID_TARGETS.include?(npc.noun)) }
	    npcs.delete_if { |npc| npc.noun =~ /child|traveller|scribe|merchant|dignitary|official|magistrate/i && npc.name !~ /ethereal|celestial|unworldly/i }
		npcs.delete_if { |npc| npc.noun =~ /^(?:arm|arms|grik|grik'trak|grik'mlar|grik'pwal|grik'tval|verlok|verlok'asha|verlok'cina|verlok'ar|imp|abyran|abyran'a|abyran'sa|grantris|igaesha|haze|rouk|brume|haar|murk|nyle|mist|smoke|vapor|fog|aishan|shien|darkling|shadowling|arashan)$/i}
		npcs.delete_if { |npc| npc.type =~ /companion|familiar/i }
	   
		flee_count = (just_entered && @LONE_TARGETS_ONLY) ? 1 : @FLEE_COUNT
		if npcs.size > flee_count
			return true
		end
    end
 
    def valid_target?( target, just_entered = false )
		echo "valid_target?" if $bigshot_debug
        return false if target == nil || target == false
        return false if should_flee?(just_entered)
        return false if just_entered && poaching?
		#HACK
		if Char.prof =~ /Bard/i
			return false if target.name =~ /rune-covered/
		end
        return false if target.noun =~ /child|traveller|scribe|merchant|dignitary|official|magistrate/i && target.name !~ /ethereal|celestial|unworldly/i
		return false if target.noun =~ /^(?:arm|arms|grik|grik'trak|grik'mlar|grik'pwal|grik'tval|verlok|verlok'asha|verlok'cina|verlok'ar|imp|abyran|abyran'a|abyran'sa|grantris|igaesha|haze|rouk|brume|haar|murk|nyle|mist|smoke|vapor|fog|aishan|shien|darkling|shadowling|arashan)$/i
       
        if( !CharSettings['targetable'].include?(target.name) && !CharSettings['untargetable'].include?(target.name) && target.status !~ /dead/ )
            result = dothistimeout( "target ##{target.id}", 3, /^You are now targeting|^You can't target/ )
            if( result =~ /^You are now targeting/ )
                CharSettings['targetable'].push(target.name) if target.status !~ /dead/
            elsif( result =~ /^You can't target/ )
                CharSettings['untargetable'].push(target.name) if target.status !~ /dead/
            end
        end
        return false if CharSettings['untargetable'].include?(target.name)
        if (target.status !~ /dead/) and GameObj.npcs.any? { |n| n.id == target.id } and (@TARGETS.nil? or @TARGETS.keys.any? { |i| target.name =~ /#{i}/i or target.noun =~ /#{i}/i })
            return true
        else
            return false
        end
    end
 
    def sort_npcs()
		echo "sort_npcs" if $bigshot_debug
		if $bigshot_quick
			targets = Hash.new
			tokens = []
			if @QUICKHUNT_TARGETS.nil?
				@QUICKHUNT_TARGETS = Hash.new 
				@QUICKHUNT_TARGETS["ZZTestZZ"]="ZZTestZZ"
			end
			npcs = GameObj.npcs.find_all { |i| i.status !~ /dead/ }
			npcs.delete_if { |npc| npc.noun =~ /child|traveller|scribe|merchant|dignitary|official|magistrate/i && npc.name !~ /ethereal|celestial|unworldly/i }
			npcs.delete_if { |npc| npc.noun =~ /^(?:arm|arms|grik|grik'trak|grik'mlar|grik'pwal|grik'tval|verlok|verlok'asha|verlok'cina|verlok'ar|imp|abyran|abyran'a|abyran'sa|grantris|igaesha|haze|rouk|brume|haar|murk|nyle|mist|smoke|vapor|fog|aishan|shien|darkling|shadowling|arashan)$/i}
			npcs.delete_if { |npc| npc.type =~ /companion|familiar/i }
			npcs.each {|i| tokens.push(i.name)}
			tokens.uniq.each {|i| 
				if i =~ /#{@QUICKHUNT_TARGETS.keys.join('|')}/i
					next
				else
					targets[i] = "quick"
				end
			}
			@TARGETS.replace(@QUICKHUNT_TARGETS)
			@TARGETS.merge!(targets)
			targets = @TARGETS
		else
			targets = @TARGETS
		end
			   
		npcs = GameObj.npcs
		sorted = Array.new
		targets.keys.each { |target| sorted += npcs.find_all { |npc| (npc.name =~ /^#{target}$/i or npc.noun =~ /^#{target}$/i) }.to_a }
		sorted.flatten
    end
    
	def priority(target)
		echo "priority" if $bigshot_debug
		priority = false
		stoppriority = false
		npcs = GameObj.npcs.find_all { |i| i.status !~ /dead/ }
	    npcs.delete_if { |npc| npc.noun =~ /child|traveller|scribe|merchant|dignitary|official|magistrate/i && npc.name !~ /ethereal|celestial|unworldly/i }
		npcs.delete_if { |npc| npc.noun =~ /^(?:arm|arms|grik|grik'trak|grik'mlar|grik'pwal|grik'tval|verlok|verlok'asha|verlok'cina|verlok'ar|imp|abyran|abyran'a|abyran'sa|grantris|igaesha|haze|rouk|brume|haar|murk|nyle|mist|smoke|vapor|fog|aishan|shien|darkling|shadowling|arashan)$/i }
		npcs.delete_if { |npc| npc.type =~ /companion|familiar/i }
		@TARGETS.keys.each{|t|
			break if stoppriority == true
			npcs.each{|s|
				break if stoppriority == true
				if (s.name =~ /#{t}/i or s.noun =~ /#{t}/i)
					if s.name == target.name
						stoppriority = true
						priority = true
					else
						stoppriority = true
					end
				end
			}
		}
		return priority
	end
	
    def find_target( target, just_entered = false )
		echo "find_target" if $bigshot_debug
        return target if valid_target?(target, just_entered)
		
		if @PRIORITY
			sort_npcs.each { |i| return i if valid_target?( i, just_entered ) && priority(i) }
		else
			sort_npcs.each { |i| return i if valid_target?( i, just_entered ) }
		end
        return nil
    end
 
    def rt?()
		echo "rt?" if $bigshot_debug
        return checkrt()
    end
 
    def fried?()
        if( percentmind() >= @FRIED )
            return true
        end
        return false
    end
 
    def oom?()
        if( percentmana() < @OOM )
            return true
        end
        return false
    end
 
	def reset_variables()
		echo "reset_variables" if $bigshot_debug
		$ambusher_here = false
		$bigshot_smite_list = []
		$bigshot_aim = 0
		$bigshot_ambush = 0
		$bigshot_archery_aim = 0
		$bigshot_archery_stuck_location = []
		$bigshot_unarmed_tier = 1
		$bigshot_unarmed_followup = false
		$bigshot_unarmed_followup_attack = ""
		$bigshot_703_list = []
		$bigshot_1614_list = []
	end
	
    def wounded?()
		if $bigshot_quick
			return false
        elsif(@WOUNDED_EVAL)
            return eval @WOUNDED_EVAL
        else
            return false
        end
    end
 
    def should_hunt?()
		echo "should_hunt?" if $bigshot_debug
		if(wounded?)
            $not_hunting_reason = 'wounded.'
            return false
        elsif( percentencumbrance >= @ENCUMBERED )
            $not_hunting_reason = 'encumbered.'
            return false
        elsif( @RESTING_SCRIPTS.any? { |i| running?(i) } )
            $not_hunting_reason = 'resting scripts still running.'
            return false
        end
 
        followers_should = (leading? && !solo?) ? @followers.should_hunt? : true
        if(followers_should)
            if( percentmind() > @REST_TILL_EXP )
                $not_hunting_reason = 'mind still above threshold.'
                return false
            elsif( percentmana() < @REST_TILL_MANA )
                $not_hunting_reason = 'mana still below threshold.'
                return false
            elsif( checkspirit() < @REST_TILL_SPIRIT )
                $not_hunting_reason = 'spirit still below threshold.'
                return false
            end
        else
            $not_hunting_reason = 'followers still need rest.'
            return false
        end
		$bigshot_status = :hunting
        return true
    end
 
    def should_rest?()
		if($bigshot_quick)
			return false
        elsif($bigshot_should_rest)
            $rest_reason = "$bigshot_should_rest was set to true." unless $rest_reason
			$bigshot_status = :resting
            return true
        elsif(wounded?)
            $rest_reason = "wounded."
			$bigshot_status = :resting
            return true
        elsif( percentencumbrance >= @ENCUMBERED )
            $rest_reason = "encumbered."
			$bigshot_status = :resting
            return true
        elsif( leading? && !solo? && @followers.emergency_rest? )
            $rest_reason = "emergency rest."
			$bigshot_status = :resting
            return true
        end
 
        followers_fried = (leading? && !solo?) ? @followers.should_rest? : true
 
        if(followers_fried)
            if(fried?)
                $rest_reason = "fried."
				$bigshot_status = :resting
                return true
            elsif(oom?)
                wrack() if @USE_WRACKING
                return false if !oom?
               
                $rest_reason = "out of mana."
				$bigshot_status = :resting
                return true
            end
        end
       
        $rest_reason = "none."
        return false
    end
 
    def cast_signs(single_cast = false)
		echo "cast_signs?" if $bigshot_debug
        @SIGNS.each do |i|
            i = i.to_i
			next if [ 9903,9904,9905,9906,9907,9908,9909,9910,9912,9913,9914,9918 ].include?(i) and Spell[9012].active?
            next if i == 9918
            next if i == 9603 && Spell[9604].active?
            next if i == 9605 && Spell[9606].active?
            sign = Spell[i]
            next unless sign.known?
 
            # wrack?
            mana_cost = sign.mana_cost > 1 ? sign.mana_cost : 0 # Many erroneously return 1
            wrack() if !sign.affordable? and mana_cost > checkmana and @USE_WRACKING
 
            if( !sign.active? && sign.affordable? )
                if( i  == 9805 )
                    2.times { sign.cast }
                else
                    while(1)
                        result = sign.cast
                        break if result !~ /Spell Hindrance/ || !sign.affordable? || dead?
                    end
                end
                               
				break if single_cast
            end
        end
    end
 
    def loot()
        echo "loot" if $bigshot_debug
		waitrt?
		dead_npcs = GameObj.npcs.find_all { |i| i.status == 'dead' && i.type !~ /escort/i }
        dead_npcs.each { |i|
			reset_variables()
            if(@LOOT_SCRIPT)
                run_script( @LOOT_SCRIPT, true )
                break
            else
				change_stance('defensive') if GameObj.npcs.any?{ |s| s.status !~ /dead/ }
                bs_put 'loot'
            end
        }
    end
 
    def prepare_for_movement()
		echo "prepare_for_movement" if $bigshot_debug
		reset_variables()
		change_stance('defensive')
        if( leading? && !solo? )
			@followers.add_event(:PREP_REST)
            wait_while { @followers.roundtime? }
            sleep 0.3
        end
    end
 
    def bs_wander()
		echo "bs_wander" if $bigshot_debug
		$wander_rooms    ||= Array.new
               
        wander = proc {
            room = Room.current
            next_room_options = room.wayto.keys - @HUNTING_BOUNDARIES
			next_room_options.delete_if { |room_id| (room.timeto[room_id].class == Proc) and room.timeto[room_id].call.nil? }
			next_room = next_room_options.find_all { |r| not $wander_rooms.include?(r) }
			if next_room.empty?
				next_room = $wander_rooms.find { |r| next_room_options.include?(r) }
			else
				next_room = next_room[rand(next_room.length)]
			end
			$wander_rooms.delete(next_room)
			$wander_rooms.push(next_room)
			way = room.wayto[next_room]
            if way.class == String
				pause @WANDER_WAIT
                move(way)
            else
                way.call
            end
			#HACK
			GameObj.pcs.each {|s| 	if s.status =~ /^lying|prone/ and s.status != /dead/
										fput "pull #{s.noun}"
									end
							}
			cast_signs(true)
        }
       
        while true  # wander, check for players
			reset_variables()
			change_stance('defensive')
			exit if $bigshot_quick
            npcs = GameObj.npcs
            npcs.delete_if { |npc| (npc.status =~ /dead/) }
            sort_npcs.each{ |i| return i if valid_target?( i, true ) and no_players == true and (GameObjNpcCheck() > 0) }
            return if should_rest?
			wander.call
            sleep 0.1
			$bigshot_flee = false
        end
    end
 
    def bs_put(message)
		echo "bs_put" if $bigshot_debug
        unless script = Script.self then respond('--- waitfor: Unable to identify calling script.'); return false; end
        clear
        put(message)
 
        while string = get
            if string =~ /(?:\.\.\.wait |Wait )[0-9]+/
                hold_up = string.slice(/[0-9]+/).to_i
                sleep(hold_up - 1) unless hold_up.nil? || hold_up == 1
                clear
                put(message)
                next
            elsif string =~ /struggle.+stand/
                clear
                bs_put("stand")
                next
            elsif string =~ /stunned|can't do that while|cannot seem|can't seem|don't seem|Sorry, you may only type ahead/
                if dead?
                    echo("You're dead...! You can't do that!")
                    sleep 0.25
                    script.downstream_buffer.unshift(string)
                    return false
                elsif checkstunned
                    while checkstunned
                        sleep("0.25".to_f)
                    end
                elsif checkwebbed
                    while checkwebbed
                        sleep("0.25".to_f)
                    end
                else
                    sleep(0.25)
                end
                clear
                put(message)
                next
            else
                script.downstream_buffer.unshift(string)
                return string
            end
        end
    end
 
    # gui
    def self.setup
        Gtk.queue {
            $OP_WINDOW = Gtk::Window.new
            $OP_WINDOW.title = "Explorer: v#{BIGSHOT_VERSION}"
            $OP_WINDOW.set_border_width(10)
			$OP_WINDOW.keep_above = true
            $OP_BOX = Gtk::VBox.new(false)
            $OP_BOX.set_border_width(5)
 
            $OP_VERTICAL_BOX1 = Gtk::VBox.new(false, 0)
            $OP_VERTICAL_BOX2 = Gtk::VBox.new(false, 0)
            $OP_VERTICAL_BOX3 = Gtk::VBox.new(false, 0)
            $OP_VERTICAL_BOX4 = Gtk::VBox.new(false, 0)
            $OP_VERTICAL_BOX5 = Gtk::VBox.new(false, 0)
            $OP_VERTICAL_BOX6 = Gtk::VBox.new(false, 0)
            $OP_VERTICAL_BOX7 = Gtk::VBox.new(false, 0)
            $OP_VERTICAL_BOX8 = Gtk::VBox.new(false, 0)
			$OP_VERTICAL_BOX9 = Gtk::VBox.new(false, 0)
			$OP_VERTICAL_BOX10 = Gtk::VBox.new(false, 0)
			$OP_VERTICAL_BOX11 = Gtk::VBox.new(false, 0)
 
            $OP_WINDOW.add($OP_BOX)
            $OP_NOTEBOOK = Gtk::Notebook.new
            $OP_NOTEBOOK.set_show_border(true)
            $OP_BOX.add($OP_NOTEBOOK)
            $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX1, Gtk::Label.new('General'))
            $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX2, Gtk::Label.new('Resting'))
            $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX3, Gtk::Label.new('Hunting Map'))
            $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX4, Gtk::Label.new('Hunting'))
            $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX5, Gtk::Label.new('Attacking'))
			$OP_NOTEBOOK.append_page($OP_VERTICAL_BOX6, Gtk::Label.new('Commands'))
			$OP_NOTEBOOK.append_page($OP_VERTICAL_BOX7, Gtk::Label.new('UAC'))
			$OP_NOTEBOOK.append_page($OP_VERTICAL_BOX8, Gtk::Label.new('MSTRIKE'))
            $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX9, Gtk::Label.new('Should_hunt?'))
            $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX10, Gtk::Label.new('Should_rest?'))
            $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX11, Gtk::Label.new('Ammo/Wands'))
 
            $OP_ENTRY = Hash.new # For mapping entries to variables
            $OP_TABLE_SIZE = Hash.new # For mapping table sizes
        }
 
        Gtk.queue {
            $OP_TABLE1 = Gtk::Table.new(6, 3, false)
            $OP_TABLE1.row_spacings=3
            $OP_TABLE1.column_spacings=3
            $OP_VERTICAL_BOX1.pack_start($OP_TABLE1, false, false, 0)
 
            $OP_TABLE2 = Gtk::Table.new(6, 3, false)
            $OP_TABLE2.row_spacings=3
            $OP_TABLE2.column_spacings=3
            $OP_VERTICAL_BOX2.pack_start($OP_TABLE2, false, false, 0)
 
            $OP_TABLE3 = Gtk::Table.new(6, 3, false)
            $OP_TABLE3.row_spacings=3
            $OP_TABLE3.column_spacings=3
            $OP_VERTICAL_BOX3.pack_start($OP_TABLE3, false, false, 0)
 
            $OP_TABLE4 = Gtk::Table.new(6, 3, false)
            $OP_TABLE4.row_spacings=3
            $OP_TABLE4.column_spacings=3
            $OP_VERTICAL_BOX4.pack_start($OP_TABLE4, false, false, 0)
 
            $OP_TABLE5 = Gtk::Table.new(6, 3, false)
            $OP_TABLE5.row_spacings=3
            $OP_TABLE5.column_spacings=3
            $OP_VERTICAL_BOX5.pack_start($OP_TABLE5, false, false, 0)
 
            $OP_TABLE6 = Gtk::Table.new(6, 3, false)
            $OP_TABLE6.row_spacings=1
            $OP_TABLE6.column_spacings=1
            $OP_VERTICAL_BOX6.pack_start($OP_TABLE6, false, false, 0)
 
            $OP_TABLE7 = Gtk::Table.new(6, 3, false)
            $OP_TABLE7.row_spacings=3
            $OP_TABLE7.column_spacings=3
            $OP_VERTICAL_BOX7.pack_start($OP_TABLE7, false, false, 0)
 
            $OP_TABLE8 = Gtk::Table.new(6, 3, false)
            $OP_TABLE8.row_spacings=3
            $OP_TABLE8.column_spacings=3
            $OP_VERTICAL_BOX8.pack_start($OP_TABLE8, false, false, 0)
			
			$OP_TABLE9 = Gtk::Table.new(6, 3, false)
            $OP_TABLE9.row_spacings=3
            $OP_TABLE9.column_spacings=3
            $OP_VERTICAL_BOX9.pack_start($OP_TABLE9, false, false, 0)

			$OP_TABLE10 = Gtk::Table.new(6, 3, false)
            $OP_TABLE10.row_spacings=3
            $OP_TABLE10.column_spacings=3
            $OP_VERTICAL_BOX10.pack_start($OP_TABLE10, false, false, 0)
			
			$OP_TABLE11 = Gtk::Table.new(6, 3, false)
            $OP_TABLE11.row_spacings=3
            $OP_TABLE11.column_spacings=3
            $OP_VERTICAL_BOX11.pack_start($OP_TABLE11, false, false, 0)
        }
 
        def self.add_label_entry(table, label, variable)
            size = $OP_TABLE_SIZE[table] || 0
 
            label = Gtk::Label.new(label)
            align = Gtk::Alignment.new 1, 0, 0, 0
            align.set_padding(4, 0, 3, 4)
            align.add(label)
            table.attach(align, 0, 1, size, size + 1)
 
            entry = Gtk::Entry.new
            entry.text = UserVars.op[variable].to_s
            entry.set_width_request(157)
            table.attach(entry, 1, 2, size, size + 1)
 
            $OP_ENTRY[variable] = entry
            $OP_TABLE_SIZE[table] += 1
        end
 
        Gtk.queue {
            $OP_ENTRY = Hash.new
            add_label_entry($OP_TABLE2, "*room id:", 'resting_room_id')
            add_label_entry($OP_TABLE2, "pre-rest commands:", 'resting_commands')
            add_label_entry($OP_TABLE2, "active resting scripts:", 'resting_scripts')
            add_label_entry($OP_TABLE3, "*starting room ID:", 'hunting_room_id')
            add_label_entry($OP_TABLE3, "*boundary rooms:", 'hunting_boundaries')
            add_label_entry($OP_TABLE4, "valid targets:", 'targets')
			add_label_entry($OP_TABLE4, "quickhunt targets:", 'quickhunt_targets')
            add_label_entry($OP_TABLE4, "attack stance:", 'hunting_stance')
            add_label_entry($OP_TABLE4, "pre-hunt commands:", 'hunting_prep_commands')
            add_label_entry($OP_TABLE4, "active hunting scripts:", 'hunting_scripts')
            add_label_entry($OP_TABLE4, "society abilities/spells/cmans:", 'signs')
            add_label_entry($OP_TABLE4, "loot script:", 'loot_script')
            add_label_entry($OP_TABLE4, "wracking spirit >=", 'wracking_spirit')
			add_label_entry($OP_TABLE5, "Ambush aiming locations (head, etc):", 'ambush')
			add_label_entry($OP_TABLE5, "Archery aiming locations (head, etc):", 'archery_aim')
            add_label_entry($OP_TABLE5, "flee if enemy count is >", 'flee_count')
            add_label_entry($OP_TABLE5, "...but don't count these:", 'invalid_targets')
            add_label_entry($OP_TABLE5, "...and always flee from:", 'always_flee_from')
			add_label_entry($OP_TABLE5, "flee from environment message:", 'flee_message')
			add_label_entry($OP_TABLE5, "Wait before wandering to another room:", 'wander_wait')
			add_label_entry($OP_TABLE6, "hunting commands(a):", 'hunting_commands')
            add_label_entry($OP_TABLE6, "hunting commands(b):", 'hunting_commands_b')
            add_label_entry($OP_TABLE6, "hunting commands(c):", 'hunting_commands_c')
			add_label_entry($OP_TABLE6, "hunting commands(d):", 'hunting_commands_d')
			add_label_entry($OP_TABLE6, "hunting commands(e):", 'hunting_commands_e')
			add_label_entry($OP_TABLE6, "hunting commands(f):", 'hunting_commands_f')
			add_label_entry($OP_TABLE6, "hunting commands(g):", 'hunting_commands_g')
			add_label_entry($OP_TABLE6, "hunting commands(h):", 'hunting_commands_h')
			add_label_entry($OP_TABLE6, "hunting commands(i):", 'hunting_commands_i')
			add_label_entry($OP_TABLE6, "hunting commands(j):", 'hunting_commands_j')
            add_label_entry($OP_TABLE6, "fried hunting commands:", 'disable_commands')
			add_label_entry($OP_TABLE6, "quick hunting commands:", 'quick_commands')
			add_label_entry($OP_TABLE7, "Tier 3 Attack", 'tier3')
			add_label_entry($OP_TABLE7, "Aim at location (head, etc)", 'aim')
			add_label_entry($OP_TABLE7, "MSTRIKE when creatures equal or greater", 'uac_mstrike')
			add_label_entry($OP_TABLE8, "MSTRIKE during cooldown stamina requirement", 'mstrike_stamina_cooldown')
			add_label_entry($OP_TABLE8, "QUICKSTRIKE stamina requirement", 'mstrike_stamina_quickstrike')
			add_label_entry($OP_TABLE8, "Unfocused MSTRIKE when creatures equal or greater", 'mstrike_mob')
            add_label_entry($OP_TABLE9, "*when percentmind <=", 'rest_till_exp')
            add_label_entry($OP_TABLE9, "...*and percentmana >=", 'rest_till_mana')
            add_label_entry($OP_TABLE9, "...and CHECKspirit >=", 'rest_till_spirit')
            add_label_entry($OP_TABLE10, "*when percentmind >=", 'fried')
            add_label_entry($OP_TABLE10, "...*or percentmana <=", 'oom')
            add_label_entry($OP_TABLE10, "...or percentencumbrance >=", 'encumbered')
            add_label_entry($OP_TABLE10, "...or wounded eval:", 'wounded_eval')
            add_label_entry($OP_TABLE11, "find ammo in this container:", 'ammo_container')
            add_label_entry($OP_TABLE11, "use this ammo type:", 'ammo')
            add_label_entry($OP_TABLE11, "fresh wand container:", 'fresh_wand_container')
            add_label_entry($OP_TABLE11, "dead wand container:", 'dead_wand_container')
            add_label_entry($OP_TABLE11, "use this wand type:", 'wand')
        }
 
        def self.add_checkbox(table, x_pos, label, variable, default = false)
            size = $OP_TABLE_SIZE[table] || 0
            checkbox = Gtk::CheckButton.new label
            value = UserVars.op[variable].nil? ? default : UserVars.op[variable]
            checkbox.set_active(value)
            table.attach(checkbox, x_pos, x_pos + 1, size, size + 1)
            $OP_ENTRY[variable] = checkbox
            $OP_TABLE_SIZE[table] += 1 if x_pos == 1
        end
 
        Gtk.queue {
            add_checkbox($OP_TABLE1, 0, "Engage deadmans switch", 'dead_man_switch')
            add_checkbox($OP_TABLE1, 1, "Monitor interaction", 'monitor_interaction')
            add_checkbox($OP_TABLE1, 0, "Depart/rerun if dead", 'depart_switch')
            add_checkbox($OP_TABLE1, 1, "Flee from clouds", 'flee_clouds')
			add_checkbox($OP_TABLE1, 1, "Flee from vines", 'flee_vines')
			add_checkbox($OP_TABLE2, 1, "Use Spirit Guide(130) or Voln Symbol of Return to return from hunting ground", 'fog_return')
            add_checkbox($OP_TABLE4, 1, "Use sign of wracking/sigil of power", 'use_wracking')
			add_checkbox($OP_TABLE4, 1, "Priority hunt", 'priority')
            add_checkbox($OP_TABLE5, 1, "Spam attacks (recommended)", 'spam', true)
            add_checkbox($OP_TABLE5, 1, "Approach lone targets only", 'lone_targets_only', false)
			add_checkbox($OP_TABLE5, 1, "Bless weapon?", 'bless', false)
			add_checkbox($OP_TABLE7, 1, "Use Voln SMITE?", 'uac_smite', false)
			add_checkbox($OP_TABLE8, 1, "MSTRIKE during cooldown", 'mstrike_cooldown', false)
			add_checkbox($OP_TABLE8, 1, "Use QUICKSTRIKE for MSTRIKE", 'mstrike_quickstrike', false)
            add_checkbox($OP_TABLE11, 1, "Hide while waiting to pick up ammo", 'hide_for_ammo')
            add_checkbox($OP_TABLE11, 1, "Use wands when out of mana", 'wand_if_oom')
        }
       
        Gtk.queue {
            $OP_WINDOW.signal_connect("delete_event") {
                $OP_SETUP_COMPLETED = true
            }
        }
       
        Gtk.queue {
            $OP_TOOLTIPS = Gtk::Tooltips.new.enable
 
            label = Gtk::Label.new
            label.set_markup("<i>Bigshot is the leader of the Battle Patrol.\nHe comes equipped with a gun as long as his entire superstructure.\nTakes the edge off.\n\n\n***Settings with * are required.***</i>")
            align = Gtk::Alignment.new(1, 0, 0, 0)
            align.set_padding(50, 0, 0, 40)
            align.add(label)
            $OP_TABLE1.attach(align, 1, 2, 8, 9)
 
            commands_tip =  "Example 1: 413 target, 903 target\nExample 2: 903 target(x2)\nExample 3: 903 target(xx)\nExample 4: 910 target(m50), 903 target\nExample 5: unarmed punch, wait 30\nExample 1 will cast 413 then 903 on the target. Example 2 will cast 903 on the target twice. Example 3 will cast 903 on the target until the fight is over. Example 4 will cast 910 if mana is at least 50, otherwise it will cast 903. Example 5 will start the unarmed routine with punch as the main attack. It will attack once, then wait 30 seconds for another attack to happen before attacking again.\nSeparate all commands with commas.\n\nNew feature: 'and'.\nFor example: stance def and 1615 target, kill target(xx)"
            $OP_TOOLTIPS.set_tip($OP_ENTRY['hunting_commands'], commands_tip, "")
            $OP_TOOLTIPS.set_tip($OP_ENTRY['g_hunting_commands'], commands_tip, "")
            $OP_TOOLTIPS.set_tip($OP_ENTRY['g_disable_commands'], commands_tip, "")
 
            signs_tip = "Shadow Mastery - 9603\nSurge of Strength - 9605\n\nSigil of Contact - 9703\nSigil of Resolve - 9704\nSigil of Minor Bane - 9705\nSigil of Defense - 9707\nSigil of Offense - 9708\nSigil of Minor Protection - 9710\nSigil of Focus - 9711\nSigil of Mending - 9713\nSigil of Concentration - 9714\nSigil of Major Bane - 9715\nSigil of Major Determination - 9716\nSigil of Major Protection - 9719\n\nSign of Warding - 9903\nSign of Striking - 9904\nSign of Thought - 9906\nSign of Defending - 9907\nSign of Smiting - 9908\nSign of Staunching - 9909\nSign of Deflection - 9910\nSign of Swords - 9912\nSign of Shields - 9913\nSign of Dissipation - 9914\nSign of Madness - 9916\n\nSymbol of Courage - 9805\nSymbol of Protection - 9806"
            $OP_TOOLTIPS.set_tip($OP_ENTRY['signs'], signs_tip, "")
			
			aim_tip = "Leave blank if you don't want to aim at anything\n\nSuggest leaving chest as last thing to aim at so you will always have something to hit"
			$OP_TOOLTIPS.set_tip($OP_ENTRY['aim'], aim_tip, "")
			$OP_TOOLTIPS.set_tip($OP_ENTRY['archery_aim'], aim_tip, "")
			
			mstrike_tip = "Set this to the highest you want your stamina to be before you MSTRIKE.\nImportant if MSTRIKEing during its cooldown or while using QUICKSTRIKE.\nLeave blank to use max stamina variable instead\nCombination of QUICKSTRIKE and MSTRIKE during cooldown may pop muscles.\nIve done best I can to ensure it doesn't happen, but depends on what you set your MSTRIKE stamina to.\n\nWorks in conjunction with MSTRIKE creature #, so if you meet the requirements for it and not this one you will MSTRIKE and visaversa."
			$OP_TOOLTIPS.set_tip($OP_ENTRY['mstrike_stamina_cooldown'], mstrike_tip, "")
			$OP_TOOLTIPS.set_tip($OP_ENTRY['mstrike_stamina_quickstrike'], mstrike_tip, "")
			
			mstrike_mob_tip = "How many creatures you want in the room before you perform an unfocused MSTRIKE.\nDefault is 2. Set to 1 to always do an unfocused MSTRIKE."
			$OP_TOOLTIPS.set_tip($OP_ENTRY['mstrike_mob'], mstrike_mob_tip, "")
			
			bless_tip = "Will bless whatever item ran out of blessing.\nWill do 304 if known or Symbol of Bless otherwise.\nIf you can do neither of those will rest and exit the script."
			$OP_TOOLTIPS.set_tip($OP_ENTRY['bless'], bless_tip, "")
			
			priority_tip = "Priority is based on order of valid targets box on hunting tab. Will switch to highest priority in room when attacking."
			$OP_TOOLTIPS.set_tip($OP_ENTRY['priority'], priority_tip, "")
			
			smite_tip = "Will SMITE a non-corporeal undead when tier is excellent during UAC Combat"
			$OP_TOOLTIPS.set_tip($OP_ENTRY['uac_smite'], smite_tip, "")
			
			flee_tip = "Input any text that when the game sends you want to move out of the room from\nlike a Roa'ter burrow attack \"You feel a rumble come from beneath your feet.\"\nSeperate different messages with a | in between them."
			$OP_TOOLTIPS.set_tip($OP_ENTRY['flee_message'], flee_tip, "")
 
            size = $OP_TABLE_SIZE[$OP_TABLE3]
            label = Gtk::Label.new
            label.set_markup("<i>Note: Big Shot will not enter boundary rooms. The goal is to pin yourself into a hunting area.</i>")
            align = Gtk::Alignment.new(1, 0, 0, 0)
            align.set_padding(75, 0, 0, 4)
            align.add(label)
            $OP_TABLE3.attach(align, 1, 2, size, size + 1)
 
            size = $OP_TABLE_SIZE[$OP_TABLE4]
            label = Gtk::Label.new
            label.set_markup("<i>Note: Use nouns or name for targets.\nMouse over society abilities field for more info.</i>")
            align = Gtk::Alignment.new(1, 0, 0, 0)
            align.set_padding(10, 0, 0, 300)
            align.add(label)
            $OP_TABLE4.attach(align, 1, 2, size, size + 1)
 
            size = $OP_TABLE_SIZE[$OP_TABLE5]
            label = Gtk::Label.new
            label.set_markup("<i>Note: Use noun or name for flee info.\nMouse over some hunting commands field for more info.</i>")
            align = Gtk::Alignment.new(1, 0, 0, 0)
            align.set_padding(10, 0, 0, 200)
            align.add(label)
            $OP_TABLE5.attach(align, 1, 2, size, size + 1)
			
			size = $OP_TABLE_SIZE[$OP_TABLE8]
            label = Gtk::Label.new
            label.set_markup("1107 and 1607 automatically cast if appropriate when using MSTRIKE\nEmpaths and Paladins rejoice!")
            align = Gtk::Alignment.new(1, 0, 0, 0)
            align.set_padding(75, 0, 0, 75)
            align.add(label)
            $OP_TABLE8.attach(align, 1, 2, size , size + 1)
 
            $OP_WINDOW.show_all
        }
       
        $OP_SETUP_COMPLETED = false
        until($OP_SETUP_COMPLETED)
            sleep 0.5
        end
       
        UserVars.op ||= Hash.new
        $OP_ENTRY.keys.each { |key|
            if( $OP_ENTRY[key].class.to_s =~ /CheckButton/ )
                value = $OP_ENTRY[key].active?
                UserVars.op[key] = $OP_ENTRY[key].active?
            else
                if(key == 'wounded_eval')
                    UserVars.op[key] = $OP_ENTRY[key].text
                else
                    UserVars.op[key] = $OP_ENTRY[key].text.strip.downcase
                end
            end
        }
        UserVars.save()
       
        Gtk.queue {
            $OP_WINDOW.destroy
        }
    end
end

if ( Char.prof =~ /Ranger/i && Spell[630].known? && GameObj.npcs.any?{|i| i.type =~ /companion/} && $companion == nil )
	npcs = GameObj.npcs.find_all { |i| i.type =~ /companion/i }
	npcs.each {|i| 
		res = dothistimeout "lean ##{i.id}", 1, /your direction in acknowledgement|rubbing.*gently|while it is flying|You lean toward/i
		if res =~ /rubbing.*gently/i
			$companion = i.name
			echo "Ranger Companion set to #{i.name}"
			break
		end
	}
end
if ( Char.prof =~ /Wizard/i && Spell[920].known? && GameObj.npcs.any?{|i| i.type =~ /familiar/} )
	res = dothistimeout "tell familiar to return", 1, /You sense understanding from your .*\.|You have no familiar at this time\./i
	if res =~ /You sense understanding from your/i
		res.sub!('You sense understanding from your ','')
		res.gsub!('.','')
		GameObj.npcs.each{|s|
			if s.name =~ /#{res}/i
				$familiar = s.name
				break
			end
		}
		echo "Familiar set as #{$familiar}"
	end
end

if( script.vars[1].nil? || script.vars[1] =~ /solo|(bounty)|quick/i )
	if script.vars[1] =~ /quick/i
		$bigshot_quick = true
	end
    bounty_mode = $1
 
    bs = Bigshot.new(bounty_mode)
    bs.croak('Requires Lich V4') unless defined?(Gtk.queue)
    bs.croak('Requires a mapped room.') if(( Room.current.id.nil? || Room.current.id == 4 ) && !$bigshot_quick)
    bs.lead()
	
elsif( script.vars[1] =~ /setup/i )
    Bigshot.setup()
 
elsif( script.vars[1] =~ /display/i )
    echo "Version: #{BIGSHOT_VERSION}"
    UserVars.op.each_pair { |k, v|
        echo "#{k}: #{v}" unless v.nil? || v.class.to_s == 'Array' || v =~ /^\s*$/
    }
	echo "Targetable Character Setting: #{CharSettings['targetable'].map{|c| c.downcase}.sort{|a,b| a.split(" ").last <=> b.split(" ").last}}"
	echo "Untargetable Character Setting: #{CharSettings['untargetable'].map{|c| c.downcase}.sort{|a,b| a.split(" ").last <=> b.split(" ").last}}"
	
elsif( script.vars[1] =~ /reset/i )
	CharSettings['targetable'] = nil
	CharSettings['untargetable'] = nil
	echo "Character Settings for Targetable and Untargetable are now reset"
	
elsif( script.vars[1] =~ /ranger|companion/i )
	$companion = nil
	echo "Ranger Companion reset"
	
elsif( script.vars[1] =~ /head|lead/i )
    # launch DRb server
    DRb.start_service( nil, Group.new )
    uri = DRb.uri
	
    Thread.new { DRb.thread.join }
 
    # launch DRb client
    DRb.start_service()
    bs = Bigshot.new()
 
    # set leader
    my_group = DRbObject.new( nil, uri )
    my_group.set_leader(bs)
 
    # announce/go
    (1..RALLY_TIME).each { |i| fput "whisper ooc group Explorer rallying at #{uri}"; sleep 1; }
	echo "Waiting for members to join Explorer rally..."
	wait_until{(my_group.size() > 0)}
	pause 3
    bs.lead(my_group)
 
elsif( script.vars[1] =~ /tail|follow/i )
    # Watch for rally
    group = nil
    bs = nil
    while( group.nil? && bs.nil? )
		echo "waiting for rally" if $bigshot_debug
        if( get =~ /rallying at (.*)\."$/ )
 
            # create group
            DRb.start_service()
            group = DRbObject.new( nil, $1 )
 
            # create Bigshot
            bs = Bigshot.new()
            group.add_member(bs)
            bs.keep_awake()
        end
    end
 
    # Participate
    bs.message("Joined group")
    leader = group.leader.name

	bs.groupcheck()
	echo "Groupcheck done" if $bigshot_debug
 
    while(!dead?)
        begin
            bs.change_stance('defensive')
            bs.stand() if !standing?
            sleep 0.25
           
            # grab event
            event = bs.event_stack.size == 0 ? nil : bs.grab_event
            next if event.nil?
           
            # kertwang!
            until( checkpcs.include?(leader) )
                start_script( 'go2', [ group.room_id, '_disable_confirm_' ] )
                wait_while { running?('go2') }
                fput "join #{leader}"
                sleep 1
            end
   
            # process event
            bs.message("event: " + event.type.to_s)
            if( event.type == :HUNTING_PREP_COMMANDS )
				bs.HUNTING_PREP_COMMANDS.each { |i|
					if i =~ /^script\s+(.*?)(\s|$)(.*)/i
					   bs.cmd_run_script( $1, $3 )
					else
						fput(i)
					end
				}
   
            elsif( event.type == :CAST_SIGNS )
                bs.cast_signs()
   
            elsif( event.type == :HUNTING_SCRIPTS_START )
                bs.run_scripts( bs.HUNTING_SCRIPTS, false )
   
            elsif( event.type == :ATTACK )
                if( event.stale? ) # consider timestamp and room_id
                    bs.message("skipping attack because it's stale")
                    next
                end
 
                target = nil
                while( target = bs.find_target(target))
					next if event.type == :PREP_REST
					target = bs.find_target(nil) if not bs.priority(target) && @PRIORITY
                    bs.attack(target)
                end
   
            elsif( event.type == :HUNTING_SCRIPTS_STOP )
                bs.croak_scripts(bs.HUNTING_SCRIPTS)
   
            elsif( event.type == :RESTING_PREP_COMMANDS )
                $bigshot_should_rest = nil # need to reset this
                bs.RESTING_COMMANDS.each { |i| fput(i) }
   
            elsif( event.type == :RESTING_SCRIPTS_START )
                bs.run_scripts( bs.RESTING_SCRIPTS, true )
   
            elsif( event.type == :DISPLAY_WATCH )
                if( event.stale? )
                    bs.message("skipping display_watch because it's stale")
                    next
                end
				fput 'exp'
                bs.message( "Explorer last rested because: #{$rest_reason}" ) if $rest_reason
                bs.message( "Explorer isn't hunting because: #{$not_hunting_reason}" ) if $not_hunting_reason
                sleep( REST_INTERVAL / 10 )
            end
 
        rescue
            fput 'leave group'
            if( bs.RESTING_ROOM_ID && bs.RESTING_ROOM_ID != 4 )
                start_script( 'go2', [ bs.RESTING_ROOM_ID, '_disable_confirm_' ] )
                wait_while { running?('go2') }
            end
            echo "Fatal exception!"
            echo $!.to_s
            echo $!.backtrace.join("\n")
            Script.self.kill
        end
    end
end