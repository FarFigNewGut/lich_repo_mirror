=begin
  Original Wrayth FE Window
    https://discordapp.com/channels/226045346399256576/1339018254517145681

    New GTK Window for Avalon and Wizard FEs
    https://discordapp.com/channels/226045346399256576/1386507836191670342

  This script creates a dedicated window to display creature information and their statuses in real time.

  Features:
  - Continuously updates with current creatures in the room.
  - Displays statuses (stunned, calmed, frozen, held, prone, etc) in a standardized format.
  - Dead creatures are filtered to a separate list to easily identify live targets.
  - Your TARGET is denoted by ** CREATURE ** and display at the top of the live targets.
  - Tracks Avg TTK (Time to Kill) and Last TTK.
  - Displays pertinent bounty task information in order to eliminate built in bounty window.

    Commands:
         *ttk - Enable or disable time to kill information.
         *bty - Enable or disable bounty task information.
         *cwcol - Swap between single and double column layouts.
         *cwgtk - Enable GTK window.

  Changelog:
     1.5.0 (2025-06-25)
           Gtk window now displays clickable targets with statuses.
     1.4.1 (2025-06-25)
           Replaced light/dark mode toggle with gtk palette selector.
     1.4.0 (2025-06-23)
           Added Wizard and Avalon FE compatability via implementation of a GTK window.
     1.3.1 (2025-06-07)
           Column button removed.  Command is *cwcol to swap between single and double column layouts.
					1.3.0 (2025-06-05)
									 	Dead creature output moved back to creaturewindow.
							 			Layout button added to toggle between a one or two column format.
								 		Will save state between sessions for all commands.
					1.2.2 (2025-06-02)
								 		Regex fixes for heirloom searches.
					1.2.1 (2025-05-06)
									 	Regex fixes for great mountain Aenatumgana.
								 		Regex fixes for Moonsedge bounties.
							 			Regex fixes for Old Ta'Faendryl bounties.
					1.2.0 (2025-05-03)
								 		Bounty information added to creaturewindow output. It takes a second to update but if it's not displaying correctly, I'm probably missing the current match from the npc. Just shoot me a DM with what the in-game BOUNTY command tells you.
					1.1.0 (2025-04-26)
								 		Killtracker output removed from creaturewindow and moved to treasurewindow.
					1.0.0 (2025-02-11)
								 		Initial release.

author: Phocosoen, ChatGPT
tags: wrayth, frontend, mod, window, target, creature, mob, bounty, bounties, advguild, adventurer's guild, avalon, wizard, gtk3, buttons, click, links
version: 1.5.0

=end

no_kill_all

require 'yaml'
require 'gtk3'

LICH5_PATHS = [
  "C:\\Lich5\\scripts", #Windows
  File.expand_path("~/Desktop/Lich5/scripts"), #Mac
  File.expand_path("~/OneDrive/Lich5/scripts"),
  "C:\\Users\\#{ENV['USERNAME']}\\OneDrive\\Lich5\\scripts" #Onedrive
]

def window_settings_path
  # Find the first directory that exists in LICH5_PATHS
  base_path = LICH5_PATHS.find { |path| path && Dir.exist?(path) }
  # Use that directory, or fall back to home directory
  settings_dir = base_path || Dir.home
  # Always save in the file "lichwraythwindows.yaml" within that directory
  File.join(settings_dir, "lichwraythwindows.yaml")
end

WINDOW_SETTINGS_PATH = window_settings_path

def load_window_settings
  return {} unless File.exist?(WINDOW_SETTINGS_PATH)
  YAML.load_file(WINDOW_SETTINGS_PATH) || {}
end

def save_window_settings(new_settings)
  settings = File.exist?(WINDOW_SETTINGS_PATH) ? YAML.load_file(WINDOW_SETTINGS_PATH) : {}
  # Merge only the changed window's section
  settings.merge!(new_settings) { |_key, oldval, newval|
    # Deep merge for hashes
    oldval.is_a?(Hash) && newval.is_a?(Hash) ? oldval.merge(newval) : newval
  }
  File.write(WINDOW_SETTINGS_PATH, settings.to_yaml)
rescue => e
  echo "Window settings: failed to save - #{e.message}"
end

$creature_settings       = load_window_settings
$creature_window         = $creature_settings["creaturewindow"] ||= {}
$use_gtk_window = $creature_window["use_gtk_window"] || false
@display_bounty   = $creature_window.fetch("display_bounty",   true) # default _on_ so you see an actual bounty line
@display_avg_ttk  = $creature_window.fetch("display_avg_ttk",  false)
@display_last_ttk = $creature_window.fetch("display_last_ttk", false)

if $use_gtk_window || $frontend != "stormfront"
  respond ""
  respond " Initiating GTK window."
  respond ""
  respond " GTK Creaturewindow is active."
  respond ""
  Gtk.queue { CreatureWindowGtk.create_main_window }
  Gtk.main unless Gtk.main_level > 0
end

if $frontend == "stormfront"
  puts("<closeDialog id='CreatureWindow'/><openDialog type='dynamic' id='CreatureWindow' title='Creatures' target='CreatureWindow' scroll='manual' location='main' justify='3' height='120' resident='true'><dialogData id='CreatureWindow'></dialogData></openDialog>")
end

@last_targets = []
@creature_timestamps = {}
@creature_status_changed = {}
@time_to_kill_list = []
@creature_targeted = {}
@custom_status_cache = {}

CMD_QUEUE = Queue.new

@recent_lines ||= []

# ─── 1) Define your palettes ────────────────────────────────────────────────
PALETTES = {
  "Lich Dark Mode"     => { bg: "#2E2E2E", fg: "#DADADA" },
  "Lich Light Mode"    => { bg: "#E6E6E6", fg: "#202020" },
  "Middle Ground"      => { bg: "#333333", fg: "#FFFFFF" },
  "White on Black"     => { bg: "#000000", fg: "#FFFFFF" },
  "NQWhite on NQBlack" => { bg: "#111111", fg: "#f6f6f6" },
  "Black on White"     => { bg: "#FFFFFF", fg: "#000000" },
}

class CreatureWindowGtk
  @window       = nil
  @css_provider = nil
  @font_size    = nil
  @pending_command = nil
  class << self
    attr_accessor :pending_command
  end
  # ─── 2) Regenerate & apply CSS using the chosen palette ────────────────────
  def self.reload_css
    # Load persisted palette choice (default to “White on Black”)
    settings = load_window_settings
    cw       = settings["creaturewindow"] ||= {}
    pal_name = cw["palette"] || "NQWhite on NQBlack"
    colors   = PALETTES[pal_name]

    css = <<~CSS
      /* window frame */
      window#creaturewindow {
        background-color: #{colors[:bg]};
        color:            #{colors[:fg]};
        border:           0px solid #888888;
        border-radius:    4px;
      }

      window#creaturewindow .palette-btn,
      window#creaturewindow popover .palette-btn,
      window#creaturewindow GtkPopover .palette-btn {
        background: #{colors[:bg]};
        color: #{colors[:fg]};
      }
  #{' '}
      window#creaturewindow .palette-btn:checked {
        background: #{colors[:bg]};
        color: #{colors[:fg]};
      }

      /* header bar */
      window#creaturewindow headerbar {
        background-color: #{colors[:bg]};
        color:            #{colors[:fg]};
      }

      /* header bar buttons / toggles */
      window#creaturewindow headerbar .header-toggle {
        margin:      0 2px;
        padding:     2px 4px;
        background-image: none;
        background-color: transparent;
        color:            #{colors[:fg]};
        border:           none;
        box-shadow:       none;
      }

      /* “on” state for toggles */
      window#creaturewindow headerbar .header-toggle:checked {
        background-color: #0a84ff; /* system blue */
        color:            #FFFFFF;
      }

      /* content labels */
      window#creaturewindow label {
        font-size: #{@font_size}px;
        color:     #{colors[:fg]};
      }

      /* scrolled area & flowbox */
      window#creaturewindow GtkScrolledWindow,
      window#creaturewindow GtkFlowBox {
        background-color: #{colors[:bg]};
      }
  window#creaturewindow .creature-btn,
  window#creaturewindow button.creature-btn {
        background: #{colors[:bg]};
        color: #{colors[:fg]};
    border-radius: 6px;
    border-width: 1px;
    border-style: solid;
    border-color: #888888;
    padding: 5px;
    font-weight: normal;
    transition: background 0.2s;
  }

  window#creaturewindow .creature-btn:active,
  window#creaturewindow button.creature-btn:active {
        background: #{colors[:bg]};
        color: #{colors[:fg]};
  }
    CSS

    @css_provider.load(data: css)
  end

  def self.create_main_window
    return if @window

    # ——— load persisted settings ———
    settings = load_window_settings
    cw       = settings["creaturewindow"] ||= {}
    @font_size = cw["font_size"] || 14
    cw["palette"] || "White on Black"

    # ——— build top‐level window & HeaderBar ———
    @window = Gtk::Window.new(:toplevel)
    @window.set_name("creaturewindow")
    @window.set_border_width(10)
    @window.set_type_hint(Gdk::WindowTypeHint::UTILITY)
    @window.set_keep_above(true)

    header = Gtk::HeaderBar.new
    header.show_close_button = true
    header.title = "CW"

    # — Font size buttons —
    dec_btn = Gtk::Button.new(label: "A−")
    inc_btn = Gtk::Button.new(label: "A+")
    [dec_btn, inc_btn].each do |b|
      b.style_context.add_class("header-toggle")
      header.pack_start(b)
    end
    dec_btn.signal_connect("clicked") do
      @font_size = [@font_size - 1, 8].max
      cw["font_size"] = @font_size; save_window_settings(settings)
      reload_css
    end
    inc_btn.signal_connect("clicked") do
      @font_size = [@font_size + 1, 30].min
      cw["font_size"] = @font_size; save_window_settings(settings)
      reload_css
    end

    # — Palette selector —
    # build your MenuButton
    palette_btn = Gtk::MenuButton.new
    palette_btn.style_context.add_class("header-toggle")
    img = Gtk::Image.new(
      icon_name: "preferences-desktop-color-symbolic",
      icon_size: Gtk::IconSize::SMALL_TOOLBAR
    )
    palette_btn.set_image(img)
    palette_btn.set_always_show_image(true)

    # create the Popover and position it _before_ attaching it
    popover = Gtk::Popover.new(palette_btn)
    popover.set_position(Gtk::PositionType::TOP) # ← do this first

    # now fill your popover
    listbox = Gtk::Box.new(:vertical, 0)
    PALETTES.each_key do |name|
      btn = Gtk::ToggleButton.new(label: name)
      btn.style_context.add_class("header-toggle")
      btn.style_context.add_class("palette-btn")
      btn.active = (name == cw["palette"])
      btn.set_sensitive(true) # <- This ensures it's clickable
					btn.signal_connect("clicked") do
							settings = load_window_settings
							settings["creaturewindow"] ||= {}
							settings["creaturewindow"]["palette"] = name
							save_window_settings(settings)
							reload_css
					end
      listbox.add(btn)
    end
    popover.add(listbox)
    listbox.show_all

    # *only now* attach the popover to the button
    palette_btn.set_popover(popover)

    # and finally pack it into your header
    header.pack_end(palette_btn)

    @window.set_titlebar(header)

    # — CSS provider & initial styling —
    @css_provider = Gtk::CssProvider.new
    reload_css
    screen = Gdk::Screen.default
    Gtk::StyleContext.add_provider_for_screen(
      screen,
      @css_provider,
      Gtk::StyleProvider::PRIORITY_APPLICATION
    )

    # — Restore geometry —
    @window.resize(cw["width"], cw["height"]) if cw["width"] && cw["height"]
    @window.move(cw["x"], cw["y"]) if cw["x"] && cw["y"]

    @scroll = Gtk::ScrolledWindow.new
    @scroll.set_policy(Gtk::PolicyType::AUTOMATIC, Gtk::PolicyType::AUTOMATIC)
    @scroll.set_hexpand(true)
    @scroll.set_vexpand(true)

    @flow = Gtk::FlowBox.new
    @flow.selection_mode        = :none
    @flow.max_children_per_line = 2
    @flow.column_spacing        = 0
    @flow.row_spacing           = 0
    @flow.set_vexpand(true)
    @flow.valign                = Gtk::Align::START
    @flow.homogeneous           = false
    @scroll.add(@flow)

    @bounty_box = Gtk::Box.new(:vertical)
    @bounty_box.set_hexpand(true)
    @bounty_box.set_vexpand(false)
    @bounty_box.set_halign(Gtk::Align::START)
    @bounty_box.set_valign(Gtk::Align::START)
    @bounty_box.hide

    @main_box = Gtk::Box.new(:vertical)
    @main_box.pack_start(@bounty_box, expand: false, fill: true, padding: 0)
    @main_box.pack_start(@scroll, expand: true, fill: true, padding: 0)
    @window.add(@main_box)

    # ─── save geometry on move/resize ────────────────────────────────────
    @ignore_next_configure = true
    @window.signal_connect("configure_event") do |_w, _ev|
      if @ignore_next_configure
        @ignore_next_configure = false
      else
        x, y = @window.position
        w, h = @window.size
        s = load_window_settings
        s["creaturewindow"] ||= {}
        s["creaturewindow"].merge!("x" => x, "y" => y, "width" => w, "height" => h)
        save_window_settings(s)
      end
      false
    end

    # ─── replace the default destroy→Gtk.main_quit handler ───────────────
    # 1) First, connect Gtk.main_quit *yourself* and capture its handler ID:
    default_quit_id = @window.signal_connect("destroy") do
      Gtk.main_quit
    end

    # 2) Immediately disconnect that handler:
    @window.signal_handler_disconnect(default_quit_id)

    # 3) Now install *your* destroy handler that only closes this window:
    @window.signal_connect("destroy") do
      @window = nil
      # NO Gtk.main_quit here!
    end

    @window.show_all
  end # ← end create_main_window

  # -----------------------------------------------------------------------
  # now the updater lives _outside_ of create_main_window
  def self.add_full_row(text = "")
    lbl = Gtk::Label.new(text)
    lbl.set_xalign(0)
    @flow.add(lbl)
    # second column is always a blank label
    @flow.add(Gtk::Label.new(""))
  end

  # ─── completely replace your old update_creatures with this ───
  def self.update_creatures(targets,
                            avg_ttk:,
                            last_ttk:,
                            bounty_task:,
                            bounty_status:,
                            display_avg_ttk:,
                            display_last_ttk:,
                            display_bounty:)
    return unless @window

    Gtk.queue do
      # — first, clear & repopulate bounty_box —
      @bounty_box.each { |c| @bounty_box.remove(c) }
      if display_bounty
        @bounty_box.show
        [bounty_task, bounty_status].each do |txt|
          lbl = Gtk::Label.new(txt)
          lbl.set_xalign(0)
          @bounty_box.add(lbl)
        end

        # <— here:
        @bounty_box.show_all
      else
        @bounty_box.hide
      end

      # 4) Creature count
      @flow.children.each { |c| @flow.remove(c) }
      add_full_row("Creatures: #{targets.size}")

      # 5) Current target
      if (curr = targets.find { |t| t.id == XMLData.current_target_id })
        st   = creature_status_fix(curr.status, curr.name, curr.id)
        txt  = st ? "#{curr.noun.capitalize} (#{st})" : curr.noun.capitalize
        add_full_row("**#{txt}**")
      end

      # Other living creatures as buttons
      (targets - [curr]).each do |t|
        st = creature_status_fix(t.status, t.name, t.id)
        btn_label = st ? "#{t.noun.capitalize} (#{st})" : t.noun.capitalize
        btn = Gtk::Button.new(label: btn_label)
        btn.style_context.add_class("creature-btn")
        btn.signal_connect("clicked") do
          CreatureWindowGtk.pending_command = "target ##{t.id}"
        end
        @flow.add(btn)
      end

      # ── if we’re in the middle of a row, finish it off ──
      if @flow.children.size.odd?
        # push us onto a fresh row for the dead header
        @flow.add(Gtk::Label.new(""))
      end

      # 7) Dead creatures – force a full row for the count, then list
      dead = GameObj.npcs.select { |n| n.status.to_s.downcase == "dead" }
      add_full_row("")
      add_full_row("Dead Creatures: #{dead.size}")
      dead.each do |t|
        lbl = Gtk::Label.new(t.noun.capitalize)
        lbl.set_xalign(0)
        @flow.add(lbl)
      end

      @flow.show_all
    end
  end
end

Thread.new do
  loop do
    begin
      line = get.strip
      @recent_lines << line
      @recent_lines.shift if @recent_lines.size > 25
    rescue => e
      echo "Line monitor error: #{e.message}"
    end
    sleep 0.01
  end
end

def creature_status_fix(status, name = nil, id = nil)
  custom_statuses = []

  if name&.match?(/cold wyrm/i)
    if @recent_lines.any? { |line| line =~ /cold wyrm plummets toward the ground.*radiating wall of devastation/i }
      custom_statuses << "grounded"
    elsif @recent_lines.any? { |line| line =~ /cold wyrm's muscles bunch and she launches herself into the air/i }
      custom_statuses << "airborne"
    elsif @recent_lines.any? { |line| line =~ /Corruscations of color play along a silver-scaled cold wyrm's scaled hide.*disrupting the attack/i }
      custom_statuses << "shielded"
    end

    # Cache logic
    if !custom_statuses.empty? && id
      @custom_status_cache[id] = custom_statuses
    elsif id && @custom_status_cache.key?(id)
      custom_statuses = @custom_status_cache[id]
    end
  end

  standard_status = case status
                    when /calmed|calm/i then "calmed"
                    when /frozen|immobilized|terrified/i then "frozen"
                    when /held/i then "held"
                    when /rooted/i then "rooted"
                    when /unconscious|slumber|sleeping/i then "unconscious"
                    when /webbed|webbing/i then "webbed"
                    when /stunned/i then "stunned"
                    when /prone|lying down|knocked to the ground/i then "prone"
                    when /flying/i then "flying"
                    else nil
                    end

  all_statuses = []
  all_statuses << standard_status if standard_status
  all_statuses.concat(custom_statuses)
  all_statuses.empty? ? nil : all_statuses.join(", ")
end

def calculate_avg_ttk
  return "N/A" if @time_to_kill_list.empty?
  avg_ttk = @time_to_kill_list.sum / @time_to_kill_list.size
  format("%.2f sec", avg_ttk)
end

def track_creature_creature(creature_id, creature_name)
  return unless @creature_timestamps[creature_id]
  return unless @creature_targeted[creature_id]

  time_alive = Time.now - @creature_timestamps[creature_id]
  @time_to_kill_list << time_alive

  @last_kill_time = time_alive
  @last_kill_name = creature_name

  @creature_timestamps.delete(creature_id)
  @creature_targeted.delete(creature_id)
  @custom_status_cache.delete(creature_id)
end

def sanitize_xml(value)
  value.to_s.gsub("&", "&amp;").gsub("<", "&lt;").gsub(">", "&gt;").gsub("'", "&apos;").gsub('"', "&quot;")
end

def parse_bounty_from_checkbounty
  bounty_text = checkbounty

  # Clear everything first
  @bounty_task_type = nil
  @bounty_total = nil
  @bounty_remaining = nil
  @bounty_location = nil
  @bounty_gem = nil
  @bounty_skin = nil
  @bounty_heirloom = nil
  @bounty_target_creature = nil
  @bounty_herb = nil
  @bounty_kills_total = nil
  @bounty_kills_remaining = nil

  if bounty_text =~ /You are not currently assigned a task/i
    @bounty_task_type = :none

  elsif bounty_text =~ /You have located (?:an? |a pair of |some )(.+?) and should bring it back/i
    @bounty_task_type = :completeheirloom
    @bounty_heirloom = bounty_text.match(/You have located (?:an? |a pair of |some )(.+?) and should bring it back/i)[1]

  elsif bounty_text =~ /report back to/i
    @bounty_task_type = :completeguard

  elsif bounty_text =~ /Guild to receive your reward/i
    @bounty_task_type = :completeguild

  elsif bounty_text =~ /task here from the town of (.+?)\.  It appears they have a bandit problem/i
    @bounty_task_type = :bandit
    @bounty_remaining = "Talk to guard for specifics."
    @bounty_location = bounty_text.match(/task here from the town of (.+?)\.  It appears they have a bandit problem/i)[1]

  elsif bounty_text =~ /You have been tasked to suppress bandit activity (?:on|in the|in) (.+?) (?:near|between)/i && bounty_text =~ /You need to kill (\d+)/i
    @bounty_task_type = :banditspecifics
    @bounty_location = bounty_text.match(/You have been tasked to suppress bandit activity (?:on|in the|in) (.+?) (?:near|between)/i)[1]
    @bounty_remaining = bounty_text.match(/You need to kill (\d+)/i)[1].to_i
  # ###################escort
  elsif bounty_text =~ /protective escort/i && bounty_text =~ /safety to (.+?) as/i && bounty_text =~ /(?:inside the |area just |south end )(.+?) and wait/i
    @bounty_task_type = :escort
    @bounty_escort = bounty_text.match(/(?:inside the |area just |south end )(.+?) and wait/i)[1]
    @bounty_location = bounty_text.match(/safety to (.+?) as/i)[1].to_i

  elsif bounty_text =~ /(?:town|outpost) of ([^\.]+)\.\s+The local gem dealer/i
    @bounty_task_type = :gem
    @bounty_remaining = "Talk to gem dealer for specifics."
    @bounty_location = bounty_text.match(/(?:town|outpost) of ([^\.]+)\.\s+The local gem dealer/i)[1]
  # ###################GEM
  elsif bounty_text =~ /The gem dealer in (.+?),/i && bounty_text =~ /The gem dealer in .*? requesting (.+?)\./i && bounty_text =~ /You have been tasked to retrieve (\d+) (?:more )?of them/i
    @bounty_task_type = :gemspecifics
    @bounty_gem = bounty_text.match(/The gem dealer in .*? requesting (.+?)\./i)[1]
    @bounty_remaining = bounty_text.match(/You have been tasked to retrieve (\d+) (?:more )?of them/i)[1].to_i
    @bounty_location = bounty_text.match(/The gem dealer in (.+?),/i)[1]

  elsif bounty_text =~ /task here from the (?:town|outpost) of (.+?)\.  The local .*(?:alchemist|healer|herbalist)/i
    @bounty_task_type = :herb
    @bounty_remaining = "Talk to healer for specifics."
    @bounty_location = bounty_text.match(/task here from the (?:town|outpost) of (.+?)\.  The local .*(?:alchemist|healer)/i)[1]
  # ###################FORAGE
  elsif bounty_text =~ /concoction that requires (?:an?|some) (.+?) found/i && bounty_text =~ /found (?:in|on the) (?:the )?(.+?) near/i && bounty_text =~ /You have been tasked to retrieve (\d+) (?:more )?samples/i
    @bounty_task_type = :herbspecifics
    @bounty_herb = bounty_text.match(/concoction that requires (?:an?|some) (.+?) found/i)[1]
    @bounty_remaining = bounty_text.match(/You have been tasked to retrieve (\d+) (?:more )?samples/i)[1].to_i
    @bounty_location = bounty_text.match(/found (?:in|on the) (?:the )?(.+?) near/i)[1]

  elsif bounty_text =~ /The local furrier .* has an order to fill and wants our help/i && bounty_text =~ /of (.+?)\.  The local furrier/i
    @bounty_task_type = :skin
    @bounty_remaining = "Talk to furrier for specifics."
    @bounty_location = bounty_text.match(/of (.+?)\.  The local furrier/i)[1]
  # ###################SKINNING
  elsif bounty_text =~ /You have been tasked to retrieve (\d+) .* of at/i && bounty_text =~ /retrieve \d+ (.+?) (?:more )?of/i && bounty_text =~ /quality\ for.*?(?:in|on\ the)\s+(.+?)\.\s+You/i
    @bounty_task_type = :skinspecifics
    @bounty_skin = bounty_text.match(/retrieve \d+ (.+?) of/i)[1]
    @bounty_remaining = bounty_text.match(/You have been tasked to retrieve (\d+) .*? (?:more )?of at/i)[1].to_i
    @bounty_location = bounty_text.match(/quality\s+for.*?(?:in|on\ the)\s+(.+?)\.\s+You/i)[1]
  # ###################CREATURE
  elsif bounty_text =~ /It appears they have a creature problem/i && bounty_text =~ /(?:town|outpost) of ([^\.]+)\.\s+It/i
    @bounty_task_type = :creature
    @bounty_remaining = "Talk to guard for specifics."
    @bounty_location = bounty_text.match(/(?:town|outpost) of ([^\.]+)\.\s+It/i)[1]
  # ###################DANGEROUS
  elsif bounty_text =~ /hunt down and kill a particularly dangerous (.+?) that has/i && bounty_text =~ /(?:activity|territory) (?:in|on the) (?:the )?(.+?)(?: near)?\./i
    @bounty_task_type = :dangerous
    @bounty_target_creature = bounty_text.match(/hunt down and kill a particularly dangerous (.+?) that has/i)[1]
    @bounty_location = bounty_text.match(/(?:activity|territory) (?:in|on the) (?:the )?(.+?)(?: near)?\./i)[1]
    @bounty_kills_total = nil
    @bounty_kills_remaining = nil
  # ###################KILL
  elsif bounty_text =~ /(?:tasked to|by) (?:.* )?(?:suppressing|suppress) (.+?) activity/i && bounty_text =~ /You need to kill (\d+)/i && bounty_text =~ /(?:activity|territory) (?:in|on the) (?:the )?(.+?)(?: near)?\./i
    @bounty_task_type = :kill
    @bounty_target_creature = bounty_text.match(/(?:tasked to|by) (?:.* )?(?:suppressing|suppress) (.+?) activity/i)[1]
    @bounty_remaining = bounty_text.match(/You need to kill (\d+)/i)[1].to_i
    @bounty_location = bounty_text.match(/(?:activity|territory) (?:in|on the) (?:the )?(.+?)(?: near)?\./i)[1]

  elsif bounty_text =~ /It appears (?:that a local resident|they need your help in tracking down some king of lost heirloom)/i && bounty_text =~ /(?:town|outpost) of ([^\.]+)\.\s+It/i
    @bounty_task_type = :resident
    @bounty_remaining = "Talk to guard for specifics."
    @bounty_location = bounty_text.match(/(?:town|outpost) of ([^\.]+)\.\s+It/i)[1]
  # ###################RESCUE
  elsif bounty_text =~ /rescue/i && bounty_text =~ /the child fleeing from an? (.+?) in/i && bounty_text =~ /(?:in|on the) (?:the )?(.+?) near/i
    @bounty_task_type = :rescue
    @bounty_target_creature = bounty_text.match(/the child fleeing from an? (.+?) in/i)[1]
    @bounty_location = bounty_text.match(/(?:in|on the) (?:the )?(.+?) near/i)[1]

  elsif bounty_text =~ /(?:town|outpost) of (.+?)\.  It appears they need your help in tracking down some kind of lost heirloom/i
    @bounty_task_type = :heirloom
    @bounty_remaining = "Talk to guard for specifics."
    @bounty_location = bounty_text.match(/(?:town|outpost) of (.+?)\.  It appears they need your help in tracking down some kind of lost heirloom/i)[1]
  # ###################HEIRLOOM KILL
  elsif bounty_text =~ /tasked to recover (?:an|a pair of|a|some) (.+?) that/i &&
        bounty_text =~ /attacked by an? (.+?) (?:in the |in |on the )(.+?) (?: near)?/i &&
        bounty_text =~ /hunt down/i
    @bounty_task_type = :heirloomkill
    @bounty_heirloom = bounty_text.match(/tasked to recover (?:an|a pair of|a|some) (.+?) that/i)[1]
    creature_match = bounty_text.match(/attacked by an? (.+?) (?:in the |in |on the )(.+?) (?: near)?/i)
    @bounty_target_creature = creature_match[1]
    @bounty_location = creature_match[2]
  # ###################HEIRLOOM SEARCH
  elsif bounty_text =~ /tasked to recover (?:an|a pair of|a|some) (.+?) that/i &&
        bounty_text =~ /attacked by an? (.+?) (?:in the |in |on the )(.+?) (?: near)?/i &&
        bounty_text =~ /search/i
    @bounty_task_type = :heirloomsearch
    @bounty_heirloom = bounty_text.match(/tasked to recover (?:an|a pair of|a|some) (.+?) that/i)[1]
    creature_match = bounty_text.match(/attacked by an? (.+?) (?:in the |in |on the )(.+?) (?: near)?/i)
    @bounty_target_creature = creature_match[1]
    @bounty_location = creature_match[2]
  end
end

def bounty_task_line
  case @bounty_task_type
  when :bandit
    "#{@bounty_location} - Bandit Bounty"
  when :banditspecifics
    "#{@bounty_location} - Bandit Bounty"
  when :escort
    "Escort - #{@bounty_location}"
  when :gem
    "#{@bounty_location} - Gem Bounty"
  when :gemspecifics
    "#{@bounty_location} - Gem Bounty"
  when :herb
    "#{@bounty_location} - Foraging Bounty"
  when :herbspecifics
    "#{@bounty_location} - Foraging Bounty"
  when :skin
    "#{@bounty_location} - Skinning Bounty"
  when :skinspecifics
    "#{@bounty_location} - Skinning Bounty"
  when :creature
    "#{@bounty_location} - Creature Bounty"
  when :kill
    "#{@bounty_location} - Culling Bounty"
  when :dangerous
    "#{@bounty_location} - Dangerous Bounty"
  when :resident
    "#{@bounty_location} - Resident Bounty"
  when :rescue
    "#{@bounty_location} - Rescue Bounty"
  when :heirloom
    "#{@bounty_location} - Heirloom Bounty"
  when :heirloomkill
    "Find - #{@bounty_heirloom}"
  when :heirloomsearch
    "Find - #{@bounty_heirloom}"
  when :completeheirloom
    "Found! - #{@bounty_heirloom}"
  when :completeguard
    "Task Complete!"
  when :completeguild
    "Task Complete!"
  else
    "No Bounty"
  end
end

def bounty_status_line
  case @bounty_task_type
  when :bandit
    "#{@bounty_remaining}"
  when :banditspecifics
    "Kill #{@bounty_remaining} - Bandit"
  when :escort
    "Start - #{@bounty_escort}"
  when :gem
    "#{@bounty_remaining}"
  when :gemspecifics
    "Find #{@bounty_remaining} - #{@bounty_gem}"
  when :herb
    "#{@bounty_remaining}"
  when :herbspecifics
    "Find #{@bounty_remaining} - #{@bounty_herb}"
  when :skin
    "#{@bounty_remaining}"
  when :skinspecifics
    "Find #{@bounty_remaining} - #{@bounty_skin}"
  when :creature
    "#{@bounty_remaining}"
  when :kill
    "Kill #{@bounty_remaining} - #{@bounty_target_creature}"
  when :dangerous
    "Kill - #{@bounty_target_creature}"
  when :resident
    "#{@bounty_remaining}"
  when :rescue
    "Kill - #{@bounty_target_creature}"
  when :heirloom
    "#{@bounty_remaining}"
  when :heirloomkill
    "Kill - #{@bounty_target_creature}"
  when :heirloomsearch
    "Search Near - #{@bounty_target_creature}"
  when :completeheirloom
    "Return it to the guard!"
  when :completeguard
    "Report to the guard!"
  when :completeguild
    "Report to the guild!"
  else
    ""
  end
end

def completed_amount
  return 0 unless @bounty_total
  @bounty_total - (@bounty_remaining || 0)
end

def push_creatures_to_window(targets)
  curr_target_id = XMLData.current_target_id
  output = "<dialogData id='CreatureWindow' clear='t' >"

  current_top = 0

  # Column layout toggle
  # column_value = @cwsingle_column ? 'Layout: Single Column' : 'Layout: Two Columns'
  # column_cmd = "*cwcolumns"
  # output += "<link id='column_toggle' value='#{column_value}' cmd='#{column_cmd}' echo='Toggling Column Layout...' justify='bottom' left='0' top='#{current_top}' />"
  # current_top += 20

  # Avg TTK
  if @display_avg_ttk
    avg_ttk_display = calculate_avg_ttk
    output += "<label id='ttk' value='Avg TTK: #{avg_ttk_display}' justify='left' left='0' top='#{current_top}' />"
    current_top += 20
  end

  # Last TTK
  if @display_last_ttk
    last_ttk_display = @last_kill_time ? format("%.2f sec", @last_kill_time) : "N/A"
    output += "<label id='last_ttk' value='Last TTK: #{last_ttk_display}' justify='left' left='0' top='#{current_top}' />"
    current_top += 20

    if @last_kill_name
      output += "<label id='last_kill_name' value='(#{@last_kill_name})' justify='left' left='0' top='#{current_top}' />"
      current_top += 20
    end

    #    output += "<label id='div1' value='--------------------------------------' justify='left' left='0' top='#{current_top}' />"
  end

  # Bounty info
  if @display_bounty && (line = bounty_task_line)
    output += "<label id='bounty_type' value='#{sanitize_xml(line)}' justify='left' left='0' top='#{current_top}' wrap='true' />"
    current_top += 20
  end

  if @display_bounty && (line = bounty_status_line)
    output += "<label id='bounty_status' value='#{sanitize_xml(line)}' justify='left' left='0' top='#{current_top}' wrap='true' />"
    current_top += 20

    #    output += "<label id='div2' value='--------------------------------------' justify='left' left='0' top='#{current_top}' />"
  end

  # Creature count
  output += "<label id='total' value='Creatures: #{targets.size}' justify='left' left='0' top='#{current_top}' />"
  current_top += 20

  # Separate and render current target first
  target_creature = targets.find { |t| t.id == curr_target_id }
  other_creatures = targets.reject { |t| t.id == curr_target_id }

  if target_creature
    status = creature_status_fix(target_creature.status, target_creature.name, target_creature.id)
    label_value = status ? "#{target_creature.noun.capitalize} (#{status})" : target_creature.noun.capitalize
    label_value = "**#{label_value}**"

    unless @creature_targeted[target_creature.id]
      @creature_timestamps[target_creature.id] = Time.now
      @creature_targeted[target_creature.id] = true
    end

    cmd = "target ##{target_creature.id}"
    output += "<link id='target_creature' value='#{sanitize_xml(label_value)}' cmd='#{cmd}' echo='Targeting #{sanitize_xml(target_creature.name)}' justify='left' left='0' top='#{current_top}' />"
    current_top += 20 # Add a little extra space after target for clarity
  end

  # Creature grid
  row_height = 20
  col_left = 0
  col_right = 180
  top_offset = current_top / row_height

  creature_pairs = @cwsingle_column ? other_creatures.each_slice(1) : other_creatures.each_slice(2)

  creature_pairs.with_index do |pair, row|
    pair.each_with_index do |creature, col|
      (other_creatures.size.to_f / (@cwsingle_column ? 1 : 2)).ceil

      noun = creature.noun.capitalize
      status = creature_status_fix(creature.status, creature.name, creature.id)

      label_value = status ? "#{noun} (#{status})" : noun
      label_id = "creature_#{row}_#{col}"

      left = col == 0 ? col_left : col_right
      top = row_height * (row + top_offset)

      cmd = "target ##{creature.id}"
      output += "<link id='#{label_id}' value='#{sanitize_xml(label_value)}' cmd='#{cmd}' echo='Targeting #{sanitize_xml(creature.name)}' justify='left' left='#{left}' top='#{top}' />"
    end
  end
  # After rendering all creatures, bump spacing by 20px before starting dead creature block
  grid_rows = (other_creatures.size.to_f / (@cwsingle_column ? 1 : 2)).ceil
  current_top = row_height * (grid_rows + top_offset) + 20
  # Track creatures for killed/removed creatures
  current_ids = targets.map(&:id)
  (@creature_timestamps.keys - current_ids).each do |missing_id|
    creature_name = GameObj.npcs.find { |npc| npc.id == missing_id }&.name || "Unknown"
    track_creature_creature(missing_id, creature_name)
  end

  # Dead creature listing
  dead_creatures = GameObj.npcs.select { |t| t.status.to_s.downcase == 'dead' }

  output += "<label id='deadcount' value='Dead Creatures: #{dead_creatures.size}' left='0' top='#{current_top}' />"
  current_top += 20

  if @cwsingle_column
    dead_creatures.each_with_index do |t, index|
      noun = t.noun.capitalize
      output += "<link id='dead_#{index}' value='#{noun}' cmd='loot ##{t.id}' echo='loot ##{t.id}' justify='bottom' left='0' top='#{current_top}' />"

      current_top += 20
    end
  else
    row_height = 20
    col_left = 0
    col_right = 180
    dead_creatures.each_slice(2).with_index do |pair, row|
      pair.each_with_index do |t, col|
        left = col == 0 ? col_left : col_right
        top = current_top + row * row_height
        noun = t.noun.capitalize
        output += "<link id='dead_#{row}_#{col}' value='#{noun}' cmd='loot ##{t.id}' echo='loot ##{t.id}' justify='bottom' left='#{left}' top='#{top}' />"
      end
    end
    current_top += ((dead_creatures.size + 1) / 2) * row_height
  end


  output += "</dialogData>"
  puts(output)
end

UPSTREAM_HOOK_ID = "#{Script.current.name}_upstream".freeze
UpstreamHook.remove(UPSTREAM_HOOK_ID) rescue nil

UpstreamHook.add(UPSTREAM_HOOK_ID, proc do |command|
  window_settings = load_window_settings
  window_settings["creaturewindow"] ||= {}

  case command
  when /\*bty/i
    @display_bounty = !@display_bounty
    window_settings["creaturewindow"]["display_bounty"] = @display_bounty
    save_window_settings(window_settings)
    CMD_QUEUE.push("update_window")
    respond "Bounty display: #{@display_bounty ? 'ON' : 'OFF'}"
    nil

  when /\*ttk/i
    @display_avg_ttk = !@display_avg_ttk
    @display_last_ttk = !@display_last_ttk
    window_settings["creaturewindow"]["display_avg_ttk"] = @display_avg_ttk
    window_settings["creaturewindow"]["display_last_ttk"] = @display_last_ttk
    save_window_settings(window_settings)
    CMD_QUEUE.push("update_window")
    respond "Average TTK display: #{@display_avg_ttk ? 'ON' : 'OFF'}"
    respond "Last TTK display: #{@display_last_ttk ? 'ON' : 'OFF'}"
    nil

  when /\*cwcol/i
    @cwsingle_column = !@cwsingle_column
    window_settings["creaturewindow"]["single_column"] = @cwsingle_column
    save_window_settings(window_settings)
    CMD_QUEUE.push("update_window")
    respond "Column Layout: #{@cwsingle_column ? 'Single' : 'Double'}"
    nil

  when /\*cwgtk/i
    $use_gtk_window = !$use_gtk_window
    respond "GTK Creaturewindow is now #{$use_gtk_window ? 'ENABLED' : 'DISABLED'}."

    # persist the new setting
    settings = load_window_settings
    settings["creaturewindow"] ||= {}
    settings["creaturewindow"]["use_gtk_window"] = $use_gtk_window
    save_window_settings(settings)

    if $use_gtk_window
      # launch it if not already up
      Gtk.queue do
        CreatureWindowGtk.create_main_window
        Gtk.main
      end
    else
      # close it if it exists
      if defined?(CreatureWindowGtk) && CreatureWindowGtk.instance_variable_get(:@window)
        Gtk.queue do
          CreatureWindowGtk.instance_variable_get(:@window).hide
        end
      end
    end

    nil

  else
    command
  end
end)

before_dying do
  UpstreamHook.remove("#{Script.current.name}_upstream")

  if defined?(CreatureWindowGtk) && (cw = CreatureWindowGtk.instance_variable_get(:@window))
    Gtk.queue { cw.hide }
  end
end

echo "Creaturewindow is active." if $frontend == "stormfront"

parse_bounty_from_checkbounty
@last_bounty_check ||= Time.now

loop do
  current_targets = GameObj.targets

  # — when the target list actually changes —
  if current_targets != @last_targets
    @last_targets = current_targets

    # old Wrayth window
    push_creatures_to_window(current_targets) if $frontend == "stormfront"

    # new GTK window
    if $use_gtk_window
      # wherever you call update_creatures:
      CreatureWindowGtk.update_creatures(
        current_targets,
        avg_ttk: calculate_avg_ttk,
        last_ttk: @last_kill_time ? format("%.2f sec", @last_kill_time) : "N/A",
        bounty_task: bounty_task_line,
        bounty_status: bounty_status_line,
        display_avg_ttk: @display_avg_ttk,
        display_last_ttk: @display_last_ttk,
        display_bounty: @display_bounty
      )

    end
  end

  # — when you flip one of the toggles via commands —
  unless CMD_QUEUE.empty?
    cmd = CMD_QUEUE.pop
    if cmd == "update_window"
      push_creatures_to_window(@last_targets) if $frontend == "stormfront"
      if $use_gtk_window
        # wherever you call update_creatures:
        CreatureWindowGtk.update_creatures(
          current_targets,
          avg_ttk: calculate_avg_ttk,
          last_ttk: @last_kill_time ? format("%.2f sec", @last_kill_time) : "N/A",
          bounty_task: bounty_task_line,
          bounty_status: bounty_status_line,
          display_avg_ttk: @display_avg_ttk,
          display_last_ttk: @display_last_ttk,
          display_bounty: @display_bounty
        )

      end
    end
  end

  # — periodic bounty refresh —
  if Time.now - @last_bounty_check > 5
    parse_bounty_from_checkbounty
    CMD_QUEUE.push("update_window")

    # also refresh GTK immediately
    if $use_gtk_window
      # wherever you call update_creatures:
      CreatureWindowGtk.update_creatures(
        current_targets,
        avg_ttk: calculate_avg_ttk,
        last_ttk: @last_kill_time ? format("%.2f sec", @last_kill_time) : "N/A",
        bounty_task: bounty_task_line,
        bounty_status: bounty_status_line,
        display_avg_ttk: @display_avg_ttk,
        display_last_ttk: @display_last_ttk,
        display_bounty: @display_bounty
      )

    end

    @last_bounty_check = Time.now
  end
  if CreatureWindowGtk.pending_command
    cmd = CreatureWindowGtk.pending_command
    CreatureWindowGtk.pending_command = nil
    Thread.new do
      fput cmd
      # Optionally: trigger a window update after fput completes if the targets list hasn't changed
      if $use_gtk_window
        Gtk.queue do
          CreatureWindowGtk.update_creatures(
            GameObj.targets,
            avg_ttk: calculate_avg_ttk,
            last_ttk: @last_kill_time ? format("%.2f sec", @last_kill_time) : "N/A",
            bounty_task: bounty_task_line,
            bounty_status: bounty_status_line,
            display_avg_ttk: @display_avg_ttk,
            display_last_ttk: @display_last_ttk,
            display_bounty: @display_bounty
          )
        end
      end
    end
  end

  sleep 0.025
end
