=begin
  Creature Window - Real-Time Creature & Bounty Display

  Creates a dedicated window to display creature information and statuses
  in real time. Supports both Wrayth FE panel and GTK window for Avalon
  and Wizard FEs. Live targets are shown with standardized status indicators
  (stunned, calmed, frozen, held, prone, etc), dead creatures are filtered
  to a separate list, and your current TARGET is highlighted at the top.
  Optionally tracks kill metrics (Avg TTK, Last TTK, KPM) and displays
  bounty task information.

  References:
    Wrayth FE Window: https://discordapp.com/channels/226045346399256576/1339018254517145681
    GTK Window:       https://discordapp.com/channels/226045346399256576/1386507836191670342

  Usage:
    ;creaturewindow              - Start creature window

  In-game Commands (while running):
    *ttk                         - Toggle time-to-kill metrics display
    *bty                         - Toggle bounty task display
    *cwcol                       - Toggle single/double column layout
    *cwgtk                       - Enable GTK window

  Author: Phocosoen, ChatGPT
  Tags: wrayth, frontend, mod, window, target, creature, mob, bounty, advguild, avalon, wizard, gtk3
  Version: 1.6.0
  Recently changed:
    - Added bounty action buttons for workflow automation (guild, guard, furrier, gem, herb, skin).
    - Added gem bounty automation with inventory-aware handling and gemshop routing controls.
    - Added herb bounty automation using zzherb and automated herb turn-in flow.
    - Added skin bounty action that tracks on-hand skin progress and automates furrier turn-in.
    - Added guard-return workflow support that can prep heirloom turn-ins and run scripted return flow.
    - Added turn-in NPC targeting safeguards that avoid invalid NPC types (for example familiars/animates).
	- Added TTK/KPM metrics display support with toggles in the creature window.
=end

no_kill_all

require 'yaml'

module CreatureWindow
  extend self
  include Lich::Common if defined?(Lich::Common)
  BOUNTY_TURNIN_NPC_REGEX = /brother Barnstel|scarred Agarnil kris|healer|herbalist|merchant Kelph|famed baker Leaftoe|Akrash|old Mistress Lomara|dwarven clerk|gem dealer|jeweler|Zirconia|town guard|Gate guard|sergeant|city guardsman|Guardsman|purser|Belle|furrier|Guild Taskmaster|sentry luthrek|fur trader Delosa|bramblefist|Halfwhistle|tavernkeeper|tavern|brindlestoat|Libram Greenleaf|Sparkfinger|Maraene|alchemist/i
  GEM_TURNIN_NPC_REGEX = /gem dealer|jeweler|brindlestoat|zirconia/i
  BLOCKED_GEMSHOP_ROOM_IDS = [3845].freeze
  BLOCKED_GEMSHOP_UIDS = [3201285].freeze
  BLOCKED_GEMSHOP_TITLES = /Etaenia's Jewels/i
  GEMSHOP_UID_BY_TOWN = {
    "Cold River" => "u7503259",
  }.freeze

  class << self
    attr_accessor :settings, :window_settings, :use_gtk_window,
                  :display_bounty, :display_avg_ttk, :display_last_ttk, :display_kpm,
                  :gtk_available, :single_column
  end
end

def CreatureWindow.deep_merge_hash(base, override)
  base.merge(override) do |_k, base_val, override_val|
    if base_val.is_a?(Hash) && override_val.is_a?(Hash)
      CreatureWindow.deep_merge_hash(base_val, override_val)
    else
      override_val
    end
  end
end

CW_DEFAULT_WINDOW_SETTINGS = {
  "creaturewindow" => {
    "single_column"          => false,
    "display_avg_ttk"        => false,
    "display_last_ttk"       => false,
    "display_kpm"            => false,
    "display_bounty"         => true,
    "x"                      => 1440,
    "y"                      => 1600,
    "width"                  => 420,
    "height"                 => 370,
    "font_size"              => 17,
    "use_gtk_creaturewindow" => true,
    "palette"                => "White on Black"
  },
} unless defined?(CW_DEFAULT_WINDOW_SETTINGS)

def CreatureWindow.window_settings_path(name: Char.name)
  # Use $data_dir and XMLData.game for Lich data structure
  base_dir = "#{$data_dir}#{XMLData.game}/#{name}"
  Dir.mkdir("#{$data_dir}#{XMLData.game}") unless File.exist?("#{$data_dir}#{XMLData.game}")
  Dir.mkdir(base_dir) unless File.exist?(base_dir)
  File.join(base_dir, "lichwindows.yaml")
end

def CreatureWindow.load_window_settings(name: Char.name)
  filename = CreatureWindow.window_settings_path(name: name)
  settings_hash = nil

  if File.exist?(filename) && name == Char.name
    begin
      raw = File.read(filename)
      parsed = YAML.safe_load(raw, permitted_classes: [Hash, Array, String, Integer, Float, TrueClass, FalseClass, NilClass], aliases: false)
      parsed = {} unless parsed.is_a?(Hash)
      settings_hash = CreatureWindow.deep_merge_hash(CW_DEFAULT_WINDOW_SETTINGS, parsed)
    rescue => e
      echo "Window settings: Corrupt settings file detected (#{e.message}). Rebuilding defaults..."
      settings_hash = CreatureWindow.deep_merge_hash(CW_DEFAULT_WINDOW_SETTINGS, {})
      File.write(filename, settings_hash.to_yaml)
    end
  elsif !File.exist?(filename) && name != Char.name
    echo "Window settings: Attempt to load a profile (#{name}) that does not exist."
    settings_hash = nil
  elsif !File.exist?(filename) && name == Char.name
    echo "Window settings: No current settings found. Loading defaults..."
    settings_hash = CreatureWindow.deep_merge_hash(CW_DEFAULT_WINDOW_SETTINGS, {})
    File.write(filename, settings_hash.to_yaml)
  else
    echo "Window settings: Unknown error loading profile (#{name})"
    settings_hash = nil
  end

  settings_hash
end

def CreatureWindow.save_window_settings(settings, name: Char.name)
  filename = CreatureWindow.window_settings_path(name: name)
  File.write(filename, settings.to_yaml)
end

CreatureWindow.settings = CreatureWindow.load_window_settings
CreatureWindow.settings ||= CreatureWindow.deep_merge_hash(CW_DEFAULT_WINDOW_SETTINGS, {})
CreatureWindow.window_settings = CreatureWindow.settings["creaturewindow"] ||= {}
CreatureWindow.use_gtk_window = CreatureWindow.window_settings["use_gtk_creaturewindow"] || false
CreatureWindow.display_bounty   = CreatureWindow.window_settings.fetch("display_bounty",   true) # default _on_ so you see an actual bounty line
CreatureWindow.display_avg_ttk  = CreatureWindow.window_settings.fetch("display_avg_ttk",  false)
CreatureWindow.display_last_ttk = CreatureWindow.window_settings.fetch("display_last_ttk", false)
CreatureWindow.display_kpm      = CreatureWindow.window_settings.fetch("display_kpm",      false)
CreatureWindow.single_column    = CreatureWindow.window_settings.fetch("single_column", false)

CreatureWindow.gtk_available = begin
  require 'gtk3'
  true
rescue LoadError => e
  echo "Creaturewindow: GTK unavailable (#{e.message})."
  false
end

def CreatureWindow.gtk_enabled?
  CreatureWindow.gtk_available && CreatureWindow.use_gtk_window
end

def CreatureWindow.start_gtk_main_if_needed
  return unless CreatureWindow.gtk_available
  Gtk.main if Gtk.main_level == 0
end

def CreatureWindow.ensure_runtime_state!
  @cw_recent_lines ||= []
  @cw_creature_timestamps ||= {}
  @cw_creature_targeted ||= {}
  @cw_custom_status_cache ||= {}
  @cw_time_to_kill_list ||= []
  @cw_counted_dead_creature_ids ||= {}
  @cw_owned_room_kill_count ||= 0
  @cw_owned_room_kill_started_at ||= nil
  @cw_last_kill_activity_at ||= nil
  @cw_last_kill_time ||= nil
  @cw_last_kill_name ||= nil
end

def CreatureWindow.push_recent_line(line)
  CreatureWindow.ensure_runtime_state!
  @cw_recent_lines << line
  @cw_recent_lines.shift if @cw_recent_lines.size > 25
end

@cw_startup_request_gtk = (CreatureWindow.use_gtk_window || $frontend != "stormfront")

if $frontend == "stormfront"
  puts("<closeDialog id='CreatureWindow'/><openDialog type='dynamic' id='CreatureWindow' title='Creatures' target='CreatureWindow' scroll='manual' location='main' justify='3' height='120' resident='true'><dialogData id='CreatureWindow'></dialogData></openDialog>")
end

@cw_last_targets = []
@cw_last_targets_snapshot = nil
@cw_last_ui_refresh_at = Time.at(0)
@cw_creature_timestamps = {}
@cw_creature_status_changed = {}
@cw_time_to_kill_list = []
@cw_owned_room_kill_count = 0
@cw_owned_room_kill_started_at = nil
@cw_counted_dead_creature_ids = {}
@cw_last_kill_activity_at = nil
@cw_creature_targeted = {}
@cw_custom_status_cache = {}
@cw_bounty_origin_room_id = Room.current.id
@cw_bounty_origin_npc_id = nil
@cw_bounty_origin_npc_noun = nil
@cw_herb_workflow_running = false
@cw_guild_workflow_running = false
@cw_guard_workflow_running = false
@cw_furrier_workflow_running = false
@cw_skin_workflow_running = false

CreatureWindow::CMD_QUEUE = Queue.new unless defined?(CreatureWindow::CMD_QUEUE)
CreatureWindow::TARGET_CMD_QUEUE = Queue.new unless defined?(CreatureWindow::TARGET_CMD_QUEUE)

@cw_recent_lines ||= []

# --- 1) Define your palettes ------------------------------------------------
CreatureWindow::PALETTES = {
  "Lich Dark Mode"     => { bg: "#2E2E2E", fg: "#DADADA" },
  "Lich Light Mode"    => { bg: "#E6E6E6", fg: "#202020" },
  "Middle Ground"      => { bg: "#333333", fg: "#FFFFFF" },
  "White on Black"     => { bg: "#000000", fg: "#FFFFFF" },
  "NQWhite on NQBlack" => { bg: "#111111", fg: "#f6f6f6" },
  "Black on White"     => { bg: "#FFFFFF", fg: "#000000" },
} unless defined?(CreatureWindow::PALETTES)

class CreatureWindowGtk
  @window       = nil
  @css_provider = nil
  @font_size    = nil
  # --- 2) Regenerate & apply CSS using the chosen palette --------------------
  def self.reload_css
    # Load persisted palette choice (default to "White on Black")
    settings = CreatureWindow.load_window_settings
    cw       = settings["creaturewindow"] ||= {}
    pal_name = cw["palette"] || "White on Black"
    colors   = CreatureWindow::PALETTES[pal_name]

    css = <<~CSS
      /* window frame */
      window#creaturewindow {
        background-color: #{colors[:bg]};
        color:            #{colors[:fg]};
        border:           0px solid #888888;
        border-radius:    4px;
      }

      window#creaturewindow .palette-btn,
      window#creaturewindow popover .palette-btn,
      window#creaturewindow GtkPopover .palette-btn {
        background: #{colors[:bg]};
        color: #{colors[:fg]};
      }

      window#creaturewindow .palette-btn:checked {
        background: #{colors[:bg]};
        color: #{colors[:fg]};
      }

      /* header bar */
      window#creaturewindow headerbar {
        background-color: #{colors[:bg]};
        color:            #{colors[:fg]};
      }

      /* header bar buttons / toggles */
      window#creaturewindow headerbar .header-toggle {
        margin:      0 2px;
        padding:     2px 4px;
        background-image: none;
        background-color: transparent;
        color:            #{colors[:fg]};
        border:           none;
        box-shadow:       none;
      }

      /* "on" state for toggles */
      window#creaturewindow headerbar .header-toggle:checked {
        background-color: #0a84ff; /* system blue */
        color:            #FFFFFF;
      }

      /* content labels */
      window#creaturewindow label {
        font-size: #{@font_size}px;
        color:     #{colors[:fg]};
      }

      /* scrolled area & flowbox */
      window#creaturewindow GtkScrolledWindow,
      window#creaturewindow GtkFlowBox {
        background-color: #{colors[:bg]};
      }
  window#creaturewindow .creature-btn,
  window#creaturewindow button.creature-btn {
        background: #{colors[:bg]};
        color: #{colors[:fg]};
    border-radius: 6px;
    border-width: 1px;
    border-style: solid;
    border-color: #888888;
    padding: 5px;
    font-weight: normal;
    transition: background 0.2s;
  }

  window#creaturewindow .creature-btn:active,
  window#creaturewindow button.creature-btn:active {
        background: #{colors[:bg]};
        color: #{colors[:fg]};
  }
    CSS

    @css_provider.load(data: css)
  end

  def self.create_main_window
    return if @window

    # --- load persisted settings ---
    settings = CreatureWindow.load_window_settings
    cw       = settings["creaturewindow"] ||= {}
    @font_size = cw["font_size"] || 14
    cw["palette"] || "White on Black"

    # --- build top-level window & HeaderBar ---
    @window = Gtk::Window.new(:toplevel)
    @window.set_name("creaturewindow")
    @window.set_border_width(10)
    @window.set_type_hint(Gdk::WindowTypeHint::UTILITY)
    @window.set_keep_above(true)

    header = Gtk::HeaderBar.new
    header.show_close_button = true
    header.title = "CW"

    # - Font size buttons -
    dec_btn = Gtk::Button.new(label: "A-")
    inc_btn = Gtk::Button.new(label: "A+")
    [dec_btn, inc_btn].each do |b|
      b.style_context.add_class("header-toggle")
      header.pack_start(b)
    end
    dec_btn.signal_connect("clicked") do
      @font_size = [@font_size - 1, 8].max
      cw["font_size"] = @font_size; CreatureWindow.save_window_settings(settings)
      reload_css
    end
    inc_btn.signal_connect("clicked") do
      @font_size = [@font_size + 1, 30].min
      cw["font_size"] = @font_size; CreatureWindow.save_window_settings(settings)
      reload_css
    end

    # - Palette selector -
    # build your MenuButton
    palette_btn = Gtk::MenuButton.new
    palette_btn.style_context.add_class("header-toggle")
    img = Gtk::Image.new(
      icon_name: "preferences-desktop-color-symbolic",
      icon_size: Gtk::IconSize::SMALL_TOOLBAR
    )
    palette_btn.set_image(img)
    palette_btn.set_always_show_image(true)

    # create the Popover and position it _before_ attaching it
    popover = Gtk::Popover.new(palette_btn)
    popover.set_position(Gtk::PositionType::TOP) # <- do this first

    # now fill your popover
    listbox = Gtk::Box.new(:vertical, 0)
    CreatureWindow::PALETTES.each_key do |name|
      btn = Gtk::ToggleButton.new(label: name)
      btn.style_context.add_class("header-toggle")
      btn.style_context.add_class("palette-btn")
      btn.active = (name == cw["palette"])
      btn.set_sensitive(true) # <- This ensures it's clickable
      btn.signal_connect("clicked") do
        settings = CreatureWindow.load_window_settings
        settings["creaturewindow"] ||= {}
        settings["creaturewindow"]["palette"] = name
        CreatureWindow.save_window_settings(settings)
        reload_css
      end
      listbox.add(btn)
    end
    popover.add(listbox)
    listbox.show_all

    # *only now* attach the popover to the button
    palette_btn.set_popover(popover)

    # and finally pack it into your header
    header.pack_end(palette_btn)

    @window.set_titlebar(header)

    # - CSS provider & initial styling -
    @css_provider = Gtk::CssProvider.new
    reload_css
    screen = Gdk::Screen.default
    Gtk::StyleContext.add_provider_for_screen(
      screen,
      @css_provider,
      Gtk::StyleProvider::PRIORITY_APPLICATION
    )

    # - Restore geometry -
    @window.resize(cw["width"], cw["height"]) if cw["width"] && cw["height"]
    @window.move(cw["x"], cw["y"]) if cw["x"] && cw["y"]

    @scroll = Gtk::ScrolledWindow.new
    @scroll.set_policy(Gtk::PolicyType::AUTOMATIC, Gtk::PolicyType::AUTOMATIC)
    @scroll.set_hexpand(true)
    @scroll.set_vexpand(true)

    @flow = Gtk::FlowBox.new
    @flow.selection_mode        = :none
    @flow.max_children_per_line = (CreatureWindow.single_column ? 1 : 2)
    @flow.column_spacing        = 0
    @flow.row_spacing           = 0
    @flow.set_vexpand(true)
    @flow.valign                = Gtk::Align::START
    @flow.homogeneous           = false
    @scroll.add(@flow)

    @cw_bounty_box = Gtk::Box.new(:vertical)
    @cw_bounty_box.set_hexpand(true)
    @cw_bounty_box.set_vexpand(false)
    @cw_bounty_box.set_halign(Gtk::Align::START)
    @cw_bounty_box.set_valign(Gtk::Align::START)
    @cw_bounty_box.hide

    @main_box = Gtk::Box.new(:vertical)
    @main_box.pack_start(@cw_bounty_box, expand: false, fill: true, padding: 0)
    @main_box.pack_start(@scroll, expand: true, fill: true, padding: 0)
    @window.add(@main_box)

    # --- save geometry on move/resize ------------------------------------
    @ignore_next_configure = true
    @window.signal_connect("configure_event") do |_w, _ev|
      if @ignore_next_configure
        @ignore_next_configure = false
      else
        x, y = @window.position
        w, h = @window.size
        s = CreatureWindow.load_window_settings
        s["creaturewindow"] ||= {}
        s["creaturewindow"].merge!("x" => x, "y" => y, "width" => w, "height" => h)
        CreatureWindow.save_window_settings(s)
      end
      false
    end

    # --- replace the default destroy->Gtk.main_quit handler ---------------
    # 1) First, connect Gtk.main_quit *yourself* and capture its handler ID:
    default_quit_id = @window.signal_connect("destroy") do
      Gtk.main_quit
    end

    # 2) Immediately disconnect that handler:
    @window.signal_handler_disconnect(default_quit_id)

    # 3) Now install *your* destroy handler that only closes this window:
    @window.signal_connect("destroy") do
      @window = nil
      # NO Gtk.main_quit here!
    end

    @window.show_all
  end # <- end create_main_window

  # -----------------------------------------------------------------------
  # now the updater lives _outside_ of create_main_window
  def self.add_full_row(text = "")
    lbl = Gtk::Label.new(text)
    lbl.set_xalign(0)
    @flow.add(lbl)
    # Add blank filler only in two-column mode.
    @flow.add(Gtk::Label.new("")) unless CreatureWindow.single_column
  end

  # --- completely replace your old update_creatures with this ---
  def self.update_creatures(targets,
                            avg_ttk:,
                            last_ttk:,
                            kpm:,
                            bounty_task:,
                            bounty_status:,
                            bounty_action:,
                            display_avg_ttk:,
                            display_last_ttk:,
                            display_kpm:,
                            display_bounty:)
    return unless @window

    Gtk.queue do
      @flow.max_children_per_line = (CreatureWindow.single_column ? 1 : 2)

      # - first, clear & repopulate bounty_box -
      @cw_bounty_box.each { |c| @cw_bounty_box.remove(c) }
      if display_bounty
        @cw_bounty_box.show
        [bounty_task, bounty_status].each do |txt|
          lbl = Gtk::Label.new(txt)
          lbl.set_xalign(0)
          @cw_bounty_box.add(lbl)
        end
        if bounty_action
          action_btn = Gtk::Button.new(label: bounty_action)
          action_btn.style_context.add_class("creature-btn")
          action_btn.signal_connect("clicked") do
            action_cmd = CreatureWindow.bounty_action_cmd
            if action_cmd == "*cwgem"
              CreatureWindow::CMD_QUEUE.push("run_gem_bounty_workflow")
            elsif action_cmd == "*cwherb"
              CreatureWindow::CMD_QUEUE.push("run_herb_bounty_workflow")
            elsif action_cmd == "*cwguild"
              CreatureWindow::CMD_QUEUE.push("run_guild_bounty_workflow")
            elsif action_cmd == "*cwguard"
              CreatureWindow::CMD_QUEUE.push("run_guard_bounty_workflow")
            elsif action_cmd == "*cwfurrier"
              CreatureWindow::CMD_QUEUE.push("run_furrier_bounty_workflow")
            elsif action_cmd == "*cwskin"
              CreatureWindow::CMD_QUEUE.push("run_skin_bounty_workflow")
            end
          end
          @cw_bounty_box.add(action_btn)
        end

        # <-- here:
        @cw_bounty_box.show_all
      else
        @cw_bounty_box.hide
      end

      # 4) Creature count
      @flow.children.each { |c| @flow.remove(c) }
      add_full_row("Creatures: #{targets.size}")

      if display_avg_ttk
        add_full_row("Avg TTK: #{avg_ttk}")
      end

      if display_last_ttk
        add_full_row("Last TTK: #{last_ttk}")
      end

      if display_kpm
        add_full_row("Kills/Min: #{kpm}")
      end

      # 5) Current target
      if (curr = targets.find { |t| t.id == XMLData.current_target_id })
        st   = CreatureWindow.creature_status_fix(curr.status, curr.name, curr.id)
        txt  = st ? "#{curr.noun} (#{st})" : curr.noun.to_s
        add_full_row("**#{txt}**")
      end

      # Other living creatures as buttons
      (targets - [curr]).each do |t|
        st = CreatureWindow.creature_status_fix(t.status, t.name, t.id)
        btn_label = st ? "#{t.noun} (#{st})" : t.noun.to_s
        btn = Gtk::Button.new(label: btn_label)
        btn.style_context.add_class("creature-btn")
        btn.signal_connect("clicked") do
          CreatureWindow::TARGET_CMD_QUEUE << "target ##{t.id}"
        end
        @flow.add(btn)
      end

      # -- if we're in the middle of a row, finish it off --
      if @flow.children.size.odd?
        # push us onto a fresh row for the dead header
        @flow.add(Gtk::Label.new(""))
      end

      # 7) Dead creatures - force a full row for the count, then list
      dead = GameObj.npcs.select { |n| n.status.to_s.downcase == "dead" }
      add_full_row("")
      add_full_row("Dead Creatures: #{dead.size}")
      dead.each do |t|
        lbl = Gtk::Label.new(t.noun.to_s)
        lbl.set_xalign(0)
        @flow.add(lbl)
      end

      @flow.show_all
    end
  end
end

if @cw_startup_request_gtk
  if CreatureWindow.gtk_available
    respond ""
    respond " Initiating GTK window."
    respond ""
    respond " GTK Creaturewindow is active."
    respond ""
    Gtk.queue { CreatureWindowGtk.create_main_window }
    Thread.new { CreatureWindow.start_gtk_main_if_needed }
  else
    CreatureWindow.use_gtk_window = false
    CreatureWindow.window_settings["use_gtk_creaturewindow"] = false
    CreatureWindow.save_window_settings(CreatureWindow.settings)
    respond ""
    respond " GTK Creaturewindow disabled: gtk3 gem not available."
    respond ""
  end
end

def CreatureWindow.creature_status_fix(status, name = nil, id = nil)
  CreatureWindow.ensure_runtime_state!
  custom_statuses = []

  if name&.match?(/cold wyrm/i)
    if @cw_recent_lines.any? { |line| line =~ /cold wyrm plummets toward the ground.*radiating wall of devastation/i }
      custom_statuses << "grounded"
    elsif @cw_recent_lines.any? { |line| line =~ /cold wyrm's muscles bunch and she launches herself into the air/i }
      custom_statuses << "airborne"
    elsif @cw_recent_lines.any? { |line| line =~ /Corruscations of color play along a silver-scaled cold wyrm's scaled hide.*disrupting the attack/i }
      custom_statuses << "shielded"
    end

    # Cache logic
    if !custom_statuses.empty? && id
      @cw_custom_status_cache[id] = custom_statuses
    elsif id && @cw_custom_status_cache.key?(id)
      custom_statuses = @cw_custom_status_cache[id]
    end
  end

  standard_status = case status
                    when /calmed|calm/i then "calmed"
                    when /frozen|immobilized|terrified/i then "frozen"
                    when /held/i then "held"
                    when /rooted/i then "rooted"
                    when /unconscious|slumber|sleeping/i then "unconscious"
                    when /webbed|webbing/i then "webbed"
                    when /stunned/i then "stunned"
                    when /prone|lying down|knocked to the ground/i then "prone"
                    when /flying/i then "flying"
                    else nil
                    end

  all_statuses = []
  all_statuses << standard_status if standard_status
  all_statuses.concat(custom_statuses)
  all_statuses.empty? ? nil : all_statuses.join(", ")
end

def CreatureWindow.calculate_avg_ttk
  CreatureWindow.ensure_runtime_state!
  return "N/A" if @cw_time_to_kill_list.empty?
  avg_ttk = @cw_time_to_kill_list.sum / @cw_time_to_kill_list.size
  format("%.2f sec", avg_ttk)
end

def CreatureWindow.register_kill_activity
  CreatureWindow.ensure_runtime_state!
  @cw_last_kill_activity_at = Time.now
end

def CreatureWindow.reset_kill_metrics_if_inactive(dead_creatures, inactivity_seconds: 300)
  CreatureWindow.ensure_runtime_state!
  return if @cw_last_kill_activity_at.nil?
  return if (Time.now - @cw_last_kill_activity_at) < inactivity_seconds

  @cw_time_to_kill_list.clear
  @cw_last_kill_time = nil
  @cw_last_kill_name = nil
  @cw_owned_room_kill_count = 0
  @cw_owned_room_kill_started_at = nil
  @cw_counted_dead_creature_ids = dead_creatures.to_h { |creature| [creature.id, Time.now] }
  @cw_last_kill_activity_at = nil
end

def CreatureWindow.claim_owned_room?
  defined?(Lich::Claim) && Lich::Claim.mine?
rescue StandardError
  false
end

def CreatureWindow.track_owned_room_kills(dead_creatures)
  CreatureWindow.ensure_runtime_state!
  return unless CreatureWindow.claim_owned_room?

  @cw_owned_room_kill_started_at ||= Time.now
  current_dead_ids = dead_creatures.map(&:id)

  dead_creatures.each do |creature|
    creature_id = creature.id
    next if @cw_counted_dead_creature_ids.key?(creature_id)

    @cw_counted_dead_creature_ids[creature_id] = Time.now
    @cw_owned_room_kill_count += 1
    CreatureWindow.register_kill_activity
  end

  @cw_counted_dead_creature_ids.delete_if { |creature_id, _| !current_dead_ids.include?(creature_id) }
end

def CreatureWindow.calculate_owned_room_kpm
  CreatureWindow.ensure_runtime_state!
  kill_count = @cw_owned_room_kill_count.to_i
  return "N/A" if @cw_owned_room_kill_started_at.nil? || kill_count.zero?

  elapsed_minutes = (Time.now - @cw_owned_room_kill_started_at) / 60.0
  return "N/A" if elapsed_minutes <= 0

  format("%.2f (%d)", kill_count / elapsed_minutes, kill_count)
end

def CreatureWindow.track_creature_creature(creature_id, creature_name)
  CreatureWindow.ensure_runtime_state!
  return unless @cw_creature_timestamps[creature_id]
  return unless @cw_creature_targeted[creature_id]

  time_alive = Time.now - @cw_creature_timestamps[creature_id]
  @cw_time_to_kill_list << time_alive

  @cw_last_kill_time = time_alive
  @cw_last_kill_name = creature_name
  CreatureWindow.register_kill_activity

  @cw_creature_timestamps.delete(creature_id)
  @cw_creature_targeted.delete(creature_id)
  @cw_custom_status_cache.delete(creature_id)
end

def CreatureWindow.sanitize_xml(value)
  value.to_s.gsub("&", "&amp;").gsub("<", "&lt;").gsub(">", "&gt;").gsub("'", "&apos;").gsub('"', "&quot;")
end

def CreatureWindow.parse_bounty_from_checkbounty
  bounty_text = checkbounty

  # Clear everything first
  @cw_bounty_task_type = nil
  @cw_bounty_total = nil
  @cw_bounty_remaining = nil
  @cw_bounty_location = nil
  @cw_bounty_gem = nil
  @cw_bounty_skin = nil
  @cw_bounty_heirloom = nil
  @cw_bounty_target_creature = nil
  @cw_bounty_herb = nil
  @cw_bounty_kills_total = nil
  @cw_bounty_kills_remaining = nil
  @cw_bounty_turnin_npc = nil

  if bounty_text =~ /You are not currently assigned a task/i
    @cw_bounty_task_type = :none

  elsif bounty_text =~ /You have located (?:an? |a pair of |some )(.+?) and should bring/i
    @cw_bounty_task_type = :completeheirloom
    @cw_bounty_heirloom = bounty_text.match(/You have located (?:an? |a pair of |some )(.+?) and should bring/i)[1]

  elsif bounty_text =~ /report back to/i
    @cw_bounty_task_type = :completeguard
    @cw_bounty_turnin_npc = bounty_text.match(/report back to (.+?)\./i)&.[](1)

  elsif bounty_text =~ /Guild to receive your reward/i
    @cw_bounty_task_type = :completeguild
  elsif bounty_text =~ /(visit|head|go|return)\s+(?:to\s+)?the Adventurer'?s Guild/i ||
        bounty_text =~ /talk to (?:the )?Guild Taskmaster/i
    @cw_bounty_task_type = :guildvisit

  elsif bounty_text =~ /task here from the town of (.+?)\.  It appears they have a bandit problem/i
    @cw_bounty_task_type = :bandit
    @cw_bounty_remaining = "Talk to guard for specifics."
    @cw_bounty_location = bounty_text.match(/task here from the town of (.+?)\.  It appears they have a bandit problem/i)[1]

  elsif bounty_text =~ /You have been tasked to suppress bandit activity (?:on|in the|in) (.+?) (?:near|between)/i && bounty_text =~ /You need to kill (\d+)/i
    @cw_bounty_task_type = :banditspecifics
    @cw_bounty_location = bounty_text.match(/You have been tasked to suppress bandit activity (?:on|in the|in) (.+?) (?:near|between)/i)[1]
    @cw_bounty_remaining = bounty_text.match(/You need to kill (\d+)/i)[1].to_i
  # ###################escort
  elsif bounty_text =~ /protective escort/i && bounty_text =~ /safety to (.+?) as/i && bounty_text =~ /(?:inside the |area just |south end )(.+?) and wait/i
    @cw_bounty_task_type = :escort
    @cw_bounty_escort = bounty_text.match(/(?:inside the |area just |south end )(.+?) and wait/i)[1]
    @cw_bounty_location = bounty_text.match(/safety to (.+?) as/i)[1]

  elsif bounty_text =~ /(?:town|outpost) of ([^\.]+)\.\s+The local gem dealer/i
    @cw_bounty_task_type = :gem
    @cw_bounty_remaining = "Talk to gem dealer for specifics."
    @cw_bounty_location = bounty_text.match(/(?:town|outpost) of ([^\.]+)\.\s+The local gem dealer/i)[1]
  # ###################GEM
  elsif bounty_text =~ /The gem dealer in (.+?),/i && bounty_text =~ /The gem dealer in .*? requesting (.+?)\./i && bounty_text =~ /You have been tasked to retrieve (\d+) (?:more )?of them/i
    @cw_bounty_task_type = :gemspecifics
    @cw_bounty_gem = bounty_text.match(/The gem dealer in .*? requesting (.+?)\./i)[1]
    @cw_bounty_remaining = bounty_text.match(/You have been tasked to retrieve (\d+) (?:more )?of them/i)[1].to_i
    @cw_bounty_location = bounty_text.match(/The gem dealer in (.+?),/i)[1]

  elsif bounty_text =~ /task here from the (?:town|outpost) of (.+?)\.  The local .*(?:alchemist|healer|herbalist)/i
    @cw_bounty_task_type = :herb
    @cw_bounty_remaining = "Talk to healer for specifics."
    @cw_bounty_location = bounty_text.match(/task here from the (?:town|outpost) of (.+?)\.  The local .*(?:alchemist|healer)/i)[1]
  # ###################FORAGE
  elsif bounty_text =~ /working on a concoction that requires (?:an?|a handful of|some)\s+(.+?)(?:\s+found\s+in|\.)/i &&
        bounty_text =~ /retrieve (\d+)\s+(?:more\s+)?sample(?:s)?/i
    @cw_bounty_task_type = :herbspecifics
    @cw_bounty_herb = bounty_text.match(/working on a concoction that requires (?:an?|a handful of|some)\s+(.+?)(?:\s+found\s+in|\.)/i)[1]
    @cw_bounty_remaining = bounty_text.match(/retrieve (\d+)\s+(?:more\s+)?sample(?:s)?/i)[1].to_i
    @cw_bounty_location = bounty_text.match(/found in (?:the )?(.+?) near/i)&.[](1) ||
                          bounty_text.match(/only grows in (?:the )?(.+?) near/i)&.[](1) ||
                          @cw_bounty_location
  elsif bounty_text =~ /concoction that requires (?:an?|some) (.+?) found/i && bounty_text =~ /found (?:in|on the) (?:the )?(.+?) near/i && bounty_text =~ /You have been tasked to retrieve (\d+) (?:more )?sample(?:s)?/i
    @cw_bounty_task_type = :herbspecifics
    @cw_bounty_herb = bounty_text.match(/concoction that requires (?:an?|some) (.+?) found/i)[1]
    @cw_bounty_remaining = bounty_text.match(/You have been tasked to retrieve (\d+) (?:more )?sample(?:s)?/i)[1].to_i
    @cw_bounty_location = bounty_text.match(/found (?:in|on the) (?:the )?(.+?) near/i)[1]

  elsif bounty_text =~ /The local furrier .* has an order to fill and wants our help/i && bounty_text =~ /of (.+?)\.  The local furrier/i
    @cw_bounty_task_type = :skin
    @cw_bounty_remaining = "Talk to furrier for specifics."
    @cw_bounty_location = bounty_text.match(/of (.+?)\.  The local furrier/i)[1]
  # ###################SKINNING
  elsif bounty_text =~ /You have been tasked to retrieve (\d+) .* of at/i && bounty_text =~ /retrieve \d+ (.+?) of at least/i && bounty_text =~ /quality\ for.*?(?:in|on\ the)\s+(.+?)\.\s+You/i
    @cw_bounty_task_type = :skinspecifics
    @cw_bounty_skin = bounty_text.match(/retrieve \d+ (.+?) of at least/i)[1]
    @cw_bounty_remaining = bounty_text.match(/You have been tasked to retrieve (\d+) .*? (?:more )?of at/i)[1].to_i
    @cw_bounty_location = bounty_text.match(/quality\s+for.*?(?:in|on\ the)\s+(.+?)\.\s+You/i)[1]
  # ###################CREATURE
  elsif bounty_text =~ /It appears they have a creature problem/i && bounty_text =~ /(?:town|outpost) of ([^\.]+)\.\s+It/i
    @cw_bounty_task_type = :creature
    @cw_bounty_remaining = "Talk to guard for specifics."
    @cw_bounty_location = bounty_text.match(/(?:town|outpost) of ([^\.]+)\.\s+It/i)[1]
  # ###################DANGEROUS
  elsif bounty_text =~ /hunt down and kill a particularly dangerous (.+?) that has/i && bounty_text =~ /(?:activity|territory) (?:in|on the) (?:the )?(.+?)(?: near)?\./i
    @cw_bounty_task_type = :dangerous
    @cw_bounty_target_creature = bounty_text.match(/hunt down and kill a particularly dangerous (.+?) that has/i)[1]
    @cw_bounty_location = bounty_text.match(/(?:activity|territory) (?:in|on the) (?:the )?(.+?)(?: near)?\./i)[1]
    @cw_bounty_kills_total = nil
    @cw_bounty_kills_remaining = nil
  # ###################KILL
  elsif bounty_text =~ /(?:tasked to|by) (?:.* )?(?:suppressing|suppress) (.+?) activity/i && bounty_text =~ /You need to kill (\d+)/i && bounty_text =~ /(?:activity|territory) (?:in|on the) (?:the )?(.+?)(?: near)?\./i
    @cw_bounty_task_type = :kill
    @cw_bounty_target_creature = bounty_text.match(/(?:tasked to|by) (?:.* )?(?:suppressing|suppress) (.+?) activity/i)[1]
    @cw_bounty_remaining = bounty_text.match(/You need to kill (\d+)/i)[1].to_i
    @cw_bounty_location = bounty_text.match(/(?:activity|territory) (?:in|on the) (?:the )?(.+?)(?: near)?\./i)[1]

  elsif bounty_text =~ /It appears (?:that a local resident|they need your help in tracking down some king of lost heirloom)/i && bounty_text =~ /(?:town|outpost) of ([^\.]+)\.\s+It/i
    @cw_bounty_task_type = :resident
    @cw_bounty_remaining = "Talk to guard for specifics."
    @cw_bounty_location = bounty_text.match(/(?:town|outpost) of ([^\.]+)\.\s+It/i)[1]
  # ###################RESCUE
  elsif bounty_text =~ /rescue/i && bounty_text =~ /the child fleeing from an? (.+?) in/i && bounty_text =~ /(?:in|on the) (?:the )?(.+?) near/i
    @cw_bounty_task_type = :rescue
    @cw_bounty_target_creature = bounty_text.match(/the child fleeing from an? (.+?) in/i)[1]
    @cw_bounty_location = bounty_text.match(/(?:in|on the) (?:the )?(.+?) near/i)[1]

  elsif bounty_text =~ /(?:town|outpost) of (.+?)\.  It appears they need your help in tracking down some kind of lost heirloom/i
    @cw_bounty_task_type = :heirloom
    @cw_bounty_remaining = "Talk to guard for specifics."
    @cw_bounty_location = bounty_text.match(/(?:town|outpost) of (.+?)\.  It appears they need your help in tracking down some kind of lost heirloom/i)[1]
  # ###################HEIRLOOM KILL
  elsif bounty_text =~ /tasked to recover (?:an|a pair of|a|some) (.+?) that/i &&
        bounty_text =~ /attacked by an? (.+?) (?:in the |in |on the )(.+?) (?: near)?/i &&
        bounty_text =~ /hunt down/i
    @cw_bounty_task_type = :heirloomkill
    @cw_bounty_heirloom = bounty_text.match(/tasked to recover (?:an|a pair of|a|some) (.+?) that/i)[1]
    creature_match = bounty_text.match(/attacked by an? (.+?) (?:in the |in |on the )(.+?) (?: near)?/i)
    @cw_bounty_target_creature = creature_match[1]
    @cw_bounty_location = creature_match[2]
  # ###################HEIRLOOM SEARCH
  elsif bounty_text =~ /tasked to recover (?:an|a pair of|a|some) (.+?) that/i &&
        bounty_text =~ /attacked by an? (.+?) (?:in the |in |on the )(.+?) (?: near)?/i &&
        bounty_text =~ /search/i
    @cw_bounty_task_type = :heirloomsearch
    @cw_bounty_heirloom = bounty_text.match(/tasked to recover (?:an|a pair of|a|some) (.+?) that/i)[1]
    creature_match = bounty_text.match(/attacked by an? (.+?) (?:in the |in |on the )(.+?) (?: near)?/i)
    @cw_bounty_target_creature = creature_match[1]
    @cw_bounty_location = creature_match[2]
  end
end

def CreatureWindow.bounty_task_line
  case @cw_bounty_task_type
  when :bandit
    "#{@cw_bounty_location} - Bandit Bounty"
  when :banditspecifics
    "#{@cw_bounty_location} - Bandit Bounty"
  when :escort
    "Escort - #{@cw_bounty_location}"
  when :gem
    "#{@cw_bounty_location} - Gem Bounty"
  when :gemspecifics
    "#{@cw_bounty_location} - Gem Bounty"
  when :herb
    "#{@cw_bounty_location} - Foraging Bounty"
  when :herbspecifics
    "#{@cw_bounty_location} - Foraging Bounty"
  when :skin
    "#{@cw_bounty_location} - Skinning Bounty"
  when :skinspecifics
    "#{@cw_bounty_location} - Skinning Bounty"
  when :creature
    "#{@cw_bounty_location} - Creature Bounty"
  when :kill
    "#{@cw_bounty_location} - Culling Bounty"
  when :dangerous
    "#{@cw_bounty_location} - Dangerous Bounty"
  when :resident
    "#{@cw_bounty_location} - Resident Bounty"
  when :rescue
    "#{@cw_bounty_location} - Rescue Bounty"
  when :heirloom
    "#{@cw_bounty_location} - Heirloom Bounty"
  when :heirloomkill
    "Find - #{@cw_bounty_heirloom}"
  when :heirloomsearch
    "Find - #{@cw_bounty_heirloom}"
  when :completeheirloom
    "Found! - #{@cw_bounty_heirloom}"
  when :completeguard
    "Task Complete!"
  when :completeguild
    "Task Complete!"
  when :guildvisit
    "Guild Bounty"
  else
    "No Bounty"
  end
end

def CreatureWindow.bounty_status_line
  case @cw_bounty_task_type
  when :bandit
    "#{@cw_bounty_remaining}"
  when :banditspecifics
    "Kill #{@cw_bounty_remaining} - Bandit"
  when :escort
    "Start - #{@cw_bounty_escort}"
  when :gem
    "#{@cw_bounty_remaining}"
  when :gemspecifics
    "Find #{@cw_bounty_remaining} - #{@cw_bounty_gem}"
  when :herb
    "#{@cw_bounty_remaining}"
  when :herbspecifics
    "Find #{@cw_bounty_remaining} - #{@cw_bounty_herb}"
  when :skin
    "#{@cw_bounty_remaining}"
  when :skinspecifics
    "Find #{@cw_bounty_remaining} - #{@cw_bounty_skin}"
  when :creature
    "#{@cw_bounty_remaining}"
  when :kill
    "Kill #{@cw_bounty_remaining} - #{@cw_bounty_target_creature}"
  when :dangerous
    "Kill - #{@cw_bounty_target_creature}"
  when :resident
    "#{@cw_bounty_remaining}"
  when :rescue
    "Kill - #{@cw_bounty_target_creature}"
  when :heirloom
    "#{@cw_bounty_remaining}"
  when :heirloomkill
    "Kill - #{@cw_bounty_target_creature}"
  when :heirloomsearch
    "Search Near - #{@cw_bounty_target_creature}"
  when :completeheirloom
    "Return it to the guard!"
  when :completeguard
    if @cw_bounty_turnin_npc && !@cw_bounty_turnin_npc.empty?
      "Report to #{@cw_bounty_turnin_npc}"
    else
      "Report to the guard!"
    end
  when :completeguild
    "Report to the guild!"
  when :guildvisit
    "Visit the Adventurer's Guild"
  else
    ""
  end
end

def CreatureWindow.bounty_state_signature
  [
    @cw_bounty_task_type,
    @cw_bounty_total,
    @cw_bounty_remaining,
    @cw_bounty_location,
    @cw_bounty_gem,
    @cw_bounty_skin,
    @cw_bounty_heirloom,
    @cw_bounty_target_creature,
    @cw_bounty_herb,
    @cw_bounty_turnin_npc
  ]
end

def CreatureWindow.refresh_bounty_ui
  CreatureWindow.parse_bounty_from_checkbounty
  CreatureWindow::CMD_QUEUE.push("update_window")
  @cw_last_bounty_check = Time.now
end

def CreatureWindow.ask_bounty_and_sync(npc, use_put: false, timeout: 1.5, interval: 0.15)
  return false unless npc

  before = CreatureWindow.bounty_state_signature
  ask_cmd = "ask ##{npc.id} about bounty"
  use_put ? put(ask_cmd) : fput(ask_cmd)

  changed = false
  deadline = Time.now + timeout
  loop do
    CreatureWindow.refresh_bounty_ui
    if CreatureWindow.bounty_state_signature != before
      changed = true
      break
    end
    break if Time.now >= deadline
    sleep interval
  end

  changed
end

def CreatureWindow.bounty_action_line
  if @cw_bounty_task_type == :none
    return "Guild Run Active..." if @cw_guild_workflow_running
    return "Get New Bounty (AdvGuild)"
  end

  if [:herb, :herbspecifics].include?(@cw_bounty_task_type)
    return "Herb Run Active..." if @cw_herb_workflow_running
    return "Forage Herbs (zzherb) and Turn In"
  end

  if [:gem, :gemspecifics].include?(@cw_bounty_task_type)
    return "Gem Run Active..." if @cw_herb_workflow_running
    return "Gem Bounty Workflow"
  end

  if [:guildvisit, :completeguild].include?(@cw_bounty_task_type)
    return "Guild Run Active..." if @cw_guild_workflow_running
    return "Go to AdvGuild and Ask About Bounty"
  end

  if @cw_bounty_task_type == :skin
    return "Furrier Run Active..." if @cw_furrier_workflow_running
    return "Go to Furrier and Ask About Bounty"
  end

  if @cw_bounty_task_type == :skinspecifics
    return "Skin Run Active..." if @cw_skin_workflow_running
    summary = CreatureWindow.skin_inventory_breakdown
    required = @cw_bounty_remaining.to_i
    required = 1 if required < 1
    return "Turn In Skins (#{summary[:singles]} singles, #{summary[:bundles]} bundles / need #{required})"
  end

  if [:bandit, :creature, :resident, :heirloom, :completeguard, :completeheirloom].include?(@cw_bounty_task_type)
    return "Guard Run Active..." if @cw_guard_workflow_running
    return "Go to AdvGuard and Ask About Bounty"
  end

  nil
end

def CreatureWindow.bounty_action_cmd
  return "*cwguild" if @cw_bounty_task_type == :none
  return "*cwherb" if [:herb, :herbspecifics].include?(@cw_bounty_task_type)
  return "*cwgem" if [:gem, :gemspecifics].include?(@cw_bounty_task_type)
  return "*cwguild" if [:guildvisit, :completeguild].include?(@cw_bounty_task_type)
  return "*cwfurrier" if @cw_bounty_task_type == :skin
  return "*cwskin" if @cw_bounty_task_type == :skinspecifics
  return "*cwguard" if [:bandit, :creature, :resident, :heirloom, :completeguard, :completeheirloom].include?(@cw_bounty_task_type)

  nil
end

def CreatureWindow.npc_is_invalid_turnin_target?(npc)
  return true unless npc

  status = npc.respond_to?(:status) ? npc.status.to_s.downcase : ""
  type = npc.respond_to?(:type) ? npc.type.to_s.downcase : ""
  name = npc.name.to_s.downcase

  return true if status =~ /dead|gone/
  return true if type =~ /companion|familiar|pet/
  return true if name =~ /\bfamiliar\b/
  return true if name =~ /\banimated\b/ && name !~ /animated slush/

  false
end

def CreatureWindow.stop_active_nonhidden_scripts_for_turnin
  Script.running
        .find_all do |scr|
          scr &&
            scr != Script.current &&
            !scr.no_kill_all &&
            scr.name.to_s.downcase != "go2"
        end
        .each { |scr| scr.kill }
end

def CreatureWindow.heirloom_item_for_turnin
  heirloom_name = @cw_bounty_heirloom.to_s.strip
  return nil if heirloom_name.empty?

  candidates = []
  GameObj.inv.each do |item|
    next unless item

    candidates << item
    if item.respond_to?(:contents) && item.contents
      item.contents.each { |contained| candidates << contained if contained }
    end
  end

  candidates.find { |i| CreatureWindow.item_matches_bounty_name?(i.name.to_s, heirloom_name) }
end

def CreatureWindow.get_heirloom_for_turnin
  item = CreatureWindow.heirloom_item_for_turnin
  return unless item

  fput "get ##{item.id}"
end

def CreatureWindow.find_guild_taskmaster
  GameObj.npcs.find { |n| n && !CreatureWindow.npc_is_invalid_turnin_target?(n) && n.name.to_s =~ /Guild Taskmaster|taskmaster/i }
end

def CreatureWindow.prepare_turnin_hands
  put "stow all"
rescue StandardError
  nil
end

def CreatureWindow.run_guild_bounty_workflow
  return if @cw_guild_workflow_running

  @cw_guild_workflow_running = true
  begin
    CreatureWindow.stop_active_nonhidden_scripts_for_turnin

    Script.run("go2", "advguild")
    sleep 0.2 while running?("go2")
    CreatureWindow.prepare_turnin_hands

    npc = CreatureWindow.find_origin_turnin_npc
    npc ||= CreatureWindow.find_guild_taskmaster
    if npc
      CreatureWindow.ask_bounty_and_sync(npc)
    else
      respond "Creaturewindow: could not find a valid guild bounty NPC here."
    end
  rescue StandardError => e
    respond "Creaturewindow guild workflow error: #{e.class} - #{e.message}"
  ensure
    @cw_guild_workflow_running = false
    CreatureWindow.refresh_bounty_ui
  end
end

def CreatureWindow.find_advguard_npc
  if @cw_bounty_turnin_npc && !@cw_bounty_turnin_npc.to_s.empty?
    npc = GameObj.npcs.find do |n|
      n && !CreatureWindow.npc_is_invalid_turnin_target?(n) && n.name.to_s.downcase.include?(@cw_bounty_turnin_npc.to_s.downcase)
    end
    return npc if npc
  end

  npc = GameObj.npcs.find do |n|
    n && !CreatureWindow.npc_is_invalid_turnin_target?(n) &&
      n.name.to_s =~ /(?:^|\s)(?:town guard|gate guard|sergeant|city guardsman|guardsman|sentry|tavernkeeper)\b/i
  end
  npc ||= GameObj.npcs.find { |n| n && !CreatureWindow.npc_is_invalid_turnin_target?(n) && n.name.to_s =~ /Guild Taskmaster|taskmaster/i }
  npc
end

def CreatureWindow.find_current_turnin_npc
  GameObj.npcs.find do |n|
    n && !CreatureWindow.npc_is_invalid_turnin_target?(n) &&
      n.name.to_s =~ CreatureWindow::BOUNTY_TURNIN_NPC_REGEX
  end
end

def CreatureWindow.run_guard_bounty_workflow
  return if @cw_guard_workflow_running

  @cw_guard_workflow_running = true
  begin
    CreatureWindow.stop_active_nonhidden_scripts_for_turnin

    Script.run("go2", "advguard")
    sleep 0.2 while running?("go2")
    CreatureWindow.prepare_turnin_hands

    CreatureWindow.get_heirloom_for_turnin if @cw_bounty_task_type == :completeheirloom

    npc = CreatureWindow.find_advguard_npc
    npc ||= CreatureWindow.find_current_turnin_npc
    if npc
      CreatureWindow.ask_bounty_and_sync(npc)
    else
      respond "Creaturewindow: could not find a valid bounty NPC here."
    end
  rescue StandardError => e
    respond "Creaturewindow guard workflow error: #{e.class} - #{e.message}"
  ensure
    @cw_guard_workflow_running = false
    CreatureWindow.refresh_bounty_ui
  end
end

def CreatureWindow.find_furrier_npc
  GameObj.npcs.find do |n|
    n && !CreatureWindow.npc_is_invalid_turnin_target?(n) &&
      n.name.to_s =~ /furrier|fur trader|Bramblefist|Delosa|Dagresar/i
  end
end

def CreatureWindow.find_healer_bounty_npc
  GameObj.npcs.find do |n|
    n && !CreatureWindow.npc_is_invalid_turnin_target?(n) &&
      n.name.to_s =~ /alchemist|healer|herbalist|Sparkfinger|Maraene/i
  end
end

def CreatureWindow.run_furrier_bounty_workflow
  return if @cw_furrier_workflow_running

  @cw_furrier_workflow_running = true
  begin
    CreatureWindow.stop_active_nonhidden_scripts_for_turnin

    Script.run("go2", "furrier")
    sleep 0.2 while running?("go2")
    CreatureWindow.prepare_turnin_hands

    npc = CreatureWindow.find_furrier_npc
    if npc
      CreatureWindow.ask_bounty_and_sync(npc)
    else
      respond "Creaturewindow: could not find a valid furrier NPC here."
    end
  rescue StandardError => e
    respond "Creaturewindow furrier workflow error: #{e.class} - #{e.message}"
  ensure
    @cw_furrier_workflow_running = false
    CreatureWindow.refresh_bounty_ui
  end
end

def CreatureWindow.run_skin_bounty_workflow
  return if @cw_skin_workflow_running

  unless @cw_bounty_task_type == :skinspecifics
    respond "Creaturewindow: no active skin-specific bounty."
    return
  end

  @cw_skin_workflow_running = true
  begin
    CreatureWindow.stop_active_nonhidden_scripts_for_turnin

    Script.run("go2", "furrier")
    sleep 0.2 while running?("go2")
    CreatureWindow.prepare_turnin_hands

    npc = CreatureWindow.find_furrier_npc
    unless npc
      respond "Creaturewindow: could not find a valid furrier NPC here."
      return
    end

    CreatureWindow.sell_skins_to_npc(npc)
  rescue StandardError => e
    respond "Creaturewindow skin workflow error: #{e.class} - #{e.message}"
  ensure
    @cw_skin_workflow_running = false
    CreatureWindow.parse_bounty_from_checkbounty
    CreatureWindow::CMD_QUEUE.push("update_window")
  end
end

def CreatureWindow.capture_bounty_origin_context
  @cw_bounty_origin_room_id ||= Room.current.id
  npc = GameObj.npcs.find do |n|
    n && !CreatureWindow.npc_is_invalid_turnin_target?(n) && n.name =~ CreatureWindow::BOUNTY_TURNIN_NPC_REGEX
  end
  return unless npc

  @cw_bounty_origin_npc_id = npc.id
  @cw_bounty_origin_npc_noun = npc.noun
end

def CreatureWindow.capture_gem_origin_context
  @cw_bounty_origin_room_id ||= Room.current.id
  npc = GameObj.npcs.find do |n|
    n && !CreatureWindow.npc_is_invalid_turnin_target?(n) && n.name =~ CreatureWindow::GEM_TURNIN_NPC_REGEX
  end
  return unless npc

  @cw_bounty_origin_npc_id = npc.id
  @cw_bounty_origin_npc_noun = npc.noun
end

def CreatureWindow.find_origin_turnin_npc
  npc = nil
  npc = GameObj.npcs.find { |n| n && !CreatureWindow.npc_is_invalid_turnin_target?(n) && n.id == @cw_bounty_origin_npc_id } if @cw_bounty_origin_npc_id
  npc ||= GameObj.npcs.find { |n| n && !CreatureWindow.npc_is_invalid_turnin_target?(n) && n.noun.to_s.casecmp(@cw_bounty_origin_npc_noun.to_s).zero? } if @cw_bounty_origin_npc_noun
  npc ||= GameObj.npcs.find { |n| n && !CreatureWindow.npc_is_invalid_turnin_target?(n) && n.name =~ CreatureWindow::BOUNTY_TURNIN_NPC_REGEX }
  npc
end

def CreatureWindow.current_herb_name
  herb = @cw_bounty_herb.to_s.dup
  herb.sub!(/\A(?:some|an?|a handful of)\s+/i, "")
  herb.sub!(/\s+found\s+in\s+.+\z/i, "")
  herb.sub!(/\s+that\s+only\s+grows\s+in\s+.+\z/i, "")
  herb.strip
end

def CreatureWindow.current_zzherb_name
  CreatureWindow.current_herb_name
end

def CreatureWindow.current_herb_noun
  herb_name = CreatureWindow.current_herb_name
  return "" if herb_name.empty?

  # forage.lic expects the base noun as a separate arg.
  herb_name.split(/\s+/).last.to_s.gsub(/[^a-zA-Z'-]/, "").downcase
end

def CreatureWindow.herb_items_for_turnin
  herb_name = CreatureWindow.current_herb_name.downcase
  return [] if herb_name.empty?

  candidates = []
  GameObj.inv.each do |item|
    next unless item

    candidates << item
    if item.respond_to?(:contents) && item.contents
      item.contents.each { |contained| candidates << contained if contained }
    end
  end

  candidates.select { |i| i.name.to_s.downcase.include?(herb_name) }
end

def CreatureWindow.herb_count_on_hand
  CreatureWindow.herb_items_for_turnin.inject(0) { |sum, item| sum + CreatureWindow.item_stack_count(item) }
end

def CreatureWindow.hand_in_herbs_to_npc(npc)
  return unless npc

  # Re-resolve items each pass and execute synchronously to avoid stale IDs/race conditions.
  loop do
    herb_item = CreatureWindow.herb_items_for_turnin.first
    break unless herb_item

    fput "get ##{herb_item.id}"
    fput "give ##{herb_item.id} to ##{npc.id}"
  end

  CreatureWindow.ask_bounty_and_sync(npc)
end

def CreatureWindow.go2_healer_room_for_turnin
  Script.run("go2", "healer")
  sleep 0.2 while running?("go2")
  CreatureWindow.prepare_turnin_hands
end

def CreatureWindow.find_origin_gem_npc
  npc = nil
  if @cw_bounty_origin_npc_id
    found_by_id = GameObj.npcs.find { |n| n && !CreatureWindow.npc_is_invalid_turnin_target?(n) && n.id == @cw_bounty_origin_npc_id }
    npc = found_by_id if found_by_id && found_by_id.name =~ CreatureWindow::GEM_TURNIN_NPC_REGEX
  end
  npc ||= GameObj.npcs.find { |n| n && !CreatureWindow.npc_is_invalid_turnin_target?(n) && n.name =~ CreatureWindow::GEM_TURNIN_NPC_REGEX }
  npc ||= GameObj.npcs.find { |n| n && !CreatureWindow.npc_is_invalid_turnin_target?(n) && n.name =~ CreatureWindow::BOUNTY_TURNIN_NPC_REGEX }
  npc
end

def CreatureWindow.current_gem_name
  @cw_bounty_gem.to_s.strip
end

def CreatureWindow.blocked_gemshop_room?
  current_uid_values = []
  if Room.current.respond_to?(:uid)
    current_uid_values = Array(Room.current.uid).compact.map { |u| u.to_s.sub(/\Au/i, "") }
  end

  return true if CreatureWindow::BLOCKED_GEMSHOP_ROOM_IDS.include?(Room.current.id.to_i)
  return true if CreatureWindow::BLOCKED_GEMSHOP_UIDS.any? { |uid| current_uid_values.include?(uid.to_s.sub(/\Au/i, "")) }
  return true if Room.current.title.to_s =~ CreatureWindow::BLOCKED_GEMSHOP_TITLES

  false
end

def CreatureWindow.goto_target_gemshop
  town = @cw_bounty_location.to_s.strip
  preferred = CreatureWindow::GEMSHOP_UID_BY_TOWN[town]

  if preferred
    Script.run("go2", preferred)
    sleep 0.2 while running?("go2")
    CreatureWindow.prepare_turnin_hands
    return
  end

  Script.run("go2", "gemshop")
  sleep 0.2 while running?("go2")
  CreatureWindow.prepare_turnin_hands
end

def CreatureWindow.normalize_bounty_item_name(name)
  name.to_s
      .downcase
      .gsub(/[^\w\s'-]/, " ")
      .gsub(/\A(?:a|an|some)\s+/, "")
      .gsub(/\A(?:piece|handful)\s+of\s+/, "")
      .gsub(/\s+/, " ")
      .strip
end

def CreatureWindow.item_matches_bounty_name?(item_name, bounty_name)
  normalized_item = CreatureWindow.normalize_bounty_item_name(item_name)
  normalized_bounty = CreatureWindow.normalize_bounty_item_name(bounty_name)
  return false if normalized_item.empty? || normalized_bounty.empty?
  return true if normalized_item.include?(normalized_bounty) || normalized_bounty.include?(normalized_item)

  # Skin/material bounty descriptions often include a dropped adjective in inventory
  # (e.g. "niveous warg pelts" bounty vs "bundle of warg pelts" item).
  if (m = normalized_bounty.match(/\A\w+\s+(.+\b(?:pelt|pelts|skin|skins|scale|scales|plume|plumes|mane|manes|trunk|trunks|hide|hides)\b)\z/))
    return true if normalized_item.include?(m[1])
  end

  bounty_tokens = normalized_bounty.split(/\s+/)
  bounty_tokens.all? { |token| normalized_item.include?(token) }
end

def CreatureWindow.item_stack_count(item)
  if item.respond_to?(:quantity)
    qty = item.quantity.to_i
    return qty if qty > 0
  end
  if item.respond_to?(:count)
    qty = item.count.to_i
    return qty if qty > 0
  end
  if item.respond_to?(:stack_size)
    qty = item.stack_size.to_i
    return qty if qty > 0
  end
  if item.name.to_s =~ /\((\d+)\)\s*\z/
    qty = Regexp.last_match(1).to_i
    return qty if qty > 0
  end

  1
end

def CreatureWindow.gem_items_for_turnin
  gem_name = CreatureWindow.current_gem_name
  return [] if gem_name.empty?

  candidates = []
  GameObj.inv.each do |item|
    next unless item

    candidates << item
    if item.respond_to?(:contents) && item.contents
      item.contents.each { |contained| candidates << contained if contained }
    end
  end

  candidates.select { |i| CreatureWindow.item_matches_bounty_name?(i.name.to_s, gem_name) }
end

def CreatureWindow.gem_count_on_hand
  CreatureWindow.gem_items_for_turnin.inject(0) { |sum, item| sum + CreatureWindow.item_stack_count(item) }
end

def CreatureWindow.current_skin_name
  @cw_bounty_skin.to_s.strip
end

def CreatureWindow.skin_items_for_turnin
  skin_name = CreatureWindow.current_skin_name
  return [] if skin_name.empty?

  candidates = []
  GameObj.inv.each do |item|
    next unless item

    candidates << item
    if item.respond_to?(:contents) && item.contents
      item.contents.each { |contained| candidates << contained if contained }
    end
  end

  candidates.select { |i| CreatureWindow.item_matches_bounty_name?(i.name.to_s, skin_name) }
end

def CreatureWindow.skin_count_on_hand
  CreatureWindow.skin_items_for_turnin.inject(0) { |sum, item| sum + CreatureWindow.item_stack_count(item) }
end

def CreatureWindow.skin_inventory_breakdown
  singles = 0
  bundles = 0

  CreatureWindow.skin_items_for_turnin.each do |item|
    count = CreatureWindow.item_stack_count(item)
    if item.name.to_s =~ /bundle of/i
      bundles += count
    else
      singles += count
    end
  end

  { singles: singles, bundles: bundles }
end

def CreatureWindow.sell_skins_to_npc(npc)
  return unless npc

  target_count = @cw_bounty_remaining.to_i
  target_count = 1 if target_count < 1
  skin_ids = CreatureWindow.skin_items_for_turnin.take(target_count).map(&:id)

  skin_ids.each do |skin_id|
    put "get ##{skin_id}"
    sleep 0.5
    put "sell ##{skin_id}"
  end

  CreatureWindow.ask_bounty_and_sync(npc, use_put: true)
end

def CreatureWindow.sell_gems_to_npc(npc)
  return unless npc

  target_count = @cw_bounty_remaining.to_i
  target_count = 1 if target_count < 1
  gem_ids = CreatureWindow.gem_items_for_turnin.take(target_count).map(&:id)

  gem_ids.each do |gem_id|
    put "get ##{gem_id}"
    sleep 0.5
    put "sell ##{gem_id}"
  end

  CreatureWindow.ask_bounty_and_sync(npc, use_put: true)
end

def CreatureWindow.run_herb_bounty_workflow
  return if @cw_herb_workflow_running

  unless [:herb, :herbspecifics].include?(@cw_bounty_task_type)
    respond "Creaturewindow: no active herb-specific bounty."
    return
  end

  @cw_herb_workflow_running = true
  begin
    CreatureWindow.stop_active_nonhidden_scripts_for_turnin

    needs_specifics = (@cw_bounty_task_type == :herb)
    needs_specifics ||= @cw_bounty_remaining.to_i < 1
    needs_specifics ||= CreatureWindow.current_zzherb_name.empty?
    needs_specifics ||= @cw_bounty_origin_npc_id.nil?
    needs_specifics ||= @cw_bounty_origin_room_id.nil?

    if needs_specifics
      CreatureWindow.go2_healer_room_for_turnin
      healer_npc = CreatureWindow.find_healer_bounty_npc || CreatureWindow.find_current_turnin_npc
      unless healer_npc
        respond "Creaturewindow: could not find healer/alchemist for herb specifics."
        return
      end

      ask_result = dothistimeout("ask ##{healer_npc.id} about bounty", 8, /concoction that requires|retrieve \d+ samples|You have been tasked to retrieve/i)
      sleep 0.2 if ask_result.nil?

      # Give checkbounty a short window to reflect freshly asked specifics.
      8.times do
        CreatureWindow.refresh_bounty_ui
        break if @cw_bounty_task_type == :herbspecifics
        sleep 0.2
      end
      @cw_bounty_origin_room_id = Room.current.id
      @cw_bounty_origin_npc_id = healer_npc.id
      @cw_bounty_origin_npc_noun = healer_npc.noun
    else
      CreatureWindow.capture_bounty_origin_context
    end

    unless @cw_bounty_task_type == :herbspecifics
      respond "Creaturewindow: could not fetch herb specifics from healer/alchemist."
      return
    end

    origin_room = @cw_bounty_origin_room_id || Room.current.id
    zzherb_name = CreatureWindow.current_zzherb_name
    needed_count = @cw_bounty_remaining.to_i
    needed_count = 1 if needed_count < 1
    on_hand_count = CreatureWindow.herb_count_on_hand
    find_count = [needed_count - on_hand_count, 0].max

    if running?("zzherb")
      respond "Creaturewindow: waiting for current zzherb run to finish..."
      sleep 0.2 while running?("zzherb")
    end

    unless File.exist?(File.join($script_dir, "zzherb.lic"))
      respond "Creaturewindow: zzherb.lic not found."
      return
    end

    if zzherb_name.empty?
      respond "Creaturewindow: no herb name parsed from bounty."
    elsif find_count > 0
      # zzherb accepts one arg string: "<herbname> <qty> [location optional]"
      Script.run("zzherb", %{#{zzherb_name} #{find_count}})
      sleep 0.2 while running?("zzherb")

      # Fallback for herb tags that require a determiner in Room.tags.
      if CreatureWindow.herb_count_on_hand < needed_count
        alt_name = "some #{zzherb_name}"
        Script.run("zzherb", %{#{alt_name} #{find_count}})
        sleep 0.2 while running?("zzherb")
      end

      # Additional fallback for herbs where scripts key off the base noun.
      if CreatureWindow.herb_count_on_hand < needed_count
        noun_name = CreatureWindow.current_herb_noun
        unless noun_name.empty?
          Script.run("zzherb", %{#{noun_name} #{find_count}})
          sleep 0.2 while running?("zzherb")
        end
      end
    end

    sleep 0.2 while running?("zzherb")

    if Room.current.id != origin_room
      Script.run("go2", origin_room.to_s)
      sleep 0.2 while running?("go2")
      CreatureWindow.prepare_turnin_hands
    end

    npc = CreatureWindow.find_origin_turnin_npc
    if npc
      CreatureWindow.hand_in_herbs_to_npc(npc)
    else
      respond "Creaturewindow: turn-in NPC not found in origin room, heading to healer room."
      CreatureWindow.go2_healer_room_for_turnin
      healer_npc = CreatureWindow.find_origin_turnin_npc
      if healer_npc
        CreatureWindow.hand_in_herbs_to_npc(healer_npc)
      else
        respond "Creaturewindow: could not find turn-in NPC in healer room."
      end
    end
  rescue StandardError => e
    respond "Creaturewindow herb workflow error: #{e.class} - #{e.message}"
  ensure
    @cw_herb_workflow_running = false
    CreatureWindow.parse_bounty_from_checkbounty
    CreatureWindow::CMD_QUEUE.push("update_window")
  end
end

def CreatureWindow.run_gem_bounty_workflow
  return if @cw_herb_workflow_running

  unless [:gem, :gemspecifics].include?(@cw_bounty_task_type)
    respond "Creaturewindow: no active gem bounty."
    return
  end

  @cw_herb_workflow_running = true
  begin
    CreatureWindow.stop_active_nonhidden_scripts_for_turnin

    CreatureWindow.capture_gem_origin_context

    CreatureWindow.goto_target_gemshop
    if CreatureWindow.blocked_gemshop_room?
      respond "Creaturewindow: blocked gemshop detected; aborting gem workflow."
      return
    end

    npc = CreatureWindow.find_origin_gem_npc
    unless npc
      respond "Creaturewindow: could not find gem dealer in gemshop."
      return
    end

    CreatureWindow.ask_bounty_and_sync(npc)

    unless @cw_bounty_task_type == :gemspecifics
      respond "Creaturewindow: could not fetch gem specifics from gem dealer."
      return
    end

    required = @cw_bounty_remaining.to_i
    required = 1 if required < 1
    on_hand = CreatureWindow.gem_count_on_hand

    if on_hand < required
      if running?("eloot")
        respond "Creaturewindow: waiting for current eloot run to finish..."
        sleep 0.2 while running?("eloot")
      end

      unless File.exist?(File.join($script_dir, "eloot.lic"))
        respond "Creaturewindow: eloot.lic not found."
        return
      end

      Script.run("eloot", "bounty")
      sleep 0.2 while running?("eloot")

      # eloot can move you; return to the correct gemshop before selling.
      CreatureWindow.goto_target_gemshop
      if CreatureWindow.blocked_gemshop_room?
        respond "Creaturewindow: blocked gemshop detected after eloot; aborting."
        return
      end
      npc = CreatureWindow.find_origin_gem_npc
      unless npc
        respond "Creaturewindow: could not find gem dealer after eloot run."
        return
      end
    else
      respond "Creaturewindow: found #{on_hand} matching gems on hand; skipping eloot bounty."
    end

    CreatureWindow.sell_gems_to_npc(npc)
  rescue StandardError => e
    respond "Creaturewindow gem workflow error: #{e.class} - #{e.message}"
  ensure
    @cw_herb_workflow_running = false
    CreatureWindow.refresh_bounty_ui
  end
end

def CreatureWindow.completed_amount
  return 0 unless @cw_bounty_total
  @cw_bounty_total - (@cw_bounty_remaining || 0)
end

def CreatureWindow.push_creatures_to_window(targets)
  curr_target_id = XMLData.current_target_id
  output = "<dialogData id='CreatureWindow' clear='t' >"

  current_top = 0

  # Column layout toggle
  # column_value = @cwsingle_column ? 'Layout: Single Column' : 'Layout: Two Columns'
  # column_cmd = "*cwcolumns"
  # output += "<link id='column_toggle' value='#{column_value}' cmd='#{column_cmd}' echo='Toggling Column Layout...' justify='bottom' left='0' top='#{current_top}' />"
  # current_top += 20

  # Avg TTK
  if CreatureWindow.display_avg_ttk
    avg_ttk_display = CreatureWindow.calculate_avg_ttk
    output += "<label id='ttk' value='Avg TTK: #{avg_ttk_display}' justify='left' left='0' top='#{current_top}' />"
    current_top += 20
  end

  # Last TTK
  if CreatureWindow.display_last_ttk
    last_ttk_display = @cw_last_kill_time ? format("%.2f sec", @cw_last_kill_time) : "N/A"
    output += "<label id='last_ttk' value='Last TTK: #{last_ttk_display}' justify='left' left='0' top='#{current_top}' />"
    current_top += 20

    if @cw_last_kill_name
      output += "<label id='last_kill_name' value='(#{@cw_last_kill_name})' justify='left' left='0' top='#{current_top}' />"
      current_top += 20
    end

    #    output += "<label id='div1' value='--------------------------------------' justify='left' left='0' top='#{current_top}' />"
  end

  if CreatureWindow.display_kpm
    output += "<label id='kpm' value='Kills/Min: #{CreatureWindow.calculate_owned_room_kpm}' justify='left' left='0' top='#{current_top}' />"
    current_top += 20
  end

  # Bounty info
  if CreatureWindow.display_bounty && (line = CreatureWindow.bounty_task_line)
    output += "<label id='bounty_type' value='#{CreatureWindow.sanitize_xml(line)}' justify='left' left='0' top='#{current_top}' wrap='true' />"
    current_top += 20
  end

  if CreatureWindow.display_bounty && (line = CreatureWindow.bounty_status_line)
    output += "<label id='bounty_status' value='#{CreatureWindow.sanitize_xml(line)}' justify='left' left='0' top='#{current_top}' wrap='true' />"
    current_top += 20

    #    output += "<label id='div2' value='--------------------------------------' justify='left' left='0' top='#{current_top}' />"
  end

  if CreatureWindow.display_bounty && (line = CreatureWindow.bounty_action_line)
    action_cmd = CreatureWindow.bounty_action_cmd
    output += "<link id='bounty_action' value='#{CreatureWindow.sanitize_xml(line)}' cmd='#{action_cmd}' echo='Starting bounty workflow...' justify='left' left='0' top='#{current_top}' />"
    current_top += 20
  end

  # Creature count
  output += "<label id='total' value='Creatures: #{targets.size}' justify='left' left='0' top='#{current_top}' />"
  current_top += 20

  # Separate and render current target first
  target_creature = targets.find { |t| t.id == curr_target_id }
  other_creatures = targets.reject { |t| t.id == curr_target_id }

  if target_creature
    status = CreatureWindow.creature_status_fix(target_creature.status, target_creature.name, target_creature.id)
    label_value = status ? "#{target_creature.noun} (#{status})" : target_creature.noun.to_s
    label_value = "**#{label_value}**"

    unless @cw_creature_targeted[target_creature.id]
      @cw_creature_timestamps[target_creature.id] = Time.now
      @cw_creature_targeted[target_creature.id] = true
    end

    cmd = "target ##{target_creature.id}"
    output += "<link id='target_creature' value='#{CreatureWindow.sanitize_xml(label_value)}' cmd='#{cmd}' echo='Targeting #{CreatureWindow.sanitize_xml(target_creature.name)}' justify='left' left='0' top='#{current_top}' />"
    current_top += 20 # Add a little extra space after target for clarity
  end

  # Creature grid
  row_height = 20
  col_left = 0
  col_right = 180
  top_offset = current_top / row_height

  creature_pairs = CreatureWindow.single_column ? other_creatures.each_slice(1) : other_creatures.each_slice(2)

  creature_pairs.with_index do |pair, row|
    pair.each_with_index do |creature, col|
      noun = creature.noun.to_s
      status = CreatureWindow.creature_status_fix(creature.status, creature.name, creature.id)

      label_value = status ? "#{noun} (#{status})" : noun
      label_id = "creature_#{row}_#{col}"

      left = col == 0 ? col_left : col_right
      top = row_height * (row + top_offset)

      cmd = "target ##{creature.id}"
      output += "<link id='#{label_id}' value='#{CreatureWindow.sanitize_xml(label_value)}' cmd='#{cmd}' echo='Targeting #{CreatureWindow.sanitize_xml(creature.name)}' justify='left' left='#{left}' top='#{top}' />"
    end
  end
  # After rendering all creatures, bump spacing by 20px before starting dead creature block
  grid_rows = (other_creatures.size.to_f / (CreatureWindow.single_column ? 1 : 2)).ceil
  current_top = row_height * (grid_rows + top_offset) + 20
  # Track creatures for killed/removed creatures
  current_ids = targets.map(&:id)
  (@cw_creature_timestamps.keys - current_ids).each do |missing_id|
    creature_name = GameObj.npcs.find { |npc| npc.id == missing_id }&.name || "Unknown"
    CreatureWindow.track_creature_creature(missing_id, creature_name)
  end

  # Dead creature listing
  dead_creatures = GameObj.npcs.select { |t| t.status.to_s.downcase == 'dead' }

  output += "<label id='deadcount' value='Dead Creatures: #{dead_creatures.size}' left='0' top='#{current_top}' />"
  current_top += 20

  if CreatureWindow.single_column
    dead_creatures.each_with_index do |t, index|
      noun = t.noun.to_s
      output += "<link id='dead_#{index}' value='#{noun}' cmd='loot ##{t.id}' echo='loot ##{t.id}' justify='bottom' left='0' top='#{current_top}' />"

      current_top += 20
    end
  else
    row_height = 20
    col_left = 0
    col_right = 180
    dead_creatures.each_slice(2).with_index do |pair, row|
      pair.each_with_index do |t, col|
        left = col == 0 ? col_left : col_right
        top = current_top + row * row_height
        noun = t.noun.to_s
        output += "<link id='dead_#{row}_#{col}' value='#{noun}' cmd='loot ##{t.id}' echo='loot ##{t.id}' justify='bottom' left='#{left}' top='#{top}' />"
      end
    end
    current_top += ((dead_creatures.size + 1) / 2) * row_height
  end


  output += "</dialogData>"
  puts(output)
end

def CreatureWindow.targets_snapshot(targets)
  current_target = XMLData.current_target_id
  creature_part = targets
                  .map { |t| "#{t.id}:#{t.status}:#{t.name}" }
                  .sort
                  .join("|")
  "#{creature_part}|current:#{current_target}"
end

def CreatureWindow.refresh_creature_windows(targets)
  dead_creatures = GameObj.npcs.select { |t| t.status.to_s.downcase == 'dead' }
  CreatureWindow.reset_kill_metrics_if_inactive(dead_creatures)
  CreatureWindow.track_owned_room_kills(dead_creatures)
  kpm_display = CreatureWindow.calculate_owned_room_kpm

  CreatureWindow.push_creatures_to_window(targets) if $frontend == "stormfront"

  return unless CreatureWindow.gtk_enabled?

  CreatureWindowGtk.update_creatures(
    targets,
    avg_ttk: CreatureWindow.calculate_avg_ttk,
    last_ttk: @cw_last_kill_time ? format("%.2f sec", @cw_last_kill_time) : "N/A",
    kpm: kpm_display,
    bounty_task: CreatureWindow.bounty_task_line,
    bounty_status: CreatureWindow.bounty_status_line,
    bounty_action: CreatureWindow.bounty_action_line,
    display_avg_ttk: CreatureWindow.display_avg_ttk,
    display_last_ttk: CreatureWindow.display_last_ttk,
    display_kpm: CreatureWindow.display_kpm,
    display_bounty: CreatureWindow.display_bounty
  )
end

upstream_hook_id = "#{Script.current.name}_upstream"
downstream_hook_id = "#{Script.current.name}_downstream"

UpstreamHook.remove(upstream_hook_id)   rescue nil
DownstreamHook.remove(downstream_hook_id) rescue nil

DownstreamHook.add(downstream_hook_id, proc do |line|
  begin
    CreatureWindow.push_recent_line(line.to_s.strip)
  rescue StandardError => e
    echo "Creaturewindow line capture error: #{e.message}"
  end
  line
end)

UpstreamHook.add(upstream_hook_id, proc do |command|
  window_settings = CreatureWindow.load_window_settings
  window_settings["creaturewindow"] ||= {}

  case command
  when /\*bty/i
    CreatureWindow.display_bounty = !CreatureWindow.display_bounty
    window_settings["creaturewindow"]["display_bounty"] = CreatureWindow.display_bounty
    CreatureWindow.save_window_settings(window_settings)
    CreatureWindow::CMD_QUEUE.push("update_window")
    respond "Bounty display: #{CreatureWindow.display_bounty ? 'ON' : 'OFF'}"
    nil

  when /\*ttk/i
    enabled = !CreatureWindow.display_avg_ttk
    CreatureWindow.display_avg_ttk = enabled
    CreatureWindow.display_last_ttk = enabled
    CreatureWindow.display_kpm = enabled
    window_settings["creaturewindow"]["display_avg_ttk"] = CreatureWindow.display_avg_ttk
    window_settings["creaturewindow"]["display_last_ttk"] = CreatureWindow.display_last_ttk
    window_settings["creaturewindow"]["display_kpm"] = CreatureWindow.display_kpm
    CreatureWindow.save_window_settings(window_settings)
    CreatureWindow::CMD_QUEUE.push("update_window")
    respond "Average TTK display: #{CreatureWindow.display_avg_ttk ? 'ON' : 'OFF'}"
    respond "Last TTK display: #{CreatureWindow.display_last_ttk ? 'ON' : 'OFF'}"
    respond "Kills per minute display: #{CreatureWindow.display_kpm ? 'ON' : 'OFF'}"
    nil

  when /\*cwcol/i
    CreatureWindow.single_column = !CreatureWindow.single_column
    window_settings["creaturewindow"]["single_column"] = CreatureWindow.single_column
    CreatureWindow.save_window_settings(window_settings)
    CreatureWindow::CMD_QUEUE.push("update_window")
    CreatureWindow.refresh_creature_windows(GameObj.targets)
    respond "Column Layout: #{CreatureWindow.single_column ? 'Single' : 'Double'}"
    nil

  when /\*cwherb/i
    CreatureWindow::CMD_QUEUE.push("run_herb_bounty_workflow")
    nil

  when /\*cwgem/i
    CreatureWindow::CMD_QUEUE.push("run_gem_bounty_workflow")
    nil

  when /\*cwguild/i
    CreatureWindow::CMD_QUEUE.push("run_guild_bounty_workflow")
    nil

  when /\*cwguard/i
    CreatureWindow::CMD_QUEUE.push("run_guard_bounty_workflow")
    nil

  when /\*cwfurrier/i
    CreatureWindow::CMD_QUEUE.push("run_furrier_bounty_workflow")
    nil

  when /\*cwskin/i
    CreatureWindow::CMD_QUEUE.push("run_skin_bounty_workflow")
    nil

  when /\*cwgtk/i
    CreatureWindow.use_gtk_window = !CreatureWindow.use_gtk_window
    respond "GTK Creaturewindow is now #{CreatureWindow.use_gtk_window ? 'ENABLED' : 'DISABLED'}."

    # persist the new setting
    settings = CreatureWindow.load_window_settings
    settings["creaturewindow"] ||= {}
    settings["creaturewindow"]["use_gtk_creaturewindow"] = CreatureWindow.use_gtk_window
    CreatureWindow.save_window_settings(settings)

    if CreatureWindow.use_gtk_window
      if CreatureWindow.gtk_available
        Gtk.queue { CreatureWindowGtk.create_main_window }
        Thread.new { CreatureWindow.start_gtk_main_if_needed }
      else
        CreatureWindow.use_gtk_window = false
        settings["creaturewindow"]["use_gtk_creaturewindow"] = false
        CreatureWindow.save_window_settings(settings)
        respond "GTK unavailable. Install gtk3 gem to enable GTK Creaturewindow."
      end
    else
      # close it if it exists
      if CreatureWindow.gtk_available && defined?(CreatureWindowGtk) && CreatureWindowGtk.instance_variable_get(:@window)
        Gtk.queue do
          CreatureWindowGtk.instance_variable_get(:@window).close
        end
      end
    end

    nil

  when /\*allgtk/i
    CreatureWindow.use_gtk_window = !CreatureWindow.use_gtk_window
    respond "GTK Creaturewindow is now #{CreatureWindow.use_gtk_window ? 'ENABLED' : 'DISABLED'}."

    # persist the new setting
    settings = CreatureWindow.load_window_settings
    settings["creaturewindow"] ||= {}
    settings["creaturewindow"]["use_gtk_creaturewindow"] = CreatureWindow.use_gtk_window
    CreatureWindow.save_window_settings(settings)

    if CreatureWindow.use_gtk_window
      if CreatureWindow.gtk_available
        Gtk.queue { CreatureWindowGtk.create_main_window }
        Thread.new { CreatureWindow.start_gtk_main_if_needed }
      else
        CreatureWindow.use_gtk_window = false
        settings["creaturewindow"]["use_gtk_creaturewindow"] = false
        CreatureWindow.save_window_settings(settings)
        respond "GTK unavailable. Install gtk3 gem to enable GTK Creaturewindow."
      end
    else
      # close it if it exists
      if CreatureWindow.gtk_available && defined?(CreatureWindowGtk) && CreatureWindowGtk.instance_variable_get(:@window)
        Gtk.queue do
          CreatureWindowGtk.instance_variable_get(:@window).close
        end
      end
    end

    nil

  else
    command
  end
end)

before_dying do
  UpstreamHook.remove(upstream_hook_id)
  DownstreamHook.remove(downstream_hook_id) rescue nil

  if CreatureWindow.gtk_available && defined?(CreatureWindowGtk) && (cw = CreatureWindowGtk.instance_variable_get(:@window))
    Gtk.queue { cw.hide }
  end
end

echo "Creaturewindow is active." if $frontend == "stormfront"

CreatureWindow.capture_bounty_origin_context
CreatureWindow.parse_bounty_from_checkbounty
@cw_last_bounty_check ||= Time.now

Thread.new do
  loop do
    cmd = CreatureWindow::TARGET_CMD_QUEUE.pop
    begin
      fput cmd
    rescue => e
      echo "Creaturewindow target command error: #{e.message}"
    ensure
      CreatureWindow::CMD_QUEUE.push("update_window")
    end
  end
end

loop do
  current_targets = GameObj.targets
  snapshot = CreatureWindow.targets_snapshot(current_targets)

  # Refresh when creature/status snapshot changes or on heartbeat interval.
  if snapshot != @cw_last_targets_snapshot || (Time.now - @cw_last_ui_refresh_at) > 0.20
    @cw_last_targets = current_targets
    @cw_last_targets_snapshot = snapshot
    @cw_last_ui_refresh_at = Time.now
    CreatureWindow.refresh_creature_windows(current_targets)
  end

  # - when you flip one of the toggles via commands -
  unless CreatureWindow::CMD_QUEUE.empty?
    cmd = CreatureWindow::CMD_QUEUE.pop
    if cmd == "update_window"
      CreatureWindow.refresh_creature_windows(current_targets)
      @cw_last_targets_snapshot = CreatureWindow.targets_snapshot(current_targets)
      @cw_last_ui_refresh_at = Time.now
    elsif cmd == "run_herb_bounty_workflow"
      CreatureWindow.run_herb_bounty_workflow
    elsif cmd == "run_gem_bounty_workflow"
      CreatureWindow.run_gem_bounty_workflow
    elsif cmd == "run_guild_bounty_workflow"
      CreatureWindow.run_guild_bounty_workflow
    elsif cmd == "run_guard_bounty_workflow"
      CreatureWindow.run_guard_bounty_workflow
    elsif cmd == "run_furrier_bounty_workflow"
      CreatureWindow.run_furrier_bounty_workflow
    elsif cmd == "run_skin_bounty_workflow"
      CreatureWindow.run_skin_bounty_workflow
    end
  end

  # - periodic bounty refresh -
  if Time.now - @cw_last_bounty_check > 5
    CreatureWindow.capture_bounty_origin_context if @cw_bounty_origin_npc_id.nil?
    CreatureWindow.parse_bounty_from_checkbounty
    CreatureWindow::CMD_QUEUE.push("update_window")
    @cw_last_bounty_check = Time.now
  end

  sleep 0.1
end


