=begin
  Creature Window - Real-Time Creature & Bounty Display

  Creates a dedicated window to display creature information and statuses
  in real time. Supports both Wrayth FE panel and GTK window for Avalon
  and Wizard FEs. Live targets are shown with standardized status indicators
  (stunned, calmed, frozen, held, prone, etc), dead creatures are filtered
  to a separate list, and your current TARGET is highlighted at the top.
  Optionally tracks kill metrics (Avg TTK, Last TTK, KPM) and displays
  bounty task information.

  References:
    Wrayth FE Window: https://discordapp.com/channels/226045346399256576/1339018254517145681
    GTK Window:       https://discordapp.com/channels/226045346399256576/1386507836191670342

  Usage:
    ;creaturewindow              - Start creature window

  In-game Commands (while running):
    *ttk                         - Toggle time-to-kill metrics display
    *bty                         - Toggle bounty task display
    *cwcol                       - Toggle single/double column layout
    *cwgtk                       - Enable GTK window

  Author: Phocosoen, ChatGPT
  Tags: wrayth, frontend, mod, window, target, creature, mob, bounty, advguild, avalon, wizard, gtk3
  Version: 1.5.12
  Recently changed: Fixed skinning bounty parsing to keep full item names like "handful of undansormr scales".
=end

no_kill_all

require 'yaml'

module CreatureWindow
  extend self
  include Lich::Common if defined?(Lich::Common)

  class << self
    attr_accessor :settings, :window_settings, :use_gtk_window,
                  :display_bounty, :display_avg_ttk, :display_last_ttk, :display_kpm,
                  :gtk_available
  end
end

def CreatureWindow.deep_merge_hash(base, override)
  base.merge(override) do |_k, base_val, override_val|
    if base_val.is_a?(Hash) && override_val.is_a?(Hash)
      CreatureWindow.deep_merge_hash(base_val, override_val)
    else
      override_val
    end
  end
end

CW_DEFAULT_WINDOW_SETTINGS = {
  "creaturewindow" => {
    "single_column"          => false,
    "display_avg_ttk"        => false,
    "display_last_ttk"       => false,
    "display_kpm"            => false,
    "display_bounty"         => true,
    "x"                      => 1440,
    "y"                      => 1600,
    "width"                  => 420,
    "height"                 => 370,
    "font_size"              => 17,
    "use_gtk_creaturewindow" => true,
    "palette"                => "White on Black"
  },
} unless defined?(CW_DEFAULT_WINDOW_SETTINGS)

def CreatureWindow.window_settings_path(name: Char.name)
  # Use $data_dir and XMLData.game for Lich data structure
  base_dir = "#{$data_dir}#{XMLData.game}/#{name}"
  Dir.mkdir("#{$data_dir}#{XMLData.game}") unless File.exist?("#{$data_dir}#{XMLData.game}")
  Dir.mkdir(base_dir) unless File.exist?(base_dir)
  File.join(base_dir, "lichwindows.yaml")
end

def CreatureWindow.load_window_settings(name: Char.name)
  filename = CreatureWindow.window_settings_path(name: name)
  settings_hash = nil

  if File.exist?(filename) && name == Char.name
    begin
      raw = File.read(filename)
      parsed = YAML.safe_load(raw, permitted_classes: [Hash, Array, String, Integer, Float, TrueClass, FalseClass, NilClass], aliases: false)
      parsed = {} unless parsed.is_a?(Hash)
      settings_hash = CreatureWindow.deep_merge_hash(CW_DEFAULT_WINDOW_SETTINGS, parsed)
    rescue => e
      echo "Window settings: Corrupt settings file detected (#{e.message}). Rebuilding defaults..."
      settings_hash = CreatureWindow.deep_merge_hash(CW_DEFAULT_WINDOW_SETTINGS, {})
      File.write(filename, settings_hash.to_yaml)
    end
  elsif !File.exist?(filename) && name != Char.name
    echo "Window settings: Attempt to load a profile (#{name}) that does not exist."
    settings_hash = nil
  elsif !File.exist?(filename) && name == Char.name
    echo "Window settings: No current settings found. Loading defaults..."
    settings_hash = CreatureWindow.deep_merge_hash(CW_DEFAULT_WINDOW_SETTINGS, {})
    File.write(filename, settings_hash.to_yaml)
  else
    echo "Window settings: Unknown error loading profile (#{name})"
    settings_hash = nil
  end

  settings_hash
end

def CreatureWindow.save_window_settings(settings, name: Char.name)
  filename = CreatureWindow.window_settings_path(name: name)
  File.write(filename, settings.to_yaml)
end

CreatureWindow.settings = CreatureWindow.load_window_settings
CreatureWindow.settings ||= CreatureWindow.deep_merge_hash(CW_DEFAULT_WINDOW_SETTINGS, {})
CreatureWindow.window_settings = CreatureWindow.settings["creaturewindow"] ||= {}
CreatureWindow.use_gtk_window = CreatureWindow.window_settings["use_gtk_creaturewindow"] || false
CreatureWindow.display_bounty   = CreatureWindow.window_settings.fetch("display_bounty",   true) # default _on_ so you see an actual bounty line
CreatureWindow.display_avg_ttk  = CreatureWindow.window_settings.fetch("display_avg_ttk",  false)
CreatureWindow.display_last_ttk = CreatureWindow.window_settings.fetch("display_last_ttk", false)
CreatureWindow.display_kpm      = CreatureWindow.window_settings.fetch("display_kpm",      false)

CreatureWindow.gtk_available = begin
  require 'gtk3'
  true
rescue LoadError => e
  echo "Creaturewindow: GTK unavailable (#{e.message})."
  false
end

def CreatureWindow.gtk_enabled?
  CreatureWindow.gtk_available && CreatureWindow.use_gtk_window
end

def CreatureWindow.start_gtk_main_if_needed
  return unless CreatureWindow.gtk_available
  Gtk.main if Gtk.main_level == 0
end

def CreatureWindow.ensure_runtime_state!
  @cw_recent_lines ||= []
  @cw_creature_timestamps ||= {}
  @cw_creature_targeted ||= {}
  @cw_custom_status_cache ||= {}
  @cw_time_to_kill_list ||= []
  @cw_counted_dead_creature_ids ||= {}
  @cw_owned_room_kill_count ||= 0
  @cw_owned_room_kill_started_at ||= nil
  @cw_last_kill_activity_at ||= nil
  @cw_last_kill_time ||= nil
  @cw_last_kill_name ||= nil
end

def CreatureWindow.push_recent_line(line)
  CreatureWindow.ensure_runtime_state!
  @cw_recent_lines << line
  @cw_recent_lines.shift if @cw_recent_lines.size > 25
end

@cw_startup_request_gtk = (CreatureWindow.use_gtk_window || $frontend != "stormfront")

if $frontend == "stormfront"
  puts("<closeDialog id='CreatureWindow'/><openDialog type='dynamic' id='CreatureWindow' title='Creatures' target='CreatureWindow' scroll='manual' location='main' justify='3' height='120' resident='true'><dialogData id='CreatureWindow'></dialogData></openDialog>")
end

@cw_last_targets = []
@cw_last_targets_snapshot = nil
@cw_last_ui_refresh_at = Time.at(0)
@cw_creature_timestamps = {}
@cw_creature_status_changed = {}
@cw_time_to_kill_list = []
@cw_owned_room_kill_count = 0
@cw_owned_room_kill_started_at = nil
@cw_counted_dead_creature_ids = {}
@cw_last_kill_activity_at = nil
@cw_creature_targeted = {}
@cw_custom_status_cache = {}

CreatureWindow::CMD_QUEUE = Queue.new unless defined?(CreatureWindow::CMD_QUEUE)
CreatureWindow::TARGET_CMD_QUEUE = Queue.new unless defined?(CreatureWindow::TARGET_CMD_QUEUE)

@cw_recent_lines ||= []

# --- 1) Define your palettes ------------------------------------------------
CreatureWindow::PALETTES = {
  "Lich Dark Mode"     => { bg: "#2E2E2E", fg: "#DADADA" },
  "Lich Light Mode"    => { bg: "#E6E6E6", fg: "#202020" },
  "Middle Ground"      => { bg: "#333333", fg: "#FFFFFF" },
  "White on Black"     => { bg: "#000000", fg: "#FFFFFF" },
  "NQWhite on NQBlack" => { bg: "#111111", fg: "#f6f6f6" },
  "Black on White"     => { bg: "#FFFFFF", fg: "#000000" },
} unless defined?(CreatureWindow::PALETTES)

class CreatureWindowGtk
  @window       = nil
  @css_provider = nil
  @font_size    = nil
  # --- 2) Regenerate & apply CSS using the chosen palette --------------------
  def self.reload_css
    # Load persisted palette choice (default to "White on Black")
    settings = CreatureWindow.load_window_settings
    cw       = settings["creaturewindow"] ||= {}
    pal_name = cw["palette"] || "White on Black"
    colors   = CreatureWindow::PALETTES[pal_name]

    css = <<~CSS
      /* window frame */
      window#creaturewindow {
        background-color: #{colors[:bg]};
        color:            #{colors[:fg]};
        border:           0px solid #888888;
        border-radius:    4px;
      }

      window#creaturewindow .palette-btn,
      window#creaturewindow popover .palette-btn,
      window#creaturewindow GtkPopover .palette-btn {
        background: #{colors[:bg]};
        color: #{colors[:fg]};
      }

      window#creaturewindow .palette-btn:checked {
        background: #{colors[:bg]};
        color: #{colors[:fg]};
      }

      /* header bar */
      window#creaturewindow headerbar {
        background-color: #{colors[:bg]};
        color:            #{colors[:fg]};
      }

      /* header bar buttons / toggles */
      window#creaturewindow headerbar .header-toggle {
        margin:      0 2px;
        padding:     2px 4px;
        background-image: none;
        background-color: transparent;
        color:            #{colors[:fg]};
        border:           none;
        box-shadow:       none;
      }

      /* "on" state for toggles */
      window#creaturewindow headerbar .header-toggle:checked {
        background-color: #0a84ff; /* system blue */
        color:            #FFFFFF;
      }

      /* content labels */
      window#creaturewindow label {
        font-size: #{@font_size}px;
        color:     #{colors[:fg]};
      }

      /* scrolled area & flowbox */
      window#creaturewindow GtkScrolledWindow,
      window#creaturewindow GtkFlowBox {
        background-color: #{colors[:bg]};
      }
  window#creaturewindow .creature-btn,
  window#creaturewindow button.creature-btn {
        background: #{colors[:bg]};
        color: #{colors[:fg]};
    border-radius: 6px;
    border-width: 1px;
    border-style: solid;
    border-color: #888888;
    padding: 5px;
    font-weight: normal;
    transition: background 0.2s;
  }

  window#creaturewindow .creature-btn:active,
  window#creaturewindow button.creature-btn:active {
        background: #{colors[:bg]};
        color: #{colors[:fg]};
  }
    CSS

    @css_provider.load(data: css)
  end

  def self.create_main_window
    return if @window

    # --- load persisted settings ---
    settings = CreatureWindow.load_window_settings
    cw       = settings["creaturewindow"] ||= {}
    @font_size = cw["font_size"] || 14
    cw["palette"] || "White on Black"

    # --- build top-level window & HeaderBar ---
    @window = Gtk::Window.new(:toplevel)
    @window.set_name("creaturewindow")
    @window.set_border_width(10)
    @window.set_type_hint(Gdk::WindowTypeHint::UTILITY)
    @window.set_keep_above(true)

    header = Gtk::HeaderBar.new
    header.show_close_button = true
    header.title = "CW"

    # - Font size buttons -
    dec_btn = Gtk::Button.new(label: "A-")
    inc_btn = Gtk::Button.new(label: "A+")
    [dec_btn, inc_btn].each do |b|
      b.style_context.add_class("header-toggle")
      header.pack_start(b)
    end
    dec_btn.signal_connect("clicked") do
      @font_size = [@font_size - 1, 8].max
      cw["font_size"] = @font_size; CreatureWindow.save_window_settings(settings)
      reload_css
    end
    inc_btn.signal_connect("clicked") do
      @font_size = [@font_size + 1, 30].min
      cw["font_size"] = @font_size; CreatureWindow.save_window_settings(settings)
      reload_css
    end

    # - Palette selector -
    # build your MenuButton
    palette_btn = Gtk::MenuButton.new
    palette_btn.style_context.add_class("header-toggle")
    img = Gtk::Image.new(
      icon_name: "preferences-desktop-color-symbolic",
      icon_size: Gtk::IconSize::SMALL_TOOLBAR
    )
    palette_btn.set_image(img)
    palette_btn.set_always_show_image(true)

    # create the Popover and position it _before_ attaching it
    popover = Gtk::Popover.new(palette_btn)
    popover.set_position(Gtk::PositionType::TOP) # <- do this first

    # now fill your popover
    listbox = Gtk::Box.new(:vertical, 0)
    CreatureWindow::PALETTES.each_key do |name|
      btn = Gtk::ToggleButton.new(label: name)
      btn.style_context.add_class("header-toggle")
      btn.style_context.add_class("palette-btn")
      btn.active = (name == cw["palette"])
      btn.set_sensitive(true) # <- This ensures it's clickable
      btn.signal_connect("clicked") do
        settings = CreatureWindow.load_window_settings
        settings["creaturewindow"] ||= {}
        settings["creaturewindow"]["palette"] = name
        CreatureWindow.save_window_settings(settings)
        reload_css
      end
      listbox.add(btn)
    end
    popover.add(listbox)
    listbox.show_all

    # *only now* attach the popover to the button
    palette_btn.set_popover(popover)

    # and finally pack it into your header
    header.pack_end(palette_btn)

    @window.set_titlebar(header)

    # - CSS provider & initial styling -
    @css_provider = Gtk::CssProvider.new
    reload_css
    screen = Gdk::Screen.default
    Gtk::StyleContext.add_provider_for_screen(
      screen,
      @css_provider,
      Gtk::StyleProvider::PRIORITY_APPLICATION
    )

    # - Restore geometry -
    @window.resize(cw["width"], cw["height"]) if cw["width"] && cw["height"]
    @window.move(cw["x"], cw["y"]) if cw["x"] && cw["y"]

    @scroll = Gtk::ScrolledWindow.new
    @scroll.set_policy(Gtk::PolicyType::AUTOMATIC, Gtk::PolicyType::AUTOMATIC)
    @scroll.set_hexpand(true)
    @scroll.set_vexpand(true)

    @flow = Gtk::FlowBox.new
    @flow.selection_mode        = :none
    @flow.max_children_per_line = 2
    @flow.column_spacing        = 0
    @flow.row_spacing           = 0
    @flow.set_vexpand(true)
    @flow.valign                = Gtk::Align::START
    @flow.homogeneous           = false
    @scroll.add(@flow)

    @cw_bounty_box = Gtk::Box.new(:vertical)
    @cw_bounty_box.set_hexpand(true)
    @cw_bounty_box.set_vexpand(false)
    @cw_bounty_box.set_halign(Gtk::Align::START)
    @cw_bounty_box.set_valign(Gtk::Align::START)
    @cw_bounty_box.hide

    @main_box = Gtk::Box.new(:vertical)
    @main_box.pack_start(@cw_bounty_box, expand: false, fill: true, padding: 0)
    @main_box.pack_start(@scroll, expand: true, fill: true, padding: 0)
    @window.add(@main_box)

    # --- save geometry on move/resize ------------------------------------
    @ignore_next_configure = true
    @window.signal_connect("configure_event") do |_w, _ev|
      if @ignore_next_configure
        @ignore_next_configure = false
      else
        x, y = @window.position
        w, h = @window.size
        s = CreatureWindow.load_window_settings
        s["creaturewindow"] ||= {}
        s["creaturewindow"].merge!("x" => x, "y" => y, "width" => w, "height" => h)
        CreatureWindow.save_window_settings(s)
      end
      false
    end

    # --- replace the default destroy->Gtk.main_quit handler ---------------
    # 1) First, connect Gtk.main_quit *yourself* and capture its handler ID:
    default_quit_id = @window.signal_connect("destroy") do
      Gtk.main_quit
    end

    # 2) Immediately disconnect that handler:
    @window.signal_handler_disconnect(default_quit_id)

    # 3) Now install *your* destroy handler that only closes this window:
    @window.signal_connect("destroy") do
      @window = nil
      # NO Gtk.main_quit here!
    end

    @window.show_all
  end # <- end create_main_window

  # -----------------------------------------------------------------------
  # now the updater lives _outside_ of create_main_window
  def self.add_full_row(text = "")
    lbl = Gtk::Label.new(text)
    lbl.set_xalign(0)
    @flow.add(lbl)
    # second column is always a blank label
    @flow.add(Gtk::Label.new(""))
  end

  # --- completely replace your old update_creatures with this ---
  def self.update_creatures(targets,
                            avg_ttk:,
                            last_ttk:,
                            kpm:,
                            bounty_task:,
                            bounty_status:,
                            display_avg_ttk:,
                            display_last_ttk:,
                            display_kpm:,
                            display_bounty:)
    return unless @window

    Gtk.queue do
      # - first, clear & repopulate bounty_box -
      @cw_bounty_box.each { |c| @cw_bounty_box.remove(c) }
      if display_bounty
        @cw_bounty_box.show
        [bounty_task, bounty_status].each do |txt|
          lbl = Gtk::Label.new(txt)
          lbl.set_xalign(0)
          @cw_bounty_box.add(lbl)
        end

        # <-- here:
        @cw_bounty_box.show_all
      else
        @cw_bounty_box.hide
      end

      # 4) Creature count
      @flow.children.each { |c| @flow.remove(c) }
      add_full_row("Creatures: #{targets.size}")

      if display_avg_ttk
        add_full_row("Avg TTK: #{avg_ttk}")
      end

      if display_last_ttk
        add_full_row("Last TTK: #{last_ttk}")
      end

      if display_kpm
        add_full_row("Kills/Min: #{kpm}")
      end

      # 5) Current target
      if (curr = targets.find { |t| t.id == XMLData.current_target_id })
        st   = CreatureWindow.creature_status_fix(curr.status, curr.name, curr.id)
        txt  = st ? "#{curr.noun.capitalize} (#{st})" : curr.noun.capitalize
        add_full_row("**#{txt}**")
      end

      # Other living creatures as buttons
      (targets - [curr]).each do |t|
        st = CreatureWindow.creature_status_fix(t.status, t.name, t.id)
        btn_label = st ? "#{t.noun.capitalize} (#{st})" : t.noun.capitalize
        btn = Gtk::Button.new(label: btn_label)
        btn.style_context.add_class("creature-btn")
        btn.signal_connect("clicked") do
          CreatureWindow::TARGET_CMD_QUEUE << "target ##{t.id}"
        end
        @flow.add(btn)
      end

      # -- if we're in the middle of a row, finish it off --
      if @flow.children.size.odd?
        # push us onto a fresh row for the dead header
        @flow.add(Gtk::Label.new(""))
      end

      # 7) Dead creatures - force a full row for the count, then list
      dead = GameObj.npcs.select { |n| n.status.to_s.downcase == "dead" }
      add_full_row("")
      add_full_row("Dead Creatures: #{dead.size}")
      dead.each do |t|
        lbl = Gtk::Label.new(t.noun.capitalize)
        lbl.set_xalign(0)
        @flow.add(lbl)
      end

      @flow.show_all
    end
  end
end

if @cw_startup_request_gtk
  if CreatureWindow.gtk_available
    respond ""
    respond " Initiating GTK window."
    respond ""
    respond " GTK Creaturewindow is active."
    respond ""
    Gtk.queue { CreatureWindowGtk.create_main_window }
    Thread.new { CreatureWindow.start_gtk_main_if_needed }
  else
    CreatureWindow.use_gtk_window = false
    CreatureWindow.window_settings["use_gtk_creaturewindow"] = false
    CreatureWindow.save_window_settings(CreatureWindow.settings)
    respond ""
    respond " GTK Creaturewindow disabled: gtk3 gem not available."
    respond ""
  end
end

Thread.new do
  loop do
    begin
      CreatureWindow.push_recent_line(get.strip)
    rescue => e
      echo "Line monitor error: #{e.message}"
    end
    sleep 0.05
  end
end

def CreatureWindow.creature_status_fix(status, name = nil, id = nil)
  CreatureWindow.ensure_runtime_state!
  custom_statuses = []

  if name&.match?(/cold wyrm/i)
    if @cw_recent_lines.any? { |line| line =~ /cold wyrm plummets toward the ground.*radiating wall of devastation/i }
      custom_statuses << "grounded"
    elsif @cw_recent_lines.any? { |line| line =~ /cold wyrm's muscles bunch and she launches herself into the air/i }
      custom_statuses << "airborne"
    elsif @cw_recent_lines.any? { |line| line =~ /Corruscations of color play along a silver-scaled cold wyrm's scaled hide.*disrupting the attack/i }
      custom_statuses << "shielded"
    end

    # Cache logic
    if !custom_statuses.empty? && id
      @cw_custom_status_cache[id] = custom_statuses
    elsif id && @cw_custom_status_cache.key?(id)
      custom_statuses = @cw_custom_status_cache[id]
    end
  end

  standard_status = case status
                    when /calmed|calm/i then "calmed"
                    when /frozen|immobilized|terrified/i then "frozen"
                    when /held/i then "held"
                    when /rooted/i then "rooted"
                    when /unconscious|slumber|sleeping/i then "unconscious"
                    when /webbed|webbing/i then "webbed"
                    when /stunned/i then "stunned"
                    when /prone|lying down|knocked to the ground/i then "prone"
                    when /flying/i then "flying"
                    else nil
                    end

  all_statuses = []
  all_statuses << standard_status if standard_status
  all_statuses.concat(custom_statuses)
  all_statuses.empty? ? nil : all_statuses.join(", ")
end

def CreatureWindow.calculate_avg_ttk
  CreatureWindow.ensure_runtime_state!
  return "N/A" if @cw_time_to_kill_list.empty?
  avg_ttk = @cw_time_to_kill_list.sum / @cw_time_to_kill_list.size
  format("%.2f sec", avg_ttk)
end

def CreatureWindow.register_kill_activity
  CreatureWindow.ensure_runtime_state!
  @cw_last_kill_activity_at = Time.now
end

def CreatureWindow.reset_kill_metrics_if_inactive(dead_creatures, inactivity_seconds: 300)
  CreatureWindow.ensure_runtime_state!
  return if @cw_last_kill_activity_at.nil?
  return if (Time.now - @cw_last_kill_activity_at) < inactivity_seconds

  @cw_time_to_kill_list.clear
  @cw_last_kill_time = nil
  @cw_last_kill_name = nil
  @cw_owned_room_kill_count = 0
  @cw_owned_room_kill_started_at = nil
  @cw_counted_dead_creature_ids = dead_creatures.to_h { |creature| [creature.id, Time.now] }
  @cw_last_kill_activity_at = nil
end

def CreatureWindow.claim_owned_room?
  defined?(Lich::Claim) && Lich::Claim.mine?
rescue StandardError
  false
end

def CreatureWindow.track_owned_room_kills(dead_creatures)
  CreatureWindow.ensure_runtime_state!
  return unless CreatureWindow.claim_owned_room?

  @cw_owned_room_kill_started_at ||= Time.now
  current_dead_ids = dead_creatures.map(&:id)

  dead_creatures.each do |creature|
    creature_id = creature.id
    next if @cw_counted_dead_creature_ids.key?(creature_id)

    @cw_counted_dead_creature_ids[creature_id] = Time.now
    @cw_owned_room_kill_count += 1
    CreatureWindow.register_kill_activity
  end

  @cw_counted_dead_creature_ids.delete_if { |creature_id, _| !current_dead_ids.include?(creature_id) }
end

def CreatureWindow.calculate_owned_room_kpm
  CreatureWindow.ensure_runtime_state!
  kill_count = @cw_owned_room_kill_count.to_i
  return "N/A" if @cw_owned_room_kill_started_at.nil? || kill_count.zero?

  elapsed_minutes = (Time.now - @cw_owned_room_kill_started_at) / 60.0
  return "N/A" if elapsed_minutes <= 0

  format("%.2f (%d)", kill_count / elapsed_minutes, kill_count)
end

def CreatureWindow.track_creature_creature(creature_id, creature_name)
  CreatureWindow.ensure_runtime_state!
  return unless @cw_creature_timestamps[creature_id]
  return unless @cw_creature_targeted[creature_id]

  time_alive = Time.now - @cw_creature_timestamps[creature_id]
  @cw_time_to_kill_list << time_alive

  @cw_last_kill_time = time_alive
  @cw_last_kill_name = creature_name
  CreatureWindow.register_kill_activity

  @cw_creature_timestamps.delete(creature_id)
  @cw_creature_targeted.delete(creature_id)
  @cw_custom_status_cache.delete(creature_id)
end

def CreatureWindow.sanitize_xml(value)
  value.to_s.gsub("&", "&amp;").gsub("<", "&lt;").gsub(">", "&gt;").gsub("'", "&apos;").gsub('"', "&quot;")
end

def CreatureWindow.parse_bounty_from_checkbounty
  bounty_text = checkbounty

  # Clear everything first
  @cw_bounty_task_type = nil
  @cw_bounty_total = nil
  @cw_bounty_remaining = nil
  @cw_bounty_location = nil
  @cw_bounty_gem = nil
  @cw_bounty_skin = nil
  @cw_bounty_heirloom = nil
  @cw_bounty_target_creature = nil
  @cw_bounty_herb = nil
  @cw_bounty_kills_total = nil
  @cw_bounty_kills_remaining = nil

  if bounty_text =~ /You are not currently assigned a task/i
    @cw_bounty_task_type = :none

  elsif bounty_text =~ /You have located (?:an? |a pair of |some )(.+?) and should bring/i
    @cw_bounty_task_type = :completeheirloom
    @cw_bounty_heirloom = bounty_text.match(/You have located (?:an? |a pair of |some )(.+?) and should bring/i)[1]

  elsif bounty_text =~ /report back to/i
    @cw_bounty_task_type = :completeguard

  elsif bounty_text =~ /Guild to receive your reward/i
    @cw_bounty_task_type = :completeguild

  elsif bounty_text =~ /task here from the town of (.+?)\.  It appears they have a bandit problem/i
    @cw_bounty_task_type = :bandit
    @cw_bounty_remaining = "Talk to guard for specifics."
    @cw_bounty_location = bounty_text.match(/task here from the town of (.+?)\.  It appears they have a bandit problem/i)[1]

  elsif bounty_text =~ /You have been tasked to suppress bandit activity (?:on|in the|in) (.+?) (?:near|between)/i && bounty_text =~ /You need to kill (\d+)/i
    @cw_bounty_task_type = :banditspecifics
    @cw_bounty_location = bounty_text.match(/You have been tasked to suppress bandit activity (?:on|in the|in) (.+?) (?:near|between)/i)[1]
    @cw_bounty_remaining = bounty_text.match(/You need to kill (\d+)/i)[1].to_i
  # ###################escort
  elsif bounty_text =~ /protective escort/i && bounty_text =~ /safety to (.+?) as/i && bounty_text =~ /(?:inside the |area just |south end )(.+?) and wait/i
    @cw_bounty_task_type = :escort
    @cw_bounty_escort = bounty_text.match(/(?:inside the |area just |south end )(.+?) and wait/i)[1]
    @cw_bounty_location = bounty_text.match(/safety to (.+?) as/i)[1]

  elsif bounty_text =~ /(?:town|outpost) of ([^\.]+)\.\s+The local gem dealer/i
    @cw_bounty_task_type = :gem
    @cw_bounty_remaining = "Talk to gem dealer for specifics."
    @cw_bounty_location = bounty_text.match(/(?:town|outpost) of ([^\.]+)\.\s+The local gem dealer/i)[1]
  # ###################GEM
  elsif bounty_text =~ /The gem dealer in (.+?),/i && bounty_text =~ /The gem dealer in .*? requesting (.+?)\./i && bounty_text =~ /You have been tasked to retrieve (\d+) (?:more )?of them/i
    @cw_bounty_task_type = :gemspecifics
    @cw_bounty_gem = bounty_text.match(/The gem dealer in .*? requesting (.+?)\./i)[1]
    @cw_bounty_remaining = bounty_text.match(/You have been tasked to retrieve (\d+) (?:more )?of them/i)[1].to_i
    @cw_bounty_location = bounty_text.match(/The gem dealer in (.+?),/i)[1]

  elsif bounty_text =~ /task here from the (?:town|outpost) of (.+?)\.  The local .*(?:alchemist|healer|herbalist)/i
    @cw_bounty_task_type = :herb
    @cw_bounty_remaining = "Talk to healer for specifics."
    @cw_bounty_location = bounty_text.match(/task here from the (?:town|outpost) of (.+?)\.  The local .*(?:alchemist|healer)/i)[1]
  # ###################FORAGE
  elsif bounty_text =~ /concoction that requires (?:an?|some) (.+?) found/i && bounty_text =~ /found (?:in|on the) (?:the )?(.+?) near/i && bounty_text =~ /You have been tasked to retrieve (\d+) (?:more )?samples/i
    @cw_bounty_task_type = :herbspecifics
    @cw_bounty_herb = bounty_text.match(/concoction that requires (?:an?|some) (.+?) found/i)[1]
    @cw_bounty_remaining = bounty_text.match(/You have been tasked to retrieve (\d+) (?:more )?samples/i)[1].to_i
    @cw_bounty_location = bounty_text.match(/found (?:in|on the) (?:the )?(.+?) near/i)[1]

  elsif bounty_text =~ /The local furrier .* has an order to fill and wants our help/i && bounty_text =~ /of (.+?)\.  The local furrier/i
    @cw_bounty_task_type = :skin
    @cw_bounty_remaining = "Talk to furrier for specifics."
    @cw_bounty_location = bounty_text.match(/of (.+?)\.  The local furrier/i)[1]
  # ###################SKINNING
  elsif bounty_text =~ /You have been tasked to retrieve (\d+) .* of at/i && bounty_text =~ /retrieve \d+ (.+?) of at least/i && bounty_text =~ /quality\ for.*?(?:in|on\ the)\s+(.+?)\.\s+You/i
    @cw_bounty_task_type = :skinspecifics
    @cw_bounty_skin = bounty_text.match(/retrieve \d+ (.+?) of at least/i)[1]
    @cw_bounty_remaining = bounty_text.match(/You have been tasked to retrieve (\d+) .*? (?:more )?of at/i)[1].to_i
    @cw_bounty_location = bounty_text.match(/quality\s+for.*?(?:in|on\ the)\s+(.+?)\.\s+You/i)[1]
  # ###################CREATURE
  elsif bounty_text =~ /It appears they have a creature problem/i && bounty_text =~ /(?:town|outpost) of ([^\.]+)\.\s+It/i
    @cw_bounty_task_type = :creature
    @cw_bounty_remaining = "Talk to guard for specifics."
    @cw_bounty_location = bounty_text.match(/(?:town|outpost) of ([^\.]+)\.\s+It/i)[1]
  # ###################DANGEROUS
  elsif bounty_text =~ /hunt down and kill a particularly dangerous (.+?) that has/i && bounty_text =~ /(?:activity|territory) (?:in|on the) (?:the )?(.+?)(?: near)?\./i
    @cw_bounty_task_type = :dangerous
    @cw_bounty_target_creature = bounty_text.match(/hunt down and kill a particularly dangerous (.+?) that has/i)[1]
    @cw_bounty_location = bounty_text.match(/(?:activity|territory) (?:in|on the) (?:the )?(.+?)(?: near)?\./i)[1]
    @cw_bounty_kills_total = nil
    @cw_bounty_kills_remaining = nil
  # ###################KILL
  elsif bounty_text =~ /(?:tasked to|by) (?:.* )?(?:suppressing|suppress) (.+?) activity/i && bounty_text =~ /You need to kill (\d+)/i && bounty_text =~ /(?:activity|territory) (?:in|on the) (?:the )?(.+?)(?: near)?\./i
    @cw_bounty_task_type = :kill
    @cw_bounty_target_creature = bounty_text.match(/(?:tasked to|by) (?:.* )?(?:suppressing|suppress) (.+?) activity/i)[1]
    @cw_bounty_remaining = bounty_text.match(/You need to kill (\d+)/i)[1].to_i
    @cw_bounty_location = bounty_text.match(/(?:activity|territory) (?:in|on the) (?:the )?(.+?)(?: near)?\./i)[1]

  elsif bounty_text =~ /It appears (?:that a local resident|they need your help in tracking down some king of lost heirloom)/i && bounty_text =~ /(?:town|outpost) of ([^\.]+)\.\s+It/i
    @cw_bounty_task_type = :resident
    @cw_bounty_remaining = "Talk to guard for specifics."
    @cw_bounty_location = bounty_text.match(/(?:town|outpost) of ([^\.]+)\.\s+It/i)[1]
  # ###################RESCUE
  elsif bounty_text =~ /rescue/i && bounty_text =~ /the child fleeing from an? (.+?) in/i && bounty_text =~ /(?:in|on the) (?:the )?(.+?) near/i
    @cw_bounty_task_type = :rescue
    @cw_bounty_target_creature = bounty_text.match(/the child fleeing from an? (.+?) in/i)[1]
    @cw_bounty_location = bounty_text.match(/(?:in|on the) (?:the )?(.+?) near/i)[1]

  elsif bounty_text =~ /(?:town|outpost) of (.+?)\.  It appears they need your help in tracking down some kind of lost heirloom/i
    @cw_bounty_task_type = :heirloom
    @cw_bounty_remaining = "Talk to guard for specifics."
    @cw_bounty_location = bounty_text.match(/(?:town|outpost) of (.+?)\.  It appears they need your help in tracking down some kind of lost heirloom/i)[1]
  # ###################HEIRLOOM KILL
  elsif bounty_text =~ /tasked to recover (?:an|a pair of|a|some) (.+?) that/i &&
        bounty_text =~ /attacked by an? (.+?) (?:in the |in |on the )(.+?) (?: near)?/i &&
        bounty_text =~ /hunt down/i
    @cw_bounty_task_type = :heirloomkill
    @cw_bounty_heirloom = bounty_text.match(/tasked to recover (?:an|a pair of|a|some) (.+?) that/i)[1]
    creature_match = bounty_text.match(/attacked by an? (.+?) (?:in the |in |on the )(.+?) (?: near)?/i)
    @cw_bounty_target_creature = creature_match[1]
    @cw_bounty_location = creature_match[2]
  # ###################HEIRLOOM SEARCH
  elsif bounty_text =~ /tasked to recover (?:an|a pair of|a|some) (.+?) that/i &&
        bounty_text =~ /attacked by an? (.+?) (?:in the |in |on the )(.+?) (?: near)?/i &&
        bounty_text =~ /search/i
    @cw_bounty_task_type = :heirloomsearch
    @cw_bounty_heirloom = bounty_text.match(/tasked to recover (?:an|a pair of|a|some) (.+?) that/i)[1]
    creature_match = bounty_text.match(/attacked by an? (.+?) (?:in the |in |on the )(.+?) (?: near)?/i)
    @cw_bounty_target_creature = creature_match[1]
    @cw_bounty_location = creature_match[2]
  end
end

def CreatureWindow.bounty_task_line
  case @cw_bounty_task_type
  when :bandit
    "#{@cw_bounty_location} - Bandit Bounty"
  when :banditspecifics
    "#{@cw_bounty_location} - Bandit Bounty"
  when :escort
    "Escort - #{@cw_bounty_location}"
  when :gem
    "#{@cw_bounty_location} - Gem Bounty"
  when :gemspecifics
    "#{@cw_bounty_location} - Gem Bounty"
  when :herb
    "#{@cw_bounty_location} - Foraging Bounty"
  when :herbspecifics
    "#{@cw_bounty_location} - Foraging Bounty"
  when :skin
    "#{@cw_bounty_location} - Skinning Bounty"
  when :skinspecifics
    "#{@cw_bounty_location} - Skinning Bounty"
  when :creature
    "#{@cw_bounty_location} - Creature Bounty"
  when :kill
    "#{@cw_bounty_location} - Culling Bounty"
  when :dangerous
    "#{@cw_bounty_location} - Dangerous Bounty"
  when :resident
    "#{@cw_bounty_location} - Resident Bounty"
  when :rescue
    "#{@cw_bounty_location} - Rescue Bounty"
  when :heirloom
    "#{@cw_bounty_location} - Heirloom Bounty"
  when :heirloomkill
    "Find - #{@cw_bounty_heirloom}"
  when :heirloomsearch
    "Find - #{@cw_bounty_heirloom}"
  when :completeheirloom
    "Found! - #{@cw_bounty_heirloom}"
  when :completeguard
    "Task Complete!"
  when :completeguild
    "Task Complete!"
  else
    "No Bounty"
  end
end

def CreatureWindow.bounty_status_line
  case @cw_bounty_task_type
  when :bandit
    "#{@cw_bounty_remaining}"
  when :banditspecifics
    "Kill #{@cw_bounty_remaining} - Bandit"
  when :escort
    "Start - #{@cw_bounty_escort}"
  when :gem
    "#{@cw_bounty_remaining}"
  when :gemspecifics
    "Find #{@cw_bounty_remaining} - #{@cw_bounty_gem}"
  when :herb
    "#{@cw_bounty_remaining}"
  when :herbspecifics
    "Find #{@cw_bounty_remaining} - #{@cw_bounty_herb}"
  when :skin
    "#{@cw_bounty_remaining}"
  when :skinspecifics
    "Find #{@cw_bounty_remaining} - #{@cw_bounty_skin}"
  when :creature
    "#{@cw_bounty_remaining}"
  when :kill
    "Kill #{@cw_bounty_remaining} - #{@cw_bounty_target_creature}"
  when :dangerous
    "Kill - #{@cw_bounty_target_creature}"
  when :resident
    "#{@cw_bounty_remaining}"
  when :rescue
    "Kill - #{@cw_bounty_target_creature}"
  when :heirloom
    "#{@cw_bounty_remaining}"
  when :heirloomkill
    "Kill - #{@cw_bounty_target_creature}"
  when :heirloomsearch
    "Search Near - #{@cw_bounty_target_creature}"
  when :completeheirloom
    "Return it to the guard!"
  when :completeguard
    "Report to the guard!"
  when :completeguild
    "Report to the guild!"
  else
    ""
  end
end

def CreatureWindow.completed_amount
  return 0 unless @cw_bounty_total
  @cw_bounty_total - (@cw_bounty_remaining || 0)
end

def CreatureWindow.push_creatures_to_window(targets)
  curr_target_id = XMLData.current_target_id
  output = "<dialogData id='CreatureWindow' clear='t' >"

  current_top = 0

  # Column layout toggle
  # column_value = @cwsingle_column ? 'Layout: Single Column' : 'Layout: Two Columns'
  # column_cmd = "*cwcolumns"
  # output += "<link id='column_toggle' value='#{column_value}' cmd='#{column_cmd}' echo='Toggling Column Layout...' justify='bottom' left='0' top='#{current_top}' />"
  # current_top += 20

  # Avg TTK
  if CreatureWindow.display_avg_ttk
    avg_ttk_display = CreatureWindow.calculate_avg_ttk
    output += "<label id='ttk' value='Avg TTK: #{avg_ttk_display}' justify='left' left='0' top='#{current_top}' />"
    current_top += 20
  end

  # Last TTK
  if CreatureWindow.display_last_ttk
    last_ttk_display = @cw_last_kill_time ? format("%.2f sec", @cw_last_kill_time) : "N/A"
    output += "<label id='last_ttk' value='Last TTK: #{last_ttk_display}' justify='left' left='0' top='#{current_top}' />"
    current_top += 20

    if @cw_last_kill_name
      output += "<label id='last_kill_name' value='(#{@cw_last_kill_name})' justify='left' left='0' top='#{current_top}' />"
      current_top += 20
    end

    #    output += "<label id='div1' value='--------------------------------------' justify='left' left='0' top='#{current_top}' />"
  end

  if CreatureWindow.display_kpm
    output += "<label id='kpm' value='Kills/Min: #{CreatureWindow.calculate_owned_room_kpm}' justify='left' left='0' top='#{current_top}' />"
    current_top += 20
  end

  # Bounty info
  if CreatureWindow.display_bounty && (line = CreatureWindow.bounty_task_line)
    output += "<label id='bounty_type' value='#{CreatureWindow.sanitize_xml(line)}' justify='left' left='0' top='#{current_top}' wrap='true' />"
    current_top += 20
  end

  if CreatureWindow.display_bounty && (line = CreatureWindow.bounty_status_line)
    output += "<label id='bounty_status' value='#{CreatureWindow.sanitize_xml(line)}' justify='left' left='0' top='#{current_top}' wrap='true' />"
    current_top += 20

    #    output += "<label id='div2' value='--------------------------------------' justify='left' left='0' top='#{current_top}' />"
  end

  # Creature count
  output += "<label id='total' value='Creatures: #{targets.size}' justify='left' left='0' top='#{current_top}' />"
  current_top += 20

  # Separate and render current target first
  target_creature = targets.find { |t| t.id == curr_target_id }
  other_creatures = targets.reject { |t| t.id == curr_target_id }

  if target_creature
    status = CreatureWindow.creature_status_fix(target_creature.status, target_creature.name, target_creature.id)
    label_value = status ? "#{target_creature.noun.capitalize} (#{status})" : target_creature.noun.capitalize
    label_value = "**#{label_value}**"

    unless @cw_creature_targeted[target_creature.id]
      @cw_creature_timestamps[target_creature.id] = Time.now
      @cw_creature_targeted[target_creature.id] = true
    end

    cmd = "target ##{target_creature.id}"
    output += "<link id='target_creature' value='#{CreatureWindow.sanitize_xml(label_value)}' cmd='#{cmd}' echo='Targeting #{CreatureWindow.sanitize_xml(target_creature.name)}' justify='left' left='0' top='#{current_top}' />"
    current_top += 20 # Add a little extra space after target for clarity
  end

  # Creature grid
  row_height = 20
  col_left = 0
  col_right = 180
  top_offset = current_top / row_height

  creature_pairs = @cwsingle_column ? other_creatures.each_slice(1) : other_creatures.each_slice(2)

  creature_pairs.with_index do |pair, row|
    pair.each_with_index do |creature, col|
      noun = creature.noun.capitalize
      status = CreatureWindow.creature_status_fix(creature.status, creature.name, creature.id)

      label_value = status ? "#{noun} (#{status})" : noun
      label_id = "creature_#{row}_#{col}"

      left = col == 0 ? col_left : col_right
      top = row_height * (row + top_offset)

      cmd = "target ##{creature.id}"
      output += "<link id='#{label_id}' value='#{CreatureWindow.sanitize_xml(label_value)}' cmd='#{cmd}' echo='Targeting #{CreatureWindow.sanitize_xml(creature.name)}' justify='left' left='#{left}' top='#{top}' />"
    end
  end
  # After rendering all creatures, bump spacing by 20px before starting dead creature block
  grid_rows = (other_creatures.size.to_f / (@cwsingle_column ? 1 : 2)).ceil
  current_top = row_height * (grid_rows + top_offset) + 20
  # Track creatures for killed/removed creatures
  current_ids = targets.map(&:id)
  (@cw_creature_timestamps.keys - current_ids).each do |missing_id|
    creature_name = GameObj.npcs.find { |npc| npc.id == missing_id }&.name || "Unknown"
    CreatureWindow.track_creature_creature(missing_id, creature_name)
  end

  # Dead creature listing
  dead_creatures = GameObj.npcs.select { |t| t.status.to_s.downcase == 'dead' }

  output += "<label id='deadcount' value='Dead Creatures: #{dead_creatures.size}' left='0' top='#{current_top}' />"
  current_top += 20

  if @cwsingle_column
    dead_creatures.each_with_index do |t, index|
      noun = t.noun.capitalize
      output += "<link id='dead_#{index}' value='#{noun}' cmd='loot ##{t.id}' echo='loot ##{t.id}' justify='bottom' left='0' top='#{current_top}' />"

      current_top += 20
    end
  else
    row_height = 20
    col_left = 0
    col_right = 180
    dead_creatures.each_slice(2).with_index do |pair, row|
      pair.each_with_index do |t, col|
        left = col == 0 ? col_left : col_right
        top = current_top + row * row_height
        noun = t.noun.capitalize
        output += "<link id='dead_#{row}_#{col}' value='#{noun}' cmd='loot ##{t.id}' echo='loot ##{t.id}' justify='bottom' left='#{left}' top='#{top}' />"
      end
    end
    current_top += ((dead_creatures.size + 1) / 2) * row_height
  end


  output += "</dialogData>"
  puts(output)
end

def CreatureWindow.targets_snapshot(targets)
  current_target = XMLData.current_target_id
  creature_part = targets
                  .map { |t| "#{t.id}:#{t.status}:#{t.name}" }
                  .sort
                  .join("|")
  "#{creature_part}|current:#{current_target}"
end

def CreatureWindow.refresh_creature_windows(targets)
  dead_creatures = GameObj.npcs.select { |t| t.status.to_s.downcase == 'dead' }
  CreatureWindow.reset_kill_metrics_if_inactive(dead_creatures)
  CreatureWindow.track_owned_room_kills(dead_creatures)
  kpm_display = CreatureWindow.calculate_owned_room_kpm

  CreatureWindow.push_creatures_to_window(targets) if $frontend == "stormfront"

  return unless CreatureWindow.gtk_enabled?

  CreatureWindowGtk.update_creatures(
    targets,
    avg_ttk: CreatureWindow.calculate_avg_ttk,
    last_ttk: @cw_last_kill_time ? format("%.2f sec", @cw_last_kill_time) : "N/A",
    kpm: kpm_display,
    bounty_task: CreatureWindow.bounty_task_line,
    bounty_status: CreatureWindow.bounty_status_line,
    display_avg_ttk: CreatureWindow.display_avg_ttk,
    display_last_ttk: CreatureWindow.display_last_ttk,
    display_kpm: CreatureWindow.display_kpm,
    display_bounty: CreatureWindow.display_bounty
  )
end

upstream_hook_id = "#{Script.current.name}_upstream"

UpstreamHook.remove(upstream_hook_id)   rescue nil

UpstreamHook.add(upstream_hook_id, proc do |command|
  window_settings = CreatureWindow.load_window_settings
  window_settings["creaturewindow"] ||= {}

  case command
  when /\*bty/i
    CreatureWindow.display_bounty = !CreatureWindow.display_bounty
    window_settings["creaturewindow"]["display_bounty"] = CreatureWindow.display_bounty
    CreatureWindow.save_window_settings(window_settings)
    CreatureWindow::CMD_QUEUE.push("update_window")
    respond "Bounty display: #{CreatureWindow.display_bounty ? 'ON' : 'OFF'}"
    nil

  when /\*ttk/i
    enabled = !CreatureWindow.display_avg_ttk
    CreatureWindow.display_avg_ttk = enabled
    CreatureWindow.display_last_ttk = enabled
    CreatureWindow.display_kpm = enabled
    window_settings["creaturewindow"]["display_avg_ttk"] = CreatureWindow.display_avg_ttk
    window_settings["creaturewindow"]["display_last_ttk"] = CreatureWindow.display_last_ttk
    window_settings["creaturewindow"]["display_kpm"] = CreatureWindow.display_kpm
    CreatureWindow.save_window_settings(window_settings)
    CreatureWindow::CMD_QUEUE.push("update_window")
    respond "Average TTK display: #{CreatureWindow.display_avg_ttk ? 'ON' : 'OFF'}"
    respond "Last TTK display: #{CreatureWindow.display_last_ttk ? 'ON' : 'OFF'}"
    respond "Kills per minute display: #{CreatureWindow.display_kpm ? 'ON' : 'OFF'}"
    nil

  when /\*cwcol/i
    @cwsingle_column = !@cwsingle_column
    window_settings["creaturewindow"]["single_column"] = @cwsingle_column
    CreatureWindow.save_window_settings(window_settings)
    CreatureWindow::CMD_QUEUE.push("update_window")
    respond "Column Layout: #{@cwsingle_column ? 'Single' : 'Double'}"
    nil

  when /\*cwgtk/i
    CreatureWindow.use_gtk_window = !CreatureWindow.use_gtk_window
    respond "GTK Creaturewindow is now #{CreatureWindow.use_gtk_window ? 'ENABLED' : 'DISABLED'}."

    # persist the new setting
    settings = CreatureWindow.load_window_settings
    settings["creaturewindow"] ||= {}
    settings["creaturewindow"]["use_gtk_creaturewindow"] = CreatureWindow.use_gtk_window
    CreatureWindow.save_window_settings(settings)

    if CreatureWindow.use_gtk_window
      if CreatureWindow.gtk_available
        Gtk.queue { CreatureWindowGtk.create_main_window }
        Thread.new { CreatureWindow.start_gtk_main_if_needed }
      else
        CreatureWindow.use_gtk_window = false
        settings["creaturewindow"]["use_gtk_creaturewindow"] = false
        CreatureWindow.save_window_settings(settings)
        respond "GTK unavailable. Install gtk3 gem to enable GTK Creaturewindow."
      end
    else
      # close it if it exists
      if CreatureWindow.gtk_available && defined?(CreatureWindowGtk) && CreatureWindowGtk.instance_variable_get(:@window)
        Gtk.queue do
          CreatureWindowGtk.instance_variable_get(:@window).close
        end
      end
    end

    nil

  when /\*allgtk/i
    CreatureWindow.use_gtk_window = !CreatureWindow.use_gtk_window
    respond "GTK Creaturewindow is now #{CreatureWindow.use_gtk_window ? 'ENABLED' : 'DISABLED'}."

    # persist the new setting
    settings = CreatureWindow.load_window_settings
    settings["creaturewindow"] ||= {}
    settings["creaturewindow"]["use_gtk_creaturewindow"] = CreatureWindow.use_gtk_window
    CreatureWindow.save_window_settings(settings)

    if CreatureWindow.use_gtk_window
      if CreatureWindow.gtk_available
        Gtk.queue { CreatureWindowGtk.create_main_window }
        Thread.new { CreatureWindow.start_gtk_main_if_needed }
      else
        CreatureWindow.use_gtk_window = false
        settings["creaturewindow"]["use_gtk_creaturewindow"] = false
        CreatureWindow.save_window_settings(settings)
        respond "GTK unavailable. Install gtk3 gem to enable GTK Creaturewindow."
      end
    else
      # close it if it exists
      if CreatureWindow.gtk_available && defined?(CreatureWindowGtk) && CreatureWindowGtk.instance_variable_get(:@window)
        Gtk.queue do
          CreatureWindowGtk.instance_variable_get(:@window).close
        end
      end
    end

    nil

  else
    command
  end
end)

before_dying do
  UpstreamHook.remove(upstream_hook_id)

  if CreatureWindow.gtk_available && defined?(CreatureWindowGtk) && (cw = CreatureWindowGtk.instance_variable_get(:@window))
    Gtk.queue { cw.hide }
  end
end

echo "Creaturewindow is active." if $frontend == "stormfront"

CreatureWindow.parse_bounty_from_checkbounty
@cw_last_bounty_check ||= Time.now

Thread.new do
  loop do
    cmd = CreatureWindow::TARGET_CMD_QUEUE.pop
    begin
      fput cmd
    rescue => e
      echo "Creaturewindow target command error: #{e.message}"
    ensure
      CreatureWindow::CMD_QUEUE.push("update_window")
    end
  end
end

loop do
  current_targets = GameObj.targets
  snapshot = CreatureWindow.targets_snapshot(current_targets)

  # Refresh when creature/status snapshot changes or on heartbeat interval.
  if snapshot != @cw_last_targets_snapshot || (Time.now - @cw_last_ui_refresh_at) > 0.20
    @cw_last_targets = current_targets
    @cw_last_targets_snapshot = snapshot
    @cw_last_ui_refresh_at = Time.now
    CreatureWindow.refresh_creature_windows(current_targets)
  end

  # - when you flip one of the toggles via commands -
  unless CreatureWindow::CMD_QUEUE.empty?
    cmd = CreatureWindow::CMD_QUEUE.pop
    if cmd == "update_window"
      CreatureWindow.refresh_creature_windows(current_targets)
      @cw_last_targets_snapshot = CreatureWindow.targets_snapshot(current_targets)
      @cw_last_ui_refresh_at = Time.now
    end
  end

  # - periodic bounty refresh -
  if Time.now - @cw_last_bounty_check > 5
    CreatureWindow.parse_bounty_from_checkbounty
    CreatureWindow::CMD_QUEUE.push("update_window")
    CreatureWindow.refresh_creature_windows(current_targets)
    @cw_last_targets_snapshot = CreatureWindow.targets_snapshot(current_targets)
    @cw_last_ui_refresh_at = Time.now
    @cw_last_bounty_check = Time.now
  end

  sleep 0.1
end


