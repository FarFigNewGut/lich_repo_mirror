##quiet
=begin

	NesBounty by Nesmeor

  This is a modified version of Sbounty by SpiffyJr

  Does all bounties except gem, escorts, and bandits. Gems should be handled 
  via your loot with stockpiling. Uses NesAtlas (modified version of Atlas)
  as lookup source for bounties. Will use the (b) set of hunting commands for 
  skinning bounties.

  By default this will only do bounties for creatures one level less than yours
  or below. You can modify this via $nesbounty[:level_mod] below.

  Additionally, search & forage bounties will only be pursued while percentmind is greater
  than the $nesbounty[:min_mind]. 

  (GUI for these two settings forthcoming)

  If you have issues find me on GSIV Discord. ;nesbounty debug can be used to output debug
  info while running the full script. ;nesbounty check can be used to check the bounty
  and output debug information without trying to run the full script. Details are 
  always helpful to fix things :)

	 author: Nesmeor
	   name: NesBounty
	   tags: bounty
	version: 1.2.2

  Changelog
  1.2.2 - Fixed missing location handling
  1.2.1 - cleaned up messaging, disabled guessing, fixed level check
  1.2.0 - changed messaging, allowed hiding of debug messages
  1.1.0 - added min_mind setting for minimum mind level for forage & search bounties
  1.0.1 - fixed level checking
  1.0.0 - moved off of $sbounty settings to unique $nesbounty
          now requires nesbounty-bigshot to run
  0.3.0 - upload version correction
  0.1.0 - added player defined level checking
  0.0.3 - fixed dangerous creature handling
  0.0.2 - fixed area selection
  0.0.1 - initial release

=end

#Check for nesatlas dependency
begin
  raise "nesatlas is missing" unless Script.exists? "nesatlas.lic"
  load 'scripts/nesatlas.lic'
rescue => error
  echo error.message
  echo "Downloading nesatlas"
  do_client(";repository download nesatlas.lic")
  wait_while {running?('repository')}
  do_client(";repository download atlas_data.db3")
  wait_while {running?('repository')}
  retry if Script.exists? "nesatlas.lic"
  echo "Some how a core script is missing.  Don't know what happened."
  exit
end

#check for nesbounty-bigshot
begin
  raise "nesbounty-bigshot is missing" unless Script.exists? "nesbounty-bigshot.lic"
rescue => error
  echo error.message
  echo "Downloading nesbounty-bigshot"
  do_client(";repository download nesbounty-bigshot.lic")
  wait_while {running?('repository')}
  retry if Script.exists? "nesbounty-bigshot.lic"
  echo "Some how a core script is missing.  Don't know what happened."
  exit
end

# Vaalor guards
Room[5827].tags.push('advguard2') unless Room[5827].tags.include?('advguard2')

$nesbounty = CharSettings.to_hash

$nesbounty[:hunter] ||= 'nesbounty-bigshot'

$nesbounty[:enable_cull]      = $nesbounty[:enable_cull].nil? ? true : $nesbounty[:enable_cull]
$nesbounty[:enable_dangerous] = $nesbounty[:enable_dangerous].nil? ? true : $nesbounty[:enable_dangerous]
$nesbounty[:enable_forage]    = $nesbounty[:enable_forage].nil? ? true : $nesbounty[:enable_forage]
$nesbounty[:enable_loot]      = $nesbounty[:enable_loot].nil? ? true : $nesbounty[:enable_loot]
$nesbounty[:enable_rescue]    = $nesbounty[:enable_rescue].nil? ? true : $nesbounty[:enable_rescue]
$nesbounty[:enable_search]    = $nesbounty[:enable_search].nil? ? true : $nesbounty[:enable_search]
$nesbounty[:enable_bandit]    = $nesbounty[:enable_bandit].nil? ? false : $nesbounty[:enable_bandit]
$nesbounty[:enable_skin]      = $nesbounty[:enable_skin].nil? ? true : $nesbounty[:enable_skin]
$nesbounty[:enable_expedite]  = $nesbounty[:enable_expedite].nil? ? false : $nesbounty[:enable_expedite]

$nesbounty[:enable_hunt_complete] = $nesbounty[:enable_hunt_complete].nil? ? true : $nesbounty[:enable_hunt_complete]

$nesbounty[:hunting_scripts]       ||= []
$nesbounty[:enable_bandit_script]  ||= false
$nesbounty[:bandit_script]         ||= 'sbounty-bandit-example'
$nesbounty[:pre_search_commands]   ||= ['store all']
$nesbounty[:post_search_commands]  ||= ['gird']
$nesbounty[:pre_forage_commands]   ||= ['store all']
$nesbounty[:post_forage_commands]  ||= ['gird']
$nesbounty[:forage_retry_delay]    ||= 300
$nesbounty[:loot_script]           ||= 'sloot'
$nesbounty[:turn_in_percent]       ||= 95
$nesbounty[:enable_turn_in_bounty] ||= $nesbounty[:enable_turn_in_bounty].nil? ? true : $nesbounty[:enable_turn_in_bounty]

$nesbounty[:should_hunt_mind]    ||= 75
$nesbounty[:should_hunt_mana]    ||= 0
$nesbounty[:should_hunt_spirit]  ||= 7
$nesbounty[:hunt_pre_commands]   ||= ['gird']
$nesbounty[:should_rest_mind]    ||= 100
$nesbounty[:should_rest_mana]    ||= 0
$nesbounty[:should_rest_encum]   ||= 20
$nesbounty[:should_rest_wounded] ||= StringProc.new('bleeding? || XMLData.injuries.any?{|key,value| value["wound"] > 1} || percenthealth <= 75')

$nesbounty[:rest_room]       ||= '288'
$nesbounty[:boundaries]      ||= ''
$nesbounty[:rest_in_commands]    ||= ['sit']
$nesbounty[:rest_out_commands]   ||= ['stand']
$nesbounty[:rest_pre_commands]   ||= ['store all']
$nesbounty[:rest_scripts]        ||= ['herbheal','poolparty', 'sloot sell', 'waggle']
$nesbounty[:rest_sleep_interval] ||= 30
$nesbounty[:level_mod]       ||= -1
$nesbounty[:min_mind]        ||= 75

$nesbounty[:locations] ||= {}

$nesbounty_rest        = false
$nesbounty_rest_reason = nil
$debug                 = false
$sleep_default         = 5
$guess_area            = false
in_rest_area         = false
rest_reason          = nil
hunt_reason          = nil
can_do_bounty_cache  = nil
expedite_left        = true
last_forage_attempt  = 0
last_forage_delay    = 300
first_run            = true
kill_bounty          = true
# TODO: Do this the new stow based way
if UserVars.lootsack.nil? or UserVars.lootsack.empty?
	echo '** lootsack has not been set, set it with ;vars set lootsack=<container>'
	exit
end

if $nesbounty[:enable_skin] and (UserVars.skinsack.nil? or UserVars.skinsack.empty?)
	echo '** skinsack has not been set, set it with ;vars set skinsack=<container>'
	exit
end

lootsack = GameObj.inv.find { |i| i.noun =~ /#{UserVars.lootsack}/ } or GameObj.inv.find { |i| i.name =~ /#{UserVars.lootsack}/ }
skinsack = GameObj.inv.find { |i| i.noun =~ /#{UserVars.skinsack}/ } or GameObj.inv.find { |i| i.name =~ /#{UserVars.lootsack}/ }

if lootsack.nil?
	echo '** failed to find your lootsack, set it with ;set change lootsack [container]'
	exit
end

if $nesbounty[:enable_skin] and skinsack.nil?
	echo '** failed to find your skinsack, set it with ;set change skinsack [container]'
	exit
end

# You have been tasked to recover a peridot-inset pewter ring that an unfortunate citizen lost after being attacked by a storm giant in the Upper Trollfang near Wehnimer's Landing.  The heirloom can be identified by the initials MG engraved upon it.  Hunt down the creature and LOOT the item from its corpse.

bounty_patterns = {
	'none' => '^You are not currently assigned a task\.',

	# help
	'help_bandit'    => 'It appears they have a bandit problem',
	'help_creature'  => 'It appears they have a creature problem they\'d like you to solve\.',
	'help_resident'  => 'It appears that a local resident urgently needs our help in some matter\.',
	'help_heirloom'  => 'It appears they need your help in tracking down some kind of lost heirloom\.',
	'help_gemdealer' => 'The local gem dealer, .*, has an order to fill and wants our help\.',
	'help_herbalist' => 'local herbalist|local healer|local alchemist',
	'help_furrier'   => 'The local furrier',

	# in progress
	'task_bandit'    => '^You have been tasked to suppress bandit activity (?:in|on|near) (?:the )?(.*)\s(?:near|between|under|\.)',
	'task_escort'    => '^You have made contact with the child',
	'task_dangerous' => 'You have been tasked to hunt down and kill a particularly dangerous (.*) that has established a territory (?:in|on|near) (?:the )?(.*)(?:\s(?:near|between|under)|\.)\s+You can',
	'task_provoked'  => 'You have been tasked to hunt down and kill a particularly dangerous (.*) that has established a territory (?:in|on|near) (?:the )?(.*)(?:\s(?:near|between|under)|\.)\s+You have provoked',
	'task_dealer'    => '^The(?: local)? gem dealer',
	'task_forage'    => 'concoction that requires (?:a|an|some) (.*) found (?:in|on|near) (?:the )?(.*?)(?: near| between| under|\.).*These samples must be in pristine condition\.\s+You have been tasked to retrieve (\d+) (?:more )?samples?\.',
	'task_cull'      => 'You have been tasked to(?: help \w*)?(?: (?:retrieve an heirloom|kill a dangerous creature|rescue a missing child) by)? suppress(?:ing)? (.*) activity (?:in|on) (?:the )?(.*)(?:\s(?:near|between|under)|\.)',
	'task_search'    => 'unfortunate citizen lost after being attacked by (?:a|an) (.*?) (?:in|on|near) (?:the )?(.*?)\s?(?:near|between|under|\.  The).*SEARCH',
	'task_heirloom'  => 'unfortunate citizen lost after being attacked by (?:a|an) (.*?) (?:in|on|near) (?:the )?(.*?)\s?(?:near|between|under|\.  The).*LOOT',
	'task_found'     => 'You have located .* and should bring it back',
	'task_skin'      => '^You have been tasked to retrieve (\d+|\w+)s? (.*) of at least .*\.  You can SKIN them off the corpse of (?:a|an) (.*) or ',
	'task_rescue'    => 'A local divinist has had visions of the child fleeing from (?:a|an) (.*) (?:in|on) (?:the )?(.*) (?:near|between|under)',

	# fail
	'fail_child' => 'The child you were tasked to rescue is gone and your task is failed\.',

	# success
	'success'          => '^You have succeeded in your task and can return',
	'success_guard'    => '^You succeeded in your task and should report back to',
	'success_heirloom' => '^You have located (?:a|an|the|some) (.*) and should bring it back .*\.$'
}
;
setup = proc {
	script_name = script.name

	action   = nil
	@window   = nil
	notebook = nil

   nil

	locations = $nesbounty[:locations].dup
	location  = nil

	error = proc { |msg|

		dlg = Gtk::MessageDialog.new(
			:parent => @window,
			:flags => [:modal, :destroy_with_parent],
	  :type => :info,
			:buttons => :ok,
	  :message => msg
		)
	dlg.run
	dlg.destroy
  }

	widgets = {
		:gui_widgets => {
			# buttons
			:close  => Gtk::Button.new(:label => 'Close'),
			:create => Gtk::Button.new(:label => 'Create'),
			:delete => Gtk::Button.new(:label => 'Delete'),
			:save   => Gtk::Button.new(:label => 'Save & Close'),

			# combos
			:locations => Gtk::ComboBoxText.new,

			# entries
			:new_name => Gtk::Entry.new,
		},

		:location_widgets => {
			# check buttons
			:enable_bounty_only      => Gtk::CheckButton.new('Only attack bounty critters'),
			:enable_hunting_rotation => Gtk::CheckButton.new('In hunting rotation'),
			:enable_search_only      => Gtk::CheckButton.new('Only search here (no hunting)'),

			#entries
			:location   => Gtk::Entry.new,
			:skins      => Gtk::Entry.new,
			:targets    => Gtk::Entry.new,
			:room       => Gtk::Entry.new,
			:boundaries => Gtk::Entry.new,
		},

		# check buttons
		:enable_cull          => Gtk::CheckButton.new('Cull critters'),
		:enable_dangerous     => Gtk::CheckButton.new('Dangerous critter'),
		:enable_forage        => Gtk::CheckButton.new('Forage herbs'),
		:enable_loot          => Gtk::CheckButton.new('Loot heirloom'),
		:enable_rescue        => Gtk::CheckButton.new('Rescue child'),
		:enable_search        => Gtk::CheckButton.new('Search heirloom'),
		:enable_bandit        => Gtk::CheckButton.new('Bandits'),
		:enable_skin          => Gtk::CheckButton.new('Skin critters'),
		:enable_expedite      => Gtk::CheckButton.new('Expedite bounties'),
		:enable_bandit_script => Gtk::CheckButton.new('Use bandit script'),
		:enable_hunt_complete => Gtk::CheckButton.new('Hunt until complete?'),
		:enable_turn_in_bounty => Gtk::CheckButton.new('Force turn in if new bounty'),

		# entries
		:hunting_scripts      => Gtk::Entry.new,
		:bandit_script        => Gtk::Entry.new,
		:pre_search_commands  => Gtk::Entry.new,
		:post_search_commands => Gtk::Entry.new,
		:pre_forage_commands  => Gtk::Entry.new,
		:post_forage_commands => Gtk::Entry.new,
		:forage_retry_delay   => Gtk::Entry.new,
		:loot_script          => Gtk::Entry.new,
		:turn_in_percent      => Gtk::Entry.new,

		:should_hunt_mind   => Gtk::Entry.new,
		:should_hunt_mana   => Gtk::Entry.new,
		:should_hunt_spirit => Gtk::Entry.new,

		:hunt_pre_commands => Gtk::Entry.new,
		:hunt_commands_a   => Gtk::Entry.new,
		:hunt_commands_b   => Gtk::Entry.new,
		:hunt_commands_c   => Gtk::Entry.new,

		:should_rest_mana    => Gtk::Entry.new,
		:should_rest_mind    => Gtk::Entry.new,
		:should_rest_encum   => Gtk::Entry.new,
		:should_rest_wounded => Gtk::Entry.new,

		:rest_in_commands  => Gtk::Entry.new,
		:rest_out_commands => Gtk::Entry.new,
		:rest_pre_commands => Gtk::Entry.new,
		:rest_room         => Gtk::Entry.new,
		:rest_scripts      => Gtk::Entry.new
	}

	Gtk.queue {
		update_disabled = proc {
			widgets[:location_widgets].each { |key, widget|
		if location.nil?
					widget.set_sensitive(false)
				else
					widget.set_sensitive(true)
				end
			}
		}

		populate_locations = proc {
			loop {
		break if not widgets[:gui_widgets][:locations].model.iter_first
				#widgets[:gui_widgets][:locations].remove_text(0)
		widgets[:gui_widgets][:locations].remove(0)
			}

			locations.keys.sort.each { |text|
		widgets[:gui_widgets][:locations].append_text(text)
			}

		}

		save_location = proc {
			widgets[:location_widgets].each { |key, widget|
				if widget.class == Gtk::CheckButton
					value = widget.active?
				elsif [:skins, :targets, :boundaries].include?(key)
					value = widget.text.strip.split(',').collect { |item| item.strip }
				else
					value = widget.text.strip
				end

				locations[location][key] = value
			}
		}

		attach_signals = proc {
			widgets[:gui_widgets][:close].signal_connect 'clicked' do action = :close end
			widgets[:gui_widgets][:save].signal_connect 'clicked' do action = :save; save_location.call end
	  @window.signal_connect('destroy') do action = :close end

###
### Something in here when clicking create kills the connection/exits the game
###

			widgets[:gui_widgets][:create].signal_connect 'clicked' do
				name = widgets[:gui_widgets][:new_name].text.strip

				if name.nil? or name.empty? or name == '' or name.length < 3
					msg("You need to enter a name!","error")
				elsif locations.keys.find { |n| n.downcase.strip == name.downcase.strip }
					msg("A location with that name already exists!","error")
				else
					locations[name] = {}
					widgets[:gui_widgets][:new_name].text = ''
					populate_locations.call
					update_disabled.call
				end
			end

###
### Creation script end...
###

			widgets[:gui_widgets][:delete].signal_connect 'clicked' do
				Gtk.queue {
					if widgets[:gui_widgets][:locations].active == -1
						msg("You do not have a location selected!","error")
					else
						locations.delete(widgets[:gui_widgets][:locations].active_text)
						widgets[:gui_widgets][:locations].remove(widgets[:gui_widgets][:locations].active)

						widgets[:location_widgets].each { |key, widget|
							if widget.class == Gtk::CheckButton
								widget.active = (false)
							else
								widget.text = ("")
							end
						}
					end
				}
			end

			widgets[:gui_widgets][:locations].signal_connect 'changed' do
				Gtk.queue {
					save_location.call
					location = widgets[:gui_widgets][:locations].active_text
					if locations[location]
						widgets[:location_widgets].each { |key, widget|
							if widget.class == Gtk::CheckButton
								widget.active = (!!locations[location][key])
							elsif [:skins, :targets, :boundaries].include?(key)
								widget.text = (locations[location][key].join(',')) if not (locations[location][key].nil?)
							else
								widget.text = (locations[location][key].strip)
							end
						}
					end

					update_disabled.call
				}
			end
		}

		# main window
		@window = Gtk::Window.new
		@window.border_width = 5
#        @window.keep_above = true  ## this setting prevents the modal ERROR dialog from appearing over it
		@window.resizable = true
		@window.resize 500, 300
		@window.set_window_position(:center)

		# main notebook (tabs)
		notebook = Gtk::Notebook.new
		notebook.show_border = true

		vbox_main = Gtk::Box.new(:vertical)
		vbox_main.pack_start notebook

		# sbounty options
		vbox = Gtk::Box.new(:vertical)

		frm = Gtk::Frame.new('Locations').set_border_width(3)
		tbl = Gtk::Table.new(7, 4, true).set_border_width(3)

		tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('New name: ')), 0, 1, 0, 1
		tbl.attach widgets[:gui_widgets][:new_name], 1, 3, 0, 1
		tbl.attach widgets[:gui_widgets][:create], 3, 4, 0, 1

		tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Locations: ')), 0, 1, 1, 2
		tbl.attach widgets[:gui_widgets][:locations], 1, 3, 1, 2
		tbl.attach widgets[:gui_widgets][:delete], 3, 4, 1, 2

		tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Location: ')), 0, 1, 3, 4
		tbl.attach widgets[:location_widgets][:location], 1, 2, 3, 4
		tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Skins: ')), 2, 3, 3, 4
		tbl.attach widgets[:location_widgets][:skins], 3, 4, 3, 4

		tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Targets: ')), 0, 1, 4, 5
		tbl.attach widgets[:location_widgets][:targets], 1, 2, 4, 5

		tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Room #: ')), 0, 1, 5, 6
		tbl.attach widgets[:location_widgets][:room], 1, 2, 5, 6
		tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Boundaries: ')), 2, 3, 5, 6
		tbl.attach widgets[:location_widgets][:boundaries], 3, 4, 5, 6

		tbl.attach widgets[:location_widgets][:enable_hunting_rotation], 0, 1, 6, 7
		tbl.attach widgets[:location_widgets][:enable_bounty_only], 1, 2, 6, 7
		tbl.attach widgets[:location_widgets][:enable_search_only], 2, 3, 6, 7

		frm.add(tbl)
		vbox.pack_start(frm)

		frm = Gtk::Frame.new('Bounties').set_border_width(3)
		tbl = Gtk::Table.new(5, 4, true).set_border_width(3)

		tbl.attach widgets[:enable_cull], 0, 1, 0, 1; widgets[:enable_cull].active = $nesbounty[:enable_cull]
		tbl.attach widgets[:enable_dangerous], 1, 2, 0, 1; widgets[:enable_dangerous].active = $nesbounty[:enable_dangerous]
		tbl.attach widgets[:enable_rescue], 2, 3, 0, 1; widgets[:enable_rescue].active = $nesbounty[:enable_rescue]
		tbl.attach widgets[:enable_skin], 3, 4, 0, 1; widgets[:enable_skin].active = $nesbounty[:enable_skin]

		tbl.attach widgets[:enable_loot], 0, 1, 1, 2; widgets[:enable_loot].active = $nesbounty[:enable_loot]
		tbl.attach widgets[:enable_search], 1, 2, 1, 2; widgets[:enable_search].active = $nesbounty[:enable_search]
		tbl.attach widgets[:enable_forage], 2, 3, 1, 2; widgets[:enable_forage].active = $nesbounty[:enable_forage]
		tbl.attach widgets[:enable_bandit], 3, 4, 1, 2; widgets[:enable_bandit].active = $nesbounty[:enable_bandit]

		tbl.attach widgets[:enable_bandit_script], 1, 2, 2, 3; widgets[:enable_bandit_script].active = $nesbounty[:enable_bandit_script]
		tbl.attach widgets[:enable_expedite], 2, 3, 2, 3; widgets[:enable_expedite].active = $nesbounty[:enable_expedite]
		tbl.attach widgets[:enable_hunt_complete], 3, 4, 2, 3; widgets[:enable_hunt_complete].active = $nesbounty[:enable_hunt_complete]

		tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('turn in when mind >= ')), 0, 1, 3, 4
		tbl.attach widgets[:turn_in_percent], 1, 2, 3, 4; widgets[:turn_in_percent].text = ($nesbounty[:turn_in_percent].to_s)
		tbl.attach widgets[:enable_turn_in_bounty], 3, 4, 3, 4; widgets[:enable_turn_in_bounty].active = $nesbounty[:enable_turn_in_bounty]

		tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('hunting scripts:')), 2, 3, 4, 5
		tbl.attach widgets[:hunting_scripts], 3, 4, 4, 5; widgets[:hunting_scripts].text = ($nesbounty[:hunting_scripts].collect { |a| a.strip }.join(','))
		tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('bandit script:')), 0, 1, 4, 5
		tbl.attach widgets[:bandit_script], 1, 2, 4, 5; widgets[:bandit_script].text = ($nesbounty[:bandit_script])

		tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('pre-search commands: ')), 0, 1, 5, 6
		tbl.attach widgets[:pre_search_commands], 1, 2, 5, 6; widgets[:pre_search_commands].text = ($nesbounty[:pre_search_commands].collect { |a| a.strip }.join(','))
		tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('post-search commands: ')), 2, 3, 5, 6
		tbl.attach widgets[:post_search_commands], 3, 4, 5, 6; widgets[:post_search_commands].text = ($nesbounty[:post_search_commands].collect { |a| a.strip }.join(','))

		tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('pre-forage commands: ')), 0, 1, 6, 7
		tbl.attach widgets[:pre_forage_commands], 1, 2, 6, 7; widgets[:pre_forage_commands].text = ($nesbounty[:pre_forage_commands].collect { |a| a.strip }.join(','))
		tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('post-forage commands: ')), 2, 3, 6, 7
		tbl.attach widgets[:post_forage_commands], 3, 4, 6, 7; widgets[:post_forage_commands].text = ($nesbounty[:post_forage_commands].collect { |a| a.strip }.join(','))

		tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('forage retry delay: ')), 0, 1, 7, 8
		tbl.attach widgets[:forage_retry_delay], 1, 2, 7, 8; widgets[:forage_retry_delay].text = ($nesbounty[:forage_retry_delay].to_s)
		tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('loot script: ')), 2, 3, 7, 8
		tbl.attach widgets[:loot_script], 3, 4, 7, 8; widgets[:loot_script].text = ($nesbounty[:loot_script].to_s)

		frm.add(tbl)
		vbox.pack_start(frm)

		notebook.append_page vbox, Gtk::Label.new('Locations / Options')

		# default options
		vbox = Gtk::Box.new(:vertical)

		frm = Gtk::Frame.new('Should Rest').set_border_width(3)
		tbl = Gtk::Table.new(3, 4, true).set_border_width(3)

		tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('when mind % >= ')), 0, 1, 0, 1
		tbl.attach widgets[:should_rest_mind], 1, 2, 0, 1; widgets[:should_rest_mind].text = ($nesbounty[:should_rest_mind].to_s)
		tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('or mana <= ')), 2, 3, 0, 1
		tbl.attach widgets[:should_rest_mana], 3, 4, 0, 1; widgets[:should_rest_mana].text = ($nesbounty[:should_rest_mana].to_s)

		tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('or encumbrance % >= ')), 0, 1, 1, 2
		tbl.attach widgets[:should_rest_encum], 1, 2, 1, 2; widgets[:should_rest_encum].text = ($nesbounty[:should_rest_encum].to_s)

		tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('or wounded eval: ')), 0, 1, 2, 3
		tbl.attach widgets[:should_rest_wounded], 1, 4, 2, 3; widgets[:should_rest_wounded].text = ($nesbounty[:should_rest_wounded]._dump)

		frm.add(tbl)
		vbox.pack_start(frm)

		frm = Gtk::Frame.new('Resting').set_border_width(3)
		tbl = Gtk::Table.new(2, 4, true).set_border_width(3)

		tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('room #: ')), 0, 1, 0, 1
		tbl.attach widgets[:rest_room], 1, 2, 0, 1; widgets[:rest_room].text = ($nesbounty[:rest_room].to_s)
		tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('pre-rest commands: ')), 2, 3, 0, 1
		tbl.attach widgets[:rest_pre_commands], 3, 4, 0, 1; widgets[:rest_pre_commands].text = ($nesbounty[:rest_pre_commands].collect { |a| a.strip }.join(','))

		tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('enter commands: ')), 0, 1, 1, 2
		tbl.attach widgets[:rest_in_commands], 1, 2, 1, 2; widgets[:rest_in_commands].text = ($nesbounty[:rest_in_commands].collect { |a| a.strip }.join(','))
		tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('exit commands: ')), 2, 3, 1, 2
		tbl.attach widgets[:rest_out_commands], 3, 4, 1, 2; widgets[:rest_out_commands].text = ($nesbounty[:rest_out_commands].collect { |a| a.strip }.join(','))

		tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('scripts: ')), 0, 1, 2, 3
		tbl.attach widgets[:rest_scripts], 1, 4, 2, 3; widgets[:rest_scripts].text = ($nesbounty[:rest_scripts].collect { |a| a.strip }.join(','))

		frm.add(tbl)
		vbox.pack_start(frm)

		frm = Gtk::Frame.new('Should Hunt').set_border_width(3)
		tbl = Gtk::Table.new(2, 4, true).set_border_width(3)

		tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('when mind % <= ')), 0, 1, 0, 1
		tbl.attach widgets[:should_hunt_mind], 1, 2, 0, 1; widgets[:should_hunt_mind].text = ($nesbounty[:should_hunt_mind].to_s)
		tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('and mana >= ')), 2, 3, 0, 1
		tbl.attach widgets[:should_hunt_mana], 3, 4, 0, 1; widgets[:should_hunt_mana].text = ($nesbounty[:should_hunt_mana].to_s)

		tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('and spirit >= ')), 0, 1, 1, 2
		tbl.attach widgets[:should_hunt_spirit], 1, 2, 1, 2; widgets[:should_hunt_spirit].text = ($nesbounty[:should_hunt_spirit].to_s)

		frm.add(tbl)
		vbox.pack_start(frm)

		frm = Gtk::Frame.new('Hunting').set_border_width(3)
		tbl = Gtk::Table.new(2, 4, true).set_border_width(3)

		tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Pre-hunt commands: ')), 0, 1, 0, 1
		tbl.attach widgets[:hunt_pre_commands], 1, 2, 0, 1; widgets[:hunt_pre_commands].text = ($nesbounty[:hunt_pre_commands].collect { |a| a.strip }.join(','))
		tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Commands (a): ')), 2, 3, 0, 1
		tbl.attach widgets[:hunt_commands_a], 3, 4, 0, 1; widgets[:hunt_commands_a].text = ($nesbounty[:hunt_commands_a].collect { |a| a.strip }.join(',')).to_s

		tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Commands (b): ')), 0, 1, 1, 2
		tbl.attach widgets[:hunt_commands_b], 1, 2, 1, 2; widgets[:hunt_commands_b].text = ($nesbounty[:hunt_commands_b].collect { |a| a.strip }.join(',')).to_s
		tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Commands (c): ')), 2, 3, 1, 2
		tbl.attach widgets[:hunt_commands_c], 3, 4, 1, 2; widgets[:hunt_commands_c].text = ($nesbounty[:hunt_commands_c].collect { |a| a.strip }.join(',')).to_s

		frm.add(tbl)
		vbox.pack_start(frm)

		notebook.append_page vbox, Gtk::Label.new('Resting / Hunting')

		# main window widgets
		vbox = Gtk::Box.new(:vertical)
	valign = Gtk::Alignment.new(0, 1, 0, 0)
		vbox.pack_start(valign, :expand => false, :fill => false, :padding => 0)

		hbox = Gtk::Box.new(:horizontal)
		hbox.add widgets[:gui_widgets][:save]
		hbox.add widgets[:gui_widgets][:close]

		halign = Gtk::Alignment.new 1, 0, 0, 0
		halign.add hbox

		vbox.pack_start halign
		vbox_main.pack_start vbox

		# create the window
		attach_signals.call
		update_disabled.call
		populate_locations.call

		@window.add vbox_main
		@window.show_all
	}

###
### This line prevents the top right corner "X" from properly closing the gui
###

	before_dying { Gtk.queue { @window.destroy unless @window.destroyed? } }

###
### Why? I don't know...
###

	sleep 0.10 while action.nil?

	case action
		when :save
			$nesbounty[:locations] = locations

			widgets.each { |key, widget|
				next if [:location_widgets, :gui_widgets].include?(key)
				if widget.class == Gtk::CheckButton
					value = widget.active?
				elsif [:hunting_scripts, :pre_forage_commands, :post_forage_commands, :pre_search_commands, :post_search_commands, :hunt_pre_commands, :hunt_commands_a, :hunt_commands_b, :hunt_commands_c, :rest_in_commands, :rest_out_commands, :rest_pre_commands, :rest_scripts].include?(key)
					value = widget.text.strip.split(',').collect { |item| item.strip }
				elsif key == :should_rest_wounded
					value = StringProc.new widget.text.strip
				else
					value = widget.text.strip
				end

				$nesbounty[key] = value
			}
	end
}

def msg(text, type = "info")
  # send debug messages if debugging
  if type == "debug" and $debug == true
    echo ">> #{text}"
  elsif $frontend == 'stormfront' and type != "debug"
    if type == "error"
      puts "\<preset id=\"thought\"\>ERROR: #{text}\<\/preset\>"
    elsif type == "warn"
      puts "\<pushBold\/\>WARNING: #{text}\<popBold\/\>"
    elsif type == "info"
      puts "\<preset id=\"whisper\"\>#{text}\<\/preset\>"
    else
      echo text
    end
  elsif type == "error"
    echo "** #{text}"
  elsif type == "warn"
    echo "!! #{text}"
  elsif type == "info"
    echo "-- #{text}"
  end
end

change_stance = proc { |stance|
	return if Spell['Zealot'].active? or Spell['Frenzy'].active? or dead?

	while (cur_stance = checkstance) != stance
		res = dothistimeout "stance #{stance}", 2, /You are now|Roundtime|Wait|wait|Your rage causes you/
		if res =~ /Roundtime: (\d+)|wait (\d+)/i
			d = ($1 || $2).strip.to_f - 1
			if d > 0
				sleep (d)
			end
		elsif res =~ /Your rage causes you/
			Spell['Frenzy'].putup
			Spell['Frenzy'].timeleft = 30
		elsif cur_stance == 'guarded' and stance == 'defensive'
			break
		end
	end
}

kneel = proc {
	while true
		break if kneeling?
		waitrt?
		put 'kneel'
		sleep 0.50
	end
}

stand = proc {
	while true
		break if standing?
		waitrt?
		put 'stand'
		sleep 0.50
	end
}

# TODO: Remove this
error = proc { |msg|
	msg(msg,"error")
	exit
}

# TODO: Remove this
print = proc { |msg|
	msg(msg)
}

clean_skin = proc { |name|
	name.strip.downcase.gsub(/s$/, '').gsub(/teeth/, 'tooth').gsub(/hooves?/, 'hoof')
}

has_skins = proc {
	if bounty? =~ /#{bounty_patterns['task_skin']}/
		count = $1.to_i
		skin  = $2.downcase

		skinsack.contents.find_all { |item| item.name =~ /#{clean_skin.call(skin)}/i }.size >= (count + 3)
	else
		false
	end
}

is_bounty = proc { |types|
	result = []
  if types.class != Array
	types = [types]
  end
	types.each { |type| result.push(bounty_patterns[type]) if not bounty_patterns[type].nil? }

	!(bounty? =~ /#{result.join('|')}/).nil?
}

get_area_by_target = proc { | target |
  # find creature via target name
    creatures = Creatures.find_by_name(target)
    creature = creatures[0]
    # TODO: smarter way? error handling.
    msg("get_area_by_target call: #{creature.name}","debug")
    # find areas with that creature
    areas =  Areas.find_by_creature(creature.id)
}

check_level = proc { | target |
  creature = Creatures.find_by_name(target)[0]
  msg("creature level: #{creature.level}","debug")
  msg("target level: #{Char.level + $nesbounty[:level_mod]}","debug")
  creature.level < (Char.level + $nesbounty[:level_mod])
}

get_bounty_location = proc { |location, target|
  # TODO: Check creature level, allow max level check, avoid undead
  # if there's no location and only a target (creature)
  if location.nil?
    # handle skinning bounty
    if bounty? =~ /#{bounty_patterns['task_skin']}/
      # extract target via regex
      target   = $3.strip.downcase
      msg("skinning target: #{target}","debug")
      # find area via target
      areas = get_area_by_target.call(target)
      # TODO: use smarter way to pick this (closest?), and error handling
      location = areas[0].region
      msg("skinning location: #{location}","debug")
    else
      # handle other bounty types via regex
      bounty_patterns.each { |key,value|
          if bounty? =~ /#{value}/i
              target   = $1
              location = $2
              break
          end
      }
    end 
  end

  # track if a matching location has been found
  matched_area = false
  # location and target should now be defined
  if location and check_level.call(target)
  	hunt_area = ''
    # get all locations for the target
    msg("target for location: #{target}","debug")
    areas = get_area_by_target.call(target)
    msg("areas: #{areas}","debug")
    # find the one that matches the location
    areas.each do | area |
      # if region contains "the", strip it
      if area.region =~ /the/i
        area.region.slice! "the "
      end

      # match location to known regions for creature
      if location =~ /#{area.region}/i
        msg("matching location: #{location}","debug")
        msg("matched area: #{area.region}","debug")
        hunt_area = area
        # matching area found
        matched_area = true
        break
      end
    end

    # if no matching area name is found, use the first one available with the creature
    # this is disabled by default, a bad guess will leave you in an endless bounty
    # so use at your own peril!!!!
    msg("matched area: #{matched_area}","debug")
    if matched_area == false and $guess_area == true
      msg("No location match found, using first available","warn")
      hunt_area = areas[0]
      msg("unmatched hunt_area: #{hunt_area}","debug")
    elsif matched_area == false
      msg("No location match found, removing bounty","warn")
      next false
    end

    # handle provoke bounties
    if target and is_bounty.call 'task_provoked'
      # add the ancient|grizzled to target (needs testing)
      if target !~ /ancient|grizzled/i
        target = "(?:ancient|grizzled).*#{target}"
        msg("provoked target: #{target}","debug")
      end
    end
 	
 	  msg("location: #{location}","debug")
    msg("target: #{target}","debug")
    msg("region: #{hunt_area.region}","debug")
    msg("start: #{hunt_area.start}","debug")
    msg("boundaries: #{hunt_area.boundaries.collect{|i| i.to_s.tr('^0-9','')}}","debug")
    # format boundaries
    boundaries = hunt_area.boundaries.collect{|i| i.to_s.tr('^0-9','')}

    # use alternate commands for skinning bounties
    if bounty? =~ /#{bounty_patterns['task_skin']}/
      target.concat(" (b)")
    end

    # present data in expected format
    name = location
    data = {}
    data[:enable_bounty_only] = true
    data[:enable_hunting_rotation] = false
    data[:enable_search_only] = false
    data[:skins] = []
    data[:location] = location
    data[:targets] = [target]
    data[:room] = hunt_area.start.to_s
    data[:boundaries] = boundaries

    msg("name: #{name}","debug")
    msg("data: #{data}","debug")
    pause 1
    [name, data]
  else
    if !check_level.call(target)
        msg("Bounty above level threshold.")
    else
        msg("Could not find bounty location.")
    end
    nil
  end
}

get_herb_rooms = proc { |location, herb|
	target_list = Array.new
	names = [herb]

	if herb == 'ayana leaf'
		names = [herb, 'ayana leaf', 'ayana lichen', 'ayana weed', 'ayana berry', 'ayana root']
	elsif herb == "ayana'al leaf"
		names = [herb, 'ayana\'al leaf', 'ayana\'al lichen', 'ayana\'al weed', 'ayana\'al berry', 'ayana\'al root']
	end

	Room.list.each { |room|
		if room.tags.find { |tag| names.find { |name| tag =~ /#{name}/i } }
			target_list.push(room.id)
		end
	}

	previous, shortest_distances = Map.dijkstra(Room.current.id)

	if location
		# delete the room if it's not the correct location
		target_list.delete_if { |room_num|
			if Room[room_num].location.nil?
				Room[room_num].title[0] !~ /#{location}/i
			elsif not Room[room_num].location.nil?
				Room[room_num].location !~ /#{location}/i
			else
				false
			end
		}
	end

	if target_list.length == 0
		similar = Room.tags.find_all { |tag| tag =~ /#{herb}/i }

		if not similar.empty?
			herb = similar.join(', ')
			Room.list.each { |room| target_list.push(room.id) if room.tags.include?(herb) }

			previous, shortest_distances = Map.dijkstra(Room.current.id)

			if location
				target_list.delete_if { |room_num| (Room[room_num].location == nil && Room[room_num].title[0] !~ /#{location}/i) }
				target_list.delete_if { |room_num| (Room[room_num].location != nil && Room[room_num].location !~ /#{location}/i) }
			end
		end
	end

	previous, shortest_distances = Map.dijkstra($nesbounty[:rest_room])
	target_list.delete_if { |room| shortest_distances[room].nil? or shortest_distances[room] > 600 }
}

can_turn_in = proc {
	is_bounty.call ['success', 'success_guard', 'success_heirloom'] and (
		$nesbounty[:turn_in_percent].nil? or
		$nesbounty[:enable_turn_in_bounty] and not Spell['Next Bounty'].active? or
		percentmind >= $nesbounty[:turn_in_percent].to_i and checkmind !~ /saturated/
	)
}

can_do_bounty = proc {
	if not can_do_bounty_cache.nil?
		; # intentionally left blank
	elsif is_bounty.call ['success', 'success_heirloom', 'success_guard']
		can_do_bounty_cache = true
	elsif is_bounty.call ['task_bandit'] and $nesbounty[:enable_bandit] and bounty? !~ /Locksmehr Trail/
		can_do_bounty_cache = true
	elsif ((is_bounty.call 'task_search' and $nesbounty[:enable_search] and get_bounty_location.call) or (is_bounty.call 'task_heirloom' and $nesbounty[:enable_loot] and get_bounty_location.call))
		can_do_bounty_cache = true
	elsif bounty? =~ /#{bounty_patterns['task_forage']}/ and $nesbounty[:enable_forage] and not get_herb_rooms.call($2, $1).empty? and bounty? !~ /green fleshbulb/
		can_do_bounty_cache = true
		# and bounty? !~ /exceptional|outstanding|superb|magnificent/
	elsif is_bounty.call 'task_skin' and $nesbounty[:enable_skin] and get_bounty_location.call
		can_do_bounty_cache = true
	elsif is_bounty.call ['task_provoked', 'task_dangerous'] and $nesbounty[:enable_dangerous] and get_bounty_location.call
		can_do_bounty_cache = true
	elsif is_bounty.call 'task_cull' and $nesbounty[:enable_cull] and get_bounty_location.call
		can_do_bounty_cache = true
	elsif (is_bounty.call 'task_escort' and $nesbounty[:enable_rescue]) or (is_bounty.call 'task_rescue' and $nesbounty[:enable_rescue] and get_bounty_location.call)
		can_do_bounty_cache = true
	else
		can_do_bounty_cache = false
	end

	$nesbounty_can_do_bounty = can_do_bounty_cache

	can_do_bounty_cache
}

should_hunt = proc {
  res = false

  if is_bounty.call ['success', 'success_heirloom', 'success_guard'] and not can_turn_in.call
	res = true
	# on start if less than numb then always try to do bounty
	elsif (can_do_bounty.call and not fried? and not saturated? and first_run)
		res = true
	elsif (not can_do_bounty.call or is_bounty.call ['success', 'success_heirloom', 'success_guard'] or not $nesbounty[:enable_hunt_complete]) and percentmind > $nesbounty[:should_hunt_mind].to_i
		hunt_reason = 'mind not clear enough'
		;
	elsif not checkmana($nesbounty[:should_hunt_mana].to_i)
		hunt_reason = 'out of mana'
		;
	elsif not checkspirit($nesbounty[:should_hunt_spirit].to_i)
		hunt_reason = 'low spirit'
		;
	else
		res = true
	end

  res
}

should_rest = proc {
	if $nesbounty[:should_rest_wounded].call
		rest_reason = 'wounded'
		true
	elsif $nesbounty_rest
		if $nesbounty_rest_reason
			rest_reason = $nesbounty_rest_reason
		else
			rest_reason = '$nesbounty_rest was set'
		end

		if $nesbounty_rest_until
			if Time.now.to_i > $nesbounty_rest_until
				$nesbounty_rest = false
				$nesbounty_rest_reason = nil
				$nesbounty_rest_until = nil
			end
		else
			$nesbounty_rest = false
			$nesbounty_rest_reason = nil
		end

		true
	elsif not checkmana($nesbounty[:should_rest_mana].to_i)
		rest_reason = 'out of mana'
		true
	elsif checkencumbrance($nesbounty[:should_rest_encum].to_i)
		rest_reason = 'encumbered'
		true
	elsif is_bounty.call 'task_provoked'
		false
	elsif is_bounty.call 'task_forage' and can_do_bounty.call and Time.now.to_i < last_forage_attempt + last_forage_delay and percentmind >= $nesbounty[:should_rest_mind].to_i
		rest_reason = 'mind is full (waiting on foraging cooldown)'
		true
	elsif ((not can_turn_in.call and is_bounty.call ['success', 'success_guard', 'success_heirloom']) or not can_do_bounty.call or not $nesbounty[:enable_hunt_complete]) and percentmind >= $nesbounty[:should_rest_mind].to_i
		rest_reason = 'mind is full'
		true
	else
		rest_reason = nil
		false
	end
}

wander = proc { |boundaries|
  room = Room.current
  next_room_options = room.wayto.keys - boundaries
  next_room_options.delete_if { |room_id| (room.timeto[room_id].class == Proc) and room.timeto[room_id].call.nil? }
  next_room = next_room_options.find_all { |r| not $nesbounty_wander_rooms.include?(r) }
  if next_room.empty?
	next_room = $nesbounty_wander_rooms.find { |r| next_room_options.include?(r) }
  else
	next_room = next_room[rand(next_room.length)]
  end
  $nesbounty_wander_rooms.delete(next_room)
  $nesbounty_wander_rooms.push(next_room)
  way = room.wayto[next_room]
  if way.class == String
	move(way)
  else
	way.call
  end
}

go2 = proc { |room|
	next if Room.current.id.to_s == room.to_s

	if checkarea =~ /Table/
	if room.to_s == $nesbounty[:rest_room].to_s
	  next
	end

		stand.call()
		move 'out'
	end

	wait_while { running? 'go2' }
	start_script('go2', [ room.to_s, '_disable_confirm_' ], h={:quiet=>true});
	wait_while { running? 'go2' }
}

go2_nearest = proc { |list|
	room = Room[$nesbounty[:rest_room]].find_nearest(list)
	if room.nil?
		msg("Failed to find nearest room.","error")
	end

	go2.call(room)
}

go2_nearest_tag = proc { |tag|
	if checkarea =~ /Table/i
		stand.call()
		fput 'out'
	end

	town = Room[$nesbounty[:rest_room]].find_nearest_by_tag('town')
	room = Room[town].find_nearest_by_tag(tag)

	if room.nil?
		msg("Failed to find room by tag: #{tag}.","error")
	end

	go2.call(room)
}

run_commands = proc { |commands|
	next if commands.empty?

	if commands.class != Array
		msg("run_commands expects an input array.","error")
	end

	commands.each { |command|
		if command[0] == ';'
			scriptname = command[1..-1]
			start_script scriptname
			wait_while { running? scriptname }
		else
			fput command
		end
	}
}

run_scripts = proc { |scripts|
	scripts.each { |script|
		args   = script.split(' ')
		script = args.shift

		start_script(script, args, true)
		wait_while { running? script }
	}
}

run_loot_script = proc {
	wait_while { running? $nesbounty[:loot_script] }
	start_script($nesbounty[:loot_script], [], true)
	wait_while { running? $nesbounty[:loot_script] }
}

hunt_prepare = proc {
	run_commands.call($nesbounty[:hunt_pre_commands])
}

start_hunting_scripts = proc {
	$nesbounty[:hunting_scripts].each { |script|
		start_script(script, [], h={:quiet=>true}) if not running?(script)
	}
}

kill_hunting_scripts = proc {
	$nesbounty[:hunting_scripts].each { |script|
		stop_script(script) if running?(script)
	}
}

rest_goto = proc {
	next if in_rest_area
	go2.call($nesbounty[:rest_room])
}

rest_exit = proc {
	next unless in_rest_area
	if Room.current.id != $nesbounty[:rest_room] and Room.current.path_to($nesbounty[:rest_room]).nil?
	run_commands.call($nesbounty[:rest_out_commands])
	end
	in_rest_area = false
}

rest_enter = proc {
	next if in_rest_area
	if Room.current.id != $nesbounty[:rest_room] and Room.current.path_to($nesbounty[:rest_room]).nil?
		run_commands.call($nesbounty[:rest_in_commands])
	end
	in_rest_area = true
}

rest_run_scripts = proc {
	rest_exit.call
	run_scripts.call($nesbounty[:rest_scripts])
}

reload_hunter = proc {
	$NESBOUNTY_HUNTER_SETUP.call($nesbounty.to_hash.dup, get_bounty_location.call)
	$NESBOUNTY_HUNTER_RELOAD.call
}

start_hunter = proc { |location|
	$NESBOUNTY_HUNTER_SETUP.call($nesbounty.to_hash.dup, location)
	$NESBOUNTY_CURRENT_LOCATION = location
	start_script($NESBOUNTY_HUNTER_NAME, [], false)
}

find_taskmaster = proc {
  npc = GameObj.npcs.find { |t| t.name =~ /taskmaster/i }
  if npc.nil?
    msg("Failed to find taskmaster!","error")
  end
  npc
}

finish_hunt = proc {
	if running? $NESBOUNTY_HUNTER_NAME
		stop_script($NESBOUNTY_HUNTER_NAME)
		wait_while { running? $NESBOUNTY_HUNTER_NAME }
	end

	stop_script 'go2' if running? 'go2'
	change_stance.call('defensive')

	# pause to make sure looter isn't running
	wait_while { running? $nesbounty[:loot_script] }

	# run loot script in case the hunter wasn't able to clean up
	if GameObj.npcs.find { |npc| npc.status =~ /dead/ } or is_bounty.call 'success_heirloom'
		run_loot_script.call
	end
}

remove_bounty = proc {
	next if (not $nesbounty[:enable_expedite] and Spell['Next Bounty'].active?) or is_bounty.call 'none'

	rest_exit.call

	kill_script 'go2' if running? 'go2'

	go2_nearest_tag.call('advguild')

	msg("Removing bounty in #{$sleep_default} seconds, ;stop nesbounty to prevent this.","warn")
	sleep $sleep_default

	npc = find_taskmaster.call()

	res = dothistimeout "ask #{npc} about remove", 5, /^#{npc}.*?want to be removed|Trying to sneak/
	if res =~ /Trying to sneak/
		fput "ask #{npc} about bounty"
	else
		dothistimeout "ask #{npc} about remove", 5, /^#{npc}.*?have removed you/
	end

	can_do_bounty_cache = nil
}

expedite_bounty = proc {
	msg("Expediting bounty in #{$sleep_default} seconds. ;stop nesbounty to prevent this.","warn")
	sleep $sleep_default

	remove_bounty.call

	rest_exit.call
	go2_nearest_tag.call('advguild')

	npc = find_taskmaster.call()

	res = dothistimeout "ask #{npc} about expedite", 5, /I'll expedite|You don't seem to have any expedited task reassignment|I still need to complete/
	if res =~ /expedited/
		expedite_left = false
	end

	can_do_bounty_cache = nil
}

get_bounty = proc {
	rest_exit.call

	go2_nearest_tag.call('advguild')

	npc = GameObj.npcs.find { |t| t.name =~ /taskmaster/i }
	res = dothistimeout "ask ##{npc.id} for bounty", 2, /(?:protective escort|creature problem|local gem dealer|local furrier|lost heirloom|local healer|local herbalist|local alchemist|local resident|bandit problem|I'm kind of busy right now|I don't seem to have any)/

	if res.nil?
		msg("Invalid response from taskmaster!","error")
	elsif res =~ /in about (\d+) minutes|in about a minute/
		time = $1.nil? ? 1 : $1.to_i

		Spell['Next Bounty'].putup
		Spell['Next Bounty'].timeleft = time
	elsif res =~ /but I don't seem to have/
		Spell['Next Bounty'].putup
		Spell['Next Bounty'].timeleft = 9999
	elsif res =~ /bandit/
		remove_bounty.call
	end

	can_do_bounty_cache = nil
}

talk_to_herbalist = proc {
	go2_nearest.call([ 3824, 1851, 10396, 640, 5722, 2406, 11002, 9505 ])

	if Room.current.id == 10396
		npc = 'maraene'
	else
		npc = GameObj.npcs.find { |t| t.name =~ /brother Barnstel|scarred Agarnil kris|healer|herbalist|merchant Kelph|famed baker Leaftoe|Akrash|old Mistress Lomara/i }
	end

	if is_bounty.call 'help_herbalist'
		res = dothistimeout "ask #{npc} about bounty", 5, /Yes, I do have a task for you/
		if res =~ /I've recently received an order for ([0-9]+) (.*?)\./
			msg("Received bounty from herbalist [#{$1} #{$2}].")
		end
	elsif bounty? =~ /#{bounty_patterns['task_forage']}/
		herb_name = $1.gsub(/s?$/,'')
		herbs     = lootsack.contents.find_all { |item| item.name =~ /#{herb_name}/ }

		if herbs.empty?
			msg("No herbs to turn in!","error")
		end

		prev_item = nil
		if GameObj.right_hand
			prev_item = GameObj.right_hand

			fput 'store right' if checkright
			fput 'stow right' if checkright
		end

		herbs.each { |herb|
			fput "get ##{herb.id} from ##{lootsack.id}"
			result = dothistimeout "give ##{herb.id} to #{npc}", 3, /This looks perfect|That looks like it has been partially used up/

			if result !~ /perfect/
				fput "drop ##{herb.id}"
			end
		}

		if prev_item
			fput "get ##{prev_item.id}"
		end
	else
		msg("Why are you at the herbalist?","error")
	end
}

talk_to_gemdealer = proc {
	go2_nearest_tag.call('gemshop')

	if Room.current.id == 10327
		npc = 'areacne'
	else
		npc = GameObj.npcs.find { |t| t.name =~ /dwarven clerk|gem dealer|jeweler|Zirconia/i }
	end

	res = dothistimeout "ask #{npc} about bounty", 5, /Yes, I do have a task for you/
	if res =~ /interested in purchasing an? (.*?)\. .* go round up ([0-9]+) of them/
		name  = $1
		count = $2.to_i

		msg("Received bounty from gem dealer [#{count} #{name}].")
	end
}

talk_to_furrier = proc {
	go2_nearest_tag.call('furrier')

	if Room.current.id == 10327
		npc 'areacne'
	else
		npc = GameObj.npcs.find { |t| t.name =~ /dwarven clerk|furrier/i }
	end

	res = dothistimeout "ask #{npc} about bounty", 5, /Yes, I do have a task for you/
	if res =~ /I've recently received an order for ([0-9]+) (.*?)\./
		msg("Received bounty from furrier [#{$1} #{$2}].")
	end
}

get_guard_npc = proc {
	if Room.current.id == 10915
		'purser'
	else
		GameObj.npcs.find { |npc| npc.name =~ /guard|sergeant|guardsman|purser|Belle/i }
	end
}

find_guard = proc {
	go2_nearest_tag.call('advguard')
	npc = get_guard_npc.call

	if npc.nil?
		go2_nearest_tag.call('advguard2')
		npc = get_guard_npc.call
	end

	if npc.nil?
		msg("Failed to locate guard.","error")
	end

	npc
}

talk_to_guard = proc {
	npc = find_guard.call

	res = dothistimeout "ask #{npc} about bounty", 5, /Yes, we do have a task for you|Ah, so you have returned/
	if res.nil?
		msg("Unknown response from guard: #{res}", "error")
	end
}

get_random_location = proc {
	keys = []
	$nesbounty[:locations].each { |key, data|
		if data[:enable_hunting_rotation]
			keys.push(key)
		end
	}
	name = keys[rand(keys.size)]

	if name.nil?
		msg("Failed to find a hunting area!","error")
	end

	[ name, $nesbounty[:locations][name] ]
}

task_escort = proc { |target|
	msg("Escorting child to #{target}.")

	path  = []
	step2 = proc { |destination_room|
		unless path and (s = path.index(Room.current.id)) and (d = path.index(destination_room)) and (s < d)
			previous, shortest_distances = Map.dijkstra(Room.current.id, destination_room)
			unless previous[destination_room]
				msg("error: failed to find a path between your current room (#{ROom.current.id}) and destination room (#{destination_room})","debug")
				exit
			end
			path = [ destination_room ]
			path.push(previous[path[-1]]) until previous[path[-1]].nil?
			path.reverse!
			previous = shortest_distances = nil
		end

		way = Room.current.wayto[path[path.index(Room.current.id)+1].to_s]

		if way.class == String
			move way
		elsif way.class == Proc
			way.call
		end
	}

	waitrt?
	fput 'stance defensive' unless checkstance('guarded')

	destination = Room[$nesbounty[:rest_room]].find_nearest_by_tag(target)
	while Room.current.id != destination and is_bounty.call 'task_escort'
		if GameObj.npcs.find { |n| n.name =~ /child/i }
			step2.call(destination)
		end
		sleep 0.25
	end

	if is_bounty.call 'fail_child'
		msg("Failed to escort child or child was killed.", "warn")
	elsif npc = get_guard_npc.call
		msg("Waiting for child to arrive.")
		wait_until { GameObj.npcs.find { |n| n.name =~ /child/ } }

	if npc.class == String
	  fput "ask #{npc} for bounty"
	else
	  fput "ask ##{npc.id} for bounty"
	end
	elsif target == 'advguard'
		task_escort.call 'advguard2'
	else
		msg("Failed to find guard for escort!","error")
	end
}

task_search = proc {
	if bounty? !~ /#{bounty_patterns['task_search']}/
		msg("You are not on a search bounty!","error")
	end

	msg("Searching for heirloom.")

	name, location = get_bounty_location.call
	song_of_peace  = false
	invalid_rooms  = []
	last_room      = nil

	hunt_prepare.call
	rest_exit.call

	go2.call location[:room]

	start_hunting_scripts.call

	while is_bounty.call 'task_search' and not $nesbounty[:should_rest_wounded].call and percentmind >= $nesbounty[:min_mind]
		if Spell[1011].known? and Spell[1011].affordable? and not song_of_peace
			Spell[1011].cast
			song_of_peace = true
	elsif Spell[506].known? and Spell[506].affordable? and not Spell[506].active?
	  Spell[506].cast
		end

		wander.call location[:boundaries]

		stand.call()
		change_stance.call('defensive')

		if (GameObj.npcs.empty? or GameObj.npcs.nil?) and Room.current.location =~ /#{location[:location].downcase.strip}/i and not invalid_rooms.include?(Room.current.id) and Room.current.id != last_room
			run_commands.call($nesbounty[:pre_search_commands])

			kneel.call()

			res = dothistimeout 'search', 1, /You intently search the area|You put your head to the/
			if res =~ /You intently search the area|You put your head to the/
				last_room = Room.current.id
			else
				msg("Invalid room, skipping in the future.","warn")
				invalid_rooms.push Room.current.id
			end

			waitrt?

			run_commands.call $nesbounty[:post_search_commands]

			while not checkstance 'offensive' and (song_of_peace or GameObj.npcs.find_all { |npc| npc.type =~ /aggressive/ && npc.status !~ /dead|gone/ }.nil?)
				fput 'stance offensive'
		sleep 0.10
			end

			stand.call()
			change_stance.call('defensive')

			if is_bounty.call 'task_found'
				run_loot_script.call
				break
			end
		end
	end

	waitrt?

	if song_of_peace
		fput "stop 1011"
	end

	kill_hunting_scripts.call
}

task_bandit = proc {
	# You have been tasked to suppress bandit activity on the Icemule Trail between Wehnimer's Landing
	# and Icemule Trace.  You need to kill 4 more of them to complete your task.

	if $nesbounty[:enable_bandit_script] and not Script.exists?($nesbounty[:bandit_script])
		msg("Bandit script is enabled and could not be found.","error")
	end

	if bounty? !~ /#{bounty_patterns['task_bandit']}/
		msg("You are not on a bandits bounty!","error")
	end

	location = $1.strip.downcase

	get_rooms = proc {
		# get the list of rooms that match
		rooms = Room.list.find_all { |r| r.location =~ /#{location}/i }.collect { |r| r.id }
		previous, shortest_distances = Map.dijkstra($nesbounty[:rest_room])
		# delete rooms with no distance or some rooms in Ta'Illistim that are unavailable
		rooms.delete_if { |room_num| shortest_distances[room_num].nil? or [38, 39, 40].include?(room_num) }

		# get 10 rooms only
		rooms = rooms.sort { |a,b| shortest_distances[a] <=> shortest_distances[b] }[0..10]

		# resort rooms by distance
		previous, shortest_distances = Map.dijkstra(Room.current)
		rooms.delete_if { |room_num| room_num == Room.current.id }
		rooms.sort! { |a,b| shortest_distances[a] <=> shortest_distances[b] }
	}

	msg("Culling bandits.")

	my_ambush = false
	ambush_room_count = XMLData.room_count
	start_hunting_scripts.call

	while not $nesbounty[:should_rest_wounded].call and is_bounty.call('task_bandit')
		get_rooms.call.each { |room|
			waitrt?
			waitcastrt?

			msg("Moving to room #{room.to_s}.")

			change_stance.call('defensive')

			go2.call(room)

			msg("Waiting for attack.")

			start = Time.now.to_i
			while true
				if Time.now.to_i - start > 2
					break
				end

				if GameObj.npcs.find { |npc| npc.type =~ /bandit/ }
					break
				end

				sleep 0.25
			end

			while not $nesbounty[:should_rest_wounded].call()
				npcs = GameObj.npcs.to_a.find_all { |npc| npc.type =~ /bandit/ and npc.status !~ /dead/ }
				dead = GameObj.npcs.to_a.find_all { |npc| npc.type =~ /bandit/ and npc.status =~ /dead/ }

				if npcs.empty?
					break
				elsif $nesbounty[:enable_bandit_script]
					waitrt?
					waitcastrt?

					if not dead.empty?
						run_loot_script.call()
					else
						start_script($nesbounty[:bandit_script], npcs.collect { |n| n.id }, h={:quiet=>true})
						wait_while { running?($nesbounty[:bandit_script]) }
					end
				else
					msg("Kill them all!")
					script.pause
				end

				sleep 0.25
			end

			break if $nesbounty[:should_rest_wounded].call or not is_bounty.call('task_bandit')
		}

		sleep 0.1
	end

	kill_hunting_scripts.call
}

task_forage = proc {
	if bounty? !~ /#{bounty_patterns['task_forage']}/
		msg("You are not on a forage bounty!","error")
	end

	herb     = $1
	location = $2
	count    = $3.to_i

	msg("Foraging for #{count} #{herb} at #{location}.")

	herb = herb.downcase

	refresh_spells = proc {
		[506, 603, 9704, 'Sigil of Resolve'].each { |spell|
			if Spell[spell].known? and not Spell[spell].active? and Spell[spell].affordable?
				waitrt?
				waitcastrt?

				Spell[spell].cast
				sleep 0.50
			end
		}

		yierka          = Spell['AA: Yierka']
		yierka_cooldown = Spell['AA: Yierka Cooldown']

		if yierka.known? and yierka.affordable? and not yierka_cooldown.active?
			yierka.cast
		end
	}

	get_herb_count = proc {
		lootsack.contents.find_all { |item| item.name =~ /#{herb.gsub(/s?$/,'')}/i }.size
	}

	last_forage_attempt = Time.now.to_i

	if get_herb_count.call < count
		hunt_prepare.call
		rest_exit.call

		rooms = get_herb_rooms.call(location, herb)
		bright_rooms = []

		cur_room  = 0
		num_tries = 0

		song_of_peace = false

		start_hunting_scripts.call

		while get_herb_count.call < count and not $nesbounty[:should_rest_wounded].call and num_tries < 3 and percentmind >= $nesbounty[:min_mind]
			sanct_cast = false
			light_cast = false

			go2.call(rooms[cur_room])
			cur_room = cur_room + 1

			if cur_room >= rooms.length
				cur_room  = 0
				num_tries = num_tries + 1
			end

			while get_herb_count.call < count and rooms.length > 0 and not $nesbounty[:should_rest_wounded].call
				if not kneeling? and GameObj.pcs.any?
					break
				end

				if Spell[1011].known? and Spell[1011].affordable? and not song_of_peace
					Spell[1011].cast
					song_of_peace = true
				end

				waitrt?
				change_stance.call('defensive')

				refresh_spells.call

				if not song_of_peace and not GameObj.npcs.find_all { |npc| npc.type =~ /aggressive/ && npc.status !~ /dead|gone/ }.nil?
					break
				end

				if not kneeling?
					run_commands.call($nesbounty[:pre_forage_commands])
					kneel.call()
				end

				if Spell[213].known? and Spell[213].affordable? and not sanct_cast
					sanct_cast = true
					fput "incant 213"
					waitcastrt?
				end

				if Spell[205].known? and Spell[205].affordable? and not bright_rooms.include?(cur_room) and not light_cast
					light_cast = true
					fput "incant 205"
					bright_rooms.push(cur_room)
					waitcastrt?
				end

				if Skills.stalkingandhiding >= 50
					fput 'hide' until hidden?
				end

				herb = herb.gsub(/(?:(?:handful|bunch|sprig) of|fragrant|fetid)\s+/, '')
				herb = herb.gsub(/dark pink\s+/, '')
				herb = herb.gsub('mass of ', '')
				herb = herb.gsub('slime-covered ', '')
				herb = herb.gsub('layer of ', '')

				res = dothistimeout "forage #{herb}", 1, /find no trace of what|not even positive|it could be|it could even be found|and manage to find|Roundtime|In order to forage|foraging here recently/

		  if res =~ /it could be|it could even be found|not even positive|find no trace of what/
					rooms.delete_at(cur_room)
			break
				elsif res =~ /and manage to find/
					while checkleft && (checkleft =~ /#{herb}/ || herb =~ /#{checkleft}/)
						fput "put #{checkleft} in ##{lootsack.id}"
					end
					while checkright && (checkright =~ /#{herb}/ || herb =~ /#{checkright}/)
						fput "put #{checkright} in ##{lootsack.id}"
					end

			msg("Success: found #{get_herb_count.call} of #{count} #{herb}")
		  elsif res =~ /In order to forage/
			fput "stow all"
		  elsif res =~ /foraging here recently/
					msg("herb can not be found here, skipping room...")
					rooms.delete_at(cur_room)
			break
		  else
			  msg("Failure: found #{get_herb_count.call} of #{count} #{herb}")
		  end
			end

			# Sanity check, cleanup any remaining herbs
			while checkleft && (checkleft =~ /#{herb}/ || herb =~ /#{checkleft}/)
				fput "put #{checkleft} in ##{lootsack.id}"
			end
			while checkright && (checkright =~ /#{herb}/ || herb =~ /#{checkright}/)
				fput "put #{checkright} in ##{lootsack.id}"
			end

			if not standing?
				run_commands.call($nesbounty[:post_forage_commands])

				while not checkstance 'offensive' and (song_of_peace or GameObj.npcs.find_all { |npc| npc.type =~ /aggressive/ && npc.status !~ /dead/ }.nil?)
					fput 'stance offensive'
		  sleep 0.10
				end

				stand.call()
				change_stance.call('defensive')
			end
		end
	end

	if song_of_peace
		fput "stop 1011"
	end

	if get_herb_count.call >= count
		talk_to_herbalist.call
		last_forage_attempt = 0
	end

	kill_hunting_scripts.call
}

success_heirloom = proc {
	msg("Turning in heirloom.")

	npc = find_guard.call

	empty_hands

	close = false
	if lootsack.contents.nil?
		open_result = dothistimeout "open ##{lootsack.id}", 5, /^You open|^That is already open\.$/
		if open_result =~ /^You open/
			close = true
		else
			dothistimeout "look in ##{lootsack.id}", 5, /In .*? you see/
		end
	end

	found = false
	bounty? =~ /#{bounty_patterns['success_heirloom']}/
	heirloom = $1
	msg("Looking for #{$1}.")

	lootsack.contents.each { |item|
		if item.name !~ /#{heirloom}/
			next
		end

		res = dothistimeout "look ##{item.id}", 2, /^Engraved .* initials|^You see nothing unusual\.$|^The ring appears|^It takes you a moment|^It is difficult to see/
		if res =~ /^Engraved .* initials/
			fput "get ##{item.id}"
			fput "give ##{item.id} to #{npc}"
			found = true

			break
		end
	}

	fput "close ##{lootsack.id}" if close

	if not found
		msg("Failed to find heirloom for guard!","error")
	end

	fill_hands
}

turn_in = proc {
	rest_exit.call

	if is_bounty.call 'success_guard'
		talk_to_guard.call
	elsif is_bounty.call 'success_heirloom'
		success_heirloom.call
	end

	go2_nearest_tag.call('advguild')

	npc = GameObj.npcs.find { |t| t.name =~ /taskmaster/i }
	res = dothistimeout "ask #{npc} about bounty", 5, /^#{npc}.*?done with that assignment/
	10.times {
		if line = get? and line =~ /You have earned ([0-9]+) bounty points?, ([0-9]+) experience points, and ([0-9]+) silver\./
			msg("Finished task! (#{$1} points, #{$2} exp, #{$3} silver)")
			break
		end

		sleep 0.1
	}

	run_loot_script.call
	can_do_bounty_cache = nil
	$nesbounty_can_do_bounty = nil
}

talk_to_npc = proc {
	if is_bounty.call ['help_creature', 'help_resident', 'help_heirloom', 'success_guard']
		talk_to_guard.call
	# separate bandits so we don't trigger them on accident while walking
	elsif is_bounty.call ['help_bandit'] and $nesbounty[:enable_bandit]
		talk_to_guard.call
	elsif is_bounty.call 'help_furrier'
		talk_to_furrier.call
	elsif is_bounty.call 'help_herbalist'
		talk_to_herbalist.call
	elsif is_bounty.call 'help_gemdealer'
		talk_to_gemdealer.call
	end
}

help = proc {
	respond
	respond 'SpiffyBounty by SpiffyJr (theman@spiffyjr.me)'
	respond 'usage: ;sbounty [hunter=bigshot]'
	respond
}

if script.vars[1] =~ /^setup$/i
	setup.call
	exit
elsif script.vars[1] =~ /^help$/i
	help.call
	exit
elsif script.vars[1] =~ /^forage$/i
	task_forage.call
	exit
elsif script.vars[1] =~ /^stop$/i
  kill_script "nesbounty"
  exit
elsif script.vars[1] =~ /^bandits?$/i
	task_bandit.call
	exit
elsif script.vars[1] =~ /^npc$/i
	talk_to_npc.call
	exit
elsif script.vars[1] =~ /^load$/i
	start_script($nesbounty[:hunter], nil, true)
	wait_while { running? $nesbounty[:hunter] }

	location = nil
	if script.vars[2]
		target = script.vars[2]
		locations = $nesbounty[:locations].dup
		location = locations.find { |name, data| $NESBOUNTY_CLEAN_TARGETS.call(data[:targets]).find { |t| target =~ /#{t}/i } }
	end
	$NESBOUNTY_HUNTER_SETUP.call($nesbounty.to_hash.dup, get_bounty_location.call(location, target))
	exit
elsif script.vars[1] =~ /^check$/i
	$debug = true
  can_do_bounty.call
	exit
elsif script.vars[1] =~ /^debug$/i
  $debug = true
elsif script.vars[1]
	$nesbounty[:hunter] = "nesbounty-#{script.vars[1]}"
end

hunter        = $nesbounty[:hunter]
task_accepted = false
resting       = false

start_script(hunter, nil, true)
wait_while { running? hunter }

if not defined? $NESBOUNTY_HUNTER_SETUP
	msg("Hunter setup was not defined.","error")
elsif not defined? $NESBOUNTY_HUNTER_NAME
	msg("Hunter name was not defined.","error")
elsif not defined? $NESBOUNTY_HUNTER_RELOAD
	msg("Hunter reload was not defined.","error")
end

before_dying {
	kill_script($NESBOUNTY_HUNTER_NAME) if running?($NESBOUNTY_HUNTER_NAME)
	kill_hunting_scripts.call
}

Thread.new {
	wait_until { dead? }
	exit
}

while true
	talk_to_npc.call

	if can_do_bounty.call and not $nesbounty[:should_rest_wounded].call
    if is_bounty.call 'task_search' 
      if percentmind >= $nesbounty[:min_mind]
        task_search.call
      elsif percentmind < $nesbounty[:min_mind]
        msg("Mind is below minimum, hunting to fill mind before beginning bounty")
      end
		elsif is_bounty.call 'task_forage'
      if Time.now.to_i >= last_forage_attempt + last_forage_delay and percentmind >= $nesbounty[:min_mind]
			  task_forage.call
      elsif percentmind < $nesbounty[:min_mind]
        msg("Mind is below minimum, hunting to fill mind before beginning bounty")
      end
		end
	elsif Spell['Next Bounty'].active? and (expedite_left and not is_bounty.call 'none' and not can_do_bounty.call and $nesbounty[:enable_expedite]) and not is_bounty.call ['success']
		expedite_bounty.call
		next
	end

	if is_bounty.call 'task_escort' and GameObj.npcs.find { |npc| npc.name =~ /child/ }
		task_escort.call 'advguard'
	elsif is_bounty.call 'task_fail'
		can_do_bounty_cache = nil
	elsif is_bounty.call 'success_heirloom'
		success_heirloom.call
	end

	exit if dead?

	if can_turn_in.call
		turn_in.call
		resting = false
	else
		if not can_do_bounty.call and not Spell['Next Bounty'].active? and not is_bounty.call ['success']
			remove_bounty.call
			get_bounty.call
		elsif should_hunt.call and not should_rest.call and not has_skins.call
			resting   = false
			provoked  = false
			success   = false
			first_run = false
			bounty    = bounty?

			rest_exit.call
			hunt_prepare.call

			# default hunter location
			if can_do_bounty.call
				# order is important here - bandits and regular culling look similar
				if is_bounty.call ['task_bandit']
					task_bandit.call
				elsif is_bounty.call ['task_cull', 'task_dangerous', 'task_heirloom', 'task_rescue', 'task_skin']
					start_hunter.call(get_bounty_location.call)
				else
					start_hunter.call(get_random_location.call)
				end
			else
				start_hunter.call(get_random_location.call)
			end

			while not should_rest.call and running? $NESBOUNTY_HUNTER_NAME
				if bounty? =~ /#{bounty_patterns['task_provoked']}/ and not provoked
					reload_hunter.call
					provoked = true
				elsif is_bounty.call 'task_escort'
					break
				elsif has_skins.call
					break
				elsif not success and (bounty? != bounty and (is_bounty.call [ 'success', 'success_heirloom' ] or (provoked and is_bounty.call 'success_guard')))
					finish_hunt.call
					start_hunter.call(get_random_location.call)

					success = true
				elsif can_turn_in.call
					break
				elsif not can_do_bounty.call and not Spell['Next Bounty'].active?
					break
				#elsif true and percentmind >= 100 and not is_bounty.call ['success', 'success_heirloom']
					# use long term boost
				end

				sleep 0.10
			end

			finish_hunt.call
		elsif not can_turn_in.call
			rest_goto.call

			if not resting or $nesbounty[:should_rest_wounded].call
				rest_run_scripts.call
				rest_goto.call
			end

			rest_enter.call

			while should_rest.call or not should_hunt.call
				if can_turn_in.call
					break
				elsif $nesbounty[:should_rest_wounded].call
					break
				elsif not can_do_bounty.call and not Spell['Next Bounty'].active?
					break
				end

				fput 'exp'

				if rest_reason.nil?
					rest_reason = hunt_reason
				end
				msg("Resting: #{rest_reason}")

				sleep $nesbounty[:rest_sleep_interval]
			end

			resting = true
			rest_exit.call
		end
	end

	sleep 0.10
end
