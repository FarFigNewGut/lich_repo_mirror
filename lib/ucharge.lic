=begin

		Author: Demandred
		Version: 1.2
		Game: GS
		Tags: Wizard,Charge Item,517

		Charges items. Gives a report of what was charged at the end, and whether it greened.

		UserVars:

		itemstocharge -- A list of the items you want to charge and optionally how many charges you want minimum, in the following format
			Examples:	;vars set itemstocharge=small statue,quartz orb,ruby amulet
								;vars set itemstocharge=small statue 15,ruby amulet,quartz orb 17
								;vars set itemstocharge=quartz orb 27,small statue

					Note: The # of charges is a MINIMUM - this setting is only
								recommend if you know exactly how many charges you
								can safely infuse - it will keep trying for this
								many until the item greens, the charges are reached,
								or it gets a message about You cannot add more.

		unchargeditembag -- Where you keep empty statues, quartz orbs, etc...
			Example:  ;vars set unchargeditembag=satchel
			Special Case: ;vars set unchargeditembag=ground
				Will check the ground for items in your itemstocharge list
				(** Not recommended to use with chargeditembag=drop)

		chargeditembag -- Where you want the charged items put
			Example:  ;vars set chargeditembag=pack
			Special Case: ;vars set chargeditembag=drop
				will drop items on the ground when you finish charging them
				(** Not recommended to use with unchargeditembag=ground)

		greeneditembag -- Where you want to put greened items
			Example:  ;vars set greeneditembag=cloak

		orbgembag -- Where you keep your pre-prepared orb gems(already grot poured - script assumes
		any gem in this bag will be an orb gem)
			Example:  ;vars set orbgembag=pouch

	Changelog:

	1.3 - Grr. Some issues with initial p orb creation. Gotta nail these down - may be some weirdness still.
	1.2 - Some more logic fixes and such - additionally made it take first items instead of last.
	1.1 - Various fixes small and large to array logic and ground stuff and...yeah.
	1.0 - Initial release version.


	Contact Demandred in game or on the GS Discord to report issues.

=end

items_to_charge_temp = Array.new
items_to_charge = Array.new
uc_items = Array.new
orb_gems = Array.new
charged_items = Array.new
orbbag = nil
uitembag = nil
citembag = nil
gitembag = nil
new_porb = true
porb_charged = false
last_orb_gem = false
current_charges = 0
item_greened = false
item_max = false
need_mana = true
last_item = false
fresh_item = true
count_flows = 0
first_porb = true
wanted_charges = nil

if script.vars[1] =~ /help|\?/
	respond ""
	respond ""
	respond "Setting up ucharge to charge items:"
	respond ""
	respond "UserVars:"
	respond ""
	respond "itemstocharge -- A list of the items you want to charge and optionally how many charges you want minimum, in the following format"
	respond ""
	respond "Examples:"	
	respond ";vars set itemstocharge=small statue,quartz orb,ruby amulet"
	respond ";vars set itemstocharge=small statue 15,ruby amulet,quartz orb 17"
	respond ";vars set itemstocharge=quartz orb 27,small statue"
	respond ""
	respond "Note: The # of charges is a MINIMUM - this setting is only"
	respond "recommend if you know exactly how many charges you"
	respond "can safely infuse - it will keep trying for this"
	respond "many until the item greens, the charges are reached,"
	respond "or it gets a message about You cannot add more."
	respond ""
	respond "unchargeditembag -- Where you keep empty statues, quartz orbs, etc..."
	respond ""
	respond "Example:"
	respond ";vars set unchargeditembag=satchel"
	respond "Special Case:"
	respond ";vars set unchargeditembag=ground"
	respond "Will check the ground for items in your itemstocharge list"
	respond "(** Not recommended to use with chargeditembag=drop)"
	respond ""
	respond "chargeditembag -- Where you want the charged items put"
	respond ""
	respond "Example:"
	respond ";vars set chargeditembag=pack"
	respond "Special Case:"
	respond ";vars set chargeditembag=drop"
	respond "will drop items on the ground when you finish charging them"
	respond "(** Not recommended to use with unchargeditembag=ground)"
	respond ""
	respond "greeneditembag -- Where you want to put greened items"
	respond ""
	respond "Example:"
	respond ";vars set greeneditembag=cloak"
	respond ""
	respond "orbgembag -- Where you keep your pre-prepared orb gems(already grot poured - script assumes"
	respond "any gem in this bag will be an orb gem)"
	respond ""
	respond "Example:"
	respond ";vars set orbgembag=pouch"
	exit
end

if !Spell[517].known?
	respond "You uh, don't seem to know the necessary spell."
	respond "You should learn 517 and then try this."
	respond "Exiting ;ucharge"
	exit
end

#if Room.current.tags !~ /workshop/
#	respond "You should go to a workshop for this script."
#	respond "Exiting ;ucharge"
#	exit
#end

# Create our array list of the types of items to charge
items_to_charge_temp = UserVars.itemstocharge.split(",")
if !items_to_charge_temp
	echo "You need to set what types of items to charge"
	echo "Example:  ;vars set itemstocharge=small statue,quartz orb"
	echo "NOTE: no spaces after the commas"
	exit
else
	items_to_charge_temp.each do |entry|
		if entry =~ /([ a-zA-Z]+ [a-zA-Z]+) ?(\d+)?/
			items_to_charge.push([$1, $2])
		end
	end
end
#echo items_to_charge # test echo

# Set up and ready the bags to access
orbbag = GameObj.inv.find { |b| UserVars.orbgembag =~ /#{b.noun}|#{b.name}/ }
if !orbbag
	echo "You need to set an orb gem bag."
	echo "Example:  ;vars set orbgembag=pouch"
	exit
end
if UserVars.unchargeditembag =~ /ground/
	uitembag = "ground"
else
	uitembag = GameObj.inv.find { |b| UserVars.unchargeditembag =~ /#{b.name}|#{b.noun}/ }
end
if !uitembag
	echo "You need to set an uncharged item bag"
	echo "Example:  ;vars set unchargeditembag=pack"
	exit
end
if UserVars.chargeditembag =~ /drop/i
	citembag = "dropitems"
else
	citembag = GameObj.inv.find { |b| UserVars.chargeditembag =~ /#{b.name}|#{b.noun}/ }
end
if !citembag
	echo "You need to set a charged item bag"
	echo "Example:  ;vars set chargeditembag=cloak"
	exit
end
gitembag = GameObj.inv.find { |b| UserVars.greeneditembag =~ /#{b.name}|#{b.noun}/ }
if !gitembag
	echo "You need to set a greened item bag"
	echo "Example:  ;vars set greeneditembag=satchel"
	exit
end
#echo orbbag # test echo
#echo uitembag # test echo
#echo citembag # test echo

# Create our actual item array
if uitembag =~ /ground/
	GameObj.loot.each do |i|
		items_to_charge.each do |j|
			if i.name =~ /#{j[0]}/
				uc_items.push(i)
			end
		end
	end
else
	uitembag.contents.each do |i|
		items_to_charge.each do |j|
			if i.name =~ /#{j[0]}/
				uc_items.push(i)
			end
		end
	end
end
#echo uc_items # test echo

# And now our orb array
orb_gems = orbbag.contents.find_all { |g| g.type =~ /gem/ }
if !orb_gems || orb_gems == false || orb_gems.nil? || orb_gems.empty?
	respond "You have no orbs gems"
	respond "Exiting ;ucharge"
	exit
end
# test echo
#echo orb_gems

# Check if there's already a pulsating orb in the room - if so don't make one.
if GameObj.loot.any? { |i| i.name =~ /pulsating orb/ }
	new_porb = false
end

#
## Begin actual action procs
#

# Cast 517 on an orb gem, and delete it from the orbs array
gem_to_porb = proc do
	if first_porb == false
		respond "Your pulsating orb has imploded and you need to make a new one."
		respond "If you would like to continue, please unpause ucharge by typing"
		respond ";u ucharge"
		respond "Otherwise, please kill ucharge by typing ;k ucharge"
		pause_script
	end
	orb_gems = orbbag.contents.find_all { |g| g.type =~ /gem/ }
	if !orb_gems || orb_gems == false || orb_gems.nil? || orb_gems.empty?
		respond "Out of orb gems somehow, most likely moved something."
		respond "Session ending"
		exit
	end
	wait_until { checkcastrt == 0 }
	pause 0.2
	fput "get ##{orb_gems[0].id}"
	wait_until { Spell[517].affordable? }
	fput "prep 517"
	fput "cast at ##{orb_gems[0].id}"
	wait_until {GameObj.loot.any? { |i| i.name =~ /pulsating orb/i }}
	orb_gems.delete(orb_gems[0])
	if orb_gems.count == 0
		last_orb_gem = true
		echo "This is your last orb gem, session will end soon"
	end
	new_porb = false
	if first_porb == true
		first_porb = false
	end
end

# Push the pulsating orb to ready to charge
charge_porb = proc do
	wait_until { Spell[517].affordable? }
	fput "prep 517"
	result = dothistimeout "cast at pulsating orb", 5, /It grows in size\!|The pulsating orb shrinks somewhat\.|It shines brightly for a moment\, flickering in color and humming tones of enchantment\!|The pulsating orb quickly implodes into oblivion\!|The orb is already prepared for charging\./
	if result =~ /grows in size|shrinks somewhat/
		charge_porb.call
	elsif result =~ /quickly implodes into oblivion/
		if last_orb_gem == true
			respond "Your pulsating orb imploded and you have no more orb gems."
			respond "Session is done."
			respond "Exiting ;ucharge"
			exit
		else
			new_porb = true
		end
	elsif result =~ /humming tones of enchantment|already prepared for charging/
		porb_charged = true
	end
end

# Detect item for initial charge count
detect_item = proc do
	wait_until { checkcastrt == 0 }
	pause 0.2
	wait_until { Spell[405].affordable? }
	fput "prep 405"
	result = dothistimeout "cast at ##{uc_items[0].id}", 5, /You sense that .+ with \d+ charges?(?: .+)?\./
	if result =~ /You sense that .+ with (\d+) charges?(?: .+)?\./
		current_charges = $1.to_i
	end
	fresh_item = false
end

# rubbing the pulsating orb proc
rub_porb = proc do
	result = dothistimeout "rub pulsating orb", 5, /The orb isn\'t properly prepared for recharging\.|You successfully add \d+ additional charges to .+\.|It flares a sickening green and then goes dim\.|You are unable to add any more charges|You do not have enough mana|You are unable to properly channel the flows|What were you referring to|Nothing else seems to happen\./
	if result =~ /isn\'t properly prepared/
		porb_charged = false
	elsif result =~ /You successfully add (\d+) additional charges/
		current_charges = current_charges + $1.to_i
		if !wanted_charges || wanted_charges == false || wanted_charges.nil?
			next
		end
		if current_charges >= wanted_charges
			item_max = true
		end
	elsif result =~ /It flares a sickening green/
		item_greened = true
	elsif result =~ /You are unable to add any more|Nothing else seems to happen\./
		item_max = true
	elsif result =~ /You are unable to properly channel the flows/
		if !wanted_charges || wanted_charges == false || wanted_charges.nil?
			count_flows += 1
			if count_flows == 4
				item_max = true
				count_flows = 0
			end
		end
	elsif result =~ /You do not have enough mana/
		need_mana = true
	elsif result =~ /What were you referring to/
		new_porb = true
	end
end

before_dying do
	respond "Items, charges, and whether they greened"
	charged_items.each do |item|
		if item.count == 2
			respond "#{item[0]} - #{item[1]}"
		elsif item.count == 3
			respond "#{item[0]} - #{item[1]} - #{item[2]}"
		end
	end
	respond "End of report"
	respond "Thank you for using ucharge!"
end

#empty our hands
if checkright || checkleft
	fput "store both"
	fput "stow all"
	wait_until { !checkright && !checkleft }
end

#
## Our main logic loop
#
loop do

	if need_mana == true
		wait_until { checkmana > 100 }
		need_mana = false
		next
	end

	if !GameObj.loot.any? { |i| i.name =~ /pulsating orb/ }
		new_porb = true
		next
	end

	if new_porb == true
		gem_to_porb.call
		next
	end

	if uc_items.count == 1
		last_item = true
	end

	if !checkright && !checkleft
		fput "get ##{uc_items[0].id}"
		wait_until { checkright }
		items_to_charge.each do |it|
			if it[0] =~ /#{uc_items[0].name}/
				wanted_charges = it[1].to_i
			end
		end
		fresh_item = true
		next
	end

	if fresh_item == true
		detect_item.call
		next
	end

	if item_greened == true
		fput "put ##{uc_items[0].id} in ##{gitembag.id}"
		wait_until { !checkright }
		charged_items.push([uc_items[0].name, current_charges.to_s, "greened"])
		uc_items.delete(uc_items[0])
		wanted_charges = nil
		if last_item
			echo "Last item of the session"
			echo "You're done."
			exit
		end
		item_greened = false
		current_charges = 0
		fput "get ##{uc_items[0].id}"
		items_to_charge.each do |it|
			if it[0] =~ /#{uc_items[0].name}/
				wanted_charges = it[1].to_i
			end
		end
		fresh_item = true
		next
	end

	if item_max == true
		if citembag == "dropitems"
			fput "drop ##{uc_items[0].id}"
		else
			fput "put ##{uc_items[0].id} in ##{citembag.id}"
		end
		wait_until { !checkright }
		charged_items.push([uc_items[0].name, current_charges.to_s])
		uc_items.delete(uc_items[0])
		wanted_charges = nil
		if last_item == true
			echo "Last item of the session"
			echo "You're done."
			exit
		end
		item_max = false
		current_charges = 0
		fput "get ##{uc_items[0].id}"
		items_to_charge.each do |it|
			if it[0] =~ /#{uc_items[0].name}/
				wanted_charges = it[1].to_i
			end
		end
		fresh_item = true
		next
	end

	if porb_charged == false
		charge_porb.call
		next
	end

	rub_porb.call

end