=begin

	author: Demandred
	game: Gemstone
	tags: rumorwoods,jousting,joust
	version 3.0

	changelog:

	3.0 - Okay. Let's try loop, put line get break unless nil?
	2.9 - change mount summon to put -> line = get
	2.8 - restroom var issues fix
	2.7 - small regex change
	2.6 - Okay - ONLY open them if their contents are empty or nil :rofl:
	2.5 - OPEN the bags no matter what at the start!
	2.4 - look in the bag if contents nil or empty... stupid pouch. stupid full hands. stupid dumb mechanics to work around :rofl:
	2.3 - Maybe a solution for the weird toss you off after you're already dismounted issue?
	2.2 - Ugh, might be a couple iterations to catch issues surrounding different summon lines. Moose should work now maybe?
	2.1 - Fixed some small issues with weirdness around dismount / dismiss / putting away the harness. Still acts funky (there's a probable bug in dismount), but it runs a bit smoother.
	2.0 - fully integrated using your own mount, with designated harness bag and harness name vars, that uses your mount ONLY for the actual jousting, and otherwise dismisses it between jousts (to avoid some weirdness that happens if you stay mounted and try running go2 or try to run go2 while dismounted in between - more delays = less efficiency - but I wanted to allow for yierkas on the field!)

	--Done with 1.x series - full mount integration on the jousting field with 2.0+

	1.8 - few minor things, early glance check, own mount thing to pause at exit so you can dismount if you prefer or kill the script inside the grounds.
	1.7 - cleaned a few things up further. Removed some commented stuff.
	1.6 - right_hand only
	1.5 - to_s
	1.4 - if !.nil to unless
	1.3 - Some transport/location/etc fixes - new var for using your own mount!! See below or the help! Added pouch emptying if you're using the own mount option! Changed inv quantity check to 490 - maybe suggest keeping your bags open and watching your inventory, though I've been told the joust people won't let you joust if your bags are full? Don't know.
	1.2 - small edits to a few lines for info and data stuff.
	1.1 - added an inventory quantity check at start, and a counter, will stop when you go over 490 items. Cleaned up some of the item setup code (containers and such).

	Thanks for the contribution from the past authors on this!
		Tovklar, Ryjex, Arianiss possibly?, others? Documentation wasn't perfect!

	Recommended to run on Lich 5.6.1 (might work on 5.6.0 but you'll need to edit the required lich line in the script)

	New Stuff:

	Demandred's edits:

	You don't have to put anything in any particular order in the vars. Here's how to do it!
		;joust22 dra(gon)/uni(corn) alt(ernate) #
	
		There's three vars possible. 
			1 - Pick dra(gon) or uni(corn) (yep, you can type in 3 or more characters and it'll work!)
			2 - put in alt(ernate) if you want it to run both (whichever faction you pick, it will keep that one 1-2 runs higher at all times, bouncing between them!)
			3 - put in a # if you only want to run that many times, then stop.

	added some vars and arrays for handling the markers a bit more methodically
	added some exp stops that are skippable by setting a var
	
	set your marker bag:
	;e echo UserVars.markersack = "<noun>"

	Avoid resting when 100% mind
	;e echo UserVars.joustrest = false
	
	where to go to rest if you have it set to rest
	;e echo UserVars.joustrestroom = #####

	where to put the loots from the prizes
	;e echo UserVars.joustprizebag = "<container>"

	If you need to stop NOW!!!
	;e echo UserVars.interrupt = true
	;vars set interrupt=yes
	;vars set interrupt=true
			Those will all work :)

			If you want a simple toggle, just create this alias:

			";alias add interrupt=;e echo UserVars.interrupt = UserVars.interrupt ? false : true"
	 
			type 'interrupt' and if it's true it becomes false! And vice versa of course!

	Additionally, this script creates a hash (UserVars.joust22_runs) to track your individual runs for unicorn or dragon. Then tells you how many you've done. IF you know how many you've already done, you can populate the hash, just do these commands:
		;e echo UserVars.joust22_runs = Hash.new
		
		;e echo UserVars.joust22_runs[:dragon] = #
			(where # is how many runs you've done for dragon)

		;e echo UserVars.joust22_runs[:unicorn] = #
			(where # is how many runs you've done for unicorn)

		The numbers are supposed to be runs, not wins, so if you haven't tracked it it might be tough to know. This is to help with determining title acquisition!

		If you have your own mount and want to ride it in the joust, please set the following vars:

		;e echo UserVars.joust22_my_own_mount = true
		;e echo UserVars.joust22_harnessbag = "container you keep the harness in"
		;e echo UserVars.joust22_harnessname = "harness name"

		(For the harnessbag and harnessname you will need to match the names so GameObj sees them)

	Old stuff:

	Origin: somehow I got this, not sure how --  thanks to all the previous folks - especially that joust logic, crazy good work and research! Now it does more! - Demandred

	This script attempts to improve returns on the joust by recognizing knight behavior patterns. Four patterns are known as of this version, there appears to be one to two more or the 5th is random.

	It starts by assuming a specific path to perfect joust and then adjusts based on results. There is plenty of randomness to the jousting so keep that in mind.

	The behaviors could change, no guarantees there.

=end

UserVars.j22debug = false if UserVars.j22debug.nil?

joust22_requires_lich = "5.6.1"
if Gem::Version.new(LICH_VERSION) < Gem::Version.new(joust22_requires_lich)
	echo "You need to update to at least Lich 5.6.1 to use this safely. It MIGHT work on 5.6.0 - you can, if you're comfy doing so, edit the script to make that the requirement, but I recommend 5.6.1."
	echo "Exiting now."
	exit
end

if UserVars.joust22_runs.nil?
	UserVars.joust22_runs = Hash.new
	UserVars.joust22_runs[:dragon] = 0
	UserVars.joust22_runs[:unicorn] = 0
end

UserVars.joust22_my_own_mount = false if UserVars.joust22_my_own_mount.nil?
$joust22_my_own_mount = false
$joust22_harnessname = nil
$joust22_harnessbag = nil
$joust22_temp_mount = nil
$joust22_mounted = false
if UserVars.joust22_my_own_mount == true
	$joust22_my_own_mount = true
	if UserVars.joust22_harnessbag.nil? || UserVars.joust22_harnessname.nil?
		Lich::Messaging.msg("info","#{Script.self.to_s}: You need to set a harnessbag since you are using your own mount. ';e echo UserVars.joust22_harnessbag = \"bag name\"'") if UserVars.joust22_harnessbag.nil?
		Lich::Messaging.msg("info","#{Script.self.to_s}: You need to set a harnessname since you are using your own mount. ';e echo UserVars.joust22_harnessname = \"harness name\"'") if UserVars.joust22_harnessname.nil?
		exit
	end
	$joust22_harnessbag = nil
	$joust22_harnessname = nil
	$joust22_harnessbag = GameObj["#{UserVars.joust22_harnessbag}"]
	$joust22_harnessbag = GameObj.inv.find { |b| b.name =~ /#{UserVars.joust22_harnessbag}/ } if $joust22_harnessbag.nil?
	if $joust22_harnessbag.nil?
		Lich::Messaging.msg("info","#{Script.self.to_s}: Couldn't find your harness bag, make sure you use a name that I can find. Exiting now.")
		exit
	end
	if $joust22_harnessbag.contents.empty? || $joust22_harnessbag.contents.nil?
		dothistimeout "open ##{$joust22_harnessbag.id}", 5, /You open|That is already open/
		dothistimeout "look in ##{$joust22_harnessbag.id}", 5, /In the|There is nothing/
	end
	$joust22_harnessname = $joust22_harnessbag.contents.find { |i| i.name =~ /#{UserVars.joust22_harnessname}/ }
	if $joust22_harnessname.nil?
		$joust22_harnessname = GameObj.right_hand if GameObj.right_hand.name =~ /#{UserVars.joust22_harnessname}/
		$joust22_harnessname = GameObj.left_hand if GameObj.left_hand.name =~ /#{UserVars.joust22_harnessname}/
	end
	if $joust22_harnessname.nil?
		Lich::Messaging.msg("info","#{Script.self.to_s}: Couldn't find your mount harness with the info in the var. See help to make sure you defined it right. Exiting.")
		exit
	end
end

res = nil
res = dothistimeout "glance", 3, /You glance down at your empty hands\.|You glance down to see/
unless res =~ /You glance down at your empty hands\./
	if $joust22_harnessname.nil?
		Lich::Messaging.msg("bold","#{Script.self.to_s}: Empty your hands, please.")
		exit
	else
		if res =~ /#{$joust22_harnessname}/ && (GameObj.right_hand == $joust22_harnessname || GameObj.left_hand == $joust22_harnessname)
			Lich::Messaging.msg("info","Putting this away while we prepare!")
			fput "put ##{$joust22_harnessname.id} in ##{$joust22_harnessbag.id}"
		end
	end
end

$joust22_loop = nil
$joust22_alternate = false
$joust22_running_team = nil
$joust22_stopreason = nil
$joust22_keep_on_top = nil

for var in script.vars[1..-1]
	if var =~ /^dra(?:g|go|gon)?$/i
		Lich::Messaging.msg("info", "#{Script.self.to_s} debug: vars chose dragon") if UserVars.j22debug == true
		if !$joust22_running_team.nil? && $joust22_running_team == "unicorn"
			Lich::Messaging.msg("bold","#{Script.self.to_s}: You seem to have tried to choose both unicorn and dragon, this will simply not do at all. Tsk tsk.")
			exit
		end
		$joust22_running_team = "dragon"
		$joust22_keep_on_top = "dragon"
	elsif var =~ /^uni(?:c|co|cor|corn)?$/i
		Lich::Messaging.msg("info", "#{Script.self.to_s} debug: vars chose unicorn") if UserVars.j22debug == true
		if !$joust22_running_team.nil? && $joust22_running_team == "dragon"
			Lich::Messaging.msg("bold","#{Script.self.to_s}: You seem to have tried to choose both unicorn and dragon, this will simply not do at all. Tsk tsk.")
			exit
		end
		$joust22_running_team = "unicorn"
		$joust22_keep_on_top = "unicorn"
	elsif var =~ /^alt(?:e|er|ern|erna|ernat|ernate)?$/i
		Lich::Messaging.msg("info", "#{Script.self.to_s} debug: vars chose to alternate") if UserVars.j22debug == true
		$joust22_alternate = true
	elsif var =~ /^[0-9]+$/
		$joust22_loop = var.to_i
		$joust22_loop = nil if $joust22_loop == 0
		unless $joust22_loop.nil?
			Lich::Messaging.msg("info", "#{Script.self.to_s} debug: vars chose to loop #{$joust22_loop} times") if UserVars.j22debug == true
		else
			Lich::Messaging.msg("info", "#{Script.self.to_s} debug: vars picked 0 for loop times?") if UserVars.j22debug == true
		end
	elsif var =~ /help|\?/
		Lich::Messaging.msg("info","You don't have to put anything in any particular order in the vars. Here's how to do it!")
		Lich::Messaging.msg("info",";joust22 dra(gon)/uni(corn) alt(ernate) #")
		Lich::Messaging.msg("info","")
		Lich::Messaging.msg("info","There's three vars possible. ")
		Lich::Messaging.msg("info","1 - Pick dra(gon) or uni(corn) (yep, you can type in 3 or more characters and it'll work!)")
		Lich::Messaging.msg("info","2 - put in alt(ernate) if you want it to run both (whichever faction you pick, it will keep that one 1-2 runs higher at all times, bouncing between them!)")
		Lich::Messaging.msg("info","3 - put in a # if you only want to run that many times, then stop.")
		Lich::Messaging.msg("info","")
		Lich::Messaging.msg("info","added some vars and arrays for handling the markers a bit more methodically")
		Lich::Messaging.msg("info","added some exp stops that are skippable by setting a var")
		Lich::Messaging.msg("info","")
		Lich::Messaging.msg("info","set your marker bag:")
		Lich::Messaging.msg("info",";e echo UserVars.markersack = \"<noun or matching name>\"")
		Lich::Messaging.msg("info","")
		Lich::Messaging.msg("info","Avoid resting when 100% mind")
		Lich::Messaging.msg("info",";e echo UserVars.joustrest = false")
		Lich::Messaging.msg("info","")
		Lich::Messaging.msg("info","where to go to rest if you have it set to rest")
		Lich::Messaging.msg("info",";e echo UserVars.joustrestroom = #####")
		Lich::Messaging.msg("info","")
		Lich::Messaging.msg("info","where to put the loots from the prizes")
		Lich::Messaging.msg("info",";e echo UserVars.joustprizebag = \"<noun or matching name>\"")
		Lich::Messaging.msg("info","")
		Lich::Messaging.msg("info","If you need to stop NOW!!!")
		Lich::Messaging.msg("info",";e echo UserVars.interrupt = true")
		Lich::Messaging.msg("info",";vars set interrupt=yes")
		Lich::Messaging.msg("info",";vars set interrupt=true")
		Lich::Messaging.msg("info","Those will all work :)")
		Lich::Messaging.msg("info","")
		Lich::Messaging.msg("info","If you want a simple toggle, just create this alias:")
		Lich::Messaging.msg("info","")
		Lich::Messaging.msg("info","\";alias add interrupt=;e echo UserVars.interrupt = UserVars.interrupt ? false : true\"")
		Lich::Messaging.msg("info","")
		Lich::Messaging.msg("info","type \"interrupt\" and if it's true it becomes false! And vice versa of course!")
		Lich::Messaging.msg("info","")
		Lich::Messaging.msg("info","Additionally, this script creates a hash (UserVars.joust22_runs) to track your individual runs for unicorn or dragon. Then tells you how many you've done. IF you know how many you've already done, you can populate the hash, just do these commands:")
		Lich::Messaging.msg("info","")
		Lich::Messaging.msg("info",";e echo UserVars.joust22_runs = Hash.new")
		Lich::Messaging.msg("info","")
		Lich::Messaging.msg("info",";e echo UserVars.joust22_runs[:dragon] = #")
		Lich::Messaging.msg("info","(where # is how many runs you've done for dragon)")
		Lich::Messaging.msg("info","")
		Lich::Messaging.msg("info",";e echo UserVars.joust22_runs[:unicorn] = #")
		Lich::Messaging.msg("info","(where # is how many runs you've done for unicorn)")
		Lich::Messaging.msg("info","")
		Lich::Messaging.msg("info","The numbers are supposed to be runs, not wins, so if you haven't tracked it it might be tough to know. This is to help with determining title acquisition!")
		Lich::Messaging.msg("info","")
		Lich::Messaging.msg("info","If you have your own mount and want to ride it in the joust, please set the following vars:")
		Lich::Messaging.msg("info","")
		Lich::Messaging.msg("info",";e echo UserVars.joust22_my_own_mount = true")
		Lich::Messaging.msg("info",";e echo UserVars.joust22_harnessbag = \"container you keep the harness in\"")
		Lich::Messaging.msg("info",";e echo UserVars.joust22_harnessname = \"harness name\"")
		Lich::Messaging.msg("info","")
		Lich::Messaging.msg("info","(For the harnessbag and harnessname you will need to match the names so GameObj sees them)")
		Lich::Messaging.msg("info","")
		exit
	end
end

if $joust22_keep_on_top == "dragon"
	$joust22_joustroom = 28062
	if $joust22_alternate == true
		if UserVars.joust22_runs[:dragon] <= (UserVars.joust22_runs[:unicorn] + 1)
			$joust22_joustroom = 28062
			$joust22_running_team = "dragon"
			Lich::Messaging.msg("info", "#{Script.self.to_s} debug: alternating with dragon on top running dragon first") if UserVars.j22debug == true
		elsif UserVars.joust22_runs[:dragon] > (UserVars.joust22_runs[:unicorn] + 1)
			$joust22_joustroom = 28041
			$joust22_running_team = "unicorn"
			Lich::Messaging.msg("info", "#{Script.self.to_s} debug: alternating with dragon on top running unicorn first") if UserVars.j22debug == true
		end
	end
elsif $joust22_keep_on_top == "unicorn"
	$joust22_joustroom = 28041
	if $joust22_alternate == true
		if UserVars.joust22_runs[:unicorn] <= (UserVars.joust22_runs[:dragon] + 1)
			$joust22_joustroom = 28041
			$joust22_running_team = "unicorn"
			Lich::Messaging.msg("info", "#{Script.self.to_s} debug: alternating with unicorn on top running unicorn first") if UserVars.j22debug == true
		elsif UserVars.joust22_runs[:unicorn] > (UserVars.joust22_runs[:dragon] + 1)
			$joust22_joustroom = 28062
			$joust22_running_team = "dragon"
			Lich::Messaging.msg("info", "#{Script.self.to_s} debug: alternating with unicorn on top running dragon first") if UserVars.j22debug == true
		end
	end
else
	Lich::Messaging.msg("bold","#{Script.self.to_s}: You forgot to choose a faction, Silly! Remember to pick one of either dra(gon) or uni(corn)!")
	exit
end

if UserVars.j22debug == true || XMLData.name =~ /^Demandred$/
	startupinfo = "joust22:"
	startupinfo += " alternate |" if $joust22_alternate == true
	startupinfo += " chosen team #{$joust22_keep_on_top} |"
	startupinfo += " #{$joust22_running_team} running first |" if $joust22_alternate == true
	startupinfo += " requested #{$joust22_loop} runs |" unless $joust22_loop.nil?
	startupinfo += " using own mount |" if $joust22_my_own_mount == true
	Lich::Messaging.msg("info",startupinfo)
end

# inventory check to be sure we're not overloaded before we even begin
$joust22_inv_count = 0
resinvct = nil
resinvct = dothistimeout "inventory quantity", 5, /You are carrying \d+ items?\./
if resinvct =~ /You are carrying (\d+) items?\./
	$joust22_inv_count = $1.to_i
end
Lich::Messaging.msg("info","#{Script.self.to_s} debug: starting inv count is #{$joust22_inv_count}") if UserVars.j22debug == true
if $joust22_inv_count > 490
	Lich::Messaging.msg("info","#{Script.self.to_s} debug: started > 490 items") if UserVars.j22debug == true
	Lich::Messaging.msg("bold","You are carrying more than 490 items on you. You should empty some inventory space before you begin.")
	Lich::Messaging.msg("bold","Exiting.")
	exit
end

Lich::Messaging.msg("info", "#{Script.self.to_s} debug: $joust22_joustroom is #{$joust22_joustroom}") if UserVars.j22debug == true
Lich::Messaging.msg("info", "#{Script.self.to_s} debug: $joust22_running_team is #{$joust22_running_team}") if UserVars.j22debug == true
Lich::Messaging.msg("info", "#{Script.self.to_s} debug: $joust22_keep_on_top is #{$joust22_keep_on_top}") if UserVars.j22debug == true
Lich::Messaging.msg("info", "#{Script.self.to_s} debug: $joust22_alternate is #{$joust22_alternate.to_s}") if UserVars.j22debug == true
Lich::Messaging.msg("info", "#{Script.self.to_s} debug: $joust22_loop is #{$joust22_loop ? $joust22_loop : "nil"}") if UserVars.j22debug == true
Lich::Messaging.msg("info", "#{Script.self.to_s} debug: $joust22_my_own_mount is #{$joust22_my_own_mount.to_s}") if UserVars.j22debug == true
Lich::Messaging.msg("info", "#{Script.self.to_s} debug: $joust22_harnessbag is #{$joust22_harnessbag ? $joust22_harnessbag : "nil"}") if UserVars.j22debug == true
Lich::Messaging.msg("info", "#{Script.self.to_s} debug: $joust22_harnessname is #{$joust22_harnessname ? $joust22_harnessname : "nil"}") if UserVars.j22debug == true
Lich::Messaging.msg("info", "#{Script.self.to_s} debug: $joust22_mounted is #{$joust22_mounted.to_s}") if UserVars.j22debug == true
Lich::Messaging.msg("info", "#{Script.self.to_s} debug: $joust22_temp_mount is #{$joust22_temp_mount ? $joust22_temp_mount : "nil"}") if UserVars.j22debug == true

# uncomment this exit to test first set of vars setup.
#exit

$joust22_markerbag = nil
$joust22_markerbag = GameObj[UserVars.markersack]
if $joust22_markerbag.nil?
	$joust22_markerbag = GameObj.inv.find { |c| c.name =~ /#{UserVars.markersack}/ }
end
unless $joust22_markerbag
	Lich::Messaging.msg("bold","UserVars.markersack isn't being found. Did you set one?")
	Lich::Messaging.msg("bold","If you have one set, check the name, something isn't matching.")
	Lich::Messaging.msg("bold","Exiting.")
	exit
end
if $joust22_markerbag.contents.empty? || $joust22_markerbag.contents.nil?
	dothistimeout "open ##{$joust22_markerbag.id}", 5, /You open|That is already open/
	dothistimeout "look in ##{$joust22_markerbag.id}", 5, /In the|There is nothing/
end
# set up the prize bag
$joust22_prizebag = GameObj[UserVars.joustprizebag]
if $joust22_prizebag.nil?
	$joust22_prizebag = GameObj.inv.find { |c| c.name =~ /#{UserVars.joustprizebag}/ }
end
unless $joust22_prizebag
	Lich::Messaging.msg("bold","UserVars.joustprizebag isn't being found. Did you set one?")
	Lich::Messaging.msg("bold","If you have one set, check the name, something isn't matching.")
	Lich::Messaging.msg("bold","Exiting.")
	exit
end
if $joust22_prizebag.contents.empty? || $joust22_prizebag.contents.nil?
	dothistimeout "open ##{$joust22_prizebag.id}", 5, /You open|That is already open/
	dothistimeout "look in ##{$joust22_markerbag.id}", 5, /In the|There is nothing/
end

$joust22_markerarray = []
$joust22_no_more_markers = false
$joust22_cur_marker = nil
$joust22_total_runs = 0

$joust22_markerbag.contents.each do |i|
	if i.name =~ /sunburst marker/
		res = dothistimeout "look ##{i.id}", 5, /It currently has \d+ (?:entry|entries) left(?:\.| and has been recorded)?/
		if res =~ /It currently has (\d+) (?:entry|entries) left/
			$joust22_cur_marker = $1.to_i
			$joust22_total_runs += $joust22_cur_marker
		end
		$joust22_markerarray.push([i, $joust22_cur_marker])
	end
end

if $joust22_markerarray.empty?
	Lich::Messaging.msg("bold","No markers in markersack.")
	Lich::Messaging.msg("bold","Exiting.")
	$joust22_no_more_markers = true
	exit
end
Lich::Messaging.msg("bold","Total Runs Remaining: #{$joust22_total_runs.to_s}")
$joust22_markerarray = $joust22_markerarray.sort_by { |e| e[1] }

#rock paper scissors mapping
$joust22_rps = {"left" => "right","center" => "left", "right" => "center"}
#modeling 2 behaviors of knights key last player move and last knight move, value next knight move, may be a third model, data incomplete
$joust22_model1 = {"centerleft" => "left", "centerright" => "left", "leftcenter" => "right", "leftright" => "right", "rightleft" => "center", "rightcenter" => "center"}
$joust22_model2 = {"centerleft" => "center", "centerright" => "left", "leftcenter" => "right", "leftright" => "left", "rightleft" => "center", "rightcenter" => "right"}
$joust22_model3 = {"centerleft" => "left", "centerright" => "left", "leftcenter" => "left", "leftright" => "left", "rightleft" => "center", "rightcenter" => "left"}

$joust22_knightMode = $joust22_model1
$joust22_modelFound = false
$joust22_randoming = false
$joust22_score = 0
$joust22_count = 0

def bundle_joust_prizes()
	Lich::Messaging.msg("info","#{Script.self.to_s} debug: in bundling def") if UserVars.j22debug == true
	guildbundle = []
	$joust22_prizebag.contents.each do |pack|
		if pack.name =~ /Elanthian Guilds/
			Lich::Messaging.msg("info","#{Script.self.to_s} debug: elanthian guilds prizebag check") if UserVars.j22debug == true
			guildbundle.push(pack)
		end
	end
	if guildbundle.count > 1
		Lich::Messaging.msg("info","#{Script.self.to_s} debug: elanthian guilds bundle count") if UserVars.j22debug == true
		firstone = true
		guildbundle.each do |pack|
			fput "get ##{pack.id}"
			if firstone
				firstone = false
				next
			end
			#wait_until { GameObj.right_hand.name =~ /pack/ && GameObj.left_hand.name =~ /pack/ }
			dothistimeout "bundle", 5, /^You bundle/
		end
		fput "put ##{GameObj.right_hand.id} in ##{$joust22_prizebag.id}" if GameObj.right_hand.name !~ /Empty/
		fput "put ##{GameObj.left_hand.id} in ##{$joust22_prizebag.id}" if GameObj.left_hand.name !~ /Empty/
	end
	Lich::Messaging.msg("info","#{Script.self.to_s} debug: done with elanthian guilds") if UserVars.j22debug == true
	wait_until { GameObj.right_hand.name == "Empty" && GameObj.left_hand.name == "Empty" }
	advbundle = []
	$joust22_prizebag.contents.each do |pack|
		if pack.name =~ /Adventurer's Guild/
			Lich::Messaging.msg("info","#{Script.self.to_s} debug: adv guild prizebag check") if UserVars.j22debug == true
			advbundle.push(pack)
		end
	end
	if advbundle.count > 1
		Lich::Messaging.msg("info","#{Script.self.to_s} debug: adv guild bundle count") if UserVars.j22debug == true
		firstone = true
		advbundle.each do |pack|
			fput "get ##{pack.id}"
			if firstone
				firstone = false
				next
			end
			#wait_until { GameObj.right_hand.name =~ /pack/ && GameObj.left_hand.name =~ /pack/ }
			dothistimeout "bundle", 5, /^You bundle/
		end
		fput "put ##{GameObj.right_hand.id} in ##{$joust22_prizebag.id}" unless GameObj.right_hand.name =~ /Empty/
		fput "put ##{GameObj.left_hand.id} in ##{$joust22_prizebag.id}" unless GameObj.left_hand.name =~ /Empty/
	end
	Lich::Messaging.msg("info","#{Script.self.to_s} debug: done with adv guild") if UserVars.j22debug == true
	wait_until { GameObj.right_hand.name == "Empty" && GameObj.left_hand.name == "Empty" }
	charmbundle = []
	$joust22_prizebag.contents.each do |charm|
		if charm.name =~ /feather-shaped charm/
			Lich::Messaging.msg("info","#{Script.self.to_s} debug: feather charm prizebag/vest check") if UserVars.j22debug == true
			charmbundle.push(charm)
		end
	end
	if charmbundle.count > 1
		Lich::Messaging.msg("info","#{Script.self.to_s} debug: feather charm bundle count") if UserVars.j22debug == true
		firstone = true
		charmbundle.each do |charm|
			fput "get ##{charm.id}"
			if firstone
				firstone = false
				next
			end
			#wait_until { GameObj.right_hand.name =~ /charm/ && GameObj.left_hand.name =~ /charm/ }
			dothistimeout "bundle", 5, /^You combine/
		end
		fput "put ##{GameObj.right_hand.id} in ##{$joust22_prizebag.id}" unless GameObj.right_hand.name =~ /Empty/
		fput "put ##{GameObj.left_hand.id} in ##{$joust22_prizebag.id}" unless GameObj.left_hand.name =~ /Empty/
	end
	Lich::Messaging.msg("info","#{Script.self.to_s} debug: done with feather charms") if UserVars.j22debug == true
	wait_until { GameObj.right_hand.name == "Empty" && GameObj.left_hand.name == "Empty" }
end

def knight_logic (lm, lm2, lm3, lkm, lkm2, lkm3)

	if lkm == lkm2 && lkm2 == lkm3
		#attempt to handle 5 in a row knights
		return $joust22_rps[lkm]
	elsif $joust22_score == 1
		#assume ties will be random and there's not much to do about it"
		return lm
	elsif $joust22_modelFound
		if $joust22_score == 2 &&	!$joust22_randoming
			#keep going with pattern if winning
			return $joust22_rps[$joust22_knightMode[lm+lkm]]
		elsif $joust22_knightMode != $joust22_model3 && $joust22_model3[lm2+lkm2] == lkm && $joust22_model3[lm3+lkm3] == lkm2
			#pattern miss, running another check starting from 3 to to 1 using more data
			$joust22_knightMode = $joust22_model3
			return $joust22_rps[$joust22_knightMode[lm+lkm]]
		elsif $joust22_knightMode != $joust22_model2 && $joust22_model2[lm2+lkm2] == lkm && $joust22_model2[lm3+lkm3] == lkm2
			$joust22_knightMode = $joust22_model2
			return $joust22_rps[$joust22_knightMode[lm+lkm]]
		elsif $joust22_knightMode != $joust22_model1 && $joust22_model1[lm2+lkm2] == lkm && $joust22_model1[lm3+lkm3] == lkm2
			$joust22_knightMode = $joust22_model1
			return $joust22_rps[$joust22_knightMode[lm+lkm]]
		else
			#no pattern found might as well random
			$joust22_randoming = true
			return ["left","center","right"].sample
		end
	else
		#check pattern if possible no need to switch if its working
		if $joust22_model2[lm2+lkm2] == lkm && $joust22_score < 2
			$joust22_knightMode = $joust22_model2
			$joust22_modelFound = true
			return $joust22_rps[$joust22_knightMode[lm+lkm]]
		elsif $joust22_model3[lm2+lkm2] == lkm && $joust22_score < 2
			$joust22_knightMode = $joust22_model3
			$joust22_modelFound = true
			return $joust22_rps[$joust22_knightMode[lm+lkm]]
		elsif $joust22_model1[lm2+lkm2] == lkm && $joust22_score < 2
			$joust22_knightMode = $joust22_model1
			$joust22_modelFound = true
			return $joust22_rps[$joust22_knightMode[lm+lkm]]
		else
			#if nothing else keep with model 1
			return $joust22_rps[$joust22_model1[lm+lkm]]
		end
	end
end

def tournyLoop (faction)

	if $joust22_loop
		looped = 0
		time_s = "time"
		time_s += "s" if $joust22_loop > 1
		Lich::Messaging.msg("bold","Going to run #{$joust22_loop} #{time_s}.")
	end

	Lich::Messaging.msg("info", "#{Script.self.to_s}: joustrest is #{UserVars.joustrest}") if UserVars.j22debug == true
	jrestroom = nil
	jrestroom = UserVars.joustrestroom

	unless XMLData.room_id.to_s =~ /^82(?:08|11)/
		if Room.current.title[0].include?("Table")
			move "out"
			wait_until { !Room.current.title[0].include?("Table") }
		end
		result = dothistimeout "quest transport rumor", 5, /You cannot be transported to Rumor Woods|Are you sure you would like to transport/
		if result =~ /You cannot be transported/
			Script.run('go2', 'town')
			sleep 1
			result = dothistimeout "quest transport rumor", 5, /You cannot be transported to Rumor Woods|Are you sure you would like to transport/
			if result =~ /You cannot be transported/
				Lich::Messaging.msg("bold","Not sure why this failed since you should be in town now, but something funky is going on, we're gonna bail.")
				exit
			end
		end
		fput "quest transport rumor"
		wait_until { Room.current.id == 25902 }
	end

	$joust22_currentruns = nil
	$joust22_currentruns = 0 if

	loop do
		$joust22_currentruns += 1
		Lich::Messaging.msg("info", "#{Script.self.to_s} debug: increment $joust22_currentruns by 1") if UserVars.j22debug == true

		if $joust22_alternate == true
			Lich::Messaging.msg("info", "#{Script.self.to_s} debug: inside loop alternate is true") if UserVars.j22debug == true
			if $joust22_keep_on_top == "dragon"
				Lich::Messaging.msg("info", "#{Script.self.to_s} debug: dragon on top inside loop") if UserVars.j22debug == true
				if UserVars.joust22_runs[:dragon] <= (UserVars.joust22_runs[:unicorn] + 1)
					$joust22_joustroom = 28062
					$joust22_running_team = "dragon"
					Lich::Messaging.msg("info", "#{Script.self.to_s} debug: dragon on top, inside loop, chose dragon") if UserVars.j22debug == true
				elsif UserVars.joust22_runs[:dragon] > (UserVars.joust22_runs[:unicorn] + 1)
					$joust22_joustroom = 28041
					$joust22_running_team = "unicorn"
					Lich::Messaging.msg("info", "#{Script.self.to_s} debug: dragon on top, inside loop, chose unicorn") if UserVars.j22debug == true
				end
			elsif $joust22_keep_on_top == "unicorn"
				Lich::Messaging.msg("info", "#{Script.self.to_s} debug: unicorn on top inside loop") if UserVars.j22debug == true
				if UserVars.joust22_runs[:unicorn] <= (UserVars.joust22_runs[:dragon] + 1)
					$joust22_joustroom = 28041
					$joust22_running_team = "unicorn"
					Lich::Messaging.msg("info", "#{Script.self.to_s} debug: unicorn on top, inside loop, chose unicorn") if UserVars.j22debug == true
				elsif UserVars.joust22_runs[:unicorn] > (UserVars.joust22_runs[:dragon] + 1)
					$joust22_joustroom = 28062
					$joust22_running_team = "dragon"
					Lich::Messaging.msg("info", "#{Script.self.to_s} debug: unicorn on top, inside loop, chose dragon") if UserVars.j22debug == true
				end
			end
			faction = $joust22_joustroom
			Lich::Messaging.msg("info", "#{Script.self.to_s} debug: set faction to joustroom in alternate true") if UserVars.j22debug == true
		end
	
		Script.run("go2", faction.to_s) if Room.current.id != faction

		if $joust22_my_own_mount == true && $joust22_mounted == false
			Script.current.want_downstream_xml = true
			dothistimeout "get ##{$joust22_harnessname.id}", 5, /#{$joust22_harnessname.id}/

			loop do
				put "wave ##{$joust22_harnessname.id}"
				while line = get
					if line =~ /You wave your <a exist=\"\d+\" noun=\"[^"]+\">[^<]+<\/a> through the air[^<]+<pushBold\/>[^<]+?<a exist=\"(\d+)\"/
						$joust22_temp_mount = GameObj[$1]
						break
					elsif line =~ /Your <pushBold\/><a exist="(\d+)" noun="[^"]+">[^<]+<\/a><popBold\/> is right here!/
						$joust22_temp_mount = GameObj[$1]
						break
					end
				end
				break unless $joust22_temp_mount.nil?
				sleep 1
			end
			dothistimeout "mount ##{$joust22_temp_mount.id}", 5, /.+?"#{$joust22_temp_mount.id}".+?"#{$joust22_harnessname.id}".+?\.$/
			$joust22_mounted = true
			Script.current.want_downstream_xml = false
		end

		result = nil
		result = dothistimeout "get ##{$joust22_markerarray[0][0].id}", 5, /sunburst marker/
		if result !~ /sunburst marker/
			if (checkright != "marker" and checkleft != "marker")
				echo "out of markers!"
				exit
			end
		end
		
		nextMove = "left"
		lastMove = "left"
		lastMove2 = "left"
		lastMove3 = "left"
		lastKnightMove = "unknown"
		lastKnightMove2 = "unknown"
		lastKnightMove3 = "unknown"
		$joust22_knightMode = $joust22_model1
		$joust22_modelFound = false
		$joust22_randoming = false
		$joust22_score = 0
		$joust22_count = 0
	
		fput "go entry table"

		dothistimeout "put ##{$joust22_markerarray[0][0].id} in ##{$joust22_markerbag.id}", 5, /sunburst marker/

		res = nil
		res = dothistimeout "glance", 3, /You glance down at your empty hands\.|You glance down to see/
		unless res =~ /You glance down at your empty hands\./
			Lich::Messaging.msg("bold","Empty your hands! Make sure you have a UserVars.joustprizebag set too.")
			Lich::Messaging.msg("info","The team run has not been incremented for this loop.")
			exit
		end

		unless $joust22_mounted == true
			dothis "look in paddock", /In the enclosed paddock/
			GameObj.loot.find { |obj| obj.name =~ /paddock/ }.contents.find { |obj| 	
				fput "get #{obj.noun} from paddock"
			}
		end

		dothis "look on rack", /On the large weapon rack you see/
		GameObj.loot.find { |obj| obj.name =~ /rack/ }.contents.find { |obj| 	
			fput "get #{obj.noun} from rack"
		}
	
		fput "look on display", /On the shield display you see/
		GameObj.loot.find { |obj| obj.name =~ /display/ }.contents.find { |obj| 	
			fput "get #{obj.noun} from display"
		}
	
		put "go entry table"
		while line = get
			if line =~ /You hold out your marker/
				$joust22_markerarray[0][1] -= 1
				$joust22_total_runs -= 1
				next
			elsif line =~ /Since that was the last entry on your marker, you discard it\./
				$joust22_markerarray.delete($joust22_markerarray[0])
				if $joust22_markerarray.count == 0
					$joust22_no_more_markers = true
				end
			next
				elsif line =~ /Tourney/
				break
			end
		end

		# Add the run to the appropriate team!
		text = ""
		if $joust22_running_team == "dragon"
			UserVars.joust22_runs[:dragon] += 1
			text = "+1 Dragon - Run #{$joust22_currentruns}"
		elsif $joust22_running_team == "unicorn"
			UserVars.joust22_runs[:unicorn] += 1
			text = "+1 Unicorn - Run #{$joust22_currentruns}"
		end
		text += " of #{$joust22_loop}" unless $joust22_loop.nil?
		Lich::Messaging.msg("info",text)

		if UserVars.j22debug == true || XMLData.name =~ /^Demandred$/
			Lich::Messaging.msg("info","#{Script.self.to_s}| Alternate: #{$joust22_alternate ? "yes" : "no"}")
			Lich::Messaging.msg("info","#{Script.self.to_s}| Chosen Team: #{$joust22_keep_on_top}")
			Lich::Messaging.msg("info","#{Script.self.to_s}| Current Run: #{$joust22_running_team}")
			Lich::Messaging.msg("info","#{Script.self.to_s}| Total Dragon Runs: #{UserVars.joust22_runs[:dragon]}")
			Lich::Messaging.msg("info","#{Script.self.to_s}| Total Unicorn Runs: #{UserVars.joust22_runs[:unicorn]}")
			if $joust22_loop.nil?
				Lich::Messaging.msg("info","#{Script.self.to_s}| Requested Runs: infinite (see total remaining entries!)")
			else
				Lich::Messaging.msg("info","#{Script.self.to_s}| Requested Runs: #{$joust22_loop}")
			end
			Lich::Messaging.msg("info","#{Script.self.to_s}| Restmode: #{UserVars.joustrest ? "on" : "off"}")
			Lich::Messaging.msg("info","#{Script.self.to_s}| Total Remaining Entries(on hand): #{$joust22_total_runs}")
		end

		fput "shout"

		loop do
			result = waitfor "AIM LEFT, AIM CENTER, or AIM RIGHT","A jousting attendant says",/appears to be aiming.+?to the (right|left|center) of your/
			if result =~ /right|center|left/
				result = result.to_s.match /appears to be aiming.+?to the (right|left|center) of your/
				tempScore = waitfor /A jousting herald announces.+?(0|1|2)/
				tempScore = tempScore.match /A jousting herald announces.+?(0|1|2)/
				$joust22_score = tempScore[1].to_i
				lastMove3 = lastMove2
				lastMove2 = lastMove
				lastMove = nextMove
				lastKnightMove3 = lastKnightMove2
				lastKnightMove2 = lastKnightMove
				lastKnightMove = result[1].to_s
				nextMove = knight_logic(lastMove, lastMove2, lastMove3, lastKnightMove, lastKnightMove2, lastKnightMove3).to_s
			elsif result =~ /AIM LEFT, AIM CENTER, or AIM RIGHT/
				fput "aim " + nextMove
				$joust22_count = $joust22_count + 1
			else
				pouch = GameObj.right_hand
				if $joust22_mounted == true
					fput "put ##{pouch.id} in ##{$joust22_prizebag.id}"
					alreadygone = false
					Script.current.want_downstream_xml = true
					put "dismount"
					$joust22_mounted = false
					dothistimeout "dismiss ##{$joust22_temp_mount.id}", 2, /"#{$joust22_temp_mount.id}"|I could not find what you were referring to\./
					dothistimeout "put ##{$joust22_harnessname.id} in ##{$joust22_harnessbag.id}", 3, /#{$joust22_harnessname.id}/
					#alreadygone = true if reget.reverse[0..25].any? { |line| line =~ /"#{$joust22_temp_mount.id}".+? away\.$/ }
					wait_until { !(GameObj.npcs.any? { |npc| npc.id == $joust22_temp_mount.id }) }
					$joust22_temp_mount = nil
					Script.current.want_downstream_xml = false
					fput "get ##{pouch.id}"
				end
				dothistimeout "open ##{pouch.id}", 5, /You open a nondescript drawstring pouch\./
				pouch.contents.each do |i|
					fput "get ##{i.id}"
					fput "put ##{i.id} in ##{$joust22_prizebag.id}"
					$joust22_inv_count += 1
					Lich::Messaging.msg("info","#{Script.self.to_s} debug: inv count incremented to #{$joust22_inv_count}") if UserVars.j22debug == true
				end
				fput "drop ##{pouch.id}"
				break
			end
		end
		
		if $joust22_inv_count > 490
			Lich::Messaging.msg("info","#{Script.self.to_s} debug: inv count > 490 after pouch drop") if UserVars.j22debug == true
			Lich::Messaging.msg("info","Your inventory is getting pretty full friend. We're gonna stop to let you manage that.")
			sleep 1
		end

		if (UserVars.interrupt == "yes" || UserVars.interrupt == true || UserVars.interrupt == "true") || $joust22_no_more_markers == true || $joust22_inv_count > 490 || (!$joust22_loop.nil? && $joust22_currentruns == $joust22_loop)
			Lich::Messaging.msg("info","#{Script.self.to_s} debug: Stopping on condition") if UserVars.j22debug == true
			$joust22_stopreason = ""
			if $joust22_no_more_markers
				$joust22_stopreason = "No more markers."
				Lich::Messaging.msg("info","#{Script.self.to_s} debug: stopreason no more markers.") if UserVars.j22debug == true
			elsif !$joust22_loop.nil? && $joust22_currentruns == $joust22_loop
				run_s = "run"
				run_s += "s" if $joust22_loop > 1
				$joust22_stopreason = "Only wanted to do #{$joust22_loop} #{run_s}."
				Lich::Messaging.msg("info","#{Script.self.to_s} debug: stopreason finished runs requested") if UserVars.j22debug == true
			elsif UserVars.interrupt == "yes" || UserVars.interrupt == true || UserVars.interrupt == "true"
				$joust22_stopreason = "Var interrupt set to yes|true."
				Lich::Messaging.msg("info","#{Script.self.to_s} debug: stopreason var interrupt") if UserVars.j22debug == true
			elsif $joust22_inv_count > 490
				Lich::Messaging.msg("info","#{Script.self.to_s} debug: stopreason inv count") if UserVars.j22debug == true
				$joust22_stopreason = "Inventory count > 490."
			end
			Lich::Messaging.msg("bold","#{$joust22_stopreason} Exiting.")
			sleep 1
			Script.run('go2', 'exit')
			move "go arch"
			wait_until { Room.current.id != 25902 }
			unless jrestroom.nil?
				Script.run('go2', "#{jrestroom}")
			else
				Script.run('go2', 'node')
			end
			bundle_joust_prizes()
			exit
		end
		unless UserVars.joustrest.nil? || UserVars.joustrest == "false" || UserVars.joustrest == false || UserVars.joustrest == "off"
			put "exp"
			while line = get
				if line =~ /Field Exp: ([,\d]+)\/([,\d]+)/
					cfe = $1.delete(",").to_i
					mfe = $2.delete(",").to_i
					break
				end
			end
			if cfe >= mfe
				Lich::Messaging.msg("info","#{Script.self.to_s} debug: resting due to mind") if UserVars.j22debug == true
				Lich::Messaging.msg("bold","Mind capped - going to rest room until muddled.")
				Script.run('go2', 'exit')
				move "go arch"
				wait_until { Room.current.id != 25902 }
				unless jrestroom.nil?
					Script.run('go2', "#{jrestroom}")
				else
					Script.run('go2', 'node')
				end
				sleep 2
				bundle_joust_prizes()
				Lich::Messaging.msg("bold","Waiting until mind is muddled - ;k joust22 to stop.")
				unless $joust22_loop.nil?
					runstogo = $joust22_loop - $joust22_currentruns
					Lich::Messaging.msg("info", "#{$joust22_currentruns} of #{$joust22_loop} runs requested so far. #{runstogo} more to go!")
				end
				wait_until { XMLData.mind_text =~ /muddled|clear/ }
				if Room.current.title[0].include?("Table")
					move "out"
					wait_until { !Room.current.title[0].include?("Table") }
				end
				result = dothistimeout "quest transport rumor", 5, /You cannot be transported to Rumor Woods|Are you sure you would like to transport/
				if result =~ /You cannot be transported/
					Lich::Messaging.msg("bold","Go somewhere that you can transport from then try to run this again!")
					exit
				end
				fput "quest transport rumor"
				wait_until { Room.current.id == 25902 }
			end
		end
	end 
end

before_dying do
	Lich::Messaging.msg("info","#{Script.self.to_s}| Stopped because: #{$joust22_stopreason}") unless $joust22_stopreason.nil?
	runtext_s = "Ran #{$joust22_currentruns} time"
	runtext_s += "s" if $joust22_currentruns > 1
	runtext_s += " out of #{$joust22_loop} requested." unless $joust22_loop.nil?
	Lich::Messaging.msg("info","#{Script.self.to_s}| #{runtext_s}")
	Lich::Messaging.msg("info","#{Script.self.to_s}| So far in 2022 jousting you've run--")
	Lich::Messaging.msg("info","#{Script.self.to_s}| Dragon: #{UserVars.joust22_runs[:dragon]}")
	Lich::Messaging.msg("info","#{Script.self.to_s}| Unicorn: #{UserVars.joust22_runs[:unicorn]}")
	Lich::Messaging.msg("info","#{Script.self.to_s}| Total: #{UserVars.joust22_runs[:dragon] + UserVars.joust22_runs[:unicorn]}")
	Lich::Messaging.msg("info","#{Script.self.to_s}| Have a nice day!")
end

tournyLoop($joust22_joustroom)