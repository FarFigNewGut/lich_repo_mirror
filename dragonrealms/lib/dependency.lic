=begin
  Documentation: https://elanthipedia.play.net/Lich_script_development#dependency
=end

require 'json'
require 'net/http'
require 'base64'
require 'yaml'
require 'ostruct'
require 'digest/sha1'
require 'monitor'

$DEPENDENCY_VERSION = '1.4.16'
$MIN_RUBY_VERSION = '2.5.5'

no_pause_all
no_kill_all

class Object
  # IMPORT FUTURE LAWLZ
  def itself
    self
  end
end

class ArgParser
  def parse_args(data, flex_args = false)
    raw_args = variable.first
    baselist = variable.drop(1).dup || []

    unless baselist.size == 1 && baselist.grep(/^help$|^\?$|^h$/).any?

      result = data.map { |definition| check_match(definition, baselist.dup, flex_args) }.compact

      return result.first if result.length == 1

      if result.empty?
        echo "***INVALID ARGUMENTS DON'T MATCH ANY PATTERN***"
        respond "Provided Arguments: '#{raw_args}'"
      elsif result.length > 1
        echo '***INVALID ARGUMENTS MATCH MULTIPLE PATTERNS***'
        respond "Provided Arguments: '#{raw_args}'"
      end

    end

    display_args(data)
    exit
  end

  def display_args(data)
    # This section displays help output for a script. It recognizes when a script call has been given
    # with the wrong number or incorrect arguments, or when a script has been called via
    # ;script-name help. It outputs an example script call, including arguments, with optional
    # arguments enclosed in brackets. If an optional script_summary argument has been specified within
    # the script, it also outputs a summary of the script. Further, if yaml settings have been
    # outlined in base-help.yaml, it will output help information for the yaml settings used.
    # Example output when all help settings have been specified:
    #
    # >;circlecheck help
    #   SCRIPT SUMMARY: Checks your circle and skills to next circle. Optionally checks skills for a target circle.
    #
    #   SCRIPT CALL FORMAT AND ARG DESCRIPTIONS (arguments in brackets are optional):
    #    ;circlecheck [debug] [mode] [target] [script_summary]
    #     debug        Runs the script with debug messages.
    #     mode         Only display requirements you don't meet [brief, short, next]
    #     target       See requirements for a specific circle
    #
    #   YAML SETTINGS USED:
    #     circlecheck_prettyprint: Tells circlecheck to use the pretty print formatting for output. [Ex: true/false]
    if Script.current.name != "bootstrap"
      data.each do |def_set|
        def_set
          .select { |x| x[:name].to_s == "script_summary" }
          .each { |x| respond " SCRIPT SUMMARY: #{x[:description]} " }
        respond ''
        respond " SCRIPT CALL FORMAT AND ARG DESCRIPTIONS (arguments in brackets are optional):"
        respond "  ;#{Script.current.name} " + def_set.map { |x| format_item(x) unless x[:name].to_s == "script_summary"}.join(' ')
        def_set
          .reject { |x| x[:name].to_s == "script_summary" }
          .each { |x| respond "   #{(x[:display] || x[:name]).ljust(12)} #{x[:description]} #{x[:options] ? '[' + x[:options].join(', ') + ']' : ''}" }
      end

      # Display help output for settings used in the script. Relies on base-help.yaml.
      yaml_data = get_data('help').to_h
      yaml_settings = yaml_data.select { |field, info| info["referenced_by"].include?(Script.current.name)}

      unless yaml_settings.empty?
        respond ''
        respond " YAML SETTINGS USED:"
        yaml_settings.each do |field, info|
          setting_line += "   #{field}: #{info["description"]} #{info["specific_descriptions"][Script.current.name]}"
          setting_line += " [Ex: #{info["example"]}]" unless info["example"].to_s.nil? || info["example"].to_s.empty?
          respond setting_line
        end
        respond ""
      end
    end
  end

  private

  def matches_def(definition, item)
    echo "#{definition}:#{item}" if UserVars.parse_args_debug
    return true if definition[:regex] && definition[:regex] =~ item
    return true if definition[:options] && definition[:options].find { |option| item =~ /^#{option}#{'$' if definition[:option_exact]}/i }
    false
  end

  def check_match(defs, vars, flex)
    args = OpenStruct.new

    defs.reject { |x| x[:optional] }.each do |definition|
      return nil unless matches_def(definition, vars.first)

      args[definition[:name]] = vars.first.downcase
      vars.shift
    end

    defs.select { |x| x[:optional] }.each do |definition|
      if match = vars.find { |x| matches_def(definition, x) }
        args[definition[:name]] = match.downcase
        vars.delete(match)
      end
    end

    if flex
      args.flex = vars
    else
      return nil unless vars.empty?
    end
    args
  end

  def format_item(definition)
    item = definition[:display] || definition[:name]
    if definition[:optional]
      item = "[#{item}]"
    elsif definition[:variable] || definition[:options]
      item = "<#{item}>"
    end
    item
  end
end

def parse_args(defn, flex_args = false)
  ArgParser.new.parse_args(defn, flex_args)
end

def display_args(defn)
  ArgParser.new.display_args(defn)
end

arg_definitions = [
  [
    { name: 'debug', regex: /debug/i, optional: true },
    { name: 'install', regex: /install/i, optional: true }
  ]
]

args = parse_args(arg_definitions)

debug = args.debug || UserVars.debug_dependency
install = args.install

class OpenStruct
  def new_ostruct_member(name)
    name = name.to_sym
    unless respond_to?(name)
      define_singleton_method(name) { |*_a| @table[name] }
      define_singleton_method("#{name}=") { |x| modifiable[name] = x }
    end
    name
  end
  protected :new_ostruct_member

  def method_missing(mid, *args)
    mname = mid.id2name
    len = args.length
    if mname.chomp!('=')
      if len != 1
        raise ArgumentError, "wrong number of arguments (#{len} for 1)", caller(1)
      end
      if !respond_to?(:modifiable?, true) # for backwards compatability <2.3, to be removed eventually
        modifiable[new_ostruct_member(mname)] = args[0]
      else                                # new >=2.3 method
        modifiable?[new_ostruct_member(mname)] = args[0]
      end
    elsif len.zero?
      @table[mid]
    elsif len == 1
      echo("Failed to find yaml setting #{mid}, using default:#{args[0]}")
      args[0]
    else
      raise NoMethodError, "undefined method `#{mid}' for #{self}", caller(1)
    end
  end
end

class ScriptManager
  attr_reader :autostarts
  attr_accessor :developer, :ignore_dependency

  def initialize(debug)
    @debug = debug
    @paste_bin_token = 'dca351a27a8af501a8d3123e29af7981'
    @paste_bin_url = 'https://pastebin.com/api/api_post.php'
    @firebase_url = 'https://dr-scripts.firebaseio.com/'
    @status_repo = Settings['status_repo'] || 'rpherbig/dr-scripts'
    @status_branch = Settings['status_branch'] ||'master'
    update_status_url
    @lich_url = 'https://api.github.com/repos/dragon-realms/dr-lich/git/trees/master'
    UserVars.autostart_scripts ||= []
    UserVars.autostart_scripts.uniq!
    UserVars.autostart_scripts = UserVars.autostart_scripts - ['dependency']
    Settings['autostart'] ||= []
    Settings['autostart'].uniq!
    Settings['autostart'] = Settings['autostart'] - ['dependency']

    Settings['base_versions'] ||= {}
    CharSettings['next_ruby_version_check_datetime'] = Time.now

    @developer = Settings['dependency-developer'] || false
    @ignore_dependency = Settings['ignore-dependency'] || false
    @add_autos = []
    @remove_autos = []
    update_autostarts
    @self_updated = false
    @thievery_queue = []
    @shop_update_queue = []

    @enable_fork = LICH_VERSION =~ /f/
    @request_authorization = manage_github_token
    @versions = nil
  end

  def updated_dependency?
    @self_updated
  end

  def update_autostarts
    @autostarts = (UserVars.autostart_scripts + Settings['autostart']).uniq
  end

  def update_status_url
    @status_url = 'https://api.github.com/repos/' + @status_repo + '/git/trees/' + @status_branch
  end

  def set_custom_status_repo(repo, branch)
    @status_repo = repo
    @status_branch = branch
    update_status_url
  end

  def set_custom_status_branch(branch)
    @status_branch = branch
    update_status_url
  end

  def unset_custom_status
    @status_repo = 'rpherbig/dr-scripts'
    @status_branch = 'master'
    update_status_url
  end

  def check_custom_status
    @status_url
  end

  def add_global_auto(script)
    @add_autos << script
  end

  def remove_global_auto(script)
    @remove_autos << script
  end

  def get_versions
    if @versions
      @versions
    else
      @versions = build_version_hash
    end
  end

  def build_version_hash
    Dir['./scripts/*.lic'].each_with_object({}) do |path, versions|
      file = File.basename(path)
      body = File.open("./scripts/#{file}", 'r').readlines.join('')
      sha = Digest::SHA1.hexdigest('blob' + " #{body.size}" + "\0" + body)
      versions[file] = sha
    end
  end

  def autos_proccessed?
    @add_autos.empty? && @remove_autos.empty?
  end

  def queue_thieving_update(id, update)
    @thievery_queue << [id, update]
  end

  def queue_shop_update(shop_data)
    @shop_update_queue << shop_data
  end

  def run_queue
    validate_supported_ruby_version
    Settings['dependency-developer'] = @developer
    Settings['ignore-dependency'] = @ignore_dependency
    Settings['status_repo'] = @status_repo
    Settings['status_branch'] = @status_branch
    update = false

    unless @add_autos.empty?
      update = true
      @add_autos.each { |script| Settings['autostart'] << script }
      @add_autos = []
    end
    unless @remove_autos.empty?
      update = true
      @remove_autos.each { |script| Settings['autostart'].delete(script) }
      @remove_autos = []
    end
    if @disable_fork
      stop_download_lich
      @disable_fork = nil
    elsif @enable_fork
      download_lich
      @enable_fork = nil
    end

    submit_thieving_update(*@thievery_queue.pop) unless @thievery_queue.empty?
    submit_shop_update(@shop_update_queue.pop) unless @shop_update_queue.empty?
    update_autostarts if update
  end

  def submit_shop_update(shop_data)
    partial = shop_data[:surfaces].nil?

    key = "#{shop_data[:root_room]}-#{shop_data[:entrance]}"

    uri = URI.parse("#{@firebase_url}/shop-data/#{key}.json")
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = true
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE

    begin
      request = partial ? Net::HTTP::Patch.new(uri.request_uri) : Net::HTTP::Put.new(uri.request_uri)
      request['Content-Type'] = 'application/json'
      request.body = shop_data.to_json
      response = http.request(request)
      response.body.chomp
    rescue => e
      echo(e)
      echo('Error in submitting shop data')
    end
  end

  def get_script(filename, force = false)
    filename = filename.dup
    echo("checking:#{filename} force:#{force}") if @debug
    download_script(filename, force)
  end

  def repo_scripts
    $manager.get_status['tree'].map { |element| element['path'] }.select { |file| file.include?('.lic') && !file.include?('-setup') }
  end

  def start_scripts(force = false)
    @versions = nil
    repo_scripts.each { |(name, _)| get_script(name, force) }
    autostarts.each do |script|
      if script == 'drinfomon'
        respond "\n---\ndrinfomon found in autostarts. This method is no longer used. Attempting to remove it now. If unsuccessful, it can be safely removed with `#{$clean_lich_char}e stop_autostart('drinfomon')`\n---\n"
        stop_autostart('drinfomon')
        next
      end
      custom_require.call(script)
      begin
        pause 0.2
      end while !Script.running.find_all { |s| s.name =~ /bootstrap/ }.empty?
    end
  end

  def queue_lich
    @enable_fork = true
  end

  def unqueue_lich
    @disable_fork = true
  end

  def download_lich
    return if @developer

    lich_data = make_request(@lich_url)['tree'].find { |data| data['path'] == 'lich.rbw' }
    if LICH_VERSION =~ /f/ && Settings['lich_fork_sha'] == lich_data['sha']
      echo('latest version of lich fork already downloaded.')
      return
    end
    blob = make_request(lich_data['url'])
    File.open('lich.rbw', 'w') { |file| file.print(Base64.decode64(blob['content'])) }
    Settings['lich_fork_sha'] = lich_data['sha']
    echo('New version of lich installed, please restart Lich.')
  end

  def stop_download_lich
    Settings['lich_fork_sha'] = nil
  end

  def download_script(filename, force = false)
    return if filename.nil? || filename.empty?
    if filename == 'dependency.lic' && @ignore_dependency
      respond 'ignoring dependency download due to ignore_dependency setting'
      respond "use '#{$clean_lich_char}e check_dependency' to check the value."
      return
    end
    echo("downloading:#{filename}") if @debug
    info = get_file_status(filename)
    return unless info
    return if @developer
    return if get_versions[filename] == info['sha'] && !force

    echo("info:#{info}") if @debug
    blob = make_request(info['url'])
    File.open("./scripts/#{filename}", 'w') { |file| file.print(Base64.decode64(blob['content'])) }

    @self_updated = true if filename == 'dependency.lic'
  end

  def verify_or_make_dir(path)
    Dir.mkdir(path) unless Dir.exist?(path)
  end

  def setup_profiles
    verify_or_make_dir './scripts/profiles'
    profile_tree_url = get_status['tree'].find { |element| element['path'] == 'profiles' }['url']
    make_request(profile_tree_url)['tree'].each do |setup_file|
      echo("downloading #{setup_file}") if @debug
      blob = make_request(setup_file['url'])
      File.open("./scripts/profiles/#{setup_file['path']}", 'w') { |file| file.print(Base64.decode64(blob['content'])) }
    end
  end

  def setup_data
    verify_or_make_dir './scripts/data'
    data_tree_url = get_status['tree'].find { |element| element['path'] == 'data' }['url']
    make_request(data_tree_url)['tree'].each do |setup_file|
      echo("downloading #{setup_file}") if @debug
      blob = make_request(setup_file['url'])
      File.open("./scripts/data/#{setup_file['path']}", 'w') { |file| file.print(Base64.decode64(blob['content'])) }
    end
  end

  def update_local_stealing_yaml(id, update, new_entry = false)
    stealing_path = './scripts/data/base-stealing.yaml'
    stealing_data = $setupfiles.safe_load_yaml(stealing_path)
    result = nil
    if new_entry
      stealing_data[:stealing_options].push(update)
    else
      stealing_data[:stealing_options].each do |data|
        if data['id'] == id
          result = data.dup
          data.merge!(update)
        end
      end
    end
    File.open(stealing_path, 'w') { |file| file.print(stealing_data.to_yaml) }
    result
  end

  def check_base_files
    return if @developer
    verify_or_make_dir './scripts/profiles'
    profile_tree_url = get_status['tree'].find { |element| element['path'] == 'profiles' }['url']
    make_request(profile_tree_url)['tree']
      .select { |data| /^base.+yaml/ =~ data['path'] }
      .reject { |setup_file| setup_file['sha'] == Settings['base_versions'][setup_file['path']] }
      .each do |setup_file|
        echo("downloading #{setup_file}") if @debug
        blob = make_request(setup_file['url'])
        File.open("./scripts/profiles/#{setup_file['path']}", 'w') { |file| file.print(Base64.decode64(blob['content'])) }
        Settings['base_versions'][setup_file['path']] = setup_file['sha']
      end
  end

  def check_data_files
    return if @developer
    verify_or_make_dir './scripts/data'
    profile_tree_url = get_status['tree'].find { |element| element['path'] == 'data' }['url']
    make_request(profile_tree_url)['tree']
      .select { |data| /^base.+yaml/ =~ data['path'] }
      .reject { |setup_file| setup_file['sha'] == Settings['base_versions'][setup_file['path']] }
      .each do |setup_file|
        echo("downloading #{setup_file}") if @debug
        blob = make_request(setup_file['url'])
        File.open("./scripts/data/#{setup_file['path']}", 'w') { |file| file.print(Base64.decode64(blob['content'])) }
        Settings['base_versions'][setup_file['path']] = setup_file['sha']
      end
  end

  def run_script(filename)
    filename.sub!(/\.lic$/, '')
    echo("refresh:#{filename}") if @debug
    stop_script(filename) if Script.running?(filename)
    pause 0.1 while Script.running?(filename)
    start_script(filename)
  end

  def file_outdated?(filename)
    echo("file_outdated?:#{filename}") if @debug
    local_version = get_versions[filename]
    echo("local:#{local_version}") if @debug
    info = get_file_status(filename)
    unless info
      echo("file not found in repository: #{filename}")
      return false
    end
    echo("remote:#{info['sha']}") if @debug
    info['sha'] != local_version
  end

  def get_file_status(filename)
    get_status['tree'].find { |element| element['path'] == filename }
  end

  def get_status
    return @status if @status && Time.now - @status_time <= 30 # prevent flooding
    @status_time = Time.now
    @status = make_request(@status_url)
  end

  def make_request(raw_uri)
    echo "make_request:raw_uri = #{raw_uri}" if @debug
    uri = URI.parse(raw_uri)
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = true
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE

    request = Net::HTTP::Get.new(uri.request_uri)
    request['Authorization'] = @request_authorization

    response = http.request(request)
    JSON.parse(response.body)
  end

  def manage_github_token
    # This method manages some checking of the GitHub token we'll be using. We allow a personal
    # GitHub token to be specified in the /data folder, or we can use the general Lich token.
    # If using a personal GitHub token, we'll verify the token is valid, and we'll also do some
    # checking of the rate limit for the token we're using. If the rate limit is above a certain
    # threshold, we'll warn but won't fail, as Lich can still function when the rate limit is
    # exceeded, albeit with some reduced functionality.
    #  Returns: request['Authorization'] token string

    github_token = [
      'Z2hwX21XN1',
      'V0RkdORXdGYlpmVDF1S3AzM2I1TV',
      'J5bHlTNjBXc09VNw==',
      '\n'
    ].join('')

    # Set up our rate limit check URL and items
    url = URI("https://api.github.com/rate_limit")
    http = Net::HTTP.new(url.host, url.port)
    http.use_ssl = true
    request = Net::HTTP::Get.new(url)

    # Check if the user has a githubtoken.txt file and use the token in that file if so. If they
    # do have a personal token specified, verify valid. Else, use general token. Note: the .strip
    # is apparently necessary to have the File.read function in Linux.
    if File.exist?("#{DATA_DIR}/githubtoken.txt")
      echo "Using personal GitHub token."
      request['Authorization'] = "token #{File.read("#{DATA_DIR}/githubtoken.txt").strip}"

      # Verify the GitHub token is valid. If not, swap to the general token.
      if http.request(request).body =~ /Bad credentials/
        echo "Bad personal GitHub token. Reverting to Lich's general token."
        echo "Please update /lich/data/githubtoken.txt"
        request['Authorization'] = "token #{Base64.decode64(github_token)}"
      end
    else
      echo "Using general GitHub token." if @debug
      request['Authorization'] = "token #{Base64.decode64(github_token)}"
    end

    response = http.request(request)
    parsed_response = JSON.parse(response.body)

    used = parsed_response["resources"]["core"]["used"].to_i
    limit = parsed_response["resources"]["core"]["limit"].to_i

    echo "Current token rate limit usage: #{used}/#{limit}" if @debug

    # Warn if rate limit is currently above 80% usage.
    if used.to_f/limit >= 0.8 && @debug
      echo ""
      echo "*** WARNING: GitHub rate currently #{used}/#{limit} ***"
      echo "*** Please report in Discord or GitHub. ***"
      echo ""
    end

    return request['Authorization']
  end

  def submit_thieving_update(id, update)
    return submit_new_thieving_item(id, update) if update.delete('new')

    old_data = update_local_stealing_yaml(id, update)

    return

    data = get_current_stealing_data(id)

    update.delete_if do |key, value|
      echo("checking:#{data[key]}:#{old_data[key]}") if UserVars.crossing_trainer_debug
      key =~ /_min$/ ? data[key] && data[key] != old_data[key] && value >= data[key] : data[key] && data[key] != old_data[key] && value <= data[key]
    end

    if update.empty?
      echo('Nothing left to update') if UserVars.crossing_trainer_debug
      return
    end

    echo("submitting:#{id}:#{update}") if UserVars.crossing_trainer_debug
    uri = URI.parse("#{@firebase_url}/stealing-options/#{id}.json")
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = true
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE

    request = Net::HTTP::Patch.new(uri.request_uri)
    request['Content-Type'] = 'application/json'
    request.body = update.to_json
    response = http.request(request)
    response.body.chomp
  end

  def submit_new_thieving_item(id, data)
    id = (id.to_i + 1).to_s while get_current_stealing_data(id)

    data['id'] = id

    update_local_stealing_yaml(id, data, true)

    echo("submittingNEW:#{id}:#{data}") if UserVars.crossing_trainer_debug

    uri = URI.parse("#{@firebase_url}/stealing-options/#{id}.json")
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = true
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE

    request = Net::HTTP::Put.new(uri.request_uri)
    request['Content-Type'] = 'application/json'
    request.body = data.to_json
    response = http.request(request)
    response.body.chomp
  end

  def get_current_stealing_data(id)
    uri = URI.parse("#{@firebase_url}/stealing-options/#{id}.json")
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = true
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE

    request = Net::HTTP::Get.new(uri.request_uri)
    request['Content-Type'] = 'application/json'
    response = http.request(request)
    return nil if response.body.nil?
    begin
      JSON.parse(response.body.chomp)
    rescue
      return nil
    end
  end

  def submit_pastebin(message_body)
    uri = URI.parse(@paste_bin_url)
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = true
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE

    request = Net::HTTP::Post.new(uri.request_uri)
    request.set_form_data(api_dev_key: @paste_bin_token, api_paste_code: message_body, api_paste_private: '1', api_paste_expire_date: '1W', api_option: 'paste')

    response = http.request(request)
    result = response.body.chomp
    if result.size >= 200
      'Failed to upload pastebin.'
    else
      result
    end
  end

  def submit_help_pastebin
    message_body = "Trusted Scripts: #{Script.list_trusted.uniq}"
    message_body += "\n"
    message_body += "Lich Version: #{LICH_VERSION}"
    message_body += "\n"
    message_body += "Ruby Version: #{RUBY_VERSION}p#{RUBY_PATCHLEVEL} #{RUBY_PLATFORM}"
    message_body += "\n"
    message_body += "Dependency Version: #{$DEPENDENCY_VERSION}"
    message_body += "\n"
    message_body += "Game Client: #{$frontend}"
    message_body += "\n"

    Dir['./scripts/profiles/*.yaml'].map { |item| File.path(item) }.select { |path| path.include?("#{checkname}-") }.each do |path|
      message_body += "\n****\n" * 3
      message_body += path.to_s
      message_body += "\n"
      message_body += File.read(path)
    end

    message_body += "\n****\n" * 3
    message_body += Dir['./scripts/profiles/*.*'].join(',')
    message_body += "\n"
    message_body += Dir['./scripts/data/*.*'].join(',')
    message_body += "\n"

    message_body.gsub!("bastard","dastard (modified)")

    submit_pastebin(message_body)
  end
end

class BankbotManager
  def initialize(debug)
    @debug = debug
    @save = false
    @load = false
    @transaction = ''
    @ledger = {}
  end

  attr_reader :ledger

  def loaded?
    !@load
  end

  def run_queue
    save_transaction
    load_ledger
  end

  def save_bankbot_transaction(transaction, ledger)
    @transaction = transaction
    @ledger = ledger.to_yaml
    @save = true
  end

  def load_bankbot_ledger
    @load = true
  end

  private

  def save_transaction
    return unless @save
    File.open("./#{checkname}-transactions.log", 'a') do |file|
      file.puts('----------')
      file.puts(Time.now)
      file.puts(@transaction)
      file.puts(@ledger)
      file.puts('----------')
    end
    File.open("./#{checkname}-ledger.yaml", 'wb') { |file| file.puts(@ledger) }
    @save = false
  end

  def load_ledger
    return unless @load
    @ledger = safe_load_yaml("./#{checkname}-ledger.yaml")
    @load = false
  end

  def safe_load_yaml(path)
    OpenStruct.new(YAML.load_file(path)).to_h
  rescue => e
    echo('*** ERROR PARSING YAML FILE ***')
    echo(e.message)
    return {}
  end
end

class ReportbotManager
  def initialize(debug)
    @debug = debug
    @save = false
    @load = false
    @whitelist = []
  end

  attr_reader :whitelist

  def loaded?
    !@load
  end

  def run_queue
    save_whitelist
    load_whitelist
  end

  def save_reportbot_whitelist(whitelist)
    @whitelist = whitelist.to_yaml
    @save = true
  end

  def load_reportbot_whitelist
    @load = true
  end

  private

  def save_whitelist
    return unless @save
    File.open('./reportbot-whitelist.yaml', 'wb') { |file| file.puts(@whitelist) }
    @save = false
  end

  def load_whitelist
    return unless @load
    @whitelist = safe_load_yaml('./reportbot-whitelist.yaml')
    @load = false
  end

  def safe_load_yaml(path)
    YAML.load_file(path)
  rescue => e
    echo('*** ERROR PARSING YAML FILE ***')
    echo(e.message)
    return []
  end
end

class SlackbotManager
  def initialize(debug)
    @debug = debug
    @slackbot = nil
    @username = nil
    @messages = []
  end

  def run_queue
    register_slackbot
    send_messages
  end

  def register(username)
    return if @slackbot

    @username = username
  end

  def queue_message(message)
    return unless message

    @messages << message
  end

  private

  def register_slackbot
    return if @slackbot
    return unless @username
    custom_require.call('slackbot')
    @slackbot = SlackBot.new
  end

  def send_messages
    return unless @slackbot

    until @messages.empty?
      message = @messages.shift
      @slackbot.direct_message(@username, message)
    end
  end
end

class SetupFiles
  # http://www.druby.org/sidruby/5-3-thread-safe-communication-using-locking-mutex-and-monitormixin.html#sec.monitormixin
  include MonitorMixin

  class FileInfo
    attr_reader :path, :name, :mtime

    def initialize(path:, name:, data:, mtime:)
      @path = path
      @name = name
      @data = data
      @mtime = mtime
    end

    def data
      # Create deep clone of data to mitigate scripts changing settings in-memory
      # because that leads to hard to track down bugs and unpredictable script behaviors.
      Marshal.load(Marshal.dump(@data))
    end

    def peek(property)
      # An efficient and safe way to return a specific property
      # from the yaml file without the risks of passing around shallow copies.
      # This marshals the one property which is magnitudes faster than
      # marshalling the entire file to access one property.
      Marshal.load(Marshal.dump(@data[property.to_sym]))
    end

    def to_s
      File.join(@path, @name)
    end

    def inspect
      "#<SetupFiles::FileInfo @name=#{@name}, @path=#{@path}, @mtime=#{@mtime}>"
    end
  end

  def initialize(debug = false)
    super() # Must call super() to initialize the MonitorMixin
    @files_cache = {} # map of filenames => FileInfo objects
    @debug = debug
  end

  def safe_load_yaml(filepath)
    OpenStruct.new(YAML.load_file(filepath)).to_h
  rescue => e
    echo('*** ERROR PARSING YAML FILE ***')
    echo(e.message)
    return {}
  end

  # Returns your character's settings.
  # base.yaml, base-empty.yaml, and MyChar-setup.yaml are always loaded.
  # You can also provide an array of character yaml suffixes to load additionally.
  # For example, ['hunt'] to load 'scripts/profiles/MyChar-hunt.yaml'.
  # The suffixes feature is primarily used by hunting-buddy.
  def get_settings(character_suffixes = [])
    character_suffixes = ['setup', character_suffixes].flatten.compact.uniq
    character_filenames = character_suffixes_to_filenames(character_suffixes)
    # Ensure latest profiles are loaded into cache
    reload_profiles(character_filenames)
    # Get 'include' filenames, suffixes to other files where players externalize
    # reusable settings that they share/include in other character setting files.
    include_filenames = character_filenames
      .reduce([]) do |result, filename|
        result += (cache_get_by_filename(filename).peek('include') || [])
      end
      .map do |suffix|
        to_include_filename(suffix)
      end
    reload_profiles(include_filenames)
    # Merge base and character settings
    settings = [
      'base.yaml',
      'base-empty.yaml',
      include_filenames,
      character_filenames
    ].flatten.reduce({}) do |result, filename|
      result.merge(cache_get_by_filename(filename).data || {})
    end
    # Transform settings for quality of life improvements
    transform_settings(settings)
  end

  # Returns the config in a 'scripts/data/base-{type}.yaml' file.
  # For example, type could be 'spells' or 'town' to return base-spells.yaml or base-town.yaml.
  def get_data(type)
    filename = to_base_filename(type)
    # Ensure latest data is loaded into cache
    reload_data([filename])
    # Transform data for quality of life improvements
    transform_data(cache_get_by_filename(filename).data)
  end

  # Designed to be called once before dependency enters its run loop.
  # Purpose is to check for file changes and reload them into cache.
  def reload
    reload_profiles(character_suffixes_to_filenames(['setup']))
    reload_data
  end

  private

  SCRIPTS_DATA_PATH = File.join('.', 'scripts', 'data')

  # use alternate location for settings to allow folks to use lich with
  # alternate configurations in Test/Platinum/Fallen
  if File.exist?("#{DATA_DIR}/#{XMLData.game}/base.yaml") && File.exist?("#{DATA_DIR}/#{XMLData.game}/base-empty.yaml") && File.exist?("#{DATA_DIR}/#{XMLData.game}/#{checkname}-setup.yaml")
    echo("Detected game instance-specific files. Loading settings from #{File.join(DATA_DIR, XMLData.game)}")
    SCRIPTS_PROFILES_PATH = File.join(DATA_DIR, XMLData.game)
  else
    SCRIPTS_PROFILES_PATH = File.join('.', 'scripts', 'profiles')
  end

  # Reloads the base profiles plus any that match the filenames given.
  def reload_profiles(filenames = [])
    load_files(get_profiles_glob_patterns(filenames))
  end

  # Reloads the base data plus any that match the filenames given.
  def reload_data(filenames = [])
    load_files(get_data_glob_patterns(filenames))
  end

  # Gets glob patterns for the profiles directory.
  # Includes base profiles plus any specified in the filenames argument.
  def get_profiles_glob_patterns(filenames = [])
    get_glob_patterns(SCRIPTS_PROFILES_PATH, filenames)
  end

  # Gets glob patterns for the data directory.
  # Includes base data plus any specified in the filenames argument.
  def get_data_glob_patterns(filenames = [])
    get_glob_patterns(SCRIPTS_DATA_PATH, filenames)
  end

  # Generates an array of file glob patterns, one per filename in the given basepath.
  # `base*.yaml` is automatically and always included in the glob pattern.
  def get_glob_patterns(basepath = '.', filenames = [])
    # base* yamls define initial setting defaults.
    # include* yamls allow players to organize their settings into files
    # and then reference them in their character specific setup yamls.
    # The use of include yamls promotes reuse, which is a big win
    # for players with several characters.
    filenames = ["base*.yaml", "include*.yaml", filenames].flatten.compact.uniq
    filenames.map { |filename| File.join(basepath, File.basename(filename)) }
  end

  # Given an array of suffixes like ['setup'] or ['setup', 'hunt'] then
  # returns an array of those values mapped to filenames "{CharacterName}-{suffix}.yaml"
  def character_suffixes_to_filenames(character_suffixes)
    character_suffixes.map { |suffix| to_character_filename(suffix) }
  end

  # Returns the filename to a character yaml file for the given suffix.
  # For example 'setup' returns '{character}-setup.yaml'.
  def to_character_filename(suffix)
    "#{checkname}-#{suffix}.yaml"
  end

  # Returns the filename to a base yaml file for the given suffix.
  # For example 'spells' returns 'base-spells.yaml'.
  def to_base_filename(suffix)
    "base-#{suffix}.yaml"
  end

  # Returns the filename to an include yaml file for the given suffix.
  # For example 'spells' returns 'include-spells.yaml'.
  def to_include_filename(suffix)
    "include-#{suffix}.yaml"
  end

  # Iterates the files matched by the glob pattern and for those that
  # have been modified since the last time they were cached then those
  # are read from disk and cached. Unchanged files are not read again.
  def load_files(glob_patterns = [])
    self.synchronize do
      echo "#{self.class}::#{__callee__} glob_patterns=#{glob_patterns}" if @debug
      glob_patterns.each do |glob_pattern|
        Dir.glob(glob_pattern)
          .uniq
          .select { |filepath| File.file?(filepath) } # ignore directories
          .each do |filepath|
            filename = File.basename(filepath)
            last_modified_date = File.mtime(filepath)
            cached_file = cache_get_by_filename(filename)
            echo "#{self.class}::#{__callee__} filepath=#{filepath}, last_modified_date=#{last_modified_date}, cached_file=#{cached_file.inspect}" if @debug
            if cached_file.mtime != last_modified_date
              cache_put_by_filepath(filepath)
            end
          end
      end
    end
  end

  # Loads the yaml file contents into the file cache.
  # Uses the filename as the cache key.
  def cache_put_by_filepath(filepath)
    self.synchronize do
      echo "#{self.class}::#{__callee__} filepath=#{filepath}" if @debug
      @files_cache[File.basename(filepath)] = SetupFiles::FileInfo.new(
        path: File.dirname(filepath),
        name: File.basename(filepath),
        mtime: File.mtime(filepath),
        data: safe_load_yaml(filepath)
      )
    end
  end

  # Returns the cached file info for the given filename.
  # Uses the filename as the cache key.
  def cache_get_by_filename(filename)
    echo "#{self.class}::#{__callee__} filename=#{filename}" if @debug
    @files_cache[filename]
  end

  # Enrich settings with base data (e.g. fill in gaps for spells),
  # migrate legacy settings where appropriate, and other QOL tweaks.
  def transform_settings(original_settings)
    echo "#{self.class}::#{__callee__}" if @debug

    # Enable dot access to top-level properties (e.g. settings.hometown)
    settings = OpenStruct.new(original_settings)

    # Get data to enrich settings
    base_data_items = get_data('items')
    base_data_spells = get_data('spells')
    base_data_empty = get_data('empty')

    battle_cries_data = base_data_spells.battle_cries
    spells_data = base_data_spells.spell_data
    empty_data = base_data_empty.empty_values

    # Populate nil settings with default empty arrays/hashes
    # to mitigate "can't convert NilClass to Array" errors.
    # Note we don't merge to overwrite, we merge to assign if nil.
    empty_data.each { |name, value| settings[name] ||= value }

    # Find spell data by its name, case insensitive.
    get_spell_data_by_name = lambda do |name_to_find|
      # This creates a new map filtered to only the entries that match the spell name.
      spell_matches = spells_data.select { |name, data| name.casecmp?(name_to_find) }
      # It's theoretically possible, though unlikely, that multiple
      # entries were returned if base data had the same spell listed
      # with different capitalization. Let's take the first entry we found.
      spell_match = spell_matches.first
      # We now have a map of spell name to map of spell properties.
      # What we want to return is just the map of spell properties.
      # Maps are treated as two-element arrays, first is the key, last is the value.
      # So we grab the last element which leaves us with map of spell properties.
      spell_data = spell_match.last
      # Inject spell name into the spell properties.
      # Some scripts check for either `abbrev` or `name`
      # but our base spells data doesn't have name as a property, so we set it.
      spell_data['name'] ||= spell_match.first

      spell_data
    end

    # Find spell data by its abbreviation, case insensitive.
    get_spell_data_by_abbrev = lambda do |abbrev_to_find|
      # This creates a new map filtered to only the entries that match the spell abbreviation.
      spell_matches = spells_data.select { |name, data| data['abbrev'].casecmp?(abbrev_to_find) }
      # It's theoretically possible, though unlikely, that multiple
      # entries were returned if base data had the same spell listed
      # with different capitalization. Let's take the first entry we found.
      spell_match = spell_matches.first
      # We now have a map of spell name to map of spell properties.
      # What we want to return is just the map of spell properties.
      # Maps are treated as two-element arrays, first is the key, last is the value.
      # So we grab the last element which leaves us with map of spell properties.
      spell_data = spell_match.last
      # Inject spell name into the spell properties.
      # Some scripts check for either `abbrev` or `name`
      # but our base spells data doesn't have name as a property, so we set it.
      spell_data['name'] ||= spell_match.first

      spell_data
    end

    # Given a hash for a single spell definition,
    # populates unset properties with base spells data.
    #
    # For example:
    # if spell data has:
    #   { name: 'Death Monkey', abbrev: 'DM', mana: 5, skill: 'Targeted Magic' }
    #
    # and your spell setting in your yaml has:
    #   { abbrev: 'DM', mana: 8 }
    #
    # then this method returns the enriched spell configuration as:
    #   { name: 'Death Monkey', abbrev: 'DM', mana: 8, skill: 'Targeted Magic' }
    #
    enrich_spells_with_data_block = lambda do |spell_setting|
      return spell_setting unless spell_setting.is_a?(Hash)
      spell_data = get_spell_data_by_name.call(spell_setting['name']) ||
                   get_spell_data_by_abbrev.call(spell_setting['abbrev'])
      (spell_data || {}).merge(spell_setting)
    end

    # Given a hash of spell names to spell definitions,
    # populates the `name:` property on the spell definition if it's missing.
    #
    # Because the the map keys are themselves the spell names,
    # some players don't repeat the `name:` or `abbrev:` property
    # in the spell setting. However, we need that information
    # in order to enrich the spell setting with base data.
    #
    # For example:
    # if spells map has:
    #   { 'Devour': { 'use_auto_mana': true }, 'wound_level_threshold': 2 }
    #
    # then this method returns the enriched spell configuration as:
    #   { 'Devour': { 'name': 'Devour', 'use_auto_mana': true }, 'wound_level_threshold': 2 }
    #
    enrich_spells_with_name_block = lambda do |spells_map|
      spells_map.each do |spell_name, spell_setting|
        # Sometimes these maps support keys other than spell names,
        # such as numeric thresholds or other related script settings.
        # Check if this setting is a hash to avoid "no implicit conversion" errors
        # when we try to access the `name` property.
        if spell_setting.is_a?(Hash)
          spell_setting['name'] ||= spell_name
        end
      end
    end

    # Waggle sets are maps of arbitrary names to map of spell names to map of spell properties.
    # For example:
    #   { 'burgle': { 'Refractive Field': { abbrev: 'RF' ... }, 'Death Monkey': { ... } } }
    # Iterate each waggle's list of spells to enrich them.
    # Enrich each's spell definition by merging base spell data with spell settings.
    settings.waggle_sets.transform_values! do |spells_map|
      # For non-magic users it's actually an array of ability names, not spells.
      if spells_map.is_a?(Hash)
        enrich_spells_with_name_block.call(spells_map)
        spells_map.transform_values!(&enrich_spells_with_data_block)
      else
        spells_map
      end
    end

    # Spell settings that are maps of spell names to map of spell properties.
    # For example:
    #   { 'Manifest Force': { abbrev: 'MAF', mana: 5 ... } }
    # Enrich each's spell definition by merging base spell data with spell settings.
    [
      settings.buff_spells,
      settings.necromancer_healing,
    ].each do |spells_map|
      enrich_spells_with_name_block.call(spells_map)
      spells_map.transform_values!(&enrich_spells_with_data_block)
    end

    # Spell settings that are magic skill names to map of spell properties.
    # For example, { 'Augmentation': { abbrev: 'MAF' ... } }
    # Enrich each's spell definition by merging base spell data with spell settings.
    [
      settings.buff_spells,
      settings.combat_spell_training,
      settings.cyclic_training_spells,
      settings.magic_training,
      settings.training_spells,
      settings.crafting_training_spells,
      settings.necromancer_healing,
    ].each do |spells_map|
      # For non-magic users it's actually an array of ability names, not spells.
      next unless spells_map.is_a?(Hash)
      # Because the map keys are skill names, not spell names,
      # we have to assume the spell name or abbrev are defined in the setting.
      spells_map.transform_values!(&enrich_spells_with_data_block)
    end

    # Spell settings that are configured as a list whose values are maps of spell properties.
    # Enrich each's spell definition by merging base spell data with spell settings.
    [
      settings.offensive_spells
    ].each do |spells_list|
      # Because there is no other context to know which spell the setting is for
      # we have to assume the spell name or abbrev are defined in the setting.
      spells_list.map!(&enrich_spells_with_data_block)
    end

    # Spell settings that are configured as a map of a single spell's properties.
    # Enrich each's spell definition by merging base spell data with spell settings.
    [
      'crossing_training_sorcery',
    ].each do |key|
      settings[key] = enrich_spells_with_data_block.call(settings[key])
    end

    # For TM spells, default their 'prep' command to 'target'
    # unless a custom 'prep' command is already specified.
    settings.offensive_spells.each do |spell_setting|
      spell_data = spells_data[spell_setting['name']]
      is_native_tm = spell_setting['skill'] == 'Targeted Magic'
      is_sorcery_tm = spell_setting['skill'] == 'Sorcery' && spell_data['skill'] == 'Targeted Magic'
      if is_native_tm || is_sorcery_tm
        spell_setting['prep'] ||= 'target'
      end
    end

    # Battle Cries
    settings.battle_cries.map! do |battle_cry_setting|
      battle_cry_data = battle_cries_data[battle_cry_setting['name']]
      (battle_cry_data || {}).merge(battle_cry_setting)
    end

    # Lootables
    settings.lootables = (
      base_data_items.lootables +
      base_data_items.box_nouns +
      base_data_items.gem_nouns +
      base_data_items.scroll_nouns +
      settings.loot_additions -
      settings.loot_subtractions
    ).uniq

    # Pull sensitive settings from UserVars.
    # This is legacy from when people would commit and share their
    # yaml files on GitHub so that specific rooms and names were not exposed.
    settings.crossing_training_sorcery_room ||= UserVars.crossing_training_sorcery_room
    settings.compost_room ||= UserVars.compost_room
    settings.engineering_room ||= UserVars.engineering_room
    settings.outfitting_room ||= UserVars.outfitting_room
    settings.alchemy_room ||= UserVars.alchemy_room
    settings.safe_room ||= UserVars.safe_room
    settings.safe_room_id ||= UserVars.safe_room_id
    settings.safe_room_empath ||= UserVars.safe_room_empath
    settings.safe_room_empaths += (UserVars.safe_room_empaths || [])
    settings.slack_username ||= UserVars.slack_username
    settings.bankbot_name ||= UserVars.bankbot_name
    settings.bankbot_room_id ||= UserVars.bankbot_room_id
    settings.prehunt_buffs ||= UserVars.prehunt_buffs
    settings.hometown ||= UserVars.hometown
    settings.hometown = $HOMETOWN if $HOMETOWN

    # If these room settings are defined as maps with a
    # room id configured per town, then grab the hometown room id
    # and assign it directly to the setting.
    [
      'alchemy_room',
      'bankbot_room_id',
      'compost_room',
      'crossing_training_sorcery_room',
      'enchanting_room',
      'engineering_room',
      'feed_cloak_room',
      'forage_override_room',
      'lockpick_room_id',
      'outdoor_room',
      'outfitting_room',
      'prehunt_buffing_room',
      'safe_room',
      'safe_room_id',
      'theurgy_prayer_mat_room'
    ].each do |setting_name|
      if settings[setting_name].is_a?(Hash)
        hometown_value = settings[setting_name][settings.hometown]
        settings[setting_name] = hometown_value if hometown_value
      end
    end

    # Merge legacy appraisal settings into target appraisal settings
    if !settings.appraisal_training.include?('pouches') && settings.train_appraisal_with_pouches
      settings.appraisal_training.append('pouches')
    end
    if !settings.appraisal_training.include?('gear') && settings.train_appraisal_with_gear
      settings.appraisal_training.append('gear')
    end

    # Merge legacy astrology training settings into target training settings
    if !settings.astrology_training.include?('events') && settings.predict_event
      settings.astrology_training.append('events')
    end
    if !settings.astrology_training.include?('ways') && settings.astral_plane_training['train_in_ap']
      settings.astrology_training.append('ways')
    end

    return settings
  rescue => e
    echo "*** ERROR TRANSFORMING SETTINGS IN DEPENDENCY ***"
    echo "*** Commonly this due to malformed config in your yaml file ***"
    echo e.message
    e.backtrace.each { |msg| echo msg }
    OpenStruct.new
  end

  def transform_data(original_data)
    echo "#{self.class}::#{__callee__}" if @debug

    # Enable dot access to top-level properties (e.g. data.cast_messages)
    data = OpenStruct.new(original_data)

    # ... reserved for future needs ...

    return data
  rescue => e
    echo "*** ERROR MODIFYING DATA IN DEPENDENCY ***"
    echo e.message
    e.backtrace.each { |msg| echo msg }
    OpenStruct.new
  end

end

class MoonWatch
  attr_reader :moon_data

  def initialize(debug)
    @debug = debug
    @moon_data = {}
    UserVars.moons = { 'katamba' => {}, 'yavash' => {}, 'xibar' => {}, 'visible' => [] }
    UserVars.sun = {}
    @firebase_url = 'https://dr-scripts.firebaseio.com/'
    @queue = []
    load_moon_data
  end

  def debug
    @debug = !@debug
  end

  def connections
    return nil unless @debug
    [@f, @moon_source]
  end

  def load_moon_data
    @last_connect = Time.now
    @data_delay = nil
    echo("retrieving moon data") if @debug
    uri = URI.parse("#{@firebase_url}/moon_data_v2.json")
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = true
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE

    request = Net::HTTP::Get.new(uri.request_uri)
    request['Content-Type'] = 'application/json'
    response = http.request(request)
    @moon_data = nil if response.body.nil?
    begin
      @moon_data = JSON.parse(response.body.chomp)
    rescue
      @moon_data = nil
    end
  rescue => e
    echo("error in moonwatch #{e.inspect}")
  end

  def queue_update(moon, data)
    @queue << [moon, data]
  end

  def snapshot_seconds_until_load
    return 60 unless UserVars.moons.reject { |m| m == 'visible' }.values.first['timer'] && UserVars.sun['timer']
    return @data_delay if @data_delay
    echo("calculting next moon data request") if @debug
    all_timers = UserVars.moons.reject { |m| m == 'visible' }.values.map{|data| data['timer']} + [UserVars.sun['timer']]
    @data_delay = ([all_timers.min*0.8, 1].max * 60).to_i
    echo("Next request in #{@data_delay} seconds") if @debug
    @data_delay
  end

  def run_queue
    load_moon_data if Time.now - @last_connect > snapshot_seconds_until_load
    return if @queue.empty?
    item = @queue.shift
    update_moon(item.first, item.last)
  end

  private

  def update_moon(body_name, data)
    echo("updating #{body_name} with #{data}") if @debug
    uri = URI.parse("#{@firebase_url}/moon_data_v2/#{body_name}.json")
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = true
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE

    request = Net::HTTP::Put.new(uri.request_uri)
    request['Content-Type'] = 'application/json'
    request.body = data.to_json
    response = http.request(request)
    response.body.chomp
  end
end

$setupfiles = SetupFiles.new(debug)
$manager = ScriptManager.new(debug)
$bankbot = BankbotManager.new(debug)
$reportbot = ReportbotManager.new(debug)
$slackbot = SlackbotManager.new(debug)

def enable_moon_connection
  $turn_on_moon_watch = true
end

def get_settings(character_suffixes = [])
  $setupfiles.get_settings(character_suffixes)
end

def get_data(type)
  $setupfiles.get_data(type)
end

def save_bankbot_transaction(transaction, ledger)
  $bankbot.save_bankbot_transaction(transaction, ledger)
end

def load_bankbot_ledger
  $bankbot.load_bankbot_ledger
  pause 0.1 until $bankbot.loaded?
  $bankbot.ledger
end

def save_reportbot_whitelist(whitelist)
  $reportbot.save_reportbot_whitelist(whitelist)
end

def load_reportbot_whitelist
  $reportbot.load_reportbot_whitelist
  pause 0.1 until $reportbot.loaded?
  $reportbot.whitelist
end

def send_slackbot_message(message)
  $slackbot.queue_message(message)
end

def register_slackbot(username)
  $slackbot.register(username)
end

def format_name(name)
  name =~ /\.lic$/ ? name : "#{name}.lic"
end

def format_yaml_name(name)
  name =~ /\.yaml$/ ? name : "#{name}.yaml"
end

def custom_require
  lambda do |script_names|
    script_names = [script_names] unless script_names.is_a?(Array)
    respond("CR:starting:#{script_names}") if UserVars.bootstrap_debug
    bootstrapper = force_start_script('bootstrap', script_names)
    pause 0.05
    while Script.running.include?(bootstrapper)
      respond("CR:waiting:#{script_names}") if UserVars.bootstrap_debug
      pause 0.05
    end
    respond("CR:done:#{script_names}") if UserVars.bootstrap_debug
  end
end

def verify_script(script_names)
  script_names = [script_names] unless script_names.is_a?(Array)
  state = true
  script_names
    .reject { |name| Script.exists?(name) }
    .each do |name|
      echo "Failed to find a script named '#{name}'"
      echo "Please report this to <https://github.com/rpherbig/dr-scripts/issues>"
      echo "or to Discord <https://discord.gg/ffcEAYfK>"
      state = false
    end
  state
end

def get_script(script_name)
  $manager.get_script(format_name(script_name), true)
end

def force_refresh_scripts
  $manager.start_scripts
end

def list_tracked_scripts
  $manager.get_versions.sort
end

def full_install
  if !supported_ruby_version?
    echo "You are using an unsupported version of ruby."
    echo "In order to prevent people from wasting too much work on an unsupported version, this will not proceed."
    echo "Please update to at least version #{$MIN_RUBY_VERSION} and try again."
    echo "For further details / assistance, please join the dr-scripts Lich Discord: https://discord.gg/uxZWxuX "
    exitfrom
  end
  respond 'Performing setup for dr-scripts.  This will take some time.  Do not stop this script until finished.'
  respond '(Step 1 of 5) Removing lich autostarts for existing scripts...'
  remove_from_autostart(managed_scripts)
  respond '(Step 2 of 5) Adding dependency.lic to lich autostart'
  add_self_to_autostart
  respond '(Step 3 of 5) Creating a /profiles directory and downloading default profiles (this will take a while)'
  setup_profiles
  respond '(Step 4 of 5) Creating a /data directory and downloading data files (this will take a while)'
  setup_data
  respond '(Step 5 of 5) Backing up existing scripts and replacing with latest versions (this will take a while)'
  replace_all
  respond 'Finished install!'
end

def replace_all
  managed_scripts
    .each do |script|
      if script == 'dependency.lic' && $manager.ignore_dependency
        respond 'ignoring replace dependency due to ignore_dependency setting'
        respond "use '#{$clean_lich_char}e check_dependency' to check the value."
        next
      end
      new_name = "#{script}.#{Time.now.to_i}.bak"
      respond "Renaming existing script #{script} to #{new_name}"
      File.rename("./scripts/#{script}", "./scripts/#{new_name}")
    end

  respond "Downloading all scripts (This may take a few minutes. Please wait until you see \"Finished Install\" before doing anything else"
  $manager.repo_scripts.each(&method(:get_script))
end

def managed_scripts
  local_scripts = Dir['./scripts/*.lic'].map { |item| File.basename(item) }
  $manager.repo_scripts & local_scripts
end

def list_autostarts
  $manager.autostarts
end

def autostart(script_names, global = true)
  script_names = [script_names] unless script_names.is_a?(Array)
  script_names.map!(&method(:format_name))
  if global
    script_names.each { |script| $manager.add_global_auto(script) }
  else
    script_names.each { |script| UserVars.autostart_scripts.push(script) unless UserVars.autostart_scripts.include?(script) }
  end
  script_names.each { |script| $manager.run_script(script) }
end

def stop_autostart(script_names)
  script_names = [script_names] unless script_names.is_a?(Array)

  script_names.each do |script|
    if UserVars.autostart_scripts.include?(script)
      UserVars.autostart_scripts.delete(script)
    else
      $manager.remove_global_auto(script)
    end
  end
end

def set_dev_mode
  echo "Now turning dev mode on"
  $manager.developer = true
  echo "Developer mode now set to: #{$manager.developer}"
end

def unset_dev_mode
  echo "Now turning dev mode off"
  $manager.developer = false
  echo "Developer mode now set to: #{$manager.developer}"
end

def check_dev_mode
  echo "Developer mode set to: #{$manager.developer}"
end

def toggle_developer_mode
  echo "THIS METHOD IS NO LONGER USED. USE '#{$clean_lich_char}e set_dev_mode' and '#{$clean_lich_char}e unset_dev_mode'."
end

def ignore_dependency
  echo "Now ignoring dependency updates"
  $manager.ignore_dependency = true
  echo "ignore_dependency now set to: #{$manager.ignore_dependency}"
end

def unignore_dependency
  echo "Now processing dependency updates"
  $manager.ignore_dependency = false
  echo "ignore_dependency now set to: #{$manager.ignore_dependency}"
end

def check_dependency
  echo "ignore_dependency is set to: #{$manager.ignore_dependency}"
  echo "Use '#{$clean_lich_char}e ignore_dependency' and '#{$clean_lich_char}e unignore_dependency' to change."
end

def use_lich_fork
  echo 'Now switching onto the DR lich fork...'
  start_script('repository', ['unset-lich-updatable'])
  pause 1 while Script.running?('repository')
  echo 'Turning off updates from main lich branch on go2...'
  start_script('repository', ['unset-updatable', 'go2'])
  $manager.queue_lich
end

def use_lich_main
  echo 'Now switching onto the lich mainline...'
  start_script('repository', ['set-lich-updatable'])
  pause 1 while Script.running?('repository')

  echo 'Turning updates from main lich branch on go2 back on...'
  start_script('repository', ['set-updatable', 'go2'])
  pause 1 while Script.running?('repository')

  start_script('repository', ['download-lich'])
  pause
  pause 1 while Script.running?('repository')
  echo('New version of lich installed, please restart Lich.')
end

def toggle_lich_fork
  echo "THIS METHOD IS NO LONGER USED. USE #{$clean_lich_char}e use_lich_fork and #{$clean_lich_char}e use_lich_main"
end

def set_custom_status_repo(repo, branch='master')
  $manager.set_custom_status_repo(repo,branch)
end

def set_custom_status_branch(branch)
  $manager.set_custom_status_branch(branch)
end

def unset_custom_status
  $manager.unset_custom_status
end

def check_custom_status
  echo $manager.check_custom_status
end

def setup_profiles
  $manager.setup_profiles
end

def setup_data
  $manager.setup_data
end

def supported_ruby_version?
  return Gem::Version.new(RUBY_VERSION) >= Gem::Version.new($MIN_RUBY_VERSION)
end

def validate_supported_ruby_version
  # Get stored time for next check (or now if not stored yet)
  next_check_datetime = CharSettings['next_ruby_version_check_datetime'] || Time.now

  # Don't spam user every iteration of run_queue
  return if next_check_datetime > Time.now

  #Check for supported version
  if !supported_ruby_version?
    echo "*** WARN WARN WARN WARN WARN WARN WARN ***"
    echo "WARN: You are using an unsupported version of ruby."
    echo "WARN: While many scripts may still continue to run, there are some that may not."
    echo "WARN: Please update to at least version #{$MIN_RUBY_VERSION} as soon as possible."
    echo "WARN: For further details / assistance, please join the dr-scripts Lich Discord: https://discord.gg/uxZWxuX."
    echo "WARN: This warning will repeat on startup and every three hours."
    echo "*** WARN WARN WARN WARN WARN WARN WARN ***"
  end

  # Set next check time to 3 hours from now
  CharSettings['next_ruby_version_check_datetime'] = Time.now + (60 * 60 * 3)
end

def remove_from_autostart(scripts)
  return if Script.running?('autostart')
  scripts.each do |script|
    start_script('autostart', ['remove', '--global', File.basename(script, '.*')])
    pause 0.1 while Script.running?('autostart')
    start_script('autostart', ['remove', File.basename(script, '.*')])
    pause 0.1 while Script.running?('autostart')
  end
end

def add_self_to_autostart
  return if Script.running?('autostart')
  start_script('autostart', ['add', '--global', 'dependency'])
  pause while Script.running?('autostart')
end

def update_d
  echo('Restarting Dependency in 2 seconds...')
  force_start_script('bootstrap', ['wipe_constants'])
  before_dying do
    sleep 2
    force_start_script('dependency')
  end
  stop_script('drinfomon') if Script.running?('drinfomon')
  stop_script('dependency')
end

def help_me(user = nil)
  result = $manager.submit_help_pastebin
  if result.include?('Bad API request')
    echo(result)
    return
  end
  if user
    LNet.send_message({ 'type' => 'private', 'to' => user }, result)
    echo("Attempted to PM YAML link on lnet to #{user}.  Check lnet window for success or failure.")
  else
    LNet.send_message({ 'type' => 'channel' }, result)
    echo('YAML link sent to lnet.  Check lnet window.')
  end
end

def submit_thieving_update(id, update)
  $manager.queue_thieving_update(id, update)
end

def submit_shop_data(shop_data)
  $manager.queue_shop_update(shop_data)
end

def get_all_moon_data
  $moon_watch ? $moon_watch.moon_data : nil
end

def update_moon_data(moon, data)
  $moon_watch.queue_update(moon, data)
end

def shift_hometown(town_name)
  $HOMETOWN = town_name
end

def clear_hometown
  $HOMETOWN = nil
end

def warn_custom_scripts
  custom_scripts = Dir.entries('./scripts/custom').reject { |f| File.directory?(f) }
  curated_scripts = Dir.entries('./scripts').reject { |f| File.directory?(f) }
  include_list = []

  custom_scripts.each do | script |
    include_list.push(script) if curated_scripts.include?(script)
  end

  unless include_list.empty?
    echo "NOTE: The following curated scripts are in your custom folder and will not receive updates"
    echo "#{include_list}" unless include_list.empty?
  end
end

full_install if install

force_start_script('bootstrap', ['wipe_constants'])

# Proactively starting DRinfomon as script zero to prevent
# race conditions involving this script which so many other
# scripts depend on, and which is slow to start on its own
echo("Starting DRinfomon, this will take a few seconds.")
custom_require.call('drinfomon')
echo("DRinfomon ready.")

$manager.check_base_files
$manager.check_data_files
$manager.start_scripts

if $manager.updated_dependency?
  echo('Update found for dependency.lic')
  update_d
end

before_dying do
  $moon_watch = nil
  stop_script('drinfomon') if Script.running?('drinfomon')
end

$setupfiles.reload

# Remind user of curated scripts with a copy in custom folder
warn_custom_scripts

loop do
  if $turn_on_moon_watch && $moon_watch.nil?
    $moon_watch = MoonWatch.new(debug)
    $turn_on_moon_watch = nil
  end

  $manager.run_queue
  $bankbot.run_queue
  $reportbot.run_queue
  $slackbot.run_queue
  $moon_watch.run_queue if $moon_watch
  clear
  pause 0.1
end
